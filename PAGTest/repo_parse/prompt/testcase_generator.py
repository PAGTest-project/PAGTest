FIX_PROMPT_JAVA = """
## Task
You are a Java testing and debugging expert. Your task is to fix the provided Java code ("code_to_fix") for a test case ("Testcase A") that was generated by `Last Round`. The provided code may have issues that need to be resolved, as indicated by the provided error messages ("error_message"). Your goal is to correct these issues while preserving the original structure and intent of the code.

## Context
The `Last Round` generated unit tests ("Testcase A") for "Method A" based on the provided "Method A" code and the test case information ("Testcase B") of another code ("Method B") that has some relationship with "Method A."
- **Method A**: The method for which "Testcase A" was generated. It defines the main logic that the test case is meant to verify.
- **Testcase A**: The generated unit test for "Method A" that contains issues.
- **Error Message**: The error message that describes the issues in "Testcase A."
- **Enhancement Information**: Additional enhancement information may be provided to help you improve the test cases.
- **Fixing Priority**: Correctness > Preservation of the original intent and structure > Consistency of style.

## Requirements
1. **Analyze the Errors**: Use the provided "error_message" to identify what needs to be fixed in "Testcase A." Think step by step about the possible causes of the error and how it relates to the code. For example, consider if there are unhandled exceptions, incorrect method calls, uncorrect asserts or missing imports. A test file may contain multiple test cases, and each test case may have a different error type. You need to identify the test case corresponding to each error and the error type of the test case, and then fix each test case accordingly.
2. **Fix the Code**: Correct the code in "Testcase A" while maintaining the original intent and structure as much as possible. Ensure the test case is correct, syntactically valid, and runnable.
3. **Choose**: If the code you need to fix is inherently flawed and difficult to repair, or if there are alternative solutions that can make it work, you can consider adopting a different approach.
4. **Maintain Consistency**: Use the same style and naming conventions as the existing test cases in the project to keep the codebase consistent.
5. **Output**: Only provide the fixed Java code without any explanations.

## Input
- **Code to Fix**: {code_to_fix}
- **Error Message**: {error_message}
- **Enhancement Information**: {enhancement_information}

## Important Notes
- Ensure that the fixed code is syntactically correct and runnable.
- Retain the structure and intent of the original test case as much as possible.
- Avoid adding new test cases if possible, try to make fixes based on the original ones.
- Only return the fixed Java code, without any explanations.
"""

FALLBACK_PROMPT_JAVA = """
## Task
You are a testing expert. Your task is to generate straightforward unit tests ("Testcase A") for "Method A" based on the provided "Method A" code. 
The task given by the boss is to see who can cover all code paths of Method A with the fewest and simplest test cases (only cover Method A, don't worry about anything else!).
Your goal is to cover all code paths of "Method A" with the fewest possible test cases. The fewer, the better. You don't need to cover all features, just cover all code paths.

## Generation Steps
1. **Given**: Identify necessary inputs and dependencies for "Method A."
2. **When**: Determine when to invoke "Method A," considering any prerequisites.
3. **Then**: Construct assertions to validate "Method A," focusing on correctness and simplicity.

## Example2
### Input
1. **Method A**: `urlEncode`
2. **Description**: The `urlEncode` method encodes a string for safe URL transmission using `URLEncoder.encode`.

```java
public static String urlEncode(String s) {
    try {
        return URLEncoder.encode(s, StandardCharsets.UTF_8.name());
    } catch (UnsupportedEncodingException e) {
        throw new RuntimeException(StandardCharsets.UTF_8.name() + " is unsupported", e);
    }
}
### Desired Output
Generate unit tests for urlEncode that only cover:
- Successful encoding of a standard input string.
- Handling exceptions when URLEncoder.encode fails.
Focus only on the specific cases for urlEncode and avoid unnecessary complexity by not covering all scenarios related to URLEncoder.encode. 
Since this method is a simple wrapper, we only need to test its normal and exceptional cases. URLEncoder.encode will be covered in its own unit tests.

## Notes
- Your output must be syntactically correct and runnable Java code, and you should only output Java code without any explanations.
- Prioritize simplicity while maintaining correctness.
- The generated test cases should focus only on covering the essential lines and branches of "Method A.". Under the condition that the line coverage meets the standard, generate as few test cases as possible. If one test case can achieve 100% line coverage, do not generate more.
- Don't forget the `package` statement, and use the same package name as the class where target method is located.
- Don't forget to import necessary dependencies.
- Do not introduce unrelated variables, such as logger, etc.
- Use mocks only when appropriate and do not abuse them.
- Handle exceptions correctly, pay attention to the types of exceptions and how they are handled.
- If a single Testcase can cover the code path of the target method, then there is no need to generate additional Testcases!!!
"""

CLASS_LEVEL_PROMPT_JAVA = """
## Task
You are a testing expert, and your task is to generate unit tests ("Testcase A") for "Method A" based on the provided "Method A" code and the test case information ("Testcase B") of another code ("Method B") that has some relationship with "Method A."

## Motivation
Starting from scratch to generate unit tests for a method can be challenging. When you have a piece of code, it can be difficult to generate test cases directly, as itâ€™s hard to ensure the accuracy of the test assertions. The generated test cases can also vary greatly. However, if we can leverage existing test information from the project, we can match the target code with related unit tests from which to draw references, thereby generating unit tests that better align with the target code.

## How do we define such relationships?
Traditional RAG (Retrieval Augmented Generation) methods typically retrieve the most similar code as the context for the target method. However, we believe that relevance is not limited to similarity alone; it can also include other relationships. RAG can be expanded to include content that is relevant in some way as context.

Within the scope of a class, the following relationships can exist, but are not limited to:
- **Functional Similarity or Opposition**: Two methods in a class may be functionally similar (e.g., both are data processing methods) or opposite (e.g., one method performs an action, and another method undoes that action). This functional relationship can be used as a reference when generating test cases.
- **Structural Similarity**: Different methods in a class may share similar structures or logical patterns, such as relying on the same input validation steps or involving loop processing. This similarity can help in reusing existing method test logic when generating new test cases.
- **Dependency**: The behavior of one method may depend on other methods within the same class. For example, `Method A` may rely on the output of `Method B`.

Given the target method and its containing class, as well as relevant information that can help generate unit tests for the target method, you should analyze how to generate test cases by following these steps:
- **Given**: Identify input patterns, object initialization, or dependencies to prepare appropriate inputs for the target method.
- **When**: Determine the timing of invoking the target method, including any other methods that need to be executed before or after to ensure the correct state.
- **Then**: Analyze the output, behavior, side effects, or exception handling to construct assertions for the target method, ensuring the validity and accuracy of the tests.

## Example
### Input
1. **Method A**: `processPayment`
2. **Method B** Description: The `validatePaymentInfo` method is used to verify the correctness of payment information, including credit card number, expiration date, and security code validation. `processPayment` relies on the result of `validatePaymentInfo` before processing the payment.
3. **Testcase B**: Test cases for the `validatePaymentInfo` method.

```java
// Method A
public String processPayment(PaymentInfo paymentInfo) {
    if (validatePaymentInfo(paymentInfo)) {
        // Perform payment logic
        return "Payment processed";
    } else {
        return "Payment validation failed";
    }
}

// Method B
public boolean validatePaymentInfo(PaymentInfo paymentInfo) {
    // Validate the correctness of the payment information
    if (isValidCardNumber(paymentInfo.getCardNumber()) && 
        isValidExpiry(paymentInfo.getExpiryDate()) && 
        isValidSecurityCode(paymentInfo.getSecurityCode())) {
        return true;
    }
    return false;
}

// Testcase B
public void testValidatePaymentInfoValid() {
    PaymentInfo paymentInfo = new PaymentInfo("1234567890123456", "12/23", "123");
    assertTrue(validatePaymentInfo(paymentInfo));
}

public void testValidatePaymentInfoInvalidCard() {
    PaymentInfo paymentInfo = new PaymentInfo("1111111111111111", "12/23", "123");
    assertFalse(validatePaymentInfo(paymentInfo));
}
```

## Output
```java
package com.example;
import org.junit.Before;
import org.junit.Test;
import static org.junit.Assert.*;

public class PaymentProcessorTest {
    private PaymentProcessor paymentProcessor;

    @Before
    public void setUp() {
        paymentProcessor = new PaymentProcessor();
    }

    @Test
    public void testProcessPaymentSuccess() {
        // Simulate valid payment information
        PaymentInfo paymentInfo = new PaymentInfo("1234567890123456", "12/23", "123");
        String result = paymentProcessor.processPayment(paymentInfo);
        assertEquals("Payment processed", result);
    }

    @Test
    public void testProcessPaymentValidationFailed() {
        // Simulate invalid payment information
        PaymentInfo paymentInfo = new PaymentInfo("1111111111111111", "12/23", "123");
        String result = paymentProcessor.processPayment(paymentInfo);
        assertEquals("Payment validation failed", result);
    }
}
```

## Notes
- Your output must be syntactically correct and runnable Java code, and you should only output Java code without any explanations.
- The priority for the generated "Testcase A" is: correctness > consistency of style > simplicity.
- Use existing variables or functions in the project as much as possible to maintain consistency with the original test cases.
- Use the same style and naming conventions as the existing test cases in the project.
- If the relevance information is insufficient, generate basic test cases.
- Don't forget the `package` statement, and use the same package name as the class where target method is located.
- Don't forget to import necessary dependencies, such as the methods or classes being tested.
- If the tested method may throw a checked exception, remember to either catch the exception or declare it in the method signature.
"""