[{"uris": "src/test/java/io/cucumber/cucumberexpressions/ExpressionFactoryTest.java.ExpressionFactoryTest.[void]assertRegularExpression(String)", "name": "assertRegularExpression", "arg_nums": 1, "params": [{"name": "expressionString", "type": "String"}], "return_type": "void", "signature": "private void assertRegularExpression(String expressionString)", "original_string": "    private void assertRegularExpression(String expressionString) {\n        assertRegularExpression(expressionString, expressionString);\n    }", "default_arguments": null, "file": "src/test/java/io/cucumber/cucumberexpressions/ExpressionFactoryTest.java", "class_name": "ExpressionFactoryTest", "class_uri": "src/test/java/io/cucumber/cucumberexpressions/ExpressionFactoryTest.java.ExpressionFactoryTest", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/io/cucumber/cucumberexpressions/ExpressionFactoryTest.java.ExpressionFactoryTest.[void]assertRegularExpression(String,String)", "name": "assertRegularExpression", "arg_nums": 2, "params": [{"name": "expectedSource", "type": "String"}, {"name": "expressionString", "type": "String"}], "return_type": "void", "signature": "private void assertRegularExpression(String expectedSource, String expressionString)", "original_string": "    private void assertRegularExpression(String expectedSource, String expressionString) {\n        assertExpression(RegularExpression.class, expectedSource, expressionString);\n    }", "default_arguments": null, "file": "src/test/java/io/cucumber/cucumberexpressions/ExpressionFactoryTest.java", "class_name": "ExpressionFactoryTest", "class_uri": "src/test/java/io/cucumber/cucumberexpressions/ExpressionFactoryTest.java.ExpressionFactoryTest", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/io/cucumber/cucumberexpressions/ExpressionFactoryTest.java.ExpressionFactoryTest.[void]assertCucumberExpression(String)", "name": "assertCucumberExpression", "arg_nums": 1, "params": [{"name": "expressionString", "type": "String"}], "return_type": "void", "signature": "private void assertCucumberExpression(String expressionString)", "original_string": "    private void assertCucumberExpression(String expressionString) {\n        assertExpression(CucumberExpression.class, expressionString, expressionString);\n    }", "default_arguments": null, "file": "src/test/java/io/cucumber/cucumberexpressions/ExpressionFactoryTest.java", "class_name": "ExpressionFactoryTest", "class_uri": "src/test/java/io/cucumber/cucumberexpressions/ExpressionFactoryTest.java.ExpressionFactoryTest", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/io/cucumber/cucumberexpressions/ExpressionFactoryTest.java.ExpressionFactoryTest.[void]assertExpression(Class<? extends Expression>,String,String)", "name": "assertExpression", "arg_nums": 3, "params": [{"name": "expectedClass", "type": "Class<? extends Expression>"}, {"name": "expectedSource", "type": "String"}, {"name": "expressionString", "type": "String"}], "return_type": "void", "signature": "private void assertExpression(Class<? extends Expression> expectedClass, String expectedSource, String expressionString)", "original_string": "    private void assertExpression(Class<? extends Expression> expectedClass, String expectedSource, String expressionString) {\n        Expression expression = createExpression(expressionString);\n        assertEquals(expectedClass, expression.getClass());\n        if (expectedSource != null) {\n            assertEquals(expectedSource, expression.getSource());\n        }\n    }", "default_arguments": null, "file": "src/test/java/io/cucumber/cucumberexpressions/ExpressionFactoryTest.java", "class_name": "ExpressionFactoryTest", "class_uri": "src/test/java/io/cucumber/cucumberexpressions/ExpressionFactoryTest.java.ExpressionFactoryTest", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/io/cucumber/cucumberexpressions/ExpressionFactoryTest.java.ExpressionFactoryTest.[Expression]createExpression(String)", "name": "createExpression", "arg_nums": 1, "params": [{"name": "expressionString", "type": "String"}], "return_type": "Expression", "signature": "private Expression createExpression(String expressionString)", "original_string": "    private Expression createExpression(String expressionString) {\n        return new ExpressionFactory(new ParameterTypeRegistry(Locale.ENGLISH)).createExpression(expressionString);\n    }", "default_arguments": null, "file": "src/test/java/io/cucumber/cucumberexpressions/ExpressionFactoryTest.java", "class_name": "ExpressionFactoryTest", "class_uri": "src/test/java/io/cucumber/cucumberexpressions/ExpressionFactoryTest.java.ExpressionFactoryTest", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "Expression", "classes": []}, "docstring": ""}, {"uris": "src/test/java/io/cucumber/cucumberexpressions/CucumberExpressionTest.java.CucumberExpressionTest.[List<Path>]acceptance_tests_pass()", "name": "acceptance_tests_pass", "arg_nums": 0, "params": [], "return_type": "List<Path>", "signature": "private static List<Path> acceptance_tests_pass()", "original_string": "    private static List<Path> acceptance_tests_pass() throws IOException {\n        List<Path> paths = new ArrayList<>();\n        newDirectoryStream(Paths.get(\"..\", \"testdata\", \"cucumber-expression\", \"matching\")).forEach(paths::add);\n        paths.sort(Comparator.naturalOrder());\n        return paths;\n    }", "default_arguments": null, "file": "src/test/java/io/cucumber/cucumberexpressions/CucumberExpressionTest.java", "class_name": "CucumberExpressionTest", "class_uri": "src/test/java/io/cucumber/cucumberexpressions/CucumberExpressionTest.java.CucumberExpressionTest", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "List<Path>", "classes": []}, "docstring": ""}, {"uris": "src/test/java/io/cucumber/cucumberexpressions/CucumberExpressionTest.java.CucumberExpressionTest.[List<?>]match(String,String)", "name": "match", "arg_nums": 2, "params": [{"name": "expr", "type": "String"}, {"name": "text", "type": "String"}], "return_type": "List<?>", "signature": "private List<?> match(String expr, String text, Type... typeHints)", "original_string": "    private List<?> match(String expr, String text, Type... typeHints) {\n        return match(expr, text, parameterTypeRegistry, typeHints);\n    }", "default_arguments": null, "file": "src/test/java/io/cucumber/cucumberexpressions/CucumberExpressionTest.java", "class_name": "CucumberExpressionTest", "class_uri": "src/test/java/io/cucumber/cucumberexpressions/CucumberExpressionTest.java.CucumberExpressionTest", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "List<?>", "classes": []}, "docstring": ""}, {"uris": "src/test/java/io/cucumber/cucumberexpressions/CucumberExpressionTest.java.CucumberExpressionTest.[List<?>]match(String,String,Locale)", "name": "match", "arg_nums": 3, "params": [{"name": "expr", "type": "String"}, {"name": "text", "type": "String"}, {"name": "locale", "type": "Locale"}], "return_type": "List<?>", "signature": "private List<?> match(String expr, String text, Locale locale, Type... typeHints)", "original_string": "    private List<?> match(String expr, String text, Locale locale, Type... typeHints) {\n        ParameterTypeRegistry parameterTypeRegistry = new ParameterTypeRegistry(locale);\n        return match(expr, text, parameterTypeRegistry, typeHints);\n    }", "default_arguments": null, "file": "src/test/java/io/cucumber/cucumberexpressions/CucumberExpressionTest.java", "class_name": "CucumberExpressionTest", "class_uri": "src/test/java/io/cucumber/cucumberexpressions/CucumberExpressionTest.java.CucumberExpressionTest", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "List<?>", "classes": []}, "docstring": ""}, {"uris": "src/test/java/io/cucumber/cucumberexpressions/CucumberExpressionTest.java.CucumberExpressionTest.[List<?>]match(String,String,ParameterTypeRegistry)", "name": "match", "arg_nums": 3, "params": [{"name": "expr", "type": "String"}, {"name": "text", "type": "String"}, {"name": "parameterTypeRegistry", "type": "ParameterTypeRegistry"}], "return_type": "List<?>", "signature": "private List<?> match(String expr, String text, ParameterTypeRegistry parameterTypeRegistry, Type... typeHints)", "original_string": "    private List<?> match(String expr, String text, ParameterTypeRegistry parameterTypeRegistry, Type... typeHints) {\n        CucumberExpression expression = new CucumberExpression(expr, parameterTypeRegistry);\n        List<Argument<?>> args = expression.match(text, typeHints);\n        if (args == null) {\n            return null;\n        } else {\n            List<Object> list = new ArrayList<>();\n            for (Argument<?> arg : args) {\n                Object value = arg.getValue();\n                list.add(value);\n            }\n            return list;\n        }\n    }", "default_arguments": null, "file": "src/test/java/io/cucumber/cucumberexpressions/CucumberExpressionTest.java", "class_name": "CucumberExpressionTest", "class_uri": "src/test/java/io/cucumber/cucumberexpressions/CucumberExpressionTest.java.CucumberExpressionTest", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "List<?>", "classes": []}, "docstring": ""}, {"uris": "src/test/java/io/cucumber/cucumberexpressions/KeyboardFriendlyDecimalFormatSymbolsTest.java.KeyboardFriendlyDecimalFormatSymbolsTest.[void]listMinusSigns(Function<Locale, DecimalFormatSymbols>)", "name": "listMinusSigns", "arg_nums": 1, "params": [{"name": "supplier", "type": "Function<Locale, DecimalFormatSymbols>"}], "return_type": "void", "signature": "private static void listMinusSigns(Function<Locale, DecimalFormatSymbols> supplier)", "original_string": "    private static void listMinusSigns(Function<Locale, DecimalFormatSymbols> supplier) {\n        getAvailableLocalesAsStream()\n                .collect(groupingBy(locale -> supplier.apply(locale).getMinusSign()))\n                .forEach((c, locales) -> System.out.println(render(c) + \" \" + render(locales)));\n    }", "default_arguments": null, "file": "src/test/java/io/cucumber/cucumberexpressions/KeyboardFriendlyDecimalFormatSymbolsTest.java", "class_name": "KeyboardFriendlyDecimalFormatSymbolsTest", "class_uri": "src/test/java/io/cucumber/cucumberexpressions/KeyboardFriendlyDecimalFormatSymbolsTest.java.KeyboardFriendlyDecimalFormatSymbolsTest", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/io/cucumber/cucumberexpressions/KeyboardFriendlyDecimalFormatSymbolsTest.java.KeyboardFriendlyDecimalFormatSymbolsTest.[void]listDecimalAndGroupingSeparators(Function<Locale, DecimalFormatSymbols>)", "name": "listDecimalAndGroupingSeparators", "arg_nums": 1, "params": [{"name": "supplier", "type": "Function<Locale, DecimalFormatSymbols>"}], "return_type": "void", "signature": "private static void listDecimalAndGroupingSeparators(Function<Locale, DecimalFormatSymbols> supplier)", "original_string": "    private static void listDecimalAndGroupingSeparators(Function<Locale, DecimalFormatSymbols> supplier) {\n        getAvailableLocalesAsStream()\n                .collect(groupingBy(locale -> {\n                    DecimalFormatSymbols symbols = supplier.apply(locale);\n                    return new SimpleEntry<>(symbols.getDecimalSeparator(), symbols.getGroupingSeparator());\n                }))\n                .entrySet()\n                .stream()\n                .sorted(comparing(entry -> entry.getKey().getKey()))\n                .forEach((entry) -> {\n                    SimpleEntry<Character, Character> characters = entry.getKey();\n                    List<Locale> locales = entry.getValue();\n                    System.out.println(render(characters.getKey()) + \" \" + render(characters.getValue()) + \" \" + render(locales));\n                });\n    }", "default_arguments": null, "file": "src/test/java/io/cucumber/cucumberexpressions/KeyboardFriendlyDecimalFormatSymbolsTest.java", "class_name": "KeyboardFriendlyDecimalFormatSymbolsTest", "class_uri": "src/test/java/io/cucumber/cucumberexpressions/KeyboardFriendlyDecimalFormatSymbolsTest.java.KeyboardFriendlyDecimalFormatSymbolsTest", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/io/cucumber/cucumberexpressions/KeyboardFriendlyDecimalFormatSymbolsTest.java.KeyboardFriendlyDecimalFormatSymbolsTest.[void]listExponentSigns(Function<Locale, DecimalFormatSymbols>)", "name": "listExponentSigns", "arg_nums": 1, "params": [{"name": "supplier", "type": "Function<Locale, DecimalFormatSymbols>"}], "return_type": "void", "signature": "private static void listExponentSigns(Function<Locale, DecimalFormatSymbols> supplier)", "original_string": "    private static void listExponentSigns(Function<Locale, DecimalFormatSymbols> supplier) {\n        getAvailableLocalesAsStream()\n                .collect(groupingBy(locale -> supplier.apply(locale).getExponentSeparator()))\n                .forEach((s, locales) -> {\n                    if (s.length() == 1) {\n                        System.out.println(render(s.charAt(0)) + \" \" + render(locales));\n                    } else {\n                        System.out.println(s + \" \" + render(locales));\n                    }\n                });\n    }", "default_arguments": null, "file": "src/test/java/io/cucumber/cucumberexpressions/KeyboardFriendlyDecimalFormatSymbolsTest.java", "class_name": "KeyboardFriendlyDecimalFormatSymbolsTest", "class_uri": "src/test/java/io/cucumber/cucumberexpressions/KeyboardFriendlyDecimalFormatSymbolsTest.java.KeyboardFriendlyDecimalFormatSymbolsTest", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/io/cucumber/cucumberexpressions/KeyboardFriendlyDecimalFormatSymbolsTest.java.KeyboardFriendlyDecimalFormatSymbolsTest.[Stream<Locale>]getAvailableLocalesAsStream()", "name": "getAvailableLocalesAsStream", "arg_nums": 0, "params": [], "return_type": "Stream<Locale>", "signature": "private static Stream<Locale> getAvailableLocalesAsStream()", "original_string": "    private static Stream<Locale> getAvailableLocalesAsStream() {\n        return Arrays.stream(DecimalFormatSymbols.getAvailableLocales());\n    }", "default_arguments": null, "file": "src/test/java/io/cucumber/cucumberexpressions/KeyboardFriendlyDecimalFormatSymbolsTest.java", "class_name": "KeyboardFriendlyDecimalFormatSymbolsTest", "class_uri": "src/test/java/io/cucumber/cucumberexpressions/KeyboardFriendlyDecimalFormatSymbolsTest.java.KeyboardFriendlyDecimalFormatSymbolsTest", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "Stream<Locale>", "classes": []}, "docstring": ""}, {"uris": "src/test/java/io/cucumber/cucumberexpressions/KeyboardFriendlyDecimalFormatSymbolsTest.java.KeyboardFriendlyDecimalFormatSymbolsTest.[String]render(Character)", "name": "render", "arg_nums": 1, "params": [{"name": "character", "type": "Character"}], "return_type": "String", "signature": "private static String render(Character character)", "original_string": "    private static String render(Character character) {\n        return character + \" (\" + (int) character + \")\";\n    }", "default_arguments": null, "file": "src/test/java/io/cucumber/cucumberexpressions/KeyboardFriendlyDecimalFormatSymbolsTest.java", "class_name": "KeyboardFriendlyDecimalFormatSymbolsTest", "class_uri": "src/test/java/io/cucumber/cucumberexpressions/KeyboardFriendlyDecimalFormatSymbolsTest.java.KeyboardFriendlyDecimalFormatSymbolsTest", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "String", "classes": []}, "docstring": ""}, {"uris": "src/test/java/io/cucumber/cucumberexpressions/KeyboardFriendlyDecimalFormatSymbolsTest.java.KeyboardFriendlyDecimalFormatSymbolsTest.[String]render(List<Locale>)", "name": "render", "arg_nums": 1, "params": [{"name": "locales", "type": "List<Locale>"}], "return_type": "String", "signature": "private static String render(List<Locale> locales)", "original_string": "    private static String render(List<Locale> locales) {\n        return locales.size() + \": \" + locales.stream()\n                .sorted(comparing(Locale::getDisplayName))\n                .map(Locale::getDisplayName)\n                .collect(toList());\n    }", "default_arguments": null, "file": "src/test/java/io/cucumber/cucumberexpressions/KeyboardFriendlyDecimalFormatSymbolsTest.java", "class_name": "KeyboardFriendlyDecimalFormatSymbolsTest", "class_uri": "src/test/java/io/cucumber/cucumberexpressions/KeyboardFriendlyDecimalFormatSymbolsTest.java.KeyboardFriendlyDecimalFormatSymbolsTest", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "String", "classes": []}, "docstring": ""}, {"uris": "src/test/java/io/cucumber/cucumberexpressions/CucumberExpressionGeneratorTest.java.CucumberExpressionGeneratorTest.[void]assertExpression(String,List<String>,String)", "name": "assertExpression", "arg_nums": 3, "params": [{"name": "expectedExpression", "type": "String"}, {"name": "expectedArgumentNames", "type": "List<String>"}, {"name": "text", "type": "String"}], "return_type": "void", "signature": "private void assertExpression(String expectedExpression, List<String> expectedArgumentNames, String text)", "original_string": "    private void assertExpression(String expectedExpression, List<String> expectedArgumentNames, String text) {\n        GeneratedExpression generatedExpression = generator.generateExpressions(text).get(0);\n        assertEquals(expectedExpression, generatedExpression.getSource());\n        assertEquals(expectedArgumentNames, generatedExpression.getParameterNames());\n\n        // Check that the generated expression matches the text\n        CucumberExpression cucumberExpression = new CucumberExpression(generatedExpression.getSource(), parameterTypeRegistry);\n        List<Argument<?>> match = cucumberExpression.match(text);\n        if (match == null) {\n            fail(String.format(\"Expected text '%s' to match generated expression '%s'\", text, generatedExpression.getSource()));\n        }\n        assertEquals(expectedArgumentNames.size(), match.size());\n    }", "default_arguments": null, "file": "src/test/java/io/cucumber/cucumberexpressions/CucumberExpressionGeneratorTest.java", "class_name": "CucumberExpressionGeneratorTest", "class_uri": "src/test/java/io/cucumber/cucumberexpressions/CucumberExpressionGeneratorTest.java.CucumberExpressionGeneratorTest", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/io/cucumber/cucumberexpressions/ParameterTypeRegistry_setDefaultParameterTransformerTest.java.ParameterTypeRegistry_setDefaultParameterTransformerTest.[void]setUp()", "name": "setUp", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@BeforeEach\n    public void setUp()", "original_string": "    @BeforeEach\n    public void setUp() {\n        parameterTypeRegistry = new ParameterTypeRegistry(Locale.ENGLISH);\n        mockTransformer = new ParameterByTypeTransformer() {\n            @Override\n            public Object transform(String fromValue, Type toValueType) {\n                return null;\n            }\n        };\n    }", "default_arguments": null, "file": "src/test/java/io/cucumber/cucumberexpressions/ParameterTypeRegistry_setDefaultParameterTransformerTest.java", "class_name": "ParameterTypeRegistry_setDefaultParameterTransformerTest", "class_uri": "src/test/java/io/cucumber/cucumberexpressions/ParameterTypeRegistry_setDefaultParameterTransformerTest.java.ParameterTypeRegistry_setDefaultParameterTransformerTest", "attributes": {"modifiers": "@BeforeEach\n    public", "marker_annotations": ["@BeforeEach"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/io/cucumber/cucumberexpressions/CustomParameterTypeTest.java.CustomParameterTypeTest.[void]create_parameter()", "name": "create_parameter", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@BeforeEach\n    public void create_parameter()", "original_string": "    @BeforeEach\n    public void create_parameter() {\n        parameterTypeRegistry.defineParameterType(new ParameterType<>(\n                \"color\",                                  // name\n                \"red|blue|yellow\",                        // regexp\n                Color.class,                              // type\n                Color::new,                               // transform\n                false,                                    // useForSnippets\n                false                                     // preferForRegexpMatch\n        ));\n    }", "default_arguments": null, "file": "src/test/java/io/cucumber/cucumberexpressions/CustomParameterTypeTest.java", "class_name": "CustomParameterTypeTest", "class_uri": "src/test/java/io/cucumber/cucumberexpressions/CustomParameterTypeTest.java.CustomParameterTypeTest", "attributes": {"modifiers": "@BeforeEach\n    public", "marker_annotations": ["@BeforeEach"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/io/cucumber/cucumberexpressions/CucumberExpressionTransformationTest.java.CucumberExpressionTransformationTest.[List<Path>]acceptance_tests_pass()", "name": "acceptance_tests_pass", "arg_nums": 0, "params": [], "return_type": "List<Path>", "signature": "private static List<Path> acceptance_tests_pass()", "original_string": "    private static List<Path> acceptance_tests_pass() throws IOException {\n        List<Path> paths = new ArrayList<>();\n        newDirectoryStream(Paths.get(\"..\", \"testdata\", \"cucumber-expression\", \"transformation\")).forEach(paths::add);\n        paths.sort(Comparator.naturalOrder());\n        return paths;\n    }", "default_arguments": null, "file": "src/test/java/io/cucumber/cucumberexpressions/CucumberExpressionTransformationTest.java", "class_name": "CucumberExpressionTransformationTest", "class_uri": "src/test/java/io/cucumber/cucumberexpressions/CucumberExpressionTransformationTest.java.CucumberExpressionTransformationTest", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "List<Path>", "classes": []}, "docstring": ""}, {"uris": "src/test/java/io/cucumber/cucumberexpressions/CucumberExpression_getRegexpTest.java.CucumberExpression_getRegexpTest.[void]setUp()", "name": "setUp", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@BeforeEach\n    public void setUp()", "original_string": "    @BeforeEach\n    public void setUp() {\n        parameterTypeRegistry = new ParameterTypeRegistry(Locale.ENGLISH);\n    }", "default_arguments": null, "file": "src/test/java/io/cucumber/cucumberexpressions/CucumberExpression_getRegexpTest.java", "class_name": "CucumberExpression_getRegexpTest", "class_uri": "src/test/java/io/cucumber/cucumberexpressions/CucumberExpression_getRegexpTest.java.CucumberExpression_getRegexpTest", "attributes": {"modifiers": "@BeforeEach\n    public", "marker_annotations": ["@BeforeEach"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/io/cucumber/cucumberexpressions/PatternCompilerProviderTest.java.PatternCompilerProviderTest.[void]setUp()", "name": "setUp", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@BeforeEach\n    public void setUp()", "original_string": "    @BeforeEach\n    public void setUp() {\n        PatternCompilerProvider.service = null;\n    }", "default_arguments": null, "file": "src/test/java/io/cucumber/cucumberexpressions/PatternCompilerProviderTest.java", "class_name": "PatternCompilerProviderTest", "class_uri": "src/test/java/io/cucumber/cucumberexpressions/PatternCompilerProviderTest.java.PatternCompilerProviderTest", "attributes": {"modifiers": "@BeforeEach\n    public", "marker_annotations": ["@BeforeEach"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/io/cucumber/cucumberexpressions/PatternCompilerProviderTest.java.PatternCompilerProviderTest.[void]tearDown()", "name": "tearDown", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@AfterEach\n    public void tearDown()", "original_string": "    @AfterEach\n    public void tearDown() {\n        PatternCompilerProvider.service = null;\n    }", "default_arguments": null, "file": "src/test/java/io/cucumber/cucumberexpressions/PatternCompilerProviderTest.java", "class_name": "PatternCompilerProviderTest", "class_uri": "src/test/java/io/cucumber/cucumberexpressions/PatternCompilerProviderTest.java.PatternCompilerProviderTest", "attributes": {"modifiers": "@AfterEach\n    public", "marker_annotations": ["@AfterEach"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/io/cucumber/cucumberexpressions/PatternCompilerProviderTest.java.PatternCompilerProviderTest.[PatternCompiler]getTestCompiler()", "name": "getTestCompiler", "arg_nums": 0, "params": [], "return_type": "PatternCompiler", "signature": "private PatternCompiler getTestCompiler()", "original_string": "    private PatternCompiler getTestCompiler() {\n        return new PatternCompiler() {\n            @Override\n            public Pattern compile(String regexp, int flags) {\n                return null;\n            }\n        };\n    }", "default_arguments": null, "file": "src/test/java/io/cucumber/cucumberexpressions/PatternCompilerProviderTest.java", "class_name": "PatternCompilerProviderTest", "class_uri": "src/test/java/io/cucumber/cucumberexpressions/PatternCompilerProviderTest.java.PatternCompilerProviderTest", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "PatternCompiler", "classes": []}, "docstring": ""}, {"uris": "src/test/java/io/cucumber/cucumberexpressions/CustomMatchers.java.CustomMatchers.[Matcher<Iterable<?>>]equalOrCloseTo(List<?>)", "name": "equalOrCloseTo", "arg_nums": 1, "params": [{"name": "list", "type": "List<?>"}], "return_type": "Matcher<Iterable<?>>", "signature": "public static Matcher<Iterable<?>> equalOrCloseTo(List<?> list)", "original_string": "    public static Matcher<Iterable<?>> equalOrCloseTo(List<?> list) {\n        if (list == null || list.isEmpty()) return equalTo(list);\n        List<Matcher<?>> matchers = list.stream().map(EqualOrCloseTo::new).collect(Collectors.toList());\n        return new IsIterableContainingInOrder(matchers);\n    }", "default_arguments": null, "file": "src/test/java/io/cucumber/cucumberexpressions/CustomMatchers.java", "class_name": "CustomMatchers", "class_uri": "src/test/java/io/cucumber/cucumberexpressions/CustomMatchers.java.CustomMatchers", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Matcher<Iterable<?>>", "classes": []}, "docstring": ""}, {"uris": "src/test/java/io/cucumber/cucumberexpressions/CucumberExpressionParserTest.java.CucumberExpressionParserTest.[List<Path>]acceptance_tests_pass()", "name": "acceptance_tests_pass", "arg_nums": 0, "params": [], "return_type": "List<Path>", "signature": "private static List<Path> acceptance_tests_pass()", "original_string": "    private static List<Path> acceptance_tests_pass() throws IOException {\n        List<Path> paths = new ArrayList<>();\n        newDirectoryStream(Paths.get(\"..\", \"testdata\", \"cucumber-expression\", \"parser\")).forEach(paths::add);\n        paths.sort(Comparator.naturalOrder());\n        return paths;\n    }", "default_arguments": null, "file": "src/test/java/io/cucumber/cucumberexpressions/CucumberExpressionParserTest.java", "class_name": "CucumberExpressionParserTest", "class_uri": "src/test/java/io/cucumber/cucumberexpressions/CucumberExpressionParserTest.java.CucumberExpressionParserTest", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "List<Path>", "classes": []}, "docstring": ""}, {"uris": "src/test/java/io/cucumber/cucumberexpressions/CucumberExpressionTokenizerTest.java.CucumberExpressionTokenizerTest.[List<Path>]acceptance_tests_pass()", "name": "acceptance_tests_pass", "arg_nums": 0, "params": [], "return_type": "List<Path>", "signature": "private static List<Path> acceptance_tests_pass()", "original_string": "    private static List<Path> acceptance_tests_pass() throws IOException {\n        List<Path> paths = new ArrayList<>();\n        newDirectoryStream(Paths.get(\"..\", \"testdata\", \"cucumber-expression\", \"tokenizer\")).forEach(paths::add);\n        paths.sort(Comparator.naturalOrder());\n        return paths;\n    }", "default_arguments": null, "file": "src/test/java/io/cucumber/cucumberexpressions/CucumberExpressionTokenizerTest.java", "class_name": "CucumberExpressionTokenizerTest", "class_uri": "src/test/java/io/cucumber/cucumberexpressions/CucumberExpressionTokenizerTest.java.CucumberExpressionTokenizerTest", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "List<Path>", "classes": []}, "docstring": ""}, {"uris": "src/test/java/io/cucumber/cucumberexpressions/ParameterType_useForSnippetsTest.java.ParameterType_useForSnippetsTest.[void]setUp()", "name": "setUp", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@BeforeEach\n    public void setUp()", "original_string": "    @BeforeEach\n    public void setUp() {\n        parameterType = new ParameterType<>(\"name\", \"regexp\", String.class, (String arg) -> arg, true, false);\n    }", "default_arguments": null, "file": "src/test/java/io/cucumber/cucumberexpressions/ParameterType_useForSnippetsTest.java", "class_name": "ParameterType_useForSnippetsTest", "class_uri": "src/test/java/io/cucumber/cucumberexpressions/ParameterType_useForSnippetsTest.java.ParameterType_useForSnippetsTest", "attributes": {"modifiers": "@BeforeEach\n    public", "marker_annotations": ["@BeforeEach"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/io/cucumber/cucumberexpressions/CucumberExpression_getSourceTest.java.CucumberExpression_getSourceTest.[void]setUp()", "name": "setUp", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@BeforeEach\n    public void setUp()", "original_string": "    @BeforeEach\n    public void setUp() {\n        parameterTypeRegistry = new ParameterTypeRegistry(Locale.ENGLISH);\n    }", "default_arguments": null, "file": "src/test/java/io/cucumber/cucumberexpressions/CucumberExpression_getSourceTest.java", "class_name": "CucumberExpression_getSourceTest", "class_uri": "src/test/java/io/cucumber/cucumberexpressions/CucumberExpression_getSourceTest.java.CucumberExpression_getSourceTest", "attributes": {"modifiers": "@BeforeEach\n    public", "marker_annotations": ["@BeforeEach"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/io/cucumber/cucumberexpressions/RegularExpressionTest.java.RegularExpressionTest.[List<Path>]acceptance_tests_pass()", "name": "acceptance_tests_pass", "arg_nums": 0, "params": [], "return_type": "List<Path>", "signature": "private static List<Path> acceptance_tests_pass()", "original_string": "    private static List<Path> acceptance_tests_pass() throws IOException {\n        List<Path> paths = new ArrayList<>();\n        newDirectoryStream(Paths.get(\"..\", \"testdata\", \"regular-expression\", \"matching\")).forEach(paths::add);\n        paths.sort(Comparator.naturalOrder());\n        return paths;\n    }", "default_arguments": null, "file": "src/test/java/io/cucumber/cucumberexpressions/RegularExpressionTest.java", "class_name": "RegularExpressionTest", "class_uri": "src/test/java/io/cucumber/cucumberexpressions/RegularExpressionTest.java.RegularExpressionTest", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "List<Path>", "classes": []}, "docstring": ""}, {"uris": "src/test/java/io/cucumber/cucumberexpressions/RegularExpressionTest.java.RegularExpressionTest.[List<?>]match(Pattern,String)", "name": "match", "arg_nums": 2, "params": [{"name": "pattern", "type": "Pattern"}, {"name": "text", "type": "String"}], "return_type": "List<?>", "signature": "private List<?> match(Pattern pattern, String text, Type... types)", "original_string": "    private List<?> match(Pattern pattern, String text, Type... types) {\n        RegularExpression regularExpression = new RegularExpression(pattern, parameterTypeRegistry);\n        List<Argument<?>> arguments = regularExpression.match(text, types);\n        List<Object> values = new ArrayList<>();\n        for (Argument<?> argument : arguments) {\n            values.add(argument.getValue());\n        }\n        return values;\n    }", "default_arguments": null, "file": "src/test/java/io/cucumber/cucumberexpressions/RegularExpressionTest.java", "class_name": "RegularExpressionTest", "class_uri": "src/test/java/io/cucumber/cucumberexpressions/RegularExpressionTest.java.RegularExpressionTest", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "List<?>", "classes": []}, "docstring": ""}, {"uris": "src/test/java/io/cucumber/cucumberexpressions/BuiltInParameterTransformer_transformTest.java.BuiltInParameterTransformer_transformTest.[void]setUp()", "name": "setUp", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@BeforeEach\n    void setUp()", "original_string": "    @BeforeEach\n    void setUp() {\n        transformer = new BuiltInParameterTransformer(Locale.ENGLISH);\n    }", "default_arguments": null, "file": "src/test/java/io/cucumber/cucumberexpressions/BuiltInParameterTransformer_transformTest.java", "class_name": "BuiltInParameterTransformer_transformTest", "class_uri": "src/test/java/io/cucumber/cucumberexpressions/BuiltInParameterTransformer_transformTest.java.BuiltInParameterTransformer_transformTest", "attributes": {"modifiers": "@BeforeEach", "marker_annotations": ["@BeforeEach"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/io/cucumber/cucumberexpressions/ParameterType_getTypeTest.java.ParameterType_getTypeTest.[void]setUp()", "name": "setUp", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@BeforeEach\n    public void setUp()", "original_string": "    @BeforeEach\n    public void setUp() {\n        parameterType = new ParameterType<>(\"testName\", \"testRegexp\", String.class, (Transformer<String>) s -> s, true, false);\n    }", "default_arguments": null, "file": "src/test/java/io/cucumber/cucumberexpressions/ParameterType_getTypeTest.java", "class_name": "ParameterType_getTypeTest", "class_uri": "src/test/java/io/cucumber/cucumberexpressions/ParameterType_getTypeTest.java.ParameterType_getTypeTest", "attributes": {"modifiers": "@BeforeEach\n    public", "marker_annotations": ["@BeforeEach"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/io/cucumber/cucumberexpressions/ParameterByTypeTransformerTest.java.ParameterByTypeTransformerTest.[Stream<ParameterByTypeTransformer>]objectMapperImplementations()", "name": "objectMapperImplementations", "arg_nums": 0, "params": [], "return_type": "Stream<ParameterByTypeTransformer>", "signature": "static Stream<ParameterByTypeTransformer> objectMapperImplementations()", "original_string": "    static Stream<ParameterByTypeTransformer> objectMapperImplementations() {\n        return Stream.of(\n                new BuiltInParameterTransformer(ENGLISH),\n                new TestJacksonDefaultTransformer()\n        );\n    }", "default_arguments": null, "file": "src/test/java/io/cucumber/cucumberexpressions/ParameterByTypeTransformerTest.java", "class_name": "ParameterByTypeTransformerTest", "class_uri": "src/test/java/io/cucumber/cucumberexpressions/ParameterByTypeTransformerTest.java.ParameterByTypeTransformerTest", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "Stream<ParameterByTypeTransformer>", "classes": []}, "docstring": ""}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/ParameterTypeMatcher.java.ParameterTypeMatcher.[]ParameterTypeMatcher(ParameterType<?>,Matcher,String)", "name": "ParameterTypeMatcher", "arg_nums": 3, "params": [{"name": "parameterType", "type": "ParameterType<?>"}, {"name": "matcher", "type": "Matcher"}, {"name": "text", "type": "String"}], "return_type": "", "signature": "ParameterTypeMatcher(ParameterType<?> parameterType, Matcher matcher, String text)", "original_string": "    ParameterTypeMatcher(ParameterType<?> parameterType, Matcher matcher, String text) {\n        this.parameterType = parameterType;\n        this.matcher = matcher;\n        this.text = text;\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/ParameterTypeMatcher.java", "class_name": "ParameterTypeMatcher", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/ParameterTypeMatcher.java.ParameterTypeMatcher", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "docstring": ""}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/ParameterTypeMatcher.java.ParameterTypeMatcher.[boolean]isWhitespaceOrPunctuationOrSymbol(char)", "name": "isWhitespaceOrPunctuationOrSymbol", "arg_nums": 1, "params": [{"name": "c", "type": "char"}], "return_type": "boolean", "signature": "private static boolean isWhitespaceOrPunctuationOrSymbol(char c)", "original_string": "    private static boolean isWhitespaceOrPunctuationOrSymbol(char c) {\n        return Pattern.matches(\"[\\\\p{Z}\\\\p{P}\\\\p{S}]\", new String(new char[] { c }));\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/ParameterTypeMatcher.java", "class_name": "ParameterTypeMatcher", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/ParameterTypeMatcher.java.ParameterTypeMatcher", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": ""}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/ParameterTypeMatcher.java.ParameterTypeMatcher.[boolean]advanceToAndFind(int)", "name": "advanceToAndFind", "arg_nums": 1, "params": [{"name": "newMatchPos", "type": "int"}], "return_type": "boolean", "signature": "boolean advanceToAndFind(int newMatchPos)", "original_string": "    boolean advanceToAndFind(int newMatchPos) {\n        // Unlike js, ruby and go, the matcher is stateful\n        // so we can't use the immutable semantics.\n        matcher.region(newMatchPos, text.length());\n        while (matcher.find()) {\n            if (group().isEmpty()) {\n                continue;\n            }\n            if (groupHasWordBoundaryOnBothSides()) {\n                return true;\n            }\n        }\n        return false;\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/ParameterTypeMatcher.java", "class_name": "ParameterTypeMatcher", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/ParameterTypeMatcher.java.ParameterTypeMatcher", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "boolean", "classes": []}, "docstring": ""}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/ParameterTypeMatcher.java.ParameterTypeMatcher.[boolean]groupHasWordBoundaryOnBothSides()", "name": "groupHasWordBoundaryOnBothSides", "arg_nums": 0, "params": [], "return_type": "boolean", "signature": "private boolean groupHasWordBoundaryOnBothSides()", "original_string": "    private boolean groupHasWordBoundaryOnBothSides() {\n        return groupHasLeftWordBoundary() && groupHasRightWordBoundary();\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/ParameterTypeMatcher.java", "class_name": "ParameterTypeMatcher", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/ParameterTypeMatcher.java.ParameterTypeMatcher", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": ""}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/ParameterTypeMatcher.java.ParameterTypeMatcher.[boolean]groupHasLeftWordBoundary()", "name": "groupHasLeftWordBoundary", "arg_nums": 0, "params": [], "return_type": "boolean", "signature": "private boolean groupHasLeftWordBoundary()", "original_string": "    private boolean groupHasLeftWordBoundary() {\n        if (matcher.start() > 0) {\n            char before = text.charAt(matcher.start() - 1);\n            return isWhitespaceOrPunctuationOrSymbol(before);\n        }\n        return true;\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/ParameterTypeMatcher.java", "class_name": "ParameterTypeMatcher", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/ParameterTypeMatcher.java.ParameterTypeMatcher", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": ""}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/ParameterTypeMatcher.java.ParameterTypeMatcher.[boolean]groupHasRightWordBoundary()", "name": "groupHasRightWordBoundary", "arg_nums": 0, "params": [], "return_type": "boolean", "signature": "private boolean groupHasRightWordBoundary()", "original_string": "    private boolean groupHasRightWordBoundary() {\n        if (matcher.end() < text.length()) {\n            char after = text.charAt(matcher.end());\n            return isWhitespaceOrPunctuationOrSymbol(after);\n        }\n        return true;\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/ParameterTypeMatcher.java", "class_name": "ParameterTypeMatcher", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/ParameterTypeMatcher.java.ParameterTypeMatcher", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": ""}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/ParameterTypeMatcher.java.ParameterTypeMatcher.[int]start()", "name": "start", "arg_nums": 0, "params": [], "return_type": "int", "signature": "int start()", "original_string": "    int start() {\n        return matcher.start();\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/ParameterTypeMatcher.java", "class_name": "ParameterTypeMatcher", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/ParameterTypeMatcher.java.ParameterTypeMatcher", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "int", "classes": []}, "docstring": ""}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/ParameterTypeMatcher.java.ParameterTypeMatcher.[String]group()", "name": "group", "arg_nums": 0, "params": [], "return_type": "String", "signature": "String group()", "original_string": "    String group() {\n        return matcher.group();\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/ParameterTypeMatcher.java", "class_name": "ParameterTypeMatcher", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/ParameterTypeMatcher.java.ParameterTypeMatcher", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "String", "classes": []}, "docstring": ""}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/ParameterTypeMatcher.java.ParameterTypeMatcher.[int]compareTo(ParameterTypeMatcher)", "name": "compareTo", "arg_nums": 1, "params": [{"name": "o", "type": "ParameterTypeMatcher"}], "return_type": "int", "signature": "@Override\n    public int compareTo(ParameterTypeMatcher o)", "original_string": "    @Override\n    public int compareTo(ParameterTypeMatcher o) {\n        int posComparison = Integer.compare(start(), o.start());\n        if (posComparison != 0) return posComparison;\n        int lengthComparison = Integer.compare(o.group().length(), group().length());\n        if (lengthComparison != 0) return lengthComparison;\n        int weightComparison = Integer.compare(o.parameterType.weight(), parameterType.weight());\n        if (weightComparison != 0) return weightComparison;\n        return 0;\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/ParameterTypeMatcher.java", "class_name": "ParameterTypeMatcher", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/ParameterTypeMatcher.java.ParameterTypeMatcher", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "docstring": ""}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/ParameterTypeMatcher.java.ParameterTypeMatcher.[ParameterType<?>]getParameterType()", "name": "getParameterType", "arg_nums": 0, "params": [], "return_type": "ParameterType<?>", "signature": "ParameterType<?> getParameterType()", "original_string": "    ParameterType<?> getParameterType() {\n        return parameterType;\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/ParameterTypeMatcher.java", "class_name": "ParameterTypeMatcher", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/ParameterTypeMatcher.java.ParameterTypeMatcher", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "ParameterType<?>", "classes": []}, "docstring": ""}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/ParameterTypeMatcher.java.ParameterTypeMatcher.[String]toString()", "name": "toString", "arg_nums": 0, "params": [], "return_type": "String", "signature": "public String toString()", "original_string": "    public String toString() {\n        return parameterType.getType().toString();\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/ParameterTypeMatcher.java", "class_name": "ParameterTypeMatcher", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/ParameterTypeMatcher.java.ParameterTypeMatcher", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "docstring": ""}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/UndefinedParameterTypeException.java.UndefinedParameterTypeException.[]UndefinedParameterTypeException(String,String)", "name": "UndefinedParameterTypeException", "arg_nums": 2, "params": [{"name": "message", "type": "String"}, {"name": "undefinedParameterTypeName", "type": "String"}], "return_type": "", "signature": "UndefinedParameterTypeException(String message, String undefinedParameterTypeName)", "original_string": "    UndefinedParameterTypeException(String message, String undefinedParameterTypeName) {\n        super(message);\n        this.undefinedParameterTypeName = undefinedParameterTypeName;\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/UndefinedParameterTypeException.java", "class_name": "UndefinedParameterTypeException", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/UndefinedParameterTypeException.java.UndefinedParameterTypeException", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "docstring": ""}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/UndefinedParameterTypeException.java.UndefinedParameterTypeException.[String]getUndefinedParameterTypeName()", "name": "getUndefinedParameterTypeName", "arg_nums": 0, "params": [], "return_type": "String", "signature": "public String getUndefinedParameterTypeName()", "original_string": "    public String getUndefinedParameterTypeName() {\n        return undefinedParameterTypeName;\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/UndefinedParameterTypeException.java", "class_name": "UndefinedParameterTypeException", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/UndefinedParameterTypeException.java.UndefinedParameterTypeException", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "docstring": ""}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/UndefinedParameterTypeException.java.UndefinedParameterTypeException.[CucumberExpressionException]createUndefinedParameterType(Node,String,String)", "name": "createUndefinedParameterType", "arg_nums": 3, "params": [{"name": "node", "type": "Node"}, {"name": "expression", "type": "String"}, {"name": "undefinedParameterTypeName", "type": "String"}], "return_type": "CucumberExpressionException", "signature": "static CucumberExpressionException createUndefinedParameterType(Node node, String expression, String undefinedParameterTypeName)", "original_string": "    static CucumberExpressionException createUndefinedParameterType(Node node, String expression, String undefinedParameterTypeName) {\n        return new UndefinedParameterTypeException(message(\n                node.start(),\n                expression,\n                pointAt(node),\n                \"Undefined parameter type '\" +undefinedParameterTypeName+ \"'\",\n                \"Please register a ParameterType for '\"+undefinedParameterTypeName+\"'\"), undefinedParameterTypeName);\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/UndefinedParameterTypeException.java", "class_name": "UndefinedParameterTypeException", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/UndefinedParameterTypeException.java.UndefinedParameterTypeException", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "CucumberExpressionException", "classes": []}, "docstring": ""}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/ParameterType.java.ParameterType.[void]checkParameterTypeName(String)", "name": "checkParameterTypeName", "arg_nums": 1, "params": [{"name": "name", "type": "String"}], "return_type": "void", "signature": "static void checkParameterTypeName(String name)", "original_string": "    static void checkParameterTypeName(String name) {\n        if (!isValidParameterTypeName(name)) {\n            throw CucumberExpressionException.createInvalidParameterTypeName(name);\n        }\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/ParameterType.java", "class_name": "ParameterType", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/ParameterType.java.ParameterType", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/ParameterType.java.ParameterType.[boolean]isValidParameterTypeName(String)", "name": "isValidParameterTypeName", "arg_nums": 1, "params": [{"name": "name", "type": "String"}], "return_type": "boolean", "signature": "static boolean isValidParameterTypeName(String name)", "original_string": "    static boolean isValidParameterTypeName(String name) {\n        String unescapedTypeName = UNESCAPE_PATTERN.matcher(name).replaceAll(\"$2\");\n        Matcher matcher = ILLEGAL_PARAMETER_NAME_PATTERN.matcher(unescapedTypeName);\n        return !matcher.find();\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/ParameterType.java", "class_name": "ParameterType", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/ParameterType.java.ParameterType", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": ""}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/ParameterType.java.ParameterType.[ParameterType<Object>]createAnonymousParameterType(String)", "name": "createAnonymousParameterType", "arg_nums": 1, "params": [{"name": "regexp", "type": "String"}], "return_type": "ParameterType<Object>", "signature": "static ParameterType<Object> createAnonymousParameterType(String regexp)", "original_string": "    static ParameterType<Object> createAnonymousParameterType(String regexp) {\n        return new ParameterType<>(\"\", singletonList(regexp), Object.class, new CaptureGroupTransformer<Object>() {\n\n            public Object transform(String[] arg) {\n                throw new UnsupportedOperationException(\"Anonymous transform must be deanonymized before use\");\n            }\n        }, false, true, false, true);\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/ParameterType.java", "class_name": "ParameterType", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/ParameterType.java.ParameterType", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "ParameterType<Object>", "classes": []}, "docstring": ""}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/ParameterType.java.ParameterType.[ParameterType<E>]fromEnum(Class<E>)", "name": "fromEnum", "arg_nums": 1, "params": [{"name": "enumClass", "type": "Class<E>"}], "return_type": "ParameterType<E>", "signature": "@SuppressWarnings(\"unchecked\")\n    static <E extends Enum> ParameterType<E> fromEnum(final Class<E> enumClass)", "original_string": "    @SuppressWarnings(\"unchecked\")\n    static <E extends Enum> ParameterType<E> fromEnum(final Class<E> enumClass) {\n        Enum[] enumConstants = enumClass.getEnumConstants();\n        StringBuilder regexpBuilder = new StringBuilder();\n        for (int i = 0; i < enumConstants.length; i++) {\n            if (i > 0)\n                regexpBuilder.append(\"|\");\n            regexpBuilder.append(enumConstants[i].name());\n        }\n        return new ParameterType<>(\n                enumClass.getSimpleName(),\n                regexpBuilder.toString(),\n                enumClass,\n                (String arg) -> (E) Enum.valueOf(enumClass, arg)\n        );\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/ParameterType.java", "class_name": "ParameterType", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/ParameterType.java.ParameterType", "attributes": {"modifiers": "@SuppressWarnings(\"unchecked\")\n    static", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings(\"unchecked\")", "static"], "comments": [], "return_type": "ParameterType<E>", "classes": []}, "docstring": ""}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/ParameterType.java.ParameterType.[]ParameterType(String,List<String>,Type,CaptureGroupTransformer<T>,boolean,boolean,boolean,boolean)", "name": "ParameterType", "arg_nums": 8, "params": [{"name": "name", "type": "String"}, {"name": "regexps", "type": "List<String>"}, {"name": "type", "type": "Type"}, {"name": "transformer", "type": "CaptureGroupTransformer<T>"}, {"name": "useForSnippets", "type": "boolean"}, {"name": "preferForRegexpMatch", "type": "boolean"}, {"name": "useRegexpMatchAsStrongTypeHint", "type": "boolean"}, {"name": "anonymous", "type": "boolean"}], "return_type": "", "signature": "private ParameterType(String name, List<String> regexps, Type type, CaptureGroupTransformer<T> transformer,\n            boolean useForSnippets, boolean preferForRegexpMatch, boolean useRegexpMatchAsStrongTypeHint,\n            boolean anonymous)", "original_string": "    private ParameterType(String name, List<String> regexps, Type type, CaptureGroupTransformer<T> transformer,\n            boolean useForSnippets, boolean preferForRegexpMatch, boolean useRegexpMatchAsStrongTypeHint,\n            boolean anonymous) {\n        if (regexps == null)\n            throw new NullPointerException(\"regexps cannot be null\");\n        if (type == null)\n            throw new NullPointerException(\"type cannot be null\");\n        if (transformer == null)\n            throw new NullPointerException(\"transformer cannot be null\");\n        if (name != null)\n            checkParameterTypeName(name);\n        this.name = name;\n        this.regexps = regexps;\n        this.type = type;\n        this.transformer = transformer;\n        this.useForSnippets = useForSnippets;\n        this.preferForRegexpMatch = preferForRegexpMatch;\n        this.anonymous = anonymous;\n        this.useRegexpMatchAsStrongTypeHint = useRegexpMatchAsStrongTypeHint;\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/ParameterType.java", "class_name": "ParameterType", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/ParameterType.java.ParameterType", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "", "classes": []}, "docstring": ""}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/ParameterType.java.ParameterType.[]ParameterType(String,List<String>,Type,CaptureGroupTransformer<T>,boolean,boolean,boolean)", "name": "ParameterType", "arg_nums": 7, "params": [{"name": "name", "type": "String"}, {"name": "regexps", "type": "List<String>"}, {"name": "type", "type": "Type"}, {"name": "transformer", "type": "CaptureGroupTransformer<T>"}, {"name": "useForSnippets", "type": "boolean"}, {"name": "preferForRegexpMatch", "type": "boolean"}, {"name": "useRegexpMatchAsStrongTypeHint", "type": "boolean"}], "return_type": "", "signature": "public ParameterType(String name, List<String> regexps, Type type, CaptureGroupTransformer<T> transformer,\n            boolean useForSnippets, boolean preferForRegexpMatch, boolean useRegexpMatchAsStrongTypeHint)", "original_string": "    public ParameterType(String name, List<String> regexps, Type type, CaptureGroupTransformer<T> transformer,\n            boolean useForSnippets, boolean preferForRegexpMatch, boolean useRegexpMatchAsStrongTypeHint) {\n        this(name, regexps, type, transformer, useForSnippets, preferForRegexpMatch, useRegexpMatchAsStrongTypeHint,\n                false);\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/ParameterType.java", "class_name": "ParameterType", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/ParameterType.java.ParameterType", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": ""}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/ParameterType.java.ParameterType.[]ParameterType(String,List<String>,Type,CaptureGroupTransformer<T>,boolean,boolean)", "name": "ParameterType", "arg_nums": 6, "params": [{"name": "name", "type": "String"}, {"name": "regexps", "type": "List<String>"}, {"name": "type", "type": "Type"}, {"name": "transformer", "type": "CaptureGroupTransformer<T>"}, {"name": "useForSnippets", "type": "boolean"}, {"name": "preferForRegexpMatch", "type": "boolean"}], "return_type": "", "signature": "public ParameterType(String name, List<String> regexps, Type type, CaptureGroupTransformer<T> transformer,\n            boolean useForSnippets, boolean preferForRegexpMatch)", "original_string": "    public ParameterType(String name, List<String> regexps, Type type, CaptureGroupTransformer<T> transformer,\n            boolean useForSnippets, boolean preferForRegexpMatch) {\n        // Unless explicitly set useRegexpMatchAsStrongTypeHint is true.\n        //\n        // Reasoning:\n        // 1. Pure cucumber expression users will not notice this in either scenario.\n        // 2. Pure regular expression users will benefit because BuiltInParameterTransformer can now seamlessly\n        //    transform any captured values. (For all built in types useRegexpMatchAsStrongTypeHint is explicitly set to\n        //    false.)\n        // 2. Regular expression users that define a default transformer have little need to define parameter types. The\n        //    default transformer should be sufficiently powerful to meet their needs and will often allow users to add\n        //    custom creation methods e.g. Jacksons @JsonFactory.\n        // 3. Users who mix regular and cucumber expressions may run into conflicts when a registered cucumber expression\n        //    and unregistered happens to collide. However this was the situation before this flag was added.\n        // 4. Regular expression users who define custom parameter types do so with the expectation that the parameter\n        //    will be matched. Subverting this expectation when the method signature does not match may result in a\n        //    parameter transformer that is unable to convert to the desired type. Leaving the user puzzled as to why\n        //    his transform was ignored.\n        this(name, regexps, type, transformer, useForSnippets, preferForRegexpMatch, true);\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/ParameterType.java", "class_name": "ParameterType", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/ParameterType.java.ParameterType", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": ""}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/ParameterType.java.ParameterType.[]ParameterType(String,List<String>,Class<T>,CaptureGroupTransformer<T>,boolean,boolean)", "name": "ParameterType", "arg_nums": 6, "params": [{"name": "name", "type": "String"}, {"name": "regexps", "type": "List<String>"}, {"name": "type", "type": "Class<T>"}, {"name": "transformer", "type": "CaptureGroupTransformer<T>"}, {"name": "useForSnippets", "type": "boolean"}, {"name": "preferForRegexpMatch", "type": "boolean"}], "return_type": "", "signature": "public ParameterType(String name, List<String> regexps, Class<T> type, CaptureGroupTransformer<T> transformer,\n            boolean useForSnippets, boolean preferForRegexpMatch)", "original_string": "    public ParameterType(String name, List<String> regexps, Class<T> type, CaptureGroupTransformer<T> transformer,\n            boolean useForSnippets, boolean preferForRegexpMatch) {\n        this(name, regexps, (Type) type, transformer, useForSnippets, preferForRegexpMatch);\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/ParameterType.java", "class_name": "ParameterType", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/ParameterType.java.ParameterType", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": ""}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/ParameterType.java.ParameterType.[]ParameterType(String,String,Class<T>,CaptureGroupTransformer<T>,boolean,boolean)", "name": "ParameterType", "arg_nums": 6, "params": [{"name": "name", "type": "String"}, {"name": "regexp", "type": "String"}, {"name": "type", "type": "Class<T>"}, {"name": "transformer", "type": "CaptureGroupTransformer<T>"}, {"name": "useForSnippets", "type": "boolean"}, {"name": "preferForRegexpMatch", "type": "boolean"}], "return_type": "", "signature": "public ParameterType(String name, String regexp, Class<T> type, CaptureGroupTransformer<T> transformer,\n            boolean useForSnippets, boolean preferForRegexpMatch)", "original_string": "    public ParameterType(String name, String regexp, Class<T> type, CaptureGroupTransformer<T> transformer,\n            boolean useForSnippets, boolean preferForRegexpMatch) {\n        this(name, singletonList(regexp), type, transformer, useForSnippets, preferForRegexpMatch);\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/ParameterType.java", "class_name": "ParameterType", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/ParameterType.java.ParameterType", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": ""}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/ParameterType.java.ParameterType.[]ParameterType(String,List<String>,Class<T>,CaptureGroupTransformer<T>)", "name": "ParameterType", "arg_nums": 4, "params": [{"name": "name", "type": "String"}, {"name": "regexps", "type": "List<String>"}, {"name": "type", "type": "Class<T>"}, {"name": "transformer", "type": "CaptureGroupTransformer<T>"}], "return_type": "", "signature": "public ParameterType(String name, List<String> regexps, Class<T> type, CaptureGroupTransformer<T> transformer)", "original_string": "    public ParameterType(String name, List<String> regexps, Class<T> type, CaptureGroupTransformer<T> transformer) {\n        this(name, regexps, type, transformer, true, false);\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/ParameterType.java", "class_name": "ParameterType", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/ParameterType.java.ParameterType", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": ""}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/ParameterType.java.ParameterType.[]ParameterType(String,String,Class<T>,CaptureGroupTransformer<T>)", "name": "ParameterType", "arg_nums": 4, "params": [{"name": "name", "type": "String"}, {"name": "regexp", "type": "String"}, {"name": "type", "type": "Class<T>"}, {"name": "transformer", "type": "CaptureGroupTransformer<T>"}], "return_type": "", "signature": "public ParameterType(String name, String regexp, Class<T> type, CaptureGroupTransformer<T> transformer)", "original_string": "    public ParameterType(String name, String regexp, Class<T> type, CaptureGroupTransformer<T> transformer) {\n        this(name, singletonList(regexp), type, transformer, true, false);\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/ParameterType.java", "class_name": "ParameterType", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/ParameterType.java.ParameterType", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": ""}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/ParameterType.java.ParameterType.[]ParameterType(String,List<String>,Type,Transformer<T>,boolean,boolean,boolean)", "name": "ParameterType", "arg_nums": 7, "params": [{"name": "name", "type": "String"}, {"name": "regexps", "type": "List<String>"}, {"name": "type", "type": "Type"}, {"name": "transformer", "type": "Transformer<T>"}, {"name": "useForSnippets", "type": "boolean"}, {"name": "preferForRegexpMatch", "type": "boolean"}, {"name": "useRegexpMatchAsStrongTypeHint", "type": "boolean"}], "return_type": "", "signature": "public ParameterType(String name, List<String> regexps, Type type, Transformer<T> transformer,\n            boolean useForSnippets, boolean preferForRegexpMatch, boolean useRegexpMatchAsStrongTypeHint)", "original_string": "    public ParameterType(String name, List<String> regexps, Type type, Transformer<T> transformer,\n            boolean useForSnippets, boolean preferForRegexpMatch, boolean useRegexpMatchAsStrongTypeHint) {\n        this(name, regexps, type, new TransformerAdaptor<>(transformer), useForSnippets, preferForRegexpMatch,\n                useRegexpMatchAsStrongTypeHint);\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/ParameterType.java", "class_name": "ParameterType", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/ParameterType.java.ParameterType", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": ""}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/ParameterType.java.ParameterType.[]ParameterType(String,List<String>,Type,Transformer<T>,boolean,boolean)", "name": "ParameterType", "arg_nums": 6, "params": [{"name": "name", "type": "String"}, {"name": "regexps", "type": "List<String>"}, {"name": "type", "type": "Type"}, {"name": "transformer", "type": "Transformer<T>"}, {"name": "useForSnippets", "type": "boolean"}, {"name": "preferForRegexpMatch", "type": "boolean"}], "return_type": "", "signature": "public ParameterType(String name, List<String> regexps, Type type, Transformer<T> transformer,\n            boolean useForSnippets, boolean preferForRegexpMatch)", "original_string": "    public ParameterType(String name, List<String> regexps, Type type, Transformer<T> transformer,\n            boolean useForSnippets, boolean preferForRegexpMatch) {\n        this(name, regexps, type, new TransformerAdaptor<>(transformer), useForSnippets, preferForRegexpMatch);\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/ParameterType.java", "class_name": "ParameterType", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/ParameterType.java.ParameterType", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": ""}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/ParameterType.java.ParameterType.[]ParameterType(String,List<String>,Class<T>,Transformer<T>,boolean,boolean,boolean)", "name": "ParameterType", "arg_nums": 7, "params": [{"name": "name", "type": "String"}, {"name": "regexps", "type": "List<String>"}, {"name": "type", "type": "Class<T>"}, {"name": "transformer", "type": "Transformer<T>"}, {"name": "useForSnippets", "type": "boolean"}, {"name": "preferForRegexpMatch", "type": "boolean"}, {"name": "useRegexpMatchAsStrongTypeHint", "type": "boolean"}], "return_type": "", "signature": "public ParameterType(String name, List<String> regexps, Class<T> type, Transformer<T> transformer,\n            boolean useForSnippets, boolean preferForRegexpMatch, boolean useRegexpMatchAsStrongTypeHint)", "original_string": "    public ParameterType(String name, List<String> regexps, Class<T> type, Transformer<T> transformer,\n            boolean useForSnippets, boolean preferForRegexpMatch, boolean useRegexpMatchAsStrongTypeHint) {\n        this(name, regexps, (Type) type, transformer, useForSnippets, preferForRegexpMatch,\n                useRegexpMatchAsStrongTypeHint);\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/ParameterType.java", "class_name": "ParameterType", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/ParameterType.java.ParameterType", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": ""}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/ParameterType.java.ParameterType.[]ParameterType(String,List<String>,Class<T>,Transformer<T>,boolean,boolean)", "name": "ParameterType", "arg_nums": 6, "params": [{"name": "name", "type": "String"}, {"name": "regexps", "type": "List<String>"}, {"name": "type", "type": "Class<T>"}, {"name": "transformer", "type": "Transformer<T>"}, {"name": "useForSnippets", "type": "boolean"}, {"name": "preferForRegexpMatch", "type": "boolean"}], "return_type": "", "signature": "public ParameterType(String name, List<String> regexps, Class<T> type, Transformer<T> transformer,\n            boolean useForSnippets, boolean preferForRegexpMatch)", "original_string": "    public ParameterType(String name, List<String> regexps, Class<T> type, Transformer<T> transformer,\n            boolean useForSnippets, boolean preferForRegexpMatch) {\n        this(name, regexps, (Type) type, transformer, useForSnippets, preferForRegexpMatch);\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/ParameterType.java", "class_name": "ParameterType", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/ParameterType.java.ParameterType", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": ""}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/ParameterType.java.ParameterType.[]ParameterType(String,String,Class<T>,Transformer<T>,boolean,boolean,boolean)", "name": "ParameterType", "arg_nums": 7, "params": [{"name": "name", "type": "String"}, {"name": "regexp", "type": "String"}, {"name": "type", "type": "Class<T>"}, {"name": "transformer", "type": "Transformer<T>"}, {"name": "useForSnippets", "type": "boolean"}, {"name": "preferForRegexpMatch", "type": "boolean"}, {"name": "useRegexpMatchAsStrongTypeHint", "type": "boolean"}], "return_type": "", "signature": "public ParameterType(String name, String regexp, Class<T> type, Transformer<T> transformer, boolean useForSnippets,\n            boolean preferForRegexpMatch, boolean useRegexpMatchAsStrongTypeHint)", "original_string": "    public ParameterType(String name, String regexp, Class<T> type, Transformer<T> transformer, boolean useForSnippets,\n            boolean preferForRegexpMatch, boolean useRegexpMatchAsStrongTypeHint) {\n        this(name, singletonList(regexp), type, transformer, useForSnippets, preferForRegexpMatch,\n                useRegexpMatchAsStrongTypeHint);\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/ParameterType.java", "class_name": "ParameterType", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/ParameterType.java.ParameterType", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": ""}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/ParameterType.java.ParameterType.[]ParameterType(String,String,Class<T>,Transformer<T>,boolean,boolean)", "name": "ParameterType", "arg_nums": 6, "params": [{"name": "name", "type": "String"}, {"name": "regexp", "type": "String"}, {"name": "type", "type": "Class<T>"}, {"name": "transformer", "type": "Transformer<T>"}, {"name": "useForSnippets", "type": "boolean"}, {"name": "preferForRegexpMatch", "type": "boolean"}], "return_type": "", "signature": "public ParameterType(String name, String regexp, Class<T> type, Transformer<T> transformer, boolean useForSnippets,\n            boolean preferForRegexpMatch)", "original_string": "    public ParameterType(String name, String regexp, Class<T> type, Transformer<T> transformer, boolean useForSnippets,\n            boolean preferForRegexpMatch) {\n        this(name, singletonList(regexp), type, transformer, useForSnippets, preferForRegexpMatch);\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/ParameterType.java", "class_name": "ParameterType", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/ParameterType.java.ParameterType", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": ""}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/ParameterType.java.ParameterType.[]ParameterType(String,List<String>,Class<T>,Transformer<T>)", "name": "ParameterType", "arg_nums": 4, "params": [{"name": "name", "type": "String"}, {"name": "regexps", "type": "List<String>"}, {"name": "type", "type": "Class<T>"}, {"name": "transformer", "type": "Transformer<T>"}], "return_type": "", "signature": "public ParameterType(String name, List<String> regexps, Class<T> type, Transformer<T> transformer)", "original_string": "    public ParameterType(String name, List<String> regexps, Class<T> type, Transformer<T> transformer) {\n        this(name, regexps, type, transformer, true, false);\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/ParameterType.java", "class_name": "ParameterType", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/ParameterType.java.ParameterType", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": ""}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/ParameterType.java.ParameterType.[]ParameterType(String,String,Class<T>,Transformer<T>)", "name": "ParameterType", "arg_nums": 4, "params": [{"name": "name", "type": "String"}, {"name": "regexp", "type": "String"}, {"name": "type", "type": "Class<T>"}, {"name": "transformer", "type": "Transformer<T>"}], "return_type": "", "signature": "public ParameterType(String name, String regexp, Class<T> type, Transformer<T> transformer)", "original_string": "    public ParameterType(String name, String regexp, Class<T> type, Transformer<T> transformer) {\n        this(name, singletonList(regexp), type, transformer, true, false);\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/ParameterType.java", "class_name": "ParameterType", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/ParameterType.java.ParameterType", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": ""}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/ParameterType.java.ParameterType.[String]getName()", "name": "getName", "arg_nums": 0, "params": [], "return_type": "String", "signature": "public String getName()", "original_string": "    public String getName() {\n        return name;\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/ParameterType.java", "class_name": "ParameterType", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/ParameterType.java.ParameterType", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "docstring": "\nThis is used in the type name in typed expressions\n\n@return human readable type name\n"}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/ParameterType.java.ParameterType.[Type]getType()", "name": "getType", "arg_nums": 0, "params": [], "return_type": "Type", "signature": "public Type getType()", "original_string": "    public Type getType() {\n        return type;\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/ParameterType.java", "class_name": "ParameterType", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/ParameterType.java.ParameterType", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Type", "classes": []}, "docstring": "\nReturns the type of the parameter type - typically the type\nthe transform transforms to. This can be used in conjunction with\nGeneratedExpression (snippets) to generate snippets for statically typed\nlanguages. Not used for anything else.\n\n@return the type of the parameter type\n"}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/ParameterType.java.ParameterType.[List<String>]getRegexps()", "name": "getRegexps", "arg_nums": 0, "params": [], "return_type": "List<String>", "signature": "public List<String> getRegexps()", "original_string": "    public List<String> getRegexps() {\n        return regexps;\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/ParameterType.java", "class_name": "ParameterType", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/ParameterType.java.ParameterType", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "List<String>", "classes": []}, "docstring": ""}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/ParameterType.java.ParameterType.[boolean]preferForRegexpMatch()", "name": "preferForRegexpMatch", "arg_nums": 0, "params": [], "return_type": "boolean", "signature": "public boolean preferForRegexpMatch()", "original_string": "    public boolean preferForRegexpMatch() {\n        return preferForRegexpMatch;\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/ParameterType.java", "class_name": "ParameterType", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/ParameterType.java.ParameterType", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nIndicates whether or not this is a preferential parameter type when matching text\nagainst a {@link RegularExpression}. In case there are multiple parameter types\nwith a regexp identical to the capture group's regexp, a preferential parameter type will\nwin. If there are more than 1 preferential ones, an error will be thrown.\n\n@return true if this is a preferential type\n"}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/ParameterType.java.ParameterType.[boolean]useForSnippets()", "name": "useForSnippets", "arg_nums": 0, "params": [], "return_type": "boolean", "signature": "public boolean useForSnippets()", "original_string": "    public boolean useForSnippets() {\n        return useForSnippets;\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/ParameterType.java", "class_name": "ParameterType", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/ParameterType.java.ParameterType", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nIndicates whether or not this is a parameter type should be used for generating\n{@link GeneratedExpression}s from text. Typically, parameter types with greedy regexps\nshould return false.\n\n@return true is this parameter type is used for expression generation\n"}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/ParameterType.java.ParameterType.[boolean]isAnonymous()", "name": "isAnonymous", "arg_nums": 0, "params": [], "return_type": "boolean", "signature": "boolean isAnonymous()", "original_string": "    boolean isAnonymous() {\n        return anonymous;\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/ParameterType.java", "class_name": "ParameterType", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/ParameterType.java.ParameterType", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "boolean", "classes": []}, "docstring": ""}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/ParameterType.java.ParameterType.[boolean]useRegexpMatchAsStrongTypeHint()", "name": "useRegexpMatchAsStrongTypeHint", "arg_nums": 0, "params": [], "return_type": "boolean", "signature": "public boolean useRegexpMatchAsStrongTypeHint()", "original_string": "    public boolean useRegexpMatchAsStrongTypeHint() {\n        return useRegexpMatchAsStrongTypeHint;\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/ParameterType.java", "class_name": "ParameterType", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/ParameterType.java.ParameterType", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nIndicates whether or not this parameter provides a strong type hint when considering a\nregular expression match. If so, the type hint provided by the method arguments  will be\nignored. If not, when both type hints are in agreement, this parameter types transformer\nwill be used. Otherwise parameter transformation for a regular expression match will be\nhandled by {@link ParameterTypeRegistry#getDefaultParameterTransformer()}.\n\n@return true if this parameter type provides a type hint when considering a regular\nexpression match\n"}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/ParameterType.java.ParameterType.[ParameterType<Object>]deAnonymize(Type,Transformer<Object>)", "name": "deAnonymize", "arg_nums": 2, "params": [{"name": "type", "type": "Type"}, {"name": "transformer", "type": "Transformer<Object>"}], "return_type": "ParameterType<Object>", "signature": "ParameterType<Object> deAnonymize(Type type, Transformer<Object> transformer)", "original_string": "    ParameterType<Object> deAnonymize(Type type, Transformer<Object> transformer) {\n        return new ParameterType<>(\"anonymous\", regexps, type, new TransformerAdaptor<>(transformer), useForSnippets,\n                preferForRegexpMatch, useRegexpMatchAsStrongTypeHint, anonymous);\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/ParameterType.java", "class_name": "ParameterType", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/ParameterType.java.ParameterType", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "ParameterType<Object>", "classes": []}, "docstring": ""}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/ParameterType.java.ParameterType.[T]transform(List<String>)", "name": "transform", "arg_nums": 1, "params": [{"name": "groupValues", "type": "List<String>"}], "return_type": "T", "signature": "T transform(List<String> groupValues)", "original_string": "    T transform(List<String> groupValues) {\n        if (transformer instanceof TransformerAdaptor) {\n            if (groupValues.size() > 1) {\n                if (isAnonymous()) {\n                    throw new CucumberExpressionException(String.format(\"\" +\n                            \"Anonymous ParameterType has multiple capture groups %s. \" +\n                            \"You can only use a single capture group in an anonymous ParameterType.\", regexps));\n                }\n                throw new CucumberExpressionException(String.format(\"\" +\n                        \"ParameterType {%s} was registered with a Transformer but has multiple capture groups %s. \" +\n                        \"Did you mean to use a CaptureGroupTransformer?\", name, regexps));\n            }\n        }\n\n        try {\n            String[] groupValueArray = groupValues.toArray(new String[0]);\n            return transformer.transform(groupValueArray);\n        } catch (CucumberExpressionException e) {\n            throw e;\n        } catch (Throwable throwable) {\n            throw new CucumberExpressionException(\n                    String.format(\"ParameterType {%s} failed to transform %s to %s\", name, groupValues, type),\n                    throwable);\n        }\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/ParameterType.java", "class_name": "ParameterType", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/ParameterType.java.ParameterType", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "T", "classes": []}, "docstring": ""}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/ParameterType.java.ParameterType.[int]compareTo(ParameterType<?>)", "name": "compareTo", "arg_nums": 1, "params": [{"name": "o", "type": "ParameterType<?>"}], "return_type": "int", "signature": "@Override\n    public int compareTo(ParameterType<?> o)", "original_string": "    @Override\n    public int compareTo(ParameterType<?> o) {\n        if (preferForRegexpMatch() && !o.preferForRegexpMatch())\n            return -1;\n        if (o.preferForRegexpMatch() && !preferForRegexpMatch())\n            return 1;\n        String name = getName() != null ? getName() : \"\";\n        String otherName = o.getName() != null ? o.getName() : \"\";\n        return name.compareTo(otherName);\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/ParameterType.java", "class_name": "ParameterType", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/ParameterType.java.ParameterType", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "docstring": ""}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/ParameterType.java.ParameterType.[int]weight()", "name": "weight", "arg_nums": 0, "params": [], "return_type": "int", "signature": "public int weight()", "original_string": "    public int weight() {\n        if (this.type.equals(Integer.class) || this.type.equals(Integer.TYPE)) {\n            return 1000;\n        }\n        return 0;\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/ParameterType.java", "class_name": "ParameterType", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/ParameterType.java.ParameterType", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "docstring": ""}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/RegexpUtils.java.RegexpUtils.[String]escapeRegex(String)", "name": "escapeRegex", "arg_nums": 1, "params": [{"name": "text", "type": "String"}], "return_type": "String", "signature": "public static String escapeRegex(String text)", "original_string": "    public static String escapeRegex(String text) {\n        /*\n        Note on performance: this code has been benchmarked for\n        escaping frequencies of 100%, 50%, 20%, 10%, 1%, 0.1%.\n        Amongst 4 other variants (including Pattern matching),\n        this variant is the faster on all escaping frequencies.\n        */\n        int length = text.length();\n        StringBuilder sb = null; // lazy initialization\n        int blockStart = 0;\n        int maxChar = CHAR_TO_ESCAPE.length;\n        for (int i = 0; i < length; i++) {\n            char currentChar = text.charAt(i);\n            if (currentChar < maxChar && CHAR_TO_ESCAPE[currentChar]) {\n                if (sb == null) {\n                    sb = new StringBuilder(length * 2);\n                }\n                if (blockStart < i) {\n                    // flush previous block\n                    sb.append(text, blockStart, i);\n                }\n                sb.append('\\\\');\n                sb.append(currentChar);\n                blockStart = i + 1;\n            }\n        }\n        if (sb != null) {\n            // finalizing character escaping\n            if (blockStart < length) {\n                // flush remaining characters\n                sb.append(text, blockStart, length);\n            }\n            return sb.toString();\n        }\n        return text;\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/RegexpUtils.java", "class_name": "RegexpUtils", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/RegexpUtils.java.RegexpUtils", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "String", "classes": []}, "docstring": "\nEscapes the regexp characters (the ones from \"^$(){}[].+*?\\\")\nfrom the given text, so that they are not considered as regexp\ncharacters.\n\n@param text the non-null input text\n@return the input text with escaped regexp characters\n"}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/Group.java.Group.[]Group(String,int,int,List<Group>)", "name": "Group", "arg_nums": 4, "params": [{"name": "value", "type": "String"}, {"name": "start", "type": "int"}, {"name": "end", "type": "int"}, {"name": "children", "type": "List<Group>"}], "return_type": "", "signature": "Group(String value, int start, int end, List<Group> children)", "original_string": "    Group(String value, int start, int end, List<Group> children) {\n        this.value = value;\n        this.start = start;\n        this.end = end;\n        this.children = children;\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/Group.java", "class_name": "Group", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/Group.java.Group", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "docstring": ""}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/Group.java.Group.[String]getValue()", "name": "getValue", "arg_nums": 0, "params": [], "return_type": "String", "signature": "public String getValue()", "original_string": "    public String getValue() {\n        return value;\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/Group.java", "class_name": "Group", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/Group.java.Group", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "docstring": ""}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/Group.java.Group.[int]getStart()", "name": "getStart", "arg_nums": 0, "params": [], "return_type": "int", "signature": "public int getStart()", "original_string": "    public int getStart() {\n        return start;\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/Group.java", "class_name": "Group", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/Group.java.Group", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "docstring": ""}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/Group.java.Group.[int]getEnd()", "name": "getEnd", "arg_nums": 0, "params": [], "return_type": "int", "signature": "public int getEnd()", "original_string": "    public int getEnd() {\n        return end;\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/Group.java", "class_name": "Group", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/Group.java.Group", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "docstring": ""}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/Group.java.Group.[List<Group>]getChildren()", "name": "getChildren", "arg_nums": 0, "params": [], "return_type": "List<Group>", "signature": "public List<Group> getChildren()", "original_string": "    public List<Group> getChildren() {\n        return children;\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/Group.java", "class_name": "Group", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/Group.java.Group", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "List<Group>", "classes": []}, "docstring": ""}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/Group.java.Group.[List<String>]getValues()", "name": "getValues", "arg_nums": 0, "params": [], "return_type": "List<String>", "signature": "public List<String> getValues()", "original_string": "    public List<String> getValues() {\n        List<Group> groups = getChildren().isEmpty() ? singletonList(this) : getChildren();\n        return groups.stream()\n                .map(Group::getValue)\n                .collect(Collectors.toList());\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/Group.java", "class_name": "Group", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/Group.java.Group", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "List<String>", "classes": []}, "docstring": ""}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/Group.java.Group.[Collection<Group>]parse(Pattern)", "name": "parse", "arg_nums": 1, "params": [{"name": "expression", "type": "Pattern"}], "return_type": "Collection<Group>", "signature": "public static Collection<Group> parse(Pattern expression)", "original_string": "    public static Collection<Group> parse(Pattern expression) {\n        GroupBuilder builder = TreeRegexp.createGroupBuilder(expression);\n        return toGroups(builder.getChildren());\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/Group.java", "class_name": "Group", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/Group.java.Group", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Collection<Group>", "classes": []}, "docstring": "\nParse a {@link Pattern} into collection of {@link Group}s\n\n@param expression the expression to decompose\n@return A collection of {@link Group}s, possibly empty but never\n        <code>null</code>\n"}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/Group.java.Group.[List<Group>]toGroups(List<GroupBuilder>)", "name": "toGroups", "arg_nums": 1, "params": [{"name": "children", "type": "List<GroupBuilder>"}], "return_type": "List<Group>", "signature": "private static List<Group> toGroups(List<GroupBuilder> children)", "original_string": "    private static List<Group> toGroups(List<GroupBuilder> children) {\n        List<Group> list = new ArrayList<>();\n        if (children != null) {\n            for (GroupBuilder child : children) {\n                list.add(new Group(child.getSource(), child.getStartIndex(), child.getEndIndex(),\n                        toGroups(child.getChildren())));\n            }\n        }\n        return list;\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/Group.java", "class_name": "Group", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/Group.java.Group", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "List<Group>", "classes": []}, "docstring": ""}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/TreeRegexp.java.TreeRegexp.[]TreeRegexp(String)", "name": "TreeRegexp", "arg_nums": 1, "params": [{"name": "regexp", "type": "String"}], "return_type": "", "signature": "TreeRegexp(String regexp)", "original_string": "    TreeRegexp(String regexp) {\n        this(PatternCompilerProvider.getCompiler().compile(regexp, Pattern.UNICODE_CHARACTER_CLASS));\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/TreeRegexp.java", "class_name": "TreeRegexp", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/TreeRegexp.java.TreeRegexp", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "docstring": ""}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/TreeRegexp.java.TreeRegexp.[]TreeRegexp(Pattern)", "name": "TreeRegexp", "arg_nums": 1, "params": [{"name": "pattern", "type": "Pattern"}], "return_type": "", "signature": "TreeRegexp(Pattern pattern)", "original_string": "    TreeRegexp(Pattern pattern) {\n        this.pattern = pattern;\n        this.groupBuilder = createGroupBuilder(pattern);\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/TreeRegexp.java", "class_name": "TreeRegexp", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/TreeRegexp.java.TreeRegexp", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "docstring": ""}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/TreeRegexp.java.TreeRegexp.[GroupBuilder]createGroupBuilder(Pattern)", "name": "createGroupBuilder", "arg_nums": 1, "params": [{"name": "pattern", "type": "Pattern"}], "return_type": "GroupBuilder", "signature": "static GroupBuilder createGroupBuilder(Pattern pattern)", "original_string": "    static GroupBuilder createGroupBuilder(Pattern pattern) {\n        String source = pattern.pattern();\n        Deque<GroupBuilder> stack = new ArrayDeque<>(singleton(new GroupBuilder(0)));\n        boolean escaping = false;\n        boolean charClass = false;\n\n        for (int i = 0; i < source.length(); i++) {\n            char c = source.charAt(i);\n            if (c == '[' && !escaping) {\n                charClass = true;\n            } else if (c == ']' && !escaping) {\n                charClass = false;\n            } else if (c == '(' && !escaping && !charClass) {\n                boolean nonCapturing = isNonCapturingGroup(source, i);\n                GroupBuilder groupBuilder = new GroupBuilder(i);\n                if (nonCapturing) {\n                    groupBuilder.setNonCapturing();\n                }\n                stack.push(groupBuilder);\n            } else if (c == ')' && !escaping && !charClass) {\n                GroupBuilder gb = stack.pop();\n                if (gb.isCapturing()) {\n                    gb.setSource(source.substring(gb.getStartIndex() + 1, i));\n                    stack.peek().add(gb);\n                } else {\n                    gb.moveChildrenTo(stack.peek());\n                }\n                gb.setEndIndex(i);\n            }\n            escaping = c == '\\\\' && !escaping;\n        }\n        return stack.pop();\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/TreeRegexp.java", "class_name": "TreeRegexp", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/TreeRegexp.java.TreeRegexp", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "GroupBuilder", "classes": []}, "docstring": ""}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/TreeRegexp.java.TreeRegexp.[boolean]isNonCapturingGroup(String,int)", "name": "isNonCapturingGroup", "arg_nums": 2, "params": [{"name": "source", "type": "String"}, {"name": "i", "type": "int"}], "return_type": "boolean", "signature": "private static boolean isNonCapturingGroup(String source, int i)", "original_string": "    private static boolean isNonCapturingGroup(String source, int i) {\n        // Regex is valid. Bounds check not required.\n        if (source.charAt(i+1) != '?') {\n            // (X)\n            return false;\n        }\n        if (source.charAt(i+2) != '<') {\n            // (?:X)\n            // (?idmsuxU-idmsuxU)\n            // (?idmsux-idmsux:X)\n            // (?=X)\n            // (?!X)\n            // (?>X)\n            return true;\n        }\n        // (?<=X) or (?<!X) else (?<name>X)\n        return source.charAt(i + 3) == '=' || source.charAt(i + 3) == '!';\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/TreeRegexp.java", "class_name": "TreeRegexp", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/TreeRegexp.java.TreeRegexp", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": ""}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/TreeRegexp.java.TreeRegexp.[Pattern]pattern()", "name": "pattern", "arg_nums": 0, "params": [], "return_type": "Pattern", "signature": "Pattern pattern()", "original_string": "    Pattern pattern() {\n        return pattern;\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/TreeRegexp.java", "class_name": "TreeRegexp", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/TreeRegexp.java.TreeRegexp", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "Pattern", "classes": []}, "docstring": ""}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/TreeRegexp.java.TreeRegexp.[Group]match(CharSequence)", "name": "match", "arg_nums": 1, "params": [{"name": "s", "type": "CharSequence"}], "return_type": "Group", "signature": "Group match(CharSequence s)", "original_string": "    Group match(CharSequence s) {\n        final Matcher matcher = pattern.matcher(s);\n        if (!matcher.matches())\n            return null;\n        return groupBuilder.build(matcher, IntStream.rangeClosed(0, matcher.groupCount()).iterator());\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/TreeRegexp.java", "class_name": "TreeRegexp", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/TreeRegexp.java.TreeRegexp", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "Group", "classes": []}, "docstring": ""}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/TreeRegexp.java.TreeRegexp.[GroupBuilder]getGroupBuilder()", "name": "getGroupBuilder", "arg_nums": 0, "params": [], "return_type": "GroupBuilder", "signature": "public GroupBuilder getGroupBuilder()", "original_string": "    public GroupBuilder getGroupBuilder() {\n        return groupBuilder;\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/TreeRegexp.java", "class_name": "TreeRegexp", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/TreeRegexp.java.TreeRegexp", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "GroupBuilder", "classes": []}, "docstring": ""}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/PatternCompiler.java.PatternCompiler.[Pattern]compile(String,int)", "name": "compile", "arg_nums": 2, "params": [{"name": "regexp", "type": "String"}, {"name": "flags", "type": "int"}], "return_type": "Pattern", "signature": "Pattern compile(String regexp, int flags)", "original_string": "    Pattern compile(String regexp, int flags);", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/PatternCompiler.java", "class_name": "PatternCompiler", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/PatternCompiler.java.PatternCompiler", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "Pattern", "classes": []}, "docstring": "\n@param regexp regular expression\n@param flags  additional flags (e.g. {@link Pattern#UNICODE_CHARACTER_CLASS})\n@return new {@link Pattern} instance from provided {@code regexp}\n"}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/DuplicateTypeNameException.java.DuplicateTypeNameException.[]DuplicateTypeNameException(String)", "name": "DuplicateTypeNameException", "arg_nums": 1, "params": [{"name": "message", "type": "String"}], "return_type": "", "signature": "DuplicateTypeNameException(String message)", "original_string": "    DuplicateTypeNameException(String message) {\n        super(message);\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/DuplicateTypeNameException.java", "class_name": "DuplicateTypeNameException", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/DuplicateTypeNameException.java.DuplicateTypeNameException", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "docstring": ""}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/Expression.java.Expression.[List<Argument<?>>]match(String)", "name": "match", "arg_nums": 1, "params": [{"name": "text", "type": "String"}], "return_type": "List<Argument<?>>", "signature": "List<Argument<?>> match(String text, Type... typeHints)", "original_string": "    List<Argument<?>> match(String text, Type... typeHints);", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/Expression.java", "class_name": "Expression", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/Expression.java.Expression", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "List<Argument<?>>", "classes": []}, "docstring": ""}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/Expression.java.Expression.[Pattern]getRegexp()", "name": "getRegexp", "arg_nums": 0, "params": [], "return_type": "Pattern", "signature": "Pattern getRegexp()", "original_string": "    Pattern getRegexp();", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/Expression.java", "class_name": "Expression", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/Expression.java.Expression", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "Pattern", "classes": []}, "docstring": ""}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/Expression.java.Expression.[String]getSource()", "name": "getSource", "arg_nums": 0, "params": [], "return_type": "String", "signature": "String getSource()", "original_string": "    String getSource();", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/Expression.java", "class_name": "Expression", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/Expression.java.Expression", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "String", "classes": []}, "docstring": ""}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/Argument.java.Argument.[List<Argument<?>>]build(Group,List<ParameterType<?>>)", "name": "build", "arg_nums": 2, "params": [{"name": "group", "type": "Group"}, {"name": "parameterTypes", "type": "List<ParameterType<?>>"}], "return_type": "List<Argument<?>>", "signature": "static List<Argument<?>> build(Group group, List<ParameterType<?>> parameterTypes)", "original_string": "    static List<Argument<?>> build(Group group, List<ParameterType<?>> parameterTypes) {\n        List<Group> argGroups = group.getChildren();\n\n        if (argGroups.size() != parameterTypes.size()) {\n            // This requires regex injection through a Cucumber expression.\n            // Regex injection should be be possible any more.\n            throw new IllegalArgumentException(String.format(\"Group has %s capture groups, but there were %s parameter types\", argGroups.size(), parameterTypes.size()));\n        }\n        List<Argument<?>> args = new ArrayList<>(argGroups.size());\n        for (int i = 0; i < parameterTypes.size(); i++) {\n            Group argGroup = argGroups.get(i);\n            ParameterType<?> parameterType = parameterTypes.get(i);\n            args.add(new Argument<>(argGroup, parameterType));\n        }\n\n        return args;\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/Argument.java", "class_name": "Argument", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/Argument.java.Argument", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "List<Argument<?>>", "classes": []}, "docstring": ""}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/Argument.java.Argument.[]Argument(Group,ParameterType<T>)", "name": "Argument", "arg_nums": 2, "params": [{"name": "group", "type": "Group"}, {"name": "parameterType", "type": "ParameterType<T>"}], "return_type": "", "signature": "private Argument(Group group, ParameterType<T> parameterType)", "original_string": "    private Argument(Group group, ParameterType<T> parameterType) {\n        this.group = group;\n        this.parameterType = parameterType;\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/Argument.java", "class_name": "Argument", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/Argument.java.Argument", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "", "classes": []}, "docstring": ""}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/Argument.java.Argument.[Group]getGroup()", "name": "getGroup", "arg_nums": 0, "params": [], "return_type": "Group", "signature": "public Group getGroup()", "original_string": "    public Group getGroup() {\n        return group;\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/Argument.java", "class_name": "Argument", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/Argument.java.Argument", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Group", "classes": []}, "docstring": ""}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/Argument.java.Argument.[T]getValue()", "name": "getValue", "arg_nums": 0, "params": [], "return_type": "T", "signature": "public T getValue()", "original_string": "    public T getValue() {\n        return parameterType.transform(group.getValues());\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/Argument.java", "class_name": "Argument", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/Argument.java.Argument", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "T", "classes": []}, "docstring": ""}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/Argument.java.Argument.[Type]getType()", "name": "getType", "arg_nums": 0, "params": [], "return_type": "Type", "signature": "public Type getType()", "original_string": "    public Type getType() {\n        return parameterType.getType();\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/Argument.java", "class_name": "Argument", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/Argument.java.Argument", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Type", "classes": []}, "docstring": ""}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/Argument.java.Argument.[ParameterType<T>]getParameterType()", "name": "getParameterType", "arg_nums": 0, "params": [], "return_type": "ParameterType<T>", "signature": "public ParameterType<T> getParameterType()", "original_string": "    public ParameterType<T> getParameterType() {\n        return parameterType;\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/Argument.java", "class_name": "Argument", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/Argument.java.Argument", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ParameterType<T>", "classes": []}, "docstring": ""}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/CombinatorialGeneratedExpressionFactory.java.CombinatorialGeneratedExpressionFactory.[]CombinatorialGeneratedExpressionFactory(String,List<List<ParameterType<?>>>)", "name": "CombinatorialGeneratedExpressionFactory", "arg_nums": 2, "params": [{"name": "expressionTemplate", "type": "String"}, {"name": "parameterTypeCombinations", "type": "List<List<ParameterType<?>>>"}], "return_type": "", "signature": "CombinatorialGeneratedExpressionFactory(\n            String expressionTemplate,\n            List<List<ParameterType<?>>> parameterTypeCombinations)", "original_string": "    CombinatorialGeneratedExpressionFactory(\n            String expressionTemplate,\n            List<List<ParameterType<?>>> parameterTypeCombinations) {\n\n        this.expressionTemplate = expressionTemplate;\n        this.parameterTypeCombinations = parameterTypeCombinations;\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/CombinatorialGeneratedExpressionFactory.java", "class_name": "CombinatorialGeneratedExpressionFactory", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/CombinatorialGeneratedExpressionFactory.java.CombinatorialGeneratedExpressionFactory", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "docstring": ""}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/CombinatorialGeneratedExpressionFactory.java.CombinatorialGeneratedExpressionFactory.[List<GeneratedExpression>]generateExpressions()", "name": "generateExpressions", "arg_nums": 0, "params": [], "return_type": "List<GeneratedExpression>", "signature": "List<GeneratedExpression> generateExpressions()", "original_string": "    List<GeneratedExpression> generateExpressions() {\n        List<GeneratedExpression> generatedExpressions = new ArrayList<>();\n        ArrayDeque<ParameterType<?>> permutation = new ArrayDeque<>(parameterTypeCombinations.size());\n        generatePermutations(generatedExpressions, permutation);\n        return generatedExpressions;\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/CombinatorialGeneratedExpressionFactory.java", "class_name": "CombinatorialGeneratedExpressionFactory", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/CombinatorialGeneratedExpressionFactory.java.CombinatorialGeneratedExpressionFactory", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "List<GeneratedExpression>", "classes": []}, "docstring": ""}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/CombinatorialGeneratedExpressionFactory.java.CombinatorialGeneratedExpressionFactory.[void]generatePermutations(List<GeneratedExpression>,Deque<ParameterType<?>>)", "name": "generatePermutations", "arg_nums": 2, "params": [{"name": "generatedExpressions", "type": "List<GeneratedExpression>"}, {"name": "permutation", "type": "Deque<ParameterType<?>>"}], "return_type": "void", "signature": "private void generatePermutations(\n            List<GeneratedExpression> generatedExpressions,\n            Deque<ParameterType<?>> permutation\n    )", "original_string": "    private void generatePermutations(\n            List<GeneratedExpression> generatedExpressions,\n            Deque<ParameterType<?>> permutation\n    ) {\n        if (generatedExpressions.size() >= MAX_EXPRESSIONS) {\n            return;\n        }\n\n        if (permutation.size() == parameterTypeCombinations.size()) {\n            ArrayList<ParameterType<?>> permutationCopy = new ArrayList<>(permutation);\n            generatedExpressions.add(new GeneratedExpression(expressionTemplate, permutationCopy));\n            return;\n        }\n\n        List<ParameterType<?>> parameterTypes = parameterTypeCombinations.get(permutation.size());\n        for (ParameterType<?> parameterType : parameterTypes) {\n            // Avoid recursion if no elements can be added.\n            if (generatedExpressions.size() >= MAX_EXPRESSIONS) {\n                return;\n            }\n            permutation.addLast(parameterType);\n            generatePermutations(generatedExpressions, permutation);\n            permutation.removeLast();\n        }\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/CombinatorialGeneratedExpressionFactory.java", "class_name": "CombinatorialGeneratedExpressionFactory", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/CombinatorialGeneratedExpressionFactory.java.CombinatorialGeneratedExpressionFactory", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/ParameterByTypeTransformer.java.ParameterByTypeTransformer.[Object]transform(String,Type)", "name": "transform", "arg_nums": 2, "params": [{"name": "fromValue", "type": "String"}, {"name": "toValueType", "type": "Type"}], "return_type": "Object", "signature": "Object transform(String fromValue, Type toValueType)", "original_string": "    Object transform(String fromValue, Type toValueType) throws Throwable;", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/ParameterByTypeTransformer.java", "class_name": "ParameterByTypeTransformer", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/ParameterByTypeTransformer.java.ParameterByTypeTransformer", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "Object", "classes": []}, "docstring": ""}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/CucumberExpressionGenerator.java.CucumberExpressionGenerator.[]CucumberExpressionGenerator(ParameterTypeRegistry)", "name": "CucumberExpressionGenerator", "arg_nums": 1, "params": [{"name": "parameterTypeRegistry", "type": "ParameterTypeRegistry"}], "return_type": "", "signature": "public CucumberExpressionGenerator(ParameterTypeRegistry parameterTypeRegistry)", "original_string": "    public CucumberExpressionGenerator(ParameterTypeRegistry parameterTypeRegistry) {\n        this.parameterTypeRegistry = parameterTypeRegistry;\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/CucumberExpressionGenerator.java", "class_name": "CucumberExpressionGenerator", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/CucumberExpressionGenerator.java.CucumberExpressionGenerator", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": ""}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/CucumberExpressionGenerator.java.CucumberExpressionGenerator.[List<GeneratedExpression>]generateExpressions(String)", "name": "generateExpressions", "arg_nums": 1, "params": [{"name": "text", "type": "String"}], "return_type": "List<GeneratedExpression>", "signature": "public List<GeneratedExpression> generateExpressions(String text)", "original_string": "    public List<GeneratedExpression> generateExpressions(String text) {\n        List<List<ParameterType<?>>> parameterTypeCombinations = new ArrayList<>();\n        List<ParameterTypeMatcher> parameterTypeMatchers = createParameterTypeMatchers(text);\n        StringBuilder expressionTemplate = new StringBuilder();\n        int pos = 0;\n        while (true) {\n            List<ParameterTypeMatcher> matchingParameterTypeMatchers = new ArrayList<>();\n\n            for (ParameterTypeMatcher parameterTypeMatcher : parameterTypeMatchers) {\n                if (parameterTypeMatcher.advanceToAndFind(pos)) {\n                    matchingParameterTypeMatchers.add(parameterTypeMatcher);\n                }\n            }\n\n            if (!matchingParameterTypeMatchers.isEmpty()) {\n                Collections.sort(matchingParameterTypeMatchers);\n\n                // Find all the best parameter type matchers, they are all candidates.\n                ParameterTypeMatcher bestParameterTypeMatcher = matchingParameterTypeMatchers.get(0);\n                List<ParameterTypeMatcher> bestParameterTypeMatchers = new ArrayList<>();\n                for (ParameterTypeMatcher m : matchingParameterTypeMatchers) {\n                    if (m.compareTo(bestParameterTypeMatcher) == 0) {\n                        bestParameterTypeMatchers.add(m);\n                    }\n                }\n\n                // Build a list of parameter types without duplicates. The reason there\n                // might be duplicates is that some parameter types have more than one regexp,\n                // which means multiple ParameterTypeMatcher objects will have a reference to the\n                // same ParameterType.\n                // We're sorting the list so preferential parameter types are listed first.\n                // Users are most likely to want these, so they should be listed at the top.\n                Set<ParameterType<?>> set = new HashSet<>();\n                for (ParameterTypeMatcher parameterTypeMatcher : bestParameterTypeMatchers) {\n                    ParameterType<?> parameterType = parameterTypeMatcher.getParameterType();\n                    set.add(parameterType);\n                }\n                SortedSet<ParameterType<?>> parameterTypes = new TreeSet<>(set);\n\n                parameterTypeCombinations.add(new ArrayList<>(parameterTypes));\n\n                expressionTemplate\n                        .append(escape(text.substring(pos, bestParameterTypeMatcher.start())))\n                        .append(\"{%s}\");\n                pos = bestParameterTypeMatcher.start() + bestParameterTypeMatcher.group().length();\n            } else {\n                break;\n            }\n\n            if (pos >= text.length()) {\n                break;\n            }\n        }\n        expressionTemplate.append(escape(text.substring(pos)));\n        return new CombinatorialGeneratedExpressionFactory(expressionTemplate.toString(), parameterTypeCombinations).generateExpressions();\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/CucumberExpressionGenerator.java", "class_name": "CucumberExpressionGenerator", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/CucumberExpressionGenerator.java.CucumberExpressionGenerator", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "List<GeneratedExpression>", "classes": []}, "docstring": ""}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/CucumberExpressionGenerator.java.CucumberExpressionGenerator.[String]escape(String)", "name": "escape", "arg_nums": 1, "params": [{"name": "s", "type": "String"}], "return_type": "String", "signature": "private String escape(String s)", "original_string": "    private String escape(String s) {\n        return s.replaceAll(\"%\", \"%%\") // Escape for String.format\n                .replaceAll(\"\\\\(\", \"\\\\\\\\(\")\n                .replaceAll(\"\\\\{\", \"\\\\\\\\{\")\n                .replaceAll(\"/\", \"\\\\\\\\/\");\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/CucumberExpressionGenerator.java", "class_name": "CucumberExpressionGenerator", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/CucumberExpressionGenerator.java.CucumberExpressionGenerator", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "String", "classes": []}, "docstring": ""}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/CucumberExpressionGenerator.java.CucumberExpressionGenerator.[List<ParameterTypeMatcher>]createParameterTypeMatchers(String)", "name": "createParameterTypeMatchers", "arg_nums": 1, "params": [{"name": "text", "type": "String"}], "return_type": "List<ParameterTypeMatcher>", "signature": "private List<ParameterTypeMatcher> createParameterTypeMatchers(String text)", "original_string": "    private List<ParameterTypeMatcher> createParameterTypeMatchers(String text) {\n        Collection<ParameterType<?>> parameterTypes = parameterTypeRegistry.getParameterTypes();\n        List<ParameterTypeMatcher> parameterTypeMatchers = new ArrayList<>();\n        for (ParameterType<?> parameterType : parameterTypes) {\n            if (parameterType.useForSnippets()) {\n                parameterTypeMatchers.addAll(createParameterTypeMatchers(parameterType, text));\n            }\n        }\n        return parameterTypeMatchers;\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/CucumberExpressionGenerator.java", "class_name": "CucumberExpressionGenerator", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/CucumberExpressionGenerator.java.CucumberExpressionGenerator", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "List<ParameterTypeMatcher>", "classes": []}, "docstring": ""}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/CucumberExpressionGenerator.java.CucumberExpressionGenerator.[List<ParameterTypeMatcher>]createParameterTypeMatchers(ParameterType<?>,String)", "name": "createParameterTypeMatchers", "arg_nums": 2, "params": [{"name": "parameterType", "type": "ParameterType<?>"}, {"name": "text", "type": "String"}], "return_type": "List<ParameterTypeMatcher>", "signature": "private static List<ParameterTypeMatcher> createParameterTypeMatchers(ParameterType<?> parameterType, String text)", "original_string": "    private static List<ParameterTypeMatcher> createParameterTypeMatchers(ParameterType<?> parameterType, String text) {\n        List<ParameterTypeMatcher> result = new ArrayList<>();\n        List<String> captureGroupRegexps = parameterType.getRegexps();\n        for (String captureGroupRegexp : captureGroupRegexps) {\n            Pattern regexp = Pattern.compile(\"(\" + captureGroupRegexp + \")\");\n            Matcher matcher = regexp.matcher(text);\n            result.add(new ParameterTypeMatcher(parameterType, matcher, text));\n        }\n        return result;\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/CucumberExpressionGenerator.java", "class_name": "CucumberExpressionGenerator", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/CucumberExpressionGenerator.java.CucumberExpressionGenerator", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "List<ParameterTypeMatcher>", "classes": []}, "docstring": ""}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/AmbiguousParameterTypeException.java.AmbiguousParameterTypeException.[]AmbiguousParameterTypeException(String,Pattern,SortedSet<ParameterType<?>>,List<GeneratedExpression>)", "name": "AmbiguousParameterTypeException", "arg_nums": 4, "params": [{"name": "parameterTypeRegexp", "type": "String"}, {"name": "expressionRegexp", "type": "Pattern"}, {"name": "parameterTypes", "type": "SortedSet<ParameterType<?>>"}, {"name": "generatedExpressions", "type": "List<GeneratedExpression>"}], "return_type": "", "signature": "AmbiguousParameterTypeException(String parameterTypeRegexp, Pattern expressionRegexp, SortedSet<ParameterType<?>> parameterTypes, List<GeneratedExpression> generatedExpressions)", "original_string": "    AmbiguousParameterTypeException(String parameterTypeRegexp, Pattern expressionRegexp, SortedSet<ParameterType<?>> parameterTypes, List<GeneratedExpression> generatedExpressions) {\n        super(String.format(\"Your Regular Expression /%s/\\n\" +\n                        \"matches multiple parameter types with regexp /%s/:\\n\" +\n                        \"   %s\\n\" +\n                        \"\\n\" +\n                        \"I couldn't decide which one to use. You have two options:\\n\" +\n                        \"\\n\" +\n                        \"1) Use a Cucumber Expression instead of a Regular Expression. Try one of these:\\n\" +\n                        \"   %s\\n\" +\n                        \"\\n\" +\n                        \"2) Make one of the parameter types preferential and continue to use a Regular Expression.\\n\" +\n                        \"\\n\",\n                expressionRegexp.pattern(),\n                parameterTypeRegexp,\n                parameterTypeNames(parameterTypes),\n                expressions(generatedExpressions)\n        ));\n        this.regexp = expressionRegexp;\n        this.parameterTypeRegexp = parameterTypeRegexp;\n        this.parameterTypes = parameterTypes;\n        this.generatedExpressions = generatedExpressions;\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/AmbiguousParameterTypeException.java", "class_name": "AmbiguousParameterTypeException", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/AmbiguousParameterTypeException.java.AmbiguousParameterTypeException", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "docstring": ""}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/AmbiguousParameterTypeException.java.AmbiguousParameterTypeException.[String]parameterTypeNames(SortedSet<ParameterType<?>>)", "name": "parameterTypeNames", "arg_nums": 1, "params": [{"name": "parameterTypes", "type": "SortedSet<ParameterType<?>>"}], "return_type": "String", "signature": "private static String parameterTypeNames(SortedSet<ParameterType<?>> parameterTypes)", "original_string": "    private static String parameterTypeNames(SortedSet<ParameterType<?>> parameterTypes) {\n\n        List<String> parameterNames = new ArrayList<>();\n        for (ParameterType<?> p : parameterTypes) {\n            String s = \"{\" + p.getName() + \"}\";\n            parameterNames.add(s);\n        }\n        return join(parameterNames);\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/AmbiguousParameterTypeException.java", "class_name": "AmbiguousParameterTypeException", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/AmbiguousParameterTypeException.java.AmbiguousParameterTypeException", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "String", "classes": []}, "docstring": ""}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/AmbiguousParameterTypeException.java.AmbiguousParameterTypeException.[String]expressions(List<GeneratedExpression>)", "name": "expressions", "arg_nums": 1, "params": [{"name": "generatedExpressions", "type": "List<GeneratedExpression>"}], "return_type": "String", "signature": "private static String expressions(List<GeneratedExpression> generatedExpressions)", "original_string": "    private static String expressions(List<GeneratedExpression> generatedExpressions) {\n        List<String> sources = new ArrayList<>();\n        for (GeneratedExpression generatedExpression : generatedExpressions) {\n            String source = generatedExpression.getSource();\n            sources.add(source);\n        }\n        return join(sources);\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/AmbiguousParameterTypeException.java", "class_name": "AmbiguousParameterTypeException", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/AmbiguousParameterTypeException.java.AmbiguousParameterTypeException", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "String", "classes": []}, "docstring": ""}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/AmbiguousParameterTypeException.java.AmbiguousParameterTypeException.[String]join(List<String>)", "name": "join", "arg_nums": 1, "params": [{"name": "strings", "type": "List<String>"}], "return_type": "String", "signature": "private static String join(List<String> strings)", "original_string": "    private static String join(List<String> strings) {\n        StringBuilder builder = new StringBuilder();\n        boolean first = true;\n        for (String element : strings) {\n            if (first) {\n                first = false;\n            } else {\n                builder.append(\"\\n   \");\n            }\n            builder.append(element);\n        }\n\n        return builder.toString();\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/AmbiguousParameterTypeException.java", "class_name": "AmbiguousParameterTypeException", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/AmbiguousParameterTypeException.java.AmbiguousParameterTypeException", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "String", "classes": []}, "docstring": ""}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/AmbiguousParameterTypeException.java.AmbiguousParameterTypeException.[Pattern]getRegexp()", "name": "getRegexp", "arg_nums": 0, "params": [], "return_type": "Pattern", "signature": "public Pattern getRegexp()", "original_string": "    public Pattern getRegexp() {\n        return regexp;\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/AmbiguousParameterTypeException.java", "class_name": "AmbiguousParameterTypeException", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/AmbiguousParameterTypeException.java.AmbiguousParameterTypeException", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Pattern", "classes": []}, "docstring": ""}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/AmbiguousParameterTypeException.java.AmbiguousParameterTypeException.[String]getParameterTypeRegexp()", "name": "getParameterTypeRegexp", "arg_nums": 0, "params": [], "return_type": "String", "signature": "public String getParameterTypeRegexp()", "original_string": "    public String getParameterTypeRegexp() {\n        return parameterTypeRegexp;\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/AmbiguousParameterTypeException.java", "class_name": "AmbiguousParameterTypeException", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/AmbiguousParameterTypeException.java.AmbiguousParameterTypeException", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "docstring": ""}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/AmbiguousParameterTypeException.java.AmbiguousParameterTypeException.[SortedSet<ParameterType<?>>]getParameterTypes()", "name": "getParameterTypes", "arg_nums": 0, "params": [], "return_type": "SortedSet<ParameterType<?>>", "signature": "public SortedSet<ParameterType<?>> getParameterTypes()", "original_string": "    public SortedSet<ParameterType<?>> getParameterTypes() {\n        return parameterTypes;\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/AmbiguousParameterTypeException.java", "class_name": "AmbiguousParameterTypeException", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/AmbiguousParameterTypeException.java.AmbiguousParameterTypeException", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "SortedSet<ParameterType<?>>", "classes": []}, "docstring": ""}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/AmbiguousParameterTypeException.java.AmbiguousParameterTypeException.[List<GeneratedExpression>]getGeneratedExpressions()", "name": "getGeneratedExpressions", "arg_nums": 0, "params": [], "return_type": "List<GeneratedExpression>", "signature": "public List<GeneratedExpression> getGeneratedExpressions()", "original_string": "    public List<GeneratedExpression> getGeneratedExpressions() {\n        return generatedExpressions;\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/AmbiguousParameterTypeException.java", "class_name": "AmbiguousParameterTypeException", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/AmbiguousParameterTypeException.java.AmbiguousParameterTypeException", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "List<GeneratedExpression>", "classes": []}, "docstring": ""}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/Transformer.java.Transformer.[T]transform(String)", "name": "transform", "arg_nums": 1, "params": [{"name": "arg", "type": "String"}], "return_type": "T", "signature": "T transform(String arg)", "original_string": "    T transform(String arg) throws Throwable;", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/Transformer.java", "class_name": "Transformer", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/Transformer.java.Transformer", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "T", "classes": []}, "docstring": "\nTransforms a string into to an object. The string is either taken\nfrom the sole capture group or matches the whole expression. Nested\ncapture groups are ignored.\n<p>\nIf the capture group is optional <code>arg</code> may be null.\n\n@param arg the value of the single capture group\n@return the transformed object\n@throws Throwable if transformation failed\n"}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/TypeReference.java.TypeReference.[]TypeReference()", "name": "TypeReference", "arg_nums": 0, "params": [], "return_type": "", "signature": "protected TypeReference()", "original_string": "    protected TypeReference() {\n        Type superclass = getClass().getGenericSuperclass();\n        if (superclass instanceof Class) {\n            throw new CucumberExpressionException(\"Missing type parameter: \" + superclass);\n        }\n        this.type = ((ParameterizedType) superclass).getActualTypeArguments()[0];\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/TypeReference.java", "class_name": "TypeReference", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/TypeReference.java.TypeReference", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "", "classes": []}, "docstring": ""}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/TypeReference.java.TypeReference.[Type]getType()", "name": "getType", "arg_nums": 0, "params": [], "return_type": "Type", "signature": "public Type getType()", "original_string": "    public Type getType() {\n        return this.type;\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/TypeReference.java", "class_name": "TypeReference", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/TypeReference.java.TypeReference", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Type", "classes": []}, "docstring": ""}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/CucumberExpressionTokenizer.java.CucumberExpressionTokenizer.[List<Token>]tokenize(String)", "name": "tokenize", "arg_nums": 1, "params": [{"name": "expression", "type": "String"}], "return_type": "List<Token>", "signature": "List<Token> tokenize(String expression)", "original_string": "    List<Token> tokenize(String expression) {\n        List<Token> tokens = new ArrayList<>();\n        tokenizeImpl(expression).forEach(tokens::add);\n        return tokens;\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/CucumberExpressionTokenizer.java", "class_name": "CucumberExpressionTokenizer", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/CucumberExpressionTokenizer.java.CucumberExpressionTokenizer", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "List<Token>", "classes": []}, "docstring": ""}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/CucumberExpressionTokenizer.java.CucumberExpressionTokenizer.[Iterable<Token>]tokenizeImpl(String)", "name": "tokenizeImpl", "arg_nums": 1, "params": [{"name": "expression", "type": "String"}], "return_type": "Iterable<Token>", "signature": "private Iterable<Token> tokenizeImpl(String expression)", "original_string": "    private Iterable<Token> tokenizeImpl(String expression) {\n        return () -> new TokenIterator(expression);\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/CucumberExpressionTokenizer.java", "class_name": "CucumberExpressionTokenizer", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/CucumberExpressionTokenizer.java.CucumberExpressionTokenizer", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "Iterable<Token>", "classes": []}, "docstring": ""}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/RegularExpression.java.RegularExpression.[]RegularExpression(Pattern,ParameterTypeRegistry)", "name": "RegularExpression", "arg_nums": 2, "params": [{"name": "expressionRegexp", "type": "Pattern"}, {"name": "parameterTypeRegistry", "type": "ParameterTypeRegistry"}], "return_type": "", "signature": "RegularExpression(Pattern expressionRegexp, ParameterTypeRegistry parameterTypeRegistry)", "original_string": "    RegularExpression(Pattern expressionRegexp, ParameterTypeRegistry parameterTypeRegistry) {\n        this.expressionRegexp = expressionRegexp;\n        this.parameterTypeRegistry = parameterTypeRegistry;\n        this.treeRegexp = new TreeRegexp(expressionRegexp);\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/RegularExpression.java", "class_name": "RegularExpression", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/RegularExpression.java.RegularExpression", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "docstring": "\nCreates a new instance. Use this when the transform types are not known in advance,\nand should be determined by the regular expression's capture groups. Use this with\ndynamically typed languages.\n\n@param expressionRegexp      the regular expression to use\n@param parameterTypeRegistry used to look up parameter types\n"}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/RegularExpression.java.RegularExpression.[List<Argument<?>>]match(String)", "name": "match", "arg_nums": 1, "params": [{"name": "text", "type": "String"}], "return_type": "List<Argument<?>>", "signature": "@Override\n    public List<Argument<?>> match(String text, Type... typeHints)", "original_string": "    @Override\n    public List<Argument<?>> match(String text, Type... typeHints) {\n        final Group group = treeRegexp.match(text);\n        if (group == null) {\n            return null;\n        }\n\n        final ParameterByTypeTransformer defaultTransformer = parameterTypeRegistry.getDefaultParameterTransformer();\n        final List<ParameterType<?>> parameterTypes = new ArrayList<>();\n        int typeHintIndex = 0;\n        for (GroupBuilder groupBuilder : treeRegexp.getGroupBuilder().getChildren()) {\n            final String parameterTypeRegexp = groupBuilder.getSource();\n            boolean hasTypeHint = typeHintIndex < typeHints.length;\n            final Type typeHint = hasTypeHint ? typeHints[typeHintIndex++] : String.class;\n\n            ParameterType<?> parameterType = parameterTypeRegistry.lookupByRegexp(parameterTypeRegexp, expressionRegexp, text);\n\n            // When there is a conflict between the type hint from the regular expression and the method\n            // prefer the parameter type associated with the regular expression. This ensures we will\n            // use the internal/user registered parameter transformer rather then the default.\n            //\n            // Unless the parameter type indicates it is the stronger type hint.\n            if (parameterType != null && hasTypeHint && !parameterType.useRegexpMatchAsStrongTypeHint()) {\n                if (!parameterType.getType().equals(typeHint)) {\n                    parameterType = null;\n                }\n            }\n\n            if (parameterType == null) {\n                parameterType = createAnonymousParameterType(parameterTypeRegexp);\n            }\n\n            // Either from createAnonymousParameterType or lookupByRegexp\n            if (parameterType.isAnonymous()) {\n                parameterType = parameterType.deAnonymize(typeHint, arg -> defaultTransformer.transform(arg, typeHint));\n            }\n\n            parameterTypes.add(parameterType);\n        }\n\n        return Argument.build(group, parameterTypes);\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/RegularExpression.java", "class_name": "RegularExpression", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/RegularExpression.java.RegularExpression", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "List<Argument<?>>", "classes": []}, "docstring": ""}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/RegularExpression.java.RegularExpression.[Pattern]getRegexp()", "name": "getRegexp", "arg_nums": 0, "params": [], "return_type": "Pattern", "signature": "@Override\n    public Pattern getRegexp()", "original_string": "    @Override\n    public Pattern getRegexp() {\n        return expressionRegexp;\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/RegularExpression.java", "class_name": "RegularExpression", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/RegularExpression.java.RegularExpression", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Pattern", "classes": []}, "docstring": ""}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/RegularExpression.java.RegularExpression.[String]getSource()", "name": "getSource", "arg_nums": 0, "params": [], "return_type": "String", "signature": "@Override\n    public String getSource()", "original_string": "    @Override\n    public String getSource() {\n        return expressionRegexp.pattern();\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/RegularExpression.java", "class_name": "RegularExpression", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/RegularExpression.java.RegularExpression", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "docstring": ""}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/KeyboardFriendlyDecimalFormatSymbols.java.KeyboardFriendlyDecimalFormatSymbols.[DecimalFormatSymbols]getInstance(Locale)", "name": "getInstance", "arg_nums": 1, "params": [{"name": "locale", "type": "Locale"}], "return_type": "DecimalFormatSymbols", "signature": "static DecimalFormatSymbols getInstance(Locale locale)", "original_string": "    static DecimalFormatSymbols getInstance(Locale locale) {\n        DecimalFormatSymbols symbols = DecimalFormatSymbols.getInstance(locale);\n\n        // Replace the minus sign with minus-hyphen as available on most keyboards.\n        if (symbols.getMinusSign() == '\\u2212') {\n            symbols.setMinusSign('-');\n        }\n\n        if (symbols.getDecimalSeparator() == '.') {\n            // For locales that use the period as the decimal separator\n            // always use the comma for thousands. The alternatives are\n            // not available on a keyboard\n            symbols.setGroupingSeparator(',');\n        } else if (symbols.getDecimalSeparator() == ',') {\n            // For locales that use the comma as the decimal separator\n            // always use the period for thousands. The alternatives are\n            // not available on a keyboard\n            symbols.setGroupingSeparator('.');\n        }\n        return symbols;\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/KeyboardFriendlyDecimalFormatSymbols.java", "class_name": "KeyboardFriendlyDecimalFormatSymbols", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/KeyboardFriendlyDecimalFormatSymbols.java.KeyboardFriendlyDecimalFormatSymbols", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "DecimalFormatSymbols", "classes": []}, "docstring": ""}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/CucumberExpressionException.java.CucumberExpressionException.[]CucumberExpressionException(String)", "name": "CucumberExpressionException", "arg_nums": 1, "params": [{"name": "message", "type": "String"}], "return_type": "", "signature": "CucumberExpressionException(String message)", "original_string": "    CucumberExpressionException(String message) {\n        super(message);\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/CucumberExpressionException.java", "class_name": "CucumberExpressionException", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/CucumberExpressionException.java.CucumberExpressionException", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "docstring": ""}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/CucumberExpressionException.java.CucumberExpressionException.[]CucumberExpressionException(String,Throwable)", "name": "CucumberExpressionException", "arg_nums": 2, "params": [{"name": "message", "type": "String"}, {"name": "cause", "type": "Throwable"}], "return_type": "", "signature": "CucumberExpressionException(String message, Throwable cause)", "original_string": "    CucumberExpressionException(String message, Throwable cause) {\n        super(message, cause);\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/CucumberExpressionException.java", "class_name": "CucumberExpressionException", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/CucumberExpressionException.java.CucumberExpressionException", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "docstring": ""}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/CucumberExpressionException.java.CucumberExpressionException.[CucumberExpressionException]createMissingEndToken(String,Type,Type,Token)", "name": "createMissingEndToken", "arg_nums": 4, "params": [{"name": "expression", "type": "String"}, {"name": "beginToken", "type": "Type"}, {"name": "endToken", "type": "Type"}, {"name": "current", "type": "Token"}], "return_type": "CucumberExpressionException", "signature": "static CucumberExpressionException createMissingEndToken(String expression, Type beginToken, Type endToken,\n            Token current)", "original_string": "    static CucumberExpressionException createMissingEndToken(String expression, Type beginToken, Type endToken,\n            Token current) {\n        return new CucumberExpressionException(message(\n                current.start(),\n                expression,\n                pointAt(current),\n                \"The '\" + beginToken.symbol() + \"' does not have a matching '\" + endToken.symbol() + \"'\",\n                \"If you did not intend to use \" + beginToken.purpose() + \" you can use '\\\\\" + beginToken\n                        .symbol() + \"' to escape the \" + beginToken.purpose()));\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/CucumberExpressionException.java", "class_name": "CucumberExpressionException", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/CucumberExpressionException.java.CucumberExpressionException", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "CucumberExpressionException", "classes": []}, "docstring": ""}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/CucumberExpressionException.java.CucumberExpressionException.[CucumberExpressionException]createAlternationNotAllowedInOptional(String,Token)", "name": "createAlternationNotAllowedInOptional", "arg_nums": 2, "params": [{"name": "expression", "type": "String"}, {"name": "current", "type": "Token"}], "return_type": "CucumberExpressionException", "signature": "static CucumberExpressionException createAlternationNotAllowedInOptional(String expression, Token current)", "original_string": "    static CucumberExpressionException createAlternationNotAllowedInOptional(String expression, Token current) {\n        return new CucumberExpressionException(message(\n                current.start,\n                expression,\n                pointAt(current),\n                \"An alternation can not be used inside an optional\",\n                \"If you did not mean to use an alternation you can use '\\\\/' to escape the '/'. Otherwise rephrase your expression or consider using a regular expression instead.\"\n        ));\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/CucumberExpressionException.java", "class_name": "CucumberExpressionException", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/CucumberExpressionException.java.CucumberExpressionException", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "CucumberExpressionException", "classes": []}, "docstring": ""}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/CucumberExpressionException.java.CucumberExpressionException.[CucumberExpressionException]createTheEndOfLineCanNotBeEscaped(String)", "name": "createTheEndOfLineCanNotBeEscaped", "arg_nums": 1, "params": [{"name": "expression", "type": "String"}], "return_type": "CucumberExpressionException", "signature": "static CucumberExpressionException createTheEndOfLineCanNotBeEscaped(String expression)", "original_string": "    static CucumberExpressionException createTheEndOfLineCanNotBeEscaped(String expression) {\n        int index = expression.codePointCount(0, expression.length()) - 1;\n        return new CucumberExpressionException(message(\n                index,\n                expression,\n                pointAt(index),\n                \"The end of line can not be escaped\",\n                \"You can use '\\\\\\\\' to escape the '\\\\'\"\n        ));\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/CucumberExpressionException.java", "class_name": "CucumberExpressionException", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/CucumberExpressionException.java.CucumberExpressionException", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "CucumberExpressionException", "classes": []}, "docstring": ""}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/CucumberExpressionException.java.CucumberExpressionException.[CucumberExpressionException]createAlternativeMayNotBeEmpty(Node,String)", "name": "createAlternativeMayNotBeEmpty", "arg_nums": 2, "params": [{"name": "node", "type": "Node"}, {"name": "expression", "type": "String"}], "return_type": "CucumberExpressionException", "signature": "static CucumberExpressionException createAlternativeMayNotBeEmpty(Node node, String expression)", "original_string": "    static CucumberExpressionException createAlternativeMayNotBeEmpty(Node node, String expression) {\n        return new CucumberExpressionException(message(\n                node.start(),\n                expression,\n                pointAt(node),\n                \"Alternative may not be empty\",\n                \"If you did not mean to use an alternative you can use '\\\\/' to escape the '/'\"));\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/CucumberExpressionException.java", "class_name": "CucumberExpressionException", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/CucumberExpressionException.java.CucumberExpressionException", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "CucumberExpressionException", "classes": []}, "docstring": ""}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/CucumberExpressionException.java.CucumberExpressionException.[CucumberExpressionException]createParameterIsNotAllowedInOptional(Node,String)", "name": "createParameterIsNotAllowedInOptional", "arg_nums": 2, "params": [{"name": "node", "type": "Node"}, {"name": "expression", "type": "String"}], "return_type": "CucumberExpressionException", "signature": "static CucumberExpressionException createParameterIsNotAllowedInOptional(Node node, String expression)", "original_string": "    static CucumberExpressionException createParameterIsNotAllowedInOptional(Node node, String expression) {\n        return new CucumberExpressionException(message(\n                node.start(),\n                expression,\n                pointAt(node),\n                \"An optional may not contain a parameter type\",\n                \"If you did not mean to use an parameter type you can use '\\\\{' to escape the '{'\"));\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/CucumberExpressionException.java", "class_name": "CucumberExpressionException", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/CucumberExpressionException.java.CucumberExpressionException", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "CucumberExpressionException", "classes": []}, "docstring": ""}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/CucumberExpressionException.java.CucumberExpressionException.[CucumberExpressionException]createOptionalIsNotAllowedInOptional(Node,String)", "name": "createOptionalIsNotAllowedInOptional", "arg_nums": 2, "params": [{"name": "node", "type": "Node"}, {"name": "expression", "type": "String"}], "return_type": "CucumberExpressionException", "signature": "static CucumberExpressionException createOptionalIsNotAllowedInOptional(Node node, String expression)", "original_string": "    static CucumberExpressionException createOptionalIsNotAllowedInOptional(Node node, String expression) {\n        return new CucumberExpressionException(message(\n                node.start(),\n                expression,\n                pointAt(node),\n                \"An optional may not contain an other optional\",\n                \"If you did not mean to use an optional type you can use '\\\\(' to escape the '('. For more complicated expressions consider using a regular expression instead.\"));\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/CucumberExpressionException.java", "class_name": "CucumberExpressionException", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/CucumberExpressionException.java.CucumberExpressionException", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "CucumberExpressionException", "classes": []}, "docstring": ""}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/CucumberExpressionException.java.CucumberExpressionException.[CucumberExpressionException]createOptionalMayNotBeEmpty(Node,String)", "name": "createOptionalMayNotBeEmpty", "arg_nums": 2, "params": [{"name": "node", "type": "Node"}, {"name": "expression", "type": "String"}], "return_type": "CucumberExpressionException", "signature": "static CucumberExpressionException createOptionalMayNotBeEmpty(Node node, String expression)", "original_string": "    static CucumberExpressionException createOptionalMayNotBeEmpty(Node node, String expression) {\n        return new CucumberExpressionException(message(\n                node.start(),\n                expression,\n                pointAt(node),\n                \"An optional must contain some text\",\n                \"If you did not mean to use an optional you can use '\\\\(' to escape the '('\"));\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/CucumberExpressionException.java", "class_name": "CucumberExpressionException", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/CucumberExpressionException.java.CucumberExpressionException", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "CucumberExpressionException", "classes": []}, "docstring": ""}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/CucumberExpressionException.java.CucumberExpressionException.[CucumberExpressionException]createAlternativeMayNotExclusivelyContainOptionals(Node,String)", "name": "createAlternativeMayNotExclusivelyContainOptionals", "arg_nums": 2, "params": [{"name": "node", "type": "Node"}, {"name": "expression", "type": "String"}], "return_type": "CucumberExpressionException", "signature": "static CucumberExpressionException createAlternativeMayNotExclusivelyContainOptionals(Node node,\n            String expression)", "original_string": "    static CucumberExpressionException createAlternativeMayNotExclusivelyContainOptionals(Node node,\n            String expression) {\n        return new CucumberExpressionException(message(\n                node.start(),\n                expression,\n                pointAt(node),\n                \"An alternative may not exclusively contain optionals\",\n                \"If you did not mean to use an optional you can use '\\\\(' to escape the '('\"));\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/CucumberExpressionException.java", "class_name": "CucumberExpressionException", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/CucumberExpressionException.java.CucumberExpressionException", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "CucumberExpressionException", "classes": []}, "docstring": ""}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/CucumberExpressionException.java.CucumberExpressionException.[String]thisCucumberExpressionHasAProblemAt(int)", "name": "thisCucumberExpressionHasAProblemAt", "arg_nums": 1, "params": [{"name": "index", "type": "int"}], "return_type": "String", "signature": "private static String thisCucumberExpressionHasAProblemAt(int index)", "original_string": "    private static String thisCucumberExpressionHasAProblemAt(int index) {\n        return \"This Cucumber Expression has a problem at column \" + (index + 1) + \":\" + \"\\n\";\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/CucumberExpressionException.java", "class_name": "CucumberExpressionException", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/CucumberExpressionException.java.CucumberExpressionException", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "String", "classes": []}, "docstring": ""}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/CucumberExpressionException.java.CucumberExpressionException.[CucumberExpressionException]createCantEscape(String,int)", "name": "createCantEscape", "arg_nums": 2, "params": [{"name": "expression", "type": "String"}, {"name": "index", "type": "int"}], "return_type": "CucumberExpressionException", "signature": "static CucumberExpressionException createCantEscape(String expression, int index)", "original_string": "    static CucumberExpressionException createCantEscape(String expression, int index) {\n        return new CucumberExpressionException(message(\n                index,\n                expression,\n                pointAt(index),\n                \"Only the characters '{', '}', '(', ')', '\\\\', '/' and whitespace can be escaped\",\n                \"If you did mean to use an '\\\\' you can use '\\\\\\\\' to escape it\"));\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/CucumberExpressionException.java", "class_name": "CucumberExpressionException", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/CucumberExpressionException.java.CucumberExpressionException", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "CucumberExpressionException", "classes": []}, "docstring": ""}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/CucumberExpressionException.java.CucumberExpressionException.[CucumberExpressionException]createInvalidParameterTypeName(String)", "name": "createInvalidParameterTypeName", "arg_nums": 1, "params": [{"name": "name", "type": "String"}], "return_type": "CucumberExpressionException", "signature": "static CucumberExpressionException createInvalidParameterTypeName(String name)", "original_string": "    static CucumberExpressionException createInvalidParameterTypeName(String name) {\n        return new CucumberExpressionException(\n                \"Illegal character in parameter name {\" + name + \"}. Parameter names may not contain '{', '}', '(', ')', '\\\\' or '/'\");\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/CucumberExpressionException.java", "class_name": "CucumberExpressionException", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/CucumberExpressionException.java.CucumberExpressionException", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "CucumberExpressionException", "classes": []}, "docstring": ""}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/CucumberExpressionException.java.CucumberExpressionException.[CucumberExpressionException]createInvalidParameterTypeName(Token,String)", "name": "createInvalidParameterTypeName", "arg_nums": 2, "params": [{"name": "token", "type": "Token"}, {"name": "expression", "type": "String"}], "return_type": "CucumberExpressionException", "signature": "static CucumberExpressionException createInvalidParameterTypeName(Token token, String expression)", "original_string": "    static CucumberExpressionException createInvalidParameterTypeName(Token token, String expression) {\n        return new CucumberExpressionException(message(\n                token.start(),\n                expression,\n                pointAt(token),\n                \"Parameter names may not contain '{', '}', '(', ')', '\\\\' or '/'\",\n                \"Did you mean to use a regular expression?\"));\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/CucumberExpressionException.java", "class_name": "CucumberExpressionException", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/CucumberExpressionException.java.CucumberExpressionException", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "CucumberExpressionException", "classes": []}, "docstring": "\nNot very clear, but this message has to be language independent\nOther languages have dedicated syntax for writing down regular expressions\n<p>\nIn java a regular expression has to start with {@code ^} and end with\n{@code $} to be recognized as one by Cucumber.\n\n@see ExpressionFactory\n"}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/CucumberExpressionException.java.CucumberExpressionException.[String]message(int,String,String,String,String)", "name": "message", "arg_nums": 5, "params": [{"name": "index", "type": "int"}, {"name": "expression", "type": "String"}, {"name": "pointer", "type": "String"}, {"name": "problem", "type": "String"}, {"name": "solution", "type": "String"}], "return_type": "String", "signature": "static String message(int index, String expression, String pointer, String problem,\n            String solution)", "original_string": "    static String message(int index, String expression, String pointer, String problem,\n            String solution) {\n        return thisCucumberExpressionHasAProblemAt(index) +\n                \"\\n\" +\n                expression + \"\\n\" +\n                pointer + \"\\n\" +\n                problem + \".\\n\" +\n                solution;\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/CucumberExpressionException.java", "class_name": "CucumberExpressionException", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/CucumberExpressionException.java.CucumberExpressionException", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "String", "classes": []}, "docstring": ""}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/CucumberExpressionException.java.CucumberExpressionException.[String]pointAt(Located)", "name": "pointAt", "arg_nums": 1, "params": [{"name": "node", "type": "Located"}], "return_type": "String", "signature": "static String pointAt(Located node)", "original_string": "    static String pointAt(Located node) {\n        StringBuilder pointer = new StringBuilder(pointAt(node.start()));\n        if (node.start() + 1 < node.end()) {\n            for (int i = node.start() + 1; i < node.end() - 1; i++) {\n                pointer.append(\"-\");\n            }\n            pointer.append(\"^\");\n        }\n        return pointer.toString();\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/CucumberExpressionException.java", "class_name": "CucumberExpressionException", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/CucumberExpressionException.java.CucumberExpressionException", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "String", "classes": []}, "docstring": ""}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/CucumberExpressionException.java.CucumberExpressionException.[String]pointAt(int)", "name": "pointAt", "arg_nums": 1, "params": [{"name": "index", "type": "int"}], "return_type": "String", "signature": "private static String pointAt(int index)", "original_string": "    private static String pointAt(int index) {\n        StringBuilder pointer = new StringBuilder();\n        for (int i = 0; i < index; i++) {\n            pointer.append(\" \");\n        }\n        pointer.append(\"^\");\n        return pointer.toString();\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/CucumberExpressionException.java", "class_name": "CucumberExpressionException", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/CucumberExpressionException.java.CucumberExpressionException", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "String", "classes": []}, "docstring": ""}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/CucumberExpressionParser.java.CucumberExpressionParser.[Node]parse(String)", "name": "parse", "arg_nums": 1, "params": [{"name": "expression", "type": "String"}], "return_type": "Node", "signature": "Node parse(String expression)", "original_string": "    Node parse(String expression) {\n        CucumberExpressionTokenizer tokenizer = new CucumberExpressionTokenizer();\n        List<Token> tokens = tokenizer.tokenize(expression);\n        Result result = cucumberExpressionParser.parse(expression, tokens, 0);\n        return result.ast.get(0);\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/CucumberExpressionParser.java", "class_name": "CucumberExpressionParser", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/CucumberExpressionParser.java.CucumberExpressionParser", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "Node", "classes": []}, "docstring": ""}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/CucumberExpressionParser.java.CucumberExpressionParser.[Parser]parseBetween(Node.Type,Type,Type,List<Parser>)", "name": "parseBetween", "arg_nums": 4, "params": [{"name": "type", "type": "Node.Type"}, {"name": "beginToken", "type": "Type"}, {"name": "endToken", "type": "Type"}, {"name": "parsers", "type": "List<Parser>"}], "return_type": "Parser", "signature": "private static Parser parseBetween(\n            Node.Type type,\n            Type beginToken,\n            Type endToken,\n            List<Parser> parsers)", "original_string": "    private static Parser parseBetween(\n            Node.Type type,\n            Type beginToken,\n            Type endToken,\n            List<Parser> parsers) {\n        return (expression, tokens, current) -> {\n            if (!lookingAt(tokens, current, beginToken)) {\n                return new Result(0);\n            }\n            int subCurrent = current + 1;\n            Result result = parseTokensUntil(expression, parsers, tokens, subCurrent, endToken, END_OF_LINE);\n            subCurrent += result.consumed;\n\n            // endToken not found\n            if (!lookingAt(tokens, subCurrent, endToken)) {\n                throw createMissingEndToken(expression, beginToken, endToken, tokens.get(current));\n            }\n            // consumes endToken\n            int start = tokens.get(current).start();\n            int end = tokens.get(subCurrent).end();\n            return new Result(subCurrent + 1 - current, new Node(type, start, end, result.ast));\n        };\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/CucumberExpressionParser.java", "class_name": "CucumberExpressionParser", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/CucumberExpressionParser.java.CucumberExpressionParser", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "Parser", "classes": []}, "docstring": ""}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/CucumberExpressionParser.java.CucumberExpressionParser.[Result]parseTokensUntil(String,List<Parser>,List<Token>,int)", "name": "parseTokensUntil", "arg_nums": 4, "params": [{"name": "expression", "type": "String"}, {"name": "parsers", "type": "List<Parser>"}, {"name": "tokens", "type": "List<Token>"}, {"name": "startAt", "type": "int"}], "return_type": "Result", "signature": "private static Result parseTokensUntil(\n            String expression,\n            List<Parser> parsers,\n            List<Token> tokens,\n            int startAt,\n            Type... endTokens)", "original_string": "    private static Result parseTokensUntil(\n            String expression,\n            List<Parser> parsers,\n            List<Token> tokens,\n            int startAt,\n            Type... endTokens) {\n        int current = startAt;\n        int size = tokens.size();\n        List<Node> ast = new ArrayList<>();\n        while (current < size) {\n            if (lookingAtAny(tokens, current, endTokens)) {\n                break;\n            }\n\n            Result result = parseToken(expression, parsers, tokens, current);\n            if (result.consumed == 0) {\n                // If configured correctly this will never happen\n                // Keep to avoid infinite loops\n                throw new IllegalStateException(\"No eligible parsers for \" + tokens);\n            }\n            current += result.consumed;\n            ast.addAll(result.ast);\n        }\n        return new Result(current - startAt, ast);\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/CucumberExpressionParser.java", "class_name": "CucumberExpressionParser", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/CucumberExpressionParser.java.CucumberExpressionParser", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "Result", "classes": []}, "docstring": ""}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/CucumberExpressionParser.java.CucumberExpressionParser.[Result]parseToken(String,List<Parser>,List<Token>,int)", "name": "parseToken", "arg_nums": 4, "params": [{"name": "expression", "type": "String"}, {"name": "parsers", "type": "List<Parser>"}, {"name": "tokens", "type": "List<Token>"}, {"name": "startAt", "type": "int"}], "return_type": "Result", "signature": "private static Result parseToken(String expression, List<Parser> parsers,\n            List<Token> tokens,\n            int startAt)", "original_string": "    private static Result parseToken(String expression, List<Parser> parsers,\n            List<Token> tokens,\n            int startAt) {\n        for (Parser parser : parsers) {\n            Result result = parser.parse(expression, tokens, startAt);\n            if (result.consumed != 0) {\n                return result;\n            }\n        }\n        // If configured correctly this will never happen\n        throw new IllegalStateException(\"No eligible parsers for \" + tokens);\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/CucumberExpressionParser.java", "class_name": "CucumberExpressionParser", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/CucumberExpressionParser.java.CucumberExpressionParser", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "Result", "classes": []}, "docstring": ""}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/CucumberExpressionParser.java.CucumberExpressionParser.[boolean]lookingAtAny(List<Token>,int)", "name": "lookingAtAny", "arg_nums": 2, "params": [{"name": "tokens", "type": "List<Token>"}, {"name": "at", "type": "int"}], "return_type": "boolean", "signature": "private static boolean lookingAtAny(List<Token> tokens, int at, Type... tokenTypes)", "original_string": "    private static boolean lookingAtAny(List<Token> tokens, int at, Type... tokenTypes) {\n        for (Type tokeType : tokenTypes) {\n            if (lookingAt(tokens, at, tokeType)) {\n                return true;\n            }\n        }\n        return false;\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/CucumberExpressionParser.java", "class_name": "CucumberExpressionParser", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/CucumberExpressionParser.java.CucumberExpressionParser", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": ""}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/CucumberExpressionParser.java.CucumberExpressionParser.[boolean]lookingAt(List<Token>,int,Type)", "name": "lookingAt", "arg_nums": 3, "params": [{"name": "tokens", "type": "List<Token>"}, {"name": "at", "type": "int"}, {"name": "token", "type": "Type"}], "return_type": "boolean", "signature": "private static boolean lookingAt(List<Token> tokens, int at, Type token)", "original_string": "    private static boolean lookingAt(List<Token> tokens, int at, Type token) {\n        if (at < 0) {\n            // If configured correctly this will never happen\n            // Keep for completeness\n            return token == START_OF_LINE;\n        }\n        if (at >= tokens.size()) {\n            return token == END_OF_LINE;\n        }\n        return tokens.get(at).type == token;\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/CucumberExpressionParser.java", "class_name": "CucumberExpressionParser", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/CucumberExpressionParser.java.CucumberExpressionParser", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": ""}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/CucumberExpressionParser.java.CucumberExpressionParser.[List<Node>]splitAlternatives(int,int,List<Node>)", "name": "splitAlternatives", "arg_nums": 3, "params": [{"name": "start", "type": "int"}, {"name": "end", "type": "int"}, {"name": "alternation", "type": "List<Node>"}], "return_type": "List<Node>", "signature": "private static List<Node> splitAlternatives(int start, int end, List<Node> alternation)", "original_string": "    private static List<Node> splitAlternatives(int start, int end, List<Node> alternation) {\n        List<Node> separators = new ArrayList<>();\n        List<List<Node>> alternatives = new ArrayList<>();\n        List<Node> alternative = new ArrayList<>();\n        for (Node n : alternation) {\n            if (ALTERNATIVE_NODE.equals(n.type())) {\n                separators.add(n);\n                alternatives.add(alternative);\n                alternative = new ArrayList<>();\n            } else {\n                alternative.add(n);\n            }\n        }\n        alternatives.add(alternative);\n\n        return createAlternativeNodes(start, end, separators, alternatives);\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/CucumberExpressionParser.java", "class_name": "CucumberExpressionParser", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/CucumberExpressionParser.java.CucumberExpressionParser", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "List<Node>", "classes": []}, "docstring": ""}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/CucumberExpressionParser.java.CucumberExpressionParser.[List<Node>]createAlternativeNodes(int,int,List<Node>,List<List<Node>>)", "name": "createAlternativeNodes", "arg_nums": 4, "params": [{"name": "start", "type": "int"}, {"name": "end", "type": "int"}, {"name": "separators", "type": "List<Node>"}, {"name": "alternatives", "type": "List<List<Node>>"}], "return_type": "List<Node>", "signature": "private static List<Node> createAlternativeNodes(int start, int end, List<Node> separators, List<List<Node>> alternatives)", "original_string": "    private static List<Node> createAlternativeNodes(int start, int end, List<Node> separators, List<List<Node>> alternatives) {\n        List<Node> nodes = new ArrayList<>();\n        for (int i = 0; i < alternatives.size(); i++) {\n            List<Node> n = alternatives.get(i);\n            if (i == 0) {\n                Node rightSeparator = separators.get(i);\n                nodes.add(new Node(ALTERNATIVE_NODE, start, rightSeparator.start(), n));\n            } else if (i == alternatives.size() - 1) {\n                Node leftSeparator = separators.get(i - 1);\n                nodes.add(new Node(ALTERNATIVE_NODE, leftSeparator.end(), end, n));\n            } else {\n                Node leftSeparator = separators.get(i - 1);\n                Node rightSeparator = separators.get(i);\n                nodes.add(new Node(ALTERNATIVE_NODE, leftSeparator.end(), rightSeparator.start(), n));\n            }\n        }\n        return nodes;\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/CucumberExpressionParser.java", "class_name": "CucumberExpressionParser", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/CucumberExpressionParser.java.CucumberExpressionParser", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "List<Node>", "classes": []}, "docstring": ""}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/BuiltInParameterTransformer.java.BuiltInParameterTransformer.[]BuiltInParameterTransformer(Locale)", "name": "BuiltInParameterTransformer", "arg_nums": 1, "params": [{"name": "locale", "type": "Locale"}], "return_type": "", "signature": "BuiltInParameterTransformer(Locale locale)", "original_string": "    BuiltInParameterTransformer(Locale locale) {\n        this.numberParser = new NumberParser(locale);\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/BuiltInParameterTransformer.java", "class_name": "BuiltInParameterTransformer", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/BuiltInParameterTransformer.java.BuiltInParameterTransformer", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "docstring": ""}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/BuiltInParameterTransformer.java.BuiltInParameterTransformer.[Object]transform(String,Type)", "name": "transform", "arg_nums": 2, "params": [{"name": "fromValue", "type": "String"}, {"name": "toValueType", "type": "Type"}], "return_type": "Object", "signature": "@Override\n    public Object transform(String fromValue, Type toValueType)", "original_string": "    @Override\n    public Object transform(String fromValue, Type toValueType) {\n        return doTransform(fromValue, toValueType, toValueType);\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/BuiltInParameterTransformer.java", "class_name": "BuiltInParameterTransformer", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/BuiltInParameterTransformer.java.BuiltInParameterTransformer", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Object", "classes": []}, "docstring": ""}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/BuiltInParameterTransformer.java.BuiltInParameterTransformer.[Object]doTransform(String,Type,Type)", "name": "doTransform", "arg_nums": 3, "params": [{"name": "fromValue", "type": "String"}, {"name": "toValueType", "type": "Type"}, {"name": "originalToValueType", "type": "Type"}], "return_type": "Object", "signature": "private Object doTransform(String fromValue, Type toValueType, Type originalToValueType)", "original_string": "    private Object doTransform(String fromValue, Type toValueType, Type originalToValueType) {\n        Type optionalValueType;\n        if ((optionalValueType = getOptionalGenericType(toValueType)) != null) {\n            Object wrappedValue = doTransform(fromValue, optionalValueType, originalToValueType);\n            return Optional.ofNullable(wrappedValue);\n        }\n\n        if (!(toValueType instanceof Class)) {\n            throw createIllegalArgumentException(fromValue, originalToValueType);\n        }\n\n        Class<?> toValueClass = (Class<?>) requireNonNull(toValueType);\n        if (fromValue == null) {\n            return null;\n        }\n\n        if (String.class.equals(toValueClass) || Object.class.equals(toValueClass)) {\n            return fromValue;\n        }\n\n        if (Character.class.equals(toValueClass) || char.class.equals(toValueClass)) {\n            if(fromValue.length() == 1) {\n                return fromValue.charAt(0);\n            }\n        }\n\n        if (BigInteger.class.equals(toValueClass)) {\n            return new BigInteger(fromValue);\n        }\n\n        if (BigDecimal.class.equals(toValueClass) || Number.class.equals(toValueClass)) {\n            return numberParser.parseBigDecimal(fromValue);\n        }\n\n        if (Byte.class.equals(toValueClass) || byte.class.equals(toValueClass)) {\n            return Byte.decode(fromValue);\n        }\n\n        if (Short.class.equals(toValueClass) || short.class.equals(toValueClass)) {\n            return Short.decode(fromValue);\n        }\n\n        if (Integer.class.equals(toValueClass) || int.class.equals(toValueClass)) {\n            return Integer.decode(fromValue);\n        }\n\n        if (Long.class.equals(toValueClass) || long.class.equals(toValueClass)) {\n            return Long.decode(fromValue);\n        }\n\n        if (Float.class.equals(toValueClass) || float.class.equals(toValueClass)) {\n            return numberParser.parseFloat(fromValue);\n        }\n\n        if (Double.class.equals(toValueClass) || double.class.equals(toValueClass)) {\n            return numberParser.parseDouble(fromValue);\n        }\n\n        if (Boolean.class.equals(toValueClass) || boolean.class.equals(toValueClass)) {\n            return Boolean.parseBoolean(fromValue);\n        }\n\n        if (toValueClass.isEnum()) {\n            @SuppressWarnings(\"unchecked\")\n            Class<? extends Enum<?>> enumClass = (Class<? extends Enum<?>>) toValueClass;\n            for (Enum<?> enumConstant : enumClass.getEnumConstants()) {\n                if (enumConstant.name().equals(fromValue)) {\n                    return enumConstant;\n                }\n            }\n            throw new CucumberExpressionException(\"Can't transform '\" + fromValue + \"' to \" + originalToValueType + \". \" +\n                    \"Not an enum constant\");\n        }\n\n        throw createIllegalArgumentException(fromValue, originalToValueType);\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/BuiltInParameterTransformer.java", "class_name": "BuiltInParameterTransformer", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/BuiltInParameterTransformer.java.BuiltInParameterTransformer", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "Object", "classes": []}, "docstring": ""}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/BuiltInParameterTransformer.java.BuiltInParameterTransformer.[Type]getOptionalGenericType(Type)", "name": "getOptionalGenericType", "arg_nums": 1, "params": [{"name": "type", "type": "Type"}], "return_type": "Type", "signature": "private Type getOptionalGenericType(Type type)", "original_string": "    private Type getOptionalGenericType(Type type) {\n        if (Optional.class.equals(type)) {\n            return Object.class;\n        }\n\n        if (!(type instanceof ParameterizedType)) {\n            return null;\n        }\n\n        ParameterizedType parameterizedType = (ParameterizedType) type;\n        if (Optional.class.equals(parameterizedType.getRawType())) {\n            return parameterizedType.getActualTypeArguments()[0];\n        }\n\n        return null;\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/BuiltInParameterTransformer.java", "class_name": "BuiltInParameterTransformer", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/BuiltInParameterTransformer.java.BuiltInParameterTransformer", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "Type", "classes": []}, "docstring": ""}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/BuiltInParameterTransformer.java.BuiltInParameterTransformer.[IllegalArgumentException]createIllegalArgumentException(String,Type)", "name": "createIllegalArgumentException", "arg_nums": 2, "params": [{"name": "fromValue", "type": "String"}, {"name": "toValueType", "type": "Type"}], "return_type": "IllegalArgumentException", "signature": "private IllegalArgumentException createIllegalArgumentException(String fromValue, Type toValueType)", "original_string": "    private IllegalArgumentException createIllegalArgumentException(String fromValue, Type toValueType) {\n        return new IllegalArgumentException(\n                \"Can't transform '\" + fromValue + \"' to \" + toValueType + \"\\n\" +\n                        \"BuiltInParameterTransformer only supports a limited number of class types\\n\" +\n                        \"Consider using a different object mapper or register a parameter type for \" + toValueType\n        );\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/BuiltInParameterTransformer.java", "class_name": "BuiltInParameterTransformer", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/BuiltInParameterTransformer.java.BuiltInParameterTransformer", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "IllegalArgumentException", "classes": []}, "docstring": ""}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/NumberParser.java.NumberParser.[]NumberParser(Locale)", "name": "NumberParser", "arg_nums": 1, "params": [{"name": "locale", "type": "Locale"}], "return_type": "", "signature": "NumberParser(Locale locale)", "original_string": "    NumberParser(Locale locale) {\n        numberFormat = DecimalFormat.getNumberInstance(locale);\n        if (numberFormat instanceof DecimalFormat) {\n            DecimalFormat decimalFormat = (DecimalFormat) numberFormat;\n            decimalFormat.setParseBigDecimal(true);\n            DecimalFormatSymbols symbols = KeyboardFriendlyDecimalFormatSymbols.getInstance(locale);\n            decimalFormat.setDecimalFormatSymbols(symbols);\n        }\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/NumberParser.java", "class_name": "NumberParser", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/NumberParser.java.NumberParser", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "docstring": ""}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/NumberParser.java.NumberParser.[double]parseDouble(String)", "name": "parseDouble", "arg_nums": 1, "params": [{"name": "s", "type": "String"}], "return_type": "double", "signature": "double parseDouble(String s)", "original_string": "    double parseDouble(String s) {\n        return parse(s).doubleValue();\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/NumberParser.java", "class_name": "NumberParser", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/NumberParser.java.NumberParser", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "double", "classes": []}, "docstring": ""}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/NumberParser.java.NumberParser.[float]parseFloat(String)", "name": "parseFloat", "arg_nums": 1, "params": [{"name": "s", "type": "String"}], "return_type": "float", "signature": "float parseFloat(String s)", "original_string": "    float parseFloat(String s) {\n        return parse(s).floatValue();\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/NumberParser.java", "class_name": "NumberParser", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/NumberParser.java.NumberParser", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "float", "classes": []}, "docstring": ""}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/NumberParser.java.NumberParser.[BigDecimal]parseBigDecimal(String)", "name": "parseBigDecimal", "arg_nums": 1, "params": [{"name": "s", "type": "String"}], "return_type": "BigDecimal", "signature": "BigDecimal parseBigDecimal(String s)", "original_string": "    BigDecimal parseBigDecimal(String s) {\n        if (numberFormat instanceof DecimalFormat) {\n            return (BigDecimal) parse(s);\n        }\n        // Fall back to default big decimal format\n        // if the locale does not have a DecimalFormat\n        return new BigDecimal(s);\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/NumberParser.java", "class_name": "NumberParser", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/NumberParser.java.NumberParser", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "BigDecimal", "classes": []}, "docstring": ""}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/NumberParser.java.NumberParser.[Number]parse(String)", "name": "parse", "arg_nums": 1, "params": [{"name": "s", "type": "String"}], "return_type": "Number", "signature": "private Number parse(String s)", "original_string": "    private Number parse(String s) {\n        try {\n            return numberFormat.parse(s);\n        } catch (ParseException e) {\n            throw new CucumberExpressionException(\"Failed to parse number\", e);\n        }\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/NumberParser.java", "class_name": "NumberParser", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/NumberParser.java.NumberParser", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "Number", "classes": []}, "docstring": ""}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/ParameterTypeRegistry.java.ParameterTypeRegistry.[]ParameterTypeRegistry(Locale)", "name": "ParameterTypeRegistry", "arg_nums": 1, "params": [{"name": "locale", "type": "Locale"}], "return_type": "", "signature": "public ParameterTypeRegistry(Locale locale)", "original_string": "    public ParameterTypeRegistry(Locale locale) {\n        this(new BuiltInParameterTransformer(locale), locale);\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/ParameterTypeRegistry.java", "class_name": "ParameterTypeRegistry", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/ParameterTypeRegistry.java.ParameterTypeRegistry", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": ""}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/ParameterTypeRegistry.java.ParameterTypeRegistry.[]ParameterTypeRegistry(ParameterByTypeTransformer,Locale)", "name": "ParameterTypeRegistry", "arg_nums": 2, "params": [{"name": "defaultParameterTransformer", "type": "ParameterByTypeTransformer"}, {"name": "locale", "type": "Locale"}], "return_type": "", "signature": "private ParameterTypeRegistry(ParameterByTypeTransformer defaultParameterTransformer, Locale locale)", "original_string": "    private ParameterTypeRegistry(ParameterByTypeTransformer defaultParameterTransformer, Locale locale) {\n        this.internalParameterTransformer = defaultParameterTransformer;\n        this.defaultParameterTransformer = defaultParameterTransformer;\n\n        DecimalFormatSymbols numberFormat = KeyboardFriendlyDecimalFormatSymbols.getInstance(locale);\n\n        List<String> localizedFloatRegexp = singletonList(FLOAT_REGEXPS\n                .replace(\"{decimal}\", \"\" + numberFormat.getDecimalSeparator())\n                .replace(\"{group}\", \"\" + numberFormat.getGroupingSeparator())\n                .replace(\"{expnt}\", \"\" + numberFormat.getExponentSeparator())\n        );\n\n        defineParameterType(new ParameterType<>(\"biginteger\", INTEGER_REGEXPS, BigInteger.class, new Transformer<BigInteger>() {\n            @Override\n            public BigInteger transform(String arg) throws Throwable {\n                return (BigInteger) internalParameterTransformer.transform(arg, BigInteger.class);\n            }\n        }, false, false, false));\n        defineParameterType(new ParameterType<>(\"bigdecimal\", localizedFloatRegexp, BigDecimal.class, new Transformer<BigDecimal>() {\n            @Override\n            public BigDecimal transform(String arg) throws Throwable {\n                return (BigDecimal) internalParameterTransformer.transform(arg, BigDecimal.class);\n            }\n        }, false, false, false));\n        defineParameterType(new ParameterType<>(\"byte\", INTEGER_REGEXPS, Byte.class, new Transformer<Byte>() {\n            @Override\n            public Byte transform(String arg) throws Throwable {\n                return (Byte) internalParameterTransformer.transform(arg, Byte.class);\n            }\n        }, false, false, false));\n        defineParameterType(new ParameterType<>(\"short\", INTEGER_REGEXPS, Short.class, new Transformer<Short>() {\n            @Override\n            public Short transform(String arg) throws Throwable {\n                return (Short) internalParameterTransformer.transform(arg, Short.class);\n            }\n        }, false, false, false));\n        defineParameterType(new ParameterType<>(\"int\", INTEGER_REGEXPS, Integer.class, new Transformer<Integer>() {\n            @Override\n            public Integer transform(String arg) throws Throwable {\n                return (Integer) internalParameterTransformer.transform(arg, Integer.class);\n            }\n        }, true, true, false));\n        defineParameterType(new ParameterType<>(\"long\", INTEGER_REGEXPS, Long.class, new Transformer<Long>() {\n            @Override\n            public Long transform(String arg) throws Throwable {\n                return (Long) internalParameterTransformer.transform(arg, Long.class);\n            }\n        }, false, false));\n        defineParameterType(new ParameterType<>(\"float\", localizedFloatRegexp, Float.class, new Transformer<Float>() {\n            @Override\n            public Float transform(String arg) throws Throwable {\n                return (Float) internalParameterTransformer.transform(arg, Float.class);\n            }\n        }, false, false));\n        defineParameterType(new ParameterType<>(\"double\", localizedFloatRegexp, Double.class, new Transformer<Double>() {\n            @Override\n            public Double transform(String arg) throws Throwable {\n                return (Double) internalParameterTransformer.transform(arg, Double.class);\n            }\n        }, true, true, false));\n        defineParameterType(new ParameterType<>(\"word\", WORD_REGEXPS, String.class, new Transformer<String>() {\n            @Override\n            public String transform(String arg) throws Throwable {\n                return (String) internalParameterTransformer.transform(arg, String.class);\n            }\n        }, false, false, false));\n        defineParameterType(new ParameterType<>(\"string\", STRING_REGEXPS, String.class, new CaptureGroupTransformer<String>() {\n            @Override\n            public String transform(String... args) throws Throwable {\n                String arg = args[0] != null ? args[0] : args[1];\n                return (String) internalParameterTransformer.transform(arg\n                                .replaceAll(\"\\\\\\\\\\\"\", \"\\\"\")\n                                .replaceAll(\"\\\\\\\\'\", \"'\"),\n                        String.class);\n            }\n        }, true, false, false));\n\n        defineParameterType(createAnonymousParameterType(ANONYMOUS_REGEX));\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/ParameterTypeRegistry.java", "class_name": "ParameterTypeRegistry", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/ParameterTypeRegistry.java.ParameterTypeRegistry", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "", "classes": []}, "docstring": ""}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/ParameterTypeRegistry.java.ParameterTypeRegistry.[void]defineParameterType(ParameterType<?>)", "name": "defineParameterType", "arg_nums": 1, "params": [{"name": "parameterType", "type": "ParameterType<?>"}], "return_type": "void", "signature": "public void defineParameterType(ParameterType<?> parameterType)", "original_string": "    public void defineParameterType(ParameterType<?> parameterType) {\n        if (parameterType.getName() != null) {\n            if (parameterTypeByName.containsKey(parameterType.getName())) {\n                if (parameterType.getName().isEmpty()) {\n                    throw new DuplicateTypeNameException(\"The anonymous parameter type has already been defined\");\n                }\n                throw new DuplicateTypeNameException(String.format(\"There is already a parameter type with name %s\", parameterType.getName()));\n            }\n            parameterTypeByName.put(parameterType.getName(), parameterType);\n        }\n\n        for (String parameterTypeRegexp : parameterType.getRegexps()) {\n            if (!parameterTypesByRegexp.containsKey(parameterTypeRegexp)) {\n                parameterTypesByRegexp.put(parameterTypeRegexp, new TreeSet<ParameterType<?>>());\n            }\n            SortedSet<ParameterType<?>> parameterTypes = parameterTypesByRegexp.get(parameterTypeRegexp);\n            if (!parameterTypes.isEmpty() && parameterTypes.first().preferForRegexpMatch() && parameterType.preferForRegexpMatch()) {\n                throw new CucumberExpressionException(String.format(\n                        \"There can only be one preferential parameter type per regexp. \" +\n                                \"The regexp /%s/ is used for two preferential parameter types, {%s} and {%s}\",\n                        parameterTypeRegexp, parameterTypes.first().getName(), parameterType.getName()\n                ));\n            }\n            parameterTypes.add(parameterType);\n        }\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/ParameterTypeRegistry.java", "class_name": "ParameterTypeRegistry", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/ParameterTypeRegistry.java.ParameterTypeRegistry", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/ParameterTypeRegistry.java.ParameterTypeRegistry.[ParameterByTypeTransformer]getDefaultParameterTransformer()", "name": "getDefaultParameterTransformer", "arg_nums": 0, "params": [], "return_type": "ParameterByTypeTransformer", "signature": "ParameterByTypeTransformer getDefaultParameterTransformer()", "original_string": "    ParameterByTypeTransformer getDefaultParameterTransformer() {\n        return defaultParameterTransformer;\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/ParameterTypeRegistry.java", "class_name": "ParameterTypeRegistry", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/ParameterTypeRegistry.java.ParameterTypeRegistry", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "ParameterByTypeTransformer", "classes": []}, "docstring": ""}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/ParameterTypeRegistry.java.ParameterTypeRegistry.[void]setDefaultParameterTransformer(ParameterByTypeTransformer)", "name": "setDefaultParameterTransformer", "arg_nums": 1, "params": [{"name": "defaultParameterTransformer", "type": "ParameterByTypeTransformer"}], "return_type": "void", "signature": "public void setDefaultParameterTransformer(ParameterByTypeTransformer defaultParameterTransformer)", "original_string": "    public void setDefaultParameterTransformer(ParameterByTypeTransformer defaultParameterTransformer) {\n        this.defaultParameterTransformer = defaultParameterTransformer;\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/ParameterTypeRegistry.java", "class_name": "ParameterTypeRegistry", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/ParameterTypeRegistry.java.ParameterTypeRegistry", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/ParameterTypeRegistry.java.ParameterTypeRegistry.[ParameterType<T>]lookupByTypeName(String)", "name": "lookupByTypeName", "arg_nums": 1, "params": [{"name": "typeName", "type": "String"}], "return_type": "ParameterType<T>", "signature": "<T> ParameterType<T> lookupByTypeName(String typeName)", "original_string": "    <T> ParameterType<T> lookupByTypeName(String typeName) {\n        return (ParameterType<T>) parameterTypeByName.get(typeName);\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/ParameterTypeRegistry.java", "class_name": "ParameterTypeRegistry", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/ParameterTypeRegistry.java.ParameterTypeRegistry", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "ParameterType<T>", "classes": []}, "docstring": ""}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/ParameterTypeRegistry.java.ParameterTypeRegistry.[ParameterType<T>]lookupByRegexp(String,Pattern,String)", "name": "lookupByRegexp", "arg_nums": 3, "params": [{"name": "parameterTypeRegexp", "type": "String"}, {"name": "expressionRegexp", "type": "Pattern"}, {"name": "text", "type": "String"}], "return_type": "ParameterType<T>", "signature": "<T> ParameterType<T> lookupByRegexp(String parameterTypeRegexp, Pattern expressionRegexp, String text)", "original_string": "    <T> ParameterType<T> lookupByRegexp(String parameterTypeRegexp, Pattern expressionRegexp, String text) {\n        SortedSet<ParameterType<?>> parameterTypes = parameterTypesByRegexp.get(parameterTypeRegexp);\n        if (parameterTypes == null) return null;\n        if (parameterTypes.size() > 1 && !parameterTypes.first().preferForRegexpMatch()) {\n            // We don't do this check on insertion because we only want to restrict\n            // ambiguity when we look up by Regexp. Users of CucumberExpression should\n            // not be restricted.\n            List<GeneratedExpression> generatedExpressions = new CucumberExpressionGenerator(this).generateExpressions(text);\n            throw new AmbiguousParameterTypeException(parameterTypeRegexp, expressionRegexp, parameterTypes, generatedExpressions);\n        }\n        return (ParameterType<T>) parameterTypes.first();\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/ParameterTypeRegistry.java", "class_name": "ParameterTypeRegistry", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/ParameterTypeRegistry.java.ParameterTypeRegistry", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "ParameterType<T>", "classes": []}, "docstring": ""}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/ParameterTypeRegistry.java.ParameterTypeRegistry.[Collection<ParameterType<?>>]getParameterTypes()", "name": "getParameterTypes", "arg_nums": 0, "params": [], "return_type": "Collection<ParameterType<?>>", "signature": "Collection<ParameterType<?>> getParameterTypes()", "original_string": "    Collection<ParameterType<?>> getParameterTypes() {\n        return parameterTypeByName.values();\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/ParameterTypeRegistry.java", "class_name": "ParameterTypeRegistry", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/ParameterTypeRegistry.java.ParameterTypeRegistry", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "Collection<ParameterType<?>>", "classes": []}, "docstring": ""}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/ExpressionFactory.java.ExpressionFactory.[]ExpressionFactory(ParameterTypeRegistry)", "name": "ExpressionFactory", "arg_nums": 1, "params": [{"name": "parameterTypeRegistry", "type": "ParameterTypeRegistry"}], "return_type": "", "signature": "public ExpressionFactory(ParameterTypeRegistry parameterTypeRegistry)", "original_string": "    public ExpressionFactory(ParameterTypeRegistry parameterTypeRegistry) {\n        this.parameterTypeRegistry = parameterTypeRegistry;\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/ExpressionFactory.java", "class_name": "ExpressionFactory", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/ExpressionFactory.java.ExpressionFactory", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": ""}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/ExpressionFactory.java.ExpressionFactory.[Expression]createExpression(String)", "name": "createExpression", "arg_nums": 1, "params": [{"name": "expressionString", "type": "String"}], "return_type": "Expression", "signature": "public Expression createExpression(String expressionString)", "original_string": "    public Expression createExpression(String expressionString) {\n        /* This method is called often (typically about number_of_steps x\n         * nbr_test_scenarios), thus performance is more important than\n         * readability here.\n         * Consequently, we check the first and last expressionString\n         * characters to determine whether we need to create a\n         * RegularExpression or a CucumberExpression (because character\n         * matching is faster than startsWith/endsWith and regexp matching).\n         */\n        int length = expressionString.length();\n        if (length == 0) {\n            return new CucumberExpression(expressionString, this.parameterTypeRegistry);\n        }\n\n        int lastCharIndex = length - 1;\n        char firstChar = expressionString.charAt(0);\n        char lastChar = expressionString.charAt(lastCharIndex);\n\n        if (firstChar == '^' || lastChar == '$') {\n            return this.createRegularExpressionWithAnchors(expressionString);\n        } else if (firstChar == '/' && lastChar == '/') {\n            return new RegularExpression(Pattern.compile(expressionString.substring(1, lastCharIndex)), this.parameterTypeRegistry);\n        }\n\n        return new CucumberExpression(expressionString, this.parameterTypeRegistry);\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/ExpressionFactory.java", "class_name": "ExpressionFactory", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/ExpressionFactory.java.ExpressionFactory", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Expression", "classes": []}, "docstring": ""}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/ExpressionFactory.java.ExpressionFactory.[RegularExpression]createRegularExpressionWithAnchors(String)", "name": "createRegularExpressionWithAnchors", "arg_nums": 1, "params": [{"name": "expressionString", "type": "String"}], "return_type": "RegularExpression", "signature": "private RegularExpression createRegularExpressionWithAnchors(String expressionString)", "original_string": "    private RegularExpression createRegularExpressionWithAnchors(String expressionString) {\n        try {\n            return new RegularExpression(Pattern.compile(expressionString), parameterTypeRegistry);\n        } catch (PatternSyntaxException e) {\n            if (PARAMETER_PATTERN.matcher(expressionString).find()) {\n                throw new CucumberExpressionException(\"You cannot use anchors (^ or $) in Cucumber Expressions. Please remove them from \" + expressionString, e);\n            }\n            throw e;\n        }\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/ExpressionFactory.java", "class_name": "ExpressionFactory", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/ExpressionFactory.java.ExpressionFactory", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "RegularExpression", "classes": []}, "docstring": ""}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/DefaultPatternCompiler.java.DefaultPatternCompiler.[Pattern]compile(String,int)", "name": "compile", "arg_nums": 2, "params": [{"name": "regexp", "type": "String"}, {"name": "flags", "type": "int"}], "return_type": "Pattern", "signature": "@Override\n    public Pattern compile(String regexp, int flags)", "original_string": "    @Override\n    public Pattern compile(String regexp, int flags) {\n        return Pattern.compile(regexp, flags);\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/DefaultPatternCompiler.java", "class_name": "DefaultPatternCompiler", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/DefaultPatternCompiler.java.DefaultPatternCompiler", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Pattern", "classes": []}, "docstring": ""}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/CucumberExpression.java.CucumberExpression.[]CucumberExpression(String,ParameterTypeRegistry)", "name": "CucumberExpression", "arg_nums": 2, "params": [{"name": "expression", "type": "String"}, {"name": "parameterTypeRegistry", "type": "ParameterTypeRegistry"}], "return_type": "", "signature": "CucumberExpression(String expression, ParameterTypeRegistry parameterTypeRegistry)", "original_string": "    CucumberExpression(String expression, ParameterTypeRegistry parameterTypeRegistry) {\n        this.source = expression;\n        this.parameterTypeRegistry = parameterTypeRegistry;\n\n        CucumberExpressionParser parser = new CucumberExpressionParser();\n        Node ast = parser.parse(expression);\n        String pattern = rewriteToRegex(ast);\n        treeRegexp = new TreeRegexp(pattern);\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/CucumberExpression.java", "class_name": "CucumberExpression", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/CucumberExpression.java.CucumberExpression", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "docstring": ""}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/CucumberExpression.java.CucumberExpression.[String]rewriteToRegex(Node)", "name": "rewriteToRegex", "arg_nums": 1, "params": [{"name": "node", "type": "Node"}], "return_type": "String", "signature": "private String rewriteToRegex(Node node)", "original_string": "    private String rewriteToRegex(Node node) {\n        switch (node.type()) {\n            case TEXT_NODE:\n                return escapeRegex(node.text());\n            case OPTIONAL_NODE:\n                return rewriteOptional(node);\n            case ALTERNATION_NODE:\n                return rewriteAlternation(node);\n            case ALTERNATIVE_NODE:\n                return rewriteAlternative(node);\n            case PARAMETER_NODE:\n                return rewriteParameter(node);\n            case EXPRESSION_NODE:\n                return rewriteExpression(node);\n            default:\n                // Can't happen as long as the switch case is exhaustive\n                throw new IllegalArgumentException(node.type().name());\n        }\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/CucumberExpression.java", "class_name": "CucumberExpression", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/CucumberExpression.java.CucumberExpression", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "String", "classes": []}, "docstring": ""}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/CucumberExpression.java.CucumberExpression.[String]rewriteOptional(Node)", "name": "rewriteOptional", "arg_nums": 1, "params": [{"name": "node", "type": "Node"}], "return_type": "String", "signature": "private String rewriteOptional(Node node)", "original_string": "    private String rewriteOptional(Node node) {\n        assertNoParameters(node, astNode -> createParameterIsNotAllowedInOptional(astNode, source));\n        assertNoOptionals(node, astNode -> createOptionalIsNotAllowedInOptional(astNode, source));\n        assertNotEmpty(node, astNode -> createOptionalMayNotBeEmpty(astNode, source));\n        return node.nodes().stream()\n                .map(this::rewriteToRegex)\n                .collect(joining(\"\", \"(?:\", \")?\"));\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/CucumberExpression.java", "class_name": "CucumberExpression", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/CucumberExpression.java.CucumberExpression", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "String", "classes": []}, "docstring": ""}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/CucumberExpression.java.CucumberExpression.[String]rewriteAlternation(Node)", "name": "rewriteAlternation", "arg_nums": 1, "params": [{"name": "node", "type": "Node"}], "return_type": "String", "signature": "private String rewriteAlternation(Node node)", "original_string": "    private String rewriteAlternation(Node node) {\n        // Make sure the alternative parts aren't empty and don't contain parameter types\n        for (Node alternative : node.nodes()) {\n            if (alternative.nodes().isEmpty()) {\n                throw createAlternativeMayNotBeEmpty(alternative, source);\n            }\n            assertNotEmpty(alternative, astNode -> createAlternativeMayNotExclusivelyContainOptionals(astNode, source));\n        }\n        return node.nodes()\n                .stream()\n                .map(this::rewriteToRegex)\n                .collect(joining(\"|\", \"(?:\", \")\"));\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/CucumberExpression.java", "class_name": "CucumberExpression", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/CucumberExpression.java.CucumberExpression", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "String", "classes": []}, "docstring": ""}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/CucumberExpression.java.CucumberExpression.[String]rewriteAlternative(Node)", "name": "rewriteAlternative", "arg_nums": 1, "params": [{"name": "node", "type": "Node"}], "return_type": "String", "signature": "private String rewriteAlternative(Node node)", "original_string": "    private String rewriteAlternative(Node node) {\n        return node.nodes().stream()\n                .map(this::rewriteToRegex)\n                .collect(joining());\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/CucumberExpression.java", "class_name": "CucumberExpression", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/CucumberExpression.java.CucumberExpression", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "String", "classes": []}, "docstring": ""}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/CucumberExpression.java.CucumberExpression.[String]rewriteParameter(Node)", "name": "rewriteParameter", "arg_nums": 1, "params": [{"name": "node", "type": "Node"}], "return_type": "String", "signature": "private String rewriteParameter(Node node)", "original_string": "    private String rewriteParameter(Node node) {\n        String name = node.text();\n        ParameterType<?> parameterType = parameterTypeRegistry.lookupByTypeName(name);\n        if (parameterType == null) {\n            throw createUndefinedParameterType(node, source, name);\n        }\n        parameterTypes.add(parameterType);\n        List<String> regexps = parameterType.getRegexps();\n        if (regexps.size() == 1) {\n            return \"(\" + regexps.get(0) + \")\";\n        }\n        return regexps.stream()\n                .collect(joining(\")|(?:\", \"((?:\", \"))\"));\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/CucumberExpression.java", "class_name": "CucumberExpression", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/CucumberExpression.java.CucumberExpression", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "String", "classes": []}, "docstring": ""}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/CucumberExpression.java.CucumberExpression.[String]rewriteExpression(Node)", "name": "rewriteExpression", "arg_nums": 1, "params": [{"name": "node", "type": "Node"}], "return_type": "String", "signature": "private String rewriteExpression(Node node)", "original_string": "    private String rewriteExpression(Node node) {\n        return node.nodes().stream()\n                .map(this::rewriteToRegex)\n                .collect(joining(\"\", \"^\", \"$\"));\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/CucumberExpression.java", "class_name": "CucumberExpression", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/CucumberExpression.java.CucumberExpression", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "String", "classes": []}, "docstring": ""}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/CucumberExpression.java.CucumberExpression.[void]assertNotEmpty(Node,Function<Node, CucumberExpressionException>)", "name": "assertNotEmpty", "arg_nums": 2, "params": [{"name": "node", "type": "Node"}, {"name": "createNodeWasNotEmptyException", "type": "Function<Node, CucumberExpressionException>"}], "return_type": "void", "signature": "private void assertNotEmpty(Node node,\n            Function<Node, CucumberExpressionException> createNodeWasNotEmptyException)", "original_string": "    private void assertNotEmpty(Node node,\n            Function<Node, CucumberExpressionException> createNodeWasNotEmptyException) {\n        node.nodes()\n                .stream()\n                .filter(astNode -> TEXT_NODE.equals(astNode.type()))\n                .findFirst()\n                .orElseThrow(() -> createNodeWasNotEmptyException.apply(node));\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/CucumberExpression.java", "class_name": "CucumberExpression", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/CucumberExpression.java.CucumberExpression", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/CucumberExpression.java.CucumberExpression.[void]assertNoParameters(Node,Function<Node, CucumberExpressionException>)", "name": "assertNoParameters", "arg_nums": 2, "params": [{"name": "node", "type": "Node"}, {"name": "createNodeContainedAParameterException", "type": "Function<Node, CucumberExpressionException>"}], "return_type": "void", "signature": "private void assertNoParameters(Node node,\n            Function<Node, CucumberExpressionException> createNodeContainedAParameterException)", "original_string": "    private void assertNoParameters(Node node,\n            Function<Node, CucumberExpressionException> createNodeContainedAParameterException) {\n        assertNoNodeOfType(PARAMETER_NODE, node, createNodeContainedAParameterException);\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/CucumberExpression.java", "class_name": "CucumberExpression", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/CucumberExpression.java.CucumberExpression", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/CucumberExpression.java.CucumberExpression.[void]assertNoOptionals(Node,Function<Node, CucumberExpressionException>)", "name": "assertNoOptionals", "arg_nums": 2, "params": [{"name": "node", "type": "Node"}, {"name": "createNodeContainedAnOptionalException", "type": "Function<Node, CucumberExpressionException>"}], "return_type": "void", "signature": "private void assertNoOptionals(Node node,\n            Function<Node, CucumberExpressionException> createNodeContainedAnOptionalException)", "original_string": "    private void assertNoOptionals(Node node,\n            Function<Node, CucumberExpressionException> createNodeContainedAnOptionalException) {\n        assertNoNodeOfType(OPTIONAL_NODE, node, createNodeContainedAnOptionalException);\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/CucumberExpression.java", "class_name": "CucumberExpression", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/CucumberExpression.java.CucumberExpression", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/CucumberExpression.java.CucumberExpression.[void]assertNoNodeOfType(Node.Type,Node,Function<Node, CucumberExpressionException>)", "name": "assertNoNodeOfType", "arg_nums": 3, "params": [{"name": "nodeType", "type": "Node.Type"}, {"name": "node", "type": "Node"}, {"name": "createException", "type": "Function<Node, CucumberExpressionException>"}], "return_type": "void", "signature": "private void assertNoNodeOfType(Node.Type nodeType, Node node,\n            Function<Node, CucumberExpressionException> createException)", "original_string": "    private void assertNoNodeOfType(Node.Type nodeType, Node node,\n            Function<Node, CucumberExpressionException> createException) {\n        node.nodes()\n                .stream()\n                .filter(astNode -> nodeType.equals(astNode.type()))\n                .map(createException)\n                .findFirst()\n                .ifPresent(exception -> {\n                    throw exception;\n                });\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/CucumberExpression.java", "class_name": "CucumberExpression", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/CucumberExpression.java.CucumberExpression", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/CucumberExpression.java.CucumberExpression.[List<Argument<?>>]match(String)", "name": "match", "arg_nums": 1, "params": [{"name": "text", "type": "String"}], "return_type": "List<Argument<?>>", "signature": "@Override\n    public List<Argument<?>> match(String text, Type... typeHints)", "original_string": "    @Override\n    public List<Argument<?>> match(String text, Type... typeHints) {\n        final Group group = treeRegexp.match(text);\n        if (group == null) {\n            return null;\n        }\n\n        List<ParameterType<?>> parameterTypes = new ArrayList<>(this.parameterTypes);\n        for (int i = 0; i < parameterTypes.size(); i++) {\n            ParameterType<?> parameterType = parameterTypes.get(i);\n            Type type = i < typeHints.length ? typeHints[i] : String.class;\n            if (parameterType.isAnonymous()) {\n                ParameterByTypeTransformer defaultTransformer = parameterTypeRegistry.getDefaultParameterTransformer();\n                parameterTypes.set(i, parameterType.deAnonymize(type, arg -> defaultTransformer.transform(arg, type)));\n            }\n        }\n\n        return Argument.build(group, parameterTypes);\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/CucumberExpression.java", "class_name": "CucumberExpression", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/CucumberExpression.java.CucumberExpression", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "List<Argument<?>>", "classes": []}, "docstring": ""}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/CucumberExpression.java.CucumberExpression.[String]getSource()", "name": "getSource", "arg_nums": 0, "params": [], "return_type": "String", "signature": "@Override\n    public String getSource()", "original_string": "    @Override\n    public String getSource() {\n        return source;\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/CucumberExpression.java", "class_name": "CucumberExpression", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/CucumberExpression.java.CucumberExpression", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "docstring": ""}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/CucumberExpression.java.CucumberExpression.[Pattern]getRegexp()", "name": "getRegexp", "arg_nums": 0, "params": [], "return_type": "Pattern", "signature": "@Override\n    public Pattern getRegexp()", "original_string": "    @Override\n    public Pattern getRegexp() {\n        return treeRegexp.pattern();\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/CucumberExpression.java", "class_name": "CucumberExpression", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/CucumberExpression.java.CucumberExpression", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Pattern", "classes": []}, "docstring": ""}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/GroupBuilder.java.GroupBuilder.[]GroupBuilder(int)", "name": "GroupBuilder", "arg_nums": 1, "params": [{"name": "startIndex", "type": "int"}], "return_type": "", "signature": "GroupBuilder(int startIndex)", "original_string": "    GroupBuilder(int startIndex) {\n        this.startIndex = startIndex;\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/GroupBuilder.java", "class_name": "GroupBuilder", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/GroupBuilder.java.GroupBuilder", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "docstring": ""}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/GroupBuilder.java.GroupBuilder.[void]add(GroupBuilder)", "name": "add", "arg_nums": 1, "params": [{"name": "groupBuilder", "type": "GroupBuilder"}], "return_type": "void", "signature": "void add(GroupBuilder groupBuilder)", "original_string": "    void add(GroupBuilder groupBuilder) {\n        groupBuilders.add(groupBuilder);\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/GroupBuilder.java", "class_name": "GroupBuilder", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/GroupBuilder.java.GroupBuilder", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/GroupBuilder.java.GroupBuilder.[Group]build(Matcher,Iterator<Integer>)", "name": "build", "arg_nums": 2, "params": [{"name": "matcher", "type": "Matcher"}, {"name": "groupIndices", "type": "Iterator<Integer>"}], "return_type": "Group", "signature": "Group build(Matcher matcher, Iterator<Integer> groupIndices)", "original_string": "    Group build(Matcher matcher, Iterator<Integer> groupIndices) {\n        int groupIndex = groupIndices.next();\n        List<Group> children = new ArrayList<>(groupBuilders.size());\n        for (GroupBuilder childGroupBuilder : groupBuilders) {\n            children.add(childGroupBuilder.build(matcher, groupIndices));\n        }\n        return new Group(matcher.group(groupIndex), matcher.start(groupIndex), matcher.end(groupIndex), children);\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/GroupBuilder.java", "class_name": "GroupBuilder", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/GroupBuilder.java.GroupBuilder", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "Group", "classes": []}, "docstring": ""}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/GroupBuilder.java.GroupBuilder.[void]setNonCapturing()", "name": "setNonCapturing", "arg_nums": 0, "params": [], "return_type": "void", "signature": "void setNonCapturing()", "original_string": "    void setNonCapturing() {\n        this.capturing = false;\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/GroupBuilder.java", "class_name": "GroupBuilder", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/GroupBuilder.java.GroupBuilder", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/GroupBuilder.java.GroupBuilder.[boolean]isCapturing()", "name": "isCapturing", "arg_nums": 0, "params": [], "return_type": "boolean", "signature": "boolean isCapturing()", "original_string": "    boolean isCapturing() {\n        return capturing;\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/GroupBuilder.java", "class_name": "GroupBuilder", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/GroupBuilder.java.GroupBuilder", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "boolean", "classes": []}, "docstring": ""}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/GroupBuilder.java.GroupBuilder.[void]moveChildrenTo(GroupBuilder)", "name": "moveChildrenTo", "arg_nums": 1, "params": [{"name": "groupBuilder", "type": "GroupBuilder"}], "return_type": "void", "signature": "void moveChildrenTo(GroupBuilder groupBuilder)", "original_string": "    void moveChildrenTo(GroupBuilder groupBuilder) {\n        for (GroupBuilder child : groupBuilders) {\n            groupBuilder.add(child);\n        }\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/GroupBuilder.java", "class_name": "GroupBuilder", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/GroupBuilder.java.GroupBuilder", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/GroupBuilder.java.GroupBuilder.[List<GroupBuilder>]getChildren()", "name": "getChildren", "arg_nums": 0, "params": [], "return_type": "List<GroupBuilder>", "signature": "List<GroupBuilder> getChildren()", "original_string": "    List<GroupBuilder> getChildren() {\n        return groupBuilders;\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/GroupBuilder.java", "class_name": "GroupBuilder", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/GroupBuilder.java.GroupBuilder", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "List<GroupBuilder>", "classes": []}, "docstring": ""}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/GroupBuilder.java.GroupBuilder.[String]getSource()", "name": "getSource", "arg_nums": 0, "params": [], "return_type": "String", "signature": "String getSource()", "original_string": "    String getSource() {\n        return source;\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/GroupBuilder.java", "class_name": "GroupBuilder", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/GroupBuilder.java.GroupBuilder", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "String", "classes": []}, "docstring": ""}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/GroupBuilder.java.GroupBuilder.[void]setSource(String)", "name": "setSource", "arg_nums": 1, "params": [{"name": "source", "type": "String"}], "return_type": "void", "signature": "void setSource(String source)", "original_string": "    void setSource(String source) {\n        this.source = source;\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/GroupBuilder.java", "class_name": "GroupBuilder", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/GroupBuilder.java.GroupBuilder", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/GroupBuilder.java.GroupBuilder.[int]getStartIndex()", "name": "getStartIndex", "arg_nums": 0, "params": [], "return_type": "int", "signature": "int getStartIndex()", "original_string": "    int getStartIndex() {\n        return startIndex;\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/GroupBuilder.java", "class_name": "GroupBuilder", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/GroupBuilder.java.GroupBuilder", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "int", "classes": []}, "docstring": ""}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/GroupBuilder.java.GroupBuilder.[int]getEndIndex()", "name": "getEndIndex", "arg_nums": 0, "params": [], "return_type": "int", "signature": "int getEndIndex()", "original_string": "    int getEndIndex() {\n        return endIndex;\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/GroupBuilder.java", "class_name": "GroupBuilder", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/GroupBuilder.java.GroupBuilder", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "int", "classes": []}, "docstring": ""}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/GroupBuilder.java.GroupBuilder.[void]setEndIndex(int)", "name": "setEndIndex", "arg_nums": 1, "params": [{"name": "endIndex", "type": "int"}], "return_type": "void", "signature": "void setEndIndex(int endIndex)", "original_string": "    void setEndIndex(int endIndex) {\n        this.endIndex = endIndex;\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/GroupBuilder.java", "class_name": "GroupBuilder", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/GroupBuilder.java.GroupBuilder", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/PatternCompilerProvider.java.PatternCompilerProvider.[]PatternCompilerProvider()", "name": "PatternCompilerProvider", "arg_nums": 0, "params": [], "return_type": "", "signature": "private PatternCompilerProvider()", "original_string": "    private PatternCompilerProvider() {\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/PatternCompilerProvider.java", "class_name": "PatternCompilerProvider", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/PatternCompilerProvider.java.PatternCompilerProvider", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "", "classes": []}, "docstring": ""}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/PatternCompilerProvider.java.PatternCompilerProvider.[PatternCompiler]getCompiler()", "name": "getCompiler", "arg_nums": 0, "params": [], "return_type": "PatternCompiler", "signature": "static synchronized PatternCompiler getCompiler()", "original_string": "    static synchronized PatternCompiler getCompiler() {\n        if (service == null) {\n            ServiceLoader<PatternCompiler> loader = ServiceLoader.load(PatternCompiler.class);\n            Iterator<PatternCompiler> iterator = loader.iterator();\n            findPatternCompiler(iterator);\n        }\n        return service;\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/PatternCompilerProvider.java", "class_name": "PatternCompilerProvider", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/PatternCompilerProvider.java.PatternCompilerProvider", "attributes": {"modifiers": "static synchronized", "marker_annotations": [], "non_marker_annotations": ["static", "synchronized"], "comments": [], "return_type": "PatternCompiler", "classes": []}, "docstring": ""}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/PatternCompilerProvider.java.PatternCompilerProvider.[void]findPatternCompiler(Iterator<PatternCompiler>)", "name": "findPatternCompiler", "arg_nums": 1, "params": [{"name": "iterator", "type": "Iterator<PatternCompiler>"}], "return_type": "void", "signature": "static void findPatternCompiler(Iterator<PatternCompiler> iterator)", "original_string": "    static void findPatternCompiler(Iterator<PatternCompiler> iterator) {\n        if (iterator.hasNext()) {\n            service = iterator.next();\n            if (iterator.hasNext()) {\n                throwMoreThanOneCompilerException(iterator);\n            }\n        } else {\n            service = new DefaultPatternCompiler();\n        }\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/PatternCompilerProvider.java", "class_name": "PatternCompilerProvider", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/PatternCompilerProvider.java.PatternCompilerProvider", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/PatternCompilerProvider.java.PatternCompilerProvider.[void]throwMoreThanOneCompilerException(Iterator<PatternCompiler>)", "name": "throwMoreThanOneCompilerException", "arg_nums": 1, "params": [{"name": "iterator", "type": "Iterator<PatternCompiler>"}], "return_type": "void", "signature": "private static void throwMoreThanOneCompilerException(Iterator<PatternCompiler> iterator)", "original_string": "    private static void throwMoreThanOneCompilerException(Iterator<PatternCompiler> iterator) {\n        List<Class<? extends PatternCompiler>> allCompilers = new ArrayList<>();\n        allCompilers.add(service.getClass());\n        while (iterator.hasNext()) {\n            allCompilers.add(iterator.next().getClass());\n        }\n        throw new IllegalStateException(\"More than one PatternCompiler: \" + allCompilers);\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/PatternCompilerProvider.java", "class_name": "PatternCompilerProvider", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/PatternCompilerProvider.java.PatternCompilerProvider", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/CaptureGroupTransformer.java.CaptureGroupTransformer.[T]transform(String[])", "name": "transform", "arg_nums": 1, "params": [{"name": "args", "type": "String[]"}], "return_type": "T", "signature": "T transform(String[] args)", "original_string": "    T transform(String[] args) throws Throwable;", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/CaptureGroupTransformer.java", "class_name": "CaptureGroupTransformer", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/CaptureGroupTransformer.java.CaptureGroupTransformer", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "T", "classes": []}, "docstring": "\nTransforms multiple strings into to an object. The strings are taken from\nthe capture groups in the regular expressions in order. Nested capture\ngroups are ignored. If a capture group is optional the corresponding element\nin the array may be null.\n\n@param args the values of the top level capture groups\n@return the transformed object\n@throws Throwable if transformation failed\n"}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/GeneratedExpression.java.GeneratedExpression.[]GeneratedExpression(String,List<ParameterType<?>>)", "name": "GeneratedExpression", "arg_nums": 2, "params": [{"name": "expressionTemplate", "type": "String"}, {"name": "parameterTypes", "type": "List<ParameterType<?>>"}], "return_type": "", "signature": "GeneratedExpression(String expressionTemplate, List<ParameterType<?>> parameterTypes)", "original_string": "    GeneratedExpression(String expressionTemplate, List<ParameterType<?>> parameterTypes) {\n        this.expressionTemplate = expressionTemplate;\n        this.parameterTypes = parameterTypes;\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/GeneratedExpression.java", "class_name": "GeneratedExpression", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/GeneratedExpression.java.GeneratedExpression", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "docstring": ""}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/GeneratedExpression.java.GeneratedExpression.[boolean]isJavaKeyword(String)", "name": "isJavaKeyword", "arg_nums": 1, "params": [{"name": "keyword", "type": "String"}], "return_type": "boolean", "signature": "private static boolean isJavaKeyword(String keyword)", "original_string": "    private static boolean isJavaKeyword(String keyword) {\n        return (Arrays.binarySearch(JAVA_KEYWORDS, keyword, ENGLISH_COLLATOR) >= 0);\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/GeneratedExpression.java", "class_name": "GeneratedExpression", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/GeneratedExpression.java.GeneratedExpression", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": ""}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/GeneratedExpression.java.GeneratedExpression.[String]getSource()", "name": "getSource", "arg_nums": 0, "params": [], "return_type": "String", "signature": "public String getSource()", "original_string": "    public String getSource() {\n        List<String> parameterTypeNames = new ArrayList<>();\n        for (ParameterType<?> parameterType : parameterTypes) {\n            String name = parameterType.getName();\n            parameterTypeNames.add(name);\n        }\n        return String.format(expressionTemplate, parameterTypeNames.toArray());\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/GeneratedExpression.java", "class_name": "GeneratedExpression", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/GeneratedExpression.java.GeneratedExpression", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "docstring": ""}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/GeneratedExpression.java.GeneratedExpression.[String]getParameterName(String,Map<String, Integer>)", "name": "getParameterName", "arg_nums": 2, "params": [{"name": "typeName", "type": "String"}, {"name": "usageByTypeName", "type": "Map<String, Integer>"}], "return_type": "String", "signature": "private String getParameterName(String typeName, Map<String, Integer> usageByTypeName)", "original_string": "    private String getParameterName(String typeName, Map<String, Integer> usageByTypeName) {\n        Integer count = usageByTypeName.get(typeName);\n        count = count != null ? count + 1 : 1;\n        usageByTypeName.put(typeName, count);\n\n        return count == 1 && !isJavaKeyword(typeName) ? typeName : typeName + count;\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/GeneratedExpression.java", "class_name": "GeneratedExpression", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/GeneratedExpression.java.GeneratedExpression", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "String", "classes": []}, "docstring": ""}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/GeneratedExpression.java.GeneratedExpression.[List<String>]getParameterNames()", "name": "getParameterNames", "arg_nums": 0, "params": [], "return_type": "List<String>", "signature": "public List<String> getParameterNames()", "original_string": "    public List<String> getParameterNames() {\n        HashMap<String, Integer> usageByTypeName = new HashMap<>();\n        List<String> list = new ArrayList<>();\n        for (ParameterType<?> parameterType : parameterTypes) {\n            String parameterName = getParameterName(parameterType.getName(), usageByTypeName);\n            list.add(parameterName);\n        }\n        return list;\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/GeneratedExpression.java", "class_name": "GeneratedExpression", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/GeneratedExpression.java.GeneratedExpression", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "List<String>", "classes": []}, "docstring": ""}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/GeneratedExpression.java.GeneratedExpression.[List<ParameterType<?>>]getParameterTypes()", "name": "getParameterTypes", "arg_nums": 0, "params": [], "return_type": "List<ParameterType<?>>", "signature": "public List<ParameterType<?>> getParameterTypes()", "original_string": "    public List<ParameterType<?>> getParameterTypes() {\n        return parameterTypes;\n    }", "default_arguments": null, "file": "src/main/java/io/cucumber/cucumberexpressions/GeneratedExpression.java", "class_name": "GeneratedExpression", "class_uri": "src/main/java/io/cucumber/cucumberexpressions/GeneratedExpression.java.GeneratedExpression", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "List<ParameterType<?>>", "classes": []}, "docstring": ""}]