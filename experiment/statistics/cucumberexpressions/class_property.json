[{"class_uri": "src/test/java/io/cucumber/cucumberexpressions/CustomMatchers.java.CustomMatchers", "class_docstring": "", "superclasses": "", "super_interfaces": [], "methods": [{"method_name": "equalOrCloseTo", "description": "Creates a matcher that matches an iterable if its elements are equal or close to the elements of the provided list. Handles numeric types with a focus on closeness for floating-point numbers.", "expected_testcases": [{"testcase_name": "EmptyList", "description": "Test with an empty list, expecting the matcher to return a matcher that matches an empty iterable."}, {"testcase_name": "NullList", "description": "Test with a null list, expecting the matcher to return a matcher that matches a null iterable."}, {"testcase_name": "ListWithIntegers", "description": "Test with a list of integers, expecting the matcher to return a matcher that matches an iterable with the same integers in the same order."}, {"testcase_name": "ListWithFloats", "description": "Test with a list of floating-point numbers, expecting the matcher to return a matcher that matches an iterable with numbers close to the provided floats within a tolerance of 0.0001."}, {"testcase_name": "ListWithMixedTypes", "description": "Test with a list containing mixed types (e.g., integers, floats, strings), expecting the matcher to return a matcher that matches an iterable with the same elements in the same order, handling floats with closeness."}]}, {"method_name": "EqualOrCloseTo.matches", "description": "Determines if the actual value matches the expected value, considering closeness for certain numeric types.", "expected_testcases": [{"testcase_name": "MatchInteger", "description": "Test with an integer, expecting the matcher to return true if the actual value is equal to the expected integer."}, {"testcase_name": "MatchFloatWithinTolerance", "description": "Test with a floating-point number, expecting the matcher to return true if the actual value is within 0.0001 of the expected float."}, {"testcase_name": "MatchFloatOutsideTolerance", "description": "Test with a floating-point number, expecting the matcher to return false if the actual value is outside 0.0001 of the expected float."}, {"testcase_name": "MatchString", "description": "Test with a string, expecting the matcher to return true if the actual value is equal to the expected string."}, {"testcase_name": "UnsupportedType", "description": "Test with an unsupported type (e.g., a custom object), expecting the matcher to throw a RuntimeException."}]}, {"method_name": "EqualOrCloseTo.describeTo", "description": "Describes the matcher by appending the expected value to the description.", "expected_testcases": []}], "overrides": null, "class_name": "CustomMatchers", "description": "Class providing custom matchers for comparing iterables with a focus on equality or closeness for certain numeric types."}, {"class_uri": "src/main/java/io/cucumber/cucumberexpressions/ParameterTypeMatcher.java.ParameterTypeMatcher", "class_docstring": "", "superclasses": "", "super_interfaces": [], "methods": [{"method_name": "ParameterTypeMatcher", "description": "Constructor that initializes the ParameterTypeMatcher with a ParameterType, a Matcher, and a String.", "expected_testcases": []}, {"method_name": "isWhitespaceOrPunctuationOrSymbol", "description": "Private static method that checks if a character is a whitespace, punctuation, or symbol.", "expected_testcases": [{"testcase_name": "WhitespaceCharacter", "description": "Test with a whitespace character, expecting true."}, {"testcase_name": "PunctuationCharacter", "description": "Test with a punctuation character, expecting true."}, {"testcase_name": "SymbolCharacter", "description": "Test with a symbol character, expecting true."}, {"testcase_name": "AlphabetCharacter", "description": "Test with an alphabet character, expecting false."}, {"testcase_name": "DigitCharacter", "description": "Test with a digit character, expecting false."}]}, {"method_name": "advanceToAndFind", "description": "Method that advances the matcher to a new position and finds matches, checking for word boundaries.", "expected_testcases": [{"testcase_name": "MatchFoundWithWordBoundaries", "description": "Test with a text that has a match with word boundaries on both sides, expecting true."}, {"testcase_name": "MatchFoundWithoutWordBoundaries", "description": "Test with a text that has a match without word boundaries on both sides, expecting false."}, {"testcase_name": "NoMatchFound", "description": "Test with a text that does not have any match, expecting false."}, {"testcase_name": "EmptyGroupMatch", "description": "Test with a text that has a match but the group is empty, expecting false."}]}, {"method_name": "groupHasWordBoundaryOnBothSides", "description": "Private method that checks if the current match has word boundaries on both sides.", "expected_testcases": []}, {"method_name": "groupHasLeftWordBoundary", "description": "Private method that checks if the current match has a word boundary on the left side.", "expected_testcases": []}, {"method_name": "groupHasRightWordBoundary", "description": "Private method that checks if the current match has a word boundary on the right side.", "expected_testcases": []}, {"method_name": "start", "description": "Method that returns the start position of the current match.", "expected_testcases": [{"testcase_name": "ValidMatchStart", "description": "Test with a valid match, expecting the correct start position."}, {"testcase_name": "NoMatchStart", "description": "Test with no match, expecting an exception or default value."}]}, {"method_name": "group", "description": "Method that returns the matched group.", "expected_testcases": [{"testcase_name": "ValidMatchGroup", "description": "Test with a valid match, expecting the correct matched group."}, {"testcase_name": "NoMatchGroup", "description": "Test with no match, expecting an exception or default value."}]}, {"method_name": "compareTo", "description": "Method that compares this ParameterTypeMatcher with another one based on start position, group length, and parameter type weight.", "expected_testcases": [{"testcase_name": "DifferentStartPositions", "description": "Test with different start positions, expecting comparison based on start position."}, {"testcase_name": "SameStartPositionsDifferentGroupLengths", "description": "Test with same start positions but different group lengths, expecting comparison based on group length."}, {"testcase_name": "SameStartPositionsSameGroupLengthsDifferentWeights", "description": "Test with same start positions, same group lengths but different parameter type weights, expecting comparison based on weight."}, {"testcase_name": "SameStartPositionsSameGroupLengthsSameWeights", "description": "Test with same start positions, same group lengths, and same parameter type weights, expecting zero comparison result."}]}, {"method_name": "getParameterType", "description": "Method that returns the ParameterType associated with this matcher.", "expected_testcases": [{"testcase_name": "GetParameterType", "description": "Test to retrieve the ParameterType, expecting the correct ParameterType object."}]}, {"method_name": "toString", "description": "Method that returns a string representation of the ParameterType's type.", "expected_testcases": [{"testcase_name": "ToStringRepresentation", "description": "Test to retrieve the string representation, expecting the correct string."}]}], "overrides": null, "class_name": "ParameterTypeMatcher", "description": "A class that matches parameter types using a Matcher and provides comparison functionality for sorting."}, {"class_uri": "src/main/java/io/cucumber/cucumberexpressions/UndefinedParameterTypeException.java.UndefinedParameterTypeException", "class_docstring": "", "superclasses": "CucumberExpressionException", "super_interfaces": [], "methods": [{"method_name": "UndefinedParameterTypeException", "description": "Constructor that initializes the exception with a message and the name of the undefined parameter type.", "expected_testcases": [{"testcase_name": "ValidInitialization", "description": "Initialize the exception with a valid message and parameter type name, expecting the exception to be created without errors."}, {"testcase_name": "EmptyMessage", "description": "Initialize the exception with an empty message and a valid parameter type name, expecting the exception to be created without errors."}, {"testcase_name": "EmptyParameterTypeName", "description": "Initialize the exception with a valid message and an empty parameter type name, expecting the exception to be created without errors."}]}, {"method_name": "getUndefinedParameterTypeName", "description": "Returns the name of the undefined parameter type.", "expected_testcases": [{"testcase_name": "ValidParameterTypeName", "description": "Get the parameter type name after initializing the exception with a valid name, expecting the correct name to be returned."}, {"testcase_name": "EmptyParameterTypeName", "description": "Get the parameter type name after initializing the exception with an empty name, expecting an empty string to be returned."}]}, {"method_name": "createUndefinedParameterType", "description": "Creates an exception for an undefined parameter type, including detailed error message generation.", "expected_testcases": [{"testcase_name": "ValidNodeAndExpression", "description": "Create an exception with a valid node, expression, and parameter type name, expecting the exception to be created with the correct message."}, {"testcase_name": "NullNode", "description": "Create an exception with a null node, expecting a NullPointerException or similar error to be thrown."}, {"testcase_name": "EmptyExpression", "description": "Create an exception with an empty expression, expecting the exception to be created with the correct message."}]}, {"method_name": "createMissingEndToken", "description": "Creates an exception for a missing end token in the expression.", "expected_testcases": [{"testcase_name": "ValidTokens", "description": "Create an exception with valid begin and end tokens, expecting the exception to be created with the correct message."}, {"testcase_name": "NullCurrentToken", "description": "Create an exception with a null current token, expecting a NullPointerException or similar error to be thrown."}]}, {"method_name": "createAlternationNotAllowedInOptional", "description": "Creates an exception for an alternation not allowed within an optional.", "expected_testcases": [{"testcase_name": "ValidToken", "description": "Create an exception with a valid token, expecting the exception to be created with the correct message."}, {"testcase_name": "NullToken", "description": "Create an exception with a null token, expecting a NullPointerException or similar error to be thrown."}]}, {"method_name": "createTheEndOfLineCanNotBeEscaped", "description": "Creates an exception for attempting to escape the end of a line.", "expected_testcases": [{"testcase_name": "ValidExpression", "description": "Create an exception with a valid expression, expecting the exception to be created with the correct message."}, {"testcase_name": "EmptyExpression", "description": "Create an exception with an empty expression, expecting the exception to be created with the correct message."}]}, {"method_name": "createAlternativeMayNotBeEmpty", "description": "Creates an exception for an empty alternative in the expression.", "expected_testcases": [{"testcase_name": "ValidNode", "description": "Create an exception with a valid node, expecting the exception to be created with the correct message."}, {"testcase_name": "NullNode", "description": "Create an exception with a null node, expecting a NullPointerException or similar error to be thrown."}]}, {"method_name": "createParameterIsNotAllowedInOptional", "description": "Creates an exception for a parameter type not allowed within an optional.", "expected_testcases": [{"testcase_name": "ValidNode", "description": "Create an exception with a valid node, expecting the exception to be created with the correct message."}, {"testcase_name": "NullNode", "description": "Create an exception with a null node, expecting a NullPointerException or similar error to be thrown."}]}, {"method_name": "createOptionalIsNotAllowedInOptional", "description": "Creates an exception for an optional not allowed within another optional.", "expected_testcases": [{"testcase_name": "ValidNode", "description": "Create an exception with a valid node, expecting the exception to be created with the correct message."}, {"testcase_name": "NullNode", "description": "Create an exception with a null node, expecting a NullPointerException or similar error to be thrown."}]}, {"method_name": "createOptionalMayNotBeEmpty", "description": "Creates an exception for an empty optional in the expression.", "expected_testcases": [{"testcase_name": "ValidNode", "description": "Create an exception with a valid node, expecting the exception to be created with the correct message."}, {"testcase_name": "NullNode", "description": "Create an exception with a null node, expecting a NullPointerException or similar error to be thrown."}]}, {"method_name": "createAlternativeMayNotExclusivelyContainOptionals", "description": "Creates an exception for an alternative that exclusively contains optionals.", "expected_testcases": [{"testcase_name": "ValidNode", "description": "Create an exception with a valid node, expecting the exception to be created with the correct message."}, {"testcase_name": "NullNode", "description": "Create an exception with a null node, expecting a NullPointerException or similar error to be thrown."}]}, {"method_name": "createCantEscape", "description": "Creates an exception for attempting to escape an invalid character.", "expected_testcases": [{"testcase_name": "ValidIndex", "description": "Create an exception with a valid index, expecting the exception to be created with the correct message."}, {"testcase_name": "OutOfBoundsIndex", "description": "Create an exception with an index out of bounds, expecting the exception to be created with the correct message."}]}, {"method_name": "createInvalidParameterTypeName", "description": "Creates an exception for an invalid parameter type name.", "expected_testcases": [{"testcase_name": "ValidName", "description": "Create an exception with a valid name, expecting the exception to be created with the correct message."}, {"testcase_name": "InvalidName", "description": "Create an exception with an invalid name, expecting the exception to be created with the correct message."}]}, {"method_name": "message", "description": "Generates a detailed error message for the exception.", "expected_testcases": [{"testcase_name": "ValidInputs", "description": "Generate a message with valid inputs, expecting the correct detailed message to be returned."}, {"testcase_name": "InvalidIndex", "description": "Generate a message with an invalid index, expecting the correct detailed message to be returned."}]}, {"method_name": "pointAt", "description": "Generates a pointer string to indicate the position of the error in the expression.", "expected_testcases": [{"testcase_name": "ValidNode", "description": "Generate a pointer with a valid node, expecting the correct pointer string to be returned."}, {"testcase_name": "NullNode", "description": "Generate a pointer with a null node, expecting a NullPointerException or similar error to be thrown."}]}], "overrides": null, "class_name": "UndefinedParameterTypeException", "description": "This class extends CucumberExpressionException and is used to handle exceptions related to undefined parameter types in Cucumber expressions."}, {"class_uri": "src/main/java/io/cucumber/cucumberexpressions/ParameterType.java.ParameterType", "class_docstring": "", "superclasses": "", "super_interfaces": [], "methods": [{"method_name": "checkParameterTypeName", "description": "Validates the given parameter type name to ensure it does not contain illegal characters.", "expected_testcases": [{"testcase_name": "ValidParameterName", "description": "Test with a valid parameter name that does not contain any illegal characters, expecting no exception to be thrown."}, {"testcase_name": "InvalidParameterName", "description": "Test with an invalid parameter name containing illegal characters, expecting a CucumberExpressionException to be thrown."}, {"testcase_name": "EmptyParameterName", "description": "Test with an empty parameter name, expecting no exception to be thrown as it is considered valid."}]}, {"method_name": "isValidParameterTypeName", "description": "Checks if the given parameter type name is valid by ensuring it does not contain illegal characters after unescaping.", "expected_testcases": [{"testcase_name": "ValidParameterName", "description": "Test with a valid parameter name that does not contain any illegal characters, expecting the method to return true."}, {"testcase_name": "InvalidParameterName", "description": "Test with an invalid parameter name containing illegal characters, expecting the method to return false."}, {"testcase_name": "EmptyParameterName", "description": "Test with an empty parameter name, expecting the method to return true as it is considered valid."}]}, {"method_name": "createAnonymousParameterType", "description": "Creates an anonymous parameter type with the given regular expression.", "expected_testcases": [{"testcase_name": "ValidRegexp", "description": "Test with a valid regular expression, expecting an anonymous ParameterType object to be created without exceptions."}, {"testcase_name": "InvalidRegexp", "description": "Test with an invalid regular expression, expecting an exception to be thrown during the creation of the ParameterType object."}]}, {"method_name": "fromEnum", "description": "Creates a ParameterType from an Enum class, using the enum constants as the regular expression.", "expected_testcases": [{"testcase_name": "ValidEnum", "description": "Test with a valid Enum class, expecting a ParameterType object to be created without exceptions."}, {"testcase_name": "EmptyEnum", "description": "Test with an Enum class with no constants, expecting a ParameterType object to be created without exceptions but with an empty regular expression."}]}, {"method_name": "transform", "description": "Transforms a list of captured group values into the specified type using the transformer.", "expected_testcases": [{"testcase_name": "SingleCaptureGroup", "description": "Test with a single capture group, expecting the transformer to successfully transform the value without exceptions."}, {"testcase_name": "MultipleCaptureGroups", "description": "Test with multiple capture groups, expecting a CucumberExpressionException to be thrown if the transformer is not a CaptureGroupTransformer."}, {"testcase_name": "AnonymousParameterTypeWithMultipleGroups", "description": "Test with an anonymous parameter type and multiple capture groups, expecting a CucumberExpressionException to be thrown."}]}, {"method_name": "compareTo", "description": "Compares this ParameterType with another based on preference for regular expression match and name.", "expected_testcases": [{"testcase_name": "PreferentialParameterType", "description": "Test comparing a preferential parameter type with a non-preferential one, expecting a negative comparison result."}, {"testcase_name": "NonPreferentialParameterType", "description": "Test comparing a non-preferential parameter type with a preferential one, expecting a positive comparison result."}, {"testcase_name": "SamePreferenceDifferentName", "description": "Test comparing two parameter types with the same preference but different names, expecting a comparison result based on name."}]}, {"method_name": "weight", "description": "Returns a weight for this parameter type, which is higher for Integer types.", "expected_testcases": [{"testcase_name": "IntegerType", "description": "Test with an Integer type, expecting the method to return a weight of 1000."}, {"testcase_name": "NonIntegerType", "description": "Test with a non-Integer type, expecting the method to return a weight of 0."}]}], "overrides": null, "class_name": "ParameterType", "description": "A class that represents a parameter type in Cucumber expressions, which includes functionality for validating parameter names, creating anonymous parameter types, and transforming captured groups into specific types."}, {"class_uri": "src/main/java/io/cucumber/cucumberexpressions/RegexpUtils.java.RegexpUtils", "class_docstring": "", "superclasses": "", "super_interfaces": [], "methods": [{"method_name": "escapeRegex", "description": "Escapes the specified regular expression characters from the input text to prevent them from being interpreted as special characters in a regular expression context.", "expected_testcases": [{"testcase_name": "NoSpecialCharacters", "description": "Input text contains no special characters that need escaping. Expect the output to be identical to the input."}, {"testcase_name": "SingleSpecialCharacter", "description": "Input text contains a single special character that needs escaping. Expect the output to have that character escaped with a backslash."}, {"testcase_name": "MultipleSpecialCharacters", "description": "Input text contains multiple special characters that need escaping. Expect the output to have all those characters escaped with backslashes."}, {"testcase_name": "AllSpecialCharacters", "description": "Input text contains all special characters that need escaping. Expect the output to have all characters escaped with backslashes."}, {"testcase_name": "EmptyString", "description": "Input text is an empty string. Expect the output to be an empty string as well."}, {"testcase_name": "SpecialCharacterAtStart", "description": "Input text starts with a special character that needs escaping. Expect the output to have that character escaped with a backslash at the start."}, {"testcase_name": "SpecialCharacterAtEnd", "description": "Input text ends with a special character that needs escaping. Expect the output to have that character escaped with a backslash at the end."}, {"testcase_name": "SpecialCharacterInMiddle", "description": "Input text has a special character that needs escaping in the middle. Expect the output to have that character escaped with a backslash in the middle."}, {"testcase_name": "ConsecutiveSpecialCharacters", "description": "Input text contains consecutive special characters that need escaping. Expect the output to have all consecutive characters escaped with backslashes."}, {"testcase_name": "MixedCharacters", "description": "Input text contains a mix of special characters that need escaping and regular characters. Expect the output to have only the special characters escaped with backslashes."}]}], "overrides": null, "class_name": "RegexpUtils", "description": "Utility class for escaping regular expression characters in a given text to ensure they are not interpreted as special characters in a regular expression context."}, {"class_uri": "src/main/java/io/cucumber/cucumberexpressions/Group.java.Group", "class_docstring": "", "superclasses": "", "super_interfaces": [], "methods": [{"method_name": "getValue", "description": "Returns the value of the group.", "expected_testcases": [{"testcase_name": "GetValueWithNonNullValue", "description": "Test with a group having a non-null value, expecting the same value to be returned."}, {"testcase_name": "GetValueWithNullValue", "description": "Test with a group having a null value, expecting null to be returned."}]}, {"method_name": "getStart", "description": "Returns the start index of the group.", "expected_testcases": [{"testcase_name": "GetStartWithPositiveIndex", "description": "Test with a group having a positive start index, expecting the same index to be returned."}, {"testcase_name": "GetStartWithZeroIndex", "description": "Test with a group having a start index of zero, expecting zero to be returned."}]}, {"method_name": "getEnd", "description": "Returns the end index of the group.", "expected_testcases": [{"testcase_name": "GetEndWithPositiveIndex", "description": "Test with a group having a positive end index, expecting the same index to be returned."}, {"testcase_name": "GetEndWithZeroIndex", "description": "Test with a group having an end index of zero, expecting zero to be returned."}]}, {"method_name": "getChildren", "description": "Returns the list of child groups.", "expected_testcases": [{"testcase_name": "GetChildrenWithNonEmptyList", "description": "Test with a group having a non-empty list of children, expecting the same list to be returned."}, {"testcase_name": "GetChildrenWithEmptyList", "description": "Test with a group having an empty list of children, expecting an empty list to be returned."}]}, {"method_name": "getValues", "description": "Returns a list of values from the group and its children.", "expected_testcases": [{"testcase_name": "GetValuesWithChildren", "description": "Test with a group having children, expecting a list of values from the group and its children."}, {"testcase_name": "GetValuesWithoutChildren", "description": "Test with a group having no children, expecting a list containing only the group's value."}]}, {"method_name": "parse", "description": "Parses a pattern into a collection of groups.", "expected_testcases": [{"testcase_name": "ParseWithValidPattern", "description": "Test with a valid pattern, expecting a non-empty collection of groups."}, {"testcase_name": "ParseWithEmptyPattern", "description": "Test with an empty pattern, expecting an empty collection of groups."}]}, {"method_name": "toGroups", "description": "Converts a list of GroupBuilder objects into a list of Group objects.", "expected_testcases": [{"testcase_name": "ToGroupsWithNonNullChildren", "description": "Test with a non-null list of GroupBuilder children, expecting a list of Group objects."}, {"testcase_name": "ToGroupsWithNullChildren", "description": "Test with a null list of GroupBuilder children, expecting an empty list of Group objects."}]}], "overrides": null, "class_name": "Group", "description": "Class representing a group of elements with a value, start and end indices, and a list of child groups."}, {"class_uri": "src/main/java/io/cucumber/cucumberexpressions/TreeRegexp.java.TreeRegexp", "class_docstring": "\nTreeRegexp represents matches as a tree of {@link Group}\nreflecting the nested structure of capture groups in the original\nregexp.\n", "superclasses": "", "super_interfaces": [], "methods": [{"method_name": "TreeRegexp(String regexp)", "description": "Constructor that initializes the TreeRegexp object with a given regular expression string, compiling it into a Pattern object.", "expected_testcases": [{"testcase_name": "ValidRegex", "description": "Initialize with a valid regex string, expecting the pattern to be compiled successfully."}, {"testcase_name": "InvalidRegex", "description": "Initialize with an invalid regex string, expecting an exception to be thrown."}]}, {"method_name": "TreeRegexp(Pattern pattern)", "description": "Constructor that initializes the TreeRegexp object with a pre-compiled Pattern object.", "expected_testcases": [{"testcase_name": "ValidPattern", "description": "Initialize with a valid Pattern object, expecting the groupBuilder to be created successfully."}]}, {"method_name": "createGroupBuilder(Pattern pattern)", "description": "Static method that creates a GroupBuilder object by parsing the pattern's source string and building a tree structure based on the groups defined in the regex.", "expected_testcases": [{"testcase_name": "SimplePattern", "description": "Create a GroupBuilder for a simple regex pattern with no groups, expecting a single root group."}, {"testcase_name": "NestedGroups", "description": "Create a GroupBuilder for a regex pattern with nested capturing groups, expecting the correct nested structure in the GroupBuilder."}, {"testcase_name": "NonCapturingGroups", "description": "Create a GroupBuilder for a regex pattern with non-capturing groups, expecting the non-capturing groups to be correctly identified and handled."}, {"testcase_name": "CharacterClass", "description": "Create a GroupBuilder for a regex pattern with character classes, expecting the character classes to be correctly parsed without affecting group structure."}]}, {"method_name": "isNonCapturingGroup(String source, int i)", "description": "Private static method that determines if a group in the regex pattern is non-capturing based on the syntax.", "expected_testcases": [{"testcase_name": "NonCapturingGroup", "description": "Check a group that is non-capturing, expecting the method to return true."}, {"testcase_name": "CapturingGroup", "description": "Check a group that is capturing, expecting the method to return false."}, {"testcase_name": "NamedGroup", "description": "Check a named capturing group, expecting the method to return false."}]}, {"method_name": "pattern()", "description": "Method that returns the Pattern object associated with the TreeRegexp instance.", "expected_testcases": [{"testcase_name": "PatternRetrieval", "description": "Retrieve the Pattern object, expecting it to match the pattern used during initialization."}]}, {"method_name": "match(CharSequence s)", "description": "Method that attempts to match the input string against the compiled pattern and returns a Group object representing the match result.", "expected_testcases": [{"testcase_name": "SuccessfulMatch", "description": "Match a string that fully matches the pattern, expecting a non-null Group object."}, {"testcase_name": "PartialMatch", "description": "Match a string that partially matches the pattern, expecting a null Group object."}, {"testcase_name": "NoMatch", "description": "Match a string that does not match the pattern at all, expecting a null Group object."}]}, {"method_name": "getGroupBuilder()", "description": "Method that returns the GroupBuilder object associated with the TreeRegexp instance.", "expected_testcases": [{"testcase_name": "GroupBuilderRetrieval", "description": "Retrieve the GroupBuilder object, expecting it to match the structure built during initialization."}]}], "overrides": null, "class_name": "TreeRegexp", "description": "Class responsible for parsing and matching regular expressions, building a tree structure based on the groups defined in the regex pattern."}, {"class_uri": "src/main/java/io/cucumber/cucumberexpressions/DuplicateTypeNameException.java.DuplicateTypeNameException", "class_docstring": "", "superclasses": "CucumberExpressionException", "super_interfaces": [], "methods": [{"method_name": "DuplicateTypeNameException", "description": "Constructor that initializes the exception with a specific message.", "expected_testcases": [{"testcase_name": "InstantiateWithMessage", "description": "Create an instance of DuplicateTypeNameException with a specific message, expecting the message to be correctly set."}]}, {"method_name": "createMissingEndToken", "description": "Creates a CucumberExpressionException indicating that a begin token does not have a matching end token.", "expected_testcases": [{"testcase_name": "MissingEndToken", "description": "Create an exception for a missing end token, expecting the exception message to correctly describe the issue and provide a solution."}]}, {"method_name": "createAlternationNotAllowedInOptional", "description": "Creates a CucumberExpressionException indicating that an alternation is not allowed inside an optional.", "expected_testcases": [{"testcase_name": "AlternationInOptional", "description": "Create an exception for an alternation inside an optional, expecting the exception message to correctly describe the issue and provide a solution."}]}, {"method_name": "createTheEndOfLineCanNotBeEscaped", "description": "Creates a CucumberExpressionException indicating that the end of line cannot be escaped.", "expected_testcases": [{"testcase_name": "EndOfLineEscaped", "description": "Create an exception for attempting to escape the end of line, expecting the exception message to correctly describe the issue and provide a solution."}]}, {"method_name": "createAlternativeMayNotBeEmpty", "description": "Creates a CucumberExpressionException indicating that an alternative may not be empty.", "expected_testcases": [{"testcase_name": "EmptyAlternative", "description": "Create an exception for an empty alternative, expecting the exception message to correctly describe the issue and provide a solution."}]}, {"method_name": "createParameterIsNotAllowedInOptional", "description": "Creates a CucumberExpressionException indicating that a parameter is not allowed inside an optional.", "expected_testcases": [{"testcase_name": "ParameterInOptional", "description": "Create an exception for a parameter inside an optional, expecting the exception message to correctly describe the issue and provide a solution."}]}, {"method_name": "createOptionalIsNotAllowedInOptional", "description": "Creates a CucumberExpressionException indicating that an optional is not allowed inside another optional.", "expected_testcases": [{"testcase_name": "OptionalInOptional", "description": "Create an exception for an optional inside another optional, expecting the exception message to correctly describe the issue and provide a solution."}]}, {"method_name": "createOptionalMayNotBeEmpty", "description": "Creates a CucumberExpressionException indicating that an optional must contain some text.", "expected_testcases": [{"testcase_name": "EmptyOptional", "description": "Create an exception for an empty optional, expecting the exception message to correctly describe the issue and provide a solution."}]}, {"method_name": "createAlternativeMayNotExclusivelyContainOptionals", "description": "Creates a CucumberExpressionException indicating that an alternative may not exclusively contain optionals.", "expected_testcases": [{"testcase_name": "AlternativeWithOnlyOptionals", "description": "Create an exception for an alternative that only contains optionals, expecting the exception message to correctly describe the issue and provide a solution."}]}, {"method_name": "createCantEscape", "description": "Creates a CucumberExpressionException indicating that only specific characters can be escaped.", "expected_testcases": [{"testcase_name": "InvalidEscapeCharacter", "description": "Create an exception for attempting to escape an invalid character, expecting the exception message to correctly describe the issue and provide a solution."}]}, {"method_name": "createInvalidParameterTypeName", "description": "Creates a CucumberExpressionException indicating that a parameter name contains invalid characters.", "expected_testcases": [{"testcase_name": "InvalidParameterName", "description": "Create an exception for an invalid parameter name, expecting the exception message to correctly describe the issue and provide a solution."}]}], "overrides": null, "class_name": "DuplicateTypeNameException", "description": "This class extends CucumberExpressionException and provides constructors and static methods to create specific types of CucumberExpressionException instances, each tailored to handle different error scenarios in Cucumber expressions."}, {"class_uri": "src/main/java/io/cucumber/cucumberexpressions/Argument.java.Argument", "class_docstring": "", "superclasses": "", "super_interfaces": [], "methods": [{"method_name": "build", "description": "A static method that constructs a list of Argument objects from a given group and list of parameter types. It ensures that the number of groups matches the number of parameter types, otherwise it throws an IllegalArgumentException.", "expected_testcases": [{"testcase_name": "MatchingGroupsAndParameterTypes", "description": "Test with a group having the same number of children as the number of parameter types. Expect a list of Argument objects to be returned."}, {"testcase_name": "MismatchedGroupsAndParameterTypes", "description": "Test with a group having a different number of children than the number of parameter types. Expect an IllegalArgumentException to be thrown."}, {"testcase_name": "EmptyGroupsAndParameterTypes", "description": "Test with both the group and parameter types list being empty. Expect an empty list of Argument objects to be returned."}]}, {"method_name": "getGroup", "description": "Returns the group associated with the argument.", "expected_testcases": [{"testcase_name": "GetGroup", "description": "Test retrieving the group from an Argument object. Expect the group used during construction to be returned."}]}, {"method_name": "getValue", "description": "Returns the value of the argument by transforming the group's values using the parameter type's transform method.", "expected_testcases": [{"testcase_name": "GetValue", "description": "Test retrieving the value from an Argument object. Expect the transformed value of the group's values to be returned."}, {"testcase_name": "EmptyGroupValues", "description": "Test retrieving the value when the group's values are empty. Expect an appropriate transformed value based on the parameter type's behavior with empty input."}]}, {"method_name": "getType", "description": "Returns the type of the parameter type associated with the argument.", "expected_testcases": [{"testcase_name": "GetType", "description": "Test retrieving the type from an Argument object. Expect the type of the parameter type used during construction to be returned."}]}, {"method_name": "getParameterType", "description": "Returns the parameter type associated with the argument.", "expected_testcases": [{"testcase_name": "GetParameterType", "description": "Test retrieving the parameter type from an Argument object. Expect the parameter type used during construction to be returned."}]}], "overrides": null, "class_name": "Argument", "description": "A class that represents an argument with a specific parameter type and group. It provides methods to retrieve the group, value, type, and parameter type of the argument."}, {"class_uri": "src/main/java/io/cucumber/cucumberexpressions/CombinatorialGeneratedExpressionFactory.java.CombinatorialGeneratedExpressionFactory", "class_docstring": "", "superclasses": "", "super_interfaces": [], "methods": [{"method_name": "CombinatorialGeneratedExpressionFactory", "description": "Constructor that initializes the factory with an expression template and a list of parameter type combinations.", "expected_testcases": []}, {"method_name": "generateExpressions", "description": "Generates a list of GeneratedExpression objects by permuting the parameter type combinations according to the template, up to a maximum of 256 expressions.", "expected_testcases": [{"testcase_name": "GenerateSingleExpression", "description": "Test with a single parameter type combination, expecting a single GeneratedExpression object in the list."}, {"testcase_name": "GenerateMaximumExpressions", "description": "Test with parameter type combinations that should generate exactly 256 expressions, expecting a list of 256 GeneratedExpression objects."}, {"testcase_name": "GenerateExceedingMaximumExpressions", "description": "Test with parameter type combinations that would generate more than 256 expressions, expecting a list of exactly 256 GeneratedExpression objects."}, {"testcase_name": "GenerateNoExpressions", "description": "Test with an empty list of parameter type combinations, expecting an empty list of GeneratedExpression objects."}]}, {"method_name": "generatePermutations", "description": "Helper method that recursively generates permutations of parameter types and adds them to the list of generated expressions, stopping if the maximum number of expressions is reached.", "expected_testcases": [{"testcase_name": "GeneratePermutationsSingleLevel", "description": "Test with a single level of parameter types, expecting permutations to be generated correctly."}, {"testcase_name": "GeneratePermutationsMultipleLevels", "description": "Test with multiple levels of parameter types, expecting permutations to be generated correctly across all levels."}, {"testcase_name": "GeneratePermutationsExceedingMax", "description": "Test with parameter types that would exceed the maximum number of expressions, expecting the method to stop generating permutations after reaching the limit."}]}], "overrides": null, "class_name": "CombinatorialGeneratedExpressionFactory", "description": "Class responsible for generating combinatorial expressions based on a template and a list of parameter type combinations."}, {"class_uri": "src/main/java/io/cucumber/cucumberexpressions/CucumberExpressionGenerator.java.CucumberExpressionGenerator", "class_docstring": "", "superclasses": "", "super_interfaces": [], "methods": [{"method_name": "CucumberExpressionGenerator", "description": "Constructor that initializes the CucumberExpressionGenerator with a ParameterTypeRegistry.", "expected_testcases": []}, {"method_name": "generateExpressions", "description": "Generates a list of GeneratedExpression objects based on the provided text and the ParameterTypeRegistry.", "expected_testcases": [{"testcase_name": "SingleParameterTypeMatch", "description": "Test with a text that matches a single parameter type, expecting a list with one GeneratedExpression containing the matched parameter type."}, {"testcase_name": "MultipleParameterTypeMatches", "description": "Test with a text that matches multiple parameter types, expecting a list with multiple GeneratedExpression objects, each containing a different matched parameter type."}, {"testcase_name": "NoParameterTypeMatch", "description": "Test with a text that does not match any parameter type, expecting an empty list."}, {"testcase_name": "EmptyText", "description": "Test with an empty text, expecting an empty list."}, {"testcase_name": "TextWithSpecialCharacters", "description": "Test with a text containing special characters that need to be escaped, expecting the special characters to be correctly escaped in the GeneratedExpression."}]}, {"method_name": "escape", "description": "Escapes special characters in the provided string to ensure they are correctly formatted for use in Cucumber expressions.", "expected_testcases": [{"testcase_name": "EscapePercentSign", "description": "Test with a string containing a percent sign, expecting the percent sign to be escaped."}, {"testcase_name": "EscapeParentheses", "description": "Test with a string containing parentheses, expecting the parentheses to be escaped."}, {"testcase_name": "EscapeBraces", "description": "Test with a string containing braces, expecting the braces to be escaped."}, {"testcase_name": "EscapeSlash", "description": "Test with a string containing a slash, expecting the slash to be escaped."}, {"testcase_name": "NoSpecialCharacters", "description": "Test with a string containing no special characters, expecting the string to remain unchanged."}]}, {"method_name": "createParameterTypeMatchers", "description": "Creates a list of ParameterTypeMatcher objects based on the provided text and the ParameterTypeRegistry.", "expected_testcases": [{"testcase_name": "SingleParameterType", "description": "Test with a text that matches a single parameter type, expecting a list with one ParameterTypeMatcher."}, {"testcase_name": "MultipleParameterTypes", "description": "Test with a text that matches multiple parameter types, expecting a list with multiple ParameterTypeMatcher objects."}, {"testcase_name": "NoParameterTypeMatch", "description": "Test with a text that does not match any parameter type, expecting an empty list."}]}, {"method_name": "createParameterTypeMatchers", "description": "Creates a list of ParameterTypeMatcher objects for a specific ParameterType and the provided text.", "expected_testcases": [{"testcase_name": "SingleRegexpMatch", "description": "Test with a text that matches a single regexp of a ParameterType, expecting a list with one ParameterTypeMatcher."}, {"testcase_name": "MultipleRegexpMatches", "description": "Test with a text that matches multiple regexps of a ParameterType, expecting a list with multiple ParameterTypeMatcher objects."}, {"testcase_name": "NoRegexpMatch", "description": "Test with a text that does not match any regexp of a ParameterType, expecting an empty list."}]}], "overrides": null, "class_name": "CucumberExpressionGenerator", "description": "Class responsible for generating Cucumber expressions based on provided text and a ParameterTypeRegistry."}, {"class_uri": "src/main/java/io/cucumber/cucumberexpressions/AmbiguousParameterTypeException.java.AmbiguousParameterTypeException", "class_docstring": "", "superclasses": "CucumberExpressionException", "super_interfaces": [], "methods": [{"method_name": "AmbiguousParameterTypeException", "description": "Constructor that initializes the exception with detailed error messages and stores the involved regular expressions, parameter types, and generated expressions.", "expected_testcases": [{"testcase_name": "AmbiguousParameterTypeException_ValidInput", "description": "Test the constructor with valid input parameters, expecting the exception to be created with the correct error message and stored values."}, {"testcase_name": "AmbiguousParameterTypeException_NullParameterTypeRegexp", "description": "Test the constructor with a null parameter type regexp, expecting a NullPointerException or similar exception to be thrown."}, {"testcase_name": "AmbiguousParameterTypeException_EmptyParameterTypes", "description": "Test the constructor with an empty set of parameter types, expecting the exception to be created with an appropriate error message indicating no parameter types."}]}, {"method_name": "parameterTypeNames", "description": "Static method that converts a set of ParameterType objects into a string of their names, formatted for error messages.", "expected_testcases": [{"testcase_name": "parameterTypeNames_SingleParameterType", "description": "Test with a single ParameterType, expecting the method to return a string containing the name of that parameter type."}, {"testcase_name": "parameterTypeNames_MultipleParameterTypes", "description": "Test with multiple ParameterType objects, expecting the method to return a string containing the names of all parameter types, joined appropriately."}, {"testcase_name": "parameterTypeNames_EmptySet", "description": "Test with an empty set of ParameterType objects, expecting the method to return an empty string."}]}, {"method_name": "expressions", "description": "Static method that converts a list of GeneratedExpression objects into a string of their sources, formatted for error messages.", "expected_testcases": [{"testcase_name": "expressions_SingleGeneratedExpression", "description": "Test with a single GeneratedExpression, expecting the method to return a string containing the source of that expression."}, {"testcase_name": "expressions_MultipleGeneratedExpressions", "description": "Test with multiple GeneratedExpression objects, expecting the method to return a string containing the sources of all expressions, joined appropriately."}, {"testcase_name": "expressions_EmptyList", "description": "Test with an empty list of GeneratedExpression objects, expecting the method to return an empty string."}]}, {"method_name": "join", "description": "Static method that joins a list of strings into a single string with each element separated by a newline and indentation.", "expected_testcases": [{"testcase_name": "join_SingleString", "description": "Test with a single string, expecting the method to return that string without any additional formatting."}, {"testcase_name": "join_MultipleStrings", "description": "Test with multiple strings, expecting the method to return a single string with each element separated by a newline and indented appropriately."}, {"testcase_name": "join_EmptyList", "description": "Test with an empty list of strings, expecting the method to return an empty string."}]}, {"method_name": "getRegexp", "description": "Getter method for retrieving the regular expression associated with the exception.", "expected_testcases": [{"testcase_name": "getRegexp_ValidPattern", "description": "Test with a valid pattern stored in the exception, expecting the method to return the correct Pattern object."}]}, {"method_name": "getParameterTypeRegexp", "description": "Getter method for retrieving the parameter type regular expression associated with the exception.", "expected_testcases": [{"testcase_name": "getParameterTypeRegexp_ValidString", "description": "Test with a valid string stored in the exception, expecting the method to return the correct string."}]}, {"method_name": "getParameterTypes", "description": "Getter method for retrieving the set of parameter types associated with the exception.", "expected_testcases": [{"testcase_name": "getParameterTypes_ValidSet", "description": "Test with a valid set of ParameterType objects stored in the exception, expecting the method to return the correct set."}]}, {"method_name": "getGeneratedExpressions", "description": "Getter method for retrieving the list of generated expressions associated with the exception.", "expected_testcases": [{"testcase_name": "getGeneratedExpressions_ValidList", "description": "Test with a valid list of GeneratedExpression objects stored in the exception, expecting the method to return the correct list."}]}], "overrides": null, "class_name": "AmbiguousParameterTypeException", "description": "This class extends CucumberExpressionException and is used to handle exceptions related to ambiguous parameter types in Cucumber expressions. It provides detailed error messages and methods to retrieve the involved regular expressions and parameter types."}, {"class_uri": "src/main/java/io/cucumber/cucumberexpressions/CucumberExpressionTokenizer.java.CucumberExpressionTokenizer", "class_docstring": "", "superclasses": "", "super_interfaces": [], "methods": [{"method_name": "tokenize", "description": "Tokenizes the given Cucumber expression string into a list of tokens.", "expected_testcases": [{"testcase_name": "EmptyExpression", "description": "Tokenize an empty string, expecting an empty list of tokens."}, {"testcase_name": "SingleTextToken", "description": "Tokenize a string with a single text token, expecting a list containing one text token."}, {"testcase_name": "MultipleTextTokens", "description": "Tokenize a string with multiple text tokens separated by whitespace, expecting a list containing multiple text tokens."}, {"testcase_name": "EscapedCharacter", "description": "Tokenize a string with an escaped character, expecting the escaped character to be treated as text."}, {"testcase_name": "MixedTokens", "description": "Tokenize a string with a mix of text and special tokens, expecting a list containing the appropriate tokens."}]}, {"method_name": "tokenizeImpl", "description": "Provides an iterable of tokens for the given Cucumber expression string. This method is not directly tested as it is an internal implementation detail and is covered by the tests of the 'tokenize' method.", "expected_testcases": []}, {"method_name": "TokenIterator", "description": "An internal class that implements the Iterator interface for tokens. This class is not directly tested as it is an internal implementation detail and is covered by the tests of the 'tokenize' method.", "expected_testcases": []}], "overrides": null, "class_name": "CucumberExpressionTokenizer", "description": "Class responsible for tokenizing a Cucumber expression into a list of tokens."}, {"class_uri": "src/main/java/io/cucumber/cucumberexpressions/RegularExpression.java.RegularExpression", "class_docstring": "", "superclasses": "", "super_interfaces": ["Expression"], "methods": [{"method_name": "RegularExpression", "description": "Constructor that initializes the regular expression, parameter type registry, and creates a TreeRegexp instance.", "expected_testcases": [{"testcase_name": "ValidInitialization", "description": "Initialize with a valid Pattern and ParameterTypeRegistry, expecting no exceptions and proper initialization of all fields."}, {"testcase_name": "NullPattern", "description": "Initialize with a null Pattern, expecting a NullPointerException or similar exception."}, {"testcase_name": "NullParameterTypeRegistry", "description": "Initialize with a null ParameterTypeRegistry, expecting a NullPointerException or similar exception."}]}, {"method_name": "match", "description": "Matches the input text against the regular expression and returns a list of arguments based on the captured groups and type hints.", "expected_testcases": [{"testcase_name": "MatchWithValidText", "description": "Provide a valid text that matches the regular expression, expecting a list of arguments with the correct types."}, {"testcase_name": "MatchWithInvalidText", "description": "Provide a text that does not match the regular expression, expecting a null return value."}, {"testcase_name": "MatchWithEmptyText", "description": "Provide an empty text, expecting a null return value if the regular expression does not match empty strings."}, {"testcase_name": "MatchWithTypeHints", "description": "Provide a text that matches the regular expression and type hints, expecting the arguments to be of the hinted types."}, {"testcase_name": "MatchWithoutTypeHints", "description": "Provide a text that matches the regular expression without type hints, expecting the arguments to be of default types (e.g., String)."}, {"testcase_name": "MatchWithConflictingTypeHints", "description": "Provide a text that matches the regular expression and conflicting type hints, expecting the parameter type associated with the regular expression to be used."}, {"testcase_name": "MatchWithStrongTypeHint", "description": "Provide a text that matches the regular expression and a strong type hint, expecting the strong type hint to be used."}]}, {"method_name": "getRegexp", "description": "Returns the regular expression pattern used by this instance.", "expected_testcases": [{"testcase_name": "GetRegexpAfterInitialization", "description": "Call getRegexp after initialization, expecting the same Pattern object that was passed to the constructor."}]}, {"method_name": "getSource", "description": "Returns the source string of the regular expression pattern.", "expected_testcases": [{"testcase_name": "GetSourceAfterInitialization", "description": "Call getSource after initialization, expecting the same string pattern that was passed to the constructor."}]}], "overrides": null, "class_name": "RegularExpression", "description": "Class responsible for handling regular expressions and matching them against input text, using a parameter type registry to determine the types of captured groups."}, {"class_uri": "src/main/java/io/cucumber/cucumberexpressions/KeyboardFriendlyDecimalFormatSymbols.java.KeyboardFriendlyDecimalFormatSymbols", "class_docstring": "\nA set of localized decimal symbols that can be written on a regular keyboard.\n<p>\nNote quite complete, feel free to make a suggestion.\n", "superclasses": "", "super_interfaces": [], "methods": [{"method_name": "getInstance", "description": "Returns a customized instance of DecimalFormatSymbols for the specified locale, adjusting the minus sign and grouping separator to be more keyboard-friendly.", "expected_testcases": [{"testcase_name": "LocaleWithMinusSignAndPeriodDecimalSeparator", "description": "Test with a locale that uses the minus sign (U+2212) and period as the decimal separator. Expect the minus sign to be replaced with a hyphen and the grouping separator to be set to a comma."}, {"testcase_name": "LocaleWithMinusSignAndCommaDecimalSeparator", "description": "Test with a locale that uses the minus sign (U+2212) and comma as the decimal separator. Expect the minus sign to be replaced with a hyphen and the grouping separator to be set to a period."}, {"testcase_name": "LocaleWithHyphenAndPeriodDecimalSeparator", "description": "Test with a locale that uses a hyphen as the minus sign and period as the decimal separator. Expect no change to the minus sign and the grouping separator to be set to a comma."}, {"testcase_name": "LocaleWithHyphenAndCommaDecimalSeparator", "description": "Test with a locale that uses a hyphen as the minus sign and comma as the decimal separator. Expect no change to the minus sign and the grouping separator to be set to a period."}, {"testcase_name": "LocaleWithNonStandardMinusSign", "description": "Test with a locale that uses a non-standard character as the minus sign and period as the decimal separator. Expect no change to the minus sign and the grouping separator to be set to a comma."}, {"testcase_name": "LocaleWithNonStandardDecimalSeparator", "description": "Test with a locale that uses a non-standard character as the decimal separator and a hyphen as the minus sign. Expect no change to the minus sign and the grouping separator to remain unchanged."}]}], "overrides": null, "class_name": "KeyboardFriendlyDecimalFormatSymbols", "description": "Class that provides a customized instance of DecimalFormatSymbols, making it more friendly for keyboard input by adjusting the minus sign and grouping separator based on the locale."}, {"class_uri": "src/main/java/io/cucumber/cucumberexpressions/CucumberExpressionException.java.CucumberExpressionException", "class_docstring": "", "superclasses": "RuntimeException", "super_interfaces": [], "methods": [{"method_name": "CucumberExpressionException", "description": "Constructor that initializes the exception with a message.", "expected_testcases": [{"testcase_name": "InitializeWithMessage", "description": "Create an instance of CucumberExpressionException with a specific message, expecting the message to be set correctly."}]}, {"method_name": "CucumberExpressionException", "description": "Constructor that initializes the exception with a message and a cause.", "expected_testcases": [{"testcase_name": "InitializeWithMessageAndCause", "description": "Create an instance of CucumberExpressionException with a specific message and a cause, expecting both the message and cause to be set correctly."}]}, {"method_name": "createMissingEndToken", "description": "Creates an exception for the case where a begin token does not have a matching end token.", "expected_testcases": [{"testcase_name": "MissingEndToken", "description": "Create an exception for a missing end token, providing an expression, begin token, end token, and current token, expecting the correct error message to be generated."}]}, {"method_name": "createAlternationNotAllowedInOptional", "description": "Creates an exception for the case where an alternation is used inside an optional.", "expected_testcases": [{"testcase_name": "AlternationInOptional", "description": "Create an exception for an alternation used inside an optional, providing an expression and current token, expecting the correct error message to be generated."}]}, {"method_name": "createTheEndOfLineCanNotBeEscaped", "description": "Creates an exception for the case where the end of the line is attempted to be escaped.", "expected_testcases": [{"testcase_name": "EndOfLineEscaped", "description": "Create an exception for attempting to escape the end of the line, providing an expression, expecting the correct error message to be generated."}]}, {"method_name": "createAlternativeMayNotBeEmpty", "description": "Creates an exception for the case where an alternative is empty.", "expected_testcases": [{"testcase_name": "EmptyAlternative", "description": "Create an exception for an empty alternative, providing a node and an expression, expecting the correct error message to be generated."}]}, {"method_name": "createParameterIsNotAllowedInOptional", "description": "Creates an exception for the case where a parameter is used inside an optional.", "expected_testcases": [{"testcase_name": "ParameterInOptional", "description": "Create an exception for a parameter used inside an optional, providing a node and an expression, expecting the correct error message to be generated."}]}, {"method_name": "createOptionalIsNotAllowedInOptional", "description": "Creates an exception for the case where an optional is nested inside another optional.", "expected_testcases": [{"testcase_name": "NestedOptional", "description": "Create an exception for an optional nested inside another optional, providing a node and an expression, expecting the correct error message to be generated."}]}, {"method_name": "createOptionalMayNotBeEmpty", "description": "Creates an exception for the case where an optional is empty.", "expected_testcases": [{"testcase_name": "EmptyOptional", "description": "Create an exception for an empty optional, providing a node and an expression, expecting the correct error message to be generated."}]}, {"method_name": "createAlternativeMayNotExclusivelyContainOptionals", "description": "Creates an exception for the case where an alternative exclusively contains optionals.", "expected_testcases": [{"testcase_name": "AlternativeWithOnlyOptionals", "description": "Create an exception for an alternative that exclusively contains optionals, providing a node and an expression, expecting the correct error message to be generated."}]}, {"method_name": "createCantEscape", "description": "Creates an exception for the case where an invalid character is attempted to be escaped.", "expected_testcases": [{"testcase_name": "InvalidEscapeCharacter", "description": "Create an exception for attempting to escape an invalid character, providing an expression and an index, expecting the correct error message to be generated."}]}, {"method_name": "createInvalidParameterTypeName", "description": "Creates an exception for the case where a parameter name contains invalid characters.", "expected_testcases": [{"testcase_name": "InvalidParameterName", "description": "Create an exception for an invalid parameter name, providing a name, expecting the correct error message to be generated."}]}, {"method_name": "createInvalidParameterTypeName", "description": "Creates an exception for the case where a parameter name contains invalid characters, with additional context from a token and expression.", "expected_testcases": [{"testcase_name": "InvalidParameterNameWithContext", "description": "Create an exception for an invalid parameter name with additional context, providing a token and an expression, expecting the correct error message to be generated."}]}, {"method_name": "message", "description": "Generates a detailed error message for a Cucumber expression issue.", "expected_testcases": [{"testcase_name": "GenerateErrorMessage", "description": "Generate an error message for a Cucumber expression issue, providing an index, expression, pointer, problem, and solution, expecting the correct formatted message to be returned."}]}, {"method_name": "pointAt", "description": "Generates a string that points to a specific location in the expression.", "expected_testcases": [{"testcase_name": "PointAtLocation", "description": "Generate a string that points to a specific location in the expression, providing a node, expecting the correct pointer string to be returned."}]}, {"method_name": "pointAt", "description": "Generates a string that points to a specific index in the expression.", "expected_testcases": [{"testcase_name": "PointAtIndex", "description": "Generate a string that points to a specific index in the expression, providing an index, expecting the correct pointer string to be returned."}]}], "overrides": null, "class_name": "CucumberExpressionException", "description": "Class responsible for handling exceptions related to Cucumber expressions, providing detailed error messages for various expression issues."}, {"class_uri": "src/main/java/io/cucumber/cucumberexpressions/Ast.java.Ast", "class_docstring": "", "superclasses": "", "super_interfaces": [], "methods": [{"method_name": "Node.start", "description": "Returns the start position of the node in the source.", "expected_testcases": [{"testcase_name": "StartPosition", "description": "Create a Node with a known start position and verify that the start() method returns this position."}]}, {"method_name": "Node.end", "description": "Returns the end position of the node in the source.", "expected_testcases": [{"testcase_name": "EndPosition", "description": "Create a Node with a known end position and verify that the end() method returns this position."}]}, {"method_name": "Node.nodes", "description": "Returns the list of child nodes of this node.", "expected_testcases": [{"testcase_name": "EmptyNodesList", "description": "Create a Node with no child nodes and verify that the nodes() method returns an empty list."}, {"testcase_name": "NonEmptyNodesList", "description": "Create a Node with several child nodes and verify that the nodes() method returns a list containing these nodes."}]}, {"method_name": "Node.type", "description": "Returns the type of the node.", "expected_testcases": [{"testcase_name": "NodeType", "description": "Create a Node with a specific type and verify that the type() method returns this type."}]}, {"method_name": "Node.text", "description": "Returns the text representation of the node, either from its token or by concatenating the text of its child nodes.", "expected_testcases": [{"testcase_name": "TextFromToken", "description": "Create a Node with a token and verify that the text() method returns the token's text."}, {"testcase_name": "TextFromChildNodes", "description": "Create a Node with child nodes and verify that the text() method returns the concatenated text of these child nodes."}]}, {"method_name": "Node.toString", "description": "Returns a string representation of the node, including its type, start and end positions, token, and child nodes.", "expected_testcases": [{"testcase_name": "ToStringWithToken", "description": "Create a Node with a token and verify that the toString() method returns a string representation including the token."}, {"testcase_name": "ToStringWithChildNodes", "description": "Create a Node with child nodes and verify that the toString() method returns a string representation including these child nodes."}]}, {"method_name": "Node.equals", "description": "Compares this node to another object for equality.", "expected_testcases": [{"testcase_name": "EqualNodes", "description": "Create two Nodes with identical properties and verify that the equals() method returns true."}, {"testcase_name": "UnequalNodes", "description": "Create two Nodes with different properties and verify that the equals() method returns false."}]}, {"method_name": "Node.hashCode", "description": "Returns a hash code value for the node.", "expected_testcases": [{"testcase_name": "HashCodeConsistency", "description": "Create a Node and verify that the hashCode() method returns consistent values across multiple invocations."}]}, {"method_name": "Token.start", "description": "Returns the start position of the token in the source.", "expected_testcases": [{"testcase_name": "TokenStartPosition", "description": "Create a Token with a known start position and verify that the start() method returns this position."}]}, {"method_name": "Token.end", "description": "Returns the end position of the token in the source.", "expected_testcases": [{"testcase_name": "TokenEndPosition", "description": "Create a Token with a known end position and verify that the end() method returns this position."}]}, {"method_name": "Token.equals", "description": "Compares this token to another object for equality.", "expected_testcases": [{"testcase_name": "EqualTokens", "description": "Create two Tokens with identical properties and verify that the equals() method returns true."}, {"testcase_name": "UnequalTokens", "description": "Create two Tokens with different properties and verify that the equals() method returns false."}]}, {"method_name": "Token.hashCode", "description": "Returns a hash code value for the token.", "expected_testcases": [{"testcase_name": "TokenHashCodeConsistency", "description": "Create a Token and verify that the hashCode() method returns consistent values across multiple invocations."}]}, {"method_name": "Token.toString", "description": "Returns a string representation of the token, including its type, start and end positions, and text.", "expected_testcases": [{"testcase_name": "TokenToString", "description": "Create a Token and verify that the toString() method returns a string representation including its type, start and end positions, and text."}]}, {"method_name": "Token.canEscape", "description": "Determines if a given token can be escaped.", "expected_testcases": [{"testcase_name": "CanEscapeWhitespace", "description": "Pass a whitespace character to canEscape() and verify that it returns true."}, {"testcase_name": "CanEscapeSpecialCharacters", "description": "Pass a special character (e.g., escapeCharacter, alternationCharacter) to canEscape() and verify that it returns true."}, {"testcase_name": "CannotEscapeRegularCharacter", "description": "Pass a regular character to canEscape() and verify that it returns false."}]}, {"method_name": "Token.typeOf", "description": "Determines the type of a given token.", "expected_testcases": [{"testcase_name": "TypeOfWhitespace", "description": "Pass a whitespace character to typeOf() and verify that it returns Type.WHITE_SPACE."}, {"testcase_name": "TypeOfSpecialCharacter", "description": "Pass a special character (e.g., alternationCharacter) to typeOf() and verify that it returns the corresponding Type (e.g., Type.ALTERNATION)."}, {"testcase_name": "TypeOfRegularCharacter", "description": "Pass a regular character to typeOf() and verify that it returns Type.TEXT."}]}, {"method_name": "Token.isEscapeCharacter", "description": "Determines if a given token is the escape character.", "expected_testcases": [{"testcase_name": "IsEscapeCharacter", "description": "Pass the escape character to isEscapeCharacter() and verify that it returns true."}, {"testcase_name": "IsNotEscapeCharacter", "description": "Pass a non-escape character to isEscapeCharacter() and verify that it returns false."}]}], "overrides": null, "class_name": "Ast", "description": "Class responsible for representing an Abstract Syntax Tree (AST) with nodes and tokens, each having specific types and positions."}, {"class_uri": "src/main/java/io/cucumber/cucumberexpressions/CucumberExpressionParser.java.CucumberExpressionParser", "class_docstring": "", "superclasses": "", "super_interfaces": [], "methods": [{"method_name": "parse", "description": "Parses a given Cucumber expression string into a structured representation (Node). It tokenizes the expression and then applies the appropriate parsers to construct the AST (Abstract Syntax Tree).", "expected_testcases": [{"testcase_name": "ValidCucumberExpression", "description": "Parse a valid Cucumber expression with a mix of text, parameters, and optionals, expecting a successful parsing with a correctly structured Node returned."}, {"testcase_name": "EmptyExpression", "description": "Parse an empty Cucumber expression, expecting a successful parsing with an empty Node returned."}, {"testcase_name": "InvalidExpression", "description": "Parse an invalid Cucumber expression that contains syntax errors, expecting an exception to be thrown."}, {"testcase_name": "ExpressionWithAlternation", "description": "Parse a Cucumber expression that includes alternation, expecting a successful parsing with the alternation correctly represented in the Node structure."}]}, {"method_name": "parseBetween", "description": "Helper method that parses tokens between specified begin and end tokens, using a list of sub-parsers to handle the content within the boundaries.", "expected_testcases": [{"testcase_name": "ValidContentBetweenTokens", "description": "Parse valid content between specified begin and end tokens, expecting a successful parsing with the content correctly structured in the Node."}, {"testcase_name": "MissingEndToken", "description": "Attempt to parse content where the end token is missing, expecting an exception to be thrown."}, {"testcase_name": "EmptyContentBetweenTokens", "description": "Parse empty content between specified begin and end tokens, expecting a successful parsing with an empty Node returned."}]}, {"method_name": "parseTokensUntil", "description": "Helper method that parses tokens until any of the specified end tokens are encountered.", "expected_testcases": [{"testcase_name": "ValidTokensUntilEnd", "description": "Parse tokens until a specified end token is encountered, expecting a successful parsing with the tokens correctly structured in the Node."}, {"testcase_name": "NoEndTokenFound", "description": "Attempt to parse tokens where none of the specified end tokens are found, expecting an exception to be thrown."}, {"testcase_name": "EmptyTokensUntilEnd", "description": "Parse empty tokens until a specified end token is encountered, expecting a successful parsing with an empty Node returned."}]}, {"method_name": "parseToken", "description": "Helper method that attempts to parse a single token using a list of parsers.", "expected_testcases": [{"testcase_name": "ValidTokenParsing", "description": "Parse a valid token using the appropriate parser, expecting a successful parsing with the token correctly structured in the Node."}, {"testcase_name": "NoEligibleParsers", "description": "Attempt to parse a token with no eligible parsers, expecting an exception to be thrown."}]}, {"method_name": "lookingAtAny", "description": "Helper method that checks if the current token matches any of the specified token types.", "expected_testcases": [{"testcase_name": "TokenMatchesOneType", "description": "Check if a token matches one of the specified types, expecting a true result."}, {"testcase_name": "TokenMatchesNoneType", "description": "Check if a token matches none of the specified types, expecting a false result."}]}, {"method_name": "lookingAt", "description": "Helper method that checks if the current token matches the specified token type.", "expected_testcases": [{"testcase_name": "TokenMatchesType", "description": "Check if a token matches the specified type, expecting a true result."}, {"testcase_name": "TokenDoesNotMatchType", "description": "Check if a token does not match the specified type, expecting a false result."}]}, {"method_name": "splitAlternatives", "description": "Helper method that splits a list of nodes representing an alternation into separate alternatives based on the separator nodes.", "expected_testcases": [{"testcase_name": "ValidAlternativesSplit", "description": "Split a list of nodes representing an alternation with valid separators, expecting the alternatives to be correctly split and structured."}, {"testcase_name": "NoSeparators", "description": "Attempt to split a list of nodes with no separators, expecting the list to remain unchanged."}]}, {"method_name": "createAlternativeNodes", "description": "Helper method that creates alternative nodes from a list of alternatives and their corresponding separators.", "expected_testcases": [{"testcase_name": "ValidAlternativesCreation", "description": "Create alternative nodes from a list of valid alternatives and separators, expecting the alternatives to be correctly structured."}, {"testcase_name": "EmptyAlternatives", "description": "Attempt to create alternative nodes from an empty list of alternatives, expecting an empty list of nodes."}]}], "overrides": null, "class_name": "CucumberExpressionParser", "description": "Class responsible for parsing Cucumber expressions, which are used to define patterns for matching step definitions in Cucumber tests."}, {"class_uri": "src/main/java/io/cucumber/cucumberexpressions/BuiltInParameterTransformer.java.BuiltInParameterTransformer", "class_docstring": "", "superclasses": "", "super_interfaces": ["ParameterByTypeTransformer"], "methods": [{"method_name": "transform", "description": "Transforms a string value into an object of the specified type. Delegates the actual transformation to the doTransform method.", "expected_testcases": [{"testcase_name": "TransformToOptional", "description": "Test transforming a string into an Optional type, expecting the string to be wrapped in an Optional."}, {"testcase_name": "TransformToUnsupportedType", "description": "Test transforming a string into an unsupported type, expecting an IllegalArgumentException to be thrown."}, {"testcase_name": "TransformNullString", "description": "Test transforming a null string, expecting a null result."}]}, {"method_name": "doTransform", "description": "Performs the actual transformation of a string value into the specified type. Handles various types including primitives, wrappers, BigInteger, BigDecimal, enums, and more.", "expected_testcases": [{"testcase_name": "TransformToString", "description": "Test transforming a string into a String type, expecting the same string as the result."}, {"testcase_name": "TransformToCharacter", "description": "Test transforming a single character string into a Character type, expecting the character as the result."}, {"testcase_name": "TransformToBigInteger", "description": "Test transforming a numeric string into a BigInteger type, expecting a BigInteger object as the result."}, {"testcase_name": "TransformToBigDecimal", "description": "Test transforming a numeric string into a BigDecimal type, expecting a BigDecimal object as the result."}, {"testcase_name": "TransformToPrimitiveAndWrapperTypes", "description": "Test transforming a numeric string into various primitive and wrapper types (Byte, Short, Integer, Long, Float, Double), expecting the corresponding type as the result."}, {"testcase_name": "TransformToBoolean", "description": "Test transforming a string into a Boolean type, expecting a Boolean object as the result."}, {"testcase_name": "TransformToEnum", "description": "Test transforming a string into an Enum type, expecting the corresponding enum constant as the result."}, {"testcase_name": "TransformToInvalidEnum", "description": "Test transforming a string into an Enum type with an invalid value, expecting a CucumberExpressionException to be thrown."}, {"testcase_name": "TransformToUnsupportedType", "description": "Test transforming a string into an unsupported type, expecting an IllegalArgumentException to be thrown."}]}, {"method_name": "getOptionalGenericType", "description": "Determines the generic type of an Optional if the provided type is an Optional. Returns null otherwise.", "expected_testcases": [{"testcase_name": "GetOptionalGenericTypeForOptional", "description": "Test getting the generic type for an Optional type, expecting the generic type to be returned."}, {"testcase_name": "GetOptionalGenericTypeForNonOptional", "description": "Test getting the generic type for a non-Optional type, expecting null to be returned."}]}, {"method_name": "createIllegalArgumentException", "description": "Creates an IllegalArgumentException with a specific error message indicating that the transformation is not supported for the given type.", "expected_testcases": [{"testcase_name": "CreateIllegalArgumentException", "description": "Test creating an IllegalArgumentException, expecting an IllegalArgumentException with the correct error message to be created."}]}], "overrides": null, "class_name": "BuiltInParameterTransformer", "description": "A final class that implements the ParameterByTypeTransformer interface, responsible for transforming string values into various types based on the provided Type."}, {"class_uri": "src/main/java/io/cucumber/cucumberexpressions/NumberParser.java.NumberParser", "class_docstring": "", "superclasses": "", "super_interfaces": [], "methods": [{"method_name": "NumberParser", "description": "Constructor that initializes the NumberFormat instance based on the provided locale and configures it to parse numbers as BigDecimals.", "expected_testcases": []}, {"method_name": "parseDouble", "description": "Parses a string to a double using the configured NumberFormat.", "expected_testcases": [{"testcase_name": "ValidDoubleParsing", "description": "Parse a valid string representing a double, expecting the correct double value."}, {"testcase_name": "InvalidDoubleParsing", "description": "Attempt to parse an invalid string that cannot be converted to a double, expecting a CucumberExpressionException."}, {"testcase_name": "EmptyStringDoubleParsing", "description": "Attempt to parse an empty string, expecting a CucumberExpressionException."}]}, {"method_name": "parseFloat", "description": "Parses a string to a float using the configured NumberFormat.", "expected_testcases": [{"testcase_name": "ValidFloatParsing", "description": "Parse a valid string representing a float, expecting the correct float value."}, {"testcase_name": "InvalidFloatParsing", "description": "Attempt to parse an invalid string that cannot be converted to a float, expecting a CucumberExpressionException."}, {"testcase_name": "EmptyStringFloatParsing", "description": "Attempt to parse an empty string, expecting a CucumberExpressionException."}]}, {"method_name": "parseBigDecimal", "description": "Parses a string to a BigDecimal using the configured NumberFormat or falls back to default BigDecimal parsing if the locale does not support DecimalFormat.", "expected_testcases": [{"testcase_name": "ValidBigDecimalParsingWithDecimalFormat", "description": "Parse a valid string representing a BigDecimal when the locale supports DecimalFormat, expecting the correct BigDecimal value."}, {"testcase_name": "ValidBigDecimalParsingWithoutDecimalFormat", "description": "Parse a valid string representing a BigDecimal when the locale does not support DecimalFormat, expecting the correct BigDecimal value using default parsing."}, {"testcase_name": "InvalidBigDecimalParsing", "description": "Attempt to parse an invalid string that cannot be converted to a BigDecimal, expecting a CucumberExpressionException."}, {"testcase_name": "EmptyStringBigDecimalParsing", "description": "Attempt to parse an empty string, expecting a CucumberExpressionException."}]}, {"method_name": "parse", "description": "Private method that performs the actual parsing of the string to a Number using the configured NumberFormat, handling ParseException by throwing a CucumberExpressionException.", "expected_testcases": []}], "overrides": null, "class_name": "NumberParser", "description": "Class responsible for parsing numbers from strings using a specified locale-based number format."}, {"class_uri": "src/main/java/io/cucumber/cucumberexpressions/ParameterTypeRegistry.java.ParameterTypeRegistry", "class_docstring": "", "superclasses": "", "super_interfaces": [], "methods": [{"method_name": "ParameterTypeRegistry", "description": "Constructor that initializes the registry with built-in parameter types and sets up the default parameter transformer based on the provided locale.", "expected_testcases": [{"testcase_name": "InitializationWithDefaultLocale", "description": "Test the constructor with the default locale, expecting all built-in parameter types to be defined correctly."}, {"testcase_name": "InitializationWithCustomLocale", "description": "Test the constructor with a custom locale, expecting the float regex to be localized correctly."}]}, {"method_name": "defineParameterType", "description": "Defines a new parameter type in the registry, handling duplicate type names and regex conflicts.", "expected_testcases": [{"testcase_name": "DefineNewParameterType", "description": "Define a new parameter type, expecting it to be added to the registry without errors."}, {"testcase_name": "DuplicateTypeName", "description": "Attempt to define a parameter type with a name that already exists, expecting a DuplicateTypeNameException."}, {"testcase_name": "PreferentialParameterTypeConflict", "description": "Attempt to define two preferential parameter types with the same regex, expecting a CucumberExpressionException."}]}, {"method_name": "getDefaultParameterTransformer", "description": "Retrieves the default parameter transformer used by the registry.", "expected_testcases": [{"testcase_name": "GetDefaultParameterTransformer", "description": "Retrieve the default parameter transformer, expecting it to match the one set during initialization."}]}, {"method_name": "setDefaultParameterTransformer", "description": "Sets a new default parameter transformer for the registry.", "expected_testcases": [{"testcase_name": "SetNewDefaultParameterTransformer", "description": "Set a new default parameter transformer, expecting the registry to use the new transformer for subsequent operations."}]}, {"method_name": "lookupByTypeName", "description": "Looks up a parameter type by its name.", "expected_testcases": [{"testcase_name": "LookupExistingParameterType", "description": "Lookup an existing parameter type by name, expecting the correct parameter type to be returned."}, {"testcase_name": "LookupNonExistingParameterType", "description": "Lookup a non-existing parameter type by name, expecting null to be returned."}]}, {"method_name": "lookupByRegexp", "description": "Looks up a parameter type by its regex pattern, handling ambiguity if multiple types match the same pattern.", "expected_testcases": [{"testcase_name": "LookupByUniqueRegex", "description": "Lookup a parameter type by a unique regex pattern, expecting the correct parameter type to be returned."}, {"testcase_name": "LookupByAmbiguousRegex", "description": "Lookup a parameter type by a regex pattern that matches multiple types, expecting an AmbiguousParameterTypeException."}]}, {"method_name": "getParameterTypes", "description": "Retrieves all parameter types currently defined in the registry.", "expected_testcases": [{"testcase_name": "GetAllParameterTypes", "description": "Retrieve all parameter types, expecting a collection of all defined parameter types."}]}], "overrides": null, "class_name": "ParameterTypeRegistry", "description": "Class responsible for managing and defining parameter types used in Cucumber expressions, including their regex patterns and transformations."}, {"class_uri": "src/main/java/io/cucumber/cucumberexpressions/ExpressionFactory.java.ExpressionFactory", "class_docstring": "\nCreates a {@link CucumberExpression} or {@link RegularExpression} from a {@link String}\nusing heuristics. This is particularly useful for languages that don't have a\nliteral syntax for regular expressions. In Java, a regular expression has to be represented as a String.\n\n A string that starts with `^` and/or ends with `$` (or written in script style, i.e. starting with `/` \n and ending with `/`) is considered a regular expression.\n Everything else is considered a Cucumber expression.\n", "superclasses": "", "super_interfaces": [], "methods": [{"method_name": "createExpression", "description": "Creates an expression object based on the input string. It determines whether to create a RegularExpression or a CucumberExpression by checking the first and last characters of the input string.", "expected_testcases": [{"testcase_name": "EmptyString", "description": "Test with an empty string input. Expecting a CucumberExpression object to be created."}, {"testcase_name": "RegularExpressionWithAnchors", "description": "Test with an input string starting with '^' or ending with '$'. Expecting a RegularExpression object to be created."}, {"testcase_name": "RegularExpressionWithSlashes", "description": "Test with an input string enclosed in slashes (e.g., '/pattern/'). Expecting a RegularExpression object to be created."}, {"testcase_name": "CucumberExpression", "description": "Test with a regular input string that does not match the conditions for RegularExpression. Expecting a CucumberExpression object to be created."}, {"testcase_name": "InvalidRegularExpression", "description": "Test with an input string that is an invalid regular expression. Expecting a PatternSyntaxException to be thrown."}, {"testcase_name": "CucumberExpressionWithAnchors", "description": "Test with an input string containing anchors (^ or $) but not starting or ending with them. Expecting a CucumberExpressionException to be thrown."}]}, {"method_name": "createRegularExpressionWithAnchors", "description": "A private helper method that creates a RegularExpression object from a string that may contain anchors (^ or $). It handles PatternSyntaxException and checks for Cucumber Expression patterns.", "expected_testcases": []}], "overrides": null, "class_name": "ExpressionFactory", "description": "Class responsible for creating different types of expressions based on the input string. It can create RegularExpression or CucumberExpression objects depending on the content of the input string."}, {"class_uri": "src/main/java/io/cucumber/cucumberexpressions/DefaultPatternCompiler.java.DefaultPatternCompiler", "class_docstring": "\nDefault {@link PatternCompiler}\n", "superclasses": "", "super_interfaces": ["PatternCompiler"], "methods": [{"method_name": "compile", "description": "Compiles the given regular expression into a Pattern object with the specified flags.", "expected_testcases": [{"testcase_name": "ValidRegexWithNoFlags", "description": "Compile a valid regular expression with no flags, expecting a Pattern object to be returned."}, {"testcase_name": "ValidRegexWithFlags", "description": "Compile a valid regular expression with specific flags (e.g., Pattern.CASE_INSENSITIVE), expecting a Pattern object with the specified flags to be returned."}, {"testcase_name": "InvalidRegex", "description": "Attempt to compile an invalid regular expression, expecting a PatternSyntaxException to be thrown."}, {"testcase_name": "EmptyRegex", "description": "Compile an empty regular expression, expecting a Pattern object to be returned, which matches an empty string."}, {"testcase_name": "RegexWithBoundaryFlags", "description": "Compile a regular expression with boundary flags (e.g., Pattern.MULTILINE, Pattern.DOTALL), expecting a Pattern object with the specified boundary conditions to be returned."}]}], "overrides": null, "class_name": "DefaultPatternCompiler", "description": "A final class that implements the PatternCompiler interface, providing a method to compile regular expressions using Java's Pattern class."}, {"class_uri": "src/main/java/io/cucumber/cucumberexpressions/CucumberExpression.java.CucumberExpression", "class_docstring": "", "superclasses": "", "super_interfaces": ["Expression"], "methods": [{"method_name": "CucumberExpression", "description": "Constructor that initializes the CucumberExpression object by parsing the given expression and creating a corresponding TreeRegexp object.", "expected_testcases": [{"testcase_name": "ValidExpression", "description": "Create a CucumberExpression with a valid expression string, expecting the object to be initialized correctly with the provided expression and parameter type registry."}, {"testcase_name": "InvalidExpression", "description": "Attempt to create a CucumberExpression with an invalid expression string, expecting an exception to be thrown during parsing."}]}, {"method_name": "rewriteToRegex", "description": "Rewrites the given AST node into a regular expression pattern based on the node type.", "expected_testcases": [{"testcase_name": "TextNode", "description": "Pass a TEXT_NODE to rewriteToRegex, expecting the method to return the escaped text of the node."}, {"testcase_name": "OptionalNode", "description": "Pass an OPTIONAL_NODE to rewriteToRegex, expecting the method to return a regex pattern representing the optional parts."}, {"testcase_name": "AlternationNode", "description": "Pass an ALTERNATION_NODE to rewriteToRegex, expecting the method to return a regex pattern representing the alternation."}, {"testcase_name": "AlternativeNode", "description": "Pass an ALTERNATIVE_NODE to rewriteToRegex, expecting the method to return a regex pattern representing the alternatives."}, {"testcase_name": "ParameterNode", "description": "Pass a PARAMETER_NODE to rewriteToRegex, expecting the method to return a regex pattern representing the parameter type."}, {"testcase_name": "ExpressionNode", "description": "Pass an EXPRESSION_NODE to rewriteToRegex, expecting the method to return a regex pattern representing the entire expression."}, {"testcase_name": "InvalidNodeType", "description": "Pass an unsupported node type to rewriteToRegex, expecting an IllegalArgumentException to be thrown."}]}, {"method_name": "match", "description": "Matches the given text against the parsed Cucumber expression and returns a list of arguments if the match is successful.", "expected_testcases": [{"testcase_name": "SuccessfulMatch", "description": "Pass a text that matches the Cucumber expression, expecting a list of arguments to be returned."}, {"testcase_name": "NoMatch", "description": "Pass a text that does not match the Cucumber expression, expecting null to be returned."}, {"testcase_name": "MatchWithTypeHints", "description": "Pass a text that matches the Cucumber expression along with type hints, expecting the arguments to be transformed according to the type hints."}]}, {"method_name": "getSource", "description": "Returns the original source expression string used to create the CucumberExpression object.", "expected_testcases": [{"testcase_name": "GetSource", "description": "Call getSource on a CucumberExpression object, expecting the original expression string to be returned."}]}, {"method_name": "getRegexp", "description": "Returns the compiled regular expression pattern derived from the Cucumber expression.", "expected_testcases": [{"testcase_name": "GetRegexp", "description": "Call getRegexp on a CucumberExpression object, expecting the compiled regex pattern to be returned."}]}], "overrides": null, "class_name": "CucumberExpression", "description": "Class responsible for parsing and matching Cucumber expressions, converting them into regular expressions and handling parameter types."}, {"class_uri": "src/main/java/io/cucumber/cucumberexpressions/GroupBuilder.java.GroupBuilder", "class_docstring": "", "superclasses": "", "super_interfaces": [], "methods": [{"method_name": "GroupBuilder", "description": "Constructor that initializes the start index of the group.", "expected_testcases": [{"testcase_name": "InitializeWithValidIndex", "description": "Create a new GroupBuilder with a valid positive integer start index, expecting the startIndex field to be set correctly."}, {"testcase_name": "InitializeWithZeroIndex", "description": "Create a new GroupBuilder with a start index of zero, expecting the startIndex field to be set to zero."}]}, {"method_name": "add", "description": "Adds a GroupBuilder to the list of child group builders.", "expected_testcases": [{"testcase_name": "AddSingleGroupBuilder", "description": "Add a single GroupBuilder to an empty list, expecting the list to contain one element."}, {"testcase_name": "AddMultipleGroupBuilders", "description": "Add multiple GroupBuilders to the list, expecting the list to contain all added elements in the correct order."}]}, {"method_name": "build", "description": "Builds a Group using the Matcher and group indices, including all child groups.", "expected_testcases": [{"testcase_name": "BuildWithNoChildren", "description": "Build a Group with no child GroupBuilders, expecting a Group with an empty children list."}, {"testcase_name": "BuildWithChildren", "description": "Build a Group with multiple child GroupBuilders, expecting a Group with a populated children list."}, {"testcase_name": "BuildWithInvalidGroupIndex", "description": "Attempt to build a Group with an invalid group index, expecting an exception or error result."}]}, {"method_name": "setNonCapturing", "description": "Sets the capturing flag to false, indicating the group is non-capturing.", "expected_testcases": [{"testcase_name": "SetNonCapturing", "description": "Set the capturing flag to false, expecting the capturing field to be false."}]}, {"method_name": "isCapturing", "description": "Checks if the group is capturing.", "expected_testcases": [{"testcase_name": "IsCapturingTrue", "description": "Check the capturing flag when it is true, expecting the method to return true."}, {"testcase_name": "IsCapturingFalse", "description": "Check the capturing flag when it is false, expecting the method to return false."}]}, {"method_name": "moveChildrenTo", "description": "Moves all child GroupBuilders to another GroupBuilder.", "expected_testcases": [{"testcase_name": "MoveChildrenToEmptyGroupBuilder", "description": "Move children to an empty GroupBuilder, expecting the target GroupBuilder to contain all children."}, {"testcase_name": "MoveChildrenToNonEmptyGroupBuilder", "description": "Move children to a GroupBuilder that already has children, expecting the target GroupBuilder to contain all children from both sources."}]}, {"method_name": "getChildren", "description": "Returns the list of child GroupBuilders.", "expected_testcases": [{"testcase_name": "GetEmptyChildrenList", "description": "Get the children list when no children have been added, expecting an empty list."}, {"testcase_name": "GetPopulatedChildrenList", "description": "Get the children list after adding multiple children, expecting a list with the added children."}]}, {"method_name": "getSource", "description": "Returns the source string of the group.", "expected_testcases": [{"testcase_name": "GetSourceWithNoSourceSet", "description": "Get the source when no source has been set, expecting a null or default value."}, {"testcase_name": "GetSourceWithSourceSet", "description": "Get the source after setting a valid string, expecting the method to return the set string."}]}, {"method_name": "setSource", "description": "Sets the source string of the group.", "expected_testcases": [{"testcase_name": "SetValidSource", "description": "Set a valid non-empty string as the source, expecting the source field to be updated."}, {"testcase_name": "SetEmptySource", "description": "Set an empty string as the source, expecting the source field to be updated to an empty string."}]}, {"method_name": "getStartIndex", "description": "Returns the start index of the group.", "expected_testcases": [{"testcase_name": "GetStartIndex", "description": "Get the start index after initialization, expecting the method to return the initialized value."}]}, {"method_name": "getEndIndex", "description": "Returns the end index of the group.", "expected_testcases": [{"testcase_name": "GetEndIndexWithNoEndIndexSet", "description": "Get the end index when no end index has been set, expecting a default or initial value."}, {"testcase_name": "GetEndIndexWithEndIndexSet", "description": "Get the end index after setting a valid end index, expecting the method to return the set value."}]}, {"method_name": "setEndIndex", "description": "Sets the end index of the group.", "expected_testcases": [{"testcase_name": "SetValidEndIndex", "description": "Set a valid positive integer as the end index, expecting the endIndex field to be updated."}, {"testcase_name": "SetZeroEndIndex", "description": "Set zero as the end index, expecting the endIndex field to be updated to zero."}]}], "overrides": null, "class_name": "GroupBuilder", "description": "Class responsible for building groups of elements, managing their indices, and handling capturing and non-capturing groups."}, {"class_uri": "src/main/java/io/cucumber/cucumberexpressions/PatternCompilerProvider.java.PatternCompilerProvider", "class_docstring": "", "superclasses": "", "super_interfaces": [], "methods": [{"method_name": "getCompiler", "description": "Synchronized method that returns a PatternCompiler instance. It loads the PatternCompiler using the ServiceLoader if it hasn't been loaded yet.", "expected_testcases": [{"testcase_name": "SinglePatternCompilerFound", "description": "Test when a single PatternCompiler is found by the ServiceLoader. Expect the method to return the found PatternCompiler instance."}, {"testcase_name": "NoPatternCompilerFound", "description": "Test when no PatternCompiler is found by the ServiceLoader. Expect the method to return a DefaultPatternCompiler instance."}, {"testcase_name": "MultiplePatternCompilersFound", "description": "Test when multiple PatternCompilers are found by the ServiceLoader. Expect the method to throw an IllegalStateException with a message listing all found compilers."}, {"testcase_name": "ConcurrentAccess", "description": "Test concurrent access to the getCompiler method. Expect the method to handle concurrent calls without race conditions or inconsistent states."}]}, {"method_name": "findPatternCompiler", "description": "Helper method that iterates over the provided iterator to find and set the PatternCompiler service. If multiple compilers are found, it throws an exception.", "expected_testcases": [{"testcase_name": "SinglePatternCompilerFound", "description": "Test when the iterator contains a single PatternCompiler. Expect the service to be set to this compiler."}, {"testcase_name": "NoPatternCompilerFound", "description": "Test when the iterator is empty. Expect the service to be set to a DefaultPatternCompiler instance."}, {"testcase_name": "MultiplePatternCompilersFound", "description": "Test when the iterator contains multiple PatternCompilers. Expect the method to throw an IllegalStateException with a message listing all found compilers."}]}, {"method_name": "throwMoreThanOneCompilerException", "description": "Private helper method that throws an IllegalStateException if more than one PatternCompiler is found. It collects all found compilers and includes them in the exception message.", "expected_testcases": []}], "overrides": null, "class_name": "PatternCompilerProvider", "description": "A utility class responsible for providing a PatternCompiler instance. It ensures that only one PatternCompiler is loaded from the service loader, or defaults to a DefaultPatternCompiler if none are found."}, {"class_uri": "src/main/java/io/cucumber/cucumberexpressions/GeneratedExpression.java.GeneratedExpression", "class_docstring": "", "superclasses": "", "super_interfaces": [], "methods": [{"method_name": "GeneratedExpression", "description": "Constructor that initializes the expression template and parameter types.", "expected_testcases": []}, {"method_name": "isJavaKeyword", "description": "Private static method that checks if a given string is a Java keyword using binary search and a collator for English locale.", "expected_testcases": [{"testcase_name": "ValidJavaKeyword", "description": "Check if 'abstract' is recognized as a Java keyword, expecting true."}, {"testcase_name": "InvalidJavaKeyword", "description": "Check if 'notakeyword' is recognized as a Java keyword, expecting false."}, {"testcase_name": "CaseSensitivity", "description": "Check if 'Abstract' (with different case) is recognized as a Java keyword, expecting false."}]}, {"method_name": "getSource", "description": "Public method that generates the source code by formatting the expression template with the parameter type names.", "expected_testcases": [{"testcase_name": "SingleParameter", "description": "Generate source with a single parameter type, expecting the template to be formatted with that single parameter name."}, {"testcase_name": "MultipleParameters", "description": "Generate source with multiple parameter types, expecting the template to be formatted with all parameter names in sequence."}, {"testcase_name": "EmptyParameters", "description": "Generate source with no parameter types, expecting the template to be formatted with an empty array."}]}, {"method_name": "getParameterName", "description": "Private method that generates a unique parameter name based on the type name, ensuring it does not conflict with Java keywords and handles duplicates by appending a count.", "expected_testcases": [{"testcase_name": "UniqueTypeName", "description": "Generate a parameter name for a unique type name, expecting the name to be the same as the type name."}, {"testcase_name": "DuplicateTypeName", "description": "Generate a parameter name for a type name that has been used before, expecting the name to have a count appended."}, {"testcase_name": "JavaKeywordConflict", "description": "Generate a parameter name that is a Java keyword, expecting the name to have a count appended."}]}, {"method_name": "getParameterNames", "description": "Public method that generates a list of unique parameter names for the parameter types.", "expected_testcases": [{"testcase_name": "UniqueParameterNames", "description": "Generate parameter names for a list of unique parameter types, expecting each name to be unique and not a Java keyword."}, {"testcase_name": "DuplicateParameterNames", "description": "Generate parameter names for a list of parameter types with duplicates, expecting each name to be unique and not a Java keyword, with counts appended for duplicates."}, {"testcase_name": "EmptyParameterTypes", "description": "Generate parameter names for an empty list of parameter types, expecting an empty list."}]}, {"method_name": "getParameterTypes", "description": "Public method that returns the list of parameter types.", "expected_testcases": [{"testcase_name": "NonEmptyParameterTypes", "description": "Return the list of parameter types when it is non-empty, expecting the list to match the input."}, {"testcase_name": "EmptyParameterTypes", "description": "Return the list of parameter types when it is empty, expecting an empty list."}]}], "overrides": null, "class_name": "GeneratedExpression", "description": "Class responsible for generating expressions based on a template and a list of parameter types. It ensures that generated parameter names do not conflict with Java keywords and handles duplicate type names by appending a count."}]