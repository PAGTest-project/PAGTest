[{"relative_path": "src/test/java/com/github/davidmoten/rtree/GreekEarthquakes.java", "original_string": "package com.github.davidmoten.rtree;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.List;\nimport java.util.zip.GZIPInputStream;\n\nimport com.github.davidmoten.rtree.geometry.Geometries;\nimport com.github.davidmoten.rtree.geometry.Point;\n\nimport rx.Observable;\nimport rx.functions.Action1;\nimport rx.functions.Func0;\nimport rx.functions.Func1;\nimport rx.observables.StringObservable;\n\npublic class GreekEarthquakes {\n\n    public static Observable<Entry<Object, Point>> entries(final Precision precision) {\n        Observable<String> source = Observable.using(new Func0<InputStream>() {\n            @Override\n            public InputStream call() {\n                try {\n                    return new GZIPInputStream(GreekEarthquakes.class\n                            .getResourceAsStream(\"/greek-earthquakes-1964-2000.txt.gz\"));\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n        }, new Func1<InputStream, Observable<String>>() {\n            @Override\n            public Observable<String> call(InputStream is) {\n                return StringObservable.from(new InputStreamReader(is));\n            }\n        }, new Action1<InputStream>() {\n            @Override\n            public void call(InputStream is) {\n                try {\n                    is.close();\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n        });\n        return StringObservable.split(source, \"\\n\")\n                .flatMap(new Func1<String, Observable<Entry<Object, Point>>>() {\n\n                    @Override\n                    public Observable<Entry<Object, Point>> call(String line) {\n                        if (line.trim().length() > 0) {\n                            String[] items = line.split(\" \");\n                            double lat = Double.parseDouble(items[0]);\n                            double lon = Double.parseDouble(items[1]);\n                            Entry<Object, Point> entry;\n                            if (precision == Precision.DOUBLE)\n                                entry = Entries.entry(new Object(), Geometries.point(lat, lon));\n                            else\n                                entry = Entries.entry(new Object(),\n                                        Geometries.point((float) lat, (float) lon));\n                            return Observable.just(entry);\n                        } else\n                            return Observable.empty();\n                    }\n                });\n    }\n\n    static List<Entry<Object, Point>> entriesList(Precision precision) {\n        List<Entry<Object, Point>> result = entries(precision).toList().toBlocking().single();\n        System.out.println(\"loaded greek earthquakes into list\");\n        return result;\n    }\n\n    public static void main(String[] args) throws InterruptedException {\n        RTree<Object, Point> tree = RTree.star().create();\n        tree = tree.add(entries(Precision.SINGLE)).last().toBlocking().single();\n        System.gc();\n        Thread.sleep(10000000);\n        System.out.println(tree.size());\n    }\n}\n", "file_hash": "16a316306979b9a06fe49732b7f5e03f05b1ed717c7298735fca7c42193742f5", "file_docstring": "", "contexts": ["package com.github.davidmoten.rtree;", "import java.io.IOException;", "import java.io.InputStream;", "import java.io.InputStreamReader;", "import java.util.List;", "import java.util.zip.GZIPInputStream;", "import com.github.davidmoten.rtree.geometry.Geometries;", "import com.github.davidmoten.rtree.geometry.Point;", "import rx.Observable;", "import rx.functions.Action1;", "import rx.functions.Func0;", "import rx.functions.Func1;", "import rx.observables.StringObservable;"], "methods": [], "classes": [{"original_string": "public class GreekEarthquakes {\n\n    public static Observable<Entry<Object, Point>> entries(final Precision precision) {\n        Observable<String> source = Observable.using(new Func0<InputStream>() {\n            @Override\n            public InputStream call() {\n                try {\n                    return new GZIPInputStream(GreekEarthquakes.class\n                            .getResourceAsStream(\"/greek-earthquakes-1964-2000.txt.gz\"));\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n        }, new Func1<InputStream, Observable<String>>() {\n            @Override\n            public Observable<String> call(InputStream is) {\n                return StringObservable.from(new InputStreamReader(is));\n            }\n        }, new Action1<InputStream>() {\n            @Override\n            public void call(InputStream is) {\n                try {\n                    is.close();\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n        });\n        return StringObservable.split(source, \"\\n\")\n                .flatMap(new Func1<String, Observable<Entry<Object, Point>>>() {\n\n                    @Override\n                    public Observable<Entry<Object, Point>> call(String line) {\n                        if (line.trim().length() > 0) {\n                            String[] items = line.split(\" \");\n                            double lat = Double.parseDouble(items[0]);\n                            double lon = Double.parseDouble(items[1]);\n                            Entry<Object, Point> entry;\n                            if (precision == Precision.DOUBLE)\n                                entry = Entries.entry(new Object(), Geometries.point(lat, lon));\n                            else\n                                entry = Entries.entry(new Object(),\n                                        Geometries.point((float) lat, (float) lon));\n                            return Observable.just(entry);\n                        } else\n                            return Observable.empty();\n                    }\n                });\n    }\n\n    static List<Entry<Object, Point>> entriesList(Precision precision) {\n        List<Entry<Object, Point>> result = entries(precision).toList().toBlocking().single();\n        System.out.println(\"loaded greek earthquakes into list\");\n        return result;\n    }\n\n    public static void main(String[] args) throws InterruptedException {\n        RTree<Object, Point> tree = RTree.star().create();\n        tree = tree.add(entries(Precision.SINGLE)).last().toBlocking().single();\n        System.gc();\n        Thread.sleep(10000000);\n        System.out.println(tree.size());\n    }\n}", "definition": "public class GreekEarthquakes", "class_docstring": "", "name": "GreekEarthquakes", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    public static Observable<Entry<Object, Point>> entries(final Precision precision) {\n        Observable<String> source = Observable.using(new Func0<InputStream>() {\n            @Override\n            public InputStream call() {\n                try {\n                    return new GZIPInputStream(GreekEarthquakes.class\n                            .getResourceAsStream(\"/greek-earthquakes-1964-2000.txt.gz\"));\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n        }, new Func1<InputStream, Observable<String>>() {\n            @Override\n            public Observable<String> call(InputStream is) {\n                return StringObservable.from(new InputStreamReader(is));\n            }\n        }, new Action1<InputStream>() {\n            @Override\n            public void call(InputStream is) {\n                try {\n                    is.close();\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n        });\n        return StringObservable.split(source, \"\\n\")\n                .flatMap(new Func1<String, Observable<Entry<Object, Point>>>() {\n\n                    @Override\n                    public Observable<Entry<Object, Point>> call(String line) {\n                        if (line.trim().length() > 0) {\n                            String[] items = line.split(\" \");\n                            double lat = Double.parseDouble(items[0]);\n                            double lon = Double.parseDouble(items[1]);\n                            Entry<Object, Point> entry;\n                            if (precision == Precision.DOUBLE)\n                                entry = Entries.entry(new Object(), Geometries.point(lat, lon));\n                            else\n                                entry = Entries.entry(new Object(),\n                                        Geometries.point((float) lat, (float) lon));\n                            return Observable.just(entry);\n                        } else\n                            return Observable.empty();\n                    }\n                });\n    }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Observable<Entry<Object, Point>>", "classes": []}, "name": "entries", "params": [{"name": "precision", "type": "Precision"}], "body": "                                                                                      {\n        Observable<String> source = Observable.using(new Func0<InputStream>() {\n            @Override\n            public InputStream call() {\n                try {\n                    return new GZIPInputStream(GreekEarthquakes.class\n                            .getResourceAsStream(\"/greek-earthquakes-1964-2000.txt.gz\"));\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n        }, new Func1<InputStream, Observable<String>>() {\n            @Override\n            public Observable<String> call(InputStream is) {\n                return StringObservable.from(new InputStreamReader(is));\n            }\n        }, new Action1<InputStream>() {\n            @Override\n            public void call(InputStream is) {\n                try {\n                    is.close();\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n        });\n        return StringObservable.split(source, \"\\n\")\n                .flatMap(new Func1<String, Observable<Entry<Object, Point>>>() {\n\n                    @Override\n                    public Observable<Entry<Object, Point>> call(String line) {\n                        if (line.trim().length() > 0) {\n                            String[] items = line.split(\" \");\n                            double lat = Double.parseDouble(items[0]);\n                            double lon = Double.parseDouble(items[1]);\n                            Entry<Object, Point> entry;\n                            if (precision == Precision.DOUBLE)\n                                entry = Entries.entry(new Object(), Geometries.point(lat, lon));\n                            else\n                                entry = Entries.entry(new Object(),\n                                        Geometries.point((float) lat, (float) lon));\n                            return Observable.just(entry);\n                        } else\n                            return Observable.empty();\n                    }\n                });\n    }", "signature": "public static Observable<Entry<Object, Point>> entries(final Precision precision)"}, {"syntax_pass": true, "original_string": "    static List<Entry<Object, Point>> entriesList(Precision precision) {\n        List<Entry<Object, Point>> result = entries(precision).toList().toBlocking().single();\n        System.out.println(\"loaded greek earthquakes into list\");\n        return result;\n    }", "docstring": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "List<Entry<Object, Point>>", "classes": []}, "name": "entriesList", "params": [{"name": "precision", "type": "Precision"}], "body": "                                                                       {\n        List<Entry<Object, Point>> result = entries(precision).toList().toBlocking().single();\n        System.out.println(\"loaded greek earthquakes into list\");\n        return result;\n    }", "signature": "static List<Entry<Object, Point>> entriesList(Precision precision)"}, {"syntax_pass": true, "original_string": "    public static void main(String[] args) throws InterruptedException {\n        RTree<Object, Point> tree = RTree.star().create();\n        tree = tree.add(entries(Precision.SINGLE)).last().toBlocking().single();\n        System.gc();\n        Thread.sleep(10000000);\n        System.out.println(tree.size());\n    }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "void", "classes": []}, "name": "main", "params": [{"name": "args", "type": "String[]"}], "body": "                                                                       {\n        RTree<Object, Point> tree = RTree.star().create();\n        tree = tree.add(entries(Precision.SINGLE)).last().toBlocking().single();\n        System.gc();\n        Thread.sleep(10000000);\n        System.out.println(tree.size());\n    }", "signature": "public static void main(String[] args)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/com/github/davidmoten/rtree/RTree_nearestTest.java", "original_string": "\npackage com.github.davidmoten.rtree;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertTrue;\n\nimport java.util.List;\n\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport com.github.davidmoten.rtree.geometry.Geometries;\nimport com.github.davidmoten.rtree.geometry.Rectangle;\nimport rx.Observable;\n\npublic class RTree_nearestTest {\n\n    private RTree<Integer, Rectangle> tree;\n\n    @Before\n    public void setUp() {\n        tree = RTree.create();\n        tree = tree.add(1, Geometries.rectangle(0, 0, 1, 1));\n        tree = tree.add(2, Geometries.rectangle(2, 2, 3, 3));\n    }\n\n    @Test\n    public void testNearestWithinDistance() {\n        Rectangle searchRectangle = Geometries.rectangle(1.5, 1.5, 2.5, 2.5);\n        Observable<Entry<Integer, Rectangle>> result = tree.nearest(searchRectangle, 1.0, 1);\n        List<Entry<Integer, Rectangle>> entries = result.toList().toBlocking().single();\n        assertEquals(1, entries.size());\n        assertEquals(2, (int) entries.get(0).value());\n    }\n\n    @Test\n    public void testNearestWithNoMatches() {\n        Rectangle searchRectangle = Geometries.rectangle(4, 4, 5, 5);\n        Observable<Entry<Integer, Rectangle>> result = tree.nearest(searchRectangle, 1.0, 1);\n        List<Entry<Integer, Rectangle>> entries = result.toList().toBlocking().single();\n        assertTrue(entries.isEmpty());\n    }\n\n    @Test\n    public void testNearestWithMaxCount() {\n        Rectangle searchRectangle = Geometries.rectangle(0.5, 0.5, 2.5, 2.5);\n        Observable<Entry<Integer, Rectangle>> result = tree.nearest(searchRectangle, 2.0, 2);\n        List<Entry<Integer, Rectangle>> entries = result.toList().toBlocking().single();\n        assertEquals(2, entries.size());\n        assertEquals(1, (int) entries.get(0).value());\n        assertEquals(2, (int) entries.get(1).value());\n    }\n}\n", "file_hash": "684055d581cdd4f9df5ccf2d6b706d1bb402a41e26d3de60070b90faf03f05b5", "file_docstring": "", "contexts": ["package com.github.davidmoten.rtree;", "import static org.junit.Assert.assertEquals;", "import static org.junit.Assert.assertTrue;", "import java.util.List;", "import org.junit.Before;", "import org.junit.Test;", "import com.github.davidmoten.rtree.geometry.Geometries;", "import com.github.davidmoten.rtree.geometry.Rectangle;", "import rx.Observable;"], "methods": [], "classes": [{"original_string": "public class RTree_nearestTest {\n\n    private RTree<Integer, Rectangle> tree;\n\n    @Before\n    public void setUp() {\n        tree = RTree.create();\n        tree = tree.add(1, Geometries.rectangle(0, 0, 1, 1));\n        tree = tree.add(2, Geometries.rectangle(2, 2, 3, 3));\n    }\n\n    @Test\n    public void testNearestWithinDistance() {\n        Rectangle searchRectangle = Geometries.rectangle(1.5, 1.5, 2.5, 2.5);\n        Observable<Entry<Integer, Rectangle>> result = tree.nearest(searchRectangle, 1.0, 1);\n        List<Entry<Integer, Rectangle>> entries = result.toList().toBlocking().single();\n        assertEquals(1, entries.size());\n        assertEquals(2, (int) entries.get(0).value());\n    }\n\n    @Test\n    public void testNearestWithNoMatches() {\n        Rectangle searchRectangle = Geometries.rectangle(4, 4, 5, 5);\n        Observable<Entry<Integer, Rectangle>> result = tree.nearest(searchRectangle, 1.0, 1);\n        List<Entry<Integer, Rectangle>> entries = result.toList().toBlocking().single();\n        assertTrue(entries.isEmpty());\n    }\n\n    @Test\n    public void testNearestWithMaxCount() {\n        Rectangle searchRectangle = Geometries.rectangle(0.5, 0.5, 2.5, 2.5);\n        Observable<Entry<Integer, Rectangle>> result = tree.nearest(searchRectangle, 2.0, 2);\n        List<Entry<Integer, Rectangle>> entries = result.toList().toBlocking().single();\n        assertEquals(2, entries.size());\n        assertEquals(1, (int) entries.get(0).value());\n        assertEquals(2, (int) entries.get(1).value());\n    }\n}", "definition": "public class RTree_nearestTest", "class_docstring": "", "name": "RTree_nearestTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private RTree<Integer, Rectangle> tree;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "RTree<Integer, Rectangle>", "name": "tree", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @Before\n    public void setUp() {\n        tree = RTree.create();\n        tree = tree.add(1, Geometries.rectangle(0, 0, 1, 1));\n        tree = tree.add(2, Geometries.rectangle(2, 2, 3, 3));\n    }", "docstring": "", "attributes": {"modifiers": "@Before\n    public", "marker_annotations": ["@Before"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setUp", "params": [], "body": "                        {\n        tree = RTree.create();\n        tree = tree.add(1, Geometries.rectangle(0, 0, 1, 1));\n        tree = tree.add(2, Geometries.rectangle(2, 2, 3, 3));\n    }", "signature": "@Before\n    public void setUp()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testNearestWithinDistance() {\n        Rectangle searchRectangle = Geometries.rectangle(1.5, 1.5, 2.5, 2.5);\n        Observable<Entry<Integer, Rectangle>> result = tree.nearest(searchRectangle, 1.0, 1);\n        List<Entry<Integer, Rectangle>> entries = result.toList().toBlocking().single();\n        assertEquals(1, entries.size());\n        assertEquals(2, (int) entries.get(0).value());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testNearestWithinDistance", "params": [], "body": "                                            {\n        Rectangle searchRectangle = Geometries.rectangle(1.5, 1.5, 2.5, 2.5);\n        Observable<Entry<Integer, Rectangle>> result = tree.nearest(searchRectangle, 1.0, 1);\n        List<Entry<Integer, Rectangle>> entries = result.toList().toBlocking().single();\n        assertEquals(1, entries.size());\n        assertEquals(2, (int) entries.get(0).value());\n    }", "signature": "@Test\n    public void testNearestWithinDistance()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testNearestWithNoMatches() {\n        Rectangle searchRectangle = Geometries.rectangle(4, 4, 5, 5);\n        Observable<Entry<Integer, Rectangle>> result = tree.nearest(searchRectangle, 1.0, 1);\n        List<Entry<Integer, Rectangle>> entries = result.toList().toBlocking().single();\n        assertTrue(entries.isEmpty());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testNearestWithNoMatches", "params": [], "body": "                                           {\n        Rectangle searchRectangle = Geometries.rectangle(4, 4, 5, 5);\n        Observable<Entry<Integer, Rectangle>> result = tree.nearest(searchRectangle, 1.0, 1);\n        List<Entry<Integer, Rectangle>> entries = result.toList().toBlocking().single();\n        assertTrue(entries.isEmpty());\n    }", "signature": "@Test\n    public void testNearestWithNoMatches()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testNearestWithMaxCount() {\n        Rectangle searchRectangle = Geometries.rectangle(0.5, 0.5, 2.5, 2.5);\n        Observable<Entry<Integer, Rectangle>> result = tree.nearest(searchRectangle, 2.0, 2);\n        List<Entry<Integer, Rectangle>> entries = result.toList().toBlocking().single();\n        assertEquals(2, entries.size());\n        assertEquals(1, (int) entries.get(0).value());\n        assertEquals(2, (int) entries.get(1).value());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testNearestWithMaxCount", "params": [], "body": "                                          {\n        Rectangle searchRectangle = Geometries.rectangle(0.5, 0.5, 2.5, 2.5);\n        Observable<Entry<Integer, Rectangle>> result = tree.nearest(searchRectangle, 2.0, 2);\n        List<Entry<Integer, Rectangle>> entries = result.toList().toBlocking().single();\n        assertEquals(2, entries.size());\n        assertEquals(1, (int) entries.get(0).value());\n        assertEquals(2, (int) entries.get(1).value());\n    }", "signature": "@Test\n    public void testNearestWithMaxCount()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/com/github/davidmoten/rtree/RTree_searchTest.java", "original_string": "\npackage com.github.davidmoten.rtree;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.mockito.Mockito.*;\n\nimport org.junit.Before;\nimport org.junit.Test;\nimport rx.Observable;\nimport rx.functions.Func2;\nimport com.github.davidmoten.rtree.geometry.Geometry;\nimport com.github.davidmoten.rtree.geometry.Rectangle;\n\npublic class RTree_searchTest {\n\n    private RTree<String, Rectangle> rTree;\n    private Func2<Rectangle, Rectangle, Boolean> intersects;\n\n    @Before\n    public void setUp() {\n        rTree = RTree.star().create();\n        intersects = mock(Func2.class);\n    }\n\n    @Test\n    public void testSearchWithIntersects() {\n        Rectangle rectangle = com.github.davidmoten.rtree.geometry.Geometries.rectangle(0, 0, 1, 1);\n        when(intersects.call(any(), eq(rectangle))).thenReturn(true);\n\n        Observable<Entry<String, Rectangle>> result = rTree.search(rectangle, intersects);\n\n        assertEquals(0, result.count().toBlocking().single().intValue());\n    }\n\n    @Test\n    public void testSearchWithNonIntersectingGeometry() {\n        Rectangle rectangle = com.github.davidmoten.rtree.geometry.Geometries.rectangle(0, 0, 1, 1);\n        when(intersects.call(any(), eq(rectangle))).thenReturn(false);\n\n        Observable<Entry<String, Rectangle>> result = rTree.search(rectangle, intersects);\n\n        assertEquals(0, result.count().toBlocking().single().intValue());\n    }\n}\n", "file_hash": "669a5d588e34f395d0288c4cdb6dbb8c235b0e5f0e81368d095cede9c7ea7be1", "file_docstring": "", "contexts": ["package com.github.davidmoten.rtree;", "import static org.junit.Assert.assertEquals;", "import static org.mockito.Mockito.*;", "import org.junit.Before;", "import org.junit.Test;", "import rx.Observable;", "import rx.functions.Func2;", "import com.github.davidmoten.rtree.geometry.Geometry;", "import com.github.davidmoten.rtree.geometry.Rectangle;"], "methods": [], "classes": [{"original_string": "public class RTree_searchTest {\n\n    private RTree<String, Rectangle> rTree;\n    private Func2<Rectangle, Rectangle, Boolean> intersects;\n\n    @Before\n    public void setUp() {\n        rTree = RTree.star().create();\n        intersects = mock(Func2.class);\n    }\n\n    @Test\n    public void testSearchWithIntersects() {\n        Rectangle rectangle = com.github.davidmoten.rtree.geometry.Geometries.rectangle(0, 0, 1, 1);\n        when(intersects.call(any(), eq(rectangle))).thenReturn(true);\n\n        Observable<Entry<String, Rectangle>> result = rTree.search(rectangle, intersects);\n\n        assertEquals(0, result.count().toBlocking().single().intValue());\n    }\n\n    @Test\n    public void testSearchWithNonIntersectingGeometry() {\n        Rectangle rectangle = com.github.davidmoten.rtree.geometry.Geometries.rectangle(0, 0, 1, 1);\n        when(intersects.call(any(), eq(rectangle))).thenReturn(false);\n\n        Observable<Entry<String, Rectangle>> result = rTree.search(rectangle, intersects);\n\n        assertEquals(0, result.count().toBlocking().single().intValue());\n    }\n}", "definition": "public class RTree_searchTest", "class_docstring": "", "name": "RTree_searchTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private RTree<String, Rectangle> rTree;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "RTree<String, Rectangle>", "name": "rTree", "syntax_pass": true}, {"attribute_expression": "private Func2<Rectangle, Rectangle, Boolean> intersects;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Func2<Rectangle, Rectangle, Boolean>", "name": "intersects", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @Before\n    public void setUp() {\n        rTree = RTree.star().create();\n        intersects = mock(Func2.class);\n    }", "docstring": "", "attributes": {"modifiers": "@Before\n    public", "marker_annotations": ["@Before"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setUp", "params": [], "body": "                        {\n        rTree = RTree.star().create();\n        intersects = mock(Func2.class);\n    }", "signature": "@Before\n    public void setUp()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testSearchWithIntersects() {\n        Rectangle rectangle = com.github.davidmoten.rtree.geometry.Geometries.rectangle(0, 0, 1, 1);\n        when(intersects.call(any(), eq(rectangle))).thenReturn(true);\n\n        Observable<Entry<String, Rectangle>> result = rTree.search(rectangle, intersects);\n\n        assertEquals(0, result.count().toBlocking().single().intValue());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testSearchWithIntersects", "params": [], "body": "                                           {\n        Rectangle rectangle = com.github.davidmoten.rtree.geometry.Geometries.rectangle(0, 0, 1, 1);\n        when(intersects.call(any(), eq(rectangle))).thenReturn(true);\n\n        Observable<Entry<String, Rectangle>> result = rTree.search(rectangle, intersects);\n\n        assertEquals(0, result.count().toBlocking().single().intValue());\n    }", "signature": "@Test\n    public void testSearchWithIntersects()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testSearchWithNonIntersectingGeometry() {\n        Rectangle rectangle = com.github.davidmoten.rtree.geometry.Geometries.rectangle(0, 0, 1, 1);\n        when(intersects.call(any(), eq(rectangle))).thenReturn(false);\n\n        Observable<Entry<String, Rectangle>> result = rTree.search(rectangle, intersects);\n\n        assertEquals(0, result.count().toBlocking().single().intValue());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testSearchWithNonIntersectingGeometry", "params": [], "body": "                                                        {\n        Rectangle rectangle = com.github.davidmoten.rtree.geometry.Geometries.rectangle(0, 0, 1, 1);\n        when(intersects.call(any(), eq(rectangle))).thenReturn(false);\n\n        Observable<Entry<String, Rectangle>> result = rTree.search(rectangle, intersects);\n\n        assertEquals(0, result.count().toBlocking().single().intValue());\n    }", "signature": "@Test\n    public void testSearchWithNonIntersectingGeometry()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/com/github/davidmoten/rtree/BenchmarksRTree.java", "original_string": "package com.github.davidmoten.rtree;\n\nimport static com.github.davidmoten.rtree.Utilities.entries1000;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.util.List;\n\nimport org.openjdk.jmh.annotations.Benchmark;\nimport org.openjdk.jmh.annotations.Scope;\nimport org.openjdk.jmh.annotations.State;\nimport org.openjdk.jmh.infra.Blackhole;\n\nimport com.github.davidmoten.rtree.fbs.SerializerFlatBuffers;\nimport com.github.davidmoten.rtree.geometry.Geometries;\nimport com.github.davidmoten.rtree.geometry.Point;\nimport com.github.davidmoten.rtree.geometry.Rectangle;\n\nimport rx.Subscriber;\nimport rx.functions.Action1;\nimport rx.functions.Func1;\n\n@State(Scope.Benchmark)\npublic class BenchmarksRTree {\n\n    private final static Precision precision = Precision.DOUBLE;\n\n    private final List<Entry<Object, Point>> entries = GreekEarthquakes.entriesList(precision);\n\n    private final List<Entry<Object, Rectangle>> some = entries1000(precision);\n\n    private final RTree<Object, Point> defaultTreeM4 = RTree.maxChildren(4).<Object, Point> create()\n            .add(entries);\n\n    private final RTree<Object, Point> defaultTreeM10 = RTree.maxChildren(10)\n            .<Object, Point> create().add(entries);\n\n    private final RTree<Object, Point> starTreeM4 = RTree.maxChildren(4).star()\n            .<Object, Point> create().add(entries);\n\n    private final RTree<Object, Point> starTreeM10 = RTree.maxChildren(10).star()\n            .<Object, Point> create().add(entries);\n\n    private final RTree<Object, Point> defaultTreeM32 = RTree.maxChildren(32)\n            .<Object, Point> create().add(entries);\n\n    private final RTree<Object, Point> starTreeM32 = RTree.maxChildren(32).star()\n            .<Object, Point> create().add(entries);\n\n    private final RTree<Object, Point> defaultTreeM128 = RTree.maxChildren(128)\n            .<Object, Point> create().add(entries);\n\n    private final RTree<Object, Point> starTreeM128 = RTree.maxChildren(128).star()\n            .<Object, Point> create().add(entries);\n\n    private final RTree<Object, Rectangle> smallDefaultTreeM4 = RTree.maxChildren(4)\n            .<Object, Rectangle> create().add(some);\n\n    private final RTree<Object, Rectangle> smallDefaultTreeM10 = RTree.maxChildren(10)\n            .<Object, Rectangle> create().add(some);\n\n    private final RTree<Object, Rectangle> smallStarTreeM4 = RTree.maxChildren(4).star()\n            .<Object, Rectangle> create().add(some);\n\n    private final RTree<Object, Rectangle> smallStarTreeM10 = RTree.maxChildren(10).star()\n            .<Object, Rectangle> create().add(some);\n\n    private final RTree<Object, Rectangle> smallDefaultTreeM32 = RTree.maxChildren(32)\n            .<Object, Rectangle> create().add(some);\n\n    private final RTree<Object, Rectangle> smallStarTreeM32 = RTree.maxChildren(32).star()\n            .<Object, Rectangle> create().add(some);\n\n    private final RTree<Object, Rectangle> smallDefaultTreeM128 = RTree.maxChildren(128)\n            .<Object, Rectangle> create().add(some);\n\n    private final RTree<Object, Rectangle> smallStarTreeM128 = RTree.maxChildren(128).star()\n            .<Object, Rectangle> create().add(some);\n\n    private final byte[] byteArrayGreek = createFlatBuffersByteArrayGreek();\n\n    private final RTree<Object, Point> starTreeM10FlatBuffers = createFlatBuffersGreek();\n\n    @Benchmark\n    public RTree<Object, Point> defaultRTreeInsertOneEntryIntoGreekDataEntriesMaxChildren004() {\n        return insertPoint(defaultTreeM4);\n    }\n\n    private byte[] createFlatBuffersByteArrayGreek() {\n        RTree<Object, Point> tree = RTree.maxChildren(10).star().<Object, Point> create()\n                .add(entries);\n        final ByteArrayOutputStream os = new ByteArrayOutputStream();\n        Func1<Object, byte[]> serializer = new Func1<Object, byte[]>() {\n            @Override\n            public byte[] call(Object o) {\n                return new byte[0];\n            }\n        };\n        Func1<byte[], Object> deserializer = new Func1<byte[], Object>() {\n            @Override\n            public Object call(byte[] bytes) {\n                return null;\n            }\n        };\n        Serializer<Object, Point> fbSerializer = SerializerFlatBuffers.create(serializer,\n                deserializer);\n        try {\n            fbSerializer.write(tree, os);\n            os.close();\n            return os.toByteArray();\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    private RTree<Object, Point> createFlatBuffersGreek() {\n        Func1<Object, byte[]> serializer = new Func1<Object, byte[]>() {\n            @Override\n            public byte[] call(Object o) {\n                return new byte[0];\n            }\n        };\n        Func1<byte[], Object> deserializer = new Func1<byte[], Object>() {\n            @Override\n            public Object call(byte[] bytes) {\n                return null;\n            }\n        };\n        Serializer<Object, Point> fbSerializer = SerializerFlatBuffers.create(serializer,\n                deserializer);\n        try {\n            ByteArrayInputStream is = new ByteArrayInputStream(byteArrayGreek);\n            return fbSerializer.read(is, byteArrayGreek.length, InternalStructure.SINGLE_ARRAY);\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    @Benchmark\n    public RTree<Object, Point> defaultRTreeCreation010() {\n        return RTree.maxChildren(10).<Object, Point> create().add(entries);\n    }\n\n    @Benchmark\n    public RTree<Object, Point> starRTreeCreation010() {\n        return RTree.maxChildren(10).star().<Object, Point> create().add(entries);\n    }\n\n    @Benchmark\n    public RTree<Object, Point> flatBufferRTreeCreation010() {\n        return createFlatBuffersGreek();\n    }\n\n    @Benchmark\n    public RTree<Object, Point> bulkLoadingRTreeCreation010() {\n        return RTree.maxChildren(10).<Object, Point> create(entries);\n    }\n\n    @Benchmark\n    public RTree<Object, Point> bulkLoadingFullRTreeCreation010() {\n        return RTree.maxChildren(10).loadingFactor(1.0).<Object, Point> create(entries);\n    }\n\n    @Benchmark\n    public void defaultRTreeSearchOfGreekDataPointsMaxChildren004(Blackhole bh) {\n        searchGreek(defaultTreeM4, bh);\n    }\n\n    @Benchmark\n    public RTree<Object, Point> defaultRTreeInsertOneEntryIntoGreekDataEntriesMaxChildren010() {\n        return insertPoint(defaultTreeM10);\n    }\n\n    @Benchmark\n    public void defaultRTreeSearchOfGreekDataPointsMaxChildren010(Blackhole bh) {\n        searchGreek(defaultTreeM10, bh);\n    }\n\n    @Benchmark\n    public RTree<Object, Point> rStarTreeInsertOneEntryIntoGreekDataEntriesMaxChildren004() {\n        return insertPoint(starTreeM4);\n    }\n\n    @Benchmark\n    public RTree<Object, Point> rStarTreeInsertOneEntryIntoGreekDataEntriesMaxChildren010() {\n        return insertPoint(starTreeM10);\n    }\n\n    @Benchmark\n    public void rStarTreeSearchOfGreekDataPointsMaxChildren004(Blackhole bh) {\n        searchGreek(starTreeM4, bh);\n    }\n\n    @Benchmark\n    public void rStarTreeSearchOfGreekDataPointsMaxChildren010(Blackhole bh) {\n        searchGreek(starTreeM10, bh);\n    }\n\n    @Benchmark\n    public void rStarTreeSearchOfGreekDataPointsMaxChildren010FlatBuffers(Blackhole bh) {\n        searchGreek(starTreeM10FlatBuffers, bh);\n    }\n\n    @Benchmark\n    public void rStarTreeSearchOfGreekDataPointsMaxChildren010FlatBuffersBackpressure(\n            Blackhole bh) {\n        searchGreekBackpressure(starTreeM10FlatBuffers, bh);\n    }\n\n    @Benchmark\n    public void rStarTreeSearchOfGreekDataPointsMaxChildren010WithBackpressure(Blackhole bh) {\n        searchGreekWithBackpressure(starTreeM10, bh);\n    }\n\n    @Benchmark\n    public RTree<Object, Point> defaultRTreeInsertOneEntryIntoGreekDataEntriesMaxChildren032() {\n        return insertPoint(defaultTreeM32);\n    }\n\n    @Benchmark\n    public void defaultRTreeSearchOfGreekDataPointsMaxChildren032(Blackhole bh) {\n        searchGreek(defaultTreeM32, bh);\n    }\n\n    @Benchmark\n    public RTree<Object, Point> rStarTreeInsertOneEntryIntoGreekDataEntriesMaxChildren032() {\n        return insertPoint(starTreeM32);\n    }\n\n    @Benchmark\n    public void rStarTreeSearchOfGreekDataPointsMaxChildren032(Blackhole bh) {\n        searchGreek(starTreeM32, bh);\n    }\n\n    @Benchmark\n    public RTree<Object, Point> defaultRTreeInsertOneEntryIntoGreekDataEntriesMaxChildren128() {\n        return insertPoint(defaultTreeM128);\n    }\n\n    @Benchmark\n    public void defaultRTreeSearchOfGreekDataPointsMaxChildren128(Blackhole bh) {\n        searchGreek(defaultTreeM128, bh);\n    }\n\n    @Benchmark\n    public RTree<Object, Point> rStarTreeInsertOneEntryIntoGreekDataEntriesMaxChildren128() {\n        return insertPoint(starTreeM128);\n    }\n\n    @Benchmark\n    public void rStarTreeSearchOfGreekDataPointsMaxChildren128(Blackhole bh) {\n        searchGreek(starTreeM128, bh);\n    }\n\n    @Benchmark\n    public RTree<Object, Rectangle> defaultRTreeInsertOneEntryInto1000EntriesMaxChildren004() {\n        return insertRectangle(smallDefaultTreeM4);\n    }\n\n    @Benchmark\n    public void defaultRTreeSearchOf1000PointsMaxChildren004(Blackhole bh) {\n        search(smallDefaultTreeM4, bh);\n    }\n\n    @Benchmark\n    public RTree<Object, Rectangle> defaultRTreeInsertOneEntryInto1000EntriesMaxChildren010() {\n        return insertRectangle(smallDefaultTreeM10);\n    }\n\n    @Benchmark\n    public void defaultRTreeSearchOf1000PointsMaxChildren010(Blackhole bh) {\n        search(smallDefaultTreeM10, bh);\n    }\n\n    @Benchmark\n    public RTree<Object, Rectangle> rStarTreeInsertOneEntryInto1000EntriesMaxChildren004() {\n        return insertRectangle(smallStarTreeM4);\n    }\n\n    @Benchmark\n    public RTree<Object, Rectangle> rStarTreeInsertOneEntryInto1000EntriesMaxChildren010() {\n        return insertRectangle(smallStarTreeM10);\n    }\n\n    @Benchmark\n    public void rStarTreeSearchOf1000PointsMaxChildren004(Blackhole bh) {\n        search(smallStarTreeM4, bh);\n    }\n\n    @Benchmark\n    public void rStarTreeSearchOf1000PointsMaxChildren010(Blackhole bh) {\n        search(smallStarTreeM10, bh);\n    }\n\n    @Benchmark\n    public RTree<Object, Rectangle> defaultRTreeInsertOneEntryInto1000EntriesMaxChildren032() {\n        return insertRectangle(smallDefaultTreeM32);\n    }\n\n    @Benchmark\n    public void defaultRTreeSearchOf1000PointsMaxChildren032(Blackhole bh) {\n        search(smallDefaultTreeM32, bh);\n    }\n\n    @Benchmark\n    public RTree<Object, Rectangle> rStarTreeInsertOneEntryInto1000EntriesMaxChildren032() {\n        return insertRectangle(smallStarTreeM32);\n    }\n\n    @Benchmark\n    public void rStarTreeSearchOf1000PointsMaxChildren032(Blackhole bh) {\n        search(smallStarTreeM32, bh);\n    }\n\n    @Benchmark\n    public RTree<Object, Rectangle> defaultRTreeInsertOneEntryInto1000EntriesMaxChildren128() {\n        return insertRectangle(smallDefaultTreeM128);\n    }\n\n    @Benchmark\n    public void defaultRTreeSearchOf1000PointsMaxChildren128(Blackhole bh) {\n        search(smallDefaultTreeM128, bh);\n    }\n\n    @Benchmark\n    public RTree<Object, Rectangle> rStarTreeInsertOneEntryInto1000EntriesMaxChildren128() {\n        return insertRectangle(smallStarTreeM128);\n    }\n\n    @Benchmark\n    public void rStarTreeSearchOf1000PointsMaxChildren128(Blackhole bh) {\n        search(smallStarTreeM128, bh);\n    }\n\n    @Benchmark\n    public void rStarTreeDeleteOneEveryOccurrenceFromGreekDataChildren010() {\n        deleteAll(starTreeM10);\n    }\n\n    @Benchmark\n    public void searchNearestGreek(Blackhole bh) {\n        searchNearestGreek(starTreeM4, bh);\n    }\n\n    private RTree<Object, Point> deleteAll(RTree<Object, Point> tree) {\n        return tree.delete(entries.get(1000), true);\n    }\n\n    private void search(RTree<Object, Rectangle> tree, Blackhole bh) {\n        // returns 10 results\n        tree.search(Geometries.rectangle(500, 500, 630, 630)).subscribe(consumeWith(bh));\n    }\n\n    private void searchGreek(RTree<Object, Point> tree, Blackhole bh) {\n        // should return 22 results\n        tree.search(Geometries.rectangle(40, 27.0, 40.5, 27.5)).subscribe(consumeWith(bh));\n    }\n\n    private Action1<Object> consumeWith(final Blackhole bh) {\n        return new Action1<Object>() {\n\n            @Override\n            public void call(Object t) {\n                bh.consume(t);\n            }\n        };\n    }\n\n    private void searchGreekBackpressure(RTree<Object, Point> tree, Blackhole bh) {\n        // should return 22 results\n        final Rectangle r = searchRectangle();\n        tree.search(r).take(1000).subscribe(consumeWith(bh));\n    }\n\n    private static Rectangle searchRectangle() {\n        final Rectangle r;\n        if (precision == Precision.DOUBLE) {\n            r = Geometries.rectangle(40, 27.0, 40.5, 27.5);\n        } else {\n            r = Geometries.rectangle(40f, 27.0f, 40.5f, 27.5f);\n        }\n        return r;\n    }\n\n    private void searchNearestGreek(RTree<Object, Point> tree, Blackhole bh) {\n        final Point p;\n        if (precision == Precision.DOUBLE) {\n            p = Geometries.point(40.0, 27.0);\n        } else {\n            p = Geometries.point(40.0f, 27.0f);\n        }\n        tree.nearest(p, 1, 300).subscribe(consumeWith(bh));\n    }\n\n    private void searchGreekWithBackpressure(RTree<Object, Point> tree, final Blackhole bh) {\n        // should return 22 results\n        tree.search(searchRectangle()).subscribe(new Subscriber<Object>() {\n\n            @Override\n            public void onStart() {\n                request(1);\n            }\n\n            @Override\n            public void onCompleted() {\n\n            }\n\n            @Override\n            public void onError(Throwable arg0) {\n\n            }\n\n            @Override\n            public void onNext(Object t) {\n                request(1);\n                bh.consume(t);\n            }\n        });\n    }\n\n    private RTree<Object, Rectangle> insertRectangle(RTree<Object, Rectangle> tree) {\n        return tree.add(new Object(), RTreeTest.random(precision));\n    }\n\n    private RTree<Object, Point> insertPoint(RTree<Object, Point> tree) {\n        if (precision == Precision.DOUBLE) {\n            return tree.add(new Object(),\n                    Geometries.point(Math.random() * 1000, Math.random() * 1000));\n        } else {\n            return tree.add(new Object(),\n                    Geometries.point((float) Math.random() * 1000, (float) Math.random() * 1000));\n        }\n    }\n\n    public static void main(String[] args) {\n        BenchmarksRTree b = new BenchmarksRTree();\n        System.out.println(\"starting searches\");\n        while (true)\n            b.starTreeM4.search(searchRectangle()).subscribe();\n    }\n}\n", "file_hash": "fc347143c60bbe74322d2a009d1bc6711cbe3c0754f6316c5af4a5ce80cc8e56", "file_docstring": "", "contexts": ["package com.github.davidmoten.rtree;", "import static com.github.davidmoten.rtree.Utilities.entries1000;", "import java.io.ByteArrayInputStream;", "import java.io.ByteArrayOutputStream;", "import java.io.IOException;", "import java.util.List;", "import org.openjdk.jmh.annotations.Benchmark;", "import org.openjdk.jmh.annotations.Scope;", "import org.openjdk.jmh.annotations.State;", "import org.openjdk.jmh.infra.Blackhole;", "import com.github.davidmoten.rtree.fbs.SerializerFlatBuffers;", "import com.github.davidmoten.rtree.geometry.Geometries;", "import com.github.davidmoten.rtree.geometry.Point;", "import com.github.davidmoten.rtree.geometry.Rectangle;", "import rx.Subscriber;", "import rx.functions.Action1;", "import rx.functions.Func1;"], "methods": [], "classes": [{"original_string": "@State(Scope.Benchmark)\npublic class BenchmarksRTree {\n\n    private final static Precision precision = Precision.DOUBLE;\n\n    private final List<Entry<Object, Point>> entries = GreekEarthquakes.entriesList(precision);\n\n    private final List<Entry<Object, Rectangle>> some = entries1000(precision);\n\n    private final RTree<Object, Point> defaultTreeM4 = RTree.maxChildren(4).<Object, Point> create()\n            .add(entries);\n\n    private final RTree<Object, Point> defaultTreeM10 = RTree.maxChildren(10)\n            .<Object, Point> create().add(entries);\n\n    private final RTree<Object, Point> starTreeM4 = RTree.maxChildren(4).star()\n            .<Object, Point> create().add(entries);\n\n    private final RTree<Object, Point> starTreeM10 = RTree.maxChildren(10).star()\n            .<Object, Point> create().add(entries);\n\n    private final RTree<Object, Point> defaultTreeM32 = RTree.maxChildren(32)\n            .<Object, Point> create().add(entries);\n\n    private final RTree<Object, Point> starTreeM32 = RTree.maxChildren(32).star()\n            .<Object, Point> create().add(entries);\n\n    private final RTree<Object, Point> defaultTreeM128 = RTree.maxChildren(128)\n            .<Object, Point> create().add(entries);\n\n    private final RTree<Object, Point> starTreeM128 = RTree.maxChildren(128).star()\n            .<Object, Point> create().add(entries);\n\n    private final RTree<Object, Rectangle> smallDefaultTreeM4 = RTree.maxChildren(4)\n            .<Object, Rectangle> create().add(some);\n\n    private final RTree<Object, Rectangle> smallDefaultTreeM10 = RTree.maxChildren(10)\n            .<Object, Rectangle> create().add(some);\n\n    private final RTree<Object, Rectangle> smallStarTreeM4 = RTree.maxChildren(4).star()\n            .<Object, Rectangle> create().add(some);\n\n    private final RTree<Object, Rectangle> smallStarTreeM10 = RTree.maxChildren(10).star()\n            .<Object, Rectangle> create().add(some);\n\n    private final RTree<Object, Rectangle> smallDefaultTreeM32 = RTree.maxChildren(32)\n            .<Object, Rectangle> create().add(some);\n\n    private final RTree<Object, Rectangle> smallStarTreeM32 = RTree.maxChildren(32).star()\n            .<Object, Rectangle> create().add(some);\n\n    private final RTree<Object, Rectangle> smallDefaultTreeM128 = RTree.maxChildren(128)\n            .<Object, Rectangle> create().add(some);\n\n    private final RTree<Object, Rectangle> smallStarTreeM128 = RTree.maxChildren(128).star()\n            .<Object, Rectangle> create().add(some);\n\n    private final byte[] byteArrayGreek = createFlatBuffersByteArrayGreek();\n\n    private final RTree<Object, Point> starTreeM10FlatBuffers = createFlatBuffersGreek();\n\n    @Benchmark\n    public RTree<Object, Point> defaultRTreeInsertOneEntryIntoGreekDataEntriesMaxChildren004() {\n        return insertPoint(defaultTreeM4);\n    }\n\n    private byte[] createFlatBuffersByteArrayGreek() {\n        RTree<Object, Point> tree = RTree.maxChildren(10).star().<Object, Point> create()\n                .add(entries);\n        final ByteArrayOutputStream os = new ByteArrayOutputStream();\n        Func1<Object, byte[]> serializer = new Func1<Object, byte[]>() {\n            @Override\n            public byte[] call(Object o) {\n                return new byte[0];\n            }\n        };\n        Func1<byte[], Object> deserializer = new Func1<byte[], Object>() {\n            @Override\n            public Object call(byte[] bytes) {\n                return null;\n            }\n        };\n        Serializer<Object, Point> fbSerializer = SerializerFlatBuffers.create(serializer,\n                deserializer);\n        try {\n            fbSerializer.write(tree, os);\n            os.close();\n            return os.toByteArray();\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    private RTree<Object, Point> createFlatBuffersGreek() {\n        Func1<Object, byte[]> serializer = new Func1<Object, byte[]>() {\n            @Override\n            public byte[] call(Object o) {\n                return new byte[0];\n            }\n        };\n        Func1<byte[], Object> deserializer = new Func1<byte[], Object>() {\n            @Override\n            public Object call(byte[] bytes) {\n                return null;\n            }\n        };\n        Serializer<Object, Point> fbSerializer = SerializerFlatBuffers.create(serializer,\n                deserializer);\n        try {\n            ByteArrayInputStream is = new ByteArrayInputStream(byteArrayGreek);\n            return fbSerializer.read(is, byteArrayGreek.length, InternalStructure.SINGLE_ARRAY);\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    @Benchmark\n    public RTree<Object, Point> defaultRTreeCreation010() {\n        return RTree.maxChildren(10).<Object, Point> create().add(entries);\n    }\n\n    @Benchmark\n    public RTree<Object, Point> starRTreeCreation010() {\n        return RTree.maxChildren(10).star().<Object, Point> create().add(entries);\n    }\n\n    @Benchmark\n    public RTree<Object, Point> flatBufferRTreeCreation010() {\n        return createFlatBuffersGreek();\n    }\n\n    @Benchmark\n    public RTree<Object, Point> bulkLoadingRTreeCreation010() {\n        return RTree.maxChildren(10).<Object, Point> create(entries);\n    }\n\n    @Benchmark\n    public RTree<Object, Point> bulkLoadingFullRTreeCreation010() {\n        return RTree.maxChildren(10).loadingFactor(1.0).<Object, Point> create(entries);\n    }\n\n    @Benchmark\n    public void defaultRTreeSearchOfGreekDataPointsMaxChildren004(Blackhole bh) {\n        searchGreek(defaultTreeM4, bh);\n    }\n\n    @Benchmark\n    public RTree<Object, Point> defaultRTreeInsertOneEntryIntoGreekDataEntriesMaxChildren010() {\n        return insertPoint(defaultTreeM10);\n    }\n\n    @Benchmark\n    public void defaultRTreeSearchOfGreekDataPointsMaxChildren010(Blackhole bh) {\n        searchGreek(defaultTreeM10, bh);\n    }\n\n    @Benchmark\n    public RTree<Object, Point> rStarTreeInsertOneEntryIntoGreekDataEntriesMaxChildren004() {\n        return insertPoint(starTreeM4);\n    }\n\n    @Benchmark\n    public RTree<Object, Point> rStarTreeInsertOneEntryIntoGreekDataEntriesMaxChildren010() {\n        return insertPoint(starTreeM10);\n    }\n\n    @Benchmark\n    public void rStarTreeSearchOfGreekDataPointsMaxChildren004(Blackhole bh) {\n        searchGreek(starTreeM4, bh);\n    }\n\n    @Benchmark\n    public void rStarTreeSearchOfGreekDataPointsMaxChildren010(Blackhole bh) {\n        searchGreek(starTreeM10, bh);\n    }\n\n    @Benchmark\n    public void rStarTreeSearchOfGreekDataPointsMaxChildren010FlatBuffers(Blackhole bh) {\n        searchGreek(starTreeM10FlatBuffers, bh);\n    }\n\n    @Benchmark\n    public void rStarTreeSearchOfGreekDataPointsMaxChildren010FlatBuffersBackpressure(\n            Blackhole bh) {\n        searchGreekBackpressure(starTreeM10FlatBuffers, bh);\n    }\n\n    @Benchmark\n    public void rStarTreeSearchOfGreekDataPointsMaxChildren010WithBackpressure(Blackhole bh) {\n        searchGreekWithBackpressure(starTreeM10, bh);\n    }\n\n    @Benchmark\n    public RTree<Object, Point> defaultRTreeInsertOneEntryIntoGreekDataEntriesMaxChildren032() {\n        return insertPoint(defaultTreeM32);\n    }\n\n    @Benchmark\n    public void defaultRTreeSearchOfGreekDataPointsMaxChildren032(Blackhole bh) {\n        searchGreek(defaultTreeM32, bh);\n    }\n\n    @Benchmark\n    public RTree<Object, Point> rStarTreeInsertOneEntryIntoGreekDataEntriesMaxChildren032() {\n        return insertPoint(starTreeM32);\n    }\n\n    @Benchmark\n    public void rStarTreeSearchOfGreekDataPointsMaxChildren032(Blackhole bh) {\n        searchGreek(starTreeM32, bh);\n    }\n\n    @Benchmark\n    public RTree<Object, Point> defaultRTreeInsertOneEntryIntoGreekDataEntriesMaxChildren128() {\n        return insertPoint(defaultTreeM128);\n    }\n\n    @Benchmark\n    public void defaultRTreeSearchOfGreekDataPointsMaxChildren128(Blackhole bh) {\n        searchGreek(defaultTreeM128, bh);\n    }\n\n    @Benchmark\n    public RTree<Object, Point> rStarTreeInsertOneEntryIntoGreekDataEntriesMaxChildren128() {\n        return insertPoint(starTreeM128);\n    }\n\n    @Benchmark\n    public void rStarTreeSearchOfGreekDataPointsMaxChildren128(Blackhole bh) {\n        searchGreek(starTreeM128, bh);\n    }\n\n    @Benchmark\n    public RTree<Object, Rectangle> defaultRTreeInsertOneEntryInto1000EntriesMaxChildren004() {\n        return insertRectangle(smallDefaultTreeM4);\n    }\n\n    @Benchmark\n    public void defaultRTreeSearchOf1000PointsMaxChildren004(Blackhole bh) {\n        search(smallDefaultTreeM4, bh);\n    }\n\n    @Benchmark\n    public RTree<Object, Rectangle> defaultRTreeInsertOneEntryInto1000EntriesMaxChildren010() {\n        return insertRectangle(smallDefaultTreeM10);\n    }\n\n    @Benchmark\n    public void defaultRTreeSearchOf1000PointsMaxChildren010(Blackhole bh) {\n        search(smallDefaultTreeM10, bh);\n    }\n\n    @Benchmark\n    public RTree<Object, Rectangle> rStarTreeInsertOneEntryInto1000EntriesMaxChildren004() {\n        return insertRectangle(smallStarTreeM4);\n    }\n\n    @Benchmark\n    public RTree<Object, Rectangle> rStarTreeInsertOneEntryInto1000EntriesMaxChildren010() {\n        return insertRectangle(smallStarTreeM10);\n    }\n\n    @Benchmark\n    public void rStarTreeSearchOf1000PointsMaxChildren004(Blackhole bh) {\n        search(smallStarTreeM4, bh);\n    }\n\n    @Benchmark\n    public void rStarTreeSearchOf1000PointsMaxChildren010(Blackhole bh) {\n        search(smallStarTreeM10, bh);\n    }\n\n    @Benchmark\n    public RTree<Object, Rectangle> defaultRTreeInsertOneEntryInto1000EntriesMaxChildren032() {\n        return insertRectangle(smallDefaultTreeM32);\n    }\n\n    @Benchmark\n    public void defaultRTreeSearchOf1000PointsMaxChildren032(Blackhole bh) {\n        search(smallDefaultTreeM32, bh);\n    }\n\n    @Benchmark\n    public RTree<Object, Rectangle> rStarTreeInsertOneEntryInto1000EntriesMaxChildren032() {\n        return insertRectangle(smallStarTreeM32);\n    }\n\n    @Benchmark\n    public void rStarTreeSearchOf1000PointsMaxChildren032(Blackhole bh) {\n        search(smallStarTreeM32, bh);\n    }\n\n    @Benchmark\n    public RTree<Object, Rectangle> defaultRTreeInsertOneEntryInto1000EntriesMaxChildren128() {\n        return insertRectangle(smallDefaultTreeM128);\n    }\n\n    @Benchmark\n    public void defaultRTreeSearchOf1000PointsMaxChildren128(Blackhole bh) {\n        search(smallDefaultTreeM128, bh);\n    }\n\n    @Benchmark\n    public RTree<Object, Rectangle> rStarTreeInsertOneEntryInto1000EntriesMaxChildren128() {\n        return insertRectangle(smallStarTreeM128);\n    }\n\n    @Benchmark\n    public void rStarTreeSearchOf1000PointsMaxChildren128(Blackhole bh) {\n        search(smallStarTreeM128, bh);\n    }\n\n    @Benchmark\n    public void rStarTreeDeleteOneEveryOccurrenceFromGreekDataChildren010() {\n        deleteAll(starTreeM10);\n    }\n\n    @Benchmark\n    public void searchNearestGreek(Blackhole bh) {\n        searchNearestGreek(starTreeM4, bh);\n    }\n\n    private RTree<Object, Point> deleteAll(RTree<Object, Point> tree) {\n        return tree.delete(entries.get(1000), true);\n    }\n\n    private void search(RTree<Object, Rectangle> tree, Blackhole bh) {\n        // returns 10 results\n        tree.search(Geometries.rectangle(500, 500, 630, 630)).subscribe(consumeWith(bh));\n    }\n\n    private void searchGreek(RTree<Object, Point> tree, Blackhole bh) {\n        // should return 22 results\n        tree.search(Geometries.rectangle(40, 27.0, 40.5, 27.5)).subscribe(consumeWith(bh));\n    }\n\n    private Action1<Object> consumeWith(final Blackhole bh) {\n        return new Action1<Object>() {\n\n            @Override\n            public void call(Object t) {\n                bh.consume(t);\n            }\n        };\n    }\n\n    private void searchGreekBackpressure(RTree<Object, Point> tree, Blackhole bh) {\n        // should return 22 results\n        final Rectangle r = searchRectangle();\n        tree.search(r).take(1000).subscribe(consumeWith(bh));\n    }\n\n    private static Rectangle searchRectangle() {\n        final Rectangle r;\n        if (precision == Precision.DOUBLE) {\n            r = Geometries.rectangle(40, 27.0, 40.5, 27.5);\n        } else {\n            r = Geometries.rectangle(40f, 27.0f, 40.5f, 27.5f);\n        }\n        return r;\n    }\n\n    private void searchNearestGreek(RTree<Object, Point> tree, Blackhole bh) {\n        final Point p;\n        if (precision == Precision.DOUBLE) {\n            p = Geometries.point(40.0, 27.0);\n        } else {\n            p = Geometries.point(40.0f, 27.0f);\n        }\n        tree.nearest(p, 1, 300).subscribe(consumeWith(bh));\n    }\n\n    private void searchGreekWithBackpressure(RTree<Object, Point> tree, final Blackhole bh) {\n        // should return 22 results\n        tree.search(searchRectangle()).subscribe(new Subscriber<Object>() {\n\n            @Override\n            public void onStart() {\n                request(1);\n            }\n\n            @Override\n            public void onCompleted() {\n\n            }\n\n            @Override\n            public void onError(Throwable arg0) {\n\n            }\n\n            @Override\n            public void onNext(Object t) {\n                request(1);\n                bh.consume(t);\n            }\n        });\n    }\n\n    private RTree<Object, Rectangle> insertRectangle(RTree<Object, Rectangle> tree) {\n        return tree.add(new Object(), RTreeTest.random(precision));\n    }\n\n    private RTree<Object, Point> insertPoint(RTree<Object, Point> tree) {\n        if (precision == Precision.DOUBLE) {\n            return tree.add(new Object(),\n                    Geometries.point(Math.random() * 1000, Math.random() * 1000));\n        } else {\n            return tree.add(new Object(),\n                    Geometries.point((float) Math.random() * 1000, (float) Math.random() * 1000));\n        }\n    }\n\n    public static void main(String[] args) {\n        BenchmarksRTree b = new BenchmarksRTree();\n        System.out.println(\"starting searches\");\n        while (true)\n            b.starTreeM4.search(searchRectangle()).subscribe();\n    }\n}", "definition": "@State(Scope.Benchmark)\npublic class BenchmarksRTree", "class_docstring": "", "name": "BenchmarksRTree", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "@State(Scope.Benchmark)\npublic", "marker_annotations": [], "non_marker_annotations": ["@State(Scope.Benchmark)", "public"], "comments": [], "fields": [{"attribute_expression": "private final static Precision precision = Precision.DOUBLE;", "docstring": "", "modifiers": "private final static", "marker_annotations": [], "non_marker_annotations": ["private", "final", "static"], "comments": [], "type": "Precision", "name": "precision = Precision.DOUBLE", "syntax_pass": true}, {"attribute_expression": "private final List<Entry<Object, Point>> entries = GreekEarthquakes.entriesList(precision);", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "List<Entry<Object, Point>>", "name": "entries = GreekEarthquakes.entriesList(precision)", "syntax_pass": true}, {"attribute_expression": "private final List<Entry<Object, Rectangle>> some = entries1000(precision);", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "List<Entry<Object, Rectangle>>", "name": "some = entries1000(precision)", "syntax_pass": true}, {"attribute_expression": "private final RTree<Object, Point> defaultTreeM4 = RTree.maxChildren(4).<Object, Point> create()\n            .add(entries);", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "RTree<Object, Point>", "name": "defaultTreeM4 = RTree.maxChildren(4).<Object, Point> create()\n            .add(entries)", "syntax_pass": true}, {"attribute_expression": "private final RTree<Object, Point> defaultTreeM10 = RTree.maxChildren(10)\n            .<Object, Point> create().add(entries);", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "RTree<Object, Point>", "name": "defaultTreeM10 = RTree.maxChildren(10)\n            .<Object, Point> create().add(entries)", "syntax_pass": true}, {"attribute_expression": "private final RTree<Object, Point> starTreeM4 = RTree.maxChildren(4).star()\n            .<Object, Point> create().add(entries);", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "RTree<Object, Point>", "name": "starTreeM4 = RTree.maxChildren(4).star()\n            .<Object, Point> create().add(entries)", "syntax_pass": true}, {"attribute_expression": "private final RTree<Object, Point> starTreeM10 = RTree.maxChildren(10).star()\n            .<Object, Point> create().add(entries);", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "RTree<Object, Point>", "name": "starTreeM10 = RTree.maxChildren(10).star()\n            .<Object, Point> create().add(entries)", "syntax_pass": true}, {"attribute_expression": "private final RTree<Object, Point> defaultTreeM32 = RTree.maxChildren(32)\n            .<Object, Point> create().add(entries);", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "RTree<Object, Point>", "name": "defaultTreeM32 = RTree.maxChildren(32)\n            .<Object, Point> create().add(entries)", "syntax_pass": true}, {"attribute_expression": "private final RTree<Object, Point> starTreeM32 = RTree.maxChildren(32).star()\n            .<Object, Point> create().add(entries);", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "RTree<Object, Point>", "name": "starTreeM32 = RTree.maxChildren(32).star()\n            .<Object, Point> create().add(entries)", "syntax_pass": true}, {"attribute_expression": "private final RTree<Object, Point> defaultTreeM128 = RTree.maxChildren(128)\n            .<Object, Point> create().add(entries);", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "RTree<Object, Point>", "name": "defaultTreeM128 = RTree.maxChildren(128)\n            .<Object, Point> create().add(entries)", "syntax_pass": true}, {"attribute_expression": "private final RTree<Object, Point> starTreeM128 = RTree.maxChildren(128).star()\n            .<Object, Point> create().add(entries);", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "RTree<Object, Point>", "name": "starTreeM128 = RTree.maxChildren(128).star()\n            .<Object, Point> create().add(entries)", "syntax_pass": true}, {"attribute_expression": "private final RTree<Object, Rectangle> smallDefaultTreeM4 = RTree.maxChildren(4)\n            .<Object, Rectangle> create().add(some);", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "RTree<Object, Rectangle>", "name": "smallDefaultTreeM4 = RTree.maxChildren(4)\n            .<Object, Rectangle> create().add(some)", "syntax_pass": true}, {"attribute_expression": "private final RTree<Object, Rectangle> smallDefaultTreeM10 = RTree.maxChildren(10)\n            .<Object, Rectangle> create().add(some);", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "RTree<Object, Rectangle>", "name": "smallDefaultTreeM10 = RTree.maxChildren(10)\n            .<Object, Rectangle> create().add(some)", "syntax_pass": true}, {"attribute_expression": "private final RTree<Object, Rectangle> smallStarTreeM4 = RTree.maxChildren(4).star()\n            .<Object, Rectangle> create().add(some);", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "RTree<Object, Rectangle>", "name": "smallStarTreeM4 = RTree.maxChildren(4).star()\n            .<Object, Rectangle> create().add(some)", "syntax_pass": true}, {"attribute_expression": "private final RTree<Object, Rectangle> smallStarTreeM10 = RTree.maxChildren(10).star()\n            .<Object, Rectangle> create().add(some);", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "RTree<Object, Rectangle>", "name": "smallStarTreeM10 = RTree.maxChildren(10).star()\n            .<Object, Rectangle> create().add(some)", "syntax_pass": true}, {"attribute_expression": "private final RTree<Object, Rectangle> smallDefaultTreeM32 = RTree.maxChildren(32)\n            .<Object, Rectangle> create().add(some);", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "RTree<Object, Rectangle>", "name": "smallDefaultTreeM32 = RTree.maxChildren(32)\n            .<Object, Rectangle> create().add(some)", "syntax_pass": true}, {"attribute_expression": "private final RTree<Object, Rectangle> smallStarTreeM32 = RTree.maxChildren(32).star()\n            .<Object, Rectangle> create().add(some);", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "RTree<Object, Rectangle>", "name": "smallStarTreeM32 = RTree.maxChildren(32).star()\n            .<Object, Rectangle> create().add(some)", "syntax_pass": true}, {"attribute_expression": "private final RTree<Object, Rectangle> smallDefaultTreeM128 = RTree.maxChildren(128)\n            .<Object, Rectangle> create().add(some);", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "RTree<Object, Rectangle>", "name": "smallDefaultTreeM128 = RTree.maxChildren(128)\n            .<Object, Rectangle> create().add(some)", "syntax_pass": true}, {"attribute_expression": "private final RTree<Object, Rectangle> smallStarTreeM128 = RTree.maxChildren(128).star()\n            .<Object, Rectangle> create().add(some);", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "RTree<Object, Rectangle>", "name": "smallStarTreeM128 = RTree.maxChildren(128).star()\n            .<Object, Rectangle> create().add(some)", "syntax_pass": true}, {"attribute_expression": "private final byte[] byteArrayGreek = createFlatBuffersByteArrayGreek();", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "byte[]", "name": "byteArrayGreek = createFlatBuffersByteArrayGreek()", "syntax_pass": true}, {"attribute_expression": "private final RTree<Object, Point> starTreeM10FlatBuffers = createFlatBuffersGreek();", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "RTree<Object, Point>", "name": "starTreeM10FlatBuffers = createFlatBuffersGreek()", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @Benchmark\n    public RTree<Object, Point> defaultRTreeInsertOneEntryIntoGreekDataEntriesMaxChildren004() {\n        return insertPoint(defaultTreeM4);\n    }", "docstring": "", "attributes": {"modifiers": "@Benchmark\n    public", "marker_annotations": ["@Benchmark"], "non_marker_annotations": ["public"], "comments": [], "return_type": "RTree<Object, Point>", "classes": []}, "name": "defaultRTreeInsertOneEntryIntoGreekDataEntriesMaxChildren004", "params": [], "body": "                                                                                               {\n        return insertPoint(defaultTreeM4);\n    }", "signature": "@Benchmark\n    public RTree<Object, Point> defaultRTreeInsertOneEntryIntoGreekDataEntriesMaxChildren004()"}, {"syntax_pass": true, "original_string": "    private byte[] createFlatBuffersByteArrayGreek() {\n        RTree<Object, Point> tree = RTree.maxChildren(10).star().<Object, Point> create()\n                .add(entries);\n        final ByteArrayOutputStream os = new ByteArrayOutputStream();\n        Func1<Object, byte[]> serializer = new Func1<Object, byte[]>() {\n            @Override\n            public byte[] call(Object o) {\n                return new byte[0];\n            }\n        };\n        Func1<byte[], Object> deserializer = new Func1<byte[], Object>() {\n            @Override\n            public Object call(byte[] bytes) {\n                return null;\n            }\n        };\n        Serializer<Object, Point> fbSerializer = SerializerFlatBuffers.create(serializer,\n                deserializer);\n        try {\n            fbSerializer.write(tree, os);\n            os.close();\n            return os.toByteArray();\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "byte[]", "classes": []}, "name": "createFlatBuffersByteArrayGreek", "params": [], "body": "                                                     {\n        RTree<Object, Point> tree = RTree.maxChildren(10).star().<Object, Point> create()\n                .add(entries);\n        final ByteArrayOutputStream os = new ByteArrayOutputStream();\n        Func1<Object, byte[]> serializer = new Func1<Object, byte[]>() {\n            @Override\n            public byte[] call(Object o) {\n                return new byte[0];\n            }\n        };\n        Func1<byte[], Object> deserializer = new Func1<byte[], Object>() {\n            @Override\n            public Object call(byte[] bytes) {\n                return null;\n            }\n        };\n        Serializer<Object, Point> fbSerializer = SerializerFlatBuffers.create(serializer,\n                deserializer);\n        try {\n            fbSerializer.write(tree, os);\n            os.close();\n            return os.toByteArray();\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }", "signature": "private byte[] createFlatBuffersByteArrayGreek()"}, {"syntax_pass": true, "original_string": "    private RTree<Object, Point> createFlatBuffersGreek() {\n        Func1<Object, byte[]> serializer = new Func1<Object, byte[]>() {\n            @Override\n            public byte[] call(Object o) {\n                return new byte[0];\n            }\n        };\n        Func1<byte[], Object> deserializer = new Func1<byte[], Object>() {\n            @Override\n            public Object call(byte[] bytes) {\n                return null;\n            }\n        };\n        Serializer<Object, Point> fbSerializer = SerializerFlatBuffers.create(serializer,\n                deserializer);\n        try {\n            ByteArrayInputStream is = new ByteArrayInputStream(byteArrayGreek);\n            return fbSerializer.read(is, byteArrayGreek.length, InternalStructure.SINGLE_ARRAY);\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "RTree<Object, Point>", "classes": []}, "name": "createFlatBuffersGreek", "params": [], "body": "                                                          {\n        Func1<Object, byte[]> serializer = new Func1<Object, byte[]>() {\n            @Override\n            public byte[] call(Object o) {\n                return new byte[0];\n            }\n        };\n        Func1<byte[], Object> deserializer = new Func1<byte[], Object>() {\n            @Override\n            public Object call(byte[] bytes) {\n                return null;\n            }\n        };\n        Serializer<Object, Point> fbSerializer = SerializerFlatBuffers.create(serializer,\n                deserializer);\n        try {\n            ByteArrayInputStream is = new ByteArrayInputStream(byteArrayGreek);\n            return fbSerializer.read(is, byteArrayGreek.length, InternalStructure.SINGLE_ARRAY);\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }", "signature": "private RTree<Object, Point> createFlatBuffersGreek()"}, {"syntax_pass": true, "original_string": "    @Benchmark\n    public RTree<Object, Point> defaultRTreeCreation010() {\n        return RTree.maxChildren(10).<Object, Point> create().add(entries);\n    }", "docstring": "", "attributes": {"modifiers": "@Benchmark\n    public", "marker_annotations": ["@Benchmark"], "non_marker_annotations": ["public"], "comments": [], "return_type": "RTree<Object, Point>", "classes": []}, "name": "defaultRTreeCreation010", "params": [], "body": "                                                          {\n        return RTree.maxChildren(10).<Object, Point> create().add(entries);\n    }", "signature": "@Benchmark\n    public RTree<Object, Point> defaultRTreeCreation010()"}, {"syntax_pass": true, "original_string": "    @Benchmark\n    public RTree<Object, Point> starRTreeCreation010() {\n        return RTree.maxChildren(10).star().<Object, Point> create().add(entries);\n    }", "docstring": "", "attributes": {"modifiers": "@Benchmark\n    public", "marker_annotations": ["@Benchmark"], "non_marker_annotations": ["public"], "comments": [], "return_type": "RTree<Object, Point>", "classes": []}, "name": "starRTreeCreation010", "params": [], "body": "                                                       {\n        return RTree.maxChildren(10).star().<Object, Point> create().add(entries);\n    }", "signature": "@Benchmark\n    public RTree<Object, Point> starRTreeCreation010()"}, {"syntax_pass": true, "original_string": "    @Benchmark\n    public RTree<Object, Point> flatBufferRTreeCreation010() {\n        return createFlatBuffersGreek();\n    }", "docstring": "", "attributes": {"modifiers": "@Benchmark\n    public", "marker_annotations": ["@Benchmark"], "non_marker_annotations": ["public"], "comments": [], "return_type": "RTree<Object, Point>", "classes": []}, "name": "flatBufferRTreeCreation010", "params": [], "body": "                                                             {\n        return createFlatBuffersGreek();\n    }", "signature": "@Benchmark\n    public RTree<Object, Point> flatBufferRTreeCreation010()"}, {"syntax_pass": true, "original_string": "    @Benchmark\n    public RTree<Object, Point> bulkLoadingRTreeCreation010() {\n        return RTree.maxChildren(10).<Object, Point> create(entries);\n    }", "docstring": "", "attributes": {"modifiers": "@Benchmark\n    public", "marker_annotations": ["@Benchmark"], "non_marker_annotations": ["public"], "comments": [], "return_type": "RTree<Object, Point>", "classes": []}, "name": "bulkLoadingRTreeCreation010", "params": [], "body": "                                                              {\n        return RTree.maxChildren(10).<Object, Point> create(entries);\n    }", "signature": "@Benchmark\n    public RTree<Object, Point> bulkLoadingRTreeCreation010()"}, {"syntax_pass": true, "original_string": "    @Benchmark\n    public RTree<Object, Point> bulkLoadingFullRTreeCreation010() {\n        return RTree.maxChildren(10).loadingFactor(1.0).<Object, Point> create(entries);\n    }", "docstring": "", "attributes": {"modifiers": "@Benchmark\n    public", "marker_annotations": ["@Benchmark"], "non_marker_annotations": ["public"], "comments": [], "return_type": "RTree<Object, Point>", "classes": []}, "name": "bulkLoadingFullRTreeCreation010", "params": [], "body": "                                                                  {\n        return RTree.maxChildren(10).loadingFactor(1.0).<Object, Point> create(entries);\n    }", "signature": "@Benchmark\n    public RTree<Object, Point> bulkLoadingFullRTreeCreation010()"}, {"syntax_pass": true, "original_string": "    @Benchmark\n    public void defaultRTreeSearchOfGreekDataPointsMaxChildren004(Blackhole bh) {\n        searchGreek(defaultTreeM4, bh);\n    }", "docstring": "", "attributes": {"modifiers": "@Benchmark\n    public", "marker_annotations": ["@Benchmark"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "defaultRTreeSearchOfGreekDataPointsMaxChildren004", "params": [{"name": "bh", "type": "Blackhole"}], "body": "                                                                                {\n        searchGreek(defaultTreeM4, bh);\n    }", "signature": "@Benchmark\n    public void defaultRTreeSearchOfGreekDataPointsMaxChildren004(Blackhole bh)"}, {"syntax_pass": true, "original_string": "    @Benchmark\n    public RTree<Object, Point> defaultRTreeInsertOneEntryIntoGreekDataEntriesMaxChildren010() {\n        return insertPoint(defaultTreeM10);\n    }", "docstring": "", "attributes": {"modifiers": "@Benchmark\n    public", "marker_annotations": ["@Benchmark"], "non_marker_annotations": ["public"], "comments": [], "return_type": "RTree<Object, Point>", "classes": []}, "name": "defaultRTreeInsertOneEntryIntoGreekDataEntriesMaxChildren010", "params": [], "body": "                                                                                               {\n        return insertPoint(defaultTreeM10);\n    }", "signature": "@Benchmark\n    public RTree<Object, Point> defaultRTreeInsertOneEntryIntoGreekDataEntriesMaxChildren010()"}, {"syntax_pass": true, "original_string": "    @Benchmark\n    public void defaultRTreeSearchOfGreekDataPointsMaxChildren010(Blackhole bh) {\n        searchGreek(defaultTreeM10, bh);\n    }", "docstring": "", "attributes": {"modifiers": "@Benchmark\n    public", "marker_annotations": ["@Benchmark"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "defaultRTreeSearchOfGreekDataPointsMaxChildren010", "params": [{"name": "bh", "type": "Blackhole"}], "body": "                                                                                {\n        searchGreek(defaultTreeM10, bh);\n    }", "signature": "@Benchmark\n    public void defaultRTreeSearchOfGreekDataPointsMaxChildren010(Blackhole bh)"}, {"syntax_pass": true, "original_string": "    @Benchmark\n    public RTree<Object, Point> rStarTreeInsertOneEntryIntoGreekDataEntriesMaxChildren004() {\n        return insertPoint(starTreeM4);\n    }", "docstring": "", "attributes": {"modifiers": "@Benchmark\n    public", "marker_annotations": ["@Benchmark"], "non_marker_annotations": ["public"], "comments": [], "return_type": "RTree<Object, Point>", "classes": []}, "name": "rStarTreeInsertOneEntryIntoGreekDataEntriesMaxChildren004", "params": [], "body": "                                                                                            {\n        return insertPoint(starTreeM4);\n    }", "signature": "@Benchmark\n    public RTree<Object, Point> rStarTreeInsertOneEntryIntoGreekDataEntriesMaxChildren004()"}, {"syntax_pass": true, "original_string": "    @Benchmark\n    public RTree<Object, Point> rStarTreeInsertOneEntryIntoGreekDataEntriesMaxChildren010() {\n        return insertPoint(starTreeM10);\n    }", "docstring": "", "attributes": {"modifiers": "@Benchmark\n    public", "marker_annotations": ["@Benchmark"], "non_marker_annotations": ["public"], "comments": [], "return_type": "RTree<Object, Point>", "classes": []}, "name": "rStarTreeInsertOneEntryIntoGreekDataEntriesMaxChildren010", "params": [], "body": "                                                                                            {\n        return insertPoint(starTreeM10);\n    }", "signature": "@Benchmark\n    public RTree<Object, Point> rStarTreeInsertOneEntryIntoGreekDataEntriesMaxChildren010()"}, {"syntax_pass": true, "original_string": "    @Benchmark\n    public void rStarTreeSearchOfGreekDataPointsMaxChildren004(Blackhole bh) {\n        searchGreek(starTreeM4, bh);\n    }", "docstring": "", "attributes": {"modifiers": "@Benchmark\n    public", "marker_annotations": ["@Benchmark"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "rStarTreeSearchOfGreekDataPointsMaxChildren004", "params": [{"name": "bh", "type": "Blackhole"}], "body": "                                                                             {\n        searchGreek(starTreeM4, bh);\n    }", "signature": "@Benchmark\n    public void rStarTreeSearchOfGreekDataPointsMaxChildren004(Blackhole bh)"}, {"syntax_pass": true, "original_string": "    @Benchmark\n    public void rStarTreeSearchOfGreekDataPointsMaxChildren010(Blackhole bh) {\n        searchGreek(starTreeM10, bh);\n    }", "docstring": "", "attributes": {"modifiers": "@Benchmark\n    public", "marker_annotations": ["@Benchmark"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "rStarTreeSearchOfGreekDataPointsMaxChildren010", "params": [{"name": "bh", "type": "Blackhole"}], "body": "                                                                             {\n        searchGreek(starTreeM10, bh);\n    }", "signature": "@Benchmark\n    public void rStarTreeSearchOfGreekDataPointsMaxChildren010(Blackhole bh)"}, {"syntax_pass": true, "original_string": "    @Benchmark\n    public void rStarTreeSearchOfGreekDataPointsMaxChildren010FlatBuffers(Blackhole bh) {\n        searchGreek(starTreeM10FlatBuffers, bh);\n    }", "docstring": "", "attributes": {"modifiers": "@Benchmark\n    public", "marker_annotations": ["@Benchmark"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "rStarTreeSearchOfGreekDataPointsMaxChildren010FlatBuffers", "params": [{"name": "bh", "type": "Blackhole"}], "body": "                                                                                        {\n        searchGreek(starTreeM10FlatBuffers, bh);\n    }", "signature": "@Benchmark\n    public void rStarTreeSearchOfGreekDataPointsMaxChildren010FlatBuffers(Blackhole bh)"}, {"syntax_pass": true, "original_string": "    @Benchmark\n    public void rStarTreeSearchOfGreekDataPointsMaxChildren010FlatBuffersBackpressure(\n            Blackhole bh) {\n        searchGreekBackpressure(starTreeM10FlatBuffers, bh);\n    }", "docstring": "", "attributes": {"modifiers": "@Benchmark\n    public", "marker_annotations": ["@Benchmark"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "rStarTreeSearchOfGreekDataPointsMaxChildren010FlatBuffersBackpressure", "params": [{"name": "bh", "type": "Blackhole"}], "body": "                          {\n        searchGreekBackpressure(starTreeM10FlatBuffers, bh);\n    }", "signature": "@Benchmark\n    public void rStarTreeSearchOfGreekDataPointsMaxChildren010FlatBuffersBackpressure(\n            Blackhole bh)"}, {"syntax_pass": true, "original_string": "    @Benchmark\n    public void rStarTreeSearchOfGreekDataPointsMaxChildren010WithBackpressure(Blackhole bh) {\n        searchGreekWithBackpressure(starTreeM10, bh);\n    }", "docstring": "", "attributes": {"modifiers": "@Benchmark\n    public", "marker_annotations": ["@Benchmark"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "rStarTreeSearchOfGreekDataPointsMaxChildren010WithBackpressure", "params": [{"name": "bh", "type": "Blackhole"}], "body": "                                                                                             {\n        searchGreekWithBackpressure(starTreeM10, bh);\n    }", "signature": "@Benchmark\n    public void rStarTreeSearchOfGreekDataPointsMaxChildren010WithBackpressure(Blackhole bh)"}, {"syntax_pass": true, "original_string": "    @Benchmark\n    public RTree<Object, Point> defaultRTreeInsertOneEntryIntoGreekDataEntriesMaxChildren032() {\n        return insertPoint(defaultTreeM32);\n    }", "docstring": "", "attributes": {"modifiers": "@Benchmark\n    public", "marker_annotations": ["@Benchmark"], "non_marker_annotations": ["public"], "comments": [], "return_type": "RTree<Object, Point>", "classes": []}, "name": "defaultRTreeInsertOneEntryIntoGreekDataEntriesMaxChildren032", "params": [], "body": "                                                                                               {\n        return insertPoint(defaultTreeM32);\n    }", "signature": "@Benchmark\n    public RTree<Object, Point> defaultRTreeInsertOneEntryIntoGreekDataEntriesMaxChildren032()"}, {"syntax_pass": true, "original_string": "    @Benchmark\n    public void defaultRTreeSearchOfGreekDataPointsMaxChildren032(Blackhole bh) {\n        searchGreek(defaultTreeM32, bh);\n    }", "docstring": "", "attributes": {"modifiers": "@Benchmark\n    public", "marker_annotations": ["@Benchmark"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "defaultRTreeSearchOfGreekDataPointsMaxChildren032", "params": [{"name": "bh", "type": "Blackhole"}], "body": "                                                                                {\n        searchGreek(defaultTreeM32, bh);\n    }", "signature": "@Benchmark\n    public void defaultRTreeSearchOfGreekDataPointsMaxChildren032(Blackhole bh)"}, {"syntax_pass": true, "original_string": "    @Benchmark\n    public RTree<Object, Point> rStarTreeInsertOneEntryIntoGreekDataEntriesMaxChildren032() {\n        return insertPoint(starTreeM32);\n    }", "docstring": "", "attributes": {"modifiers": "@Benchmark\n    public", "marker_annotations": ["@Benchmark"], "non_marker_annotations": ["public"], "comments": [], "return_type": "RTree<Object, Point>", "classes": []}, "name": "rStarTreeInsertOneEntryIntoGreekDataEntriesMaxChildren032", "params": [], "body": "                                                                                            {\n        return insertPoint(starTreeM32);\n    }", "signature": "@Benchmark\n    public RTree<Object, Point> rStarTreeInsertOneEntryIntoGreekDataEntriesMaxChildren032()"}, {"syntax_pass": true, "original_string": "    @Benchmark\n    public void rStarTreeSearchOfGreekDataPointsMaxChildren032(Blackhole bh) {\n        searchGreek(starTreeM32, bh);\n    }", "docstring": "", "attributes": {"modifiers": "@Benchmark\n    public", "marker_annotations": ["@Benchmark"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "rStarTreeSearchOfGreekDataPointsMaxChildren032", "params": [{"name": "bh", "type": "Blackhole"}], "body": "                                                                             {\n        searchGreek(starTreeM32, bh);\n    }", "signature": "@Benchmark\n    public void rStarTreeSearchOfGreekDataPointsMaxChildren032(Blackhole bh)"}, {"syntax_pass": true, "original_string": "    @Benchmark\n    public RTree<Object, Point> defaultRTreeInsertOneEntryIntoGreekDataEntriesMaxChildren128() {\n        return insertPoint(defaultTreeM128);\n    }", "docstring": "", "attributes": {"modifiers": "@Benchmark\n    public", "marker_annotations": ["@Benchmark"], "non_marker_annotations": ["public"], "comments": [], "return_type": "RTree<Object, Point>", "classes": []}, "name": "defaultRTreeInsertOneEntryIntoGreekDataEntriesMaxChildren128", "params": [], "body": "                                                                                               {\n        return insertPoint(defaultTreeM128);\n    }", "signature": "@Benchmark\n    public RTree<Object, Point> defaultRTreeInsertOneEntryIntoGreekDataEntriesMaxChildren128()"}, {"syntax_pass": true, "original_string": "    @Benchmark\n    public void defaultRTreeSearchOfGreekDataPointsMaxChildren128(Blackhole bh) {\n        searchGreek(defaultTreeM128, bh);\n    }", "docstring": "", "attributes": {"modifiers": "@Benchmark\n    public", "marker_annotations": ["@Benchmark"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "defaultRTreeSearchOfGreekDataPointsMaxChildren128", "params": [{"name": "bh", "type": "Blackhole"}], "body": "                                                                                {\n        searchGreek(defaultTreeM128, bh);\n    }", "signature": "@Benchmark\n    public void defaultRTreeSearchOfGreekDataPointsMaxChildren128(Blackhole bh)"}, {"syntax_pass": true, "original_string": "    @Benchmark\n    public RTree<Object, Point> rStarTreeInsertOneEntryIntoGreekDataEntriesMaxChildren128() {\n        return insertPoint(starTreeM128);\n    }", "docstring": "", "attributes": {"modifiers": "@Benchmark\n    public", "marker_annotations": ["@Benchmark"], "non_marker_annotations": ["public"], "comments": [], "return_type": "RTree<Object, Point>", "classes": []}, "name": "rStarTreeInsertOneEntryIntoGreekDataEntriesMaxChildren128", "params": [], "body": "                                                                                            {\n        return insertPoint(starTreeM128);\n    }", "signature": "@Benchmark\n    public RTree<Object, Point> rStarTreeInsertOneEntryIntoGreekDataEntriesMaxChildren128()"}, {"syntax_pass": true, "original_string": "    @Benchmark\n    public void rStarTreeSearchOfGreekDataPointsMaxChildren128(Blackhole bh) {\n        searchGreek(starTreeM128, bh);\n    }", "docstring": "", "attributes": {"modifiers": "@Benchmark\n    public", "marker_annotations": ["@Benchmark"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "rStarTreeSearchOfGreekDataPointsMaxChildren128", "params": [{"name": "bh", "type": "Blackhole"}], "body": "                                                                             {\n        searchGreek(starTreeM128, bh);\n    }", "signature": "@Benchmark\n    public void rStarTreeSearchOfGreekDataPointsMaxChildren128(Blackhole bh)"}, {"syntax_pass": true, "original_string": "    @Benchmark\n    public RTree<Object, Rectangle> defaultRTreeInsertOneEntryInto1000EntriesMaxChildren004() {\n        return insertRectangle(smallDefaultTreeM4);\n    }", "docstring": "", "attributes": {"modifiers": "@Benchmark\n    public", "marker_annotations": ["@Benchmark"], "non_marker_annotations": ["public"], "comments": [], "return_type": "RTree<Object, Rectangle>", "classes": []}, "name": "defaultRTreeInsertOneEntryInto1000EntriesMaxChildren004", "params": [], "body": "                                                                                              {\n        return insertRectangle(smallDefaultTreeM4);\n    }", "signature": "@Benchmark\n    public RTree<Object, Rectangle> defaultRTreeInsertOneEntryInto1000EntriesMaxChildren004()"}, {"syntax_pass": true, "original_string": "    @Benchmark\n    public void defaultRTreeSearchOf1000PointsMaxChildren004(Blackhole bh) {\n        search(smallDefaultTreeM4, bh);\n    }", "docstring": "", "attributes": {"modifiers": "@Benchmark\n    public", "marker_annotations": ["@Benchmark"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "defaultRTreeSearchOf1000PointsMaxChildren004", "params": [{"name": "bh", "type": "Blackhole"}], "body": "                                                                           {\n        search(smallDefaultTreeM4, bh);\n    }", "signature": "@Benchmark\n    public void defaultRTreeSearchOf1000PointsMaxChildren004(Blackhole bh)"}, {"syntax_pass": true, "original_string": "    @Benchmark\n    public RTree<Object, Rectangle> defaultRTreeInsertOneEntryInto1000EntriesMaxChildren010() {\n        return insertRectangle(smallDefaultTreeM10);\n    }", "docstring": "", "attributes": {"modifiers": "@Benchmark\n    public", "marker_annotations": ["@Benchmark"], "non_marker_annotations": ["public"], "comments": [], "return_type": "RTree<Object, Rectangle>", "classes": []}, "name": "defaultRTreeInsertOneEntryInto1000EntriesMaxChildren010", "params": [], "body": "                                                                                              {\n        return insertRectangle(smallDefaultTreeM10);\n    }", "signature": "@Benchmark\n    public RTree<Object, Rectangle> defaultRTreeInsertOneEntryInto1000EntriesMaxChildren010()"}, {"syntax_pass": true, "original_string": "    @Benchmark\n    public void defaultRTreeSearchOf1000PointsMaxChildren010(Blackhole bh) {\n        search(smallDefaultTreeM10, bh);\n    }", "docstring": "", "attributes": {"modifiers": "@Benchmark\n    public", "marker_annotations": ["@Benchmark"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "defaultRTreeSearchOf1000PointsMaxChildren010", "params": [{"name": "bh", "type": "Blackhole"}], "body": "                                                                           {\n        search(smallDefaultTreeM10, bh);\n    }", "signature": "@Benchmark\n    public void defaultRTreeSearchOf1000PointsMaxChildren010(Blackhole bh)"}, {"syntax_pass": true, "original_string": "    @Benchmark\n    public RTree<Object, Rectangle> rStarTreeInsertOneEntryInto1000EntriesMaxChildren004() {\n        return insertRectangle(smallStarTreeM4);\n    }", "docstring": "", "attributes": {"modifiers": "@Benchmark\n    public", "marker_annotations": ["@Benchmark"], "non_marker_annotations": ["public"], "comments": [], "return_type": "RTree<Object, Rectangle>", "classes": []}, "name": "rStarTreeInsertOneEntryInto1000EntriesMaxChildren004", "params": [], "body": "                                                                                           {\n        return insertRectangle(smallStarTreeM4);\n    }", "signature": "@Benchmark\n    public RTree<Object, Rectangle> rStarTreeInsertOneEntryInto1000EntriesMaxChildren004()"}, {"syntax_pass": true, "original_string": "    @Benchmark\n    public RTree<Object, Rectangle> rStarTreeInsertOneEntryInto1000EntriesMaxChildren010() {\n        return insertRectangle(smallStarTreeM10);\n    }", "docstring": "", "attributes": {"modifiers": "@Benchmark\n    public", "marker_annotations": ["@Benchmark"], "non_marker_annotations": ["public"], "comments": [], "return_type": "RTree<Object, Rectangle>", "classes": []}, "name": "rStarTreeInsertOneEntryInto1000EntriesMaxChildren010", "params": [], "body": "                                                                                           {\n        return insertRectangle(smallStarTreeM10);\n    }", "signature": "@Benchmark\n    public RTree<Object, Rectangle> rStarTreeInsertOneEntryInto1000EntriesMaxChildren010()"}, {"syntax_pass": true, "original_string": "    @Benchmark\n    public void rStarTreeSearchOf1000PointsMaxChildren004(Blackhole bh) {\n        search(smallStarTreeM4, bh);\n    }", "docstring": "", "attributes": {"modifiers": "@Benchmark\n    public", "marker_annotations": ["@Benchmark"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "rStarTreeSearchOf1000PointsMaxChildren004", "params": [{"name": "bh", "type": "Blackhole"}], "body": "                                                                        {\n        search(smallStarTreeM4, bh);\n    }", "signature": "@Benchmark\n    public void rStarTreeSearchOf1000PointsMaxChildren004(Blackhole bh)"}, {"syntax_pass": true, "original_string": "    @Benchmark\n    public void rStarTreeSearchOf1000PointsMaxChildren010(Blackhole bh) {\n        search(smallStarTreeM10, bh);\n    }", "docstring": "", "attributes": {"modifiers": "@Benchmark\n    public", "marker_annotations": ["@Benchmark"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "rStarTreeSearchOf1000PointsMaxChildren010", "params": [{"name": "bh", "type": "Blackhole"}], "body": "                                                                        {\n        search(smallStarTreeM10, bh);\n    }", "signature": "@Benchmark\n    public void rStarTreeSearchOf1000PointsMaxChildren010(Blackhole bh)"}, {"syntax_pass": true, "original_string": "    @Benchmark\n    public RTree<Object, Rectangle> defaultRTreeInsertOneEntryInto1000EntriesMaxChildren032() {\n        return insertRectangle(smallDefaultTreeM32);\n    }", "docstring": "", "attributes": {"modifiers": "@Benchmark\n    public", "marker_annotations": ["@Benchmark"], "non_marker_annotations": ["public"], "comments": [], "return_type": "RTree<Object, Rectangle>", "classes": []}, "name": "defaultRTreeInsertOneEntryInto1000EntriesMaxChildren032", "params": [], "body": "                                                                                              {\n        return insertRectangle(smallDefaultTreeM32);\n    }", "signature": "@Benchmark\n    public RTree<Object, Rectangle> defaultRTreeInsertOneEntryInto1000EntriesMaxChildren032()"}, {"syntax_pass": true, "original_string": "    @Benchmark\n    public void defaultRTreeSearchOf1000PointsMaxChildren032(Blackhole bh) {\n        search(smallDefaultTreeM32, bh);\n    }", "docstring": "", "attributes": {"modifiers": "@Benchmark\n    public", "marker_annotations": ["@Benchmark"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "defaultRTreeSearchOf1000PointsMaxChildren032", "params": [{"name": "bh", "type": "Blackhole"}], "body": "                                                                           {\n        search(smallDefaultTreeM32, bh);\n    }", "signature": "@Benchmark\n    public void defaultRTreeSearchOf1000PointsMaxChildren032(Blackhole bh)"}, {"syntax_pass": true, "original_string": "    @Benchmark\n    public RTree<Object, Rectangle> rStarTreeInsertOneEntryInto1000EntriesMaxChildren032() {\n        return insertRectangle(smallStarTreeM32);\n    }", "docstring": "", "attributes": {"modifiers": "@Benchmark\n    public", "marker_annotations": ["@Benchmark"], "non_marker_annotations": ["public"], "comments": [], "return_type": "RTree<Object, Rectangle>", "classes": []}, "name": "rStarTreeInsertOneEntryInto1000EntriesMaxChildren032", "params": [], "body": "                                                                                           {\n        return insertRectangle(smallStarTreeM32);\n    }", "signature": "@Benchmark\n    public RTree<Object, Rectangle> rStarTreeInsertOneEntryInto1000EntriesMaxChildren032()"}, {"syntax_pass": true, "original_string": "    @Benchmark\n    public void rStarTreeSearchOf1000PointsMaxChildren032(Blackhole bh) {\n        search(smallStarTreeM32, bh);\n    }", "docstring": "", "attributes": {"modifiers": "@Benchmark\n    public", "marker_annotations": ["@Benchmark"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "rStarTreeSearchOf1000PointsMaxChildren032", "params": [{"name": "bh", "type": "Blackhole"}], "body": "                                                                        {\n        search(smallStarTreeM32, bh);\n    }", "signature": "@Benchmark\n    public void rStarTreeSearchOf1000PointsMaxChildren032(Blackhole bh)"}, {"syntax_pass": true, "original_string": "    @Benchmark\n    public RTree<Object, Rectangle> defaultRTreeInsertOneEntryInto1000EntriesMaxChildren128() {\n        return insertRectangle(smallDefaultTreeM128);\n    }", "docstring": "", "attributes": {"modifiers": "@Benchmark\n    public", "marker_annotations": ["@Benchmark"], "non_marker_annotations": ["public"], "comments": [], "return_type": "RTree<Object, Rectangle>", "classes": []}, "name": "defaultRTreeInsertOneEntryInto1000EntriesMaxChildren128", "params": [], "body": "                                                                                              {\n        return insertRectangle(smallDefaultTreeM128);\n    }", "signature": "@Benchmark\n    public RTree<Object, Rectangle> defaultRTreeInsertOneEntryInto1000EntriesMaxChildren128()"}, {"syntax_pass": true, "original_string": "    @Benchmark\n    public void defaultRTreeSearchOf1000PointsMaxChildren128(Blackhole bh) {\n        search(smallDefaultTreeM128, bh);\n    }", "docstring": "", "attributes": {"modifiers": "@Benchmark\n    public", "marker_annotations": ["@Benchmark"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "defaultRTreeSearchOf1000PointsMaxChildren128", "params": [{"name": "bh", "type": "Blackhole"}], "body": "                                                                           {\n        search(smallDefaultTreeM128, bh);\n    }", "signature": "@Benchmark\n    public void defaultRTreeSearchOf1000PointsMaxChildren128(Blackhole bh)"}, {"syntax_pass": true, "original_string": "    @Benchmark\n    public RTree<Object, Rectangle> rStarTreeInsertOneEntryInto1000EntriesMaxChildren128() {\n        return insertRectangle(smallStarTreeM128);\n    }", "docstring": "", "attributes": {"modifiers": "@Benchmark\n    public", "marker_annotations": ["@Benchmark"], "non_marker_annotations": ["public"], "comments": [], "return_type": "RTree<Object, Rectangle>", "classes": []}, "name": "rStarTreeInsertOneEntryInto1000EntriesMaxChildren128", "params": [], "body": "                                                                                           {\n        return insertRectangle(smallStarTreeM128);\n    }", "signature": "@Benchmark\n    public RTree<Object, Rectangle> rStarTreeInsertOneEntryInto1000EntriesMaxChildren128()"}, {"syntax_pass": true, "original_string": "    @Benchmark\n    public void rStarTreeSearchOf1000PointsMaxChildren128(Blackhole bh) {\n        search(smallStarTreeM128, bh);\n    }", "docstring": "", "attributes": {"modifiers": "@Benchmark\n    public", "marker_annotations": ["@Benchmark"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "rStarTreeSearchOf1000PointsMaxChildren128", "params": [{"name": "bh", "type": "Blackhole"}], "body": "                                                                        {\n        search(smallStarTreeM128, bh);\n    }", "signature": "@Benchmark\n    public void rStarTreeSearchOf1000PointsMaxChildren128(Blackhole bh)"}, {"syntax_pass": true, "original_string": "    @Benchmark\n    public void rStarTreeDeleteOneEveryOccurrenceFromGreekDataChildren010() {\n        deleteAll(starTreeM10);\n    }", "docstring": "", "attributes": {"modifiers": "@Benchmark\n    public", "marker_annotations": ["@Benchmark"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "rStarTreeDeleteOneEveryOccurrenceFromGreekDataChildren010", "params": [], "body": "                                                                            {\n        deleteAll(starTreeM10);\n    }", "signature": "@Benchmark\n    public void rStarTreeDeleteOneEveryOccurrenceFromGreekDataChildren010()"}, {"syntax_pass": true, "original_string": "    @Benchmark\n    public void searchNearestGreek(Blackhole bh) {\n        searchNearestGreek(starTreeM4, bh);\n    }", "docstring": "", "attributes": {"modifiers": "@Benchmark\n    public", "marker_annotations": ["@Benchmark"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "searchNearestGreek", "params": [{"name": "bh", "type": "Blackhole"}], "body": "                                                 {\n        searchNearestGreek(starTreeM4, bh);\n    }", "signature": "@Benchmark\n    public void searchNearestGreek(Blackhole bh)"}, {"syntax_pass": true, "original_string": "    private RTree<Object, Point> deleteAll(RTree<Object, Point> tree) {\n        return tree.delete(entries.get(1000), true);\n    }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "RTree<Object, Point>", "classes": []}, "name": "deleteAll", "params": [{"name": "tree", "type": "RTree<Object, Point>"}], "body": "                                                                      {\n        return tree.delete(entries.get(1000), true);\n    }", "signature": "private RTree<Object, Point> deleteAll(RTree<Object, Point> tree)"}, {"syntax_pass": true, "original_string": "    private void search(RTree<Object, Rectangle> tree, Blackhole bh) {\n        // returns 10 results\n        tree.search(Geometries.rectangle(500, 500, 630, 630)).subscribe(consumeWith(bh));\n    }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "name": "search", "params": [{"name": "tree", "type": "RTree<Object, Rectangle>"}, {"name": "bh", "type": "Blackhole"}], "body": "                                                                     {\n        // returns 10 results\n        tree.search(Geometries.rectangle(500, 500, 630, 630)).subscribe(consumeWith(bh));\n    }", "signature": "private void search(RTree<Object, Rectangle> tree, Blackhole bh)"}, {"syntax_pass": true, "original_string": "    private void searchGreek(RTree<Object, Point> tree, Blackhole bh) {\n        // should return 22 results\n        tree.search(Geometries.rectangle(40, 27.0, 40.5, 27.5)).subscribe(consumeWith(bh));\n    }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "name": "searchGreek", "params": [{"name": "tree", "type": "RTree<Object, Point>"}, {"name": "bh", "type": "Blackhole"}], "body": "                                                                      {\n        // should return 22 results\n        tree.search(Geometries.rectangle(40, 27.0, 40.5, 27.5)).subscribe(consumeWith(bh));\n    }", "signature": "private void searchGreek(RTree<Object, Point> tree, Blackhole bh)"}, {"syntax_pass": true, "original_string": "    private Action1<Object> consumeWith(final Blackhole bh) {\n        return new Action1<Object>() {\n\n            @Override\n            public void call(Object t) {\n                bh.consume(t);\n            }\n        };\n    }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "Action1<Object>", "classes": []}, "name": "consumeWith", "params": [{"name": "bh", "type": "Blackhole"}], "body": "                                                            {\n        return new Action1<Object>() {\n\n            @Override\n            public void call(Object t) {\n                bh.consume(t);\n            }\n        };\n    }", "signature": "private Action1<Object> consumeWith(final Blackhole bh)"}, {"syntax_pass": true, "original_string": "    private void searchGreekBackpressure(RTree<Object, Point> tree, Blackhole bh) {\n        // should return 22 results\n        final Rectangle r = searchRectangle();\n        tree.search(r).take(1000).subscribe(consumeWith(bh));\n    }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "name": "searchGreekBackpressure", "params": [{"name": "tree", "type": "RTree<Object, Point>"}, {"name": "bh", "type": "Blackhole"}], "body": "                                                                                  {\n        // should return 22 results\n        final Rectangle r = searchRectangle();\n        tree.search(r).take(1000).subscribe(consumeWith(bh));\n    }", "signature": "private void searchGreekBackpressure(RTree<Object, Point> tree, Blackhole bh)"}, {"syntax_pass": true, "original_string": "    private static Rectangle searchRectangle() {\n        final Rectangle r;\n        if (precision == Precision.DOUBLE) {\n            r = Geometries.rectangle(40, 27.0, 40.5, 27.5);\n        } else {\n            r = Geometries.rectangle(40f, 27.0f, 40.5f, 27.5f);\n        }\n        return r;\n    }", "docstring": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "Rectangle", "classes": []}, "name": "searchRectangle", "params": [], "body": "                                               {\n        final Rectangle r;\n        if (precision == Precision.DOUBLE) {\n            r = Geometries.rectangle(40, 27.0, 40.5, 27.5);\n        } else {\n            r = Geometries.rectangle(40f, 27.0f, 40.5f, 27.5f);\n        }\n        return r;\n    }", "signature": "private static Rectangle searchRectangle()"}, {"syntax_pass": true, "original_string": "    private void searchNearestGreek(RTree<Object, Point> tree, Blackhole bh) {\n        final Point p;\n        if (precision == Precision.DOUBLE) {\n            p = Geometries.point(40.0, 27.0);\n        } else {\n            p = Geometries.point(40.0f, 27.0f);\n        }\n        tree.nearest(p, 1, 300).subscribe(consumeWith(bh));\n    }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "name": "searchNearestGreek", "params": [{"name": "tree", "type": "RTree<Object, Point>"}, {"name": "bh", "type": "Blackhole"}], "body": "                                                                             {\n        final Point p;\n        if (precision == Precision.DOUBLE) {\n            p = Geometries.point(40.0, 27.0);\n        } else {\n            p = Geometries.point(40.0f, 27.0f);\n        }\n        tree.nearest(p, 1, 300).subscribe(consumeWith(bh));\n    }", "signature": "private void searchNearestGreek(RTree<Object, Point> tree, Blackhole bh)"}, {"syntax_pass": true, "original_string": "    private void searchGreekWithBackpressure(RTree<Object, Point> tree, final Blackhole bh) {\n        // should return 22 results\n        tree.search(searchRectangle()).subscribe(new Subscriber<Object>() {\n\n            @Override\n            public void onStart() {\n                request(1);\n            }\n\n            @Override\n            public void onCompleted() {\n\n            }\n\n            @Override\n            public void onError(Throwable arg0) {\n\n            }\n\n            @Override\n            public void onNext(Object t) {\n                request(1);\n                bh.consume(t);\n            }\n        });\n    }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "name": "searchGreekWithBackpressure", "params": [{"name": "tree", "type": "RTree<Object, Point>"}, {"name": "bh", "type": "Blackhole"}], "body": "                                                                                            {\n        // should return 22 results\n        tree.search(searchRectangle()).subscribe(new Subscriber<Object>() {\n\n            @Override\n            public void onStart() {\n                request(1);\n            }\n\n            @Override\n            public void onCompleted() {\n\n            }\n\n            @Override\n            public void onError(Throwable arg0) {\n\n            }\n\n            @Override\n            public void onNext(Object t) {\n                request(1);\n                bh.consume(t);\n            }\n        });\n    }", "signature": "private void searchGreekWithBackpressure(RTree<Object, Point> tree, final Blackhole bh)"}, {"syntax_pass": true, "original_string": "    private RTree<Object, Rectangle> insertRectangle(RTree<Object, Rectangle> tree) {\n        return tree.add(new Object(), RTreeTest.random(precision));\n    }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "RTree<Object, Rectangle>", "classes": []}, "name": "insertRectangle", "params": [{"name": "tree", "type": "RTree<Object, Rectangle>"}], "body": "                                                                                    {\n        return tree.add(new Object(), RTreeTest.random(precision));\n    }", "signature": "private RTree<Object, Rectangle> insertRectangle(RTree<Object, Rectangle> tree)"}, {"syntax_pass": true, "original_string": "    private RTree<Object, Point> insertPoint(RTree<Object, Point> tree) {\n        if (precision == Precision.DOUBLE) {\n            return tree.add(new Object(),\n                    Geometries.point(Math.random() * 1000, Math.random() * 1000));\n        } else {\n            return tree.add(new Object(),\n                    Geometries.point((float) Math.random() * 1000, (float) Math.random() * 1000));\n        }\n    }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "RTree<Object, Point>", "classes": []}, "name": "insertPoint", "params": [{"name": "tree", "type": "RTree<Object, Point>"}], "body": "                                                                        {\n        if (precision == Precision.DOUBLE) {\n            return tree.add(new Object(),\n                    Geometries.point(Math.random() * 1000, Math.random() * 1000));\n        } else {\n            return tree.add(new Object(),\n                    Geometries.point((float) Math.random() * 1000, (float) Math.random() * 1000));\n        }\n    }", "signature": "private RTree<Object, Point> insertPoint(RTree<Object, Point> tree)"}, {"syntax_pass": true, "original_string": "    public static void main(String[] args) {\n        BenchmarksRTree b = new BenchmarksRTree();\n        System.out.println(\"starting searches\");\n        while (true)\n            b.starTreeM4.search(searchRectangle()).subscribe();\n    }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "void", "classes": []}, "name": "main", "params": [{"name": "args", "type": "String[]"}], "body": "                                           {\n        BenchmarksRTree b = new BenchmarksRTree();\n        System.out.println(\"starting searches\");\n        while (true)\n            b.starTreeM4.search(searchRectangle()).subscribe();\n    }", "signature": "public static void main(String[] args)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/com/github/davidmoten/rtree/RTreeTest.java", "original_string": "package com.github.davidmoten.rtree;\n\nimport static com.github.davidmoten.rtree.Entries.entry;\nimport static com.github.davidmoten.rtree.geometry.Geometries.circle;\nimport static com.github.davidmoten.rtree.geometry.Geometries.line;\nimport static com.github.davidmoten.rtree.geometry.Geometries.point;\nimport static com.github.davidmoten.rtree.geometry.Geometries.rectangle;\nimport static com.github.davidmoten.rtree.geometry.Intersects.pointIntersectsCircle;\nimport static com.github.davidmoten.rtree.geometry.Intersects.rectangleIntersectsCircle;\nimport static java.util.Arrays.asList;\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertFalse;\nimport static org.junit.Assert.assertNotNull;\nimport static org.junit.Assert.assertTrue;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.RandomAccessFile;\nimport java.nio.channels.FileLock;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Optional;\nimport java.util.Set;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.concurrent.atomic.AtomicInteger;\n\nimport org.junit.Test;\n\nimport com.github.davidmoten.guavamini.Lists;\nimport com.github.davidmoten.guavamini.Sets;\nimport com.github.davidmoten.rtree.fbs.FactoryFlatBuffers;\nimport com.github.davidmoten.rtree.geometry.Circle;\nimport com.github.davidmoten.rtree.geometry.Geometries;\nimport com.github.davidmoten.rtree.geometry.Geometry;\nimport com.github.davidmoten.rtree.geometry.HasGeometry;\nimport com.github.davidmoten.rtree.geometry.Intersects;\nimport com.github.davidmoten.rtree.geometry.Point;\nimport com.github.davidmoten.rtree.geometry.Rectangle;\nimport com.github.davidmoten.rtree.internal.EntryDefault;\nimport com.github.davidmoten.rtree.internal.Functions;\n\nimport rx.Observable;\nimport rx.Subscriber;\nimport rx.functions.Action1;\nimport rx.functions.Func1;\nimport rx.functions.Func2;\nimport rx.observables.GroupedObservable;\n\npublic class RTreeTest {\n\n    private static final double PRECISION = 0.000001;\n\n    @Test\n    public void testInstantiation() {\n        RTree<Object, Geometry> tree = RTree.create();\n        assertTrue(tree.entries().isEmpty().toBlocking().single());\n    }\n\n    @Test\n    public void testSearchEmptyTree() {\n        RTree<Object, Geometry> tree = RTree.create();\n        assertTrue(tree.search(r(1)).isEmpty().toBlocking().single());\n    }\n\n    @Test\n    public void testSearchOnOneItem() {\n        RTree<Object, Rectangle> tree = RTree.create();\n        Entry<Object, Rectangle> entry = e(1);\n        tree = tree.add(entry);\n        assertEquals(Arrays.asList(entry), tree.search(r(1)).toList().toBlocking().single());\n    }\n\n    @Test\n    public void testTreeWithOneItemIsNotEmpty() {\n        RTree<Object, Geometry> tree = RTree.create().add(e(1));\n        assertFalse(tree.isEmpty());\n    }\n\n    // @Test(expected = IOException.class)\n    public void testSaveFileException() throws IOException {\n        FileLock lock = null;\n        RandomAccessFile file = null;\n        try {\n            String filename = \"target/locked.png\";\n            File f = new File(filename);\n            f.createNewFile();\n            file = new RandomAccessFile(f, \"rw\");\n            lock = file.getChannel().lock();\n            RTree.create().visualize(600, 600).save(filename, \"PNG\");\n        } finally {\n            try {\n                lock.release();\n                file.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    @Test\n    public void testVisualizerWithEmptyTree() {\n        RTree<Object, Geometry> tree = RTree.create();\n        tree.visualize(600, 600).save(\"target/tree.png\", \"PNG\");\n    }\n\n    @Test\n    public void testBulkLoadingEmpty() {\n        RTree<Object, Point> tree = RTree.create(new ArrayList<Entry<Object, Point>>());\n        assertTrue(tree.entries().isEmpty().toBlocking().single());\n    }\n\n    @Test\n    public void testBulkLoadingWithOneItemIsNotEmpty() {\n        RTree<Object, Rectangle> tree = RTree.create(Arrays.asList(e(1)));\n        assertFalse(tree.isEmpty());\n    }\n\n    @Test\n    public void testBulkLoadingEntryCount() {\n        List<Entry<Integer, Geometry>> entries = new ArrayList<Entry<Integer, Geometry>>(10000);\n        for (int i = 1; i <= 10000; i++) {\n            Point point = nextPoint();\n            // System.out.println(\"point(\" + point.x() + \",\" + point.y() +\n            // \"),\");\n            entries.add(new EntryDefault<Integer, Geometry>(i, point));\n        }\n        RTree<Integer, Geometry> tree = RTree.create(entries);\n        int entrySize = tree.entries().count().toBlocking().single();\n        System.out.println(\"entry count: \" + entrySize);\n        assertEquals(entrySize, entries.size());\n    }\n\n    @Test\n    public void testSearchOnOneItemOnBulkLoadingRTree() {\n        Entry<Object, Rectangle> entry = e(1);\n        RTree<Object, Rectangle> tree = RTree.create(Arrays.asList(entry));\n        assertEquals(Arrays.asList(entry), tree.search(r(1)).toList().toBlocking().single());\n    }\n\n    @Test\n    public void testAddObservable() {\n        Entry<Object, Rectangle> e1 = e(1);\n        Entry<Object, Rectangle> e2 = e2(1);\n\n        RTree<Object, Rectangle> tree = RTree.maxChildren(4).<Object, Rectangle>create().add(e1)\n                .add(e2).delete(e1);\n        RTree<Object, Rectangle> emptyTree = RTree.maxChildren(4).create();\n        rx.Observable<?> deletedtree = emptyTree.add(tree.entries());\n        assertEquals(2, (int) deletedtree.count().toBlocking().single());\n    }\n\n    @Test\n    public void testPerformanceAndEntriesCount() {\n\n        long repeats = Long.parseLong(System.getProperty(\"r\", \"1\"));\n        long n = Long.parseLong(System.getProperty(\"n\", \"10000\"));\n        RTree<Object, Geometry> tree = null;\n        while (--repeats >= 0) {\n            long t = System.currentTimeMillis();\n            tree = createRandomRTree(n);\n            long diff = System.currentTimeMillis() - t;\n            System.out.println(\"inserts/second = \" + ((double) n / diff * 1000));\n        }\n        assertEquals(n, (int) tree.entries().count().toBlocking().single());\n\n        long t = System.currentTimeMillis();\n        Entry<Object, Geometry> entry = tree.search(rectangle(0, 0, 500, 500)).first().toBlocking()\n                .single();\n        long diff = System.currentTimeMillis() - t;\n        System.out.println(\"found \" + entry);\n        System.out.println(\"time to get nearest with \" + n + \" entries=\" + diff);\n\n    }\n\n    @Test\n    public void testSearchOfPoint() {\n        Object value = new Object();\n        RTree<Object, Geometry> tree = RTree.create().add(value, point(1, 1));\n        List<Entry<Object, Geometry>> list = tree.search(point(1, 1)).toList().toBlocking()\n                .single();\n        assertEquals(1, list.size());\n        assertEquals(value, list.get(0).value());\n    }\n\n    @Test\n    public void testSearchOfPointWithinDistance() {\n        Object value = new Object();\n        RTree<Object, Geometry> tree = RTree.create().add(value, point(1, 1));\n        List<Entry<Object, Geometry>> list = tree.search(point(1, 1), 2).toList().toBlocking()\n                .single();\n        assertEquals(1, list.size());\n        assertEquals(value, list.get(0).value());\n    }\n\n    static List<Entry<Object, Geometry>> createRandomEntries(long n) {\n        List<Entry<Object, Geometry>> list = new ArrayList<Entry<Object, Geometry>>();\n        for (long i = 0; i < n; i++)\n            list.add(randomEntry());\n        return list;\n    }\n\n    static RTree<Object, Geometry> createRandomRTree(long n) {\n        RTree<Object, Geometry> tree = RTree.maxChildren(4).create();\n        for (long i = 0; i < n; i++) {\n            Entry<Object, Geometry> entry = randomEntry();\n            tree = tree.add(entry);\n        }\n        return tree;\n    }\n\n    static Entry<Object, Geometry> randomEntry() {\n        return entry(new Object(), (Geometry) random(Precision.SINGLE));\n    }\n\n    @Test\n    public void testDeleteWithGeometry() {\n        RTree<Object, Rectangle> tree = RTree.maxChildren(4).create();\n        Entry<Object, Rectangle> entry = e(1);\n        Entry<Object, Rectangle> entry2 = e2(1);\n        tree = tree.add(entry).add(entry2);\n\n        tree = tree.delete(entry.value(), entry.geometry(), true);\n        List<Entry<Object, Rectangle>> entries = tree.entries().toList().toBlocking().single();\n        assertTrue(entries.contains(entry2) && !entries.contains(entry));\n    }\n    \n    @Test\n    public void testDeleteIssue81() {\n        RTree<Object, Point> t = RTree.create();\n        t = t.add(1, Geometries.pointGeographic(123, 23));\n        t = t.delete(1, Geometries.pointGeographic(123, 23));\n        assertEquals(0, t.size());\n    }\n\n    @Test\n    public void testDepthWith0() {\n        RTree<Object, Geometry> tree = RTree.create();\n        tree = tree.add(createRandomEntries(5));\n        List<Entry<Object, Geometry>> entries = tree.entries().toList().toBlocking().single();\n        RTree<Object, Geometry> deletedTree = tree.delete(entries, true);\n        assertTrue(deletedTree.isEmpty());\n    }\n\n    @Test\n    public void testContext() {\n        RTree<Object, Geometry> tree = RTree.create();\n        assertNotNull(tree.context());\n    }\n\n    @Test\n    public void testIterableDeletion() {\n        RTree<Object, Rectangle> tree = RTree.create();\n        Entry<Object, Rectangle> entry1 = e(1);\n        Entry<Object, Rectangle> entry2 = e(2);\n        Entry<Object, Rectangle> entry3 = e(3);\n        tree = tree.add(entry1).add(entry2).add(entry3);\n\n        List<Entry<Object, Rectangle>> list = new ArrayList<Entry<Object, Rectangle>>();\n        list.add(entry1);\n        list.add(entry3);\n        RTree<Object, Rectangle> deletedTree = tree.delete(list);\n        List<Entry<Object, Rectangle>> entries = deletedTree.entries().toList().toBlocking()\n                .single();\n        assertTrue(\n                entries.contains(entry2) && !entries.contains(entry1) && !entries.contains(entry3));\n    }\n\n    @Test\n    public void testObservableDeletion() {\n        RTree<Object, Rectangle> tree = RTree.create();\n        Entry<Object, Rectangle> entry1 = e(1);\n        Entry<Object, Rectangle> entry2 = e(3);\n        Entry<Object, Rectangle> entry3 = e(5);\n        tree = tree.add(entry1).add(entry2).add(entry3);\n        rx.Observable<Entry<Object, Rectangle>> obs = tree.search(r(2), 5);\n        rx.Observable<RTree<Object, Rectangle>> deleted = tree.delete(obs, true);\n        assertTrue(deleted.elementAt(deleted.count().toBlocking().single() - 1).count().toBlocking()\n                .single() == 1);\n    }\n\n    @Test\n    public void testFullDeletion() {\n        RTree<Object, Rectangle> tree = RTree.maxChildren(4).create();\n        Entry<Object, Rectangle> entry = e(1);\n        tree = tree.add(entry).add(entry);\n        tree = tree.delete(entry, true);\n        assertTrue(tree.isEmpty());\n    }\n\n    @Test\n    public void testPartialDeletion() {\n        RTree<Object, Rectangle> tree = RTree.maxChildren(4).create();\n        Entry<Object, Rectangle> entry = e(1);\n        tree = tree.add(entry).add(entry);\n        tree = tree.delete(entry, false);\n        List<Entry<Object, Rectangle>> entries = tree.entries().toList().toBlocking().single();\n        int countEntries = tree.entries().count().toBlocking().single();\n        assertTrue(countEntries == 1);\n        assertTrue(entries.get(0).equals(entry));\n    }\n\n    @Test\n    public void testDepthWithMaxChildren3Entries1() {\n        RTree<Object, Rectangle> tree = create(3, 1);\n        assertEquals(1, tree.calculateDepth());\n    }\n\n    @Test\n    public void testDepthWithMaxChildren3Entries2() {\n        RTree<Object, Rectangle> tree = create(3, 2);\n        assertEquals(1, tree.calculateDepth());\n    }\n\n    @Test\n    public void testDepthWithMaxChildren3Entries3() {\n        RTree<Object, Rectangle> tree = create(3, 3);\n        assertEquals(1, tree.calculateDepth());\n    }\n\n    @Test\n    public void testDepthWithMaxChildren3Entries4() {\n        RTree<Object, Rectangle> tree = create(3, 4);\n        assertEquals(2, tree.calculateDepth());\n    }\n\n    @Test\n    public void testDepthWithMaxChildren3Entries8() {\n        RTree<Object, Rectangle> tree = create(3, 8);\n        tree.visualize(800, 800).save(new File(\"target/treeLittle.png\"), \"PNG\");\n        assertEquals(3, tree.calculateDepth());\n    }\n\n    @Test\n    public void testDepthWithMaxChildren3Entries10() {\n        RTree<Object, Rectangle> tree = create(3, 10);\n        assertEquals(3, tree.calculateDepth());\n    }\n\n    @Test\n    public void testSizeIsZeroIfTreeEmpty() {\n        assertEquals(0, create(3, 0).size());\n    }\n\n    @Test\n    public void testSizeIsOneIfTreeHasOneEntry() {\n        assertEquals(1, create(3, 1).size());\n    }\n\n    @Test\n    public void testSizeIsFiveIfTreeHasFiveEntries() {\n        assertEquals(5, create(3, 5).size());\n    }\n\n    @Test\n    public void testSizeAfterDelete() {\n        Entry<Object, Rectangle> entry = e(1);\n        RTree<Object, Rectangle> tree = create(3, 0).add(entry).add(entry).add(entry).delete(entry);\n        assertEquals(2, tree.size());\n\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @Test\n    public void testDeletionThatRemovesAllNodesChildren() {\n        RTree<Object, Rectangle> tree = create(3, 8);\n        tree = tree.add(e(10));\n        // node children are now 1,2 and 3,4\n        assertEquals(3, tree.calculateDepth());\n        tree = tree.delete(e(10));\n        // node children are now 1,2 and 3\n        assertEquals(3, tree.calculateDepth());\n        assertEquals(Sets.newHashSet(e(1), e(2), e(3), e(4), e(5), e(6), e(7), e(8)),\n                Sets.newHashSet(tree.entries().toList().toBlocking().single()));\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @Test\n    public void testDeleteOfEntryThatDoesNotExistFromTreeOfOneEntry() {\n        RTree<Object, Geometry> tree = RTree.create().add(e(1));\n        tree = tree.delete(e(2));\n        assertEquals(Lists.newArrayList(e(1)), tree.entries().toList().toBlocking().single());\n    }\n\n    @Test\n    public void testDeleteFromEmptyTree() {\n        RTree<Object, Geometry> tree = RTree.create();\n        tree = tree.delete(e(2));\n        assertEquals(0, (int) tree.entries().count().toBlocking().single());\n    }\n\n    @Test\n    public void testBuilder1() {\n        RTree<Object, Point> tree = RTree.minChildren(1).maxChildren(4)\n                .selector(new SelectorMinimalAreaIncrease()).splitter(new SplitterQuadratic())\n                .create();\n        testBuiltTree(tree);\n    }\n\n    @Test\n    public void testDeletionOfEntryThatDoesNotExistFromNonLeaf() {\n        RTree<Object, Rectangle> tree = create(3, 100).delete(e(1000));\n        assertEquals(100, (int) tree.entries().count().toBlocking().single());\n    }\n\n    @Test\n    public void testBuilder2() {\n        RTree<Object, Point> tree = RTree.selector(new SelectorMinimalAreaIncrease()).minChildren(1)\n                .maxChildren(4).splitter(new SplitterQuadratic()).create();\n        testBuiltTree(tree);\n    }\n\n    @Test\n    public void testBuilder3() {\n        RTree<Object, Point> tree = RTree.maxChildren(4).selector(new SelectorMinimalAreaIncrease())\n                .minChildren(1).splitter(new SplitterQuadratic()).create();\n        testBuiltTree(tree);\n    }\n\n    @Test\n    public void testBuilder4() {\n        RTree<Object, Point> tree = RTree.splitter(new SplitterQuadratic()).maxChildren(4)\n                .selector(new SelectorMinimalAreaIncrease()).minChildren(1).create();\n        testBuiltTree(tree);\n    }\n\n    @Test\n    public void testBackpressureIterationForUpTo1000Entries() {\n        List<Entry<Object, Rectangle>> entries = Utilities.entries1000(Precision.SINGLE);\n        RTree<Object, Rectangle> tree = RTree.star().create();\n        for (int i = 1; i <= 1000; i++) {\n            tree = tree.add(entries.get(i - 1));\n            final HashSet<Entry<Object, Rectangle>> set = new HashSet<Entry<Object, Rectangle>>();\n            tree.entries().subscribe(createBackpressureSubscriber(set));\n            assertEquals(new HashSet<Entry<Object, Rectangle>>(entries.subList(0, i)), set);\n        }\n    }\n\n    private static <T extends Geometry> Subscriber<Entry<Object, T>> createBackpressureSubscriber(\n            final Collection<Entry<Object, T>> collection) {\n        return new Subscriber<Entry<Object, T>>() {\n\n            @Override\n            public void onStart() {\n                request(1);\n            }\n\n            @Override\n            public void onCompleted() {\n            }\n\n            @Override\n            public void onError(Throwable e) {\n            }\n\n            @Override\n            public void onNext(Entry<Object, T> t) {\n                collection.add(t);\n                request(1);\n            }\n        };\n    }\n\n    private void testBuiltTree(RTree<Object, Point> tree) {\n        for (int i = 1; i <= 1000; i++) {\n            tree = tree.add(i, Geometries.point(i, i));\n        }\n        assertEquals(1000, (int) tree.entries().count().toBlocking().single());\n    }\n\n    private static RTree<Object, Rectangle> create(int maxChildren, int n) {\n        RTree<Object, Rectangle> tree = RTree.maxChildren(maxChildren).create();\n        for (int i = 1; i <= n; i++)\n            tree = tree.add(e(i));\n        return tree;\n    }\n\n    @Test\n    public void testNearestSameDirection() {\n        RTree<Object, Rectangle> tree = RTree.maxChildren(4).<Object, Rectangle>create().add(e(1))\n                .add(e(2)).add(e(3)).add(e(10)).add(e(11));\n        List<Entry<Object, Rectangle>> list = tree.nearest(r(9), 10, 2).toList().toBlocking()\n                .single();\n        assertEquals(2, list.size());\n        System.out.println(list);\n        assertEquals(10, list.get(0).geometry().mbr().x1(), PRECISION);\n        assertEquals(11, list.get(1).geometry().mbr().x1(), PRECISION);\n\n        List<Entry<Object, Rectangle>> list2 = tree.nearest(r(10), 8, 3).toList().toBlocking()\n                .single();\n        assertEquals(2, list2.size());\n        assertEquals(10, list2.get(1).geometry().mbr().x1(), PRECISION);\n        assertEquals(11, list2.get(0).geometry().mbr().x1(), PRECISION);\n    }\n\n    @Test\n    public void testNearestDifferentDirections() {\n        RTree<Object, Geometry> tree = RTree.maxChildren(4).create().add(e(1)).add(e(2)).add(e(3))\n                .add(e(9)).add(e(10));\n        List<Entry<Object, Geometry>> list = tree.nearest(r(6), 10, 2).toList().toBlocking()\n                .single();\n        assertEquals(2, list.size());\n        assertEquals(3, list.get(0).geometry().mbr().x1(), PRECISION);\n        assertEquals(9, list.get(1).geometry().mbr().x1(), PRECISION);\n    }\n\n    @Test\n    public void testNearestToAPoint() {\n        Object value = new Object();\n        RTree<Object, Geometry> tree = RTree.create().add(value, point(1, 1));\n        List<Entry<Object, Geometry>> list = tree.nearest(point(2, 2), 3, 2).toList().toBlocking()\n                .single();\n        assertEquals(1, list.size());\n        assertEquals(value, list.get(0).value());\n    }\n\n    @Test\n    public void testNearestReturnsInOrder() {\n        Object value = new Object();\n        RTree<Object, Geometry> tree = RTree.create().add(value, point(1, 1))\n                .add(value, point(2, 2)).add(value, point(3, 3)).add(value, point(4, 4));\n        List<Entry<Object, Geometry>> list = tree.nearest(point(0, 0), 10, 10).toList().toBlocking()\n                .single();\n        System.out.println(list);\n        assertEquals(4, list.size());\n        assertEquals(point(1, 1), list.get(0).geometry());\n        assertEquals(point(2, 2), list.get(1).geometry());\n        assertEquals(point(3, 3), list.get(2).geometry());\n        assertEquals(point(4, 4), list.get(3).geometry());\n    }\n\n    @Test\n    public void testNearestHonoursUnsubscribeJustBeforeCompletion() {\n        Object value = new Object();\n        RTree<Object, Geometry> tree = RTree.create().add(value, point(1, 1));\n        final AtomicBoolean completeCalled = new AtomicBoolean(false);\n        tree.nearest(point(0, 0), 10, 10).subscribe(new Subscriber<Object>() {\n\n            @Override\n            public void onCompleted() {\n                completeCalled.set(true);\n            }\n\n            @Override\n            public void onError(Throwable e) {\n\n            }\n\n            @Override\n            public void onNext(Object t) {\n                unsubscribe();\n            }\n        });\n        assertFalse(completeCalled.get());\n    }\n\n    @Test\n    public void testVisualizer() {\n        List<Entry<Object, Geometry>> entries = createRandomEntries(1000);\n        int maxChildren = 8;\n        RTree<Object, Geometry> tree = RTree.maxChildren(maxChildren).create().add(entries);\n        tree.visualize(600, 600).save(\"target/tree.png\");\n\n        RTree<Object, Geometry> tree2 = RTree.star().maxChildren(maxChildren).create().add(entries);\n        tree2.visualize(600, 600).save(\"target/tree2.png\");\n\n        RTree<Object, Geometry> tree3 = RTree.maxChildren(maxChildren).create(entries);\n        tree3.visualize(600, 600).save(\"target/tree3.png\");\n    }\n\n    @Test(expected = RuntimeException.class)\n    public void testSplitterRStarThrowsExceptionOnEmptyList() {\n        SplitterRStar spl = new SplitterRStar();\n        spl.split(Collections.<HasGeometry>emptyList(), 4);\n    }\n\n    @Test\n    public void testSearchOnGreekDataUsingFlatBuffersFactory() {\n\n    }\n\n    @Test\n    public void testVisualizerWithGreekData() {\n        List<Entry<Object, Point>> entries = GreekEarthquakes.entriesList(Precision.DOUBLE);\n        int maxChildren = 8;\n        RTree<Object, Point> tree = RTree.maxChildren(maxChildren)\n                .factory(new FactoryFlatBuffers<Object, Geometry>(new Func1<Object, byte[]>() {\n                    @Override\n                    public byte[] call(Object o) {\n                        return \"boo\".getBytes();\n                    }\n                }, new Func1<byte[], Object>() {\n                    @Override\n                    public Object call(byte[] t) {\n                        return new String(t);\n                    }\n                })).<Object, Point>create().add(entries);\n        tree.visualize(2000, 2000).save(\"target/greek.png\");\n\n        // do search\n        int found = tree.search(Geometries.rectangle(40, 27.0, 40.5, 27.5)).count().toBlocking()\n                .single();\n        System.out.println(\"found=\" + found);\n        assertEquals(22, found);\n\n        RTree<Object, Point> tree2 = RTree.maxChildren(maxChildren).star().<Object, Point>create()\n                .add(entries);\n        tree2.visualize(2000, 2000).save(\"target/greek2.png\");\n\n        RTree<Object, Point> tree3 = RTree.maxChildren(maxChildren).create(entries);\n        tree3.visualize(2000, 2000).save(\"target/greek3.png\");\n    }\n\n    @Test\n    public void testDeleteOneFromOne() {\n        Entry<Object, Rectangle> e1 = e(1);\n        RTree<Object, Rectangle> tree = RTree.maxChildren(4).<Object, Rectangle>create().add(e1)\n                .delete(e1);\n        assertEquals(0, (int) tree.entries().count().toBlocking().single());\n    }\n\n    @Test\n    public void testDeleteOneFromTreeWithDepthGreaterThanOne() {\n        Entry<Object, Rectangle> e1 = e(1);\n        RTree<Object, Rectangle> tree = RTree.maxChildren(4).<Object, Rectangle>create().add(e1)\n                .add(e(2)).add(e(3)).add(e(4)).add(e(5)).add(e(6)).add(e(7)).add(e(8)).add(e(9))\n                .add(e(10)).delete(e1);\n        assertEquals(9, (int) tree.entries().count().toBlocking().single());\n        assertFalse(tree.entries().contains(e1).toBlocking().single());\n    }\n\n    @Test\n    public void testDeleteOneFromLargeTreeThenDeleteAllAndEnsureEmpty() {\n        int n = 10000;\n        RTree<Object, Geometry> tree = createRandomRTree(n).add(e(1)).add(e(2)).delete(e(1));\n        assertEquals(n + 1, (int) tree.entries().count().toBlocking().single());\n        assertFalse(tree.entries().contains(e(1)).toBlocking().single());\n        assertTrue(tree.entries().contains(e(2)).toBlocking().single());\n        n++;\n        assertEquals(n, tree.size());\n\n        for (Entry<Object, Geometry> entry : tree.entries().toBlocking().toIterable()) {\n            tree = tree.delete(entry);\n            n--;\n            assertEquals(n, tree.size());\n        }\n        assertEquals(0, (int) tree.entries().count().toBlocking().single());\n        assertTrue(tree.isEmpty());\n    }\n\n    @Test\n    public void testDeleteOnlyDeleteOneIfThereAreMoreThanMaxChildren() {\n        Entry<Object, Rectangle> e1 = e(1);\n        int count = RTree.maxChildren(4).create().add(e1).add(e1).add(e1).add(e1).add(e1).delete(e1)\n                .search(e1.geometry().mbr()).count().toBlocking().single();\n        assertEquals(4, count);\n    }\n\n    @Test\n    public void testDeleteAllIfThereAreMoreThanMaxChildren() {\n        Entry<Object, Rectangle> e1 = e(1);\n        int count = RTree.maxChildren(4).create().add(e1).add(e1).add(e1).add(e1).add(e1)\n                .delete(e1, true).search(e1.geometry().mbr()).count().toBlocking().single();\n        assertEquals(0, count);\n    }\n\n    @Test\n    public void testDeleteItemThatIsNotPresentDoesNothing() {\n        Entry<Object, Rectangle> e1 = e(1);\n        Entry<Object, Rectangle> e2 = e(2);\n        RTree<Object, Rectangle> tree = RTree.<Object, Rectangle>create().add(e1);\n        assertTrue(tree == tree.delete(e2));\n    }\n\n    @Test\n    public void testExampleOnReadMe() {\n        RTree<String, Geometry> tree = RTree.maxChildren(5).create();\n        tree = tree.add(entry(\"DAVE\", point(10, 20))).add(entry(\"FRED\", point(12, 25)))\n                .add(entry(\"MARY\", point(97, 125)));\n    }\n\n    @Test(timeout = 2000)\n    public void testUnsubscribe() {\n        RTree<Object, Geometry> tree = createRandomRTree(1000);\n        assertEquals(0, (int) tree.entries().take(0).count().toBlocking().single());\n    }\n\n    @Test\n    public void testSearchConditionAlwaysFalse() {\n        @SuppressWarnings(\"unchecked\")\n        RTree<Object, Geometry> tree = (RTree<Object, Geometry>) (RTree<?, ?>) create(3, 3);\n        assertEquals(0, (int) tree.search(Functions.alwaysFalse()).count().toBlocking().single());\n    }\n\n    @Test\n    public void testAddOverload() {\n        @SuppressWarnings(\"unchecked\")\n        RTree<Object, Geometry> tree = (RTree<Object, Geometry>) (RTree<?, ?>) create(3, 0);\n        tree = tree.add(123, Geometries.point(1, 2));\n        assertEquals(1, (int) tree.entries().count().toBlocking().single());\n    }\n\n    @Test\n    public void testDeleteOverload() {\n        @SuppressWarnings(\"unchecked\")\n        RTree<Object, Geometry> tree = (RTree<Object, Geometry>) (RTree<?, ?>) create(3, 0);\n        tree = tree.add(123, Geometries.point(1, 2)).delete(123, Geometries.point(1, 2));\n        assertEquals(0, (int) tree.entries().count().toBlocking().single());\n    }\n\n    @Test\n    public void testStandardRTreeSearch() {\n        Rectangle r = rectangle(13.0, 23.0, 50.0, 80.0);\n        Point[] points = { point(59.0, 91.0), point(86.0, 14.0), point(36.0, 60.0),\n                point(57.0, 36.0), point(14.0, 37.0) };\n\n        RTree<Integer, Geometry> tree = RTree.create();\n        for (int i = 0; i < points.length; i++) {\n            Point point = points[i];\n            System.out.println(\"point(\" + point.x() + \",\" + point.y() + \"), value=\" + (i + 1));\n            tree = tree.add(i + 1, point);\n        }\n        System.out.println(tree.asString());\n        System.out.println(\"searching \" + r);\n        Set<Integer> set = new HashSet<Integer>(\n                tree.search(r).map(RTreeTest.<Integer>toValue()).toList().toBlocking().single());\n        assertEquals(new HashSet<Integer>(asList(3, 5)), set);\n    }\n\n    @Test\n    public void testStandardRTreeSearch2() {\n        Rectangle r = rectangle(10.0, 10.0, 50.0, 50.0);\n        Point[] points = { point(28.0, 19.0), point(29.0, 4.0), point(10.0, 63.0),\n                point(34.0, 85.0), point(62.0, 45.0) };\n\n        RTree<Integer, Geometry> tree = RTree.create();\n        for (int i = 0; i < points.length; i++) {\n            Point point = points[i];\n            System.out.println(\"point(\" + point.x() + \",\" + point.y() + \"), value=\" + (i + 1));\n            tree = tree.add(i + 1, point);\n        }\n        System.out.println(tree.asString());\n        System.out.println(\"searching \" + r);\n        Set<Integer> set = new HashSet<Integer>(\n                tree.search(r).map(RTreeTest.<Integer>toValue()).toList().toBlocking().single());\n        assertEquals(new HashSet<Integer>(asList(1)), set);\n    }\n\n    @Test\n    public void testBulkLoadingTreeAndStarTreeReturnsSameAsStandardRTree() {\n\n        RTree<Integer, Geometry> tree1 = RTree.create();\n        RTree<Integer, Geometry> tree2 = RTree.star().create();\n\n        Rectangle[] testRects = { rectangle(0, 0, 0, 0), rectangle(0, 0, 100, 100),\n                rectangle(0, 0, 10, 10), rectangle(0.12, 0.25, 50.356, 50.756),\n                rectangle(1, 0.252, 50, 69.23), rectangle(13.12, 23.123, 50.45, 80.9),\n                rectangle(10, 10, 50, 50) };\n\n        List<Entry<Integer, Geometry>> entries = new ArrayList<Entry<Integer, Geometry>>(10000);\n        for (int i = 1; i <= 10000; i++) {\n            Point point = nextPoint();\n            // System.out.println(\"point(\" + point.x() + \",\" + point.y() +\n            // \"),\");\n            tree1 = tree1.add(i, point);\n            tree2 = tree2.add(i, point);\n            entries.add(new EntryDefault<Integer, Geometry>(i, point));\n        }\n        RTree<Integer, Geometry> tree3 = RTree.create(entries);\n\n        // tree2.visualize(2000, 2000).save(\"target/tree22.png\");\n        // tree3.visualize(2000, 2000).save(\"target/tree33.png\");\n\n        for (Rectangle r : testRects) {\n            Set<Integer> res1 = new HashSet<Integer>(tree1.search(r)\n                    .map(RTreeTest.<Integer>toValue()).toList().toBlocking().single());\n            Set<Integer> res2 = new HashSet<Integer>(tree2.search(r)\n                    .map(RTreeTest.<Integer>toValue()).toList().toBlocking().single());\n            Set<Integer> res3 = new HashSet<Integer>(tree3.search(r)\n                    .map(RTreeTest.<Integer>toValue()).toList().toBlocking().single());\n            System.out.println(\"searchRect= rectangle(\" + r.x1() + \",\" + r.y1() + \",\" + r.x2() + \",\"\n                    + r.y2() + \")\");\n            System.out.println(\"res1.size=\" + res1.size() + \",res2.size=\" + res2.size()\n                    + \",res3.size=\" + res3.size());\n            // System.out.println(\"res1=\" + res1 + \",res2=\" + res2 + \",res3=\" + res3);\n            assertEquals(res1.size(), res2.size());\n            assertEquals(res1.size(), res3.size());\n        }\n    }\n\n    @Test\n    public void testUnsubscribeWhileIteratingLeafNode() {\n        RTree<Object, Rectangle> tree = RTree.maxChildren(5).<Object, Rectangle>create().add(e(1))\n                .add(e(2));\n        tree.entries().subscribe(new Subscriber<Object>() {\n\n            @Override\n            public void onCompleted() {\n\n            }\n\n            @Override\n            public void onError(Throwable e) {\n            }\n\n            @Override\n            public void onNext(Object t) {\n                unsubscribe();\n            }\n        });\n    }\n\n    @Test\n    public void testUnsubscribeWhileIteratingNonLeafNode() {\n        final AtomicBoolean completed = new AtomicBoolean(false);\n        RTree<Object, Rectangle> tree = RTree.maxChildren(3).<Object, Rectangle>create().add(e(1))\n                .add(e(2)).add(e(3)).add(e(4));\n        tree.entries().subscribe(new Subscriber<Object>() {\n\n            @Override\n            public void onCompleted() {\n                completed.set(true);\n            }\n\n            @Override\n            public void onError(Throwable e) {\n            }\n\n            @Override\n            public void onNext(Object t) {\n                unsubscribe();\n            }\n        });\n        assertFalse(completed.get());\n    }\n\n    @Test\n    public void testSearchWithIntersectsRectangleFunction() {\n        RTree<Integer, Rectangle> tree = RTree.create();\n        tree.search(circle(0, 0, 1), rectangleIntersectsCircle);\n    }\n\n    @Test\n    public void testSearchWithIntersectsPointFunctionReturnsOne() {\n        RTree<Integer, Point> tree = RTree.<Integer, Point>create().add(1, point(0, 0));\n        Observable<Entry<Integer, Point>> entries = tree.search(circle(0, 0, 1),\n                pointIntersectsCircle);\n        assertEquals(1, (int) entries.count().toBlocking().single());\n    }\n\n    @Test\n    public void testSearchWithIntersectsPointFunctionReturnsNone() {\n        RTree<Integer, Point> tree = RTree.<Integer, Point>create().add(1, point(10, 10));\n        Observable<Entry<Integer, Point>> entries = tree.search(circle(0, 0, 1),\n                pointIntersectsCircle);\n        assertEquals(0, (int) entries.count().toBlocking().single());\n    }\n\n    @Test\n    public void testSearchWithDistanceFunctionIntersectsMbrButNotActualGeometry() {\n        RTree<Integer, Point> tree = RTree.<Integer, Point>create().add(1, point(0, 0)).add(2,\n                point(1, 1));\n\n        Observable<Entry<Integer, Point>> entries = tree.search(circle(0, 0, 1), 0.1,\n                distanceCircleToPoint);\n        assertEquals(1, (int) entries.count().toBlocking().single());\n    }\n\n    @Test\n    public void testSearchWithDistanceFunctionIntersectsMbrAndActualGeometry() {\n        RTree<Integer, Point> tree = RTree.<Integer, Point>create().add(1, point(0, 0)).add(2,\n                point(1, 1));\n\n        Observable<Entry<Integer, Point>> entries = tree.search(circle(0, 0, 1), 0.5,\n                distanceCircleToPoint);\n        assertEquals(2, (int) entries.count().toBlocking().single());\n    }\n\n    @Test\n    public void testSearchWithDistanceFunctionIntersectsNothing() {\n        RTree<Integer, Point> tree = RTree.<Integer, Point>create().add(1, point(0, 0)).add(2,\n                point(1, 1));\n\n        Observable<Entry<Integer, Point>> entries = tree.search(circle(10, 10, 1), 0.5,\n                distanceCircleToPoint);\n        assertEquals(0, (int) entries.count().toBlocking().single());\n    }\n\n    @Test\n    public void calculateDepthOfEmptyTree() {\n        RTree<Object, Geometry> tree = RTree.create();\n        assertEquals(0, tree.calculateDepth());\n    }\n\n    @Test\n    public void calculateAsStringOfEmptyTree() {\n        RTree<Object, Geometry> tree = RTree.create();\n        assertEquals(\"\", tree.asString());\n    }\n\n    @Test\n    public void testForMeiZhao() {\n        for (int minChildren = 1; minChildren <= 2; minChildren++) {\n            RTree<Integer, Point> tree = RTree.maxChildren(3).minChildren(minChildren)\n                    .<Integer, Point>create().add(1, point(1, 9)).add(2, point(2, 10))\n                    .add(3, point(4, 8)).add(4, point(6, 7)).add(5, point(9, 10))\n                    .add(6, point(7, 5)).add(7, point(5, 6)).add(8, point(4, 3)).add(9, point(3, 2))\n                    .add(10, point(9, 1)).add(11, point(10, 4)).add(12, point(6, 2))\n                    .add(13, point(8, 3));\n            System.out.println(tree.asString());\n        }\n    }\n\n    @Test\n    public void testSearchWithCircleFindsCentreOnly() {\n        RTree<Integer, Point> tree = RTree.<Integer, Point>create().add(1, point(1, 1))\n                .add(2, point(2, 2)).add(3, point(3, 3));\n        List<Entry<Integer, Point>> list = tree.search(Geometries.circle(2, 2, 1)).toList()\n                .toBlocking().single();\n        assertEquals(1, list.size());\n        assertEquals(2, (int) list.get(0).value());\n    }\n\n    @Test\n    public void testSearchWithCircleFindsAll() {\n        RTree<Integer, Point> tree = RTree.<Integer, Point>create().add(1, point(1, 1))\n                .add(2, point(2, 2)).add(3, point(3, 3));\n        List<Entry<Integer, Point>> list = tree.search(Geometries.circle(2, 2, 1.5)).toList()\n                .toBlocking().single();\n        assertEquals(3, list.size());\n    }\n\n    @Test\n    public void testSearchWithLineFindsAll() {\n        RTree<Integer, Point> tree = RTree.<Integer, Point>create().add(1, point(1, 1))\n                .add(2, point(2, 2)).add(3, point(3, 3));\n        List<Entry<Integer, Point>> list = tree.search(Geometries.line(0, 0, 4, 4)).toList()\n                .toBlocking().single();\n        assertEquals(3, list.size());\n    }\n\n    @Test\n    public void testSearchWithLineFindsOne() {\n        RTree<Integer, Point> tree = RTree.<Integer, Point>create().add(1, point(1, 1))\n                .add(2, point(2, 2)).add(3, point(3, 3));\n        List<Entry<Integer, Point>> list = tree.search(Geometries.line(1.5, 1.5, 2.5, 2.5)).toList()\n                .toBlocking().single();\n        assertEquals(1, list.size());\n        assertEquals(2, (int) list.get(0).value());\n    }\n\n    @Test\n    public void testSearchWithLineFindsNone() {\n        RTree<Integer, Point> tree = RTree.<Integer, Point>create().add(1, point(1, 1))\n                .add(2, point(2, 2)).add(3, point(3, 3));\n        List<Entry<Integer, Point>> list = tree.search(Geometries.line(1.5, 1.5, 2.6, 2.5)).toList()\n                .toBlocking().single();\n        System.out.println(list);\n        assertEquals(0, list.size());\n    }\n\n    @Test\n    public void testRTreeRootMbrWhenRTreeEmpty() {\n        assertFalse(RTree.create().mbr().isPresent());\n    }\n\n    @Test\n    public void testRTreeRootMbrWhenRTreeNonEmpty() {\n        Optional<Rectangle> r = RTree.<Integer, Point>create().add(1, point(1, 1))\n                .add(2, point(2, 2)).mbr();\n        assertEquals(Geometries.rectangle(1, 1, 2, 2), r.get());\n    }\n\n    @Test\n    public void testIntersectsPointLine() {\n        assertTrue(Intersects.lineIntersectsPoint.call(line(1, 1, 2, 2), point(1, 1)));\n    }\n\n    @Test(timeout = 30000000)\n    public void testGroupByIssue40() {\n        RTree<Integer, Geometry> tree = RTree.star().create();\n\n        tree = tree.add(1, Geometries.point(13.0, 52.0));\n        tree = tree.add(2, Geometries.point(13.0, 52.0));\n        tree = tree.add(3, Geometries.point(13.0, 52.0));\n        tree = tree.add(4, Geometries.point(13.0, 52.0));\n        tree = tree.add(5, Geometries.point(13.0, 52.0));\n        tree = tree.add(6, Geometries.point(13.0, 52.0));\n\n        Rectangle rectangle = Geometries.rectangle(12.9, 51.9, 13.1, 52.1);\n        assertEquals(Integer.valueOf(2), tree.search(rectangle).doOnRequest(new Action1<Long>() {\n            @Override\n            public void call(Long n) {\n                System.out.println(\"requestFromGroupBy=\" + n);\n            }\n        }).groupBy(new Func1<Entry<Integer, Geometry>, Boolean>() {\n            @Override\n            public Boolean call(Entry<Integer, Geometry> entry) {\n                System.out.println(entry);\n                return entry.value() % 2 == 0;\n            }\n        }).doOnRequest(new Action1<Long>() {\n            @Override\n            public void call(Long n) {\n                System.out.println(\"requestFromFlatMap=\" + n);\n            }\n        }).flatMap(\n                new Func1<GroupedObservable<Boolean, Entry<Integer, Geometry>>, Observable<Integer>>() {\n                    @Override\n                    public Observable<Integer> call(\n                            GroupedObservable<Boolean, Entry<Integer, Geometry>> group) {\n                        return group.count();\n                    }\n                }).count().toBlocking().single());\n    }\n\n    @Test\n    public void testBackpressureForOverflow() {\n        RTree<Integer, Geometry> tree = RTree.star().create();\n\n        tree = tree.add(1, Geometries.point(13.0, 52.0));\n        tree = tree.add(2, Geometries.point(13.0, 52.0));\n        tree = tree.add(3, Geometries.point(13.0, 52.0));\n        tree = tree.add(4, Geometries.point(13.0, 52.0));\n        tree = tree.add(5, Geometries.point(13.0, 52.0));\n        tree = tree.add(6, Geometries.point(13.0, 52.0));\n        final AtomicInteger count = new AtomicInteger();\n        Rectangle rectangle = Geometries.rectangle(12.9, 51.9, 13.1, 52.1);\n        tree.search(rectangle).subscribe(new Subscriber<Object>() {\n\n            @Override\n            public void onStart() {\n                request(4);\n            }\n\n            @Override\n            public void onCompleted() {\n\n            }\n\n            @Override\n            public void onError(Throwable e) {\n\n            }\n\n            @Override\n            public void onNext(Object t) {\n                request(Long.MAX_VALUE);\n                count.incrementAndGet();\n            }\n        });\n        assertEquals(6, count.get());\n        assertEquals(6, (int) tree.search(rectangle).count().toBlocking().single());\n\n    }\n    \n    @Test\n    public void testDeleteIssue81d() {\n         RTree<Object, Point> t = RTree.create();\n         t = t.add(1, Geometries.pointGeographic(123.4d, 23.3d));\n         t = t.delete(1, Geometries.pointGeographic(123.4d, 23.3d));\n         assertEquals(0, t.size());\n     }\n    \n     @Test\n     public void testDeleteIssue81f() {\n         RTree<Object, Point> t = RTree.create();\n         t = t.add(1, Geometries.pointGeographic(123.4f, 23.3f));\n         t = t.delete(1, Geometries.pointGeographic(123.4f, 23.3f));\n         assertEquals(0, t.size());\n     }\n\n    private static Func2<Point, Circle, Double> distanceCircleToPoint = new Func2<Point, Circle, Double>() {\n        @Override\n        public Double call(Point point, Circle circle) {\n            return circle.distance(point.mbr());\n        }\n    };\n\n    private static <T> Func1<Entry<T, ?>, T> toValue() {\n        return new Func1<Entry<T, ?>, T>() {\n\n            @Override\n            public T call(Entry<T, ?> entry) {\n                return entry.value();\n            }\n        };\n    }\n\n    private static Point nextPoint() {\n\n        double randomX = Math.round(Math.random() * 100);\n\n        double randomY = Math.round(Math.random() * 100);\n\n        return Geometries.point(randomX, randomY);\n\n    }\n\n    static Entry<Object, Rectangle> e(int n) {\n        return Entries.<Object, Rectangle>entry(n, r(n));\n    }\n\n    static Entry<Object, Rectangle> e2(int n) {\n        return Entries.<Object, Rectangle>entry(n, r(n - 1));\n    }\n\n    private static Rectangle r(int n) {\n        return rectangle(n, n, n + 1, n + 1);\n    }\n\n    private static Rectangle r(double n, double m) {\n        return rectangle(n, m, n + 1, m + 1);\n    }\n\n    private static Rectangle r(float n, float m) {\n        return rectangle(n, m, n + 1, m + 1);\n    }\n\n    static Rectangle random(Precision precision) {\n        if (precision == Precision.SINGLE)\n            return r((float) Math.random() * 1000, (float) Math.random() * 1000);\n        else\n            return r(Math.random() * 1000, Math.random() * 1000);\n    }\n\n    @Test\n    public void testSearchGreekEarthquakesDouble() {\n        Observable<Entry<Object, Point>> entriesDouble = GreekEarthquakes.entries(Precision.DOUBLE);\n        RTree<Object, Point> t = RTree.maxChildren(4).<Object, Point>create().add(entriesDouble)\n                .last().toBlocking().single(); //\n        t.search(Geometries.rectangle(40, 27.0, 40.5, 27.5)) //\n                .test() //\n                .assertValueCount(22) //\n                .assertCompleted();\n    }\n    \n}\n", "file_hash": "f9f07f31ba21982f4e0dfcac7e302fca5a078514b482023b8d5cfc56ced10b4b", "file_docstring": "", "contexts": ["package com.github.davidmoten.rtree;", "import static com.github.davidmoten.rtree.Entries.entry;", "import static com.github.davidmoten.rtree.geometry.Geometries.circle;", "import static com.github.davidmoten.rtree.geometry.Geometries.line;", "import static com.github.davidmoten.rtree.geometry.Geometries.point;", "import static com.github.davidmoten.rtree.geometry.Geometries.rectangle;", "import static com.github.davidmoten.rtree.geometry.Intersects.pointIntersectsCircle;", "import static com.github.davidmoten.rtree.geometry.Intersects.rectangleIntersectsCircle;", "import static java.util.Arrays.asList;", "import static org.junit.Assert.assertEquals;", "import static org.junit.Assert.assertFalse;", "import static org.junit.Assert.assertNotNull;", "import static org.junit.Assert.assertTrue;", "import java.io.File;", "import java.io.IOException;", "import java.io.RandomAccessFile;", "import java.nio.channels.FileLock;", "import java.util.ArrayList;", "import java.util.Arrays;", "import java.util.Collection;", "import java.util.Collections;", "import java.util.HashSet;", "import java.util.List;", "import java.util.Optional;", "import java.util.Set;", "import java.util.concurrent.atomic.AtomicBoolean;", "import java.util.concurrent.atomic.AtomicInteger;", "import org.junit.Test;", "import com.github.davidmoten.guavamini.Lists;", "import com.github.davidmoten.guavamini.Sets;", "import com.github.davidmoten.rtree.fbs.FactoryFlatBuffers;", "import com.github.davidmoten.rtree.geometry.Circle;", "import com.github.davidmoten.rtree.geometry.Geometries;", "import com.github.davidmoten.rtree.geometry.Geometry;", "import com.github.davidmoten.rtree.geometry.HasGeometry;", "import com.github.davidmoten.rtree.geometry.Intersects;", "import com.github.davidmoten.rtree.geometry.Point;", "import com.github.davidmoten.rtree.geometry.Rectangle;", "import com.github.davidmoten.rtree.internal.EntryDefault;", "import com.github.davidmoten.rtree.internal.Functions;", "import rx.Observable;", "import rx.Subscriber;", "import rx.functions.Action1;", "import rx.functions.Func1;", "import rx.functions.Func2;", "import rx.observables.GroupedObservable;"], "methods": [], "classes": [{"original_string": "public class RTreeTest {\n\n    private static final double PRECISION = 0.000001;\n\n    @Test\n    public void testInstantiation() {\n        RTree<Object, Geometry> tree = RTree.create();\n        assertTrue(tree.entries().isEmpty().toBlocking().single());\n    }\n\n    @Test\n    public void testSearchEmptyTree() {\n        RTree<Object, Geometry> tree = RTree.create();\n        assertTrue(tree.search(r(1)).isEmpty().toBlocking().single());\n    }\n\n    @Test\n    public void testSearchOnOneItem() {\n        RTree<Object, Rectangle> tree = RTree.create();\n        Entry<Object, Rectangle> entry = e(1);\n        tree = tree.add(entry);\n        assertEquals(Arrays.asList(entry), tree.search(r(1)).toList().toBlocking().single());\n    }\n\n    @Test\n    public void testTreeWithOneItemIsNotEmpty() {\n        RTree<Object, Geometry> tree = RTree.create().add(e(1));\n        assertFalse(tree.isEmpty());\n    }\n\n    // @Test(expected = IOException.class)\n    public void testSaveFileException() throws IOException {\n        FileLock lock = null;\n        RandomAccessFile file = null;\n        try {\n            String filename = \"target/locked.png\";\n            File f = new File(filename);\n            f.createNewFile();\n            file = new RandomAccessFile(f, \"rw\");\n            lock = file.getChannel().lock();\n            RTree.create().visualize(600, 600).save(filename, \"PNG\");\n        } finally {\n            try {\n                lock.release();\n                file.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    @Test\n    public void testVisualizerWithEmptyTree() {\n        RTree<Object, Geometry> tree = RTree.create();\n        tree.visualize(600, 600).save(\"target/tree.png\", \"PNG\");\n    }\n\n    @Test\n    public void testBulkLoadingEmpty() {\n        RTree<Object, Point> tree = RTree.create(new ArrayList<Entry<Object, Point>>());\n        assertTrue(tree.entries().isEmpty().toBlocking().single());\n    }\n\n    @Test\n    public void testBulkLoadingWithOneItemIsNotEmpty() {\n        RTree<Object, Rectangle> tree = RTree.create(Arrays.asList(e(1)));\n        assertFalse(tree.isEmpty());\n    }\n\n    @Test\n    public void testBulkLoadingEntryCount() {\n        List<Entry<Integer, Geometry>> entries = new ArrayList<Entry<Integer, Geometry>>(10000);\n        for (int i = 1; i <= 10000; i++) {\n            Point point = nextPoint();\n            // System.out.println(\"point(\" + point.x() + \",\" + point.y() +\n            // \"),\");\n            entries.add(new EntryDefault<Integer, Geometry>(i, point));\n        }\n        RTree<Integer, Geometry> tree = RTree.create(entries);\n        int entrySize = tree.entries().count().toBlocking().single();\n        System.out.println(\"entry count: \" + entrySize);\n        assertEquals(entrySize, entries.size());\n    }\n\n    @Test\n    public void testSearchOnOneItemOnBulkLoadingRTree() {\n        Entry<Object, Rectangle> entry = e(1);\n        RTree<Object, Rectangle> tree = RTree.create(Arrays.asList(entry));\n        assertEquals(Arrays.asList(entry), tree.search(r(1)).toList().toBlocking().single());\n    }\n\n    @Test\n    public void testAddObservable() {\n        Entry<Object, Rectangle> e1 = e(1);\n        Entry<Object, Rectangle> e2 = e2(1);\n\n        RTree<Object, Rectangle> tree = RTree.maxChildren(4).<Object, Rectangle>create().add(e1)\n                .add(e2).delete(e1);\n        RTree<Object, Rectangle> emptyTree = RTree.maxChildren(4).create();\n        rx.Observable<?> deletedtree = emptyTree.add(tree.entries());\n        assertEquals(2, (int) deletedtree.count().toBlocking().single());\n    }\n\n    @Test\n    public void testPerformanceAndEntriesCount() {\n\n        long repeats = Long.parseLong(System.getProperty(\"r\", \"1\"));\n        long n = Long.parseLong(System.getProperty(\"n\", \"10000\"));\n        RTree<Object, Geometry> tree = null;\n        while (--repeats >= 0) {\n            long t = System.currentTimeMillis();\n            tree = createRandomRTree(n);\n            long diff = System.currentTimeMillis() - t;\n            System.out.println(\"inserts/second = \" + ((double) n / diff * 1000));\n        }\n        assertEquals(n, (int) tree.entries().count().toBlocking().single());\n\n        long t = System.currentTimeMillis();\n        Entry<Object, Geometry> entry = tree.search(rectangle(0, 0, 500, 500)).first().toBlocking()\n                .single();\n        long diff = System.currentTimeMillis() - t;\n        System.out.println(\"found \" + entry);\n        System.out.println(\"time to get nearest with \" + n + \" entries=\" + diff);\n\n    }\n\n    @Test\n    public void testSearchOfPoint() {\n        Object value = new Object();\n        RTree<Object, Geometry> tree = RTree.create().add(value, point(1, 1));\n        List<Entry<Object, Geometry>> list = tree.search(point(1, 1)).toList().toBlocking()\n                .single();\n        assertEquals(1, list.size());\n        assertEquals(value, list.get(0).value());\n    }\n\n    @Test\n    public void testSearchOfPointWithinDistance() {\n        Object value = new Object();\n        RTree<Object, Geometry> tree = RTree.create().add(value, point(1, 1));\n        List<Entry<Object, Geometry>> list = tree.search(point(1, 1), 2).toList().toBlocking()\n                .single();\n        assertEquals(1, list.size());\n        assertEquals(value, list.get(0).value());\n    }\n\n    static List<Entry<Object, Geometry>> createRandomEntries(long n) {\n        List<Entry<Object, Geometry>> list = new ArrayList<Entry<Object, Geometry>>();\n        for (long i = 0; i < n; i++)\n            list.add(randomEntry());\n        return list;\n    }\n\n    static RTree<Object, Geometry> createRandomRTree(long n) {\n        RTree<Object, Geometry> tree = RTree.maxChildren(4).create();\n        for (long i = 0; i < n; i++) {\n            Entry<Object, Geometry> entry = randomEntry();\n            tree = tree.add(entry);\n        }\n        return tree;\n    }\n\n    static Entry<Object, Geometry> randomEntry() {\n        return entry(new Object(), (Geometry) random(Precision.SINGLE));\n    }\n\n    @Test\n    public void testDeleteWithGeometry() {\n        RTree<Object, Rectangle> tree = RTree.maxChildren(4).create();\n        Entry<Object, Rectangle> entry = e(1);\n        Entry<Object, Rectangle> entry2 = e2(1);\n        tree = tree.add(entry).add(entry2);\n\n        tree = tree.delete(entry.value(), entry.geometry(), true);\n        List<Entry<Object, Rectangle>> entries = tree.entries().toList().toBlocking().single();\n        assertTrue(entries.contains(entry2) && !entries.contains(entry));\n    }\n    \n    @Test\n    public void testDeleteIssue81() {\n        RTree<Object, Point> t = RTree.create();\n        t = t.add(1, Geometries.pointGeographic(123, 23));\n        t = t.delete(1, Geometries.pointGeographic(123, 23));\n        assertEquals(0, t.size());\n    }\n\n    @Test\n    public void testDepthWith0() {\n        RTree<Object, Geometry> tree = RTree.create();\n        tree = tree.add(createRandomEntries(5));\n        List<Entry<Object, Geometry>> entries = tree.entries().toList().toBlocking().single();\n        RTree<Object, Geometry> deletedTree = tree.delete(entries, true);\n        assertTrue(deletedTree.isEmpty());\n    }\n\n    @Test\n    public void testContext() {\n        RTree<Object, Geometry> tree = RTree.create();\n        assertNotNull(tree.context());\n    }\n\n    @Test\n    public void testIterableDeletion() {\n        RTree<Object, Rectangle> tree = RTree.create();\n        Entry<Object, Rectangle> entry1 = e(1);\n        Entry<Object, Rectangle> entry2 = e(2);\n        Entry<Object, Rectangle> entry3 = e(3);\n        tree = tree.add(entry1).add(entry2).add(entry3);\n\n        List<Entry<Object, Rectangle>> list = new ArrayList<Entry<Object, Rectangle>>();\n        list.add(entry1);\n        list.add(entry3);\n        RTree<Object, Rectangle> deletedTree = tree.delete(list);\n        List<Entry<Object, Rectangle>> entries = deletedTree.entries().toList().toBlocking()\n                .single();\n        assertTrue(\n                entries.contains(entry2) && !entries.contains(entry1) && !entries.contains(entry3));\n    }\n\n    @Test\n    public void testObservableDeletion() {\n        RTree<Object, Rectangle> tree = RTree.create();\n        Entry<Object, Rectangle> entry1 = e(1);\n        Entry<Object, Rectangle> entry2 = e(3);\n        Entry<Object, Rectangle> entry3 = e(5);\n        tree = tree.add(entry1).add(entry2).add(entry3);\n        rx.Observable<Entry<Object, Rectangle>> obs = tree.search(r(2), 5);\n        rx.Observable<RTree<Object, Rectangle>> deleted = tree.delete(obs, true);\n        assertTrue(deleted.elementAt(deleted.count().toBlocking().single() - 1).count().toBlocking()\n                .single() == 1);\n    }\n\n    @Test\n    public void testFullDeletion() {\n        RTree<Object, Rectangle> tree = RTree.maxChildren(4).create();\n        Entry<Object, Rectangle> entry = e(1);\n        tree = tree.add(entry).add(entry);\n        tree = tree.delete(entry, true);\n        assertTrue(tree.isEmpty());\n    }\n\n    @Test\n    public void testPartialDeletion() {\n        RTree<Object, Rectangle> tree = RTree.maxChildren(4).create();\n        Entry<Object, Rectangle> entry = e(1);\n        tree = tree.add(entry).add(entry);\n        tree = tree.delete(entry, false);\n        List<Entry<Object, Rectangle>> entries = tree.entries().toList().toBlocking().single();\n        int countEntries = tree.entries().count().toBlocking().single();\n        assertTrue(countEntries == 1);\n        assertTrue(entries.get(0).equals(entry));\n    }\n\n    @Test\n    public void testDepthWithMaxChildren3Entries1() {\n        RTree<Object, Rectangle> tree = create(3, 1);\n        assertEquals(1, tree.calculateDepth());\n    }\n\n    @Test\n    public void testDepthWithMaxChildren3Entries2() {\n        RTree<Object, Rectangle> tree = create(3, 2);\n        assertEquals(1, tree.calculateDepth());\n    }\n\n    @Test\n    public void testDepthWithMaxChildren3Entries3() {\n        RTree<Object, Rectangle> tree = create(3, 3);\n        assertEquals(1, tree.calculateDepth());\n    }\n\n    @Test\n    public void testDepthWithMaxChildren3Entries4() {\n        RTree<Object, Rectangle> tree = create(3, 4);\n        assertEquals(2, tree.calculateDepth());\n    }\n\n    @Test\n    public void testDepthWithMaxChildren3Entries8() {\n        RTree<Object, Rectangle> tree = create(3, 8);\n        tree.visualize(800, 800).save(new File(\"target/treeLittle.png\"), \"PNG\");\n        assertEquals(3, tree.calculateDepth());\n    }\n\n    @Test\n    public void testDepthWithMaxChildren3Entries10() {\n        RTree<Object, Rectangle> tree = create(3, 10);\n        assertEquals(3, tree.calculateDepth());\n    }\n\n    @Test\n    public void testSizeIsZeroIfTreeEmpty() {\n        assertEquals(0, create(3, 0).size());\n    }\n\n    @Test\n    public void testSizeIsOneIfTreeHasOneEntry() {\n        assertEquals(1, create(3, 1).size());\n    }\n\n    @Test\n    public void testSizeIsFiveIfTreeHasFiveEntries() {\n        assertEquals(5, create(3, 5).size());\n    }\n\n    @Test\n    public void testSizeAfterDelete() {\n        Entry<Object, Rectangle> entry = e(1);\n        RTree<Object, Rectangle> tree = create(3, 0).add(entry).add(entry).add(entry).delete(entry);\n        assertEquals(2, tree.size());\n\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @Test\n    public void testDeletionThatRemovesAllNodesChildren() {\n        RTree<Object, Rectangle> tree = create(3, 8);\n        tree = tree.add(e(10));\n        // node children are now 1,2 and 3,4\n        assertEquals(3, tree.calculateDepth());\n        tree = tree.delete(e(10));\n        // node children are now 1,2 and 3\n        assertEquals(3, tree.calculateDepth());\n        assertEquals(Sets.newHashSet(e(1), e(2), e(3), e(4), e(5), e(6), e(7), e(8)),\n                Sets.newHashSet(tree.entries().toList().toBlocking().single()));\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @Test\n    public void testDeleteOfEntryThatDoesNotExistFromTreeOfOneEntry() {\n        RTree<Object, Geometry> tree = RTree.create().add(e(1));\n        tree = tree.delete(e(2));\n        assertEquals(Lists.newArrayList(e(1)), tree.entries().toList().toBlocking().single());\n    }\n\n    @Test\n    public void testDeleteFromEmptyTree() {\n        RTree<Object, Geometry> tree = RTree.create();\n        tree = tree.delete(e(2));\n        assertEquals(0, (int) tree.entries().count().toBlocking().single());\n    }\n\n    @Test\n    public void testBuilder1() {\n        RTree<Object, Point> tree = RTree.minChildren(1).maxChildren(4)\n                .selector(new SelectorMinimalAreaIncrease()).splitter(new SplitterQuadratic())\n                .create();\n        testBuiltTree(tree);\n    }\n\n    @Test\n    public void testDeletionOfEntryThatDoesNotExistFromNonLeaf() {\n        RTree<Object, Rectangle> tree = create(3, 100).delete(e(1000));\n        assertEquals(100, (int) tree.entries().count().toBlocking().single());\n    }\n\n    @Test\n    public void testBuilder2() {\n        RTree<Object, Point> tree = RTree.selector(new SelectorMinimalAreaIncrease()).minChildren(1)\n                .maxChildren(4).splitter(new SplitterQuadratic()).create();\n        testBuiltTree(tree);\n    }\n\n    @Test\n    public void testBuilder3() {\n        RTree<Object, Point> tree = RTree.maxChildren(4).selector(new SelectorMinimalAreaIncrease())\n                .minChildren(1).splitter(new SplitterQuadratic()).create();\n        testBuiltTree(tree);\n    }\n\n    @Test\n    public void testBuilder4() {\n        RTree<Object, Point> tree = RTree.splitter(new SplitterQuadratic()).maxChildren(4)\n                .selector(new SelectorMinimalAreaIncrease()).minChildren(1).create();\n        testBuiltTree(tree);\n    }\n\n    @Test\n    public void testBackpressureIterationForUpTo1000Entries() {\n        List<Entry<Object, Rectangle>> entries = Utilities.entries1000(Precision.SINGLE);\n        RTree<Object, Rectangle> tree = RTree.star().create();\n        for (int i = 1; i <= 1000; i++) {\n            tree = tree.add(entries.get(i - 1));\n            final HashSet<Entry<Object, Rectangle>> set = new HashSet<Entry<Object, Rectangle>>();\n            tree.entries().subscribe(createBackpressureSubscriber(set));\n            assertEquals(new HashSet<Entry<Object, Rectangle>>(entries.subList(0, i)), set);\n        }\n    }\n\n    private static <T extends Geometry> Subscriber<Entry<Object, T>> createBackpressureSubscriber(\n            final Collection<Entry<Object, T>> collection) {\n        return new Subscriber<Entry<Object, T>>() {\n\n            @Override\n            public void onStart() {\n                request(1);\n            }\n\n            @Override\n            public void onCompleted() {\n            }\n\n            @Override\n            public void onError(Throwable e) {\n            }\n\n            @Override\n            public void onNext(Entry<Object, T> t) {\n                collection.add(t);\n                request(1);\n            }\n        };\n    }\n\n    private void testBuiltTree(RTree<Object, Point> tree) {\n        for (int i = 1; i <= 1000; i++) {\n            tree = tree.add(i, Geometries.point(i, i));\n        }\n        assertEquals(1000, (int) tree.entries().count().toBlocking().single());\n    }\n\n    private static RTree<Object, Rectangle> create(int maxChildren, int n) {\n        RTree<Object, Rectangle> tree = RTree.maxChildren(maxChildren).create();\n        for (int i = 1; i <= n; i++)\n            tree = tree.add(e(i));\n        return tree;\n    }\n\n    @Test\n    public void testNearestSameDirection() {\n        RTree<Object, Rectangle> tree = RTree.maxChildren(4).<Object, Rectangle>create().add(e(1))\n                .add(e(2)).add(e(3)).add(e(10)).add(e(11));\n        List<Entry<Object, Rectangle>> list = tree.nearest(r(9), 10, 2).toList().toBlocking()\n                .single();\n        assertEquals(2, list.size());\n        System.out.println(list);\n        assertEquals(10, list.get(0).geometry().mbr().x1(), PRECISION);\n        assertEquals(11, list.get(1).geometry().mbr().x1(), PRECISION);\n\n        List<Entry<Object, Rectangle>> list2 = tree.nearest(r(10), 8, 3).toList().toBlocking()\n                .single();\n        assertEquals(2, list2.size());\n        assertEquals(10, list2.get(1).geometry().mbr().x1(), PRECISION);\n        assertEquals(11, list2.get(0).geometry().mbr().x1(), PRECISION);\n    }\n\n    @Test\n    public void testNearestDifferentDirections() {\n        RTree<Object, Geometry> tree = RTree.maxChildren(4).create().add(e(1)).add(e(2)).add(e(3))\n                .add(e(9)).add(e(10));\n        List<Entry<Object, Geometry>> list = tree.nearest(r(6), 10, 2).toList().toBlocking()\n                .single();\n        assertEquals(2, list.size());\n        assertEquals(3, list.get(0).geometry().mbr().x1(), PRECISION);\n        assertEquals(9, list.get(1).geometry().mbr().x1(), PRECISION);\n    }\n\n    @Test\n    public void testNearestToAPoint() {\n        Object value = new Object();\n        RTree<Object, Geometry> tree = RTree.create().add(value, point(1, 1));\n        List<Entry<Object, Geometry>> list = tree.nearest(point(2, 2), 3, 2).toList().toBlocking()\n                .single();\n        assertEquals(1, list.size());\n        assertEquals(value, list.get(0).value());\n    }\n\n    @Test\n    public void testNearestReturnsInOrder() {\n        Object value = new Object();\n        RTree<Object, Geometry> tree = RTree.create().add(value, point(1, 1))\n                .add(value, point(2, 2)).add(value, point(3, 3)).add(value, point(4, 4));\n        List<Entry<Object, Geometry>> list = tree.nearest(point(0, 0), 10, 10).toList().toBlocking()\n                .single();\n        System.out.println(list);\n        assertEquals(4, list.size());\n        assertEquals(point(1, 1), list.get(0).geometry());\n        assertEquals(point(2, 2), list.get(1).geometry());\n        assertEquals(point(3, 3), list.get(2).geometry());\n        assertEquals(point(4, 4), list.get(3).geometry());\n    }\n\n    @Test\n    public void testNearestHonoursUnsubscribeJustBeforeCompletion() {\n        Object value = new Object();\n        RTree<Object, Geometry> tree = RTree.create().add(value, point(1, 1));\n        final AtomicBoolean completeCalled = new AtomicBoolean(false);\n        tree.nearest(point(0, 0), 10, 10).subscribe(new Subscriber<Object>() {\n\n            @Override\n            public void onCompleted() {\n                completeCalled.set(true);\n            }\n\n            @Override\n            public void onError(Throwable e) {\n\n            }\n\n            @Override\n            public void onNext(Object t) {\n                unsubscribe();\n            }\n        });\n        assertFalse(completeCalled.get());\n    }\n\n    @Test\n    public void testVisualizer() {\n        List<Entry<Object, Geometry>> entries = createRandomEntries(1000);\n        int maxChildren = 8;\n        RTree<Object, Geometry> tree = RTree.maxChildren(maxChildren).create().add(entries);\n        tree.visualize(600, 600).save(\"target/tree.png\");\n\n        RTree<Object, Geometry> tree2 = RTree.star().maxChildren(maxChildren).create().add(entries);\n        tree2.visualize(600, 600).save(\"target/tree2.png\");\n\n        RTree<Object, Geometry> tree3 = RTree.maxChildren(maxChildren).create(entries);\n        tree3.visualize(600, 600).save(\"target/tree3.png\");\n    }\n\n    @Test(expected = RuntimeException.class)\n    public void testSplitterRStarThrowsExceptionOnEmptyList() {\n        SplitterRStar spl = new SplitterRStar();\n        spl.split(Collections.<HasGeometry>emptyList(), 4);\n    }\n\n    @Test\n    public void testSearchOnGreekDataUsingFlatBuffersFactory() {\n\n    }\n\n    @Test\n    public void testVisualizerWithGreekData() {\n        List<Entry<Object, Point>> entries = GreekEarthquakes.entriesList(Precision.DOUBLE);\n        int maxChildren = 8;\n        RTree<Object, Point> tree = RTree.maxChildren(maxChildren)\n                .factory(new FactoryFlatBuffers<Object, Geometry>(new Func1<Object, byte[]>() {\n                    @Override\n                    public byte[] call(Object o) {\n                        return \"boo\".getBytes();\n                    }\n                }, new Func1<byte[], Object>() {\n                    @Override\n                    public Object call(byte[] t) {\n                        return new String(t);\n                    }\n                })).<Object, Point>create().add(entries);\n        tree.visualize(2000, 2000).save(\"target/greek.png\");\n\n        // do search\n        int found = tree.search(Geometries.rectangle(40, 27.0, 40.5, 27.5)).count().toBlocking()\n                .single();\n        System.out.println(\"found=\" + found);\n        assertEquals(22, found);\n\n        RTree<Object, Point> tree2 = RTree.maxChildren(maxChildren).star().<Object, Point>create()\n                .add(entries);\n        tree2.visualize(2000, 2000).save(\"target/greek2.png\");\n\n        RTree<Object, Point> tree3 = RTree.maxChildren(maxChildren).create(entries);\n        tree3.visualize(2000, 2000).save(\"target/greek3.png\");\n    }\n\n    @Test\n    public void testDeleteOneFromOne() {\n        Entry<Object, Rectangle> e1 = e(1);\n        RTree<Object, Rectangle> tree = RTree.maxChildren(4).<Object, Rectangle>create().add(e1)\n                .delete(e1);\n        assertEquals(0, (int) tree.entries().count().toBlocking().single());\n    }\n\n    @Test\n    public void testDeleteOneFromTreeWithDepthGreaterThanOne() {\n        Entry<Object, Rectangle> e1 = e(1);\n        RTree<Object, Rectangle> tree = RTree.maxChildren(4).<Object, Rectangle>create().add(e1)\n                .add(e(2)).add(e(3)).add(e(4)).add(e(5)).add(e(6)).add(e(7)).add(e(8)).add(e(9))\n                .add(e(10)).delete(e1);\n        assertEquals(9, (int) tree.entries().count().toBlocking().single());\n        assertFalse(tree.entries().contains(e1).toBlocking().single());\n    }\n\n    @Test\n    public void testDeleteOneFromLargeTreeThenDeleteAllAndEnsureEmpty() {\n        int n = 10000;\n        RTree<Object, Geometry> tree = createRandomRTree(n).add(e(1)).add(e(2)).delete(e(1));\n        assertEquals(n + 1, (int) tree.entries().count().toBlocking().single());\n        assertFalse(tree.entries().contains(e(1)).toBlocking().single());\n        assertTrue(tree.entries().contains(e(2)).toBlocking().single());\n        n++;\n        assertEquals(n, tree.size());\n\n        for (Entry<Object, Geometry> entry : tree.entries().toBlocking().toIterable()) {\n            tree = tree.delete(entry);\n            n--;\n            assertEquals(n, tree.size());\n        }\n        assertEquals(0, (int) tree.entries().count().toBlocking().single());\n        assertTrue(tree.isEmpty());\n    }\n\n    @Test\n    public void testDeleteOnlyDeleteOneIfThereAreMoreThanMaxChildren() {\n        Entry<Object, Rectangle> e1 = e(1);\n        int count = RTree.maxChildren(4).create().add(e1).add(e1).add(e1).add(e1).add(e1).delete(e1)\n                .search(e1.geometry().mbr()).count().toBlocking().single();\n        assertEquals(4, count);\n    }\n\n    @Test\n    public void testDeleteAllIfThereAreMoreThanMaxChildren() {\n        Entry<Object, Rectangle> e1 = e(1);\n        int count = RTree.maxChildren(4).create().add(e1).add(e1).add(e1).add(e1).add(e1)\n                .delete(e1, true).search(e1.geometry().mbr()).count().toBlocking().single();\n        assertEquals(0, count);\n    }\n\n    @Test\n    public void testDeleteItemThatIsNotPresentDoesNothing() {\n        Entry<Object, Rectangle> e1 = e(1);\n        Entry<Object, Rectangle> e2 = e(2);\n        RTree<Object, Rectangle> tree = RTree.<Object, Rectangle>create().add(e1);\n        assertTrue(tree == tree.delete(e2));\n    }\n\n    @Test\n    public void testExampleOnReadMe() {\n        RTree<String, Geometry> tree = RTree.maxChildren(5).create();\n        tree = tree.add(entry(\"DAVE\", point(10, 20))).add(entry(\"FRED\", point(12, 25)))\n                .add(entry(\"MARY\", point(97, 125)));\n    }\n\n    @Test(timeout = 2000)\n    public void testUnsubscribe() {\n        RTree<Object, Geometry> tree = createRandomRTree(1000);\n        assertEquals(0, (int) tree.entries().take(0).count().toBlocking().single());\n    }\n\n    @Test\n    public void testSearchConditionAlwaysFalse() {\n        @SuppressWarnings(\"unchecked\")\n        RTree<Object, Geometry> tree = (RTree<Object, Geometry>) (RTree<?, ?>) create(3, 3);\n        assertEquals(0, (int) tree.search(Functions.alwaysFalse()).count().toBlocking().single());\n    }\n\n    @Test\n    public void testAddOverload() {\n        @SuppressWarnings(\"unchecked\")\n        RTree<Object, Geometry> tree = (RTree<Object, Geometry>) (RTree<?, ?>) create(3, 0);\n        tree = tree.add(123, Geometries.point(1, 2));\n        assertEquals(1, (int) tree.entries().count().toBlocking().single());\n    }\n\n    @Test\n    public void testDeleteOverload() {\n        @SuppressWarnings(\"unchecked\")\n        RTree<Object, Geometry> tree = (RTree<Object, Geometry>) (RTree<?, ?>) create(3, 0);\n        tree = tree.add(123, Geometries.point(1, 2)).delete(123, Geometries.point(1, 2));\n        assertEquals(0, (int) tree.entries().count().toBlocking().single());\n    }\n\n    @Test\n    public void testStandardRTreeSearch() {\n        Rectangle r = rectangle(13.0, 23.0, 50.0, 80.0);\n        Point[] points = { point(59.0, 91.0), point(86.0, 14.0), point(36.0, 60.0),\n                point(57.0, 36.0), point(14.0, 37.0) };\n\n        RTree<Integer, Geometry> tree = RTree.create();\n        for (int i = 0; i < points.length; i++) {\n            Point point = points[i];\n            System.out.println(\"point(\" + point.x() + \",\" + point.y() + \"), value=\" + (i + 1));\n            tree = tree.add(i + 1, point);\n        }\n        System.out.println(tree.asString());\n        System.out.println(\"searching \" + r);\n        Set<Integer> set = new HashSet<Integer>(\n                tree.search(r).map(RTreeTest.<Integer>toValue()).toList().toBlocking().single());\n        assertEquals(new HashSet<Integer>(asList(3, 5)), set);\n    }\n\n    @Test\n    public void testStandardRTreeSearch2() {\n        Rectangle r = rectangle(10.0, 10.0, 50.0, 50.0);\n        Point[] points = { point(28.0, 19.0), point(29.0, 4.0), point(10.0, 63.0),\n                point(34.0, 85.0), point(62.0, 45.0) };\n\n        RTree<Integer, Geometry> tree = RTree.create();\n        for (int i = 0; i < points.length; i++) {\n            Point point = points[i];\n            System.out.println(\"point(\" + point.x() + \",\" + point.y() + \"), value=\" + (i + 1));\n            tree = tree.add(i + 1, point);\n        }\n        System.out.println(tree.asString());\n        System.out.println(\"searching \" + r);\n        Set<Integer> set = new HashSet<Integer>(\n                tree.search(r).map(RTreeTest.<Integer>toValue()).toList().toBlocking().single());\n        assertEquals(new HashSet<Integer>(asList(1)), set);\n    }\n\n    @Test\n    public void testBulkLoadingTreeAndStarTreeReturnsSameAsStandardRTree() {\n\n        RTree<Integer, Geometry> tree1 = RTree.create();\n        RTree<Integer, Geometry> tree2 = RTree.star().create();\n\n        Rectangle[] testRects = { rectangle(0, 0, 0, 0), rectangle(0, 0, 100, 100),\n                rectangle(0, 0, 10, 10), rectangle(0.12, 0.25, 50.356, 50.756),\n                rectangle(1, 0.252, 50, 69.23), rectangle(13.12, 23.123, 50.45, 80.9),\n                rectangle(10, 10, 50, 50) };\n\n        List<Entry<Integer, Geometry>> entries = new ArrayList<Entry<Integer, Geometry>>(10000);\n        for (int i = 1; i <= 10000; i++) {\n            Point point = nextPoint();\n            // System.out.println(\"point(\" + point.x() + \",\" + point.y() +\n            // \"),\");\n            tree1 = tree1.add(i, point);\n            tree2 = tree2.add(i, point);\n            entries.add(new EntryDefault<Integer, Geometry>(i, point));\n        }\n        RTree<Integer, Geometry> tree3 = RTree.create(entries);\n\n        // tree2.visualize(2000, 2000).save(\"target/tree22.png\");\n        // tree3.visualize(2000, 2000).save(\"target/tree33.png\");\n\n        for (Rectangle r : testRects) {\n            Set<Integer> res1 = new HashSet<Integer>(tree1.search(r)\n                    .map(RTreeTest.<Integer>toValue()).toList().toBlocking().single());\n            Set<Integer> res2 = new HashSet<Integer>(tree2.search(r)\n                    .map(RTreeTest.<Integer>toValue()).toList().toBlocking().single());\n            Set<Integer> res3 = new HashSet<Integer>(tree3.search(r)\n                    .map(RTreeTest.<Integer>toValue()).toList().toBlocking().single());\n            System.out.println(\"searchRect= rectangle(\" + r.x1() + \",\" + r.y1() + \",\" + r.x2() + \",\"\n                    + r.y2() + \")\");\n            System.out.println(\"res1.size=\" + res1.size() + \",res2.size=\" + res2.size()\n                    + \",res3.size=\" + res3.size());\n            // System.out.println(\"res1=\" + res1 + \",res2=\" + res2 + \",res3=\" + res3);\n            assertEquals(res1.size(), res2.size());\n            assertEquals(res1.size(), res3.size());\n        }\n    }\n\n    @Test\n    public void testUnsubscribeWhileIteratingLeafNode() {\n        RTree<Object, Rectangle> tree = RTree.maxChildren(5).<Object, Rectangle>create().add(e(1))\n                .add(e(2));\n        tree.entries().subscribe(new Subscriber<Object>() {\n\n            @Override\n            public void onCompleted() {\n\n            }\n\n            @Override\n            public void onError(Throwable e) {\n            }\n\n            @Override\n            public void onNext(Object t) {\n                unsubscribe();\n            }\n        });\n    }\n\n    @Test\n    public void testUnsubscribeWhileIteratingNonLeafNode() {\n        final AtomicBoolean completed = new AtomicBoolean(false);\n        RTree<Object, Rectangle> tree = RTree.maxChildren(3).<Object, Rectangle>create().add(e(1))\n                .add(e(2)).add(e(3)).add(e(4));\n        tree.entries().subscribe(new Subscriber<Object>() {\n\n            @Override\n            public void onCompleted() {\n                completed.set(true);\n            }\n\n            @Override\n            public void onError(Throwable e) {\n            }\n\n            @Override\n            public void onNext(Object t) {\n                unsubscribe();\n            }\n        });\n        assertFalse(completed.get());\n    }\n\n    @Test\n    public void testSearchWithIntersectsRectangleFunction() {\n        RTree<Integer, Rectangle> tree = RTree.create();\n        tree.search(circle(0, 0, 1), rectangleIntersectsCircle);\n    }\n\n    @Test\n    public void testSearchWithIntersectsPointFunctionReturnsOne() {\n        RTree<Integer, Point> tree = RTree.<Integer, Point>create().add(1, point(0, 0));\n        Observable<Entry<Integer, Point>> entries = tree.search(circle(0, 0, 1),\n                pointIntersectsCircle);\n        assertEquals(1, (int) entries.count().toBlocking().single());\n    }\n\n    @Test\n    public void testSearchWithIntersectsPointFunctionReturnsNone() {\n        RTree<Integer, Point> tree = RTree.<Integer, Point>create().add(1, point(10, 10));\n        Observable<Entry<Integer, Point>> entries = tree.search(circle(0, 0, 1),\n                pointIntersectsCircle);\n        assertEquals(0, (int) entries.count().toBlocking().single());\n    }\n\n    @Test\n    public void testSearchWithDistanceFunctionIntersectsMbrButNotActualGeometry() {\n        RTree<Integer, Point> tree = RTree.<Integer, Point>create().add(1, point(0, 0)).add(2,\n                point(1, 1));\n\n        Observable<Entry<Integer, Point>> entries = tree.search(circle(0, 0, 1), 0.1,\n                distanceCircleToPoint);\n        assertEquals(1, (int) entries.count().toBlocking().single());\n    }\n\n    @Test\n    public void testSearchWithDistanceFunctionIntersectsMbrAndActualGeometry() {\n        RTree<Integer, Point> tree = RTree.<Integer, Point>create().add(1, point(0, 0)).add(2,\n                point(1, 1));\n\n        Observable<Entry<Integer, Point>> entries = tree.search(circle(0, 0, 1), 0.5,\n                distanceCircleToPoint);\n        assertEquals(2, (int) entries.count().toBlocking().single());\n    }\n\n    @Test\n    public void testSearchWithDistanceFunctionIntersectsNothing() {\n        RTree<Integer, Point> tree = RTree.<Integer, Point>create().add(1, point(0, 0)).add(2,\n                point(1, 1));\n\n        Observable<Entry<Integer, Point>> entries = tree.search(circle(10, 10, 1), 0.5,\n                distanceCircleToPoint);\n        assertEquals(0, (int) entries.count().toBlocking().single());\n    }\n\n    @Test\n    public void calculateDepthOfEmptyTree() {\n        RTree<Object, Geometry> tree = RTree.create();\n        assertEquals(0, tree.calculateDepth());\n    }\n\n    @Test\n    public void calculateAsStringOfEmptyTree() {\n        RTree<Object, Geometry> tree = RTree.create();\n        assertEquals(\"\", tree.asString());\n    }\n\n    @Test\n    public void testForMeiZhao() {\n        for (int minChildren = 1; minChildren <= 2; minChildren++) {\n            RTree<Integer, Point> tree = RTree.maxChildren(3).minChildren(minChildren)\n                    .<Integer, Point>create().add(1, point(1, 9)).add(2, point(2, 10))\n                    .add(3, point(4, 8)).add(4, point(6, 7)).add(5, point(9, 10))\n                    .add(6, point(7, 5)).add(7, point(5, 6)).add(8, point(4, 3)).add(9, point(3, 2))\n                    .add(10, point(9, 1)).add(11, point(10, 4)).add(12, point(6, 2))\n                    .add(13, point(8, 3));\n            System.out.println(tree.asString());\n        }\n    }\n\n    @Test\n    public void testSearchWithCircleFindsCentreOnly() {\n        RTree<Integer, Point> tree = RTree.<Integer, Point>create().add(1, point(1, 1))\n                .add(2, point(2, 2)).add(3, point(3, 3));\n        List<Entry<Integer, Point>> list = tree.search(Geometries.circle(2, 2, 1)).toList()\n                .toBlocking().single();\n        assertEquals(1, list.size());\n        assertEquals(2, (int) list.get(0).value());\n    }\n\n    @Test\n    public void testSearchWithCircleFindsAll() {\n        RTree<Integer, Point> tree = RTree.<Integer, Point>create().add(1, point(1, 1))\n                .add(2, point(2, 2)).add(3, point(3, 3));\n        List<Entry<Integer, Point>> list = tree.search(Geometries.circle(2, 2, 1.5)).toList()\n                .toBlocking().single();\n        assertEquals(3, list.size());\n    }\n\n    @Test\n    public void testSearchWithLineFindsAll() {\n        RTree<Integer, Point> tree = RTree.<Integer, Point>create().add(1, point(1, 1))\n                .add(2, point(2, 2)).add(3, point(3, 3));\n        List<Entry<Integer, Point>> list = tree.search(Geometries.line(0, 0, 4, 4)).toList()\n                .toBlocking().single();\n        assertEquals(3, list.size());\n    }\n\n    @Test\n    public void testSearchWithLineFindsOne() {\n        RTree<Integer, Point> tree = RTree.<Integer, Point>create().add(1, point(1, 1))\n                .add(2, point(2, 2)).add(3, point(3, 3));\n        List<Entry<Integer, Point>> list = tree.search(Geometries.line(1.5, 1.5, 2.5, 2.5)).toList()\n                .toBlocking().single();\n        assertEquals(1, list.size());\n        assertEquals(2, (int) list.get(0).value());\n    }\n\n    @Test\n    public void testSearchWithLineFindsNone() {\n        RTree<Integer, Point> tree = RTree.<Integer, Point>create().add(1, point(1, 1))\n                .add(2, point(2, 2)).add(3, point(3, 3));\n        List<Entry<Integer, Point>> list = tree.search(Geometries.line(1.5, 1.5, 2.6, 2.5)).toList()\n                .toBlocking().single();\n        System.out.println(list);\n        assertEquals(0, list.size());\n    }\n\n    @Test\n    public void testRTreeRootMbrWhenRTreeEmpty() {\n        assertFalse(RTree.create().mbr().isPresent());\n    }\n\n    @Test\n    public void testRTreeRootMbrWhenRTreeNonEmpty() {\n        Optional<Rectangle> r = RTree.<Integer, Point>create().add(1, point(1, 1))\n                .add(2, point(2, 2)).mbr();\n        assertEquals(Geometries.rectangle(1, 1, 2, 2), r.get());\n    }\n\n    @Test\n    public void testIntersectsPointLine() {\n        assertTrue(Intersects.lineIntersectsPoint.call(line(1, 1, 2, 2), point(1, 1)));\n    }\n\n    @Test(timeout = 30000000)\n    public void testGroupByIssue40() {\n        RTree<Integer, Geometry> tree = RTree.star().create();\n\n        tree = tree.add(1, Geometries.point(13.0, 52.0));\n        tree = tree.add(2, Geometries.point(13.0, 52.0));\n        tree = tree.add(3, Geometries.point(13.0, 52.0));\n        tree = tree.add(4, Geometries.point(13.0, 52.0));\n        tree = tree.add(5, Geometries.point(13.0, 52.0));\n        tree = tree.add(6, Geometries.point(13.0, 52.0));\n\n        Rectangle rectangle = Geometries.rectangle(12.9, 51.9, 13.1, 52.1);\n        assertEquals(Integer.valueOf(2), tree.search(rectangle).doOnRequest(new Action1<Long>() {\n            @Override\n            public void call(Long n) {\n                System.out.println(\"requestFromGroupBy=\" + n);\n            }\n        }).groupBy(new Func1<Entry<Integer, Geometry>, Boolean>() {\n            @Override\n            public Boolean call(Entry<Integer, Geometry> entry) {\n                System.out.println(entry);\n                return entry.value() % 2 == 0;\n            }\n        }).doOnRequest(new Action1<Long>() {\n            @Override\n            public void call(Long n) {\n                System.out.println(\"requestFromFlatMap=\" + n);\n            }\n        }).flatMap(\n                new Func1<GroupedObservable<Boolean, Entry<Integer, Geometry>>, Observable<Integer>>() {\n                    @Override\n                    public Observable<Integer> call(\n                            GroupedObservable<Boolean, Entry<Integer, Geometry>> group) {\n                        return group.count();\n                    }\n                }).count().toBlocking().single());\n    }\n\n    @Test\n    public void testBackpressureForOverflow() {\n        RTree<Integer, Geometry> tree = RTree.star().create();\n\n        tree = tree.add(1, Geometries.point(13.0, 52.0));\n        tree = tree.add(2, Geometries.point(13.0, 52.0));\n        tree = tree.add(3, Geometries.point(13.0, 52.0));\n        tree = tree.add(4, Geometries.point(13.0, 52.0));\n        tree = tree.add(5, Geometries.point(13.0, 52.0));\n        tree = tree.add(6, Geometries.point(13.0, 52.0));\n        final AtomicInteger count = new AtomicInteger();\n        Rectangle rectangle = Geometries.rectangle(12.9, 51.9, 13.1, 52.1);\n        tree.search(rectangle).subscribe(new Subscriber<Object>() {\n\n            @Override\n            public void onStart() {\n                request(4);\n            }\n\n            @Override\n            public void onCompleted() {\n\n            }\n\n            @Override\n            public void onError(Throwable e) {\n\n            }\n\n            @Override\n            public void onNext(Object t) {\n                request(Long.MAX_VALUE);\n                count.incrementAndGet();\n            }\n        });\n        assertEquals(6, count.get());\n        assertEquals(6, (int) tree.search(rectangle).count().toBlocking().single());\n\n    }\n    \n    @Test\n    public void testDeleteIssue81d() {\n         RTree<Object, Point> t = RTree.create();\n         t = t.add(1, Geometries.pointGeographic(123.4d, 23.3d));\n         t = t.delete(1, Geometries.pointGeographic(123.4d, 23.3d));\n         assertEquals(0, t.size());\n     }\n    \n     @Test\n     public void testDeleteIssue81f() {\n         RTree<Object, Point> t = RTree.create();\n         t = t.add(1, Geometries.pointGeographic(123.4f, 23.3f));\n         t = t.delete(1, Geometries.pointGeographic(123.4f, 23.3f));\n         assertEquals(0, t.size());\n     }\n\n    private static Func2<Point, Circle, Double> distanceCircleToPoint = new Func2<Point, Circle, Double>() {\n        @Override\n        public Double call(Point point, Circle circle) {\n            return circle.distance(point.mbr());\n        }\n    };\n\n    private static <T> Func1<Entry<T, ?>, T> toValue() {\n        return new Func1<Entry<T, ?>, T>() {\n\n            @Override\n            public T call(Entry<T, ?> entry) {\n                return entry.value();\n            }\n        };\n    }\n\n    private static Point nextPoint() {\n\n        double randomX = Math.round(Math.random() * 100);\n\n        double randomY = Math.round(Math.random() * 100);\n\n        return Geometries.point(randomX, randomY);\n\n    }\n\n    static Entry<Object, Rectangle> e(int n) {\n        return Entries.<Object, Rectangle>entry(n, r(n));\n    }\n\n    static Entry<Object, Rectangle> e2(int n) {\n        return Entries.<Object, Rectangle>entry(n, r(n - 1));\n    }\n\n    private static Rectangle r(int n) {\n        return rectangle(n, n, n + 1, n + 1);\n    }\n\n    private static Rectangle r(double n, double m) {\n        return rectangle(n, m, n + 1, m + 1);\n    }\n\n    private static Rectangle r(float n, float m) {\n        return rectangle(n, m, n + 1, m + 1);\n    }\n\n    static Rectangle random(Precision precision) {\n        if (precision == Precision.SINGLE)\n            return r((float) Math.random() * 1000, (float) Math.random() * 1000);\n        else\n            return r(Math.random() * 1000, Math.random() * 1000);\n    }\n\n    @Test\n    public void testSearchGreekEarthquakesDouble() {\n        Observable<Entry<Object, Point>> entriesDouble = GreekEarthquakes.entries(Precision.DOUBLE);\n        RTree<Object, Point> t = RTree.maxChildren(4).<Object, Point>create().add(entriesDouble)\n                .last().toBlocking().single(); //\n        t.search(Geometries.rectangle(40, 27.0, 40.5, 27.5)) //\n                .test() //\n                .assertValueCount(22) //\n                .assertCompleted();\n    }\n    \n}", "definition": "public class RTreeTest", "class_docstring": "", "name": "RTreeTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private static final double PRECISION = 0.000001;", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "double", "name": "PRECISION = 0.000001", "syntax_pass": true}, {"attribute_expression": "private static Func2<Point, Circle, Double> distanceCircleToPoint = new Func2<Point, Circle, Double>() {\n        @Override\n        public Double call(Point point, Circle circle) {\n            return circle.distance(point.mbr());\n        }\n    };", "docstring": "", "modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "type": "Func2<Point, Circle, Double>", "name": "distanceCircleToPoint = new Func2<Point, Circle, Double>() {\n        @Override\n        public Double call(Point point, Circle circle) {\n            return circle.distance(point.mbr());\n        }\n    }", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @Test\n    public void testInstantiation() {\n        RTree<Object, Geometry> tree = RTree.create();\n        assertTrue(tree.entries().isEmpty().toBlocking().single());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testInstantiation", "params": [], "body": "                                    {\n        RTree<Object, Geometry> tree = RTree.create();\n        assertTrue(tree.entries().isEmpty().toBlocking().single());\n    }", "signature": "@Test\n    public void testInstantiation()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testSearchEmptyTree() {\n        RTree<Object, Geometry> tree = RTree.create();\n        assertTrue(tree.search(r(1)).isEmpty().toBlocking().single());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testSearchEmptyTree", "params": [], "body": "                                      {\n        RTree<Object, Geometry> tree = RTree.create();\n        assertTrue(tree.search(r(1)).isEmpty().toBlocking().single());\n    }", "signature": "@Test\n    public void testSearchEmptyTree()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testSearchOnOneItem() {\n        RTree<Object, Rectangle> tree = RTree.create();\n        Entry<Object, Rectangle> entry = e(1);\n        tree = tree.add(entry);\n        assertEquals(Arrays.asList(entry), tree.search(r(1)).toList().toBlocking().single());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testSearchOnOneItem", "params": [], "body": "                                      {\n        RTree<Object, Rectangle> tree = RTree.create();\n        Entry<Object, Rectangle> entry = e(1);\n        tree = tree.add(entry);\n        assertEquals(Arrays.asList(entry), tree.search(r(1)).toList().toBlocking().single());\n    }", "signature": "@Test\n    public void testSearchOnOneItem()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testTreeWithOneItemIsNotEmpty() {\n        RTree<Object, Geometry> tree = RTree.create().add(e(1));\n        assertFalse(tree.isEmpty());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testTreeWithOneItemIsNotEmpty", "params": [], "body": "                                                {\n        RTree<Object, Geometry> tree = RTree.create().add(e(1));\n        assertFalse(tree.isEmpty());\n    }", "signature": "@Test\n    public void testTreeWithOneItemIsNotEmpty()"}, {"syntax_pass": true, "original_string": "    public void testSaveFileException() throws IOException {\n        FileLock lock = null;\n        RandomAccessFile file = null;\n        try {\n            String filename = \"target/locked.png\";\n            File f = new File(filename);\n            f.createNewFile();\n            file = new RandomAccessFile(f, \"rw\");\n            lock = file.getChannel().lock();\n            RTree.create().visualize(600, 600).save(filename, \"PNG\");\n        } finally {\n            try {\n                lock.release();\n                file.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }", "docstring": " @Test(expected = IOException.class)", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testSaveFileException", "params": [], "body": "                                                           {\n        FileLock lock = null;\n        RandomAccessFile file = null;\n        try {\n            String filename = \"target/locked.png\";\n            File f = new File(filename);\n            f.createNewFile();\n            file = new RandomAccessFile(f, \"rw\");\n            lock = file.getChannel().lock();\n            RTree.create().visualize(600, 600).save(filename, \"PNG\");\n        } finally {\n            try {\n                lock.release();\n                file.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }", "signature": "public void testSaveFileException()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testVisualizerWithEmptyTree() {\n        RTree<Object, Geometry> tree = RTree.create();\n        tree.visualize(600, 600).save(\"target/tree.png\", \"PNG\");\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testVisualizerWithEmptyTree", "params": [], "body": "                                              {\n        RTree<Object, Geometry> tree = RTree.create();\n        tree.visualize(600, 600).save(\"target/tree.png\", \"PNG\");\n    }", "signature": "@Test\n    public void testVisualizerWithEmptyTree()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testBulkLoadingEmpty() {\n        RTree<Object, Point> tree = RTree.create(new ArrayList<Entry<Object, Point>>());\n        assertTrue(tree.entries().isEmpty().toBlocking().single());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testBulkLoadingEmpty", "params": [], "body": "                                       {\n        RTree<Object, Point> tree = RTree.create(new ArrayList<Entry<Object, Point>>());\n        assertTrue(tree.entries().isEmpty().toBlocking().single());\n    }", "signature": "@Test\n    public void testBulkLoadingEmpty()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testBulkLoadingWithOneItemIsNotEmpty() {\n        RTree<Object, Rectangle> tree = RTree.create(Arrays.asList(e(1)));\n        assertFalse(tree.isEmpty());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testBulkLoadingWithOneItemIsNotEmpty", "params": [], "body": "                                                       {\n        RTree<Object, Rectangle> tree = RTree.create(Arrays.asList(e(1)));\n        assertFalse(tree.isEmpty());\n    }", "signature": "@Test\n    public void testBulkLoadingWithOneItemIsNotEmpty()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testBulkLoadingEntryCount() {\n        List<Entry<Integer, Geometry>> entries = new ArrayList<Entry<Integer, Geometry>>(10000);\n        for (int i = 1; i <= 10000; i++) {\n            Point point = nextPoint();\n            // System.out.println(\"point(\" + point.x() + \",\" + point.y() +\n            // \"),\");\n            entries.add(new EntryDefault<Integer, Geometry>(i, point));\n        }\n        RTree<Integer, Geometry> tree = RTree.create(entries);\n        int entrySize = tree.entries().count().toBlocking().single();\n        System.out.println(\"entry count: \" + entrySize);\n        assertEquals(entrySize, entries.size());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testBulkLoadingEntryCount", "params": [], "body": "                                            {\n        List<Entry<Integer, Geometry>> entries = new ArrayList<Entry<Integer, Geometry>>(10000);\n        for (int i = 1; i <= 10000; i++) {\n            Point point = nextPoint();\n            // System.out.println(\"point(\" + point.x() + \",\" + point.y() +\n            // \"),\");\n            entries.add(new EntryDefault<Integer, Geometry>(i, point));\n        }\n        RTree<Integer, Geometry> tree = RTree.create(entries);\n        int entrySize = tree.entries().count().toBlocking().single();\n        System.out.println(\"entry count: \" + entrySize);\n        assertEquals(entrySize, entries.size());\n    }", "signature": "@Test\n    public void testBulkLoadingEntryCount()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testSearchOnOneItemOnBulkLoadingRTree() {\n        Entry<Object, Rectangle> entry = e(1);\n        RTree<Object, Rectangle> tree = RTree.create(Arrays.asList(entry));\n        assertEquals(Arrays.asList(entry), tree.search(r(1)).toList().toBlocking().single());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testSearchOnOneItemOnBulkLoadingRTree", "params": [], "body": "                                                        {\n        Entry<Object, Rectangle> entry = e(1);\n        RTree<Object, Rectangle> tree = RTree.create(Arrays.asList(entry));\n        assertEquals(Arrays.asList(entry), tree.search(r(1)).toList().toBlocking().single());\n    }", "signature": "@Test\n    public void testSearchOnOneItemOnBulkLoadingRTree()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testAddObservable() {\n        Entry<Object, Rectangle> e1 = e(1);\n        Entry<Object, Rectangle> e2 = e2(1);\n\n        RTree<Object, Rectangle> tree = RTree.maxChildren(4).<Object, Rectangle>create().add(e1)\n                .add(e2).delete(e1);\n        RTree<Object, Rectangle> emptyTree = RTree.maxChildren(4).create();\n        rx.Observable<?> deletedtree = emptyTree.add(tree.entries());\n        assertEquals(2, (int) deletedtree.count().toBlocking().single());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testAddObservable", "params": [], "body": "                                    {\n        Entry<Object, Rectangle> e1 = e(1);\n        Entry<Object, Rectangle> e2 = e2(1);\n\n        RTree<Object, Rectangle> tree = RTree.maxChildren(4).<Object, Rectangle>create().add(e1)\n                .add(e2).delete(e1);\n        RTree<Object, Rectangle> emptyTree = RTree.maxChildren(4).create();\n        rx.Observable<?> deletedtree = emptyTree.add(tree.entries());\n        assertEquals(2, (int) deletedtree.count().toBlocking().single());\n    }", "signature": "@Test\n    public void testAddObservable()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testPerformanceAndEntriesCount() {\n\n        long repeats = Long.parseLong(System.getProperty(\"r\", \"1\"));\n        long n = Long.parseLong(System.getProperty(\"n\", \"10000\"));\n        RTree<Object, Geometry> tree = null;\n        while (--repeats >= 0) {\n            long t = System.currentTimeMillis();\n            tree = createRandomRTree(n);\n            long diff = System.currentTimeMillis() - t;\n            System.out.println(\"inserts/second = \" + ((double) n / diff * 1000));\n        }\n        assertEquals(n, (int) tree.entries().count().toBlocking().single());\n\n        long t = System.currentTimeMillis();\n        Entry<Object, Geometry> entry = tree.search(rectangle(0, 0, 500, 500)).first().toBlocking()\n                .single();\n        long diff = System.currentTimeMillis() - t;\n        System.out.println(\"found \" + entry);\n        System.out.println(\"time to get nearest with \" + n + \" entries=\" + diff);\n\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testPerformanceAndEntriesCount", "params": [], "body": "                                                 {\n\n        long repeats = Long.parseLong(System.getProperty(\"r\", \"1\"));\n        long n = Long.parseLong(System.getProperty(\"n\", \"10000\"));\n        RTree<Object, Geometry> tree = null;\n        while (--repeats >= 0) {\n            long t = System.currentTimeMillis();\n            tree = createRandomRTree(n);\n            long diff = System.currentTimeMillis() - t;\n            System.out.println(\"inserts/second = \" + ((double) n / diff * 1000));\n        }\n        assertEquals(n, (int) tree.entries().count().toBlocking().single());\n\n        long t = System.currentTimeMillis();\n        Entry<Object, Geometry> entry = tree.search(rectangle(0, 0, 500, 500)).first().toBlocking()\n                .single();\n        long diff = System.currentTimeMillis() - t;\n        System.out.println(\"found \" + entry);\n        System.out.println(\"time to get nearest with \" + n + \" entries=\" + diff);\n\n    }", "signature": "@Test\n    public void testPerformanceAndEntriesCount()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testSearchOfPoint() {\n        Object value = new Object();\n        RTree<Object, Geometry> tree = RTree.create().add(value, point(1, 1));\n        List<Entry<Object, Geometry>> list = tree.search(point(1, 1)).toList().toBlocking()\n                .single();\n        assertEquals(1, list.size());\n        assertEquals(value, list.get(0).value());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testSearchOfPoint", "params": [], "body": "                                    {\n        Object value = new Object();\n        RTree<Object, Geometry> tree = RTree.create().add(value, point(1, 1));\n        List<Entry<Object, Geometry>> list = tree.search(point(1, 1)).toList().toBlocking()\n                .single();\n        assertEquals(1, list.size());\n        assertEquals(value, list.get(0).value());\n    }", "signature": "@Test\n    public void testSearchOfPoint()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testSearchOfPointWithinDistance() {\n        Object value = new Object();\n        RTree<Object, Geometry> tree = RTree.create().add(value, point(1, 1));\n        List<Entry<Object, Geometry>> list = tree.search(point(1, 1), 2).toList().toBlocking()\n                .single();\n        assertEquals(1, list.size());\n        assertEquals(value, list.get(0).value());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testSearchOfPointWithinDistance", "params": [], "body": "                                                  {\n        Object value = new Object();\n        RTree<Object, Geometry> tree = RTree.create().add(value, point(1, 1));\n        List<Entry<Object, Geometry>> list = tree.search(point(1, 1), 2).toList().toBlocking()\n                .single();\n        assertEquals(1, list.size());\n        assertEquals(value, list.get(0).value());\n    }", "signature": "@Test\n    public void testSearchOfPointWithinDistance()"}, {"syntax_pass": true, "original_string": "    static List<Entry<Object, Geometry>> createRandomEntries(long n) {\n        List<Entry<Object, Geometry>> list = new ArrayList<Entry<Object, Geometry>>();\n        for (long i = 0; i < n; i++)\n            list.add(randomEntry());\n        return list;\n    }", "docstring": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "List<Entry<Object, Geometry>>", "classes": []}, "name": "createRandomEntries", "params": [{"name": "n", "type": "long"}], "body": "                                                                     {\n        List<Entry<Object, Geometry>> list = new ArrayList<Entry<Object, Geometry>>();\n        for (long i = 0; i < n; i++)\n            list.add(randomEntry());\n        return list;\n    }", "signature": "static List<Entry<Object, Geometry>> createRandomEntries(long n)"}, {"syntax_pass": true, "original_string": "    static RTree<Object, Geometry> createRandomRTree(long n) {\n        RTree<Object, Geometry> tree = RTree.maxChildren(4).create();\n        for (long i = 0; i < n; i++) {\n            Entry<Object, Geometry> entry = randomEntry();\n            tree = tree.add(entry);\n        }\n        return tree;\n    }", "docstring": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "RTree<Object, Geometry>", "classes": []}, "name": "createRandomRTree", "params": [{"name": "n", "type": "long"}], "body": "                                                             {\n        RTree<Object, Geometry> tree = RTree.maxChildren(4).create();\n        for (long i = 0; i < n; i++) {\n            Entry<Object, Geometry> entry = randomEntry();\n            tree = tree.add(entry);\n        }\n        return tree;\n    }", "signature": "static RTree<Object, Geometry> createRandomRTree(long n)"}, {"syntax_pass": true, "original_string": "    static Entry<Object, Geometry> randomEntry() {\n        return entry(new Object(), (Geometry) random(Precision.SINGLE));\n    }", "docstring": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "Entry<Object, Geometry>", "classes": []}, "name": "randomEntry", "params": [], "body": "                                                 {\n        return entry(new Object(), (Geometry) random(Precision.SINGLE));\n    }", "signature": "static Entry<Object, Geometry> randomEntry()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testDeleteWithGeometry() {\n        RTree<Object, Rectangle> tree = RTree.maxChildren(4).create();\n        Entry<Object, Rectangle> entry = e(1);\n        Entry<Object, Rectangle> entry2 = e2(1);\n        tree = tree.add(entry).add(entry2);\n\n        tree = tree.delete(entry.value(), entry.geometry(), true);\n        List<Entry<Object, Rectangle>> entries = tree.entries().toList().toBlocking().single();\n        assertTrue(entries.contains(entry2) && !entries.contains(entry));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testDeleteWithGeometry", "params": [], "body": "                                         {\n        RTree<Object, Rectangle> tree = RTree.maxChildren(4).create();\n        Entry<Object, Rectangle> entry = e(1);\n        Entry<Object, Rectangle> entry2 = e2(1);\n        tree = tree.add(entry).add(entry2);\n\n        tree = tree.delete(entry.value(), entry.geometry(), true);\n        List<Entry<Object, Rectangle>> entries = tree.entries().toList().toBlocking().single();\n        assertTrue(entries.contains(entry2) && !entries.contains(entry));\n    }", "signature": "@Test\n    public void testDeleteWithGeometry()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testDeleteIssue81() {\n        RTree<Object, Point> t = RTree.create();\n        t = t.add(1, Geometries.pointGeographic(123, 23));\n        t = t.delete(1, Geometries.pointGeographic(123, 23));\n        assertEquals(0, t.size());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testDeleteIssue81", "params": [], "body": "                                    {\n        RTree<Object, Point> t = RTree.create();\n        t = t.add(1, Geometries.pointGeographic(123, 23));\n        t = t.delete(1, Geometries.pointGeographic(123, 23));\n        assertEquals(0, t.size());\n    }", "signature": "@Test\n    public void testDeleteIssue81()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testDepthWith0() {\n        RTree<Object, Geometry> tree = RTree.create();\n        tree = tree.add(createRandomEntries(5));\n        List<Entry<Object, Geometry>> entries = tree.entries().toList().toBlocking().single();\n        RTree<Object, Geometry> deletedTree = tree.delete(entries, true);\n        assertTrue(deletedTree.isEmpty());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testDepthWith0", "params": [], "body": "                                 {\n        RTree<Object, Geometry> tree = RTree.create();\n        tree = tree.add(createRandomEntries(5));\n        List<Entry<Object, Geometry>> entries = tree.entries().toList().toBlocking().single();\n        RTree<Object, Geometry> deletedTree = tree.delete(entries, true);\n        assertTrue(deletedTree.isEmpty());\n    }", "signature": "@Test\n    public void testDepthWith0()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testContext() {\n        RTree<Object, Geometry> tree = RTree.create();\n        assertNotNull(tree.context());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testContext", "params": [], "body": "                              {\n        RTree<Object, Geometry> tree = RTree.create();\n        assertNotNull(tree.context());\n    }", "signature": "@Test\n    public void testContext()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testIterableDeletion() {\n        RTree<Object, Rectangle> tree = RTree.create();\n        Entry<Object, Rectangle> entry1 = e(1);\n        Entry<Object, Rectangle> entry2 = e(2);\n        Entry<Object, Rectangle> entry3 = e(3);\n        tree = tree.add(entry1).add(entry2).add(entry3);\n\n        List<Entry<Object, Rectangle>> list = new ArrayList<Entry<Object, Rectangle>>();\n        list.add(entry1);\n        list.add(entry3);\n        RTree<Object, Rectangle> deletedTree = tree.delete(list);\n        List<Entry<Object, Rectangle>> entries = deletedTree.entries().toList().toBlocking()\n                .single();\n        assertTrue(\n                entries.contains(entry2) && !entries.contains(entry1) && !entries.contains(entry3));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testIterableDeletion", "params": [], "body": "                                       {\n        RTree<Object, Rectangle> tree = RTree.create();\n        Entry<Object, Rectangle> entry1 = e(1);\n        Entry<Object, Rectangle> entry2 = e(2);\n        Entry<Object, Rectangle> entry3 = e(3);\n        tree = tree.add(entry1).add(entry2).add(entry3);\n\n        List<Entry<Object, Rectangle>> list = new ArrayList<Entry<Object, Rectangle>>();\n        list.add(entry1);\n        list.add(entry3);\n        RTree<Object, Rectangle> deletedTree = tree.delete(list);\n        List<Entry<Object, Rectangle>> entries = deletedTree.entries().toList().toBlocking()\n                .single();\n        assertTrue(\n                entries.contains(entry2) && !entries.contains(entry1) && !entries.contains(entry3));\n    }", "signature": "@Test\n    public void testIterableDeletion()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testObservableDeletion() {\n        RTree<Object, Rectangle> tree = RTree.create();\n        Entry<Object, Rectangle> entry1 = e(1);\n        Entry<Object, Rectangle> entry2 = e(3);\n        Entry<Object, Rectangle> entry3 = e(5);\n        tree = tree.add(entry1).add(entry2).add(entry3);\n        rx.Observable<Entry<Object, Rectangle>> obs = tree.search(r(2), 5);\n        rx.Observable<RTree<Object, Rectangle>> deleted = tree.delete(obs, true);\n        assertTrue(deleted.elementAt(deleted.count().toBlocking().single() - 1).count().toBlocking()\n                .single() == 1);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testObservableDeletion", "params": [], "body": "                                         {\n        RTree<Object, Rectangle> tree = RTree.create();\n        Entry<Object, Rectangle> entry1 = e(1);\n        Entry<Object, Rectangle> entry2 = e(3);\n        Entry<Object, Rectangle> entry3 = e(5);\n        tree = tree.add(entry1).add(entry2).add(entry3);\n        rx.Observable<Entry<Object, Rectangle>> obs = tree.search(r(2), 5);\n        rx.Observable<RTree<Object, Rectangle>> deleted = tree.delete(obs, true);\n        assertTrue(deleted.elementAt(deleted.count().toBlocking().single() - 1).count().toBlocking()\n                .single() == 1);\n    }", "signature": "@Test\n    public void testObservableDeletion()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testFullDeletion() {\n        RTree<Object, Rectangle> tree = RTree.maxChildren(4).create();\n        Entry<Object, Rectangle> entry = e(1);\n        tree = tree.add(entry).add(entry);\n        tree = tree.delete(entry, true);\n        assertTrue(tree.isEmpty());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testFullDeletion", "params": [], "body": "                                   {\n        RTree<Object, Rectangle> tree = RTree.maxChildren(4).create();\n        Entry<Object, Rectangle> entry = e(1);\n        tree = tree.add(entry).add(entry);\n        tree = tree.delete(entry, true);\n        assertTrue(tree.isEmpty());\n    }", "signature": "@Test\n    public void testFullDeletion()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testPartialDeletion() {\n        RTree<Object, Rectangle> tree = RTree.maxChildren(4).create();\n        Entry<Object, Rectangle> entry = e(1);\n        tree = tree.add(entry).add(entry);\n        tree = tree.delete(entry, false);\n        List<Entry<Object, Rectangle>> entries = tree.entries().toList().toBlocking().single();\n        int countEntries = tree.entries().count().toBlocking().single();\n        assertTrue(countEntries == 1);\n        assertTrue(entries.get(0).equals(entry));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testPartialDeletion", "params": [], "body": "                                      {\n        RTree<Object, Rectangle> tree = RTree.maxChildren(4).create();\n        Entry<Object, Rectangle> entry = e(1);\n        tree = tree.add(entry).add(entry);\n        tree = tree.delete(entry, false);\n        List<Entry<Object, Rectangle>> entries = tree.entries().toList().toBlocking().single();\n        int countEntries = tree.entries().count().toBlocking().single();\n        assertTrue(countEntries == 1);\n        assertTrue(entries.get(0).equals(entry));\n    }", "signature": "@Test\n    public void testPartialDeletion()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testDepthWithMaxChildren3Entries1() {\n        RTree<Object, Rectangle> tree = create(3, 1);\n        assertEquals(1, tree.calculateDepth());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testDepthWithMaxChildren3Entries1", "params": [], "body": "                                                    {\n        RTree<Object, Rectangle> tree = create(3, 1);\n        assertEquals(1, tree.calculateDepth());\n    }", "signature": "@Test\n    public void testDepthWithMaxChildren3Entries1()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testDepthWithMaxChildren3Entries2() {\n        RTree<Object, Rectangle> tree = create(3, 2);\n        assertEquals(1, tree.calculateDepth());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testDepthWithMaxChildren3Entries2", "params": [], "body": "                                                    {\n        RTree<Object, Rectangle> tree = create(3, 2);\n        assertEquals(1, tree.calculateDepth());\n    }", "signature": "@Test\n    public void testDepthWithMaxChildren3Entries2()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testDepthWithMaxChildren3Entries3() {\n        RTree<Object, Rectangle> tree = create(3, 3);\n        assertEquals(1, tree.calculateDepth());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testDepthWithMaxChildren3Entries3", "params": [], "body": "                                                    {\n        RTree<Object, Rectangle> tree = create(3, 3);\n        assertEquals(1, tree.calculateDepth());\n    }", "signature": "@Test\n    public void testDepthWithMaxChildren3Entries3()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testDepthWithMaxChildren3Entries4() {\n        RTree<Object, Rectangle> tree = create(3, 4);\n        assertEquals(2, tree.calculateDepth());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testDepthWithMaxChildren3Entries4", "params": [], "body": "                                                    {\n        RTree<Object, Rectangle> tree = create(3, 4);\n        assertEquals(2, tree.calculateDepth());\n    }", "signature": "@Test\n    public void testDepthWithMaxChildren3Entries4()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testDepthWithMaxChildren3Entries8() {\n        RTree<Object, Rectangle> tree = create(3, 8);\n        tree.visualize(800, 800).save(new File(\"target/treeLittle.png\"), \"PNG\");\n        assertEquals(3, tree.calculateDepth());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testDepthWithMaxChildren3Entries8", "params": [], "body": "                                                    {\n        RTree<Object, Rectangle> tree = create(3, 8);\n        tree.visualize(800, 800).save(new File(\"target/treeLittle.png\"), \"PNG\");\n        assertEquals(3, tree.calculateDepth());\n    }", "signature": "@Test\n    public void testDepthWithMaxChildren3Entries8()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testDepthWithMaxChildren3Entries10() {\n        RTree<Object, Rectangle> tree = create(3, 10);\n        assertEquals(3, tree.calculateDepth());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testDepthWithMaxChildren3Entries10", "params": [], "body": "                                                     {\n        RTree<Object, Rectangle> tree = create(3, 10);\n        assertEquals(3, tree.calculateDepth());\n    }", "signature": "@Test\n    public void testDepthWithMaxChildren3Entries10()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testSizeIsZeroIfTreeEmpty() {\n        assertEquals(0, create(3, 0).size());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testSizeIsZeroIfTreeEmpty", "params": [], "body": "                                            {\n        assertEquals(0, create(3, 0).size());\n    }", "signature": "@Test\n    public void testSizeIsZeroIfTreeEmpty()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testSizeIsOneIfTreeHasOneEntry() {\n        assertEquals(1, create(3, 1).size());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testSizeIsOneIfTreeHasOneEntry", "params": [], "body": "                                                 {\n        assertEquals(1, create(3, 1).size());\n    }", "signature": "@Test\n    public void testSizeIsOneIfTreeHasOneEntry()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testSizeIsFiveIfTreeHasFiveEntries() {\n        assertEquals(5, create(3, 5).size());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testSizeIsFiveIfTreeHasFiveEntries", "params": [], "body": "                                                     {\n        assertEquals(5, create(3, 5).size());\n    }", "signature": "@Test\n    public void testSizeIsFiveIfTreeHasFiveEntries()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testSizeAfterDelete() {\n        Entry<Object, Rectangle> entry = e(1);\n        RTree<Object, Rectangle> tree = create(3, 0).add(entry).add(entry).add(entry).delete(entry);\n        assertEquals(2, tree.size());\n\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testSizeAfterDelete", "params": [], "body": "                                      {\n        Entry<Object, Rectangle> entry = e(1);\n        RTree<Object, Rectangle> tree = create(3, 0).add(entry).add(entry).add(entry).delete(entry);\n        assertEquals(2, tree.size());\n\n    }", "signature": "@Test\n    public void testSizeAfterDelete()"}, {"syntax_pass": true, "original_string": "    @SuppressWarnings(\"unchecked\")\n    @Test\n    public void testDeletionThatRemovesAllNodesChildren() {\n        RTree<Object, Rectangle> tree = create(3, 8);\n        tree = tree.add(e(10));\n        // node children are now 1,2 and 3,4\n        assertEquals(3, tree.calculateDepth());\n        tree = tree.delete(e(10));\n        // node children are now 1,2 and 3\n        assertEquals(3, tree.calculateDepth());\n        assertEquals(Sets.newHashSet(e(1), e(2), e(3), e(4), e(5), e(6), e(7), e(8)),\n                Sets.newHashSet(tree.entries().toList().toBlocking().single()));\n    }", "docstring": "", "attributes": {"modifiers": "@SuppressWarnings(\"unchecked\")\n    @Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["@SuppressWarnings(\"unchecked\")", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "testDeletionThatRemovesAllNodesChildren", "params": [], "body": "                                                          {\n        RTree<Object, Rectangle> tree = create(3, 8);\n        tree = tree.add(e(10));\n        // node children are now 1,2 and 3,4\n        assertEquals(3, tree.calculateDepth());\n        tree = tree.delete(e(10));\n        // node children are now 1,2 and 3\n        assertEquals(3, tree.calculateDepth());\n        assertEquals(Sets.newHashSet(e(1), e(2), e(3), e(4), e(5), e(6), e(7), e(8)),\n                Sets.newHashSet(tree.entries().toList().toBlocking().single()));\n    }", "signature": "@SuppressWarnings(\"unchecked\")\n    @Test\n    public void testDeletionThatRemovesAllNodesChildren()"}, {"syntax_pass": true, "original_string": "    @SuppressWarnings(\"unchecked\")\n    @Test\n    public void testDeleteOfEntryThatDoesNotExistFromTreeOfOneEntry() {\n        RTree<Object, Geometry> tree = RTree.create().add(e(1));\n        tree = tree.delete(e(2));\n        assertEquals(Lists.newArrayList(e(1)), tree.entries().toList().toBlocking().single());\n    }", "docstring": "", "attributes": {"modifiers": "@SuppressWarnings(\"unchecked\")\n    @Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["@SuppressWarnings(\"unchecked\")", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "testDeleteOfEntryThatDoesNotExistFromTreeOfOneEntry", "params": [], "body": "                                                                      {\n        RTree<Object, Geometry> tree = RTree.create().add(e(1));\n        tree = tree.delete(e(2));\n        assertEquals(Lists.newArrayList(e(1)), tree.entries().toList().toBlocking().single());\n    }", "signature": "@SuppressWarnings(\"unchecked\")\n    @Test\n    public void testDeleteOfEntryThatDoesNotExistFromTreeOfOneEntry()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testDeleteFromEmptyTree() {\n        RTree<Object, Geometry> tree = RTree.create();\n        tree = tree.delete(e(2));\n        assertEquals(0, (int) tree.entries().count().toBlocking().single());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testDeleteFromEmptyTree", "params": [], "body": "                                          {\n        RTree<Object, Geometry> tree = RTree.create();\n        tree = tree.delete(e(2));\n        assertEquals(0, (int) tree.entries().count().toBlocking().single());\n    }", "signature": "@Test\n    public void testDeleteFromEmptyTree()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testBuilder1() {\n        RTree<Object, Point> tree = RTree.minChildren(1).maxChildren(4)\n                .selector(new SelectorMinimalAreaIncrease()).splitter(new SplitterQuadratic())\n                .create();\n        testBuiltTree(tree);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testBuilder1", "params": [], "body": "                               {\n        RTree<Object, Point> tree = RTree.minChildren(1).maxChildren(4)\n                .selector(new SelectorMinimalAreaIncrease()).splitter(new SplitterQuadratic())\n                .create();\n        testBuiltTree(tree);\n    }", "signature": "@Test\n    public void testBuilder1()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testDeletionOfEntryThatDoesNotExistFromNonLeaf() {\n        RTree<Object, Rectangle> tree = create(3, 100).delete(e(1000));\n        assertEquals(100, (int) tree.entries().count().toBlocking().single());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testDeletionOfEntryThatDoesNotExistFromNonLeaf", "params": [], "body": "                                                                 {\n        RTree<Object, Rectangle> tree = create(3, 100).delete(e(1000));\n        assertEquals(100, (int) tree.entries().count().toBlocking().single());\n    }", "signature": "@Test\n    public void testDeletionOfEntryThatDoesNotExistFromNonLeaf()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testBuilder2() {\n        RTree<Object, Point> tree = RTree.selector(new SelectorMinimalAreaIncrease()).minChildren(1)\n                .maxChildren(4).splitter(new SplitterQuadratic()).create();\n        testBuiltTree(tree);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testBuilder2", "params": [], "body": "                               {\n        RTree<Object, Point> tree = RTree.selector(new SelectorMinimalAreaIncrease()).minChildren(1)\n                .maxChildren(4).splitter(new SplitterQuadratic()).create();\n        testBuiltTree(tree);\n    }", "signature": "@Test\n    public void testBuilder2()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testBuilder3() {\n        RTree<Object, Point> tree = RTree.maxChildren(4).selector(new SelectorMinimalAreaIncrease())\n                .minChildren(1).splitter(new SplitterQuadratic()).create();\n        testBuiltTree(tree);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testBuilder3", "params": [], "body": "                               {\n        RTree<Object, Point> tree = RTree.maxChildren(4).selector(new SelectorMinimalAreaIncrease())\n                .minChildren(1).splitter(new SplitterQuadratic()).create();\n        testBuiltTree(tree);\n    }", "signature": "@Test\n    public void testBuilder3()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testBuilder4() {\n        RTree<Object, Point> tree = RTree.splitter(new SplitterQuadratic()).maxChildren(4)\n                .selector(new SelectorMinimalAreaIncrease()).minChildren(1).create();\n        testBuiltTree(tree);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testBuilder4", "params": [], "body": "                               {\n        RTree<Object, Point> tree = RTree.splitter(new SplitterQuadratic()).maxChildren(4)\n                .selector(new SelectorMinimalAreaIncrease()).minChildren(1).create();\n        testBuiltTree(tree);\n    }", "signature": "@Test\n    public void testBuilder4()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testBackpressureIterationForUpTo1000Entries() {\n        List<Entry<Object, Rectangle>> entries = Utilities.entries1000(Precision.SINGLE);\n        RTree<Object, Rectangle> tree = RTree.star().create();\n        for (int i = 1; i <= 1000; i++) {\n            tree = tree.add(entries.get(i - 1));\n            final HashSet<Entry<Object, Rectangle>> set = new HashSet<Entry<Object, Rectangle>>();\n            tree.entries().subscribe(createBackpressureSubscriber(set));\n            assertEquals(new HashSet<Entry<Object, Rectangle>>(entries.subList(0, i)), set);\n        }\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testBackpressureIterationForUpTo1000Entries", "params": [], "body": "                                                              {\n        List<Entry<Object, Rectangle>> entries = Utilities.entries1000(Precision.SINGLE);\n        RTree<Object, Rectangle> tree = RTree.star().create();\n        for (int i = 1; i <= 1000; i++) {\n            tree = tree.add(entries.get(i - 1));\n            final HashSet<Entry<Object, Rectangle>> set = new HashSet<Entry<Object, Rectangle>>();\n            tree.entries().subscribe(createBackpressureSubscriber(set));\n            assertEquals(new HashSet<Entry<Object, Rectangle>>(entries.subList(0, i)), set);\n        }\n    }", "signature": "@Test\n    public void testBackpressureIterationForUpTo1000Entries()"}, {"syntax_pass": true, "original_string": "    private static <T extends Geometry> Subscriber<Entry<Object, T>> createBackpressureSubscriber(\n            final Collection<Entry<Object, T>> collection) {\n        return new Subscriber<Entry<Object, T>>() {\n\n            @Override\n            public void onStart() {\n                request(1);\n            }\n\n            @Override\n            public void onCompleted() {\n            }\n\n            @Override\n            public void onError(Throwable e) {\n            }\n\n            @Override\n            public void onNext(Entry<Object, T> t) {\n                collection.add(t);\n                request(1);\n            }\n        };\n    }", "docstring": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "Subscriber<Entry<Object, T>>", "classes": []}, "name": "createBackpressureSubscriber", "params": [{"name": "collection", "type": "Collection<Entry<Object, T>>"}], "body": "                                                           {\n        return new Subscriber<Entry<Object, T>>() {\n\n            @Override\n            public void onStart() {\n                request(1);\n            }\n\n            @Override\n            public void onCompleted() {\n            }\n\n            @Override\n            public void onError(Throwable e) {\n            }\n\n            @Override\n            public void onNext(Entry<Object, T> t) {\n                collection.add(t);\n                request(1);\n            }\n        };\n    }", "signature": "private static <T extends Geometry> Subscriber<Entry<Object, T>> createBackpressureSubscriber(\n            final Collection<Entry<Object, T>> collection)"}, {"syntax_pass": true, "original_string": "    private void testBuiltTree(RTree<Object, Point> tree) {\n        for (int i = 1; i <= 1000; i++) {\n            tree = tree.add(i, Geometries.point(i, i));\n        }\n        assertEquals(1000, (int) tree.entries().count().toBlocking().single());\n    }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "name": "testBuiltTree", "params": [{"name": "tree", "type": "RTree<Object, Point>"}], "body": "                                                          {\n        for (int i = 1; i <= 1000; i++) {\n            tree = tree.add(i, Geometries.point(i, i));\n        }\n        assertEquals(1000, (int) tree.entries().count().toBlocking().single());\n    }", "signature": "private void testBuiltTree(RTree<Object, Point> tree)"}, {"syntax_pass": true, "original_string": "    private static RTree<Object, Rectangle> create(int maxChildren, int n) {\n        RTree<Object, Rectangle> tree = RTree.maxChildren(maxChildren).create();\n        for (int i = 1; i <= n; i++)\n            tree = tree.add(e(i));\n        return tree;\n    }", "docstring": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "RTree<Object, Rectangle>", "classes": []}, "name": "create", "params": [{"name": "maxChildren", "type": "int"}, {"name": "n", "type": "int"}], "body": "                                                                           {\n        RTree<Object, Rectangle> tree = RTree.maxChildren(maxChildren).create();\n        for (int i = 1; i <= n; i++)\n            tree = tree.add(e(i));\n        return tree;\n    }", "signature": "private static RTree<Object, Rectangle> create(int maxChildren, int n)"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testNearestSameDirection() {\n        RTree<Object, Rectangle> tree = RTree.maxChildren(4).<Object, Rectangle>create().add(e(1))\n                .add(e(2)).add(e(3)).add(e(10)).add(e(11));\n        List<Entry<Object, Rectangle>> list = tree.nearest(r(9), 10, 2).toList().toBlocking()\n                .single();\n        assertEquals(2, list.size());\n        System.out.println(list);\n        assertEquals(10, list.get(0).geometry().mbr().x1(), PRECISION);\n        assertEquals(11, list.get(1).geometry().mbr().x1(), PRECISION);\n\n        List<Entry<Object, Rectangle>> list2 = tree.nearest(r(10), 8, 3).toList().toBlocking()\n                .single();\n        assertEquals(2, list2.size());\n        assertEquals(10, list2.get(1).geometry().mbr().x1(), PRECISION);\n        assertEquals(11, list2.get(0).geometry().mbr().x1(), PRECISION);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testNearestSameDirection", "params": [], "body": "                                           {\n        RTree<Object, Rectangle> tree = RTree.maxChildren(4).<Object, Rectangle>create().add(e(1))\n                .add(e(2)).add(e(3)).add(e(10)).add(e(11));\n        List<Entry<Object, Rectangle>> list = tree.nearest(r(9), 10, 2).toList().toBlocking()\n                .single();\n        assertEquals(2, list.size());\n        System.out.println(list);\n        assertEquals(10, list.get(0).geometry().mbr().x1(), PRECISION);\n        assertEquals(11, list.get(1).geometry().mbr().x1(), PRECISION);\n\n        List<Entry<Object, Rectangle>> list2 = tree.nearest(r(10), 8, 3).toList().toBlocking()\n                .single();\n        assertEquals(2, list2.size());\n        assertEquals(10, list2.get(1).geometry().mbr().x1(), PRECISION);\n        assertEquals(11, list2.get(0).geometry().mbr().x1(), PRECISION);\n    }", "signature": "@Test\n    public void testNearestSameDirection()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testNearestDifferentDirections() {\n        RTree<Object, Geometry> tree = RTree.maxChildren(4).create().add(e(1)).add(e(2)).add(e(3))\n                .add(e(9)).add(e(10));\n        List<Entry<Object, Geometry>> list = tree.nearest(r(6), 10, 2).toList().toBlocking()\n                .single();\n        assertEquals(2, list.size());\n        assertEquals(3, list.get(0).geometry().mbr().x1(), PRECISION);\n        assertEquals(9, list.get(1).geometry().mbr().x1(), PRECISION);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testNearestDifferentDirections", "params": [], "body": "                                                 {\n        RTree<Object, Geometry> tree = RTree.maxChildren(4).create().add(e(1)).add(e(2)).add(e(3))\n                .add(e(9)).add(e(10));\n        List<Entry<Object, Geometry>> list = tree.nearest(r(6), 10, 2).toList().toBlocking()\n                .single();\n        assertEquals(2, list.size());\n        assertEquals(3, list.get(0).geometry().mbr().x1(), PRECISION);\n        assertEquals(9, list.get(1).geometry().mbr().x1(), PRECISION);\n    }", "signature": "@Test\n    public void testNearestDifferentDirections()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testNearestToAPoint() {\n        Object value = new Object();\n        RTree<Object, Geometry> tree = RTree.create().add(value, point(1, 1));\n        List<Entry<Object, Geometry>> list = tree.nearest(point(2, 2), 3, 2).toList().toBlocking()\n                .single();\n        assertEquals(1, list.size());\n        assertEquals(value, list.get(0).value());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testNearestToAPoint", "params": [], "body": "                                      {\n        Object value = new Object();\n        RTree<Object, Geometry> tree = RTree.create().add(value, point(1, 1));\n        List<Entry<Object, Geometry>> list = tree.nearest(point(2, 2), 3, 2).toList().toBlocking()\n                .single();\n        assertEquals(1, list.size());\n        assertEquals(value, list.get(0).value());\n    }", "signature": "@Test\n    public void testNearestToAPoint()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testNearestReturnsInOrder() {\n        Object value = new Object();\n        RTree<Object, Geometry> tree = RTree.create().add(value, point(1, 1))\n                .add(value, point(2, 2)).add(value, point(3, 3)).add(value, point(4, 4));\n        List<Entry<Object, Geometry>> list = tree.nearest(point(0, 0), 10, 10).toList().toBlocking()\n                .single();\n        System.out.println(list);\n        assertEquals(4, list.size());\n        assertEquals(point(1, 1), list.get(0).geometry());\n        assertEquals(point(2, 2), list.get(1).geometry());\n        assertEquals(point(3, 3), list.get(2).geometry());\n        assertEquals(point(4, 4), list.get(3).geometry());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testNearestReturnsInOrder", "params": [], "body": "                                            {\n        Object value = new Object();\n        RTree<Object, Geometry> tree = RTree.create().add(value, point(1, 1))\n                .add(value, point(2, 2)).add(value, point(3, 3)).add(value, point(4, 4));\n        List<Entry<Object, Geometry>> list = tree.nearest(point(0, 0), 10, 10).toList().toBlocking()\n                .single();\n        System.out.println(list);\n        assertEquals(4, list.size());\n        assertEquals(point(1, 1), list.get(0).geometry());\n        assertEquals(point(2, 2), list.get(1).geometry());\n        assertEquals(point(3, 3), list.get(2).geometry());\n        assertEquals(point(4, 4), list.get(3).geometry());\n    }", "signature": "@Test\n    public void testNearestReturnsInOrder()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testNearestHonoursUnsubscribeJustBeforeCompletion() {\n        Object value = new Object();\n        RTree<Object, Geometry> tree = RTree.create().add(value, point(1, 1));\n        final AtomicBoolean completeCalled = new AtomicBoolean(false);\n        tree.nearest(point(0, 0), 10, 10).subscribe(new Subscriber<Object>() {\n\n            @Override\n            public void onCompleted() {\n                completeCalled.set(true);\n            }\n\n            @Override\n            public void onError(Throwable e) {\n\n            }\n\n            @Override\n            public void onNext(Object t) {\n                unsubscribe();\n            }\n        });\n        assertFalse(completeCalled.get());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testNearestHonoursUnsubscribeJustBeforeCompletion", "params": [], "body": "                                                                    {\n        Object value = new Object();\n        RTree<Object, Geometry> tree = RTree.create().add(value, point(1, 1));\n        final AtomicBoolean completeCalled = new AtomicBoolean(false);\n        tree.nearest(point(0, 0), 10, 10).subscribe(new Subscriber<Object>() {\n\n            @Override\n            public void onCompleted() {\n                completeCalled.set(true);\n            }\n\n            @Override\n            public void onError(Throwable e) {\n\n            }\n\n            @Override\n            public void onNext(Object t) {\n                unsubscribe();\n            }\n        });\n        assertFalse(completeCalled.get());\n    }", "signature": "@Test\n    public void testNearestHonoursUnsubscribeJustBeforeCompletion()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testVisualizer() {\n        List<Entry<Object, Geometry>> entries = createRandomEntries(1000);\n        int maxChildren = 8;\n        RTree<Object, Geometry> tree = RTree.maxChildren(maxChildren).create().add(entries);\n        tree.visualize(600, 600).save(\"target/tree.png\");\n\n        RTree<Object, Geometry> tree2 = RTree.star().maxChildren(maxChildren).create().add(entries);\n        tree2.visualize(600, 600).save(\"target/tree2.png\");\n\n        RTree<Object, Geometry> tree3 = RTree.maxChildren(maxChildren).create(entries);\n        tree3.visualize(600, 600).save(\"target/tree3.png\");\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testVisualizer", "params": [], "body": "                                 {\n        List<Entry<Object, Geometry>> entries = createRandomEntries(1000);\n        int maxChildren = 8;\n        RTree<Object, Geometry> tree = RTree.maxChildren(maxChildren).create().add(entries);\n        tree.visualize(600, 600).save(\"target/tree.png\");\n\n        RTree<Object, Geometry> tree2 = RTree.star().maxChildren(maxChildren).create().add(entries);\n        tree2.visualize(600, 600).save(\"target/tree2.png\");\n\n        RTree<Object, Geometry> tree3 = RTree.maxChildren(maxChildren).create(entries);\n        tree3.visualize(600, 600).save(\"target/tree3.png\");\n    }", "signature": "@Test\n    public void testVisualizer()"}, {"syntax_pass": true, "original_string": "    @Test(expected = RuntimeException.class)\n    public void testSplitterRStarThrowsExceptionOnEmptyList() {\n        SplitterRStar spl = new SplitterRStar();\n        spl.split(Collections.<HasGeometry>emptyList(), 4);\n    }", "docstring": "", "attributes": {"modifiers": "@Test(expected = RuntimeException.class)\n    public", "marker_annotations": [], "non_marker_annotations": ["@Test(expected = RuntimeException.class)", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "testSplitterRStarThrowsExceptionOnEmptyList", "params": [], "body": "                                                              {\n        SplitterRStar spl = new SplitterRStar();\n        spl.split(Collections.<HasGeometry>emptyList(), 4);\n    }", "signature": "@Test(expected = RuntimeException.class)\n    public void testSplitterRStarThrowsExceptionOnEmptyList()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testSearchOnGreekDataUsingFlatBuffersFactory() {\n\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testSearchOnGreekDataUsingFlatBuffersFactory", "params": [], "body": "                                                               {\n\n    }", "signature": "@Test\n    public void testSearchOnGreekDataUsingFlatBuffersFactory()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testVisualizerWithGreekData() {\n        List<Entry<Object, Point>> entries = GreekEarthquakes.entriesList(Precision.DOUBLE);\n        int maxChildren = 8;\n        RTree<Object, Point> tree = RTree.maxChildren(maxChildren)\n                .factory(new FactoryFlatBuffers<Object, Geometry>(new Func1<Object, byte[]>() {\n                    @Override\n                    public byte[] call(Object o) {\n                        return \"boo\".getBytes();\n                    }\n                }, new Func1<byte[], Object>() {\n                    @Override\n                    public Object call(byte[] t) {\n                        return new String(t);\n                    }\n                })).<Object, Point>create().add(entries);\n        tree.visualize(2000, 2000).save(\"target/greek.png\");\n\n        // do search\n        int found = tree.search(Geometries.rectangle(40, 27.0, 40.5, 27.5)).count().toBlocking()\n                .single();\n        System.out.println(\"found=\" + found);\n        assertEquals(22, found);\n\n        RTree<Object, Point> tree2 = RTree.maxChildren(maxChildren).star().<Object, Point>create()\n                .add(entries);\n        tree2.visualize(2000, 2000).save(\"target/greek2.png\");\n\n        RTree<Object, Point> tree3 = RTree.maxChildren(maxChildren).create(entries);\n        tree3.visualize(2000, 2000).save(\"target/greek3.png\");\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testVisualizerWithGreekData", "params": [], "body": "                                              {\n        List<Entry<Object, Point>> entries = GreekEarthquakes.entriesList(Precision.DOUBLE);\n        int maxChildren = 8;\n        RTree<Object, Point> tree = RTree.maxChildren(maxChildren)\n                .factory(new FactoryFlatBuffers<Object, Geometry>(new Func1<Object, byte[]>() {\n                    @Override\n                    public byte[] call(Object o) {\n                        return \"boo\".getBytes();\n                    }\n                }, new Func1<byte[], Object>() {\n                    @Override\n                    public Object call(byte[] t) {\n                        return new String(t);\n                    }\n                })).<Object, Point>create().add(entries);\n        tree.visualize(2000, 2000).save(\"target/greek.png\");\n\n        // do search\n        int found = tree.search(Geometries.rectangle(40, 27.0, 40.5, 27.5)).count().toBlocking()\n                .single();\n        System.out.println(\"found=\" + found);\n        assertEquals(22, found);\n\n        RTree<Object, Point> tree2 = RTree.maxChildren(maxChildren).star().<Object, Point>create()\n                .add(entries);\n        tree2.visualize(2000, 2000).save(\"target/greek2.png\");\n\n        RTree<Object, Point> tree3 = RTree.maxChildren(maxChildren).create(entries);\n        tree3.visualize(2000, 2000).save(\"target/greek3.png\");\n    }", "signature": "@Test\n    public void testVisualizerWithGreekData()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testDeleteOneFromOne() {\n        Entry<Object, Rectangle> e1 = e(1);\n        RTree<Object, Rectangle> tree = RTree.maxChildren(4).<Object, Rectangle>create().add(e1)\n                .delete(e1);\n        assertEquals(0, (int) tree.entries().count().toBlocking().single());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testDeleteOneFromOne", "params": [], "body": "                                       {\n        Entry<Object, Rectangle> e1 = e(1);\n        RTree<Object, Rectangle> tree = RTree.maxChildren(4).<Object, Rectangle>create().add(e1)\n                .delete(e1);\n        assertEquals(0, (int) tree.entries().count().toBlocking().single());\n    }", "signature": "@Test\n    public void testDeleteOneFromOne()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testDeleteOneFromTreeWithDepthGreaterThanOne() {\n        Entry<Object, Rectangle> e1 = e(1);\n        RTree<Object, Rectangle> tree = RTree.maxChildren(4).<Object, Rectangle>create().add(e1)\n                .add(e(2)).add(e(3)).add(e(4)).add(e(5)).add(e(6)).add(e(7)).add(e(8)).add(e(9))\n                .add(e(10)).delete(e1);\n        assertEquals(9, (int) tree.entries().count().toBlocking().single());\n        assertFalse(tree.entries().contains(e1).toBlocking().single());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testDeleteOneFromTreeWithDepthGreaterThanOne", "params": [], "body": "                                                               {\n        Entry<Object, Rectangle> e1 = e(1);\n        RTree<Object, Rectangle> tree = RTree.maxChildren(4).<Object, Rectangle>create().add(e1)\n                .add(e(2)).add(e(3)).add(e(4)).add(e(5)).add(e(6)).add(e(7)).add(e(8)).add(e(9))\n                .add(e(10)).delete(e1);\n        assertEquals(9, (int) tree.entries().count().toBlocking().single());\n        assertFalse(tree.entries().contains(e1).toBlocking().single());\n    }", "signature": "@Test\n    public void testDeleteOneFromTreeWithDepthGreaterThanOne()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testDeleteOneFromLargeTreeThenDeleteAllAndEnsureEmpty() {\n        int n = 10000;\n        RTree<Object, Geometry> tree = createRandomRTree(n).add(e(1)).add(e(2)).delete(e(1));\n        assertEquals(n + 1, (int) tree.entries().count().toBlocking().single());\n        assertFalse(tree.entries().contains(e(1)).toBlocking().single());\n        assertTrue(tree.entries().contains(e(2)).toBlocking().single());\n        n++;\n        assertEquals(n, tree.size());\n\n        for (Entry<Object, Geometry> entry : tree.entries().toBlocking().toIterable()) {\n            tree = tree.delete(entry);\n            n--;\n            assertEquals(n, tree.size());\n        }\n        assertEquals(0, (int) tree.entries().count().toBlocking().single());\n        assertTrue(tree.isEmpty());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testDeleteOneFromLargeTreeThenDeleteAllAndEnsureEmpty", "params": [], "body": "                                                                        {\n        int n = 10000;\n        RTree<Object, Geometry> tree = createRandomRTree(n).add(e(1)).add(e(2)).delete(e(1));\n        assertEquals(n + 1, (int) tree.entries().count().toBlocking().single());\n        assertFalse(tree.entries().contains(e(1)).toBlocking().single());\n        assertTrue(tree.entries().contains(e(2)).toBlocking().single());\n        n++;\n        assertEquals(n, tree.size());\n\n        for (Entry<Object, Geometry> entry : tree.entries().toBlocking().toIterable()) {\n            tree = tree.delete(entry);\n            n--;\n            assertEquals(n, tree.size());\n        }\n        assertEquals(0, (int) tree.entries().count().toBlocking().single());\n        assertTrue(tree.isEmpty());\n    }", "signature": "@Test\n    public void testDeleteOneFromLargeTreeThenDeleteAllAndEnsureEmpty()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testDeleteOnlyDeleteOneIfThereAreMoreThanMaxChildren() {\n        Entry<Object, Rectangle> e1 = e(1);\n        int count = RTree.maxChildren(4).create().add(e1).add(e1).add(e1).add(e1).add(e1).delete(e1)\n                .search(e1.geometry().mbr()).count().toBlocking().single();\n        assertEquals(4, count);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testDeleteOnlyDeleteOneIfThereAreMoreThanMaxChildren", "params": [], "body": "                                                                       {\n        Entry<Object, Rectangle> e1 = e(1);\n        int count = RTree.maxChildren(4).create().add(e1).add(e1).add(e1).add(e1).add(e1).delete(e1)\n                .search(e1.geometry().mbr()).count().toBlocking().single();\n        assertEquals(4, count);\n    }", "signature": "@Test\n    public void testDeleteOnlyDeleteOneIfThereAreMoreThanMaxChildren()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testDeleteAllIfThereAreMoreThanMaxChildren() {\n        Entry<Object, Rectangle> e1 = e(1);\n        int count = RTree.maxChildren(4).create().add(e1).add(e1).add(e1).add(e1).add(e1)\n                .delete(e1, true).search(e1.geometry().mbr()).count().toBlocking().single();\n        assertEquals(0, count);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testDeleteAllIfThereAreMoreThanMaxChildren", "params": [], "body": "                                                             {\n        Entry<Object, Rectangle> e1 = e(1);\n        int count = RTree.maxChildren(4).create().add(e1).add(e1).add(e1).add(e1).add(e1)\n                .delete(e1, true).search(e1.geometry().mbr()).count().toBlocking().single();\n        assertEquals(0, count);\n    }", "signature": "@Test\n    public void testDeleteAllIfThereAreMoreThanMaxChildren()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testDeleteItemThatIsNotPresentDoesNothing() {\n        Entry<Object, Rectangle> e1 = e(1);\n        Entry<Object, Rectangle> e2 = e(2);\n        RTree<Object, Rectangle> tree = RTree.<Object, Rectangle>create().add(e1);\n        assertTrue(tree == tree.delete(e2));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testDeleteItemThatIsNotPresentDoesNothing", "params": [], "body": "                                                            {\n        Entry<Object, Rectangle> e1 = e(1);\n        Entry<Object, Rectangle> e2 = e(2);\n        RTree<Object, Rectangle> tree = RTree.<Object, Rectangle>create().add(e1);\n        assertTrue(tree == tree.delete(e2));\n    }", "signature": "@Test\n    public void testDeleteItemThatIsNotPresentDoesNothing()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testExampleOnReadMe() {\n        RTree<String, Geometry> tree = RTree.maxChildren(5).create();\n        tree = tree.add(entry(\"DAVE\", point(10, 20))).add(entry(\"FRED\", point(12, 25)))\n                .add(entry(\"MARY\", point(97, 125)));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testExampleOnReadMe", "params": [], "body": "                                      {\n        RTree<String, Geometry> tree = RTree.maxChildren(5).create();\n        tree = tree.add(entry(\"DAVE\", point(10, 20))).add(entry(\"FRED\", point(12, 25)))\n                .add(entry(\"MARY\", point(97, 125)));\n    }", "signature": "@Test\n    public void testExampleOnReadMe()"}, {"syntax_pass": true, "original_string": "    @Test(timeout = 2000)\n    public void testUnsubscribe() {\n        RTree<Object, Geometry> tree = createRandomRTree(1000);\n        assertEquals(0, (int) tree.entries().take(0).count().toBlocking().single());\n    }", "docstring": "", "attributes": {"modifiers": "@Test(timeout = 2000)\n    public", "marker_annotations": [], "non_marker_annotations": ["@Test(timeout = 2000)", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "testUnsubscribe", "params": [], "body": "                                  {\n        RTree<Object, Geometry> tree = createRandomRTree(1000);\n        assertEquals(0, (int) tree.entries().take(0).count().toBlocking().single());\n    }", "signature": "@Test(timeout = 2000)\n    public void testUnsubscribe()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testSearchConditionAlwaysFalse() {\n        @SuppressWarnings(\"unchecked\")\n        RTree<Object, Geometry> tree = (RTree<Object, Geometry>) (RTree<?, ?>) create(3, 3);\n        assertEquals(0, (int) tree.search(Functions.alwaysFalse()).count().toBlocking().single());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testSearchConditionAlwaysFalse", "params": [], "body": "                                                 {\n        @SuppressWarnings(\"unchecked\")\n        RTree<Object, Geometry> tree = (RTree<Object, Geometry>) (RTree<?, ?>) create(3, 3);\n        assertEquals(0, (int) tree.search(Functions.alwaysFalse()).count().toBlocking().single());\n    }", "signature": "@Test\n    public void testSearchConditionAlwaysFalse()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testAddOverload() {\n        @SuppressWarnings(\"unchecked\")\n        RTree<Object, Geometry> tree = (RTree<Object, Geometry>) (RTree<?, ?>) create(3, 0);\n        tree = tree.add(123, Geometries.point(1, 2));\n        assertEquals(1, (int) tree.entries().count().toBlocking().single());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testAddOverload", "params": [], "body": "                                  {\n        @SuppressWarnings(\"unchecked\")\n        RTree<Object, Geometry> tree = (RTree<Object, Geometry>) (RTree<?, ?>) create(3, 0);\n        tree = tree.add(123, Geometries.point(1, 2));\n        assertEquals(1, (int) tree.entries().count().toBlocking().single());\n    }", "signature": "@Test\n    public void testAddOverload()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testDeleteOverload() {\n        @SuppressWarnings(\"unchecked\")\n        RTree<Object, Geometry> tree = (RTree<Object, Geometry>) (RTree<?, ?>) create(3, 0);\n        tree = tree.add(123, Geometries.point(1, 2)).delete(123, Geometries.point(1, 2));\n        assertEquals(0, (int) tree.entries().count().toBlocking().single());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testDeleteOverload", "params": [], "body": "                                     {\n        @SuppressWarnings(\"unchecked\")\n        RTree<Object, Geometry> tree = (RTree<Object, Geometry>) (RTree<?, ?>) create(3, 0);\n        tree = tree.add(123, Geometries.point(1, 2)).delete(123, Geometries.point(1, 2));\n        assertEquals(0, (int) tree.entries().count().toBlocking().single());\n    }", "signature": "@Test\n    public void testDeleteOverload()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testStandardRTreeSearch() {\n        Rectangle r = rectangle(13.0, 23.0, 50.0, 80.0);\n        Point[] points = { point(59.0, 91.0), point(86.0, 14.0), point(36.0, 60.0),\n                point(57.0, 36.0), point(14.0, 37.0) };\n\n        RTree<Integer, Geometry> tree = RTree.create();\n        for (int i = 0; i < points.length; i++) {\n            Point point = points[i];\n            System.out.println(\"point(\" + point.x() + \",\" + point.y() + \"), value=\" + (i + 1));\n            tree = tree.add(i + 1, point);\n        }\n        System.out.println(tree.asString());\n        System.out.println(\"searching \" + r);\n        Set<Integer> set = new HashSet<Integer>(\n                tree.search(r).map(RTreeTest.<Integer>toValue()).toList().toBlocking().single());\n        assertEquals(new HashSet<Integer>(asList(3, 5)), set);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testStandardRTreeSearch", "params": [], "body": "                                          {\n        Rectangle r = rectangle(13.0, 23.0, 50.0, 80.0);\n        Point[] points = { point(59.0, 91.0), point(86.0, 14.0), point(36.0, 60.0),\n                point(57.0, 36.0), point(14.0, 37.0) };\n\n        RTree<Integer, Geometry> tree = RTree.create();\n        for (int i = 0; i < points.length; i++) {\n            Point point = points[i];\n            System.out.println(\"point(\" + point.x() + \",\" + point.y() + \"), value=\" + (i + 1));\n            tree = tree.add(i + 1, point);\n        }\n        System.out.println(tree.asString());\n        System.out.println(\"searching \" + r);\n        Set<Integer> set = new HashSet<Integer>(\n                tree.search(r).map(RTreeTest.<Integer>toValue()).toList().toBlocking().single());\n        assertEquals(new HashSet<Integer>(asList(3, 5)), set);\n    }", "signature": "@Test\n    public void testStandardRTreeSearch()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testStandardRTreeSearch2() {\n        Rectangle r = rectangle(10.0, 10.0, 50.0, 50.0);\n        Point[] points = { point(28.0, 19.0), point(29.0, 4.0), point(10.0, 63.0),\n                point(34.0, 85.0), point(62.0, 45.0) };\n\n        RTree<Integer, Geometry> tree = RTree.create();\n        for (int i = 0; i < points.length; i++) {\n            Point point = points[i];\n            System.out.println(\"point(\" + point.x() + \",\" + point.y() + \"), value=\" + (i + 1));\n            tree = tree.add(i + 1, point);\n        }\n        System.out.println(tree.asString());\n        System.out.println(\"searching \" + r);\n        Set<Integer> set = new HashSet<Integer>(\n                tree.search(r).map(RTreeTest.<Integer>toValue()).toList().toBlocking().single());\n        assertEquals(new HashSet<Integer>(asList(1)), set);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testStandardRTreeSearch2", "params": [], "body": "                                           {\n        Rectangle r = rectangle(10.0, 10.0, 50.0, 50.0);\n        Point[] points = { point(28.0, 19.0), point(29.0, 4.0), point(10.0, 63.0),\n                point(34.0, 85.0), point(62.0, 45.0) };\n\n        RTree<Integer, Geometry> tree = RTree.create();\n        for (int i = 0; i < points.length; i++) {\n            Point point = points[i];\n            System.out.println(\"point(\" + point.x() + \",\" + point.y() + \"), value=\" + (i + 1));\n            tree = tree.add(i + 1, point);\n        }\n        System.out.println(tree.asString());\n        System.out.println(\"searching \" + r);\n        Set<Integer> set = new HashSet<Integer>(\n                tree.search(r).map(RTreeTest.<Integer>toValue()).toList().toBlocking().single());\n        assertEquals(new HashSet<Integer>(asList(1)), set);\n    }", "signature": "@Test\n    public void testStandardRTreeSearch2()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testBulkLoadingTreeAndStarTreeReturnsSameAsStandardRTree() {\n\n        RTree<Integer, Geometry> tree1 = RTree.create();\n        RTree<Integer, Geometry> tree2 = RTree.star().create();\n\n        Rectangle[] testRects = { rectangle(0, 0, 0, 0), rectangle(0, 0, 100, 100),\n                rectangle(0, 0, 10, 10), rectangle(0.12, 0.25, 50.356, 50.756),\n                rectangle(1, 0.252, 50, 69.23), rectangle(13.12, 23.123, 50.45, 80.9),\n                rectangle(10, 10, 50, 50) };\n\n        List<Entry<Integer, Geometry>> entries = new ArrayList<Entry<Integer, Geometry>>(10000);\n        for (int i = 1; i <= 10000; i++) {\n            Point point = nextPoint();\n            // System.out.println(\"point(\" + point.x() + \",\" + point.y() +\n            // \"),\");\n            tree1 = tree1.add(i, point);\n            tree2 = tree2.add(i, point);\n            entries.add(new EntryDefault<Integer, Geometry>(i, point));\n        }\n        RTree<Integer, Geometry> tree3 = RTree.create(entries);\n\n        // tree2.visualize(2000, 2000).save(\"target/tree22.png\");\n        // tree3.visualize(2000, 2000).save(\"target/tree33.png\");\n\n        for (Rectangle r : testRects) {\n            Set<Integer> res1 = new HashSet<Integer>(tree1.search(r)\n                    .map(RTreeTest.<Integer>toValue()).toList().toBlocking().single());\n            Set<Integer> res2 = new HashSet<Integer>(tree2.search(r)\n                    .map(RTreeTest.<Integer>toValue()).toList().toBlocking().single());\n            Set<Integer> res3 = new HashSet<Integer>(tree3.search(r)\n                    .map(RTreeTest.<Integer>toValue()).toList().toBlocking().single());\n            System.out.println(\"searchRect= rectangle(\" + r.x1() + \",\" + r.y1() + \",\" + r.x2() + \",\"\n                    + r.y2() + \")\");\n            System.out.println(\"res1.size=\" + res1.size() + \",res2.size=\" + res2.size()\n                    + \",res3.size=\" + res3.size());\n            // System.out.println(\"res1=\" + res1 + \",res2=\" + res2 + \",res3=\" + res3);\n            assertEquals(res1.size(), res2.size());\n            assertEquals(res1.size(), res3.size());\n        }\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testBulkLoadingTreeAndStarTreeReturnsSameAsStandardRTree", "params": [], "body": "                                                                           {\n\n        RTree<Integer, Geometry> tree1 = RTree.create();\n        RTree<Integer, Geometry> tree2 = RTree.star().create();\n\n        Rectangle[] testRects = { rectangle(0, 0, 0, 0), rectangle(0, 0, 100, 100),\n                rectangle(0, 0, 10, 10), rectangle(0.12, 0.25, 50.356, 50.756),\n                rectangle(1, 0.252, 50, 69.23), rectangle(13.12, 23.123, 50.45, 80.9),\n                rectangle(10, 10, 50, 50) };\n\n        List<Entry<Integer, Geometry>> entries = new ArrayList<Entry<Integer, Geometry>>(10000);\n        for (int i = 1; i <= 10000; i++) {\n            Point point = nextPoint();\n            // System.out.println(\"point(\" + point.x() + \",\" + point.y() +\n            // \"),\");\n            tree1 = tree1.add(i, point);\n            tree2 = tree2.add(i, point);\n            entries.add(new EntryDefault<Integer, Geometry>(i, point));\n        }\n        RTree<Integer, Geometry> tree3 = RTree.create(entries);\n\n        // tree2.visualize(2000, 2000).save(\"target/tree22.png\");\n        // tree3.visualize(2000, 2000).save(\"target/tree33.png\");\n\n        for (Rectangle r : testRects) {\n            Set<Integer> res1 = new HashSet<Integer>(tree1.search(r)\n                    .map(RTreeTest.<Integer>toValue()).toList().toBlocking().single());\n            Set<Integer> res2 = new HashSet<Integer>(tree2.search(r)\n                    .map(RTreeTest.<Integer>toValue()).toList().toBlocking().single());\n            Set<Integer> res3 = new HashSet<Integer>(tree3.search(r)\n                    .map(RTreeTest.<Integer>toValue()).toList().toBlocking().single());\n            System.out.println(\"searchRect= rectangle(\" + r.x1() + \",\" + r.y1() + \",\" + r.x2() + \",\"\n                    + r.y2() + \")\");\n            System.out.println(\"res1.size=\" + res1.size() + \",res2.size=\" + res2.size()\n                    + \",res3.size=\" + res3.size());\n            // System.out.println(\"res1=\" + res1 + \",res2=\" + res2 + \",res3=\" + res3);\n            assertEquals(res1.size(), res2.size());\n            assertEquals(res1.size(), res3.size());\n        }\n    }", "signature": "@Test\n    public void testBulkLoadingTreeAndStarTreeReturnsSameAsStandardRTree()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testUnsubscribeWhileIteratingLeafNode() {\n        RTree<Object, Rectangle> tree = RTree.maxChildren(5).<Object, Rectangle>create().add(e(1))\n                .add(e(2));\n        tree.entries().subscribe(new Subscriber<Object>() {\n\n            @Override\n            public void onCompleted() {\n\n            }\n\n            @Override\n            public void onError(Throwable e) {\n            }\n\n            @Override\n            public void onNext(Object t) {\n                unsubscribe();\n            }\n        });\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testUnsubscribeWhileIteratingLeafNode", "params": [], "body": "                                                        {\n        RTree<Object, Rectangle> tree = RTree.maxChildren(5).<Object, Rectangle>create().add(e(1))\n                .add(e(2));\n        tree.entries().subscribe(new Subscriber<Object>() {\n\n            @Override\n            public void onCompleted() {\n\n            }\n\n            @Override\n            public void onError(Throwable e) {\n            }\n\n            @Override\n            public void onNext(Object t) {\n                unsubscribe();\n            }\n        });\n    }", "signature": "@Test\n    public void testUnsubscribeWhileIteratingLeafNode()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testUnsubscribeWhileIteratingNonLeafNode() {\n        final AtomicBoolean completed = new AtomicBoolean(false);\n        RTree<Object, Rectangle> tree = RTree.maxChildren(3).<Object, Rectangle>create().add(e(1))\n                .add(e(2)).add(e(3)).add(e(4));\n        tree.entries().subscribe(new Subscriber<Object>() {\n\n            @Override\n            public void onCompleted() {\n                completed.set(true);\n            }\n\n            @Override\n            public void onError(Throwable e) {\n            }\n\n            @Override\n            public void onNext(Object t) {\n                unsubscribe();\n            }\n        });\n        assertFalse(completed.get());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testUnsubscribeWhileIteratingNonLeafNode", "params": [], "body": "                                                           {\n        final AtomicBoolean completed = new AtomicBoolean(false);\n        RTree<Object, Rectangle> tree = RTree.maxChildren(3).<Object, Rectangle>create().add(e(1))\n                .add(e(2)).add(e(3)).add(e(4));\n        tree.entries().subscribe(new Subscriber<Object>() {\n\n            @Override\n            public void onCompleted() {\n                completed.set(true);\n            }\n\n            @Override\n            public void onError(Throwable e) {\n            }\n\n            @Override\n            public void onNext(Object t) {\n                unsubscribe();\n            }\n        });\n        assertFalse(completed.get());\n    }", "signature": "@Test\n    public void testUnsubscribeWhileIteratingNonLeafNode()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testSearchWithIntersectsRectangleFunction() {\n        RTree<Integer, Rectangle> tree = RTree.create();\n        tree.search(circle(0, 0, 1), rectangleIntersectsCircle);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testSearchWithIntersectsRectangleFunction", "params": [], "body": "                                                            {\n        RTree<Integer, Rectangle> tree = RTree.create();\n        tree.search(circle(0, 0, 1), rectangleIntersectsCircle);\n    }", "signature": "@Test\n    public void testSearchWithIntersectsRectangleFunction()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testSearchWithIntersectsPointFunctionReturnsOne() {\n        RTree<Integer, Point> tree = RTree.<Integer, Point>create().add(1, point(0, 0));\n        Observable<Entry<Integer, Point>> entries = tree.search(circle(0, 0, 1),\n                pointIntersectsCircle);\n        assertEquals(1, (int) entries.count().toBlocking().single());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testSearchWithIntersectsPointFunctionReturnsOne", "params": [], "body": "                                                                  {\n        RTree<Integer, Point> tree = RTree.<Integer, Point>create().add(1, point(0, 0));\n        Observable<Entry<Integer, Point>> entries = tree.search(circle(0, 0, 1),\n                pointIntersectsCircle);\n        assertEquals(1, (int) entries.count().toBlocking().single());\n    }", "signature": "@Test\n    public void testSearchWithIntersectsPointFunctionReturnsOne()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testSearchWithIntersectsPointFunctionReturnsNone() {\n        RTree<Integer, Point> tree = RTree.<Integer, Point>create().add(1, point(10, 10));\n        Observable<Entry<Integer, Point>> entries = tree.search(circle(0, 0, 1),\n                pointIntersectsCircle);\n        assertEquals(0, (int) entries.count().toBlocking().single());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testSearchWithIntersectsPointFunctionReturnsNone", "params": [], "body": "                                                                   {\n        RTree<Integer, Point> tree = RTree.<Integer, Point>create().add(1, point(10, 10));\n        Observable<Entry<Integer, Point>> entries = tree.search(circle(0, 0, 1),\n                pointIntersectsCircle);\n        assertEquals(0, (int) entries.count().toBlocking().single());\n    }", "signature": "@Test\n    public void testSearchWithIntersectsPointFunctionReturnsNone()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testSearchWithDistanceFunctionIntersectsMbrButNotActualGeometry() {\n        RTree<Integer, Point> tree = RTree.<Integer, Point>create().add(1, point(0, 0)).add(2,\n                point(1, 1));\n\n        Observable<Entry<Integer, Point>> entries = tree.search(circle(0, 0, 1), 0.1,\n                distanceCircleToPoint);\n        assertEquals(1, (int) entries.count().toBlocking().single());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testSearchWithDistanceFunctionIntersectsMbrButNotActualGeometry", "params": [], "body": "                                                                                  {\n        RTree<Integer, Point> tree = RTree.<Integer, Point>create().add(1, point(0, 0)).add(2,\n                point(1, 1));\n\n        Observable<Entry<Integer, Point>> entries = tree.search(circle(0, 0, 1), 0.1,\n                distanceCircleToPoint);\n        assertEquals(1, (int) entries.count().toBlocking().single());\n    }", "signature": "@Test\n    public void testSearchWithDistanceFunctionIntersectsMbrButNotActualGeometry()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testSearchWithDistanceFunctionIntersectsMbrAndActualGeometry() {\n        RTree<Integer, Point> tree = RTree.<Integer, Point>create().add(1, point(0, 0)).add(2,\n                point(1, 1));\n\n        Observable<Entry<Integer, Point>> entries = tree.search(circle(0, 0, 1), 0.5,\n                distanceCircleToPoint);\n        assertEquals(2, (int) entries.count().toBlocking().single());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testSearchWithDistanceFunctionIntersectsMbrAndActualGeometry", "params": [], "body": "                                                                               {\n        RTree<Integer, Point> tree = RTree.<Integer, Point>create().add(1, point(0, 0)).add(2,\n                point(1, 1));\n\n        Observable<Entry<Integer, Point>> entries = tree.search(circle(0, 0, 1), 0.5,\n                distanceCircleToPoint);\n        assertEquals(2, (int) entries.count().toBlocking().single());\n    }", "signature": "@Test\n    public void testSearchWithDistanceFunctionIntersectsMbrAndActualGeometry()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testSearchWithDistanceFunctionIntersectsNothing() {\n        RTree<Integer, Point> tree = RTree.<Integer, Point>create().add(1, point(0, 0)).add(2,\n                point(1, 1));\n\n        Observable<Entry<Integer, Point>> entries = tree.search(circle(10, 10, 1), 0.5,\n                distanceCircleToPoint);\n        assertEquals(0, (int) entries.count().toBlocking().single());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testSearchWithDistanceFunctionIntersectsNothing", "params": [], "body": "                                                                  {\n        RTree<Integer, Point> tree = RTree.<Integer, Point>create().add(1, point(0, 0)).add(2,\n                point(1, 1));\n\n        Observable<Entry<Integer, Point>> entries = tree.search(circle(10, 10, 1), 0.5,\n                distanceCircleToPoint);\n        assertEquals(0, (int) entries.count().toBlocking().single());\n    }", "signature": "@Test\n    public void testSearchWithDistanceFunctionIntersectsNothing()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void calculateDepthOfEmptyTree() {\n        RTree<Object, Geometry> tree = RTree.create();\n        assertEquals(0, tree.calculateDepth());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "calculateDepthOfEmptyTree", "params": [], "body": "                                            {\n        RTree<Object, Geometry> tree = RTree.create();\n        assertEquals(0, tree.calculateDepth());\n    }", "signature": "@Test\n    public void calculateDepthOfEmptyTree()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void calculateAsStringOfEmptyTree() {\n        RTree<Object, Geometry> tree = RTree.create();\n        assertEquals(\"\", tree.asString());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "calculateAsStringOfEmptyTree", "params": [], "body": "                                               {\n        RTree<Object, Geometry> tree = RTree.create();\n        assertEquals(\"\", tree.asString());\n    }", "signature": "@Test\n    public void calculateAsStringOfEmptyTree()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testForMeiZhao() {\n        for (int minChildren = 1; minChildren <= 2; minChildren++) {\n            RTree<Integer, Point> tree = RTree.maxChildren(3).minChildren(minChildren)\n                    .<Integer, Point>create().add(1, point(1, 9)).add(2, point(2, 10))\n                    .add(3, point(4, 8)).add(4, point(6, 7)).add(5, point(9, 10))\n                    .add(6, point(7, 5)).add(7, point(5, 6)).add(8, point(4, 3)).add(9, point(3, 2))\n                    .add(10, point(9, 1)).add(11, point(10, 4)).add(12, point(6, 2))\n                    .add(13, point(8, 3));\n            System.out.println(tree.asString());\n        }\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testForMeiZhao", "params": [], "body": "                                 {\n        for (int minChildren = 1; minChildren <= 2; minChildren++) {\n            RTree<Integer, Point> tree = RTree.maxChildren(3).minChildren(minChildren)\n                    .<Integer, Point>create().add(1, point(1, 9)).add(2, point(2, 10))\n                    .add(3, point(4, 8)).add(4, point(6, 7)).add(5, point(9, 10))\n                    .add(6, point(7, 5)).add(7, point(5, 6)).add(8, point(4, 3)).add(9, point(3, 2))\n                    .add(10, point(9, 1)).add(11, point(10, 4)).add(12, point(6, 2))\n                    .add(13, point(8, 3));\n            System.out.println(tree.asString());\n        }\n    }", "signature": "@Test\n    public void testForMeiZhao()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testSearchWithCircleFindsCentreOnly() {\n        RTree<Integer, Point> tree = RTree.<Integer, Point>create().add(1, point(1, 1))\n                .add(2, point(2, 2)).add(3, point(3, 3));\n        List<Entry<Integer, Point>> list = tree.search(Geometries.circle(2, 2, 1)).toList()\n                .toBlocking().single();\n        assertEquals(1, list.size());\n        assertEquals(2, (int) list.get(0).value());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testSearchWithCircleFindsCentreOnly", "params": [], "body": "                                                      {\n        RTree<Integer, Point> tree = RTree.<Integer, Point>create().add(1, point(1, 1))\n                .add(2, point(2, 2)).add(3, point(3, 3));\n        List<Entry<Integer, Point>> list = tree.search(Geometries.circle(2, 2, 1)).toList()\n                .toBlocking().single();\n        assertEquals(1, list.size());\n        assertEquals(2, (int) list.get(0).value());\n    }", "signature": "@Test\n    public void testSearchWithCircleFindsCentreOnly()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testSearchWithCircleFindsAll() {\n        RTree<Integer, Point> tree = RTree.<Integer, Point>create().add(1, point(1, 1))\n                .add(2, point(2, 2)).add(3, point(3, 3));\n        List<Entry<Integer, Point>> list = tree.search(Geometries.circle(2, 2, 1.5)).toList()\n                .toBlocking().single();\n        assertEquals(3, list.size());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testSearchWithCircleFindsAll", "params": [], "body": "                                               {\n        RTree<Integer, Point> tree = RTree.<Integer, Point>create().add(1, point(1, 1))\n                .add(2, point(2, 2)).add(3, point(3, 3));\n        List<Entry<Integer, Point>> list = tree.search(Geometries.circle(2, 2, 1.5)).toList()\n                .toBlocking().single();\n        assertEquals(3, list.size());\n    }", "signature": "@Test\n    public void testSearchWithCircleFindsAll()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testSearchWithLineFindsAll() {\n        RTree<Integer, Point> tree = RTree.<Integer, Point>create().add(1, point(1, 1))\n                .add(2, point(2, 2)).add(3, point(3, 3));\n        List<Entry<Integer, Point>> list = tree.search(Geometries.line(0, 0, 4, 4)).toList()\n                .toBlocking().single();\n        assertEquals(3, list.size());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testSearchWithLineFindsAll", "params": [], "body": "                                             {\n        RTree<Integer, Point> tree = RTree.<Integer, Point>create().add(1, point(1, 1))\n                .add(2, point(2, 2)).add(3, point(3, 3));\n        List<Entry<Integer, Point>> list = tree.search(Geometries.line(0, 0, 4, 4)).toList()\n                .toBlocking().single();\n        assertEquals(3, list.size());\n    }", "signature": "@Test\n    public void testSearchWithLineFindsAll()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testSearchWithLineFindsOne() {\n        RTree<Integer, Point> tree = RTree.<Integer, Point>create().add(1, point(1, 1))\n                .add(2, point(2, 2)).add(3, point(3, 3));\n        List<Entry<Integer, Point>> list = tree.search(Geometries.line(1.5, 1.5, 2.5, 2.5)).toList()\n                .toBlocking().single();\n        assertEquals(1, list.size());\n        assertEquals(2, (int) list.get(0).value());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testSearchWithLineFindsOne", "params": [], "body": "                                             {\n        RTree<Integer, Point> tree = RTree.<Integer, Point>create().add(1, point(1, 1))\n                .add(2, point(2, 2)).add(3, point(3, 3));\n        List<Entry<Integer, Point>> list = tree.search(Geometries.line(1.5, 1.5, 2.5, 2.5)).toList()\n                .toBlocking().single();\n        assertEquals(1, list.size());\n        assertEquals(2, (int) list.get(0).value());\n    }", "signature": "@Test\n    public void testSearchWithLineFindsOne()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testSearchWithLineFindsNone() {\n        RTree<Integer, Point> tree = RTree.<Integer, Point>create().add(1, point(1, 1))\n                .add(2, point(2, 2)).add(3, point(3, 3));\n        List<Entry<Integer, Point>> list = tree.search(Geometries.line(1.5, 1.5, 2.6, 2.5)).toList()\n                .toBlocking().single();\n        System.out.println(list);\n        assertEquals(0, list.size());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testSearchWithLineFindsNone", "params": [], "body": "                                              {\n        RTree<Integer, Point> tree = RTree.<Integer, Point>create().add(1, point(1, 1))\n                .add(2, point(2, 2)).add(3, point(3, 3));\n        List<Entry<Integer, Point>> list = tree.search(Geometries.line(1.5, 1.5, 2.6, 2.5)).toList()\n                .toBlocking().single();\n        System.out.println(list);\n        assertEquals(0, list.size());\n    }", "signature": "@Test\n    public void testSearchWithLineFindsNone()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testRTreeRootMbrWhenRTreeEmpty() {\n        assertFalse(RTree.create().mbr().isPresent());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testRTreeRootMbrWhenRTreeEmpty", "params": [], "body": "                                                 {\n        assertFalse(RTree.create().mbr().isPresent());\n    }", "signature": "@Test\n    public void testRTreeRootMbrWhenRTreeEmpty()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testRTreeRootMbrWhenRTreeNonEmpty() {\n        Optional<Rectangle> r = RTree.<Integer, Point>create().add(1, point(1, 1))\n                .add(2, point(2, 2)).mbr();\n        assertEquals(Geometries.rectangle(1, 1, 2, 2), r.get());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testRTreeRootMbrWhenRTreeNonEmpty", "params": [], "body": "                                                    {\n        Optional<Rectangle> r = RTree.<Integer, Point>create().add(1, point(1, 1))\n                .add(2, point(2, 2)).mbr();\n        assertEquals(Geometries.rectangle(1, 1, 2, 2), r.get());\n    }", "signature": "@Test\n    public void testRTreeRootMbrWhenRTreeNonEmpty()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testIntersectsPointLine() {\n        assertTrue(Intersects.lineIntersectsPoint.call(line(1, 1, 2, 2), point(1, 1)));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testIntersectsPointLine", "params": [], "body": "                                          {\n        assertTrue(Intersects.lineIntersectsPoint.call(line(1, 1, 2, 2), point(1, 1)));\n    }", "signature": "@Test\n    public void testIntersectsPointLine()"}, {"syntax_pass": true, "original_string": "    @Test(timeout = 30000000)\n    public void testGroupByIssue40() {\n        RTree<Integer, Geometry> tree = RTree.star().create();\n\n        tree = tree.add(1, Geometries.point(13.0, 52.0));\n        tree = tree.add(2, Geometries.point(13.0, 52.0));\n        tree = tree.add(3, Geometries.point(13.0, 52.0));\n        tree = tree.add(4, Geometries.point(13.0, 52.0));\n        tree = tree.add(5, Geometries.point(13.0, 52.0));\n        tree = tree.add(6, Geometries.point(13.0, 52.0));\n\n        Rectangle rectangle = Geometries.rectangle(12.9, 51.9, 13.1, 52.1);\n        assertEquals(Integer.valueOf(2), tree.search(rectangle).doOnRequest(new Action1<Long>() {\n            @Override\n            public void call(Long n) {\n                System.out.println(\"requestFromGroupBy=\" + n);\n            }\n        }).groupBy(new Func1<Entry<Integer, Geometry>, Boolean>() {\n            @Override\n            public Boolean call(Entry<Integer, Geometry> entry) {\n                System.out.println(entry);\n                return entry.value() % 2 == 0;\n            }\n        }).doOnRequest(new Action1<Long>() {\n            @Override\n            public void call(Long n) {\n                System.out.println(\"requestFromFlatMap=\" + n);\n            }\n        }).flatMap(\n                new Func1<GroupedObservable<Boolean, Entry<Integer, Geometry>>, Observable<Integer>>() {\n                    @Override\n                    public Observable<Integer> call(\n                            GroupedObservable<Boolean, Entry<Integer, Geometry>> group) {\n                        return group.count();\n                    }\n                }).count().toBlocking().single());\n    }", "docstring": "", "attributes": {"modifiers": "@Test(timeout = 30000000)\n    public", "marker_annotations": [], "non_marker_annotations": ["@Test(timeout = 30000000)", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "testGroupByIssue40", "params": [], "body": "                                     {\n        RTree<Integer, Geometry> tree = RTree.star().create();\n\n        tree = tree.add(1, Geometries.point(13.0, 52.0));\n        tree = tree.add(2, Geometries.point(13.0, 52.0));\n        tree = tree.add(3, Geometries.point(13.0, 52.0));\n        tree = tree.add(4, Geometries.point(13.0, 52.0));\n        tree = tree.add(5, Geometries.point(13.0, 52.0));\n        tree = tree.add(6, Geometries.point(13.0, 52.0));\n\n        Rectangle rectangle = Geometries.rectangle(12.9, 51.9, 13.1, 52.1);\n        assertEquals(Integer.valueOf(2), tree.search(rectangle).doOnRequest(new Action1<Long>() {\n            @Override\n            public void call(Long n) {\n                System.out.println(\"requestFromGroupBy=\" + n);\n            }\n        }).groupBy(new Func1<Entry<Integer, Geometry>, Boolean>() {\n            @Override\n            public Boolean call(Entry<Integer, Geometry> entry) {\n                System.out.println(entry);\n                return entry.value() % 2 == 0;\n            }\n        }).doOnRequest(new Action1<Long>() {\n            @Override\n            public void call(Long n) {\n                System.out.println(\"requestFromFlatMap=\" + n);\n            }\n        }).flatMap(\n                new Func1<GroupedObservable<Boolean, Entry<Integer, Geometry>>, Observable<Integer>>() {\n                    @Override\n                    public Observable<Integer> call(\n                            GroupedObservable<Boolean, Entry<Integer, Geometry>> group) {\n                        return group.count();\n                    }\n                }).count().toBlocking().single());\n    }", "signature": "@Test(timeout = 30000000)\n    public void testGroupByIssue40()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testBackpressureForOverflow() {\n        RTree<Integer, Geometry> tree = RTree.star().create();\n\n        tree = tree.add(1, Geometries.point(13.0, 52.0));\n        tree = tree.add(2, Geometries.point(13.0, 52.0));\n        tree = tree.add(3, Geometries.point(13.0, 52.0));\n        tree = tree.add(4, Geometries.point(13.0, 52.0));\n        tree = tree.add(5, Geometries.point(13.0, 52.0));\n        tree = tree.add(6, Geometries.point(13.0, 52.0));\n        final AtomicInteger count = new AtomicInteger();\n        Rectangle rectangle = Geometries.rectangle(12.9, 51.9, 13.1, 52.1);\n        tree.search(rectangle).subscribe(new Subscriber<Object>() {\n\n            @Override\n            public void onStart() {\n                request(4);\n            }\n\n            @Override\n            public void onCompleted() {\n\n            }\n\n            @Override\n            public void onError(Throwable e) {\n\n            }\n\n            @Override\n            public void onNext(Object t) {\n                request(Long.MAX_VALUE);\n                count.incrementAndGet();\n            }\n        });\n        assertEquals(6, count.get());\n        assertEquals(6, (int) tree.search(rectangle).count().toBlocking().single());\n\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testBackpressureForOverflow", "params": [], "body": "                                              {\n        RTree<Integer, Geometry> tree = RTree.star().create();\n\n        tree = tree.add(1, Geometries.point(13.0, 52.0));\n        tree = tree.add(2, Geometries.point(13.0, 52.0));\n        tree = tree.add(3, Geometries.point(13.0, 52.0));\n        tree = tree.add(4, Geometries.point(13.0, 52.0));\n        tree = tree.add(5, Geometries.point(13.0, 52.0));\n        tree = tree.add(6, Geometries.point(13.0, 52.0));\n        final AtomicInteger count = new AtomicInteger();\n        Rectangle rectangle = Geometries.rectangle(12.9, 51.9, 13.1, 52.1);\n        tree.search(rectangle).subscribe(new Subscriber<Object>() {\n\n            @Override\n            public void onStart() {\n                request(4);\n            }\n\n            @Override\n            public void onCompleted() {\n\n            }\n\n            @Override\n            public void onError(Throwable e) {\n\n            }\n\n            @Override\n            public void onNext(Object t) {\n                request(Long.MAX_VALUE);\n                count.incrementAndGet();\n            }\n        });\n        assertEquals(6, count.get());\n        assertEquals(6, (int) tree.search(rectangle).count().toBlocking().single());\n\n    }", "signature": "@Test\n    public void testBackpressureForOverflow()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testDeleteIssue81d() {\n         RTree<Object, Point> t = RTree.create();\n         t = t.add(1, Geometries.pointGeographic(123.4d, 23.3d));\n         t = t.delete(1, Geometries.pointGeographic(123.4d, 23.3d));\n         assertEquals(0, t.size());\n     }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testDeleteIssue81d", "params": [], "body": "                                     {\n         RTree<Object, Point> t = RTree.create();\n         t = t.add(1, Geometries.pointGeographic(123.4d, 23.3d));\n         t = t.delete(1, Geometries.pointGeographic(123.4d, 23.3d));\n         assertEquals(0, t.size());\n     }", "signature": "@Test\n    public void testDeleteIssue81d()"}, {"syntax_pass": true, "original_string": "     @Test\n     public void testDeleteIssue81f() {\n         RTree<Object, Point> t = RTree.create();\n         t = t.add(1, Geometries.pointGeographic(123.4f, 23.3f));\n         t = t.delete(1, Geometries.pointGeographic(123.4f, 23.3f));\n         assertEquals(0, t.size());\n     }", "docstring": "", "attributes": {"modifiers": "@Test\n     public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testDeleteIssue81f", "params": [], "body": "                                      {\n         RTree<Object, Point> t = RTree.create();\n         t = t.add(1, Geometries.pointGeographic(123.4f, 23.3f));\n         t = t.delete(1, Geometries.pointGeographic(123.4f, 23.3f));\n         assertEquals(0, t.size());\n     }", "signature": "@Test\n     public void testDeleteIssue81f()"}, {"syntax_pass": true, "original_string": "    private static <T> Func1<Entry<T, ?>, T> toValue() {\n        return new Func1<Entry<T, ?>, T>() {\n\n            @Override\n            public T call(Entry<T, ?> entry) {\n                return entry.value();\n            }\n        };\n    }", "docstring": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "Func1<Entry<T, ?>, T>", "classes": []}, "name": "toValue", "params": [], "body": "                                                       {\n        return new Func1<Entry<T, ?>, T>() {\n\n            @Override\n            public T call(Entry<T, ?> entry) {\n                return entry.value();\n            }\n        };\n    }", "signature": "private static <T> Func1<Entry<T, ?>, T> toValue()"}, {"syntax_pass": true, "original_string": "    private static Point nextPoint() {\n\n        double randomX = Math.round(Math.random() * 100);\n\n        double randomY = Math.round(Math.random() * 100);\n\n        return Geometries.point(randomX, randomY);\n\n    }", "docstring": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "Point", "classes": []}, "name": "nextPoint", "params": [], "body": "                                     {\n\n        double randomX = Math.round(Math.random() * 100);\n\n        double randomY = Math.round(Math.random() * 100);\n\n        return Geometries.point(randomX, randomY);\n\n    }", "signature": "private static Point nextPoint()"}, {"syntax_pass": true, "original_string": "    static Entry<Object, Rectangle> e(int n) {\n        return Entries.<Object, Rectangle>entry(n, r(n));\n    }", "docstring": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "Entry<Object, Rectangle>", "classes": []}, "name": "e", "params": [{"name": "n", "type": "int"}], "body": "                                             {\n        return Entries.<Object, Rectangle>entry(n, r(n));\n    }", "signature": "static Entry<Object, Rectangle> e(int n)"}, {"syntax_pass": true, "original_string": "    static Entry<Object, Rectangle> e2(int n) {\n        return Entries.<Object, Rectangle>entry(n, r(n - 1));\n    }", "docstring": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "Entry<Object, Rectangle>", "classes": []}, "name": "e2", "params": [{"name": "n", "type": "int"}], "body": "                                              {\n        return Entries.<Object, Rectangle>entry(n, r(n - 1));\n    }", "signature": "static Entry<Object, Rectangle> e2(int n)"}, {"syntax_pass": true, "original_string": "    private static Rectangle r(int n) {\n        return rectangle(n, n, n + 1, n + 1);\n    }", "docstring": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "Rectangle", "classes": []}, "name": "r", "params": [{"name": "n", "type": "int"}], "body": "                                      {\n        return rectangle(n, n, n + 1, n + 1);\n    }", "signature": "private static Rectangle r(int n)"}, {"syntax_pass": true, "original_string": "    private static Rectangle r(double n, double m) {\n        return rectangle(n, m, n + 1, m + 1);\n    }", "docstring": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "Rectangle", "classes": []}, "name": "r", "params": [{"name": "n", "type": "double"}, {"name": "m", "type": "double"}], "body": "                                                   {\n        return rectangle(n, m, n + 1, m + 1);\n    }", "signature": "private static Rectangle r(double n, double m)"}, {"syntax_pass": true, "original_string": "    private static Rectangle r(float n, float m) {\n        return rectangle(n, m, n + 1, m + 1);\n    }", "docstring": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "Rectangle", "classes": []}, "name": "r", "params": [{"name": "n", "type": "float"}, {"name": "m", "type": "float"}], "body": "                                                 {\n        return rectangle(n, m, n + 1, m + 1);\n    }", "signature": "private static Rectangle r(float n, float m)"}, {"syntax_pass": true, "original_string": "    static Rectangle random(Precision precision) {\n        if (precision == Precision.SINGLE)\n            return r((float) Math.random() * 1000, (float) Math.random() * 1000);\n        else\n            return r(Math.random() * 1000, Math.random() * 1000);\n    }", "docstring": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "Rectangle", "classes": []}, "name": "random", "params": [{"name": "precision", "type": "Precision"}], "body": "                                                 {\n        if (precision == Precision.SINGLE)\n            return r((float) Math.random() * 1000, (float) Math.random() * 1000);\n        else\n            return r(Math.random() * 1000, Math.random() * 1000);\n    }", "signature": "static Rectangle random(Precision precision)"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testSearchGreekEarthquakesDouble() {\n        Observable<Entry<Object, Point>> entriesDouble = GreekEarthquakes.entries(Precision.DOUBLE);\n        RTree<Object, Point> t = RTree.maxChildren(4).<Object, Point>create().add(entriesDouble)\n                .last().toBlocking().single(); //\n        t.search(Geometries.rectangle(40, 27.0, 40.5, 27.5)) //\n                .test() //\n                .assertValueCount(22) //\n                .assertCompleted();\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testSearchGreekEarthquakesDouble", "params": [], "body": "                                                   {\n        Observable<Entry<Object, Point>> entriesDouble = GreekEarthquakes.entries(Precision.DOUBLE);\n        RTree<Object, Point> t = RTree.maxChildren(4).<Object, Point>create().add(entriesDouble)\n                .last().toBlocking().single(); //\n        t.search(Geometries.rectangle(40, 27.0, 40.5, 27.5)) //\n                .test() //\n                .assertValueCount(22) //\n                .assertCompleted();\n    }", "signature": "@Test\n    public void testSearchGreekEarthquakesDouble()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/com/github/davidmoten/rtree/ComparatorsTest.java", "original_string": "package com.github.davidmoten.rtree;\n\nimport org.junit.Test;\n\nimport com.github.davidmoten.junit.Asserts;\nimport com.github.davidmoten.rtree.internal.Comparators;\n\npublic class ComparatorsTest {\n\n    @Test\n    public void testConstructorIsPrivate() {\n        Asserts.assertIsUtilityClass(Comparators.class);\n    }\n\n}\n", "file_hash": "966d0f827f26edc04457b90f864977afff630733b24553d03d76d2d4a63f6243", "file_docstring": "", "contexts": ["package com.github.davidmoten.rtree;", "import org.junit.Test;", "import com.github.davidmoten.junit.Asserts;", "import com.github.davidmoten.rtree.internal.Comparators;"], "methods": [], "classes": [{"original_string": "public class ComparatorsTest {\n\n    @Test\n    public void testConstructorIsPrivate() {\n        Asserts.assertIsUtilityClass(Comparators.class);\n    }\n\n}", "definition": "public class ComparatorsTest", "class_docstring": "", "name": "ComparatorsTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @Test\n    public void testConstructorIsPrivate() {\n        Asserts.assertIsUtilityClass(Comparators.class);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testConstructorIsPrivate", "params": [], "body": "                                           {\n        Asserts.assertIsUtilityClass(Comparators.class);\n    }", "signature": "@Test\n    public void testConstructorIsPrivate()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/com/github/davidmoten/rtree/UtilTest.java", "original_string": "package com.github.davidmoten.rtree;\n\nimport static org.junit.Assert.assertEquals;\n\nimport java.util.Collections;\n\nimport org.junit.Test;\n\nimport com.github.davidmoten.junit.Asserts;\nimport com.github.davidmoten.rtree.geometry.Geometries;\nimport com.github.davidmoten.rtree.geometry.Rectangle;\nimport com.github.davidmoten.rtree.internal.Util;\n\npublic class UtilTest {\n\n    @Test\n    public void coverPrivateConstructor() {\n        Asserts.assertIsUtilityClass(Util.class);\n    }\n\n    @Test\n    public void testMbrWithNegativeValues() {\n        Rectangle r = Geometries.rectangle(-2D, -2, -1, -1);\n        Rectangle mbr = Util.mbr(Collections.singleton(r));\n        assertEquals(r, mbr);\n        System.out.println(r);\n    }\n\n}\n", "file_hash": "cf7a5b94944f18297816f7a8ac461c923083015b9f0aec79c1f1241ffd8e76f6", "file_docstring": "", "contexts": ["package com.github.davidmoten.rtree;", "import static org.junit.Assert.assertEquals;", "import java.util.Collections;", "import org.junit.Test;", "import com.github.davidmoten.junit.Asserts;", "import com.github.davidmoten.rtree.geometry.Geometries;", "import com.github.davidmoten.rtree.geometry.Rectangle;", "import com.github.davidmoten.rtree.internal.Util;"], "methods": [], "classes": [{"original_string": "public class UtilTest {\n\n    @Test\n    public void coverPrivateConstructor() {\n        Asserts.assertIsUtilityClass(Util.class);\n    }\n\n    @Test\n    public void testMbrWithNegativeValues() {\n        Rectangle r = Geometries.rectangle(-2D, -2, -1, -1);\n        Rectangle mbr = Util.mbr(Collections.singleton(r));\n        assertEquals(r, mbr);\n        System.out.println(r);\n    }\n\n}", "definition": "public class UtilTest", "class_docstring": "", "name": "UtilTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @Test\n    public void coverPrivateConstructor() {\n        Asserts.assertIsUtilityClass(Util.class);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "coverPrivateConstructor", "params": [], "body": "                                          {\n        Asserts.assertIsUtilityClass(Util.class);\n    }", "signature": "@Test\n    public void coverPrivateConstructor()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testMbrWithNegativeValues() {\n        Rectangle r = Geometries.rectangle(-2D, -2, -1, -1);\n        Rectangle mbr = Util.mbr(Collections.singleton(r));\n        assertEquals(r, mbr);\n        System.out.println(r);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testMbrWithNegativeValues", "params": [], "body": "                                            {\n        Rectangle r = Geometries.rectangle(-2D, -2, -1, -1);\n        Rectangle mbr = Util.mbr(Collections.singleton(r));\n        assertEquals(r, mbr);\n        System.out.println(r);\n    }", "signature": "@Test\n    public void testMbrWithNegativeValues()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/com/github/davidmoten/rtree/QuadraticSplitterTest.java", "original_string": "package com.github.davidmoten.rtree;\n\nimport static org.junit.Assert.assertEquals;\n\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\n\nimport org.junit.Test;\n\nimport com.github.davidmoten.guavamini.Sets;\nimport com.github.davidmoten.rtree.geometry.Geometries;\nimport com.github.davidmoten.rtree.geometry.HasGeometry;\nimport com.github.davidmoten.rtree.geometry.ListPair;\nimport com.github.davidmoten.rtree.internal.Util;\nimport com.github.davidmoten.rtree.internal.util.Pair;\n\npublic class QuadraticSplitterTest {\n\n    @Test\n    public void testWorstCombinationOn3() {\n        final Mbr r1 = r(1);\n        final Mbr r2 = r(100);\n        final Mbr r3 = r(3);\n        final Pair<Mbr> pair = SplitterQuadratic.worstCombination(Arrays.asList(r1, r2, r3));\n        assertEquals(r1, pair.value1());\n        assertEquals(r2, pair.value2());\n    }\n\n    @Test\n    public void testWorstCombinationOnTwoEntries() {\n        final Mbr r1 = r(1);\n        final Mbr r2 = r(2);\n        final Pair<Mbr> pair = SplitterQuadratic.worstCombination(Arrays.asList(r1, r2));\n        assertEquals(r1, pair.value1());\n        assertEquals(r2, pair.value2());\n    }\n\n    @Test\n    public void testWorstCombinationOn4() {\n        final Mbr r1 = r(2);\n        final Mbr r2 = r(1);\n        final Mbr r3 = r(3);\n        final Mbr r4 = r(4);\n        final Pair<Mbr> pair = SplitterQuadratic.worstCombination(Arrays.asList(r1, r2, r3, r4));\n        assertEquals(r2, pair.value1());\n        assertEquals(r4, pair.value2());\n    }\n\n    @Test\n    public void testGetBestCandidateForGroup1() {\n        final Mbr r1 = r(1);\n        final Mbr r2 = r(2);\n        final List<Mbr> list = Collections.singletonList(r1);\n        final List<Mbr> group = Collections.singletonList(r2);\n        final Mbr r = SplitterQuadratic.getBestCandidateForGroup(list, group, Util.mbr(group));\n        assertEquals(r1, r);\n    }\n\n    @Test\n    public void testGetBestCandidateForGroup2() {\n        final Mbr r1 = r(1);\n        final Mbr r2 = r(2);\n        final Mbr r3 = r(10);\n        final List<Mbr> list = Collections.singletonList(r1);\n        final List<Mbr> group = Arrays.asList(r2, r3);\n        final Mbr r = SplitterQuadratic.getBestCandidateForGroup(list, group, Util.mbr(group));\n        assertEquals(r1, r);\n    }\n\n    @Test\n    public void testGetBestCandidateForGroup3() {\n        final Mbr r1 = r(1);\n        final Mbr r2 = r(2);\n        final Mbr r3 = r(10);\n        final List<Mbr> list = Arrays.asList(r1, r2);\n        final List<Mbr> group = Arrays.asList(r3);\n        final Mbr r = SplitterQuadratic.getBestCandidateForGroup(list, group, Util.mbr(group));\n        assertEquals(r2, r);\n    }\n\n    @Test\n    public void testSplit() {\n        final SplitterQuadratic q = new SplitterQuadratic();\n        final Mbr r1 = r(1);\n        final Mbr r2 = r(2);\n        final Mbr r3 = r(100);\n        final Mbr r4 = r(101);\n        final ListPair<Mbr> pair = q.split(Arrays.asList(r1, r2, r3, r4), 2);\n        assertEquals(Sets.newHashSet(r1, r2), Sets.newHashSet(pair.group1().list()));\n        assertEquals(Sets.newHashSet(r3, r4), Sets.newHashSet(pair.group2().list()));\n    }\n\n    @Test\n    public void testSplit2() {\n        final SplitterQuadratic q = new SplitterQuadratic();\n        final Mbr r1 = r(1);\n        final Mbr r2 = r(2);\n        final Mbr r3 = r(100);\n        final Mbr r4 = r(101);\n        final Mbr r5 = r(103);\n        final ListPair<Mbr> pair = q.split(Arrays.asList(r1, r2, r3, r4, r5), 2);\n        assertEquals(Sets.newHashSet(r1, r2), Sets.newHashSet(pair.group1().list()));\n        assertEquals(Sets.newHashSet(r3, r4, r5), Sets.newHashSet(pair.group2().list()));\n    }\n\n    @Test\n    public void testSplit3() {\n        final SplitterQuadratic q = new SplitterQuadratic();\n        final Mbr r1 = r(1);\n        final Mbr r2 = r(2);\n        final Mbr r3 = r(100);\n        final Mbr r4 = r(101);\n        final Mbr r5 = r(103);\n        final Mbr r6 = r(104);\n        final ListPair<Mbr> pair = q.split(Arrays.asList(r1, r2, r3, r4, r5, r6), 3);\n        assertEquals(Sets.newHashSet(r1, r2, r3), Sets.newHashSet(pair.group1().list()));\n        assertEquals(Sets.newHashSet(r4, r5, r6), Sets.newHashSet(pair.group2().list()));\n    }\n\n    @Test(expected = RuntimeException.class)\n    public void testExceptionForSplitEmptyList() {\n        final SplitterQuadratic q = new SplitterQuadratic();\n        q.split(Collections.<HasGeometry> emptyList(), 3);\n    }\n\n    private static Mbr r(int n) {\n        return new Mbr(Geometries.rectangle(n, n, n + 1, n + 1));\n    }\n\n}\n", "file_hash": "d4c3f94998c4a6cd05e682495e644141af329e8636a9162790e52d35974582c8", "file_docstring": "", "contexts": ["package com.github.davidmoten.rtree;", "import static org.junit.Assert.assertEquals;", "import java.util.Arrays;", "import java.util.Collections;", "import java.util.List;", "import org.junit.Test;", "import com.github.davidmoten.guavamini.Sets;", "import com.github.davidmoten.rtree.geometry.Geometries;", "import com.github.davidmoten.rtree.geometry.HasGeometry;", "import com.github.davidmoten.rtree.geometry.ListPair;", "import com.github.davidmoten.rtree.internal.Util;", "import com.github.davidmoten.rtree.internal.util.Pair;"], "methods": [], "classes": [{"original_string": "public class QuadraticSplitterTest {\n\n    @Test\n    public void testWorstCombinationOn3() {\n        final Mbr r1 = r(1);\n        final Mbr r2 = r(100);\n        final Mbr r3 = r(3);\n        final Pair<Mbr> pair = SplitterQuadratic.worstCombination(Arrays.asList(r1, r2, r3));\n        assertEquals(r1, pair.value1());\n        assertEquals(r2, pair.value2());\n    }\n\n    @Test\n    public void testWorstCombinationOnTwoEntries() {\n        final Mbr r1 = r(1);\n        final Mbr r2 = r(2);\n        final Pair<Mbr> pair = SplitterQuadratic.worstCombination(Arrays.asList(r1, r2));\n        assertEquals(r1, pair.value1());\n        assertEquals(r2, pair.value2());\n    }\n\n    @Test\n    public void testWorstCombinationOn4() {\n        final Mbr r1 = r(2);\n        final Mbr r2 = r(1);\n        final Mbr r3 = r(3);\n        final Mbr r4 = r(4);\n        final Pair<Mbr> pair = SplitterQuadratic.worstCombination(Arrays.asList(r1, r2, r3, r4));\n        assertEquals(r2, pair.value1());\n        assertEquals(r4, pair.value2());\n    }\n\n    @Test\n    public void testGetBestCandidateForGroup1() {\n        final Mbr r1 = r(1);\n        final Mbr r2 = r(2);\n        final List<Mbr> list = Collections.singletonList(r1);\n        final List<Mbr> group = Collections.singletonList(r2);\n        final Mbr r = SplitterQuadratic.getBestCandidateForGroup(list, group, Util.mbr(group));\n        assertEquals(r1, r);\n    }\n\n    @Test\n    public void testGetBestCandidateForGroup2() {\n        final Mbr r1 = r(1);\n        final Mbr r2 = r(2);\n        final Mbr r3 = r(10);\n        final List<Mbr> list = Collections.singletonList(r1);\n        final List<Mbr> group = Arrays.asList(r2, r3);\n        final Mbr r = SplitterQuadratic.getBestCandidateForGroup(list, group, Util.mbr(group));\n        assertEquals(r1, r);\n    }\n\n    @Test\n    public void testGetBestCandidateForGroup3() {\n        final Mbr r1 = r(1);\n        final Mbr r2 = r(2);\n        final Mbr r3 = r(10);\n        final List<Mbr> list = Arrays.asList(r1, r2);\n        final List<Mbr> group = Arrays.asList(r3);\n        final Mbr r = SplitterQuadratic.getBestCandidateForGroup(list, group, Util.mbr(group));\n        assertEquals(r2, r);\n    }\n\n    @Test\n    public void testSplit() {\n        final SplitterQuadratic q = new SplitterQuadratic();\n        final Mbr r1 = r(1);\n        final Mbr r2 = r(2);\n        final Mbr r3 = r(100);\n        final Mbr r4 = r(101);\n        final ListPair<Mbr> pair = q.split(Arrays.asList(r1, r2, r3, r4), 2);\n        assertEquals(Sets.newHashSet(r1, r2), Sets.newHashSet(pair.group1().list()));\n        assertEquals(Sets.newHashSet(r3, r4), Sets.newHashSet(pair.group2().list()));\n    }\n\n    @Test\n    public void testSplit2() {\n        final SplitterQuadratic q = new SplitterQuadratic();\n        final Mbr r1 = r(1);\n        final Mbr r2 = r(2);\n        final Mbr r3 = r(100);\n        final Mbr r4 = r(101);\n        final Mbr r5 = r(103);\n        final ListPair<Mbr> pair = q.split(Arrays.asList(r1, r2, r3, r4, r5), 2);\n        assertEquals(Sets.newHashSet(r1, r2), Sets.newHashSet(pair.group1().list()));\n        assertEquals(Sets.newHashSet(r3, r4, r5), Sets.newHashSet(pair.group2().list()));\n    }\n\n    @Test\n    public void testSplit3() {\n        final SplitterQuadratic q = new SplitterQuadratic();\n        final Mbr r1 = r(1);\n        final Mbr r2 = r(2);\n        final Mbr r3 = r(100);\n        final Mbr r4 = r(101);\n        final Mbr r5 = r(103);\n        final Mbr r6 = r(104);\n        final ListPair<Mbr> pair = q.split(Arrays.asList(r1, r2, r3, r4, r5, r6), 3);\n        assertEquals(Sets.newHashSet(r1, r2, r3), Sets.newHashSet(pair.group1().list()));\n        assertEquals(Sets.newHashSet(r4, r5, r6), Sets.newHashSet(pair.group2().list()));\n    }\n\n    @Test(expected = RuntimeException.class)\n    public void testExceptionForSplitEmptyList() {\n        final SplitterQuadratic q = new SplitterQuadratic();\n        q.split(Collections.<HasGeometry> emptyList(), 3);\n    }\n\n    private static Mbr r(int n) {\n        return new Mbr(Geometries.rectangle(n, n, n + 1, n + 1));\n    }\n\n}", "definition": "public class QuadraticSplitterTest", "class_docstring": "", "name": "QuadraticSplitterTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @Test\n    public void testWorstCombinationOn3() {\n        final Mbr r1 = r(1);\n        final Mbr r2 = r(100);\n        final Mbr r3 = r(3);\n        final Pair<Mbr> pair = SplitterQuadratic.worstCombination(Arrays.asList(r1, r2, r3));\n        assertEquals(r1, pair.value1());\n        assertEquals(r2, pair.value2());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testWorstCombinationOn3", "params": [], "body": "                                          {\n        final Mbr r1 = r(1);\n        final Mbr r2 = r(100);\n        final Mbr r3 = r(3);\n        final Pair<Mbr> pair = SplitterQuadratic.worstCombination(Arrays.asList(r1, r2, r3));\n        assertEquals(r1, pair.value1());\n        assertEquals(r2, pair.value2());\n    }", "signature": "@Test\n    public void testWorstCombinationOn3()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testWorstCombinationOnTwoEntries() {\n        final Mbr r1 = r(1);\n        final Mbr r2 = r(2);\n        final Pair<Mbr> pair = SplitterQuadratic.worstCombination(Arrays.asList(r1, r2));\n        assertEquals(r1, pair.value1());\n        assertEquals(r2, pair.value2());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testWorstCombinationOnTwoEntries", "params": [], "body": "                                                   {\n        final Mbr r1 = r(1);\n        final Mbr r2 = r(2);\n        final Pair<Mbr> pair = SplitterQuadratic.worstCombination(Arrays.asList(r1, r2));\n        assertEquals(r1, pair.value1());\n        assertEquals(r2, pair.value2());\n    }", "signature": "@Test\n    public void testWorstCombinationOnTwoEntries()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testWorstCombinationOn4() {\n        final Mbr r1 = r(2);\n        final Mbr r2 = r(1);\n        final Mbr r3 = r(3);\n        final Mbr r4 = r(4);\n        final Pair<Mbr> pair = SplitterQuadratic.worstCombination(Arrays.asList(r1, r2, r3, r4));\n        assertEquals(r2, pair.value1());\n        assertEquals(r4, pair.value2());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testWorstCombinationOn4", "params": [], "body": "                                          {\n        final Mbr r1 = r(2);\n        final Mbr r2 = r(1);\n        final Mbr r3 = r(3);\n        final Mbr r4 = r(4);\n        final Pair<Mbr> pair = SplitterQuadratic.worstCombination(Arrays.asList(r1, r2, r3, r4));\n        assertEquals(r2, pair.value1());\n        assertEquals(r4, pair.value2());\n    }", "signature": "@Test\n    public void testWorstCombinationOn4()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testGetBestCandidateForGroup1() {\n        final Mbr r1 = r(1);\n        final Mbr r2 = r(2);\n        final List<Mbr> list = Collections.singletonList(r1);\n        final List<Mbr> group = Collections.singletonList(r2);\n        final Mbr r = SplitterQuadratic.getBestCandidateForGroup(list, group, Util.mbr(group));\n        assertEquals(r1, r);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testGetBestCandidateForGroup1", "params": [], "body": "                                                {\n        final Mbr r1 = r(1);\n        final Mbr r2 = r(2);\n        final List<Mbr> list = Collections.singletonList(r1);\n        final List<Mbr> group = Collections.singletonList(r2);\n        final Mbr r = SplitterQuadratic.getBestCandidateForGroup(list, group, Util.mbr(group));\n        assertEquals(r1, r);\n    }", "signature": "@Test\n    public void testGetBestCandidateForGroup1()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testGetBestCandidateForGroup2() {\n        final Mbr r1 = r(1);\n        final Mbr r2 = r(2);\n        final Mbr r3 = r(10);\n        final List<Mbr> list = Collections.singletonList(r1);\n        final List<Mbr> group = Arrays.asList(r2, r3);\n        final Mbr r = SplitterQuadratic.getBestCandidateForGroup(list, group, Util.mbr(group));\n        assertEquals(r1, r);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testGetBestCandidateForGroup2", "params": [], "body": "                                                {\n        final Mbr r1 = r(1);\n        final Mbr r2 = r(2);\n        final Mbr r3 = r(10);\n        final List<Mbr> list = Collections.singletonList(r1);\n        final List<Mbr> group = Arrays.asList(r2, r3);\n        final Mbr r = SplitterQuadratic.getBestCandidateForGroup(list, group, Util.mbr(group));\n        assertEquals(r1, r);\n    }", "signature": "@Test\n    public void testGetBestCandidateForGroup2()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testGetBestCandidateForGroup3() {\n        final Mbr r1 = r(1);\n        final Mbr r2 = r(2);\n        final Mbr r3 = r(10);\n        final List<Mbr> list = Arrays.asList(r1, r2);\n        final List<Mbr> group = Arrays.asList(r3);\n        final Mbr r = SplitterQuadratic.getBestCandidateForGroup(list, group, Util.mbr(group));\n        assertEquals(r2, r);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testGetBestCandidateForGroup3", "params": [], "body": "                                                {\n        final Mbr r1 = r(1);\n        final Mbr r2 = r(2);\n        final Mbr r3 = r(10);\n        final List<Mbr> list = Arrays.asList(r1, r2);\n        final List<Mbr> group = Arrays.asList(r3);\n        final Mbr r = SplitterQuadratic.getBestCandidateForGroup(list, group, Util.mbr(group));\n        assertEquals(r2, r);\n    }", "signature": "@Test\n    public void testGetBestCandidateForGroup3()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testSplit() {\n        final SplitterQuadratic q = new SplitterQuadratic();\n        final Mbr r1 = r(1);\n        final Mbr r2 = r(2);\n        final Mbr r3 = r(100);\n        final Mbr r4 = r(101);\n        final ListPair<Mbr> pair = q.split(Arrays.asList(r1, r2, r3, r4), 2);\n        assertEquals(Sets.newHashSet(r1, r2), Sets.newHashSet(pair.group1().list()));\n        assertEquals(Sets.newHashSet(r3, r4), Sets.newHashSet(pair.group2().list()));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testSplit", "params": [], "body": "                            {\n        final SplitterQuadratic q = new SplitterQuadratic();\n        final Mbr r1 = r(1);\n        final Mbr r2 = r(2);\n        final Mbr r3 = r(100);\n        final Mbr r4 = r(101);\n        final ListPair<Mbr> pair = q.split(Arrays.asList(r1, r2, r3, r4), 2);\n        assertEquals(Sets.newHashSet(r1, r2), Sets.newHashSet(pair.group1().list()));\n        assertEquals(Sets.newHashSet(r3, r4), Sets.newHashSet(pair.group2().list()));\n    }", "signature": "@Test\n    public void testSplit()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testSplit2() {\n        final SplitterQuadratic q = new SplitterQuadratic();\n        final Mbr r1 = r(1);\n        final Mbr r2 = r(2);\n        final Mbr r3 = r(100);\n        final Mbr r4 = r(101);\n        final Mbr r5 = r(103);\n        final ListPair<Mbr> pair = q.split(Arrays.asList(r1, r2, r3, r4, r5), 2);\n        assertEquals(Sets.newHashSet(r1, r2), Sets.newHashSet(pair.group1().list()));\n        assertEquals(Sets.newHashSet(r3, r4, r5), Sets.newHashSet(pair.group2().list()));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testSplit2", "params": [], "body": "                             {\n        final SplitterQuadratic q = new SplitterQuadratic();\n        final Mbr r1 = r(1);\n        final Mbr r2 = r(2);\n        final Mbr r3 = r(100);\n        final Mbr r4 = r(101);\n        final Mbr r5 = r(103);\n        final ListPair<Mbr> pair = q.split(Arrays.asList(r1, r2, r3, r4, r5), 2);\n        assertEquals(Sets.newHashSet(r1, r2), Sets.newHashSet(pair.group1().list()));\n        assertEquals(Sets.newHashSet(r3, r4, r5), Sets.newHashSet(pair.group2().list()));\n    }", "signature": "@Test\n    public void testSplit2()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testSplit3() {\n        final SplitterQuadratic q = new SplitterQuadratic();\n        final Mbr r1 = r(1);\n        final Mbr r2 = r(2);\n        final Mbr r3 = r(100);\n        final Mbr r4 = r(101);\n        final Mbr r5 = r(103);\n        final Mbr r6 = r(104);\n        final ListPair<Mbr> pair = q.split(Arrays.asList(r1, r2, r3, r4, r5, r6), 3);\n        assertEquals(Sets.newHashSet(r1, r2, r3), Sets.newHashSet(pair.group1().list()));\n        assertEquals(Sets.newHashSet(r4, r5, r6), Sets.newHashSet(pair.group2().list()));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testSplit3", "params": [], "body": "                             {\n        final SplitterQuadratic q = new SplitterQuadratic();\n        final Mbr r1 = r(1);\n        final Mbr r2 = r(2);\n        final Mbr r3 = r(100);\n        final Mbr r4 = r(101);\n        final Mbr r5 = r(103);\n        final Mbr r6 = r(104);\n        final ListPair<Mbr> pair = q.split(Arrays.asList(r1, r2, r3, r4, r5, r6), 3);\n        assertEquals(Sets.newHashSet(r1, r2, r3), Sets.newHashSet(pair.group1().list()));\n        assertEquals(Sets.newHashSet(r4, r5, r6), Sets.newHashSet(pair.group2().list()));\n    }", "signature": "@Test\n    public void testSplit3()"}, {"syntax_pass": true, "original_string": "    @Test(expected = RuntimeException.class)\n    public void testExceptionForSplitEmptyList() {\n        final SplitterQuadratic q = new SplitterQuadratic();\n        q.split(Collections.<HasGeometry> emptyList(), 3);\n    }", "docstring": "", "attributes": {"modifiers": "@Test(expected = RuntimeException.class)\n    public", "marker_annotations": [], "non_marker_annotations": ["@Test(expected = RuntimeException.class)", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "testExceptionForSplitEmptyList", "params": [], "body": "                                                 {\n        final SplitterQuadratic q = new SplitterQuadratic();\n        q.split(Collections.<HasGeometry> emptyList(), 3);\n    }", "signature": "@Test(expected = RuntimeException.class)\n    public void testExceptionForSplitEmptyList()"}, {"syntax_pass": true, "original_string": "    private static Mbr r(int n) {\n        return new Mbr(Geometries.rectangle(n, n, n + 1, n + 1));\n    }", "docstring": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "Mbr", "classes": []}, "name": "r", "params": [{"name": "n", "type": "int"}], "body": "                                {\n        return new Mbr(Geometries.rectangle(n, n, n + 1, n + 1));\n    }", "signature": "private static Mbr r(int n)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/com/github/davidmoten/rtree/LatLongExampleTest.java", "original_string": "package com.github.davidmoten.rtree;\n\nimport static org.junit.Assert.assertEquals;\n\nimport java.util.List;\n\nimport org.junit.Test;\n\nimport com.github.davidmoten.grumpy.core.Position;\nimport com.github.davidmoten.rtree.geometry.Geometries;\nimport com.github.davidmoten.rtree.geometry.Point;\nimport com.github.davidmoten.rtree.geometry.Rectangle;\n\nimport rx.Observable;\nimport rx.functions.Func1;\n\npublic class LatLongExampleTest {\n\n    private static final Point sydney = Geometries.point(151.2094, -33.86);\n    private static final Point canberra = Geometries.point(149.1244, -35.3075);\n    private static final Point brisbane = Geometries.point(153.0278, -27.4679);\n    private static final Point bungendore = Geometries.point(149.4500, -35.2500);\n\n    @Test\n    public void testLatLongExample() {\n\n        // This is to demonstrate how to use rtree to to do distance searches\n        // with Lat Long points\n\n        // Let's find all cities within 300km of Canberra\n\n        RTree<String, Point> tree = RTree.star().create();\n        tree = tree.add(\"Sydney\", sydney);\n        tree = tree.add(\"Brisbane\", brisbane);\n\n        // Now search for all locations within 300km of Canberra\n        final double distanceKm = 300;\n        List<Entry<String, Point>> list = search(tree, canberra, distanceKm)\n                // get the result\n                .toList().toBlocking().single();\n\n        // should have returned Sydney only\n        assertEquals(1, list.size());\n        assertEquals(\"Sydney\", list.get(0).value());\n    }\n\n    public static <T> Observable<Entry<T, Point>> search(RTree<T, Point> tree, Point lonLat,\n            final double distanceKm) {\n        // First we need to calculate an enclosing lat long rectangle for this\n        // distance then we refine on the exact distance\n        final Position from = Position.create(lonLat.y(), lonLat.x());\n        Rectangle bounds = createBounds(from, distanceKm);\n\n        return tree\n                // do the first search using the bounds\n                .search(bounds)\n                // refine using the exact distance\n                .filter(new Func1<Entry<T, Point>, Boolean>() {\n                    @Override\n                    public Boolean call(Entry<T, Point> entry) {\n                        Point p = entry.geometry();\n                        Position position = Position.create(p.y(), p.x());\n                        return from.getDistanceToKm(position) < distanceKm;\n                    }\n                });\n    }\n\n    @Test\n    public void testSearchLatLongCircles() {\n        RTree<GeoCircleValue<String>, Rectangle> tree = RTree.star().create();\n        // create circles around these major towns\n        GeoCircleValue<String> sydneyCircle = createGeoCircleValue(sydney, 100, \"Sydney\");\n        GeoCircleValue<String> canberraCircle = createGeoCircleValue(canberra, 50, \"Canberra\");\n        GeoCircleValue<String> brisbaneCircle = createGeoCircleValue(brisbane, 200, \"Brisbane\");\n\n        // add the circles to the RTree using the bounding box of the circle as\n        // the geometry\n        tree = add(tree, sydneyCircle);\n        tree = add(tree, canberraCircle);\n        tree = add(tree, brisbaneCircle);\n\n        // now find the circles that contain bungendore (which is 30km from\n        // Canberra)\n        final Point location = bungendore;\n        String result = tree.search(location)\n                // filter on the exact distance from the centre of the GeoCircle\n                .filter(new Func1<Entry<GeoCircleValue<String>, Rectangle>, Boolean>() {\n                    Position from = Position.create(location.y(), location.x());\n\n                    @Override\n                    public Boolean call(Entry<GeoCircleValue<String>, Rectangle> entry) {\n                        Position centre = Position.create(entry.value().lat, entry.value().lon);\n                        return from.getDistanceToKm(centre) < entry.value().radiusKm;\n                    }\n                })\n                // do the search (only expect one value)\n                .toBlocking().single()\n                // get the name of the GoeCircleValue returned\n                .value().value;\n        assertEquals(\"Canberra\", result);\n    }\n\n    private static Rectangle createBounds(final Position from, final double distanceKm) {\n        // this calculates a pretty accurate bounding box. Depending on the\n        // performance you require you wouldn't have to be this accurate because\n        // accuracy is enforced later\n        Position north = from.predict(distanceKm, 0);\n        Position south = from.predict(distanceKm, 180);\n        Position east = from.predict(distanceKm, 90);\n        Position west = from.predict(distanceKm, 270);\n\n        return Geometries.rectangle(west.getLon(), south.getLat(), east.getLon(), north.getLat());\n    }\n\n    private static <T> GeoCircleValue<T> createGeoCircleValue(Point point, double radiusKm,\n            T value) {\n        return new GeoCircleValue<T>((float) point.y(), (float) point.x(), radiusKm, value);\n    }\n\n    private static <T> RTree<GeoCircleValue<T>, Rectangle> add(\n            RTree<GeoCircleValue<T>, Rectangle> tree, GeoCircleValue<T> c) {\n        return tree.add(c, createBounds(Position.create(c.lat, c.lon), c.radiusKm));\n    }\n\n    private static class GeoCircleValue<T> {\n\n        GeoCircleValue(float lat, float lon, double radiusKm, T value) {\n            this.lat = lat;\n            this.lon = lon;\n            this.radiusKm = radiusKm;\n            this.value = value;\n        }\n\n        float lat;\n        float lon;\n        double radiusKm;\n        T value;\n    }\n}\n", "file_hash": "4a4a28067bfcb0fceef1dba936cb3dab1b834b6a0d52126700343822cb19d6b8", "file_docstring": "", "contexts": ["package com.github.davidmoten.rtree;", "import static org.junit.Assert.assertEquals;", "import java.util.List;", "import org.junit.Test;", "import com.github.davidmoten.grumpy.core.Position;", "import com.github.davidmoten.rtree.geometry.Geometries;", "import com.github.davidmoten.rtree.geometry.Point;", "import com.github.davidmoten.rtree.geometry.Rectangle;", "import rx.Observable;", "import rx.functions.Func1;"], "methods": [], "classes": [{"original_string": "public class LatLongExampleTest {\n\n    private static final Point sydney = Geometries.point(151.2094, -33.86);\n    private static final Point canberra = Geometries.point(149.1244, -35.3075);\n    private static final Point brisbane = Geometries.point(153.0278, -27.4679);\n    private static final Point bungendore = Geometries.point(149.4500, -35.2500);\n\n    @Test\n    public void testLatLongExample() {\n\n        // This is to demonstrate how to use rtree to to do distance searches\n        // with Lat Long points\n\n        // Let's find all cities within 300km of Canberra\n\n        RTree<String, Point> tree = RTree.star().create();\n        tree = tree.add(\"Sydney\", sydney);\n        tree = tree.add(\"Brisbane\", brisbane);\n\n        // Now search for all locations within 300km of Canberra\n        final double distanceKm = 300;\n        List<Entry<String, Point>> list = search(tree, canberra, distanceKm)\n                // get the result\n                .toList().toBlocking().single();\n\n        // should have returned Sydney only\n        assertEquals(1, list.size());\n        assertEquals(\"Sydney\", list.get(0).value());\n    }\n\n    public static <T> Observable<Entry<T, Point>> search(RTree<T, Point> tree, Point lonLat,\n            final double distanceKm) {\n        // First we need to calculate an enclosing lat long rectangle for this\n        // distance then we refine on the exact distance\n        final Position from = Position.create(lonLat.y(), lonLat.x());\n        Rectangle bounds = createBounds(from, distanceKm);\n\n        return tree\n                // do the first search using the bounds\n                .search(bounds)\n                // refine using the exact distance\n                .filter(new Func1<Entry<T, Point>, Boolean>() {\n                    @Override\n                    public Boolean call(Entry<T, Point> entry) {\n                        Point p = entry.geometry();\n                        Position position = Position.create(p.y(), p.x());\n                        return from.getDistanceToKm(position) < distanceKm;\n                    }\n                });\n    }\n\n    @Test\n    public void testSearchLatLongCircles() {\n        RTree<GeoCircleValue<String>, Rectangle> tree = RTree.star().create();\n        // create circles around these major towns\n        GeoCircleValue<String> sydneyCircle = createGeoCircleValue(sydney, 100, \"Sydney\");\n        GeoCircleValue<String> canberraCircle = createGeoCircleValue(canberra, 50, \"Canberra\");\n        GeoCircleValue<String> brisbaneCircle = createGeoCircleValue(brisbane, 200, \"Brisbane\");\n\n        // add the circles to the RTree using the bounding box of the circle as\n        // the geometry\n        tree = add(tree, sydneyCircle);\n        tree = add(tree, canberraCircle);\n        tree = add(tree, brisbaneCircle);\n\n        // now find the circles that contain bungendore (which is 30km from\n        // Canberra)\n        final Point location = bungendore;\n        String result = tree.search(location)\n                // filter on the exact distance from the centre of the GeoCircle\n                .filter(new Func1<Entry<GeoCircleValue<String>, Rectangle>, Boolean>() {\n                    Position from = Position.create(location.y(), location.x());\n\n                    @Override\n                    public Boolean call(Entry<GeoCircleValue<String>, Rectangle> entry) {\n                        Position centre = Position.create(entry.value().lat, entry.value().lon);\n                        return from.getDistanceToKm(centre) < entry.value().radiusKm;\n                    }\n                })\n                // do the search (only expect one value)\n                .toBlocking().single()\n                // get the name of the GoeCircleValue returned\n                .value().value;\n        assertEquals(\"Canberra\", result);\n    }\n\n    private static Rectangle createBounds(final Position from, final double distanceKm) {\n        // this calculates a pretty accurate bounding box. Depending on the\n        // performance you require you wouldn't have to be this accurate because\n        // accuracy is enforced later\n        Position north = from.predict(distanceKm, 0);\n        Position south = from.predict(distanceKm, 180);\n        Position east = from.predict(distanceKm, 90);\n        Position west = from.predict(distanceKm, 270);\n\n        return Geometries.rectangle(west.getLon(), south.getLat(), east.getLon(), north.getLat());\n    }\n\n    private static <T> GeoCircleValue<T> createGeoCircleValue(Point point, double radiusKm,\n            T value) {\n        return new GeoCircleValue<T>((float) point.y(), (float) point.x(), radiusKm, value);\n    }\n\n    private static <T> RTree<GeoCircleValue<T>, Rectangle> add(\n            RTree<GeoCircleValue<T>, Rectangle> tree, GeoCircleValue<T> c) {\n        return tree.add(c, createBounds(Position.create(c.lat, c.lon), c.radiusKm));\n    }\n\n    private static class GeoCircleValue<T> {\n\n        GeoCircleValue(float lat, float lon, double radiusKm, T value) {\n            this.lat = lat;\n            this.lon = lon;\n            this.radiusKm = radiusKm;\n            this.value = value;\n        }\n\n        float lat;\n        float lon;\n        double radiusKm;\n        T value;\n    }\n}", "definition": "public class LatLongExampleTest", "class_docstring": "", "name": "LatLongExampleTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private static final Point sydney = Geometries.point(151.2094, -33.86);", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Point", "name": "sydney = Geometries.point(151.2094, -33.86)", "syntax_pass": true}, {"attribute_expression": "private static final Point canberra = Geometries.point(149.1244, -35.3075);", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Point", "name": "canberra = Geometries.point(149.1244, -35.3075)", "syntax_pass": true}, {"attribute_expression": "private static final Point brisbane = Geometries.point(153.0278, -27.4679);", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Point", "name": "brisbane = Geometries.point(153.0278, -27.4679)", "syntax_pass": true}, {"attribute_expression": "private static final Point bungendore = Geometries.point(149.4500, -35.2500);", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Point", "name": "bungendore = Geometries.point(149.4500, -35.2500)", "syntax_pass": true}], "classes": [{"original_string": "    private static class GeoCircleValue<T> {\n\n        GeoCircleValue(float lat, float lon, double radiusKm, T value) {\n            this.lat = lat;\n            this.lon = lon;\n            this.radiusKm = radiusKm;\n            this.value = value;\n        }\n\n        float lat;\n        float lon;\n        double radiusKm;\n        T value;\n    }", "definition": "    private static class GeoCircleValue<T>", "class_docstring": "", "name": "GeoCircleValue", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "fields": [{"attribute_expression": "float lat;", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "float", "name": "lat", "syntax_pass": true}, {"attribute_expression": "float lon;", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "float", "name": "lon", "syntax_pass": true}, {"attribute_expression": "double radiusKm;", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "double", "name": "radiusKm", "syntax_pass": true}, {"attribute_expression": "T value;", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "T", "name": "value", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        GeoCircleValue(float lat, float lon, double radiusKm, T value) {\n            this.lat = lat;\n            this.lon = lon;\n            this.radiusKm = radiusKm;\n            this.value = value;\n        }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "GeoCircleValue", "params": [{"name": "lat", "type": "float"}, {"name": "lon", "type": "float"}, {"name": "radiusKm", "type": "double"}, {"name": "value", "type": "T"}], "body": "                                                                       {\n            this.lat = lat;\n            this.lon = lon;\n            this.radiusKm = radiusKm;\n            this.value = value;\n        }", "signature": "GeoCircleValue(float lat, float lon, double radiusKm, T value)"}]}]}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @Test\n    public void testLatLongExample() {\n\n        // This is to demonstrate how to use rtree to to do distance searches\n        // with Lat Long points\n\n        // Let's find all cities within 300km of Canberra\n\n        RTree<String, Point> tree = RTree.star().create();\n        tree = tree.add(\"Sydney\", sydney);\n        tree = tree.add(\"Brisbane\", brisbane);\n\n        // Now search for all locations within 300km of Canberra\n        final double distanceKm = 300;\n        List<Entry<String, Point>> list = search(tree, canberra, distanceKm)\n                // get the result\n                .toList().toBlocking().single();\n\n        // should have returned Sydney only\n        assertEquals(1, list.size());\n        assertEquals(\"Sydney\", list.get(0).value());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testLatLongExample", "params": [], "body": "                                     {\n\n        // This is to demonstrate how to use rtree to to do distance searches\n        // with Lat Long points\n\n        // Let's find all cities within 300km of Canberra\n\n        RTree<String, Point> tree = RTree.star().create();\n        tree = tree.add(\"Sydney\", sydney);\n        tree = tree.add(\"Brisbane\", brisbane);\n\n        // Now search for all locations within 300km of Canberra\n        final double distanceKm = 300;\n        List<Entry<String, Point>> list = search(tree, canberra, distanceKm)\n                // get the result\n                .toList().toBlocking().single();\n\n        // should have returned Sydney only\n        assertEquals(1, list.size());\n        assertEquals(\"Sydney\", list.get(0).value());\n    }", "signature": "@Test\n    public void testLatLongExample()"}, {"syntax_pass": true, "original_string": "    public static <T> Observable<Entry<T, Point>> search(RTree<T, Point> tree, Point lonLat,\n            final double distanceKm) {\n        // First we need to calculate an enclosing lat long rectangle for this\n        // distance then we refine on the exact distance\n        final Position from = Position.create(lonLat.y(), lonLat.x());\n        Rectangle bounds = createBounds(from, distanceKm);\n\n        return tree\n                // do the first search using the bounds\n                .search(bounds)\n                // refine using the exact distance\n                .filter(new Func1<Entry<T, Point>, Boolean>() {\n                    @Override\n                    public Boolean call(Entry<T, Point> entry) {\n                        Point p = entry.geometry();\n                        Position position = Position.create(p.y(), p.x());\n                        return from.getDistanceToKm(position) < distanceKm;\n                    }\n                });\n    }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Observable<Entry<T, Point>>", "classes": []}, "name": "search", "params": [{"name": "tree", "type": "RTree<T, Point>"}, {"name": "lonLat", "type": "Point"}, {"name": "distanceKm", "type": "double"}], "body": "                                     {\n        // First we need to calculate an enclosing lat long rectangle for this\n        // distance then we refine on the exact distance\n        final Position from = Position.create(lonLat.y(), lonLat.x());\n        Rectangle bounds = createBounds(from, distanceKm);\n\n        return tree\n                // do the first search using the bounds\n                .search(bounds)\n                // refine using the exact distance\n                .filter(new Func1<Entry<T, Point>, Boolean>() {\n                    @Override\n                    public Boolean call(Entry<T, Point> entry) {\n                        Point p = entry.geometry();\n                        Position position = Position.create(p.y(), p.x());\n                        return from.getDistanceToKm(position) < distanceKm;\n                    }\n                });\n    }", "signature": "public static <T> Observable<Entry<T, Point>> search(RTree<T, Point> tree, Point lonLat,\n            final double distanceKm)"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testSearchLatLongCircles() {\n        RTree<GeoCircleValue<String>, Rectangle> tree = RTree.star().create();\n        // create circles around these major towns\n        GeoCircleValue<String> sydneyCircle = createGeoCircleValue(sydney, 100, \"Sydney\");\n        GeoCircleValue<String> canberraCircle = createGeoCircleValue(canberra, 50, \"Canberra\");\n        GeoCircleValue<String> brisbaneCircle = createGeoCircleValue(brisbane, 200, \"Brisbane\");\n\n        // add the circles to the RTree using the bounding box of the circle as\n        // the geometry\n        tree = add(tree, sydneyCircle);\n        tree = add(tree, canberraCircle);\n        tree = add(tree, brisbaneCircle);\n\n        // now find the circles that contain bungendore (which is 30km from\n        // Canberra)\n        final Point location = bungendore;\n        String result = tree.search(location)\n                // filter on the exact distance from the centre of the GeoCircle\n                .filter(new Func1<Entry<GeoCircleValue<String>, Rectangle>, Boolean>() {\n                    Position from = Position.create(location.y(), location.x());\n\n                    @Override\n                    public Boolean call(Entry<GeoCircleValue<String>, Rectangle> entry) {\n                        Position centre = Position.create(entry.value().lat, entry.value().lon);\n                        return from.getDistanceToKm(centre) < entry.value().radiusKm;\n                    }\n                })\n                // do the search (only expect one value)\n                .toBlocking().single()\n                // get the name of the GoeCircleValue returned\n                .value().value;\n        assertEquals(\"Canberra\", result);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testSearchLatLongCircles", "params": [], "body": "                                           {\n        RTree<GeoCircleValue<String>, Rectangle> tree = RTree.star().create();\n        // create circles around these major towns\n        GeoCircleValue<String> sydneyCircle = createGeoCircleValue(sydney, 100, \"Sydney\");\n        GeoCircleValue<String> canberraCircle = createGeoCircleValue(canberra, 50, \"Canberra\");\n        GeoCircleValue<String> brisbaneCircle = createGeoCircleValue(brisbane, 200, \"Brisbane\");\n\n        // add the circles to the RTree using the bounding box of the circle as\n        // the geometry\n        tree = add(tree, sydneyCircle);\n        tree = add(tree, canberraCircle);\n        tree = add(tree, brisbaneCircle);\n\n        // now find the circles that contain bungendore (which is 30km from\n        // Canberra)\n        final Point location = bungendore;\n        String result = tree.search(location)\n                // filter on the exact distance from the centre of the GeoCircle\n                .filter(new Func1<Entry<GeoCircleValue<String>, Rectangle>, Boolean>() {\n                    Position from = Position.create(location.y(), location.x());\n\n                    @Override\n                    public Boolean call(Entry<GeoCircleValue<String>, Rectangle> entry) {\n                        Position centre = Position.create(entry.value().lat, entry.value().lon);\n                        return from.getDistanceToKm(centre) < entry.value().radiusKm;\n                    }\n                })\n                // do the search (only expect one value)\n                .toBlocking().single()\n                // get the name of the GoeCircleValue returned\n                .value().value;\n        assertEquals(\"Canberra\", result);\n    }", "signature": "@Test\n    public void testSearchLatLongCircles()"}, {"syntax_pass": true, "original_string": "    private static Rectangle createBounds(final Position from, final double distanceKm) {\n        // this calculates a pretty accurate bounding box. Depending on the\n        // performance you require you wouldn't have to be this accurate because\n        // accuracy is enforced later\n        Position north = from.predict(distanceKm, 0);\n        Position south = from.predict(distanceKm, 180);\n        Position east = from.predict(distanceKm, 90);\n        Position west = from.predict(distanceKm, 270);\n\n        return Geometries.rectangle(west.getLon(), south.getLat(), east.getLon(), north.getLat());\n    }", "docstring": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "Rectangle", "classes": []}, "name": "createBounds", "params": [{"name": "from", "type": "Position"}, {"name": "distanceKm", "type": "double"}], "body": "                                                                                        {\n        // this calculates a pretty accurate bounding box. Depending on the\n        // performance you require you wouldn't have to be this accurate because\n        // accuracy is enforced later\n        Position north = from.predict(distanceKm, 0);\n        Position south = from.predict(distanceKm, 180);\n        Position east = from.predict(distanceKm, 90);\n        Position west = from.predict(distanceKm, 270);\n\n        return Geometries.rectangle(west.getLon(), south.getLat(), east.getLon(), north.getLat());\n    }", "signature": "private static Rectangle createBounds(final Position from, final double distanceKm)"}, {"syntax_pass": true, "original_string": "    private static <T> GeoCircleValue<T> createGeoCircleValue(Point point, double radiusKm,\n            T value) {\n        return new GeoCircleValue<T>((float) point.y(), (float) point.x(), radiusKm, value);\n    }", "docstring": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "GeoCircleValue<T>", "classes": []}, "name": "createGeoCircleValue", "params": [{"name": "point", "type": "Point"}, {"name": "radiusKm", "type": "double"}, {"name": "value", "type": "T"}], "body": "                     {\n        return new GeoCircleValue<T>((float) point.y(), (float) point.x(), radiusKm, value);\n    }", "signature": "private static <T> GeoCircleValue<T> createGeoCircleValue(Point point, double radiusKm,\n            T value)"}, {"syntax_pass": true, "original_string": "    private static <T> RTree<GeoCircleValue<T>, Rectangle> add(\n            RTree<GeoCircleValue<T>, Rectangle> tree, GeoCircleValue<T> c) {\n        return tree.add(c, createBounds(Position.create(c.lat, c.lon), c.radiusKm));\n    }", "docstring": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "RTree<GeoCircleValue<T>, Rectangle>", "classes": []}, "name": "add", "params": [{"name": "tree", "type": "RTree<GeoCircleValue<T>, Rectangle>"}, {"name": "c", "type": "GeoCircleValue<T>"}], "body": "                                                                           {\n        return tree.add(c, createBounds(Position.create(c.lat, c.lon), c.radiusKm));\n    }", "signature": "private static <T> RTree<GeoCircleValue<T>, Rectangle> add(\n            RTree<GeoCircleValue<T>, Rectangle> tree, GeoCircleValue<T> c)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/com/github/davidmoten/rtree/SerializersTest.java", "original_string": "package com.github.davidmoten.rtree;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertTrue;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\n\nimport org.junit.Test;\n\nimport com.github.davidmoten.guavamini.Sets;\nimport com.github.davidmoten.junit.Asserts;\nimport com.github.davidmoten.rtree.geometry.Circle;\nimport com.github.davidmoten.rtree.geometry.Geometries;\nimport com.github.davidmoten.rtree.geometry.Geometry;\nimport com.github.davidmoten.rtree.geometry.Line;\nimport com.github.davidmoten.rtree.geometry.Point;\nimport com.github.davidmoten.rtree.geometry.Rectangle;\n\npublic class SerializersTest {\n\n    @Test\n    public void testJavaIoSerialization() throws IOException {\n        Serializer<String, Point> serializer = Serializers.flatBuffers().javaIo();\n        checkRoundTripPoint(serializer);\n    }\n\n    @Test\n    public void testStringPointSerialization() throws IOException {\n        Serializer<String, Point> serializer = Serializers.flatBuffers().utf8();\n        checkRoundTripPoint(serializer);\n    }\n\n    @Test\n    public void testStringRectangleFloatSerialization() throws IOException {\n        Serializer<String, Rectangle> serializer = Serializers.flatBuffers().utf8();\n        Entry<String, Rectangle> a = Entries.entry(\"hello\", Geometries.rectangle(1, 2, 3, 4));\n        Entry<String, Rectangle> b = Entries.entry(\"there\", Geometries.rectangle(3, 4, 5, 6));\n        check(serializer, a, b);\n    }\n\n    @Test\n    public void testStringRectangleDoubleSerialization() throws IOException {\n        Serializer<String, Rectangle> serializer = Serializers.flatBuffers().utf8();\n        Entry<String, Rectangle> a = Entries.entry(\"hello\",\n                Geometries.rectangle(1.0000000001, 2, 3, 4));\n        Entry<String, Rectangle> b = Entries.entry(\"there\",\n                Geometries.rectangle(3.0000000001, 4, 5, 6));\n        check(serializer, a, b);\n    }\n\n    @Test\n    public void testStringCircleFloatSerialization() throws IOException {\n        Serializer<String, Circle> serializer = Serializers.flatBuffers().utf8();\n        Entry<String, Circle> a = Entries.entry(\"hello\", Geometries.circle(1, 2, 3));\n        Entry<String, Circle> b = Entries.entry(\"there\", Geometries.circle(3, 4, 5));\n        check(serializer, a, b);\n    }\n\n    @Test\n    public void testStringCircleDoubleSerialization() throws IOException {\n        Serializer<String, Circle> serializer = Serializers.flatBuffers().utf8();\n        Entry<String, Circle> a = Entries.entry(\"hello\", Geometries.circle(1.0000000001, 2, 3));\n        Entry<String, Circle> b = Entries.entry(\"there\", Geometries.circle(3.0000000001, 4, 5));\n        check(serializer, a, b);\n    }\n\n    @Test\n    public void testStringLineFloatSerialization() throws IOException {\n        Serializer<String, Line> serializer = Serializers.flatBuffers().utf8();\n        Entry<String, Line> a = Entries.entry(\"hello\", Geometries.line(1, 2, 3, 4));\n        Entry<String, Line> b = Entries.entry(\"there\", Geometries.line(3, 4, 5, 6));\n        check(serializer, a, b);\n    }\n\n    @Test\n    public void testStringLineDoubleSerialization() throws IOException {\n        Serializer<String, Line> serializer = Serializers.flatBuffers().utf8();\n        Entry<String, Line> a = Entries.entry(\"hello\", Geometries.line(1.0000000001, 2, 3, 4));\n        Entry<String, Line> b = Entries.entry(\"there\", Geometries.line(3.0000000001, 4, 5, 6));\n        check(serializer, a, b);\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @Test\n    public void testAddToFlatBuffers() throws IOException {\n        Entry<String, Point> a = Entries.entry(\"hello\", Geometries.point(1, 2));\n        Entry<String, Point> b = Entries.entry(\"there\", Geometries.point(3, 4));\n        Entry<String, Point> c = Entries.entry(\"you\", Geometries.point(5, 6));\n        RTree<String, Point> tree = RTree.create();\n        tree = tree.add(a).add(b);\n        Serializer<String, Point> serializer = Serializers.flatBuffers().utf8();\n        ByteArrayOutputStream bytes = new ByteArrayOutputStream();\n        serializer.write(tree, bytes);\n        bytes.close();\n        byte[] array = bytes.toByteArray();\n        RTree<String, Point> tree2 = serializer.read(new ByteArrayInputStream(array), array.length,\n                InternalStructure.SINGLE_ARRAY);\n        tree2 = tree2.add(c);\n        assertEquals(Sets.newHashSet(a, b, c),\n                Sets.newHashSet(tree2.entries().toList().toBlocking().single()));\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @Test\n    public void testDeleteFromFlatBuffers() throws IOException {\n        Entry<String, Point> a = Entries.entry(\"hello\", Geometries.point(1, 2));\n        Entry<String, Point> b = Entries.entry(\"there\", Geometries.point(3, 4));\n        RTree<String, Point> tree = RTree.create();\n        tree = tree.add(a).add(b);\n        Serializer<String, Point> serializer = Serializers.flatBuffers().utf8();\n        ByteArrayOutputStream bytes = new ByteArrayOutputStream();\n        serializer.write(tree, bytes);\n        bytes.close();\n        byte[] array = bytes.toByteArray();\n        RTree<String, Point> tree2 = serializer.read(new ByteArrayInputStream(array), array.length,\n                InternalStructure.SINGLE_ARRAY);\n        tree2 = tree2.delete(a);\n        assertEquals(Sets.newHashSet(b),\n                Sets.newHashSet(tree2.entries().toList().toBlocking().single()));\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @Test\n    public void testAddToFlatBuffersWhenRootNodeIsNonLeaf() throws IOException {\n        Entry<String, Point> a = Entries.entry(\"hello\", Geometries.point(1, 2));\n        Entry<String, Point> b = Entries.entry(\"there\", Geometries.point(3, 4));\n        Entry<String, Point> c = Entries.entry(\"you\", Geometries.point(5, 6));\n        Entry<String, Point> d = Entries.entry(\"smart\", Geometries.point(7, 8));\n        Entry<String, Point> e = Entries.entry(\"person\", Geometries.point(9, 10));\n        RTree<String, Point> tree = RTree.create();\n        tree = tree.add(a).add(b).add(c).add(d).add(e);\n        Serializer<String, Point> serializer = Serializers.flatBuffers().utf8();\n        ByteArrayOutputStream bytes = new ByteArrayOutputStream();\n        serializer.write(tree, bytes);\n        bytes.close();\n        byte[] array = bytes.toByteArray();\n        RTree<String, Point> tree2 = serializer.read(new ByteArrayInputStream(array), array.length,\n                InternalStructure.SINGLE_ARRAY);\n        tree2 = tree2.add(c);\n        assertEquals(Sets.newHashSet(a, b, c, d, e),\n                Sets.newHashSet(tree2.entries().toList().toBlocking().single()));\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @Test\n    public void testDeleteFromFlatBuffersWhenRootNodeIsNonLeaf() throws IOException {\n        Entry<String, Point> a = Entries.entry(\"hello\", Geometries.point(1, 2));\n        Entry<String, Point> b = Entries.entry(\"there\", Geometries.point(3, 4));\n        Entry<String, Point> c = Entries.entry(\"you\", Geometries.point(5, 6));\n        Entry<String, Point> d = Entries.entry(\"smart\", Geometries.point(7, 8));\n        Entry<String, Point> e = Entries.entry(\"person\", Geometries.point(9, 10));\n        RTree<String, Point> tree = RTree.create();\n        tree = tree.add(a).add(b).add(c).add(d).add(e);\n        Serializer<String, Point> serializer = Serializers.flatBuffers().utf8();\n        ByteArrayOutputStream bytes = new ByteArrayOutputStream();\n        serializer.write(tree, bytes);\n        bytes.close();\n        byte[] array = bytes.toByteArray();\n        RTree<String, Point> tree2 = serializer.read(new ByteArrayInputStream(array), array.length,\n                InternalStructure.SINGLE_ARRAY);\n        tree2 = tree2.delete(b);\n        assertEquals(Sets.newHashSet(a, c, d, e),\n                Sets.newHashSet(tree2.entries().toList().toBlocking().single()));\n    }\n\n    @Test\n    public void canRoundTripEmptyTree() throws IOException {\n        RTree<String, Point> tree = RTree.create();\n        Serializer<String, Point> serializer = Serializers.flatBuffers().utf8();\n        ByteArrayOutputStream bytes = new ByteArrayOutputStream();\n        serializer.write(tree, bytes);\n        bytes.close();\n        byte[] array = bytes.toByteArray();\n        RTree<String, Point> tree2 = serializer.read(new ByteArrayInputStream(array), array.length,\n                InternalStructure.SINGLE_ARRAY);\n        assertTrue(tree2.isEmpty());\n    }\n\n    private static void checkRoundTripPoint(Serializer<String, Point> serializer)\n            throws IOException {\n        Entry<String, Point> a = Entries.entry(\"hello\", Geometries.point(1, 2));\n        Entry<String, Point> b = Entries.entry(\"there\", Geometries.point(3, 4));\n        check(serializer, a, b);\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private static <S extends Geometry> void check(Serializer<String, S> serializer,\n            Entry<String, S> a, Entry<String, S> b) throws IOException {\n        RTree<String, S> tree = RTree.create();\n        tree = tree.add(a).add(b);\n        ByteArrayOutputStream bytes = new ByteArrayOutputStream();\n        serializer.write(tree, bytes);\n        bytes.close();\n        {\n            ByteArrayInputStream input = new ByteArrayInputStream(bytes.toByteArray());\n            RTree<String, S> tree2 = serializer.read(input, bytes.size(),\n                    InternalStructure.DEFAULT);\n            assertEquals(2, tree2.size());\n            assertEquals(Sets.newHashSet(a, b),\n                    Sets.newHashSet(tree2.entries().toList().toBlocking().single()));\n        }\n        {\n            ByteArrayInputStream input = new ByteArrayInputStream(bytes.toByteArray());\n            RTree<String, S> tree2 = serializer.read(input, bytes.size(),\n                    InternalStructure.SINGLE_ARRAY);\n            assertEquals(2, tree2.size());\n            assertEquals(Sets.newHashSet(a, b),\n                    Sets.newHashSet(tree2.entries().toList().toBlocking().single()));\n        }\n    }\n\n    @Test\n    public void isUtilityClass() {\n        Asserts.assertIsUtilityClass(Serializers.class);\n    }\n\n}\n", "file_hash": "1fa7b56a810f9de210a9f7b2c680c6e800c3afa482bc46b9c20665fdf1da2b82", "file_docstring": "", "contexts": ["package com.github.davidmoten.rtree;", "import static org.junit.Assert.assertEquals;", "import static org.junit.Assert.assertTrue;", "import java.io.ByteArrayInputStream;", "import java.io.ByteArrayOutputStream;", "import java.io.IOException;", "import org.junit.Test;", "import com.github.davidmoten.guavamini.Sets;", "import com.github.davidmoten.junit.Asserts;", "import com.github.davidmoten.rtree.geometry.Circle;", "import com.github.davidmoten.rtree.geometry.Geometries;", "import com.github.davidmoten.rtree.geometry.Geometry;", "import com.github.davidmoten.rtree.geometry.Line;", "import com.github.davidmoten.rtree.geometry.Point;", "import com.github.davidmoten.rtree.geometry.Rectangle;"], "methods": [], "classes": [{"original_string": "public class SerializersTest {\n\n    @Test\n    public void testJavaIoSerialization() throws IOException {\n        Serializer<String, Point> serializer = Serializers.flatBuffers().javaIo();\n        checkRoundTripPoint(serializer);\n    }\n\n    @Test\n    public void testStringPointSerialization() throws IOException {\n        Serializer<String, Point> serializer = Serializers.flatBuffers().utf8();\n        checkRoundTripPoint(serializer);\n    }\n\n    @Test\n    public void testStringRectangleFloatSerialization() throws IOException {\n        Serializer<String, Rectangle> serializer = Serializers.flatBuffers().utf8();\n        Entry<String, Rectangle> a = Entries.entry(\"hello\", Geometries.rectangle(1, 2, 3, 4));\n        Entry<String, Rectangle> b = Entries.entry(\"there\", Geometries.rectangle(3, 4, 5, 6));\n        check(serializer, a, b);\n    }\n\n    @Test\n    public void testStringRectangleDoubleSerialization() throws IOException {\n        Serializer<String, Rectangle> serializer = Serializers.flatBuffers().utf8();\n        Entry<String, Rectangle> a = Entries.entry(\"hello\",\n                Geometries.rectangle(1.0000000001, 2, 3, 4));\n        Entry<String, Rectangle> b = Entries.entry(\"there\",\n                Geometries.rectangle(3.0000000001, 4, 5, 6));\n        check(serializer, a, b);\n    }\n\n    @Test\n    public void testStringCircleFloatSerialization() throws IOException {\n        Serializer<String, Circle> serializer = Serializers.flatBuffers().utf8();\n        Entry<String, Circle> a = Entries.entry(\"hello\", Geometries.circle(1, 2, 3));\n        Entry<String, Circle> b = Entries.entry(\"there\", Geometries.circle(3, 4, 5));\n        check(serializer, a, b);\n    }\n\n    @Test\n    public void testStringCircleDoubleSerialization() throws IOException {\n        Serializer<String, Circle> serializer = Serializers.flatBuffers().utf8();\n        Entry<String, Circle> a = Entries.entry(\"hello\", Geometries.circle(1.0000000001, 2, 3));\n        Entry<String, Circle> b = Entries.entry(\"there\", Geometries.circle(3.0000000001, 4, 5));\n        check(serializer, a, b);\n    }\n\n    @Test\n    public void testStringLineFloatSerialization() throws IOException {\n        Serializer<String, Line> serializer = Serializers.flatBuffers().utf8();\n        Entry<String, Line> a = Entries.entry(\"hello\", Geometries.line(1, 2, 3, 4));\n        Entry<String, Line> b = Entries.entry(\"there\", Geometries.line(3, 4, 5, 6));\n        check(serializer, a, b);\n    }\n\n    @Test\n    public void testStringLineDoubleSerialization() throws IOException {\n        Serializer<String, Line> serializer = Serializers.flatBuffers().utf8();\n        Entry<String, Line> a = Entries.entry(\"hello\", Geometries.line(1.0000000001, 2, 3, 4));\n        Entry<String, Line> b = Entries.entry(\"there\", Geometries.line(3.0000000001, 4, 5, 6));\n        check(serializer, a, b);\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @Test\n    public void testAddToFlatBuffers() throws IOException {\n        Entry<String, Point> a = Entries.entry(\"hello\", Geometries.point(1, 2));\n        Entry<String, Point> b = Entries.entry(\"there\", Geometries.point(3, 4));\n        Entry<String, Point> c = Entries.entry(\"you\", Geometries.point(5, 6));\n        RTree<String, Point> tree = RTree.create();\n        tree = tree.add(a).add(b);\n        Serializer<String, Point> serializer = Serializers.flatBuffers().utf8();\n        ByteArrayOutputStream bytes = new ByteArrayOutputStream();\n        serializer.write(tree, bytes);\n        bytes.close();\n        byte[] array = bytes.toByteArray();\n        RTree<String, Point> tree2 = serializer.read(new ByteArrayInputStream(array), array.length,\n                InternalStructure.SINGLE_ARRAY);\n        tree2 = tree2.add(c);\n        assertEquals(Sets.newHashSet(a, b, c),\n                Sets.newHashSet(tree2.entries().toList().toBlocking().single()));\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @Test\n    public void testDeleteFromFlatBuffers() throws IOException {\n        Entry<String, Point> a = Entries.entry(\"hello\", Geometries.point(1, 2));\n        Entry<String, Point> b = Entries.entry(\"there\", Geometries.point(3, 4));\n        RTree<String, Point> tree = RTree.create();\n        tree = tree.add(a).add(b);\n        Serializer<String, Point> serializer = Serializers.flatBuffers().utf8();\n        ByteArrayOutputStream bytes = new ByteArrayOutputStream();\n        serializer.write(tree, bytes);\n        bytes.close();\n        byte[] array = bytes.toByteArray();\n        RTree<String, Point> tree2 = serializer.read(new ByteArrayInputStream(array), array.length,\n                InternalStructure.SINGLE_ARRAY);\n        tree2 = tree2.delete(a);\n        assertEquals(Sets.newHashSet(b),\n                Sets.newHashSet(tree2.entries().toList().toBlocking().single()));\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @Test\n    public void testAddToFlatBuffersWhenRootNodeIsNonLeaf() throws IOException {\n        Entry<String, Point> a = Entries.entry(\"hello\", Geometries.point(1, 2));\n        Entry<String, Point> b = Entries.entry(\"there\", Geometries.point(3, 4));\n        Entry<String, Point> c = Entries.entry(\"you\", Geometries.point(5, 6));\n        Entry<String, Point> d = Entries.entry(\"smart\", Geometries.point(7, 8));\n        Entry<String, Point> e = Entries.entry(\"person\", Geometries.point(9, 10));\n        RTree<String, Point> tree = RTree.create();\n        tree = tree.add(a).add(b).add(c).add(d).add(e);\n        Serializer<String, Point> serializer = Serializers.flatBuffers().utf8();\n        ByteArrayOutputStream bytes = new ByteArrayOutputStream();\n        serializer.write(tree, bytes);\n        bytes.close();\n        byte[] array = bytes.toByteArray();\n        RTree<String, Point> tree2 = serializer.read(new ByteArrayInputStream(array), array.length,\n                InternalStructure.SINGLE_ARRAY);\n        tree2 = tree2.add(c);\n        assertEquals(Sets.newHashSet(a, b, c, d, e),\n                Sets.newHashSet(tree2.entries().toList().toBlocking().single()));\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @Test\n    public void testDeleteFromFlatBuffersWhenRootNodeIsNonLeaf() throws IOException {\n        Entry<String, Point> a = Entries.entry(\"hello\", Geometries.point(1, 2));\n        Entry<String, Point> b = Entries.entry(\"there\", Geometries.point(3, 4));\n        Entry<String, Point> c = Entries.entry(\"you\", Geometries.point(5, 6));\n        Entry<String, Point> d = Entries.entry(\"smart\", Geometries.point(7, 8));\n        Entry<String, Point> e = Entries.entry(\"person\", Geometries.point(9, 10));\n        RTree<String, Point> tree = RTree.create();\n        tree = tree.add(a).add(b).add(c).add(d).add(e);\n        Serializer<String, Point> serializer = Serializers.flatBuffers().utf8();\n        ByteArrayOutputStream bytes = new ByteArrayOutputStream();\n        serializer.write(tree, bytes);\n        bytes.close();\n        byte[] array = bytes.toByteArray();\n        RTree<String, Point> tree2 = serializer.read(new ByteArrayInputStream(array), array.length,\n                InternalStructure.SINGLE_ARRAY);\n        tree2 = tree2.delete(b);\n        assertEquals(Sets.newHashSet(a, c, d, e),\n                Sets.newHashSet(tree2.entries().toList().toBlocking().single()));\n    }\n\n    @Test\n    public void canRoundTripEmptyTree() throws IOException {\n        RTree<String, Point> tree = RTree.create();\n        Serializer<String, Point> serializer = Serializers.flatBuffers().utf8();\n        ByteArrayOutputStream bytes = new ByteArrayOutputStream();\n        serializer.write(tree, bytes);\n        bytes.close();\n        byte[] array = bytes.toByteArray();\n        RTree<String, Point> tree2 = serializer.read(new ByteArrayInputStream(array), array.length,\n                InternalStructure.SINGLE_ARRAY);\n        assertTrue(tree2.isEmpty());\n    }\n\n    private static void checkRoundTripPoint(Serializer<String, Point> serializer)\n            throws IOException {\n        Entry<String, Point> a = Entries.entry(\"hello\", Geometries.point(1, 2));\n        Entry<String, Point> b = Entries.entry(\"there\", Geometries.point(3, 4));\n        check(serializer, a, b);\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private static <S extends Geometry> void check(Serializer<String, S> serializer,\n            Entry<String, S> a, Entry<String, S> b) throws IOException {\n        RTree<String, S> tree = RTree.create();\n        tree = tree.add(a).add(b);\n        ByteArrayOutputStream bytes = new ByteArrayOutputStream();\n        serializer.write(tree, bytes);\n        bytes.close();\n        {\n            ByteArrayInputStream input = new ByteArrayInputStream(bytes.toByteArray());\n            RTree<String, S> tree2 = serializer.read(input, bytes.size(),\n                    InternalStructure.DEFAULT);\n            assertEquals(2, tree2.size());\n            assertEquals(Sets.newHashSet(a, b),\n                    Sets.newHashSet(tree2.entries().toList().toBlocking().single()));\n        }\n        {\n            ByteArrayInputStream input = new ByteArrayInputStream(bytes.toByteArray());\n            RTree<String, S> tree2 = serializer.read(input, bytes.size(),\n                    InternalStructure.SINGLE_ARRAY);\n            assertEquals(2, tree2.size());\n            assertEquals(Sets.newHashSet(a, b),\n                    Sets.newHashSet(tree2.entries().toList().toBlocking().single()));\n        }\n    }\n\n    @Test\n    public void isUtilityClass() {\n        Asserts.assertIsUtilityClass(Serializers.class);\n    }\n\n}", "definition": "public class SerializersTest", "class_docstring": "", "name": "SerializersTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @Test\n    public void testJavaIoSerialization() throws IOException {\n        Serializer<String, Point> serializer = Serializers.flatBuffers().javaIo();\n        checkRoundTripPoint(serializer);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testJavaIoSerialization", "params": [], "body": "                                                             {\n        Serializer<String, Point> serializer = Serializers.flatBuffers().javaIo();\n        checkRoundTripPoint(serializer);\n    }", "signature": "@Test\n    public void testJavaIoSerialization()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testStringPointSerialization() throws IOException {\n        Serializer<String, Point> serializer = Serializers.flatBuffers().utf8();\n        checkRoundTripPoint(serializer);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testStringPointSerialization", "params": [], "body": "                                                                  {\n        Serializer<String, Point> serializer = Serializers.flatBuffers().utf8();\n        checkRoundTripPoint(serializer);\n    }", "signature": "@Test\n    public void testStringPointSerialization()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testStringRectangleFloatSerialization() throws IOException {\n        Serializer<String, Rectangle> serializer = Serializers.flatBuffers().utf8();\n        Entry<String, Rectangle> a = Entries.entry(\"hello\", Geometries.rectangle(1, 2, 3, 4));\n        Entry<String, Rectangle> b = Entries.entry(\"there\", Geometries.rectangle(3, 4, 5, 6));\n        check(serializer, a, b);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testStringRectangleFloatSerialization", "params": [], "body": "                                                                           {\n        Serializer<String, Rectangle> serializer = Serializers.flatBuffers().utf8();\n        Entry<String, Rectangle> a = Entries.entry(\"hello\", Geometries.rectangle(1, 2, 3, 4));\n        Entry<String, Rectangle> b = Entries.entry(\"there\", Geometries.rectangle(3, 4, 5, 6));\n        check(serializer, a, b);\n    }", "signature": "@Test\n    public void testStringRectangleFloatSerialization()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testStringRectangleDoubleSerialization() throws IOException {\n        Serializer<String, Rectangle> serializer = Serializers.flatBuffers().utf8();\n        Entry<String, Rectangle> a = Entries.entry(\"hello\",\n                Geometries.rectangle(1.0000000001, 2, 3, 4));\n        Entry<String, Rectangle> b = Entries.entry(\"there\",\n                Geometries.rectangle(3.0000000001, 4, 5, 6));\n        check(serializer, a, b);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testStringRectangleDoubleSerialization", "params": [], "body": "                                                                            {\n        Serializer<String, Rectangle> serializer = Serializers.flatBuffers().utf8();\n        Entry<String, Rectangle> a = Entries.entry(\"hello\",\n                Geometries.rectangle(1.0000000001, 2, 3, 4));\n        Entry<String, Rectangle> b = Entries.entry(\"there\",\n                Geometries.rectangle(3.0000000001, 4, 5, 6));\n        check(serializer, a, b);\n    }", "signature": "@Test\n    public void testStringRectangleDoubleSerialization()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testStringCircleFloatSerialization() throws IOException {\n        Serializer<String, Circle> serializer = Serializers.flatBuffers().utf8();\n        Entry<String, Circle> a = Entries.entry(\"hello\", Geometries.circle(1, 2, 3));\n        Entry<String, Circle> b = Entries.entry(\"there\", Geometries.circle(3, 4, 5));\n        check(serializer, a, b);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testStringCircleFloatSerialization", "params": [], "body": "                                                                        {\n        Serializer<String, Circle> serializer = Serializers.flatBuffers().utf8();\n        Entry<String, Circle> a = Entries.entry(\"hello\", Geometries.circle(1, 2, 3));\n        Entry<String, Circle> b = Entries.entry(\"there\", Geometries.circle(3, 4, 5));\n        check(serializer, a, b);\n    }", "signature": "@Test\n    public void testStringCircleFloatSerialization()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testStringCircleDoubleSerialization() throws IOException {\n        Serializer<String, Circle> serializer = Serializers.flatBuffers().utf8();\n        Entry<String, Circle> a = Entries.entry(\"hello\", Geometries.circle(1.0000000001, 2, 3));\n        Entry<String, Circle> b = Entries.entry(\"there\", Geometries.circle(3.0000000001, 4, 5));\n        check(serializer, a, b);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testStringCircleDoubleSerialization", "params": [], "body": "                                                                         {\n        Serializer<String, Circle> serializer = Serializers.flatBuffers().utf8();\n        Entry<String, Circle> a = Entries.entry(\"hello\", Geometries.circle(1.0000000001, 2, 3));\n        Entry<String, Circle> b = Entries.entry(\"there\", Geometries.circle(3.0000000001, 4, 5));\n        check(serializer, a, b);\n    }", "signature": "@Test\n    public void testStringCircleDoubleSerialization()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testStringLineFloatSerialization() throws IOException {\n        Serializer<String, Line> serializer = Serializers.flatBuffers().utf8();\n        Entry<String, Line> a = Entries.entry(\"hello\", Geometries.line(1, 2, 3, 4));\n        Entry<String, Line> b = Entries.entry(\"there\", Geometries.line(3, 4, 5, 6));\n        check(serializer, a, b);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testStringLineFloatSerialization", "params": [], "body": "                                                                      {\n        Serializer<String, Line> serializer = Serializers.flatBuffers().utf8();\n        Entry<String, Line> a = Entries.entry(\"hello\", Geometries.line(1, 2, 3, 4));\n        Entry<String, Line> b = Entries.entry(\"there\", Geometries.line(3, 4, 5, 6));\n        check(serializer, a, b);\n    }", "signature": "@Test\n    public void testStringLineFloatSerialization()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testStringLineDoubleSerialization() throws IOException {\n        Serializer<String, Line> serializer = Serializers.flatBuffers().utf8();\n        Entry<String, Line> a = Entries.entry(\"hello\", Geometries.line(1.0000000001, 2, 3, 4));\n        Entry<String, Line> b = Entries.entry(\"there\", Geometries.line(3.0000000001, 4, 5, 6));\n        check(serializer, a, b);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testStringLineDoubleSerialization", "params": [], "body": "                                                                       {\n        Serializer<String, Line> serializer = Serializers.flatBuffers().utf8();\n        Entry<String, Line> a = Entries.entry(\"hello\", Geometries.line(1.0000000001, 2, 3, 4));\n        Entry<String, Line> b = Entries.entry(\"there\", Geometries.line(3.0000000001, 4, 5, 6));\n        check(serializer, a, b);\n    }", "signature": "@Test\n    public void testStringLineDoubleSerialization()"}, {"syntax_pass": true, "original_string": "    @SuppressWarnings(\"unchecked\")\n    @Test\n    public void testAddToFlatBuffers() throws IOException {\n        Entry<String, Point> a = Entries.entry(\"hello\", Geometries.point(1, 2));\n        Entry<String, Point> b = Entries.entry(\"there\", Geometries.point(3, 4));\n        Entry<String, Point> c = Entries.entry(\"you\", Geometries.point(5, 6));\n        RTree<String, Point> tree = RTree.create();\n        tree = tree.add(a).add(b);\n        Serializer<String, Point> serializer = Serializers.flatBuffers().utf8();\n        ByteArrayOutputStream bytes = new ByteArrayOutputStream();\n        serializer.write(tree, bytes);\n        bytes.close();\n        byte[] array = bytes.toByteArray();\n        RTree<String, Point> tree2 = serializer.read(new ByteArrayInputStream(array), array.length,\n                InternalStructure.SINGLE_ARRAY);\n        tree2 = tree2.add(c);\n        assertEquals(Sets.newHashSet(a, b, c),\n                Sets.newHashSet(tree2.entries().toList().toBlocking().single()));\n    }", "docstring": "", "attributes": {"modifiers": "@SuppressWarnings(\"unchecked\")\n    @Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["@SuppressWarnings(\"unchecked\")", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "testAddToFlatBuffers", "params": [], "body": "                                                          {\n        Entry<String, Point> a = Entries.entry(\"hello\", Geometries.point(1, 2));\n        Entry<String, Point> b = Entries.entry(\"there\", Geometries.point(3, 4));\n        Entry<String, Point> c = Entries.entry(\"you\", Geometries.point(5, 6));\n        RTree<String, Point> tree = RTree.create();\n        tree = tree.add(a).add(b);\n        Serializer<String, Point> serializer = Serializers.flatBuffers().utf8();\n        ByteArrayOutputStream bytes = new ByteArrayOutputStream();\n        serializer.write(tree, bytes);\n        bytes.close();\n        byte[] array = bytes.toByteArray();\n        RTree<String, Point> tree2 = serializer.read(new ByteArrayInputStream(array), array.length,\n                InternalStructure.SINGLE_ARRAY);\n        tree2 = tree2.add(c);\n        assertEquals(Sets.newHashSet(a, b, c),\n                Sets.newHashSet(tree2.entries().toList().toBlocking().single()));\n    }", "signature": "@SuppressWarnings(\"unchecked\")\n    @Test\n    public void testAddToFlatBuffers()"}, {"syntax_pass": true, "original_string": "    @SuppressWarnings(\"unchecked\")\n    @Test\n    public void testDeleteFromFlatBuffers() throws IOException {\n        Entry<String, Point> a = Entries.entry(\"hello\", Geometries.point(1, 2));\n        Entry<String, Point> b = Entries.entry(\"there\", Geometries.point(3, 4));\n        RTree<String, Point> tree = RTree.create();\n        tree = tree.add(a).add(b);\n        Serializer<String, Point> serializer = Serializers.flatBuffers().utf8();\n        ByteArrayOutputStream bytes = new ByteArrayOutputStream();\n        serializer.write(tree, bytes);\n        bytes.close();\n        byte[] array = bytes.toByteArray();\n        RTree<String, Point> tree2 = serializer.read(new ByteArrayInputStream(array), array.length,\n                InternalStructure.SINGLE_ARRAY);\n        tree2 = tree2.delete(a);\n        assertEquals(Sets.newHashSet(b),\n                Sets.newHashSet(tree2.entries().toList().toBlocking().single()));\n    }", "docstring": "", "attributes": {"modifiers": "@SuppressWarnings(\"unchecked\")\n    @Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["@SuppressWarnings(\"unchecked\")", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "testDeleteFromFlatBuffers", "params": [], "body": "                                                               {\n        Entry<String, Point> a = Entries.entry(\"hello\", Geometries.point(1, 2));\n        Entry<String, Point> b = Entries.entry(\"there\", Geometries.point(3, 4));\n        RTree<String, Point> tree = RTree.create();\n        tree = tree.add(a).add(b);\n        Serializer<String, Point> serializer = Serializers.flatBuffers().utf8();\n        ByteArrayOutputStream bytes = new ByteArrayOutputStream();\n        serializer.write(tree, bytes);\n        bytes.close();\n        byte[] array = bytes.toByteArray();\n        RTree<String, Point> tree2 = serializer.read(new ByteArrayInputStream(array), array.length,\n                InternalStructure.SINGLE_ARRAY);\n        tree2 = tree2.delete(a);\n        assertEquals(Sets.newHashSet(b),\n                Sets.newHashSet(tree2.entries().toList().toBlocking().single()));\n    }", "signature": "@SuppressWarnings(\"unchecked\")\n    @Test\n    public void testDeleteFromFlatBuffers()"}, {"syntax_pass": true, "original_string": "    @SuppressWarnings(\"unchecked\")\n    @Test\n    public void testAddToFlatBuffersWhenRootNodeIsNonLeaf() throws IOException {\n        Entry<String, Point> a = Entries.entry(\"hello\", Geometries.point(1, 2));\n        Entry<String, Point> b = Entries.entry(\"there\", Geometries.point(3, 4));\n        Entry<String, Point> c = Entries.entry(\"you\", Geometries.point(5, 6));\n        Entry<String, Point> d = Entries.entry(\"smart\", Geometries.point(7, 8));\n        Entry<String, Point> e = Entries.entry(\"person\", Geometries.point(9, 10));\n        RTree<String, Point> tree = RTree.create();\n        tree = tree.add(a).add(b).add(c).add(d).add(e);\n        Serializer<String, Point> serializer = Serializers.flatBuffers().utf8();\n        ByteArrayOutputStream bytes = new ByteArrayOutputStream();\n        serializer.write(tree, bytes);\n        bytes.close();\n        byte[] array = bytes.toByteArray();\n        RTree<String, Point> tree2 = serializer.read(new ByteArrayInputStream(array), array.length,\n                InternalStructure.SINGLE_ARRAY);\n        tree2 = tree2.add(c);\n        assertEquals(Sets.newHashSet(a, b, c, d, e),\n                Sets.newHashSet(tree2.entries().toList().toBlocking().single()));\n    }", "docstring": "", "attributes": {"modifiers": "@SuppressWarnings(\"unchecked\")\n    @Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["@SuppressWarnings(\"unchecked\")", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "testAddToFlatBuffersWhenRootNodeIsNonLeaf", "params": [], "body": "                                                                               {\n        Entry<String, Point> a = Entries.entry(\"hello\", Geometries.point(1, 2));\n        Entry<String, Point> b = Entries.entry(\"there\", Geometries.point(3, 4));\n        Entry<String, Point> c = Entries.entry(\"you\", Geometries.point(5, 6));\n        Entry<String, Point> d = Entries.entry(\"smart\", Geometries.point(7, 8));\n        Entry<String, Point> e = Entries.entry(\"person\", Geometries.point(9, 10));\n        RTree<String, Point> tree = RTree.create();\n        tree = tree.add(a).add(b).add(c).add(d).add(e);\n        Serializer<String, Point> serializer = Serializers.flatBuffers().utf8();\n        ByteArrayOutputStream bytes = new ByteArrayOutputStream();\n        serializer.write(tree, bytes);\n        bytes.close();\n        byte[] array = bytes.toByteArray();\n        RTree<String, Point> tree2 = serializer.read(new ByteArrayInputStream(array), array.length,\n                InternalStructure.SINGLE_ARRAY);\n        tree2 = tree2.add(c);\n        assertEquals(Sets.newHashSet(a, b, c, d, e),\n                Sets.newHashSet(tree2.entries().toList().toBlocking().single()));\n    }", "signature": "@SuppressWarnings(\"unchecked\")\n    @Test\n    public void testAddToFlatBuffersWhenRootNodeIsNonLeaf()"}, {"syntax_pass": true, "original_string": "    @SuppressWarnings(\"unchecked\")\n    @Test\n    public void testDeleteFromFlatBuffersWhenRootNodeIsNonLeaf() throws IOException {\n        Entry<String, Point> a = Entries.entry(\"hello\", Geometries.point(1, 2));\n        Entry<String, Point> b = Entries.entry(\"there\", Geometries.point(3, 4));\n        Entry<String, Point> c = Entries.entry(\"you\", Geometries.point(5, 6));\n        Entry<String, Point> d = Entries.entry(\"smart\", Geometries.point(7, 8));\n        Entry<String, Point> e = Entries.entry(\"person\", Geometries.point(9, 10));\n        RTree<String, Point> tree = RTree.create();\n        tree = tree.add(a).add(b).add(c).add(d).add(e);\n        Serializer<String, Point> serializer = Serializers.flatBuffers().utf8();\n        ByteArrayOutputStream bytes = new ByteArrayOutputStream();\n        serializer.write(tree, bytes);\n        bytes.close();\n        byte[] array = bytes.toByteArray();\n        RTree<String, Point> tree2 = serializer.read(new ByteArrayInputStream(array), array.length,\n                InternalStructure.SINGLE_ARRAY);\n        tree2 = tree2.delete(b);\n        assertEquals(Sets.newHashSet(a, c, d, e),\n                Sets.newHashSet(tree2.entries().toList().toBlocking().single()));\n    }", "docstring": "", "attributes": {"modifiers": "@SuppressWarnings(\"unchecked\")\n    @Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["@SuppressWarnings(\"unchecked\")", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "testDeleteFromFlatBuffersWhenRootNodeIsNonLeaf", "params": [], "body": "                                                                                    {\n        Entry<String, Point> a = Entries.entry(\"hello\", Geometries.point(1, 2));\n        Entry<String, Point> b = Entries.entry(\"there\", Geometries.point(3, 4));\n        Entry<String, Point> c = Entries.entry(\"you\", Geometries.point(5, 6));\n        Entry<String, Point> d = Entries.entry(\"smart\", Geometries.point(7, 8));\n        Entry<String, Point> e = Entries.entry(\"person\", Geometries.point(9, 10));\n        RTree<String, Point> tree = RTree.create();\n        tree = tree.add(a).add(b).add(c).add(d).add(e);\n        Serializer<String, Point> serializer = Serializers.flatBuffers().utf8();\n        ByteArrayOutputStream bytes = new ByteArrayOutputStream();\n        serializer.write(tree, bytes);\n        bytes.close();\n        byte[] array = bytes.toByteArray();\n        RTree<String, Point> tree2 = serializer.read(new ByteArrayInputStream(array), array.length,\n                InternalStructure.SINGLE_ARRAY);\n        tree2 = tree2.delete(b);\n        assertEquals(Sets.newHashSet(a, c, d, e),\n                Sets.newHashSet(tree2.entries().toList().toBlocking().single()));\n    }", "signature": "@SuppressWarnings(\"unchecked\")\n    @Test\n    public void testDeleteFromFlatBuffersWhenRootNodeIsNonLeaf()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void canRoundTripEmptyTree() throws IOException {\n        RTree<String, Point> tree = RTree.create();\n        Serializer<String, Point> serializer = Serializers.flatBuffers().utf8();\n        ByteArrayOutputStream bytes = new ByteArrayOutputStream();\n        serializer.write(tree, bytes);\n        bytes.close();\n        byte[] array = bytes.toByteArray();\n        RTree<String, Point> tree2 = serializer.read(new ByteArrayInputStream(array), array.length,\n                InternalStructure.SINGLE_ARRAY);\n        assertTrue(tree2.isEmpty());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "canRoundTripEmptyTree", "params": [], "body": "                                                           {\n        RTree<String, Point> tree = RTree.create();\n        Serializer<String, Point> serializer = Serializers.flatBuffers().utf8();\n        ByteArrayOutputStream bytes = new ByteArrayOutputStream();\n        serializer.write(tree, bytes);\n        bytes.close();\n        byte[] array = bytes.toByteArray();\n        RTree<String, Point> tree2 = serializer.read(new ByteArrayInputStream(array), array.length,\n                InternalStructure.SINGLE_ARRAY);\n        assertTrue(tree2.isEmpty());\n    }", "signature": "@Test\n    public void canRoundTripEmptyTree()"}, {"syntax_pass": true, "original_string": "    private static void checkRoundTripPoint(Serializer<String, Point> serializer)\n            throws IOException {\n        Entry<String, Point> a = Entries.entry(\"hello\", Geometries.point(1, 2));\n        Entry<String, Point> b = Entries.entry(\"there\", Geometries.point(3, 4));\n        check(serializer, a, b);\n    }", "docstring": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "void", "classes": []}, "name": "checkRoundTripPoint", "params": [{"name": "serializer", "type": "Serializer<String, Point>"}], "body": "                               {\n        Entry<String, Point> a = Entries.entry(\"hello\", Geometries.point(1, 2));\n        Entry<String, Point> b = Entries.entry(\"there\", Geometries.point(3, 4));\n        check(serializer, a, b);\n    }", "signature": "private static void checkRoundTripPoint(Serializer<String, Point> serializer)"}, {"syntax_pass": true, "original_string": "    @SuppressWarnings(\"unchecked\")\n    private static <S extends Geometry> void check(Serializer<String, S> serializer,\n            Entry<String, S> a, Entry<String, S> b) throws IOException {\n        RTree<String, S> tree = RTree.create();\n        tree = tree.add(a).add(b);\n        ByteArrayOutputStream bytes = new ByteArrayOutputStream();\n        serializer.write(tree, bytes);\n        bytes.close();\n        {\n            ByteArrayInputStream input = new ByteArrayInputStream(bytes.toByteArray());\n            RTree<String, S> tree2 = serializer.read(input, bytes.size(),\n                    InternalStructure.DEFAULT);\n            assertEquals(2, tree2.size());\n            assertEquals(Sets.newHashSet(a, b),\n                    Sets.newHashSet(tree2.entries().toList().toBlocking().single()));\n        }\n        {\n            ByteArrayInputStream input = new ByteArrayInputStream(bytes.toByteArray());\n            RTree<String, S> tree2 = serializer.read(input, bytes.size(),\n                    InternalStructure.SINGLE_ARRAY);\n            assertEquals(2, tree2.size());\n            assertEquals(Sets.newHashSet(a, b),\n                    Sets.newHashSet(tree2.entries().toList().toBlocking().single()));\n        }\n    }", "docstring": "", "attributes": {"modifiers": "@SuppressWarnings(\"unchecked\")\n    private static", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings(\"unchecked\")", "private", "static"], "comments": [], "return_type": "void", "classes": []}, "name": "check", "params": [{"name": "serializer", "type": "Serializer<String, S>"}, {"name": "a", "type": "Entry<String, S>"}, {"name": "b", "type": "Entry<String, S>"}], "body": "                                                                       {\n        RTree<String, S> tree = RTree.create();\n        tree = tree.add(a).add(b);\n        ByteArrayOutputStream bytes = new ByteArrayOutputStream();\n        serializer.write(tree, bytes);\n        bytes.close();\n        {\n            ByteArrayInputStream input = new ByteArrayInputStream(bytes.toByteArray());\n            RTree<String, S> tree2 = serializer.read(input, bytes.size(),\n                    InternalStructure.DEFAULT);\n            assertEquals(2, tree2.size());\n            assertEquals(Sets.newHashSet(a, b),\n                    Sets.newHashSet(tree2.entries().toList().toBlocking().single()));\n        }\n        {\n            ByteArrayInputStream input = new ByteArrayInputStream(bytes.toByteArray());\n            RTree<String, S> tree2 = serializer.read(input, bytes.size(),\n                    InternalStructure.SINGLE_ARRAY);\n            assertEquals(2, tree2.size());\n            assertEquals(Sets.newHashSet(a, b),\n                    Sets.newHashSet(tree2.entries().toList().toBlocking().single()));\n        }\n    }", "signature": "@SuppressWarnings(\"unchecked\")\n    private static <S extends Geometry> void check(Serializer<String, S> serializer,\n            Entry<String, S> a, Entry<String, S> b)"}, {"syntax_pass": true, "original_string": "    @Test\n    public void isUtilityClass() {\n        Asserts.assertIsUtilityClass(Serializers.class);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "isUtilityClass", "params": [], "body": "                                 {\n        Asserts.assertIsUtilityClass(Serializers.class);\n    }", "signature": "@Test\n    public void isUtilityClass()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/com/github/davidmoten/rtree/Utilities.java", "original_string": "package com.github.davidmoten.rtree;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport com.github.davidmoten.rtree.geometry.Geometries;\nimport com.github.davidmoten.rtree.geometry.Rectangle;\n\npublic class Utilities {\n\n    static List<Entry<Object, Rectangle>> entries1000(Precision precision) {\n        List<Entry<Object, Rectangle>> list = new ArrayList<Entry<Object, Rectangle>>();\n        BufferedReader br = new BufferedReader(\n                new InputStreamReader(BenchmarksRTree.class.getResourceAsStream(\"/1000.txt\")));\n        String line;\n        try {\n            while ((line = br.readLine()) != null) {\n                String[] items = line.split(\" \");\n                double x = Double.parseDouble(items[0]);\n                double y = Double.parseDouble(items[1]);\n                Entry<Object, Rectangle> entry;\n                if (precision == Precision.DOUBLE)\n                    entry = Entries.entry(new Object(), Geometries.rectangle(x, y, x + 1, y + 1));\n                else\n                    entry = Entries.entry(new Object(), Geometries.rectangle((float) x, (float) y,\n                            (float) x + 1, (float) y + 1));\n                list.add(entry);\n            }\n            br.close();\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n        return list;\n    }\n\n}\n", "file_hash": "d44f44ef885439db905ee5a75ac64434dafad739b1fcad05112b4e8ec9c06789", "file_docstring": "", "contexts": ["package com.github.davidmoten.rtree;", "import java.io.BufferedReader;", "import java.io.IOException;", "import java.io.InputStreamReader;", "import java.util.ArrayList;", "import java.util.List;", "import com.github.davidmoten.rtree.geometry.Geometries;", "import com.github.davidmoten.rtree.geometry.Rectangle;"], "methods": [], "classes": [{"original_string": "public class Utilities {\n\n    static List<Entry<Object, Rectangle>> entries1000(Precision precision) {\n        List<Entry<Object, Rectangle>> list = new ArrayList<Entry<Object, Rectangle>>();\n        BufferedReader br = new BufferedReader(\n                new InputStreamReader(BenchmarksRTree.class.getResourceAsStream(\"/1000.txt\")));\n        String line;\n        try {\n            while ((line = br.readLine()) != null) {\n                String[] items = line.split(\" \");\n                double x = Double.parseDouble(items[0]);\n                double y = Double.parseDouble(items[1]);\n                Entry<Object, Rectangle> entry;\n                if (precision == Precision.DOUBLE)\n                    entry = Entries.entry(new Object(), Geometries.rectangle(x, y, x + 1, y + 1));\n                else\n                    entry = Entries.entry(new Object(), Geometries.rectangle((float) x, (float) y,\n                            (float) x + 1, (float) y + 1));\n                list.add(entry);\n            }\n            br.close();\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n        return list;\n    }\n\n}", "definition": "public class Utilities", "class_docstring": "", "name": "Utilities", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    static List<Entry<Object, Rectangle>> entries1000(Precision precision) {\n        List<Entry<Object, Rectangle>> list = new ArrayList<Entry<Object, Rectangle>>();\n        BufferedReader br = new BufferedReader(\n                new InputStreamReader(BenchmarksRTree.class.getResourceAsStream(\"/1000.txt\")));\n        String line;\n        try {\n            while ((line = br.readLine()) != null) {\n                String[] items = line.split(\" \");\n                double x = Double.parseDouble(items[0]);\n                double y = Double.parseDouble(items[1]);\n                Entry<Object, Rectangle> entry;\n                if (precision == Precision.DOUBLE)\n                    entry = Entries.entry(new Object(), Geometries.rectangle(x, y, x + 1, y + 1));\n                else\n                    entry = Entries.entry(new Object(), Geometries.rectangle((float) x, (float) y,\n                            (float) x + 1, (float) y + 1));\n                list.add(entry);\n            }\n            br.close();\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n        return list;\n    }", "docstring": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "List<Entry<Object, Rectangle>>", "classes": []}, "name": "entries1000", "params": [{"name": "precision", "type": "Precision"}], "body": "                                                                           {\n        List<Entry<Object, Rectangle>> list = new ArrayList<Entry<Object, Rectangle>>();\n        BufferedReader br = new BufferedReader(\n                new InputStreamReader(BenchmarksRTree.class.getResourceAsStream(\"/1000.txt\")));\n        String line;\n        try {\n            while ((line = br.readLine()) != null) {\n                String[] items = line.split(\" \");\n                double x = Double.parseDouble(items[0]);\n                double y = Double.parseDouble(items[1]);\n                Entry<Object, Rectangle> entry;\n                if (precision == Precision.DOUBLE)\n                    entry = Entries.entry(new Object(), Geometries.rectangle(x, y, x + 1, y + 1));\n                else\n                    entry = Entries.entry(new Object(), Geometries.rectangle((float) x, (float) y,\n                            (float) x + 1, (float) y + 1));\n                list.add(entry);\n            }\n            br.close();\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n        return list;\n    }", "signature": "static List<Entry<Object, Rectangle>> entries1000(Precision precision)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/com/github/davidmoten/rtree/KryoSerializationTest.java", "original_string": "package com.github.davidmoten.rtree;\n\nimport static org.junit.Assert.assertEquals;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\n\nimport org.junit.Ignore;\nimport org.junit.Test;\n\nimport com.esotericsoftware.kryo.Kryo;\nimport com.esotericsoftware.kryo.io.Input;\nimport com.esotericsoftware.kryo.io.Output;\nimport com.github.davidmoten.rtree.geometry.Geometries;\nimport com.github.davidmoten.rtree.geometry.Point;\n\npublic class KryoSerializationTest {\n\n    @Test\n    @Ignore\n    public void testRTree() {\n        Kryo kryo = new Kryo();\n        ByteArrayOutputStream bytes = new ByteArrayOutputStream();\n        Output output = new Output(bytes);\n        RTree<String, Point> tree = RTree.<String, Point> create()\n                .add(Entries.entry(\"thing\", Geometries.point(10, 20)))\n                .add(Entries.entry(\"monster\", Geometries.point(23, 45)));\n        kryo.writeObject(output, tree);\n        output.close();\n        Input input = new Input(new ByteArrayInputStream(bytes.toByteArray()));\n        @SuppressWarnings(\"unchecked\")\n        RTree<String, Point> tree2 = kryo.readObject(input, RTree.class);\n        assertEquals(2, (int) tree2.entries().count().toBlocking().single());\n    }\n\n    @Test\n    public void testKryo() {\n        Kryo kryo = new Kryo();\n        ByteArrayOutputStream bytes = new ByteArrayOutputStream();\n        Output output = new Output(bytes);\n        Boo b = new Boo(\"hello\");\n        kryo.register(Boo.class);\n        kryo.writeObject(output, b);\n        output.close();\n        Input input = new Input(new ByteArrayInputStream(bytes.toByteArray()));\n        Boo b2 = kryo.readObject(input, Boo.class);\n        assertEquals(\"hello\", b2.name);\n    }\n\n    public static class Boo {\n\n        public final String name;\n\n        @SuppressWarnings(\"unused\")\n        private Boo() {\n            this(\"boo\");\n        }\n\n        public Boo(String name) {\n            this.name = name;\n        }\n    }\n\n}\n", "file_hash": "7af3039038613087ba21a126e77038797902ce56c9d0f6d3e6440a17a739f1ac", "file_docstring": "", "contexts": ["package com.github.davidmoten.rtree;", "import static org.junit.Assert.assertEquals;", "import java.io.ByteArrayInputStream;", "import java.io.ByteArrayOutputStream;", "import org.junit.Ignore;", "import org.junit.Test;", "import com.esotericsoftware.kryo.Kryo;", "import com.esotericsoftware.kryo.io.Input;", "import com.esotericsoftware.kryo.io.Output;", "import com.github.davidmoten.rtree.geometry.Geometries;", "import com.github.davidmoten.rtree.geometry.Point;"], "methods": [], "classes": [{"original_string": "public class KryoSerializationTest {\n\n    @Test\n    @Ignore\n    public void testRTree() {\n        Kryo kryo = new Kryo();\n        ByteArrayOutputStream bytes = new ByteArrayOutputStream();\n        Output output = new Output(bytes);\n        RTree<String, Point> tree = RTree.<String, Point> create()\n                .add(Entries.entry(\"thing\", Geometries.point(10, 20)))\n                .add(Entries.entry(\"monster\", Geometries.point(23, 45)));\n        kryo.writeObject(output, tree);\n        output.close();\n        Input input = new Input(new ByteArrayInputStream(bytes.toByteArray()));\n        @SuppressWarnings(\"unchecked\")\n        RTree<String, Point> tree2 = kryo.readObject(input, RTree.class);\n        assertEquals(2, (int) tree2.entries().count().toBlocking().single());\n    }\n\n    @Test\n    public void testKryo() {\n        Kryo kryo = new Kryo();\n        ByteArrayOutputStream bytes = new ByteArrayOutputStream();\n        Output output = new Output(bytes);\n        Boo b = new Boo(\"hello\");\n        kryo.register(Boo.class);\n        kryo.writeObject(output, b);\n        output.close();\n        Input input = new Input(new ByteArrayInputStream(bytes.toByteArray()));\n        Boo b2 = kryo.readObject(input, Boo.class);\n        assertEquals(\"hello\", b2.name);\n    }\n\n    public static class Boo {\n\n        public final String name;\n\n        @SuppressWarnings(\"unused\")\n        private Boo() {\n            this(\"boo\");\n        }\n\n        public Boo(String name) {\n            this.name = name;\n        }\n    }\n\n}", "definition": "public class KryoSerializationTest", "class_docstring": "", "name": "KryoSerializationTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [], "classes": [{"original_string": "    public static class Boo {\n\n        public final String name;\n\n        @SuppressWarnings(\"unused\")\n        private Boo() {\n            this(\"boo\");\n        }\n\n        public Boo(String name) {\n            this.name = name;\n        }\n    }", "definition": "    public static class Boo", "class_docstring": "", "name": "Boo", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [{"attribute_expression": "public final String name;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "String", "name": "name", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        @SuppressWarnings(\"unused\")\n        private Boo() {\n            this(\"boo\");\n        }", "docstring": "", "attributes": {"modifiers": "@SuppressWarnings(\"unused\")\n        private", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings(\"unused\")", "private"], "comments": [], "return_type": "", "classes": []}, "name": "Boo", "params": [], "body": "                      {\n            this(\"boo\");\n        }", "signature": "@SuppressWarnings(\"unused\")\n        private Boo()"}, {"syntax_pass": true, "original_string": "        public Boo(String name) {\n            this.name = name;\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "Boo", "params": [{"name": "name", "type": "String"}], "body": "                                {\n            this.name = name;\n        }", "signature": "public Boo(String name)"}]}]}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @Test\n    @Ignore\n    public void testRTree() {\n        Kryo kryo = new Kryo();\n        ByteArrayOutputStream bytes = new ByteArrayOutputStream();\n        Output output = new Output(bytes);\n        RTree<String, Point> tree = RTree.<String, Point> create()\n                .add(Entries.entry(\"thing\", Geometries.point(10, 20)))\n                .add(Entries.entry(\"monster\", Geometries.point(23, 45)));\n        kryo.writeObject(output, tree);\n        output.close();\n        Input input = new Input(new ByteArrayInputStream(bytes.toByteArray()));\n        @SuppressWarnings(\"unchecked\")\n        RTree<String, Point> tree2 = kryo.readObject(input, RTree.class);\n        assertEquals(2, (int) tree2.entries().count().toBlocking().single());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    @Ignore\n    public", "marker_annotations": ["@Test", "@Ignore"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testRTree", "params": [], "body": "                            {\n        Kryo kryo = new Kryo();\n        ByteArrayOutputStream bytes = new ByteArrayOutputStream();\n        Output output = new Output(bytes);\n        RTree<String, Point> tree = RTree.<String, Point> create()\n                .add(Entries.entry(\"thing\", Geometries.point(10, 20)))\n                .add(Entries.entry(\"monster\", Geometries.point(23, 45)));\n        kryo.writeObject(output, tree);\n        output.close();\n        Input input = new Input(new ByteArrayInputStream(bytes.toByteArray()));\n        @SuppressWarnings(\"unchecked\")\n        RTree<String, Point> tree2 = kryo.readObject(input, RTree.class);\n        assertEquals(2, (int) tree2.entries().count().toBlocking().single());\n    }", "signature": "@Test\n    @Ignore\n    public void testRTree()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testKryo() {\n        Kryo kryo = new Kryo();\n        ByteArrayOutputStream bytes = new ByteArrayOutputStream();\n        Output output = new Output(bytes);\n        Boo b = new Boo(\"hello\");\n        kryo.register(Boo.class);\n        kryo.writeObject(output, b);\n        output.close();\n        Input input = new Input(new ByteArrayInputStream(bytes.toByteArray()));\n        Boo b2 = kryo.readObject(input, Boo.class);\n        assertEquals(\"hello\", b2.name);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testKryo", "params": [], "body": "                           {\n        Kryo kryo = new Kryo();\n        ByteArrayOutputStream bytes = new ByteArrayOutputStream();\n        Output output = new Output(bytes);\n        Boo b = new Boo(\"hello\");\n        kryo.register(Boo.class);\n        kryo.writeObject(output, b);\n        output.close();\n        Input input = new Input(new ByteArrayInputStream(bytes.toByteArray()));\n        Boo b2 = kryo.readObject(input, Boo.class);\n        assertEquals(\"hello\", b2.name);\n    }", "signature": "@Test\n    public void testKryo()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/com/github/davidmoten/rtree/ContextTest.java", "original_string": "package com.github.davidmoten.rtree;\n\nimport org.junit.Test;\n\nimport com.github.davidmoten.rtree.geometry.Geometry;\n\npublic class ContextTest {\n\n    @Test(expected = RuntimeException.class)\n    public void testContextIllegalMinChildren() {\n        new Context<Object, Geometry>(0, 4, new SelectorMinimalAreaIncrease(),\n                new SplitterQuadratic(), Factories.defaultFactory());\n    }\n\n    @Test(expected = RuntimeException.class)\n    public void testContextIllegalMaxChildren() {\n        new Context<Object, Geometry>(1, 2, new SelectorMinimalAreaIncrease(),\n                new SplitterQuadratic(), Factories.defaultFactory());\n    }\n\n    @Test(expected = RuntimeException.class)\n    public void testContextIllegalMinMaxChildren() {\n        new Context<Object, Geometry>(4, 3, new SelectorMinimalAreaIncrease(),\n                new SplitterQuadratic(), Factories.defaultFactory());\n    }\n\n    @Test\n    public void testContextLegalChildren() {\n        new Context<Object, Geometry>(2, 4, new SelectorMinimalAreaIncrease(),\n                new SplitterQuadratic(), Factories.defaultFactory());\n    }\n\n    @Test(expected = NullPointerException.class)\n    public void testContextSelectorNullThrowsNPE() {\n        new Context<Object, Geometry>(2, 4, null, new SplitterQuadratic(),\n                Factories.defaultFactory());\n    }\n\n    @Test(expected = NullPointerException.class)\n    public void testContextSplitterNullThrowsNPE() {\n        new Context<Object, Geometry>(2, 4, new SelectorMinimalAreaIncrease(), null,\n                Factories.defaultFactory());\n    }\n\n    @Test(expected = NullPointerException.class)\n    public void testContextNodeFactoryNullThrowsNPE() {\n        new Context<Object, Geometry>(2, 4, new SelectorMinimalAreaIncrease(),\n                new SplitterQuadratic(), null);\n    }\n}\n", "file_hash": "0952ec436c4486c6d2541fa6cde0cfd62fdb9e6429b92f110ffbed524ca7b0fb", "file_docstring": "", "contexts": ["package com.github.davidmoten.rtree;", "import org.junit.Test;", "import com.github.davidmoten.rtree.geometry.Geometry;"], "methods": [], "classes": [{"original_string": "public class ContextTest {\n\n    @Test(expected = RuntimeException.class)\n    public void testContextIllegalMinChildren() {\n        new Context<Object, Geometry>(0, 4, new SelectorMinimalAreaIncrease(),\n                new SplitterQuadratic(), Factories.defaultFactory());\n    }\n\n    @Test(expected = RuntimeException.class)\n    public void testContextIllegalMaxChildren() {\n        new Context<Object, Geometry>(1, 2, new SelectorMinimalAreaIncrease(),\n                new SplitterQuadratic(), Factories.defaultFactory());\n    }\n\n    @Test(expected = RuntimeException.class)\n    public void testContextIllegalMinMaxChildren() {\n        new Context<Object, Geometry>(4, 3, new SelectorMinimalAreaIncrease(),\n                new SplitterQuadratic(), Factories.defaultFactory());\n    }\n\n    @Test\n    public void testContextLegalChildren() {\n        new Context<Object, Geometry>(2, 4, new SelectorMinimalAreaIncrease(),\n                new SplitterQuadratic(), Factories.defaultFactory());\n    }\n\n    @Test(expected = NullPointerException.class)\n    public void testContextSelectorNullThrowsNPE() {\n        new Context<Object, Geometry>(2, 4, null, new SplitterQuadratic(),\n                Factories.defaultFactory());\n    }\n\n    @Test(expected = NullPointerException.class)\n    public void testContextSplitterNullThrowsNPE() {\n        new Context<Object, Geometry>(2, 4, new SelectorMinimalAreaIncrease(), null,\n                Factories.defaultFactory());\n    }\n\n    @Test(expected = NullPointerException.class)\n    public void testContextNodeFactoryNullThrowsNPE() {\n        new Context<Object, Geometry>(2, 4, new SelectorMinimalAreaIncrease(),\n                new SplitterQuadratic(), null);\n    }\n}", "definition": "public class ContextTest", "class_docstring": "", "name": "ContextTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @Test(expected = RuntimeException.class)\n    public void testContextIllegalMinChildren() {\n        new Context<Object, Geometry>(0, 4, new SelectorMinimalAreaIncrease(),\n                new SplitterQuadratic(), Factories.defaultFactory());\n    }", "docstring": "", "attributes": {"modifiers": "@Test(expected = RuntimeException.class)\n    public", "marker_annotations": [], "non_marker_annotations": ["@Test(expected = RuntimeException.class)", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "testContextIllegalMinChildren", "params": [], "body": "                                                {\n        new Context<Object, Geometry>(0, 4, new SelectorMinimalAreaIncrease(),\n                new SplitterQuadratic(), Factories.defaultFactory());\n    }", "signature": "@Test(expected = RuntimeException.class)\n    public void testContextIllegalMinChildren()"}, {"syntax_pass": true, "original_string": "    @Test(expected = RuntimeException.class)\n    public void testContextIllegalMaxChildren() {\n        new Context<Object, Geometry>(1, 2, new SelectorMinimalAreaIncrease(),\n                new SplitterQuadratic(), Factories.defaultFactory());\n    }", "docstring": "", "attributes": {"modifiers": "@Test(expected = RuntimeException.class)\n    public", "marker_annotations": [], "non_marker_annotations": ["@Test(expected = RuntimeException.class)", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "testContextIllegalMaxChildren", "params": [], "body": "                                                {\n        new Context<Object, Geometry>(1, 2, new SelectorMinimalAreaIncrease(),\n                new SplitterQuadratic(), Factories.defaultFactory());\n    }", "signature": "@Test(expected = RuntimeException.class)\n    public void testContextIllegalMaxChildren()"}, {"syntax_pass": true, "original_string": "    @Test(expected = RuntimeException.class)\n    public void testContextIllegalMinMaxChildren() {\n        new Context<Object, Geometry>(4, 3, new SelectorMinimalAreaIncrease(),\n                new SplitterQuadratic(), Factories.defaultFactory());\n    }", "docstring": "", "attributes": {"modifiers": "@Test(expected = RuntimeException.class)\n    public", "marker_annotations": [], "non_marker_annotations": ["@Test(expected = RuntimeException.class)", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "testContextIllegalMinMaxChildren", "params": [], "body": "                                                   {\n        new Context<Object, Geometry>(4, 3, new SelectorMinimalAreaIncrease(),\n                new SplitterQuadratic(), Factories.defaultFactory());\n    }", "signature": "@Test(expected = RuntimeException.class)\n    public void testContextIllegalMinMaxChildren()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testContextLegalChildren() {\n        new Context<Object, Geometry>(2, 4, new SelectorMinimalAreaIncrease(),\n                new SplitterQuadratic(), Factories.defaultFactory());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testContextLegalChildren", "params": [], "body": "                                           {\n        new Context<Object, Geometry>(2, 4, new SelectorMinimalAreaIncrease(),\n                new SplitterQuadratic(), Factories.defaultFactory());\n    }", "signature": "@Test\n    public void testContextLegalChildren()"}, {"syntax_pass": true, "original_string": "    @Test(expected = NullPointerException.class)\n    public void testContextSelectorNullThrowsNPE() {\n        new Context<Object, Geometry>(2, 4, null, new SplitterQuadratic(),\n                Factories.defaultFactory());\n    }", "docstring": "", "attributes": {"modifiers": "@Test(expected = NullPointerException.class)\n    public", "marker_annotations": [], "non_marker_annotations": ["@Test(expected = NullPointerException.class)", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "testContextSelectorNullThrowsNPE", "params": [], "body": "                                                   {\n        new Context<Object, Geometry>(2, 4, null, new SplitterQuadratic(),\n                Factories.defaultFactory());\n    }", "signature": "@Test(expected = NullPointerException.class)\n    public void testContextSelectorNullThrowsNPE()"}, {"syntax_pass": true, "original_string": "    @Test(expected = NullPointerException.class)\n    public void testContextSplitterNullThrowsNPE() {\n        new Context<Object, Geometry>(2, 4, new SelectorMinimalAreaIncrease(), null,\n                Factories.defaultFactory());\n    }", "docstring": "", "attributes": {"modifiers": "@Test(expected = NullPointerException.class)\n    public", "marker_annotations": [], "non_marker_annotations": ["@Test(expected = NullPointerException.class)", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "testContextSplitterNullThrowsNPE", "params": [], "body": "                                                   {\n        new Context<Object, Geometry>(2, 4, new SelectorMinimalAreaIncrease(), null,\n                Factories.defaultFactory());\n    }", "signature": "@Test(expected = NullPointerException.class)\n    public void testContextSplitterNullThrowsNPE()"}, {"syntax_pass": true, "original_string": "    @Test(expected = NullPointerException.class)\n    public void testContextNodeFactoryNullThrowsNPE() {\n        new Context<Object, Geometry>(2, 4, new SelectorMinimalAreaIncrease(),\n                new SplitterQuadratic(), null);\n    }", "docstring": "", "attributes": {"modifiers": "@Test(expected = NullPointerException.class)\n    public", "marker_annotations": [], "non_marker_annotations": ["@Test(expected = NullPointerException.class)", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "testContextNodeFactoryNullThrowsNPE", "params": [], "body": "                                                      {\n        new Context<Object, Geometry>(2, 4, new SelectorMinimalAreaIncrease(),\n                new SplitterQuadratic(), null);\n    }", "signature": "@Test(expected = NullPointerException.class)\n    public void testContextNodeFactoryNullThrowsNPE()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/com/github/davidmoten/rtree/ImageSaverTest.java", "original_string": "package com.github.davidmoten.rtree;\n\nimport static org.junit.Assert.assertTrue;\n\nimport java.io.IOException;\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\nimport org.junit.Test;\n\nimport com.github.davidmoten.junit.Asserts;\n\npublic class ImageSaverTest {\n\n    @Test\n    public void testSaveImageToNonExistentDirectoryThrowsRuntimeException() {\n        Visualizer v = RTree.create().visualize(100, 100);\n        v.save(\"target/saved-image\");\n    }\n\n    @Test(expected = RuntimeException.class)\n    public void testRunThatThrows() {\n        ImageSaver.run(new Callable<Void>() {\n\n            @Override\n            public Void call() throws Exception {\n                throw new IOException();\n            }\n        });\n    }\n\n    @Test\n    public void testRunThatDoesNotThrow() {\n        final AtomicBoolean b = new AtomicBoolean();\n        ImageSaver.run(new Callable<Void>() {\n\n            @Override\n            public Void call() throws Exception {\n                b.set(true);\n                return null;\n            }\n        });\n        assertTrue(b.get());\n    }\n\n    @Test\n    public void testIsUtilClass() {\n        Asserts.assertIsUtilityClass(ImageSaver.class);\n    }\n\n}\n", "file_hash": "bd2cce1c8ce873e2d9323d6fd9113595594b1078205d84f3012fc15e269c572f", "file_docstring": "", "contexts": ["package com.github.davidmoten.rtree;", "import static org.junit.Assert.assertTrue;", "import java.io.IOException;", "import java.util.concurrent.Callable;", "import java.util.concurrent.atomic.AtomicBoolean;", "import org.junit.Test;", "import com.github.davidmoten.junit.Asserts;"], "methods": [], "classes": [{"original_string": "public class ImageSaverTest {\n\n    @Test\n    public void testSaveImageToNonExistentDirectoryThrowsRuntimeException() {\n        Visualizer v = RTree.create().visualize(100, 100);\n        v.save(\"target/saved-image\");\n    }\n\n    @Test(expected = RuntimeException.class)\n    public void testRunThatThrows() {\n        ImageSaver.run(new Callable<Void>() {\n\n            @Override\n            public Void call() throws Exception {\n                throw new IOException();\n            }\n        });\n    }\n\n    @Test\n    public void testRunThatDoesNotThrow() {\n        final AtomicBoolean b = new AtomicBoolean();\n        ImageSaver.run(new Callable<Void>() {\n\n            @Override\n            public Void call() throws Exception {\n                b.set(true);\n                return null;\n            }\n        });\n        assertTrue(b.get());\n    }\n\n    @Test\n    public void testIsUtilClass() {\n        Asserts.assertIsUtilityClass(ImageSaver.class);\n    }\n\n}", "definition": "public class ImageSaverTest", "class_docstring": "", "name": "ImageSaverTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @Test\n    public void testSaveImageToNonExistentDirectoryThrowsRuntimeException() {\n        Visualizer v = RTree.create().visualize(100, 100);\n        v.save(\"target/saved-image\");\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testSaveImageToNonExistentDirectoryThrowsRuntimeException", "params": [], "body": "                                                                            {\n        Visualizer v = RTree.create().visualize(100, 100);\n        v.save(\"target/saved-image\");\n    }", "signature": "@Test\n    public void testSaveImageToNonExistentDirectoryThrowsRuntimeException()"}, {"syntax_pass": true, "original_string": "    @Test(expected = RuntimeException.class)\n    public void testRunThatThrows() {\n        ImageSaver.run(new Callable<Void>() {\n\n            @Override\n            public Void call() throws Exception {\n                throw new IOException();\n            }\n        });\n    }", "docstring": "", "attributes": {"modifiers": "@Test(expected = RuntimeException.class)\n    public", "marker_annotations": [], "non_marker_annotations": ["@Test(expected = RuntimeException.class)", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "testRunThatThrows", "params": [], "body": "                                    {\n        ImageSaver.run(new Callable<Void>() {\n\n            @Override\n            public Void call() throws Exception {\n                throw new IOException();\n            }\n        });\n    }", "signature": "@Test(expected = RuntimeException.class)\n    public void testRunThatThrows()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testRunThatDoesNotThrow() {\n        final AtomicBoolean b = new AtomicBoolean();\n        ImageSaver.run(new Callable<Void>() {\n\n            @Override\n            public Void call() throws Exception {\n                b.set(true);\n                return null;\n            }\n        });\n        assertTrue(b.get());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testRunThatDoesNotThrow", "params": [], "body": "                                          {\n        final AtomicBoolean b = new AtomicBoolean();\n        ImageSaver.run(new Callable<Void>() {\n\n            @Override\n            public Void call() throws Exception {\n                b.set(true);\n                return null;\n            }\n        });\n        assertTrue(b.get());\n    }", "signature": "@Test\n    public void testRunThatDoesNotThrow()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testIsUtilClass() {\n        Asserts.assertIsUtilityClass(ImageSaver.class);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testIsUtilClass", "params": [], "body": "                                  {\n        Asserts.assertIsUtilityClass(ImageSaver.class);\n    }", "signature": "@Test\n    public void testIsUtilClass()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/com/github/davidmoten/rtree/FactoriesTest.java", "original_string": "package com.github.davidmoten.rtree;\n\nimport org.junit.Test;\n\nimport com.github.davidmoten.junit.Asserts;\n\npublic class FactoriesTest {\n\n    @Test\n    public void isUtilityClass() {\n        Asserts.assertIsUtilityClass(Factories.class);\n    }\n\n}\n", "file_hash": "ebe50c2e41d13291e3ddd9401c8ed36ced04b14c767bfca8aaedd7437e018e68", "file_docstring": "", "contexts": ["package com.github.davidmoten.rtree;", "import org.junit.Test;", "import com.github.davidmoten.junit.Asserts;"], "methods": [], "classes": [{"original_string": "public class FactoriesTest {\n\n    @Test\n    public void isUtilityClass() {\n        Asserts.assertIsUtilityClass(Factories.class);\n    }\n\n}", "definition": "public class FactoriesTest", "class_docstring": "", "name": "FactoriesTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @Test\n    public void isUtilityClass() {\n        Asserts.assertIsUtilityClass(Factories.class);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "isUtilityClass", "params": [], "body": "                                 {\n        Asserts.assertIsUtilityClass(Factories.class);\n    }", "signature": "@Test\n    public void isUtilityClass()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/com/github/davidmoten/rtree/GalleryMain.java", "original_string": "package com.github.davidmoten.rtree;\n\nimport java.util.Arrays;\nimport java.util.List;\n\nimport com.github.davidmoten.rtree.geometry.Point;\n\nimport rx.Observable;\n\npublic class GalleryMain {\n\n    public static void main(String[] args) {\n        Observable<Entry<Object, Point>> entries = GreekEarthquakes.entries(Precision.DOUBLE)\n                .cache();\n\n        List<Integer> sizes = Arrays.asList(100, 1000, 10000, 1000000);\n        List<Integer> maxChildrenValues = Arrays.asList(4, 8, 16, 32, 64, 128);\n        for (int size : sizes)\n            for (int maxChildren : maxChildrenValues) {\n                if (size > maxChildren) {\n                    System.out.println(\"saving \" + size + \" m=\" + maxChildren);\n                    RTree<Object, Point> tree = RTree.maxChildren(maxChildren)\n                            .<Object, Point>create().add(entries.take(size)).last().toBlocking()\n                            .single();\n                    tree.visualize(600, 600)\n                            .save(\"target/greek-\" + size + \"-\" + maxChildren + \"-quad.png\");\n                    RTree<Object, Point> tree2 = RTree.star().maxChildren(maxChildren)\n                            .<Object, Point>create().add(entries.take(size)).last().toBlocking()\n                            .single();\n                    tree2.visualize(600, 600)\n                            .save(\"target/greek-\" + size + \"-\" + maxChildren + \"-star.png\");\n                }\n            }\n    }\n}\n", "file_hash": "e41d5a285135fae952657e6e5288402eb9778ee8091316a8777db6624756c226", "file_docstring": "", "contexts": ["package com.github.davidmoten.rtree;", "import java.util.Arrays;", "import java.util.List;", "import com.github.davidmoten.rtree.geometry.Point;", "import rx.Observable;"], "methods": [], "classes": [{"original_string": "public class GalleryMain {\n\n    public static void main(String[] args) {\n        Observable<Entry<Object, Point>> entries = GreekEarthquakes.entries(Precision.DOUBLE)\n                .cache();\n\n        List<Integer> sizes = Arrays.asList(100, 1000, 10000, 1000000);\n        List<Integer> maxChildrenValues = Arrays.asList(4, 8, 16, 32, 64, 128);\n        for (int size : sizes)\n            for (int maxChildren : maxChildrenValues) {\n                if (size > maxChildren) {\n                    System.out.println(\"saving \" + size + \" m=\" + maxChildren);\n                    RTree<Object, Point> tree = RTree.maxChildren(maxChildren)\n                            .<Object, Point>create().add(entries.take(size)).last().toBlocking()\n                            .single();\n                    tree.visualize(600, 600)\n                            .save(\"target/greek-\" + size + \"-\" + maxChildren + \"-quad.png\");\n                    RTree<Object, Point> tree2 = RTree.star().maxChildren(maxChildren)\n                            .<Object, Point>create().add(entries.take(size)).last().toBlocking()\n                            .single();\n                    tree2.visualize(600, 600)\n                            .save(\"target/greek-\" + size + \"-\" + maxChildren + \"-star.png\");\n                }\n            }\n    }\n}", "definition": "public class GalleryMain", "class_docstring": "", "name": "GalleryMain", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    public static void main(String[] args) {\n        Observable<Entry<Object, Point>> entries = GreekEarthquakes.entries(Precision.DOUBLE)\n                .cache();\n\n        List<Integer> sizes = Arrays.asList(100, 1000, 10000, 1000000);\n        List<Integer> maxChildrenValues = Arrays.asList(4, 8, 16, 32, 64, 128);\n        for (int size : sizes)\n            for (int maxChildren : maxChildrenValues) {\n                if (size > maxChildren) {\n                    System.out.println(\"saving \" + size + \" m=\" + maxChildren);\n                    RTree<Object, Point> tree = RTree.maxChildren(maxChildren)\n                            .<Object, Point>create().add(entries.take(size)).last().toBlocking()\n                            .single();\n                    tree.visualize(600, 600)\n                            .save(\"target/greek-\" + size + \"-\" + maxChildren + \"-quad.png\");\n                    RTree<Object, Point> tree2 = RTree.star().maxChildren(maxChildren)\n                            .<Object, Point>create().add(entries.take(size)).last().toBlocking()\n                            .single();\n                    tree2.visualize(600, 600)\n                            .save(\"target/greek-\" + size + \"-\" + maxChildren + \"-star.png\");\n                }\n            }\n    }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "void", "classes": []}, "name": "main", "params": [{"name": "args", "type": "String[]"}], "body": "                                           {\n        Observable<Entry<Object, Point>> entries = GreekEarthquakes.entries(Precision.DOUBLE)\n                .cache();\n\n        List<Integer> sizes = Arrays.asList(100, 1000, 10000, 1000000);\n        List<Integer> maxChildrenValues = Arrays.asList(4, 8, 16, 32, 64, 128);\n        for (int size : sizes)\n            for (int maxChildren : maxChildrenValues) {\n                if (size > maxChildren) {\n                    System.out.println(\"saving \" + size + \" m=\" + maxChildren);\n                    RTree<Object, Point> tree = RTree.maxChildren(maxChildren)\n                            .<Object, Point>create().add(entries.take(size)).last().toBlocking()\n                            .single();\n                    tree.visualize(600, 600)\n                            .save(\"target/greek-\" + size + \"-\" + maxChildren + \"-quad.png\");\n                    RTree<Object, Point> tree2 = RTree.star().maxChildren(maxChildren)\n                            .<Object, Point>create().add(entries.take(size)).last().toBlocking()\n                            .single();\n                    tree2.visualize(600, 600)\n                            .save(\"target/greek-\" + size + \"-\" + maxChildren + \"-star.png\");\n                }\n            }\n    }", "signature": "public static void main(String[] args)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/com/github/davidmoten/rtree/SplitterRStarTest.java", "original_string": "package com.github.davidmoten.rtree;\n\nimport static org.junit.Assert.assertEquals;\n\nimport java.util.List;\n\nimport org.junit.Test;\n\nimport com.github.davidmoten.guavamini.Lists;\nimport com.github.davidmoten.rtree.geometry.Geometries;\nimport com.github.davidmoten.rtree.geometry.HasGeometry;\nimport com.github.davidmoten.rtree.geometry.ListPair;\n\npublic class SplitterRStarTest {\n\n    @Test\n    public void testGetPairs() {\n\n        int minSize = 2;\n        List<HasGeometry> list = Lists.newArrayList();\n        list.add(Geometries.point(1, 1).mbr());\n        list.add(Geometries.point(2, 2).mbr());\n        list.add(Geometries.point(3, 3).mbr());\n        list.add(Geometries.point(4, 4).mbr());\n        list.add(Geometries.point(5, 5).mbr());\n        List<ListPair<HasGeometry>> pairs = SplitterRStar.getPairs(minSize, list);\n        assertEquals(2, pairs.size());\n    }\n}\n", "file_hash": "f7422c69ba330e09b12d10370a3590afc5beef313775897e19c61fb470dba637", "file_docstring": "", "contexts": ["package com.github.davidmoten.rtree;", "import static org.junit.Assert.assertEquals;", "import java.util.List;", "import org.junit.Test;", "import com.github.davidmoten.guavamini.Lists;", "import com.github.davidmoten.rtree.geometry.Geometries;", "import com.github.davidmoten.rtree.geometry.HasGeometry;", "import com.github.davidmoten.rtree.geometry.ListPair;"], "methods": [], "classes": [{"original_string": "public class SplitterRStarTest {\n\n    @Test\n    public void testGetPairs() {\n\n        int minSize = 2;\n        List<HasGeometry> list = Lists.newArrayList();\n        list.add(Geometries.point(1, 1).mbr());\n        list.add(Geometries.point(2, 2).mbr());\n        list.add(Geometries.point(3, 3).mbr());\n        list.add(Geometries.point(4, 4).mbr());\n        list.add(Geometries.point(5, 5).mbr());\n        List<ListPair<HasGeometry>> pairs = SplitterRStar.getPairs(minSize, list);\n        assertEquals(2, pairs.size());\n    }\n}", "definition": "public class SplitterRStarTest", "class_docstring": "", "name": "SplitterRStarTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @Test\n    public void testGetPairs() {\n\n        int minSize = 2;\n        List<HasGeometry> list = Lists.newArrayList();\n        list.add(Geometries.point(1, 1).mbr());\n        list.add(Geometries.point(2, 2).mbr());\n        list.add(Geometries.point(3, 3).mbr());\n        list.add(Geometries.point(4, 4).mbr());\n        list.add(Geometries.point(5, 5).mbr());\n        List<ListPair<HasGeometry>> pairs = SplitterRStar.getPairs(minSize, list);\n        assertEquals(2, pairs.size());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testGetPairs", "params": [], "body": "                               {\n\n        int minSize = 2;\n        List<HasGeometry> list = Lists.newArrayList();\n        list.add(Geometries.point(1, 1).mbr());\n        list.add(Geometries.point(2, 2).mbr());\n        list.add(Geometries.point(3, 3).mbr());\n        list.add(Geometries.point(4, 4).mbr());\n        list.add(Geometries.point(5, 5).mbr());\n        List<ListPair<HasGeometry>> pairs = SplitterRStar.getPairs(minSize, list);\n        assertEquals(2, pairs.size());\n    }", "signature": "@Test\n    public void testGetPairs()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/com/github/davidmoten/rtree/HighPrecisionTest.java", "original_string": "package com.github.davidmoten.rtree;\n\nimport java.math.BigDecimal;\nimport java.math.MathContext;\nimport java.math.RoundingMode;\n\nimport org.junit.Test;\n\nimport com.github.davidmoten.rtree.geometry.Geometries;\nimport com.github.davidmoten.rtree.geometry.Rectangle;\n\npublic class HighPrecisionTest {\n\n    @Test\n    public void testForIssue72() {\n        long x = 123456789L;\n        System.out.println(new BigDecimal(x).floatValue());\n        BigDecimal b = new BigDecimal(x);\n        System.out.println(b.round(FLOOR).floatValue());\n        System.out.println(b.round(CEILING).floatValue());\n    }\n\n    @Test\n    public void testHighPrecision() {\n        RTree<Integer, Rectangle> tree = RTree.create();\n        tree = tree.add(1, Geometries.rectangle(0, 0, 1, 1));\n        double x1 = 2.0000000001;\n        System.out.println((float) x1);\n        tree = tree.add(2, Geometries.rectangle(x1, 2, 3, 3));\n        tree.search(Geometries.rectangle((float) x1, 2.0, (float) x1, 2.0)) //\n                .test() //\n                .assertNoValues() //\n                .assertCompleted();\n        tree.search(Geometries.rectangle(x1, 2.0, x1, 2.0)) //\n                .test() //\n                .assertValueCount(1) //\n                .assertCompleted();\n    }\n\n    private static final MathContext FLOOR = new MathContext(7, RoundingMode.FLOOR);\n    private static final MathContext CEILING = new MathContext(7, RoundingMode.CEILING);\n\n}\n", "file_hash": "c17884135ce61588443489a24f0f24f7c79397e275e4ba736ccf489d01884267", "file_docstring": "", "contexts": ["package com.github.davidmoten.rtree;", "import java.math.BigDecimal;", "import java.math.MathContext;", "import java.math.RoundingMode;", "import org.junit.Test;", "import com.github.davidmoten.rtree.geometry.Geometries;", "import com.github.davidmoten.rtree.geometry.Rectangle;"], "methods": [], "classes": [{"original_string": "public class HighPrecisionTest {\n\n    @Test\n    public void testForIssue72() {\n        long x = 123456789L;\n        System.out.println(new BigDecimal(x).floatValue());\n        BigDecimal b = new BigDecimal(x);\n        System.out.println(b.round(FLOOR).floatValue());\n        System.out.println(b.round(CEILING).floatValue());\n    }\n\n    @Test\n    public void testHighPrecision() {\n        RTree<Integer, Rectangle> tree = RTree.create();\n        tree = tree.add(1, Geometries.rectangle(0, 0, 1, 1));\n        double x1 = 2.0000000001;\n        System.out.println((float) x1);\n        tree = tree.add(2, Geometries.rectangle(x1, 2, 3, 3));\n        tree.search(Geometries.rectangle((float) x1, 2.0, (float) x1, 2.0)) //\n                .test() //\n                .assertNoValues() //\n                .assertCompleted();\n        tree.search(Geometries.rectangle(x1, 2.0, x1, 2.0)) //\n                .test() //\n                .assertValueCount(1) //\n                .assertCompleted();\n    }\n\n    private static final MathContext FLOOR = new MathContext(7, RoundingMode.FLOOR);\n    private static final MathContext CEILING = new MathContext(7, RoundingMode.CEILING);\n\n}", "definition": "public class HighPrecisionTest", "class_docstring": "", "name": "HighPrecisionTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private static final MathContext FLOOR = new MathContext(7, RoundingMode.FLOOR);", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "MathContext", "name": "FLOOR = new MathContext(7, RoundingMode.FLOOR)", "syntax_pass": true}, {"attribute_expression": "private static final MathContext CEILING = new MathContext(7, RoundingMode.CEILING);", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "MathContext", "name": "CEILING = new MathContext(7, RoundingMode.CEILING)", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @Test\n    public void testForIssue72() {\n        long x = 123456789L;\n        System.out.println(new BigDecimal(x).floatValue());\n        BigDecimal b = new BigDecimal(x);\n        System.out.println(b.round(FLOOR).floatValue());\n        System.out.println(b.round(CEILING).floatValue());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testForIssue72", "params": [], "body": "                                 {\n        long x = 123456789L;\n        System.out.println(new BigDecimal(x).floatValue());\n        BigDecimal b = new BigDecimal(x);\n        System.out.println(b.round(FLOOR).floatValue());\n        System.out.println(b.round(CEILING).floatValue());\n    }", "signature": "@Test\n    public void testForIssue72()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testHighPrecision() {\n        RTree<Integer, Rectangle> tree = RTree.create();\n        tree = tree.add(1, Geometries.rectangle(0, 0, 1, 1));\n        double x1 = 2.0000000001;\n        System.out.println((float) x1);\n        tree = tree.add(2, Geometries.rectangle(x1, 2, 3, 3));\n        tree.search(Geometries.rectangle((float) x1, 2.0, (float) x1, 2.0)) //\n                .test() //\n                .assertNoValues() //\n                .assertCompleted();\n        tree.search(Geometries.rectangle(x1, 2.0, x1, 2.0)) //\n                .test() //\n                .assertValueCount(1) //\n                .assertCompleted();\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testHighPrecision", "params": [], "body": "                                    {\n        RTree<Integer, Rectangle> tree = RTree.create();\n        tree = tree.add(1, Geometries.rectangle(0, 0, 1, 1));\n        double x1 = 2.0000000001;\n        System.out.println((float) x1);\n        tree = tree.add(2, Geometries.rectangle(x1, 2, 3, 3));\n        tree.search(Geometries.rectangle((float) x1, 2.0, (float) x1, 2.0)) //\n                .test() //\n                .assertNoValues() //\n                .assertCompleted();\n        tree.search(Geometries.rectangle(x1, 2.0, x1, 2.0)) //\n                .test() //\n                .assertValueCount(1) //\n                .assertCompleted();\n    }", "signature": "@Test\n    public void testHighPrecision()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/com/github/davidmoten/rtree/Mbr.java", "original_string": "package com.github.davidmoten.rtree;\n\nimport com.github.davidmoten.rtree.geometry.Geometry;\nimport com.github.davidmoten.rtree.geometry.HasGeometry;\nimport com.github.davidmoten.rtree.geometry.Rectangle;\n\npublic class Mbr implements HasGeometry {\n\n    private final Rectangle r;\n\n    public Mbr(Rectangle r) {\n        this.r = r;\n    }\n\n    @Override\n    public Geometry geometry() {\n        return r;\n    }\n\n}\n", "file_hash": "c158d3c8cc8322490b28b581942f56df5c160293bee955ec88428ce372765c3b", "file_docstring": "", "contexts": ["package com.github.davidmoten.rtree;", "import com.github.davidmoten.rtree.geometry.Geometry;", "import com.github.davidmoten.rtree.geometry.HasGeometry;", "import com.github.davidmoten.rtree.geometry.Rectangle;"], "methods": [], "classes": [{"original_string": "public class Mbr implements HasGeometry {\n\n    private final Rectangle r;\n\n    public Mbr(Rectangle r) {\n        this.r = r;\n    }\n\n    @Override\n    public Geometry geometry() {\n        return r;\n    }\n\n}", "definition": "public class Mbr implements HasGeometry", "class_docstring": "", "name": "Mbr", "super_interfaces": ["HasGeometry"], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private final Rectangle r;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Rectangle", "name": "r", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    public Mbr(Rectangle r) {\n        this.r = r;\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "Mbr", "params": [{"name": "r", "type": "Rectangle"}], "body": "                            {\n        this.r = r;\n    }", "signature": "public Mbr(Rectangle r)"}, {"syntax_pass": true, "original_string": "    @Override\n    public Geometry geometry() {\n        return r;\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Geometry", "classes": []}, "name": "geometry", "params": [], "body": "                               {\n        return r;\n    }", "signature": "@Override\n    public Geometry geometry()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/com/github/davidmoten/rtree/BackpressureTest.java", "original_string": "package com.github.davidmoten.rtree;\n\nimport static com.github.davidmoten.rtree.RTreeTest.e;\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertTrue;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\n\nimport org.junit.Test;\nimport org.mockito.Mockito;\n\nimport com.github.davidmoten.junit.Asserts;\nimport com.github.davidmoten.rtree.geometry.Geometry;\nimport com.github.davidmoten.rtree.geometry.Rectangle;\nimport com.github.davidmoten.rtree.internal.util.ImmutableStack;\n\nimport rx.Subscriber;\nimport rx.Subscription;\nimport rx.functions.Func1;\n\npublic class BackpressureTest {\n\n    @Test\n    public void testConstructorIsPrivate() {\n        Asserts.assertIsUtilityClass(Backpressure.class);\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @Test\n    public void testBackpressureSearch() {\n        Subscriber<Object> sub = Mockito.mock(Subscriber.class);\n        ImmutableStack<NodePosition<Object, Geometry>> stack = ImmutableStack.empty();\n        Func1<Geometry, Boolean> condition = Mockito.mock(Func1.class);\n        Backpressure.search(condition, sub, stack, 1);\n        Mockito.verify(sub, Mockito.never()).onNext(Mockito.any());\n    }\n\n    @Test\n    public void testBackpressureSearchNodeWithConditionThatAlwaysReturnsFalse() {\n        RTree<Object, Rectangle> tree = RTree.maxChildren(3).<Object, Rectangle> create()\n                .add(e(1)).add(e(3)).add(e(5)).add(e(7));\n\n        Set<Entry<Object, Rectangle>> found = new HashSet<Entry<Object, Rectangle>>();\n        tree.search(e(1).geometry()).subscribe(backpressureSubscriber(found));\n        assertEquals(1, found.size());\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @Test\n    public void testRequestZero() {\n        Subscriber<Object> sub = new Subscriber<Object>() {\n\n            @Override\n            public void onCompleted() {\n            }\n\n            @Override\n            public void onError(Throwable e) {\n            }\n\n            @Override\n            public void onNext(Object t) {\n\n            }\n        };\n        sub.add(new Subscription() {\n            volatile boolean subscribed = true;\n\n            @Override\n            public void unsubscribe() {\n                subscribed = false;\n            }\n\n            @Override\n            public boolean isUnsubscribed() {\n                return !subscribed;\n            }\n        });\n        Node<Object, Geometry> node = Mockito.mock(Node.class);\n        NodePosition<Object, Geometry> np = new NodePosition<Object, Geometry>(node, 1);\n        ImmutableStack<NodePosition<Object, Geometry>> stack = ImmutableStack\n                .<NodePosition<Object, Geometry>> empty().push(np);\n        Func1<Geometry, Boolean> condition = Mockito.mock(Func1.class);\n        ImmutableStack<NodePosition<Object, Geometry>> stack2 = Backpressure.search(condition, sub,\n                stack, 0);\n        assertTrue(stack2 == stack);\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @Test\n    public void testRequestZeroWhenUnsubscribed() {\n        Subscriber<Object> sub = new Subscriber<Object>() {\n\n            @Override\n            public void onCompleted() {\n            }\n\n            @Override\n            public void onError(Throwable e) {\n            }\n\n            @Override\n            public void onNext(Object t) {\n\n            }\n        };\n        sub.add(new Subscription() {\n\n            volatile boolean subscribed = true;\n\n            @Override\n            public void unsubscribe() {\n                subscribed = false;\n            }\n\n            @Override\n            public boolean isUnsubscribed() {\n                return !subscribed;\n            }\n        });\n        sub.unsubscribe();\n        Node<Object, Geometry> node = Mockito.mock(Node.class);\n        NodePosition<Object, Geometry> np = new NodePosition<Object, Geometry>(node, 1);\n        ImmutableStack<NodePosition<Object, Geometry>> stack = ImmutableStack\n                .<NodePosition<Object, Geometry>> empty().push(np);\n        Func1<Geometry, Boolean> condition = Mockito.mock(Func1.class);\n        ImmutableStack<NodePosition<Object, Geometry>> stack2 = Backpressure.search(condition, sub,\n                stack, 1);\n        assertTrue(stack2.isEmpty());\n    }\n\n    @Test\n    public void testBackpressureIterateWhenNodeHasMaxChildrenAndIsRoot() {\n        Entry<Object, Rectangle> e1 = RTreeTest.e(1);\n        List<Entry<Object, Rectangle>> list = Arrays.asList(e1, e1, e1, e1);\n        RTree<Object, Rectangle> tree = RTree.star().maxChildren(4).<Object, Rectangle> create()\n                .add(list);\n        HashSet<Entry<Object, Rectangle>> expected = new HashSet<Entry<Object, Rectangle>>(list);\n        final HashSet<Entry<Object, Rectangle>> found = new HashSet<Entry<Object, Rectangle>>();\n        tree.entries().subscribe(backpressureSubscriber(found));\n        assertEquals(expected, found);\n    }\n\n    @Test\n    public void testBackpressureRequestZero() {\n        Entry<Object, Rectangle> e1 = RTreeTest.e(1);\n        List<Entry<Object, Rectangle>> list = Arrays.asList(e1, e1, e1, e1);\n        RTree<Object, Rectangle> tree = RTree.star().maxChildren(4).<Object, Rectangle> create()\n                .add(list);\n        HashSet<Entry<Object, Rectangle>> expected = new HashSet<Entry<Object, Rectangle>>(list);\n        final HashSet<Entry<Object, Rectangle>> found = new HashSet<Entry<Object, Rectangle>>();\n        tree.entries().subscribe(new Subscriber<Entry<Object, Rectangle>>() {\n\n            @Override\n            public void onStart() {\n                request(1);\n            }\n\n            @Override\n            public void onCompleted() {\n\n            }\n\n            @Override\n            public void onError(Throwable e) {\n\n            }\n\n            @Override\n            public void onNext(Entry<Object, Rectangle> t) {\n                found.add(t);\n                request(0);\n            }\n        });\n        assertEquals(expected, found);\n    }\n\n    @Test\n    public void testBackpressureIterateWhenNodeHasMaxChildrenAndIsNotRoot() {\n        Entry<Object, Rectangle> e1 = RTreeTest.e(1);\n        List<Entry<Object, Rectangle>> list = new ArrayList<Entry<Object, Rectangle>>();\n        for (int i = 1; i <= 17; i++)\n            list.add(e1);\n        RTree<Object, Rectangle> tree = RTree.star().maxChildren(4).<Object, Rectangle> create()\n                .add(list);\n        HashSet<Entry<Object, Rectangle>> expected = new HashSet<Entry<Object, Rectangle>>(list);\n        final HashSet<Entry<Object, Rectangle>> found = new HashSet<Entry<Object, Rectangle>>();\n        tree.entries().subscribe(backpressureSubscriber(found));\n        assertEquals(expected, found);\n    }\n\n    @Test\n    public void testBackpressureIterateWhenConditionFailsAgainstNonLeafNode() {\n        Entry<Object, Rectangle> e1 = e(1);\n        List<Entry<Object, Rectangle>> list = new ArrayList<Entry<Object, Rectangle>>();\n        for (int i = 1; i <= 17; i++)\n            list.add(e1);\n        list.add(e(2));\n        RTree<Object, Rectangle> tree = RTree.star().maxChildren(4).<Object, Rectangle> create()\n                .add(list);\n        HashSet<Entry<Object, Rectangle>> expected = new HashSet<Entry<Object, Rectangle>>(list);\n        final HashSet<Entry<Object, Rectangle>> found = new HashSet<Entry<Object, Rectangle>>();\n        tree.entries().subscribe(backpressureSubscriber(found));\n        assertEquals(expected, found);\n    }\n\n    @Test\n    public void testBackpressureIterateWhenConditionFailsAgainstLeafNode() {\n        Entry<Object, Rectangle> e3 = e(3);\n        RTree<Object, Rectangle> tree = RTree.star().maxChildren(4).<Object, Rectangle> create()\n                .add(e(1)).add(e3);\n        Set<Entry<Object, Rectangle>> expected = Collections.singleton(e3);\n        final Set<Entry<Object, Rectangle>> found = new HashSet<Entry<Object, Rectangle>>();\n        tree.search(e3.geometry()).subscribe(backpressureSubscriber(found));\n        assertEquals(expected, found);\n    }\n\n    @Test\n    public void testBackpressureFastPathNotInitiatedTwice() {\n        Entry<Object, Rectangle> e3 = e(3);\n        RTree<Object, Rectangle> tree = RTree.star().maxChildren(4).<Object, Rectangle> create()\n                .add(e(1)).add(e3);\n        Set<Entry<Object, Rectangle>> expected = Collections.singleton(e3);\n        final Set<Entry<Object, Rectangle>> found = new HashSet<Entry<Object, Rectangle>>();\n        tree.search(e3.geometry()).subscribe(new Subscriber<Entry<Object, Rectangle>>() {\n\n            @Override\n            public void onCompleted() {\n\n            }\n\n            @Override\n            public void onError(Throwable e) {\n\n            }\n\n            @Override\n            public void onNext(Entry<Object, Rectangle> t) {\n                found.add(t);\n                request(Long.MAX_VALUE);\n            }\n        });\n        assertEquals(expected, found);\n    }\n\n    private static Subscriber<Entry<Object, Rectangle>> backpressureSubscriber(\n            final Set<Entry<Object, Rectangle>> found) {\n        return new Subscriber<Entry<Object, Rectangle>>() {\n\n            @Override\n            public void onStart() {\n                request(1);\n            }\n\n            @Override\n            public void onCompleted() {\n\n            }\n\n            @Override\n            public void onError(Throwable e) {\n\n            }\n\n            @Override\n            public void onNext(Entry<Object, Rectangle> t) {\n                found.add(t);\n                request(1);\n            }\n        };\n    }\n\n}\n", "file_hash": "9698fa55381d8ed6591b2c932fb71caf199f5674133efd8dcbb737ead3d68a81", "file_docstring": "", "contexts": ["package com.github.davidmoten.rtree;", "import static com.github.davidmoten.rtree.RTreeTest.e;", "import static org.junit.Assert.assertEquals;", "import static org.junit.Assert.assertTrue;", "import java.util.ArrayList;", "import java.util.Arrays;", "import java.util.Collections;", "import java.util.HashSet;", "import java.util.List;", "import java.util.Set;", "import org.junit.Test;", "import org.mockito.Mockito;", "import com.github.davidmoten.junit.Asserts;", "import com.github.davidmoten.rtree.geometry.Geometry;", "import com.github.davidmoten.rtree.geometry.Rectangle;", "import com.github.davidmoten.rtree.internal.util.ImmutableStack;", "import rx.Subscriber;", "import rx.Subscription;", "import rx.functions.Func1;"], "methods": [], "classes": [{"original_string": "public class BackpressureTest {\n\n    @Test\n    public void testConstructorIsPrivate() {\n        Asserts.assertIsUtilityClass(Backpressure.class);\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @Test\n    public void testBackpressureSearch() {\n        Subscriber<Object> sub = Mockito.mock(Subscriber.class);\n        ImmutableStack<NodePosition<Object, Geometry>> stack = ImmutableStack.empty();\n        Func1<Geometry, Boolean> condition = Mockito.mock(Func1.class);\n        Backpressure.search(condition, sub, stack, 1);\n        Mockito.verify(sub, Mockito.never()).onNext(Mockito.any());\n    }\n\n    @Test\n    public void testBackpressureSearchNodeWithConditionThatAlwaysReturnsFalse() {\n        RTree<Object, Rectangle> tree = RTree.maxChildren(3).<Object, Rectangle> create()\n                .add(e(1)).add(e(3)).add(e(5)).add(e(7));\n\n        Set<Entry<Object, Rectangle>> found = new HashSet<Entry<Object, Rectangle>>();\n        tree.search(e(1).geometry()).subscribe(backpressureSubscriber(found));\n        assertEquals(1, found.size());\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @Test\n    public void testRequestZero() {\n        Subscriber<Object> sub = new Subscriber<Object>() {\n\n            @Override\n            public void onCompleted() {\n            }\n\n            @Override\n            public void onError(Throwable e) {\n            }\n\n            @Override\n            public void onNext(Object t) {\n\n            }\n        };\n        sub.add(new Subscription() {\n            volatile boolean subscribed = true;\n\n            @Override\n            public void unsubscribe() {\n                subscribed = false;\n            }\n\n            @Override\n            public boolean isUnsubscribed() {\n                return !subscribed;\n            }\n        });\n        Node<Object, Geometry> node = Mockito.mock(Node.class);\n        NodePosition<Object, Geometry> np = new NodePosition<Object, Geometry>(node, 1);\n        ImmutableStack<NodePosition<Object, Geometry>> stack = ImmutableStack\n                .<NodePosition<Object, Geometry>> empty().push(np);\n        Func1<Geometry, Boolean> condition = Mockito.mock(Func1.class);\n        ImmutableStack<NodePosition<Object, Geometry>> stack2 = Backpressure.search(condition, sub,\n                stack, 0);\n        assertTrue(stack2 == stack);\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @Test\n    public void testRequestZeroWhenUnsubscribed() {\n        Subscriber<Object> sub = new Subscriber<Object>() {\n\n            @Override\n            public void onCompleted() {\n            }\n\n            @Override\n            public void onError(Throwable e) {\n            }\n\n            @Override\n            public void onNext(Object t) {\n\n            }\n        };\n        sub.add(new Subscription() {\n\n            volatile boolean subscribed = true;\n\n            @Override\n            public void unsubscribe() {\n                subscribed = false;\n            }\n\n            @Override\n            public boolean isUnsubscribed() {\n                return !subscribed;\n            }\n        });\n        sub.unsubscribe();\n        Node<Object, Geometry> node = Mockito.mock(Node.class);\n        NodePosition<Object, Geometry> np = new NodePosition<Object, Geometry>(node, 1);\n        ImmutableStack<NodePosition<Object, Geometry>> stack = ImmutableStack\n                .<NodePosition<Object, Geometry>> empty().push(np);\n        Func1<Geometry, Boolean> condition = Mockito.mock(Func1.class);\n        ImmutableStack<NodePosition<Object, Geometry>> stack2 = Backpressure.search(condition, sub,\n                stack, 1);\n        assertTrue(stack2.isEmpty());\n    }\n\n    @Test\n    public void testBackpressureIterateWhenNodeHasMaxChildrenAndIsRoot() {\n        Entry<Object, Rectangle> e1 = RTreeTest.e(1);\n        List<Entry<Object, Rectangle>> list = Arrays.asList(e1, e1, e1, e1);\n        RTree<Object, Rectangle> tree = RTree.star().maxChildren(4).<Object, Rectangle> create()\n                .add(list);\n        HashSet<Entry<Object, Rectangle>> expected = new HashSet<Entry<Object, Rectangle>>(list);\n        final HashSet<Entry<Object, Rectangle>> found = new HashSet<Entry<Object, Rectangle>>();\n        tree.entries().subscribe(backpressureSubscriber(found));\n        assertEquals(expected, found);\n    }\n\n    @Test\n    public void testBackpressureRequestZero() {\n        Entry<Object, Rectangle> e1 = RTreeTest.e(1);\n        List<Entry<Object, Rectangle>> list = Arrays.asList(e1, e1, e1, e1);\n        RTree<Object, Rectangle> tree = RTree.star().maxChildren(4).<Object, Rectangle> create()\n                .add(list);\n        HashSet<Entry<Object, Rectangle>> expected = new HashSet<Entry<Object, Rectangle>>(list);\n        final HashSet<Entry<Object, Rectangle>> found = new HashSet<Entry<Object, Rectangle>>();\n        tree.entries().subscribe(new Subscriber<Entry<Object, Rectangle>>() {\n\n            @Override\n            public void onStart() {\n                request(1);\n            }\n\n            @Override\n            public void onCompleted() {\n\n            }\n\n            @Override\n            public void onError(Throwable e) {\n\n            }\n\n            @Override\n            public void onNext(Entry<Object, Rectangle> t) {\n                found.add(t);\n                request(0);\n            }\n        });\n        assertEquals(expected, found);\n    }\n\n    @Test\n    public void testBackpressureIterateWhenNodeHasMaxChildrenAndIsNotRoot() {\n        Entry<Object, Rectangle> e1 = RTreeTest.e(1);\n        List<Entry<Object, Rectangle>> list = new ArrayList<Entry<Object, Rectangle>>();\n        for (int i = 1; i <= 17; i++)\n            list.add(e1);\n        RTree<Object, Rectangle> tree = RTree.star().maxChildren(4).<Object, Rectangle> create()\n                .add(list);\n        HashSet<Entry<Object, Rectangle>> expected = new HashSet<Entry<Object, Rectangle>>(list);\n        final HashSet<Entry<Object, Rectangle>> found = new HashSet<Entry<Object, Rectangle>>();\n        tree.entries().subscribe(backpressureSubscriber(found));\n        assertEquals(expected, found);\n    }\n\n    @Test\n    public void testBackpressureIterateWhenConditionFailsAgainstNonLeafNode() {\n        Entry<Object, Rectangle> e1 = e(1);\n        List<Entry<Object, Rectangle>> list = new ArrayList<Entry<Object, Rectangle>>();\n        for (int i = 1; i <= 17; i++)\n            list.add(e1);\n        list.add(e(2));\n        RTree<Object, Rectangle> tree = RTree.star().maxChildren(4).<Object, Rectangle> create()\n                .add(list);\n        HashSet<Entry<Object, Rectangle>> expected = new HashSet<Entry<Object, Rectangle>>(list);\n        final HashSet<Entry<Object, Rectangle>> found = new HashSet<Entry<Object, Rectangle>>();\n        tree.entries().subscribe(backpressureSubscriber(found));\n        assertEquals(expected, found);\n    }\n\n    @Test\n    public void testBackpressureIterateWhenConditionFailsAgainstLeafNode() {\n        Entry<Object, Rectangle> e3 = e(3);\n        RTree<Object, Rectangle> tree = RTree.star().maxChildren(4).<Object, Rectangle> create()\n                .add(e(1)).add(e3);\n        Set<Entry<Object, Rectangle>> expected = Collections.singleton(e3);\n        final Set<Entry<Object, Rectangle>> found = new HashSet<Entry<Object, Rectangle>>();\n        tree.search(e3.geometry()).subscribe(backpressureSubscriber(found));\n        assertEquals(expected, found);\n    }\n\n    @Test\n    public void testBackpressureFastPathNotInitiatedTwice() {\n        Entry<Object, Rectangle> e3 = e(3);\n        RTree<Object, Rectangle> tree = RTree.star().maxChildren(4).<Object, Rectangle> create()\n                .add(e(1)).add(e3);\n        Set<Entry<Object, Rectangle>> expected = Collections.singleton(e3);\n        final Set<Entry<Object, Rectangle>> found = new HashSet<Entry<Object, Rectangle>>();\n        tree.search(e3.geometry()).subscribe(new Subscriber<Entry<Object, Rectangle>>() {\n\n            @Override\n            public void onCompleted() {\n\n            }\n\n            @Override\n            public void onError(Throwable e) {\n\n            }\n\n            @Override\n            public void onNext(Entry<Object, Rectangle> t) {\n                found.add(t);\n                request(Long.MAX_VALUE);\n            }\n        });\n        assertEquals(expected, found);\n    }\n\n    private static Subscriber<Entry<Object, Rectangle>> backpressureSubscriber(\n            final Set<Entry<Object, Rectangle>> found) {\n        return new Subscriber<Entry<Object, Rectangle>>() {\n\n            @Override\n            public void onStart() {\n                request(1);\n            }\n\n            @Override\n            public void onCompleted() {\n\n            }\n\n            @Override\n            public void onError(Throwable e) {\n\n            }\n\n            @Override\n            public void onNext(Entry<Object, Rectangle> t) {\n                found.add(t);\n                request(1);\n            }\n        };\n    }\n\n}", "definition": "public class BackpressureTest", "class_docstring": "", "name": "BackpressureTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @Test\n    public void testConstructorIsPrivate() {\n        Asserts.assertIsUtilityClass(Backpressure.class);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testConstructorIsPrivate", "params": [], "body": "                                           {\n        Asserts.assertIsUtilityClass(Backpressure.class);\n    }", "signature": "@Test\n    public void testConstructorIsPrivate()"}, {"syntax_pass": true, "original_string": "    @SuppressWarnings(\"unchecked\")\n    @Test\n    public void testBackpressureSearch() {\n        Subscriber<Object> sub = Mockito.mock(Subscriber.class);\n        ImmutableStack<NodePosition<Object, Geometry>> stack = ImmutableStack.empty();\n        Func1<Geometry, Boolean> condition = Mockito.mock(Func1.class);\n        Backpressure.search(condition, sub, stack, 1);\n        Mockito.verify(sub, Mockito.never()).onNext(Mockito.any());\n    }", "docstring": "", "attributes": {"modifiers": "@SuppressWarnings(\"unchecked\")\n    @Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["@SuppressWarnings(\"unchecked\")", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "testBackpressureSearch", "params": [], "body": "                                         {\n        Subscriber<Object> sub = Mockito.mock(Subscriber.class);\n        ImmutableStack<NodePosition<Object, Geometry>> stack = ImmutableStack.empty();\n        Func1<Geometry, Boolean> condition = Mockito.mock(Func1.class);\n        Backpressure.search(condition, sub, stack, 1);\n        Mockito.verify(sub, Mockito.never()).onNext(Mockito.any());\n    }", "signature": "@SuppressWarnings(\"unchecked\")\n    @Test\n    public void testBackpressureSearch()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testBackpressureSearchNodeWithConditionThatAlwaysReturnsFalse() {\n        RTree<Object, Rectangle> tree = RTree.maxChildren(3).<Object, Rectangle> create()\n                .add(e(1)).add(e(3)).add(e(5)).add(e(7));\n\n        Set<Entry<Object, Rectangle>> found = new HashSet<Entry<Object, Rectangle>>();\n        tree.search(e(1).geometry()).subscribe(backpressureSubscriber(found));\n        assertEquals(1, found.size());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testBackpressureSearchNodeWithConditionThatAlwaysReturnsFalse", "params": [], "body": "                                                                                {\n        RTree<Object, Rectangle> tree = RTree.maxChildren(3).<Object, Rectangle> create()\n                .add(e(1)).add(e(3)).add(e(5)).add(e(7));\n\n        Set<Entry<Object, Rectangle>> found = new HashSet<Entry<Object, Rectangle>>();\n        tree.search(e(1).geometry()).subscribe(backpressureSubscriber(found));\n        assertEquals(1, found.size());\n    }", "signature": "@Test\n    public void testBackpressureSearchNodeWithConditionThatAlwaysReturnsFalse()"}, {"syntax_pass": true, "original_string": "    @SuppressWarnings(\"unchecked\")\n    @Test\n    public void testRequestZero() {\n        Subscriber<Object> sub = new Subscriber<Object>() {\n\n            @Override\n            public void onCompleted() {\n            }\n\n            @Override\n            public void onError(Throwable e) {\n            }\n\n            @Override\n            public void onNext(Object t) {\n\n            }\n        };\n        sub.add(new Subscription() {\n            volatile boolean subscribed = true;\n\n            @Override\n            public void unsubscribe() {\n                subscribed = false;\n            }\n\n            @Override\n            public boolean isUnsubscribed() {\n                return !subscribed;\n            }\n        });\n        Node<Object, Geometry> node = Mockito.mock(Node.class);\n        NodePosition<Object, Geometry> np = new NodePosition<Object, Geometry>(node, 1);\n        ImmutableStack<NodePosition<Object, Geometry>> stack = ImmutableStack\n                .<NodePosition<Object, Geometry>> empty().push(np);\n        Func1<Geometry, Boolean> condition = Mockito.mock(Func1.class);\n        ImmutableStack<NodePosition<Object, Geometry>> stack2 = Backpressure.search(condition, sub,\n                stack, 0);\n        assertTrue(stack2 == stack);\n    }", "docstring": "", "attributes": {"modifiers": "@SuppressWarnings(\"unchecked\")\n    @Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["@SuppressWarnings(\"unchecked\")", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "testRequestZero", "params": [], "body": "                                  {\n        Subscriber<Object> sub = new Subscriber<Object>() {\n\n            @Override\n            public void onCompleted() {\n            }\n\n            @Override\n            public void onError(Throwable e) {\n            }\n\n            @Override\n            public void onNext(Object t) {\n\n            }\n        };\n        sub.add(new Subscription() {\n            volatile boolean subscribed = true;\n\n            @Override\n            public void unsubscribe() {\n                subscribed = false;\n            }\n\n            @Override\n            public boolean isUnsubscribed() {\n                return !subscribed;\n            }\n        });\n        Node<Object, Geometry> node = Mockito.mock(Node.class);\n        NodePosition<Object, Geometry> np = new NodePosition<Object, Geometry>(node, 1);\n        ImmutableStack<NodePosition<Object, Geometry>> stack = ImmutableStack\n                .<NodePosition<Object, Geometry>> empty().push(np);\n        Func1<Geometry, Boolean> condition = Mockito.mock(Func1.class);\n        ImmutableStack<NodePosition<Object, Geometry>> stack2 = Backpressure.search(condition, sub,\n                stack, 0);\n        assertTrue(stack2 == stack);\n    }", "signature": "@SuppressWarnings(\"unchecked\")\n    @Test\n    public void testRequestZero()"}, {"syntax_pass": true, "original_string": "    @SuppressWarnings(\"unchecked\")\n    @Test\n    public void testRequestZeroWhenUnsubscribed() {\n        Subscriber<Object> sub = new Subscriber<Object>() {\n\n            @Override\n            public void onCompleted() {\n            }\n\n            @Override\n            public void onError(Throwable e) {\n            }\n\n            @Override\n            public void onNext(Object t) {\n\n            }\n        };\n        sub.add(new Subscription() {\n\n            volatile boolean subscribed = true;\n\n            @Override\n            public void unsubscribe() {\n                subscribed = false;\n            }\n\n            @Override\n            public boolean isUnsubscribed() {\n                return !subscribed;\n            }\n        });\n        sub.unsubscribe();\n        Node<Object, Geometry> node = Mockito.mock(Node.class);\n        NodePosition<Object, Geometry> np = new NodePosition<Object, Geometry>(node, 1);\n        ImmutableStack<NodePosition<Object, Geometry>> stack = ImmutableStack\n                .<NodePosition<Object, Geometry>> empty().push(np);\n        Func1<Geometry, Boolean> condition = Mockito.mock(Func1.class);\n        ImmutableStack<NodePosition<Object, Geometry>> stack2 = Backpressure.search(condition, sub,\n                stack, 1);\n        assertTrue(stack2.isEmpty());\n    }", "docstring": "", "attributes": {"modifiers": "@SuppressWarnings(\"unchecked\")\n    @Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["@SuppressWarnings(\"unchecked\")", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "testRequestZeroWhenUnsubscribed", "params": [], "body": "                                                  {\n        Subscriber<Object> sub = new Subscriber<Object>() {\n\n            @Override\n            public void onCompleted() {\n            }\n\n            @Override\n            public void onError(Throwable e) {\n            }\n\n            @Override\n            public void onNext(Object t) {\n\n            }\n        };\n        sub.add(new Subscription() {\n\n            volatile boolean subscribed = true;\n\n            @Override\n            public void unsubscribe() {\n                subscribed = false;\n            }\n\n            @Override\n            public boolean isUnsubscribed() {\n                return !subscribed;\n            }\n        });\n        sub.unsubscribe();\n        Node<Object, Geometry> node = Mockito.mock(Node.class);\n        NodePosition<Object, Geometry> np = new NodePosition<Object, Geometry>(node, 1);\n        ImmutableStack<NodePosition<Object, Geometry>> stack = ImmutableStack\n                .<NodePosition<Object, Geometry>> empty().push(np);\n        Func1<Geometry, Boolean> condition = Mockito.mock(Func1.class);\n        ImmutableStack<NodePosition<Object, Geometry>> stack2 = Backpressure.search(condition, sub,\n                stack, 1);\n        assertTrue(stack2.isEmpty());\n    }", "signature": "@SuppressWarnings(\"unchecked\")\n    @Test\n    public void testRequestZeroWhenUnsubscribed()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testBackpressureIterateWhenNodeHasMaxChildrenAndIsRoot() {\n        Entry<Object, Rectangle> e1 = RTreeTest.e(1);\n        List<Entry<Object, Rectangle>> list = Arrays.asList(e1, e1, e1, e1);\n        RTree<Object, Rectangle> tree = RTree.star().maxChildren(4).<Object, Rectangle> create()\n                .add(list);\n        HashSet<Entry<Object, Rectangle>> expected = new HashSet<Entry<Object, Rectangle>>(list);\n        final HashSet<Entry<Object, Rectangle>> found = new HashSet<Entry<Object, Rectangle>>();\n        tree.entries().subscribe(backpressureSubscriber(found));\n        assertEquals(expected, found);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testBackpressureIterateWhenNodeHasMaxChildrenAndIsRoot", "params": [], "body": "                                                                         {\n        Entry<Object, Rectangle> e1 = RTreeTest.e(1);\n        List<Entry<Object, Rectangle>> list = Arrays.asList(e1, e1, e1, e1);\n        RTree<Object, Rectangle> tree = RTree.star().maxChildren(4).<Object, Rectangle> create()\n                .add(list);\n        HashSet<Entry<Object, Rectangle>> expected = new HashSet<Entry<Object, Rectangle>>(list);\n        final HashSet<Entry<Object, Rectangle>> found = new HashSet<Entry<Object, Rectangle>>();\n        tree.entries().subscribe(backpressureSubscriber(found));\n        assertEquals(expected, found);\n    }", "signature": "@Test\n    public void testBackpressureIterateWhenNodeHasMaxChildrenAndIsRoot()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testBackpressureRequestZero() {\n        Entry<Object, Rectangle> e1 = RTreeTest.e(1);\n        List<Entry<Object, Rectangle>> list = Arrays.asList(e1, e1, e1, e1);\n        RTree<Object, Rectangle> tree = RTree.star().maxChildren(4).<Object, Rectangle> create()\n                .add(list);\n        HashSet<Entry<Object, Rectangle>> expected = new HashSet<Entry<Object, Rectangle>>(list);\n        final HashSet<Entry<Object, Rectangle>> found = new HashSet<Entry<Object, Rectangle>>();\n        tree.entries().subscribe(new Subscriber<Entry<Object, Rectangle>>() {\n\n            @Override\n            public void onStart() {\n                request(1);\n            }\n\n            @Override\n            public void onCompleted() {\n\n            }\n\n            @Override\n            public void onError(Throwable e) {\n\n            }\n\n            @Override\n            public void onNext(Entry<Object, Rectangle> t) {\n                found.add(t);\n                request(0);\n            }\n        });\n        assertEquals(expected, found);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testBackpressureRequestZero", "params": [], "body": "                                              {\n        Entry<Object, Rectangle> e1 = RTreeTest.e(1);\n        List<Entry<Object, Rectangle>> list = Arrays.asList(e1, e1, e1, e1);\n        RTree<Object, Rectangle> tree = RTree.star().maxChildren(4).<Object, Rectangle> create()\n                .add(list);\n        HashSet<Entry<Object, Rectangle>> expected = new HashSet<Entry<Object, Rectangle>>(list);\n        final HashSet<Entry<Object, Rectangle>> found = new HashSet<Entry<Object, Rectangle>>();\n        tree.entries().subscribe(new Subscriber<Entry<Object, Rectangle>>() {\n\n            @Override\n            public void onStart() {\n                request(1);\n            }\n\n            @Override\n            public void onCompleted() {\n\n            }\n\n            @Override\n            public void onError(Throwable e) {\n\n            }\n\n            @Override\n            public void onNext(Entry<Object, Rectangle> t) {\n                found.add(t);\n                request(0);\n            }\n        });\n        assertEquals(expected, found);\n    }", "signature": "@Test\n    public void testBackpressureRequestZero()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testBackpressureIterateWhenNodeHasMaxChildrenAndIsNotRoot() {\n        Entry<Object, Rectangle> e1 = RTreeTest.e(1);\n        List<Entry<Object, Rectangle>> list = new ArrayList<Entry<Object, Rectangle>>();\n        for (int i = 1; i <= 17; i++)\n            list.add(e1);\n        RTree<Object, Rectangle> tree = RTree.star().maxChildren(4).<Object, Rectangle> create()\n                .add(list);\n        HashSet<Entry<Object, Rectangle>> expected = new HashSet<Entry<Object, Rectangle>>(list);\n        final HashSet<Entry<Object, Rectangle>> found = new HashSet<Entry<Object, Rectangle>>();\n        tree.entries().subscribe(backpressureSubscriber(found));\n        assertEquals(expected, found);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testBackpressureIterateWhenNodeHasMaxChildrenAndIsNotRoot", "params": [], "body": "                                                                            {\n        Entry<Object, Rectangle> e1 = RTreeTest.e(1);\n        List<Entry<Object, Rectangle>> list = new ArrayList<Entry<Object, Rectangle>>();\n        for (int i = 1; i <= 17; i++)\n            list.add(e1);\n        RTree<Object, Rectangle> tree = RTree.star().maxChildren(4).<Object, Rectangle> create()\n                .add(list);\n        HashSet<Entry<Object, Rectangle>> expected = new HashSet<Entry<Object, Rectangle>>(list);\n        final HashSet<Entry<Object, Rectangle>> found = new HashSet<Entry<Object, Rectangle>>();\n        tree.entries().subscribe(backpressureSubscriber(found));\n        assertEquals(expected, found);\n    }", "signature": "@Test\n    public void testBackpressureIterateWhenNodeHasMaxChildrenAndIsNotRoot()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testBackpressureIterateWhenConditionFailsAgainstNonLeafNode() {\n        Entry<Object, Rectangle> e1 = e(1);\n        List<Entry<Object, Rectangle>> list = new ArrayList<Entry<Object, Rectangle>>();\n        for (int i = 1; i <= 17; i++)\n            list.add(e1);\n        list.add(e(2));\n        RTree<Object, Rectangle> tree = RTree.star().maxChildren(4).<Object, Rectangle> create()\n                .add(list);\n        HashSet<Entry<Object, Rectangle>> expected = new HashSet<Entry<Object, Rectangle>>(list);\n        final HashSet<Entry<Object, Rectangle>> found = new HashSet<Entry<Object, Rectangle>>();\n        tree.entries().subscribe(backpressureSubscriber(found));\n        assertEquals(expected, found);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testBackpressureIterateWhenConditionFailsAgainstNonLeafNode", "params": [], "body": "                                                                              {\n        Entry<Object, Rectangle> e1 = e(1);\n        List<Entry<Object, Rectangle>> list = new ArrayList<Entry<Object, Rectangle>>();\n        for (int i = 1; i <= 17; i++)\n            list.add(e1);\n        list.add(e(2));\n        RTree<Object, Rectangle> tree = RTree.star().maxChildren(4).<Object, Rectangle> create()\n                .add(list);\n        HashSet<Entry<Object, Rectangle>> expected = new HashSet<Entry<Object, Rectangle>>(list);\n        final HashSet<Entry<Object, Rectangle>> found = new HashSet<Entry<Object, Rectangle>>();\n        tree.entries().subscribe(backpressureSubscriber(found));\n        assertEquals(expected, found);\n    }", "signature": "@Test\n    public void testBackpressureIterateWhenConditionFailsAgainstNonLeafNode()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testBackpressureIterateWhenConditionFailsAgainstLeafNode() {\n        Entry<Object, Rectangle> e3 = e(3);\n        RTree<Object, Rectangle> tree = RTree.star().maxChildren(4).<Object, Rectangle> create()\n                .add(e(1)).add(e3);\n        Set<Entry<Object, Rectangle>> expected = Collections.singleton(e3);\n        final Set<Entry<Object, Rectangle>> found = new HashSet<Entry<Object, Rectangle>>();\n        tree.search(e3.geometry()).subscribe(backpressureSubscriber(found));\n        assertEquals(expected, found);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testBackpressureIterateWhenConditionFailsAgainstLeafNode", "params": [], "body": "                                                                           {\n        Entry<Object, Rectangle> e3 = e(3);\n        RTree<Object, Rectangle> tree = RTree.star().maxChildren(4).<Object, Rectangle> create()\n                .add(e(1)).add(e3);\n        Set<Entry<Object, Rectangle>> expected = Collections.singleton(e3);\n        final Set<Entry<Object, Rectangle>> found = new HashSet<Entry<Object, Rectangle>>();\n        tree.search(e3.geometry()).subscribe(backpressureSubscriber(found));\n        assertEquals(expected, found);\n    }", "signature": "@Test\n    public void testBackpressureIterateWhenConditionFailsAgainstLeafNode()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testBackpressureFastPathNotInitiatedTwice() {\n        Entry<Object, Rectangle> e3 = e(3);\n        RTree<Object, Rectangle> tree = RTree.star().maxChildren(4).<Object, Rectangle> create()\n                .add(e(1)).add(e3);\n        Set<Entry<Object, Rectangle>> expected = Collections.singleton(e3);\n        final Set<Entry<Object, Rectangle>> found = new HashSet<Entry<Object, Rectangle>>();\n        tree.search(e3.geometry()).subscribe(new Subscriber<Entry<Object, Rectangle>>() {\n\n            @Override\n            public void onCompleted() {\n\n            }\n\n            @Override\n            public void onError(Throwable e) {\n\n            }\n\n            @Override\n            public void onNext(Entry<Object, Rectangle> t) {\n                found.add(t);\n                request(Long.MAX_VALUE);\n            }\n        });\n        assertEquals(expected, found);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testBackpressureFastPathNotInitiatedTwice", "params": [], "body": "                                                            {\n        Entry<Object, Rectangle> e3 = e(3);\n        RTree<Object, Rectangle> tree = RTree.star().maxChildren(4).<Object, Rectangle> create()\n                .add(e(1)).add(e3);\n        Set<Entry<Object, Rectangle>> expected = Collections.singleton(e3);\n        final Set<Entry<Object, Rectangle>> found = new HashSet<Entry<Object, Rectangle>>();\n        tree.search(e3.geometry()).subscribe(new Subscriber<Entry<Object, Rectangle>>() {\n\n            @Override\n            public void onCompleted() {\n\n            }\n\n            @Override\n            public void onError(Throwable e) {\n\n            }\n\n            @Override\n            public void onNext(Entry<Object, Rectangle> t) {\n                found.add(t);\n                request(Long.MAX_VALUE);\n            }\n        });\n        assertEquals(expected, found);\n    }", "signature": "@Test\n    public void testBackpressureFastPathNotInitiatedTwice()"}, {"syntax_pass": true, "original_string": "    private static Subscriber<Entry<Object, Rectangle>> backpressureSubscriber(\n            final Set<Entry<Object, Rectangle>> found) {\n        return new Subscriber<Entry<Object, Rectangle>>() {\n\n            @Override\n            public void onStart() {\n                request(1);\n            }\n\n            @Override\n            public void onCompleted() {\n\n            }\n\n            @Override\n            public void onError(Throwable e) {\n\n            }\n\n            @Override\n            public void onNext(Entry<Object, Rectangle> t) {\n                found.add(t);\n                request(1);\n            }\n        };\n    }", "docstring": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "Subscriber<Entry<Object, Rectangle>>", "classes": []}, "name": "backpressureSubscriber", "params": [{"name": "found", "type": "Set<Entry<Object, Rectangle>>"}], "body": "                                                       {\n        return new Subscriber<Entry<Object, Rectangle>>() {\n\n            @Override\n            public void onStart() {\n                request(1);\n            }\n\n            @Override\n            public void onCompleted() {\n\n            }\n\n            @Override\n            public void onError(Throwable e) {\n\n            }\n\n            @Override\n            public void onNext(Entry<Object, Rectangle> t) {\n                found.add(t);\n                request(1);\n            }\n        };\n    }", "signature": "private static Subscriber<Entry<Object, Rectangle>> backpressureSubscriber(\n            final Set<Entry<Object, Rectangle>> found)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/com/github/davidmoten/rtree/StringSplitTest.java", "original_string": "package com.github.davidmoten.rtree;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.fail;\n\nimport rx.Observable;\nimport rx.observables.StringObservable;\n\npublic class StringSplitTest {\n\n    // TODO remove this when 0.22.0 released\n    // @Test\n    public void testSplitOnEmptyStream() {\n        assertEquals(0, (int) StringObservable.split(Observable.<String> empty(), \"\\n\").count()\n                .toBlocking().single());\n    }\n\n    // TODO remove thiese when 0.22 released of rxjava-string\n    // @Test\n    public void testSplitOnStreamThatThrowsExceptionImmediately() {\n        RuntimeException ex = new RuntimeException(\"boo\");\n        try {\n            StringObservable.split(Observable.<String> error(ex), \"\\n\").count().toBlocking()\n                    .single();\n            fail();\n        } catch (RuntimeException e) {\n            assertEquals(ex, e);\n        }\n    }\n}\n", "file_hash": "871ef32486e752bc06826aa083ea8189b9e6f2da7ea34d47565ce4ac7f59f2a9", "file_docstring": "", "contexts": ["package com.github.davidmoten.rtree;", "import static org.junit.Assert.assertEquals;", "import static org.junit.Assert.fail;", "import rx.Observable;", "import rx.observables.StringObservable;"], "methods": [], "classes": [{"original_string": "public class StringSplitTest {\n\n    // TODO remove this when 0.22.0 released\n    // @Test\n    public void testSplitOnEmptyStream() {\n        assertEquals(0, (int) StringObservable.split(Observable.<String> empty(), \"\\n\").count()\n                .toBlocking().single());\n    }\n\n    // TODO remove thiese when 0.22 released of rxjava-string\n    // @Test\n    public void testSplitOnStreamThatThrowsExceptionImmediately() {\n        RuntimeException ex = new RuntimeException(\"boo\");\n        try {\n            StringObservable.split(Observable.<String> error(ex), \"\\n\").count().toBlocking()\n                    .single();\n            fail();\n        } catch (RuntimeException e) {\n            assertEquals(ex, e);\n        }\n    }\n}", "definition": "public class StringSplitTest", "class_docstring": "", "name": "StringSplitTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    public void testSplitOnEmptyStream() {\n        assertEquals(0, (int) StringObservable.split(Observable.<String> empty(), \"\\n\").count()\n                .toBlocking().single());\n    }", "docstring": " @Test", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testSplitOnEmptyStream", "params": [], "body": "                                         {\n        assertEquals(0, (int) StringObservable.split(Observable.<String> empty(), \"\\n\").count()\n                .toBlocking().single());\n    }", "signature": "public void testSplitOnEmptyStream()"}, {"syntax_pass": true, "original_string": "    public void testSplitOnStreamThatThrowsExceptionImmediately() {\n        RuntimeException ex = new RuntimeException(\"boo\");\n        try {\n            StringObservable.split(Observable.<String> error(ex), \"\\n\").count().toBlocking()\n                    .single();\n            fail();\n        } catch (RuntimeException e) {\n            assertEquals(ex, e);\n        }\n    }", "docstring": " @Test", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testSplitOnStreamThatThrowsExceptionImmediately", "params": [], "body": "                                                                  {\n        RuntimeException ex = new RuntimeException(\"boo\");\n        try {\n            StringObservable.split(Observable.<String> error(ex), \"\\n\").count().toBlocking()\n                    .single();\n            fail();\n        } catch (RuntimeException e) {\n            assertEquals(ex, e);\n        }\n    }", "signature": "public void testSplitOnStreamThatThrowsExceptionImmediately()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/com/github/davidmoten/rtree/OnSubscribeSearchTest.java", "original_string": "package com.github.davidmoten.rtree;\n\nimport java.util.Collections;\n\nimport org.junit.Test;\nimport org.mockito.Mockito;\n\nimport com.github.davidmoten.rtree.OnSubscribeSearch.SearchProducer;\nimport com.github.davidmoten.rtree.geometry.Geometries;\nimport com.github.davidmoten.rtree.geometry.Geometry;\nimport com.github.davidmoten.rtree.geometry.Point;\nimport com.github.davidmoten.rtree.internal.LeafDefault;\n\nimport rx.Subscriber;\nimport rx.functions.Func1;\n\npublic class OnSubscribeSearchTest {\n\n    @SuppressWarnings(\"unchecked\")\n    @Test\n    public void testSearchProducerThrowsExceptionFromRequestAll() {\n        Node<Integer, Geometry> node = Mockito.mock(Node.class);\n        Func1<Geometry, Boolean> condition = Mockito.mock(Func1.class);\n        Subscriber<Entry<Integer, Geometry>> subscriber = Mockito.mock(Subscriber.class);\n        RuntimeException error = new RuntimeException();\n        Mockito.doThrow(error).when(node).searchWithoutBackpressure(condition, subscriber);\n        SearchProducer<Integer, Geometry> p = new OnSubscribeSearch.SearchProducer<Integer, Geometry>(\n                node, condition, subscriber);\n        p.request(Long.MAX_VALUE);\n        Mockito.verify(subscriber).onError(error);\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @Test\n    public void testSearchProducerThrowsExceptionFromRequestSome() {\n        Node<Integer, Point> node = new LeafDefault<Integer, Point>(Collections.singletonList(Entries.entry(\n                1, Geometries.point(1, 1))), null);\n\n        Func1<Geometry, Boolean> condition = Mockito.mock(Func1.class);\n        Subscriber<Entry<Integer, Point>> subscriber = new Subscriber<Entry<Integer, Point>>() {\n\n            @Override\n            public void onCompleted() {\n\n            }\n\n            @Override\n            public void onError(Throwable e) {\n\n            }\n\n            @Override\n            public void onNext(Entry<Integer, Point> t) {\n\n            }\n        };\n        SearchProducer<Integer, Point> p = new OnSubscribeSearch.SearchProducer<Integer, Point>(\n                node, condition, subscriber);\n        p.request(1);\n    }\n\n}\n", "file_hash": "585ccbba32a4287b920e3b5fba6f4349466381ad2ccbd1746a3cfc9e5946edc0", "file_docstring": "", "contexts": ["package com.github.davidmoten.rtree;", "import java.util.Collections;", "import org.junit.Test;", "import org.mockito.Mockito;", "import com.github.davidmoten.rtree.OnSubscribeSearch.SearchProducer;", "import com.github.davidmoten.rtree.geometry.Geometries;", "import com.github.davidmoten.rtree.geometry.Geometry;", "import com.github.davidmoten.rtree.geometry.Point;", "import com.github.davidmoten.rtree.internal.LeafDefault;", "import rx.Subscriber;", "import rx.functions.Func1;"], "methods": [], "classes": [{"original_string": "public class OnSubscribeSearchTest {\n\n    @SuppressWarnings(\"unchecked\")\n    @Test\n    public void testSearchProducerThrowsExceptionFromRequestAll() {\n        Node<Integer, Geometry> node = Mockito.mock(Node.class);\n        Func1<Geometry, Boolean> condition = Mockito.mock(Func1.class);\n        Subscriber<Entry<Integer, Geometry>> subscriber = Mockito.mock(Subscriber.class);\n        RuntimeException error = new RuntimeException();\n        Mockito.doThrow(error).when(node).searchWithoutBackpressure(condition, subscriber);\n        SearchProducer<Integer, Geometry> p = new OnSubscribeSearch.SearchProducer<Integer, Geometry>(\n                node, condition, subscriber);\n        p.request(Long.MAX_VALUE);\n        Mockito.verify(subscriber).onError(error);\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @Test\n    public void testSearchProducerThrowsExceptionFromRequestSome() {\n        Node<Integer, Point> node = new LeafDefault<Integer, Point>(Collections.singletonList(Entries.entry(\n                1, Geometries.point(1, 1))), null);\n\n        Func1<Geometry, Boolean> condition = Mockito.mock(Func1.class);\n        Subscriber<Entry<Integer, Point>> subscriber = new Subscriber<Entry<Integer, Point>>() {\n\n            @Override\n            public void onCompleted() {\n\n            }\n\n            @Override\n            public void onError(Throwable e) {\n\n            }\n\n            @Override\n            public void onNext(Entry<Integer, Point> t) {\n\n            }\n        };\n        SearchProducer<Integer, Point> p = new OnSubscribeSearch.SearchProducer<Integer, Point>(\n                node, condition, subscriber);\n        p.request(1);\n    }\n\n}", "definition": "public class OnSubscribeSearchTest", "class_docstring": "", "name": "OnSubscribeSearchTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @SuppressWarnings(\"unchecked\")\n    @Test\n    public void testSearchProducerThrowsExceptionFromRequestAll() {\n        Node<Integer, Geometry> node = Mockito.mock(Node.class);\n        Func1<Geometry, Boolean> condition = Mockito.mock(Func1.class);\n        Subscriber<Entry<Integer, Geometry>> subscriber = Mockito.mock(Subscriber.class);\n        RuntimeException error = new RuntimeException();\n        Mockito.doThrow(error).when(node).searchWithoutBackpressure(condition, subscriber);\n        SearchProducer<Integer, Geometry> p = new OnSubscribeSearch.SearchProducer<Integer, Geometry>(\n                node, condition, subscriber);\n        p.request(Long.MAX_VALUE);\n        Mockito.verify(subscriber).onError(error);\n    }", "docstring": "", "attributes": {"modifiers": "@SuppressWarnings(\"unchecked\")\n    @Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["@SuppressWarnings(\"unchecked\")", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "testSearchProducerThrowsExceptionFromRequestAll", "params": [], "body": "                                                                  {\n        Node<Integer, Geometry> node = Mockito.mock(Node.class);\n        Func1<Geometry, Boolean> condition = Mockito.mock(Func1.class);\n        Subscriber<Entry<Integer, Geometry>> subscriber = Mockito.mock(Subscriber.class);\n        RuntimeException error = new RuntimeException();\n        Mockito.doThrow(error).when(node).searchWithoutBackpressure(condition, subscriber);\n        SearchProducer<Integer, Geometry> p = new OnSubscribeSearch.SearchProducer<Integer, Geometry>(\n                node, condition, subscriber);\n        p.request(Long.MAX_VALUE);\n        Mockito.verify(subscriber).onError(error);\n    }", "signature": "@SuppressWarnings(\"unchecked\")\n    @Test\n    public void testSearchProducerThrowsExceptionFromRequestAll()"}, {"syntax_pass": true, "original_string": "    @SuppressWarnings(\"unchecked\")\n    @Test\n    public void testSearchProducerThrowsExceptionFromRequestSome() {\n        Node<Integer, Point> node = new LeafDefault<Integer, Point>(Collections.singletonList(Entries.entry(\n                1, Geometries.point(1, 1))), null);\n\n        Func1<Geometry, Boolean> condition = Mockito.mock(Func1.class);\n        Subscriber<Entry<Integer, Point>> subscriber = new Subscriber<Entry<Integer, Point>>() {\n\n            @Override\n            public void onCompleted() {\n\n            }\n\n            @Override\n            public void onError(Throwable e) {\n\n            }\n\n            @Override\n            public void onNext(Entry<Integer, Point> t) {\n\n            }\n        };\n        SearchProducer<Integer, Point> p = new OnSubscribeSearch.SearchProducer<Integer, Point>(\n                node, condition, subscriber);\n        p.request(1);\n    }", "docstring": "", "attributes": {"modifiers": "@SuppressWarnings(\"unchecked\")\n    @Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["@SuppressWarnings(\"unchecked\")", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "testSearchProducerThrowsExceptionFromRequestSome", "params": [], "body": "                                                                   {\n        Node<Integer, Point> node = new LeafDefault<Integer, Point>(Collections.singletonList(Entries.entry(\n                1, Geometries.point(1, 1))), null);\n\n        Func1<Geometry, Boolean> condition = Mockito.mock(Func1.class);\n        Subscriber<Entry<Integer, Point>> subscriber = new Subscriber<Entry<Integer, Point>>() {\n\n            @Override\n            public void onCompleted() {\n\n            }\n\n            @Override\n            public void onError(Throwable e) {\n\n            }\n\n            @Override\n            public void onNext(Entry<Integer, Point> t) {\n\n            }\n        };\n        SearchProducer<Integer, Point> p = new OnSubscribeSearch.SearchProducer<Integer, Point>(\n                node, condition, subscriber);\n        p.request(1);\n    }", "signature": "@SuppressWarnings(\"unchecked\")\n    @Test\n    public void testSearchProducerThrowsExceptionFromRequestSome()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/com/github/davidmoten/rtree/Precision.java", "original_string": "package com.github.davidmoten.rtree;\n\npublic enum Precision {\n\n    DOUBLE, SINGLE;\n\n}\n", "file_hash": "8586bbf05d8420f8bc3ade004997737087542f87df02cb6880998b3e3ff31205", "file_docstring": "", "contexts": ["package com.github.davidmoten.rtree;"], "methods": [], "classes": [], "interfaces": [], "records": []}, {"relative_path": "src/test/java/com/github/davidmoten/rtree/NodePositionTest.java", "original_string": "package com.github.davidmoten.rtree;\n\nimport static org.junit.Assert.assertTrue;\n\nimport org.junit.Test;\nimport org.mockito.Mockito;\n\nimport com.github.davidmoten.rtree.geometry.Rectangle;\n\npublic class NodePositionTest {\n\n    @Test\n    public void testToString() {\n        @SuppressWarnings(\"unchecked\")\n        Node<Object, Rectangle> node = Mockito.mock(Node.class);\n        assertTrue(new NodePosition<Object, Rectangle>(node, 1).toString()\n                .startsWith(\"NodePosition [\"));\n    }\n\n}\n", "file_hash": "9c694ad362e848c6710ee454aafe0dcf480b103b0f03f57b2f6e513cafbd70c6", "file_docstring": "", "contexts": ["package com.github.davidmoten.rtree;", "import static org.junit.Assert.assertTrue;", "import org.junit.Test;", "import org.mockito.Mockito;", "import com.github.davidmoten.rtree.geometry.Rectangle;"], "methods": [], "classes": [{"original_string": "public class NodePositionTest {\n\n    @Test\n    public void testToString() {\n        @SuppressWarnings(\"unchecked\")\n        Node<Object, Rectangle> node = Mockito.mock(Node.class);\n        assertTrue(new NodePosition<Object, Rectangle>(node, 1).toString()\n                .startsWith(\"NodePosition [\"));\n    }\n\n}", "definition": "public class NodePositionTest", "class_docstring": "", "name": "NodePositionTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @Test\n    public void testToString() {\n        @SuppressWarnings(\"unchecked\")\n        Node<Object, Rectangle> node = Mockito.mock(Node.class);\n        assertTrue(new NodePosition<Object, Rectangle>(node, 1).toString()\n                .startsWith(\"NodePosition [\"));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testToString", "params": [], "body": "                               {\n        @SuppressWarnings(\"unchecked\")\n        Node<Object, Rectangle> node = Mockito.mock(Node.class);\n        assertTrue(new NodePosition<Object, Rectangle>(node, 1).toString()\n                .startsWith(\"NodePosition [\"));\n    }", "signature": "@Test\n    public void testToString()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/com/github/davidmoten/rtree/LeafTest.java", "original_string": "package com.github.davidmoten.rtree;\n\nimport static org.junit.Assert.assertEquals;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\n\nimport org.junit.Test;\n\nimport com.github.davidmoten.rtree.geometry.Geometries;\nimport com.github.davidmoten.rtree.geometry.Rectangle;\nimport com.github.davidmoten.rtree.internal.LeafDefault;\n\npublic class LeafTest {\n\n    private static Context<Object, Rectangle> context = new Context<Object, Rectangle>(2, 4,\n            new SelectorMinimalAreaIncrease(), new SplitterQuadratic(),\n            Factories.<Object, Rectangle>defaultFactory());\n\n    @Test(expected = IllegalArgumentException.class)\n    public void testCannotHaveZeroChildren() {\n        new LeafDefault<Object, Rectangle>(new ArrayList<Entry<Object, Rectangle>>(), context);\n    }\n\n    @Test\n    public void testMbr() {\n        Rectangle r1 = Geometries.rectangle(0d, 1, 3, 5);\n        Rectangle r2 = Geometries.rectangle(1d, 2, 4, 6);\n        Rectangle r = new LeafDefault<Object, Rectangle>(\n                Arrays.asList(Entries.entry(new Object(), r1), Entries.entry(new Object(), r2)),\n                context).geometry().mbr();\n        assertEquals(r1.add(r2), r);\n    }\n}\n", "file_hash": "b3396f8f7a0808644c5e275b03786dd7291c7b81427a2bb6d1e4991cf106976c", "file_docstring": "", "contexts": ["package com.github.davidmoten.rtree;", "import static org.junit.Assert.assertEquals;", "import java.util.ArrayList;", "import java.util.Arrays;", "import org.junit.Test;", "import com.github.davidmoten.rtree.geometry.Geometries;", "import com.github.davidmoten.rtree.geometry.Rectangle;", "import com.github.davidmoten.rtree.internal.LeafDefault;"], "methods": [], "classes": [{"original_string": "public class LeafTest {\n\n    private static Context<Object, Rectangle> context = new Context<Object, Rectangle>(2, 4,\n            new SelectorMinimalAreaIncrease(), new SplitterQuadratic(),\n            Factories.<Object, Rectangle>defaultFactory());\n\n    @Test(expected = IllegalArgumentException.class)\n    public void testCannotHaveZeroChildren() {\n        new LeafDefault<Object, Rectangle>(new ArrayList<Entry<Object, Rectangle>>(), context);\n    }\n\n    @Test\n    public void testMbr() {\n        Rectangle r1 = Geometries.rectangle(0d, 1, 3, 5);\n        Rectangle r2 = Geometries.rectangle(1d, 2, 4, 6);\n        Rectangle r = new LeafDefault<Object, Rectangle>(\n                Arrays.asList(Entries.entry(new Object(), r1), Entries.entry(new Object(), r2)),\n                context).geometry().mbr();\n        assertEquals(r1.add(r2), r);\n    }\n}", "definition": "public class LeafTest", "class_docstring": "", "name": "LeafTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private static Context<Object, Rectangle> context = new Context<Object, Rectangle>(2, 4,\n            new SelectorMinimalAreaIncrease(), new SplitterQuadratic(),\n            Factories.<Object, Rectangle>defaultFactory());", "docstring": "", "modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "type": "Context<Object, Rectangle>", "name": "context = new Context<Object, Rectangle>(2, 4,\n            new SelectorMinimalAreaIncrease(), new SplitterQuadratic(),\n            Factories.<Object, Rectangle>defaultFactory())", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @Test(expected = IllegalArgumentException.class)\n    public void testCannotHaveZeroChildren() {\n        new LeafDefault<Object, Rectangle>(new ArrayList<Entry<Object, Rectangle>>(), context);\n    }", "docstring": "", "attributes": {"modifiers": "@Test(expected = IllegalArgumentException.class)\n    public", "marker_annotations": [], "non_marker_annotations": ["@Test(expected = IllegalArgumentException.class)", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "testCannotHaveZeroChildren", "params": [], "body": "                                             {\n        new LeafDefault<Object, Rectangle>(new ArrayList<Entry<Object, Rectangle>>(), context);\n    }", "signature": "@Test(expected = IllegalArgumentException.class)\n    public void testCannotHaveZeroChildren()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testMbr() {\n        Rectangle r1 = Geometries.rectangle(0d, 1, 3, 5);\n        Rectangle r2 = Geometries.rectangle(1d, 2, 4, 6);\n        Rectangle r = new LeafDefault<Object, Rectangle>(\n                Arrays.asList(Entries.entry(new Object(), r1), Entries.entry(new Object(), r2)),\n                context).geometry().mbr();\n        assertEquals(r1.add(r2), r);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testMbr", "params": [], "body": "                          {\n        Rectangle r1 = Geometries.rectangle(0d, 1, 3, 5);\n        Rectangle r2 = Geometries.rectangle(1d, 2, 4, 6);\n        Rectangle r = new LeafDefault<Object, Rectangle>(\n                Arrays.asList(Entries.entry(new Object(), r1), Entries.entry(new Object(), r2)),\n                context).geometry().mbr();\n        assertEquals(r1.add(r2), r);\n    }", "signature": "@Test\n    public void testMbr()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/com/github/davidmoten/rtree/NonLeafTest.java", "original_string": "package com.github.davidmoten.rtree;\n\nimport java.util.Collections;\n\nimport org.junit.Test;\n\nimport com.github.davidmoten.rtree.geometry.Geometry;\nimport com.github.davidmoten.rtree.internal.NonLeafDefault;\n\npublic class NonLeafTest {\n\n    @Test(expected=IllegalArgumentException.class)\n    public void testNonLeafPrecondition() {\n        new NonLeafDefault<Object,Geometry>(Collections.<Node<Object,Geometry>>emptyList(), null);\n    }\n    \n}\n", "file_hash": "fd2a99397c4d2bc8f95d1e13ad3b885f601463099c769c65ffeacd1cff491977", "file_docstring": "", "contexts": ["package com.github.davidmoten.rtree;", "import java.util.Collections;", "import org.junit.Test;", "import com.github.davidmoten.rtree.geometry.Geometry;", "import com.github.davidmoten.rtree.internal.NonLeafDefault;"], "methods": [], "classes": [{"original_string": "public class NonLeafTest {\n\n    @Test(expected=IllegalArgumentException.class)\n    public void testNonLeafPrecondition() {\n        new NonLeafDefault<Object,Geometry>(Collections.<Node<Object,Geometry>>emptyList(), null);\n    }\n    \n}", "definition": "public class NonLeafTest", "class_docstring": "", "name": "NonLeafTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @Test(expected=IllegalArgumentException.class)\n    public void testNonLeafPrecondition() {\n        new NonLeafDefault<Object,Geometry>(Collections.<Node<Object,Geometry>>emptyList(), null);\n    }", "docstring": "", "attributes": {"modifiers": "@Test(expected=IllegalArgumentException.class)\n    public", "marker_annotations": [], "non_marker_annotations": ["@Test(expected=IllegalArgumentException.class)", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "testNonLeafPrecondition", "params": [], "body": "                                          {\n        new NonLeafDefault<Object,Geometry>(Collections.<Node<Object,Geometry>>emptyList(), null);\n    }", "signature": "@Test(expected=IllegalArgumentException.class)\n    public void testNonLeafPrecondition()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/com/github/davidmoten/rtree/EntriesTest.java", "original_string": "package com.github.davidmoten.rtree;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertFalse;\nimport static org.junit.Assert.assertNotEquals;\n\nimport org.junit.Test;\n\nimport com.github.davidmoten.junit.Asserts;\nimport com.github.davidmoten.rtree.geometry.Geometries;\n\npublic class EntriesTest {\n\n    @Test\n    public void testValue() {\n        assertEquals(1, (int) Entries.entry(1, Geometries.point(0, 0)).value());\n    }\n\n    @Test\n    public void testEquality() {\n        assertEquals(Entries.entry(1, Geometries.point(0, 0)), Entries.entry(1, Geometries.point(0, 0)));\n    }\n\n    @Test\n    public void testEqualityWithGeometry() {\n        assertNotEquals(Entries.entry(1, Geometries.point(0, 0)),\n                Entries.entry(1, Geometries.point(0, 1)));\n    }\n\n    @Test\n    public void testInequality() {\n        assertNotEquals(Entries.entry(1, Geometries.point(0, 0)),\n                Entries.entry(2, Geometries.point(0, 0)));\n    }\n\n    @Test\n    public void testInequalityWithNull() {\n        assertFalse(Entries.entry(1, Geometries.point(0, 0)).equals(null));\n    }\n    \n    @Test\n    public void testIsUtilityClass() {\n        Asserts.assertIsUtilityClass(Entries.class);\n    }\n\n}\n", "file_hash": "31f09b2c21b26586bfa2d3558378d76c983f89767a9e25d98f4366252926570e", "file_docstring": "", "contexts": ["package com.github.davidmoten.rtree;", "import static org.junit.Assert.assertEquals;", "import static org.junit.Assert.assertFalse;", "import static org.junit.Assert.assertNotEquals;", "import org.junit.Test;", "import com.github.davidmoten.junit.Asserts;", "import com.github.davidmoten.rtree.geometry.Geometries;"], "methods": [], "classes": [{"original_string": "public class EntriesTest {\n\n    @Test\n    public void testValue() {\n        assertEquals(1, (int) Entries.entry(1, Geometries.point(0, 0)).value());\n    }\n\n    @Test\n    public void testEquality() {\n        assertEquals(Entries.entry(1, Geometries.point(0, 0)), Entries.entry(1, Geometries.point(0, 0)));\n    }\n\n    @Test\n    public void testEqualityWithGeometry() {\n        assertNotEquals(Entries.entry(1, Geometries.point(0, 0)),\n                Entries.entry(1, Geometries.point(0, 1)));\n    }\n\n    @Test\n    public void testInequality() {\n        assertNotEquals(Entries.entry(1, Geometries.point(0, 0)),\n                Entries.entry(2, Geometries.point(0, 0)));\n    }\n\n    @Test\n    public void testInequalityWithNull() {\n        assertFalse(Entries.entry(1, Geometries.point(0, 0)).equals(null));\n    }\n    \n    @Test\n    public void testIsUtilityClass() {\n        Asserts.assertIsUtilityClass(Entries.class);\n    }\n\n}", "definition": "public class EntriesTest", "class_docstring": "", "name": "EntriesTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @Test\n    public void testValue() {\n        assertEquals(1, (int) Entries.entry(1, Geometries.point(0, 0)).value());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testValue", "params": [], "body": "                            {\n        assertEquals(1, (int) Entries.entry(1, Geometries.point(0, 0)).value());\n    }", "signature": "@Test\n    public void testValue()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testEquality() {\n        assertEquals(Entries.entry(1, Geometries.point(0, 0)), Entries.entry(1, Geometries.point(0, 0)));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testEquality", "params": [], "body": "                               {\n        assertEquals(Entries.entry(1, Geometries.point(0, 0)), Entries.entry(1, Geometries.point(0, 0)));\n    }", "signature": "@Test\n    public void testEquality()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testEqualityWithGeometry() {\n        assertNotEquals(Entries.entry(1, Geometries.point(0, 0)),\n                Entries.entry(1, Geometries.point(0, 1)));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testEqualityWithGeometry", "params": [], "body": "                                           {\n        assertNotEquals(Entries.entry(1, Geometries.point(0, 0)),\n                Entries.entry(1, Geometries.point(0, 1)));\n    }", "signature": "@Test\n    public void testEqualityWithGeometry()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testInequality() {\n        assertNotEquals(Entries.entry(1, Geometries.point(0, 0)),\n                Entries.entry(2, Geometries.point(0, 0)));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testInequality", "params": [], "body": "                                 {\n        assertNotEquals(Entries.entry(1, Geometries.point(0, 0)),\n                Entries.entry(2, Geometries.point(0, 0)));\n    }", "signature": "@Test\n    public void testInequality()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testInequalityWithNull() {\n        assertFalse(Entries.entry(1, Geometries.point(0, 0)).equals(null));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testInequalityWithNull", "params": [], "body": "                                         {\n        assertFalse(Entries.entry(1, Geometries.point(0, 0)).equals(null));\n    }", "signature": "@Test\n    public void testInequalityWithNull()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testIsUtilityClass() {\n        Asserts.assertIsUtilityClass(Entries.class);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testIsUtilityClass", "params": [], "body": "                                     {\n        Asserts.assertIsUtilityClass(Entries.class);\n    }", "signature": "@Test\n    public void testIsUtilityClass()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/com/github/davidmoten/rtree/NodePosition_toStringTest.java", "original_string": "\npackage com.github.davidmoten.rtree;\n\nimport com.github.davidmoten.rtree.geometry.Geometry;\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\nimport static org.mockito.Mockito.mock;\nimport static org.mockito.Mockito.when;\n\npublic class NodePosition_toStringTest {\n\n    @Test\n    public void testToString() {\n        Node<String, Geometry> mockNode = mock(Node.class);\n        when(mockNode.toString()).thenReturn(\"MockNode\");\n\n        NodePosition<String, Geometry> nodePosition = new NodePosition<>(mockNode, 42);\n        String expected = \"NodePosition [node=MockNode, position=42]\";\n        assertEquals(expected, nodePosition.toString());\n    }\n}\n", "file_hash": "c9221ba4f484218741967091331e55d9647d474c4b629acf1337899a353ae35d", "file_docstring": "", "contexts": ["package com.github.davidmoten.rtree;", "import com.github.davidmoten.rtree.geometry.Geometry;", "import org.junit.Test;", "import static org.junit.Assert.assertEquals;", "import static org.mockito.Mockito.mock;", "import static org.mockito.Mockito.when;"], "methods": [], "classes": [{"original_string": "public class NodePosition_toStringTest {\n\n    @Test\n    public void testToString() {\n        Node<String, Geometry> mockNode = mock(Node.class);\n        when(mockNode.toString()).thenReturn(\"MockNode\");\n\n        NodePosition<String, Geometry> nodePosition = new NodePosition<>(mockNode, 42);\n        String expected = \"NodePosition [node=MockNode, position=42]\";\n        assertEquals(expected, nodePosition.toString());\n    }\n}", "definition": "public class NodePosition_toStringTest", "class_docstring": "", "name": "NodePosition_toStringTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @Test\n    public void testToString() {\n        Node<String, Geometry> mockNode = mock(Node.class);\n        when(mockNode.toString()).thenReturn(\"MockNode\");\n\n        NodePosition<String, Geometry> nodePosition = new NodePosition<>(mockNode, 42);\n        String expected = \"NodePosition [node=MockNode, position=42]\";\n        assertEquals(expected, nodePosition.toString());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testToString", "params": [], "body": "                               {\n        Node<String, Geometry> mockNode = mock(Node.class);\n        when(mockNode.toString()).thenReturn(\"MockNode\");\n\n        NodePosition<String, Geometry> nodePosition = new NodePosition<>(mockNode, 42);\n        String expected = \"NodePosition [node=MockNode, position=42]\";\n        assertEquals(expected, nodePosition.toString());\n    }", "signature": "@Test\n    public void testToString()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/com/github/davidmoten/rtree/SerializerHelperTest.java", "original_string": "package com.github.davidmoten.rtree;\n\nimport org.junit.Test;\n\nimport com.github.davidmoten.junit.Asserts;\n\npublic class SerializerHelperTest {\n    \n    @Test\n    public void assertIsUtilityClass() {\n        Asserts.assertIsUtilityClass(SerializerHelper.class);\n    }\n\n}\n", "file_hash": "a20178ded0ed82688387fc20e4661cacfc3f9a58ef075ee8564469081d01576d", "file_docstring": "", "contexts": ["package com.github.davidmoten.rtree;", "import org.junit.Test;", "import com.github.davidmoten.junit.Asserts;"], "methods": [], "classes": [{"original_string": "public class SerializerHelperTest {\n    \n    @Test\n    public void assertIsUtilityClass() {\n        Asserts.assertIsUtilityClass(SerializerHelper.class);\n    }\n\n}", "definition": "public class SerializerHelperTest", "class_docstring": "", "name": "SerializerHelperTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @Test\n    public void assertIsUtilityClass() {\n        Asserts.assertIsUtilityClass(SerializerHelper.class);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "assertIsUtilityClass", "params": [], "body": "                                       {\n        Asserts.assertIsUtilityClass(SerializerHelper.class);\n    }", "signature": "@Test\n    public void assertIsUtilityClass()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/com/github/davidmoten/rtree/fbs/SerializerFlatBuffersTest.java", "original_string": "package com.github.davidmoten.rtree.fbs;\n\nimport static org.junit.Assert.assertEquals;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\n\nimport org.junit.Test;\n\nimport com.github.davidmoten.rtree.Entry;\nimport com.github.davidmoten.rtree.GreekEarthquakes;\nimport com.github.davidmoten.rtree.InternalStructure;\nimport com.github.davidmoten.rtree.Precision;\nimport com.github.davidmoten.rtree.RTree;\nimport com.github.davidmoten.rtree.Serializer;\nimport com.github.davidmoten.rtree.geometry.Geometries;\nimport com.github.davidmoten.rtree.geometry.Point;\n\nimport rx.Observable;\nimport rx.functions.Func1;\n\npublic class SerializerFlatBuffersTest {\n\n    private static final byte[] EMPTY = new byte[] {};\n\n    @Test\n    public void testSerializeRoundTripToFlatBuffersSingleArray() throws Exception {\n        roundTrip(InternalStructure.SINGLE_ARRAY, false);\n    }\n\n    @Test\n    public void testSerializeRoundTripToDefaultStructure() throws Exception {\n        roundTrip(InternalStructure.DEFAULT, false);\n    }\n\n    @Test\n    public void testSerializeRoundTripToFlatBuffersSingleArrayBackpressure() throws Exception {\n        roundTrip(InternalStructure.SINGLE_ARRAY, true);\n    }\n\n    @Test\n    public void testSerializeRoundTripToDefaultStructureBackpressure() throws Exception {\n        roundTrip(InternalStructure.DEFAULT, true);\n    }\n\n    private void roundTrip(InternalStructure structure, boolean backpressure) throws Exception {\n        RTree<Object, Point> tree = RTree.star().maxChildren(10).create();\n        tree = tree.add(GreekEarthquakes.entries(Precision.SINGLE)).last().toBlocking().single();\n        long t = System.currentTimeMillis();\n        File file = new File(\"target/file\");\n        FileOutputStream os = new FileOutputStream(file);\n        Serializer<Object, Point> fbSerializer = createSerializer();\n\n        serialize(tree, t, file, os, fbSerializer);\n\n        deserialize(structure, file, fbSerializer, backpressure);\n    }\n\n    private static Serializer<Object, Point> createSerializer() {\n        Func1<Object, byte[]> serializer = new Func1<Object, byte[]>() {\n            @Override\n            public byte[] call(Object o) {\n                return EMPTY;\n            }\n        };\n        Func1<byte[], Object> deserializer = new Func1<byte[], Object>() {\n            @Override\n            public Object call(byte[] bytes) {\n                return null;\n            }\n        };\n        Serializer<Object, Point> fbSerializer = SerializerFlatBuffers.create(serializer,\n                deserializer);\n        return fbSerializer;\n    }\n\n    private static void serialize(RTree<Object, Point> tree, long t, File file, FileOutputStream os,\n            Serializer<Object, Point> fbSerializer) throws IOException {\n        fbSerializer.write(tree, os);\n        os.close();\n        System.out.println(\"written in \" + (System.currentTimeMillis() - t) + \"ms, \" + \"file size=\"\n                + file.length() / 1000000.0 + \"MB\");\n        System.out.println(\"bytes per entry=\" + file.length() / tree.size());\n    }\n\n    private static void deserialize(InternalStructure structure, File file,\n            Serializer<Object, Point> fbSerializer, boolean backpressure) throws Exception {\n        long t = System.currentTimeMillis();\n        InputStream is = new FileInputStream(file);\n        t = System.currentTimeMillis();\n        RTree<Object, Point> tr = fbSerializer.read(is, file.length(), structure);\n        System.out.println(tr.root().get());\n\n        System.out.println(\"read in \" + (System.currentTimeMillis() - t) + \"ms\");\n        Observable<Entry<Object, Point>> o = tr.search(Geometries.rectangle(40, 27.0, 40.5, 27.5));\n        if (backpressure)\n            o = o.take(10000);\n        int found = o.count().toBlocking().single();\n        System.out.println(\"found=\" + found);\n        assertEquals(22, found);\n        System.out.println(tr.size());\n    }\n\n    @Test(expected = RuntimeException.class)\n    public void testInputStreamNotAsLongAsExpected() throws IOException {\n        SerializerFlatBuffers.readFully(new ByteArrayInputStream(new byte[10]), 12);\n    }\n\n    @Test\n    public void testInputStreamReturnsArrayInSmallChunks() throws IOException {\n        InputStream is = new InputStream() {\n\n            int i = 0;\n\n            @Override\n            public int read() throws IOException {\n                i += 1;\n                if (i == 1) {\n                    return 1;\n                } else if (i == 2) {\n                    throw new IOException();\n                } else {\n                    return 1;\n                }\n            }\n\n        };\n        byte[] b = SerializerFlatBuffers.readFully(is, 2);\n        assertEquals(2, b.length);\n        assertEquals(1, b[0]);\n        assertEquals(1, b[0]);\n    }\n\n    public static void main(String[] args) throws Exception {\n        // use this with jvisualvm and heap dump, find biggest objects to check\n        // memory usage of rtree\n        // deserialize(InternalStructure.FLATBUFFERS_SINGLE_ARRAY, new\n        // File(\"target/file\"),\n        // createSerializer());\n    }\n\n}\n", "file_hash": "5f994e899c10be66fb27e475485e57a649add5b6a432910515a078fced84bd42", "file_docstring": "", "contexts": ["package com.github.davidmoten.rtree.fbs;", "import static org.junit.Assert.assertEquals;", "import java.io.ByteArrayInputStream;", "import java.io.File;", "import java.io.FileInputStream;", "import java.io.FileOutputStream;", "import java.io.IOException;", "import java.io.InputStream;", "import org.junit.Test;", "import com.github.davidmoten.rtree.Entry;", "import com.github.davidmoten.rtree.GreekEarthquakes;", "import com.github.davidmoten.rtree.InternalStructure;", "import com.github.davidmoten.rtree.Precision;", "import com.github.davidmoten.rtree.RTree;", "import com.github.davidmoten.rtree.Serializer;", "import com.github.davidmoten.rtree.geometry.Geometries;", "import com.github.davidmoten.rtree.geometry.Point;", "import rx.Observable;", "import rx.functions.Func1;"], "methods": [], "classes": [{"original_string": "public class SerializerFlatBuffersTest {\n\n    private static final byte[] EMPTY = new byte[] {};\n\n    @Test\n    public void testSerializeRoundTripToFlatBuffersSingleArray() throws Exception {\n        roundTrip(InternalStructure.SINGLE_ARRAY, false);\n    }\n\n    @Test\n    public void testSerializeRoundTripToDefaultStructure() throws Exception {\n        roundTrip(InternalStructure.DEFAULT, false);\n    }\n\n    @Test\n    public void testSerializeRoundTripToFlatBuffersSingleArrayBackpressure() throws Exception {\n        roundTrip(InternalStructure.SINGLE_ARRAY, true);\n    }\n\n    @Test\n    public void testSerializeRoundTripToDefaultStructureBackpressure() throws Exception {\n        roundTrip(InternalStructure.DEFAULT, true);\n    }\n\n    private void roundTrip(InternalStructure structure, boolean backpressure) throws Exception {\n        RTree<Object, Point> tree = RTree.star().maxChildren(10).create();\n        tree = tree.add(GreekEarthquakes.entries(Precision.SINGLE)).last().toBlocking().single();\n        long t = System.currentTimeMillis();\n        File file = new File(\"target/file\");\n        FileOutputStream os = new FileOutputStream(file);\n        Serializer<Object, Point> fbSerializer = createSerializer();\n\n        serialize(tree, t, file, os, fbSerializer);\n\n        deserialize(structure, file, fbSerializer, backpressure);\n    }\n\n    private static Serializer<Object, Point> createSerializer() {\n        Func1<Object, byte[]> serializer = new Func1<Object, byte[]>() {\n            @Override\n            public byte[] call(Object o) {\n                return EMPTY;\n            }\n        };\n        Func1<byte[], Object> deserializer = new Func1<byte[], Object>() {\n            @Override\n            public Object call(byte[] bytes) {\n                return null;\n            }\n        };\n        Serializer<Object, Point> fbSerializer = SerializerFlatBuffers.create(serializer,\n                deserializer);\n        return fbSerializer;\n    }\n\n    private static void serialize(RTree<Object, Point> tree, long t, File file, FileOutputStream os,\n            Serializer<Object, Point> fbSerializer) throws IOException {\n        fbSerializer.write(tree, os);\n        os.close();\n        System.out.println(\"written in \" + (System.currentTimeMillis() - t) + \"ms, \" + \"file size=\"\n                + file.length() / 1000000.0 + \"MB\");\n        System.out.println(\"bytes per entry=\" + file.length() / tree.size());\n    }\n\n    private static void deserialize(InternalStructure structure, File file,\n            Serializer<Object, Point> fbSerializer, boolean backpressure) throws Exception {\n        long t = System.currentTimeMillis();\n        InputStream is = new FileInputStream(file);\n        t = System.currentTimeMillis();\n        RTree<Object, Point> tr = fbSerializer.read(is, file.length(), structure);\n        System.out.println(tr.root().get());\n\n        System.out.println(\"read in \" + (System.currentTimeMillis() - t) + \"ms\");\n        Observable<Entry<Object, Point>> o = tr.search(Geometries.rectangle(40, 27.0, 40.5, 27.5));\n        if (backpressure)\n            o = o.take(10000);\n        int found = o.count().toBlocking().single();\n        System.out.println(\"found=\" + found);\n        assertEquals(22, found);\n        System.out.println(tr.size());\n    }\n\n    @Test(expected = RuntimeException.class)\n    public void testInputStreamNotAsLongAsExpected() throws IOException {\n        SerializerFlatBuffers.readFully(new ByteArrayInputStream(new byte[10]), 12);\n    }\n\n    @Test\n    public void testInputStreamReturnsArrayInSmallChunks() throws IOException {\n        InputStream is = new InputStream() {\n\n            int i = 0;\n\n            @Override\n            public int read() throws IOException {\n                i += 1;\n                if (i == 1) {\n                    return 1;\n                } else if (i == 2) {\n                    throw new IOException();\n                } else {\n                    return 1;\n                }\n            }\n\n        };\n        byte[] b = SerializerFlatBuffers.readFully(is, 2);\n        assertEquals(2, b.length);\n        assertEquals(1, b[0]);\n        assertEquals(1, b[0]);\n    }\n\n    public static void main(String[] args) throws Exception {\n        // use this with jvisualvm and heap dump, find biggest objects to check\n        // memory usage of rtree\n        // deserialize(InternalStructure.FLATBUFFERS_SINGLE_ARRAY, new\n        // File(\"target/file\"),\n        // createSerializer());\n    }\n\n}", "definition": "public class SerializerFlatBuffersTest", "class_docstring": "", "name": "SerializerFlatBuffersTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private static final byte[] EMPTY = new byte[] {};", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "byte[]", "name": "EMPTY = new byte[] {}", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @Test\n    public void testSerializeRoundTripToFlatBuffersSingleArray() throws Exception {\n        roundTrip(InternalStructure.SINGLE_ARRAY, false);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testSerializeRoundTripToFlatBuffersSingleArray", "params": [], "body": "                                                                                  {\n        roundTrip(InternalStructure.SINGLE_ARRAY, false);\n    }", "signature": "@Test\n    public void testSerializeRoundTripToFlatBuffersSingleArray()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testSerializeRoundTripToDefaultStructure() throws Exception {\n        roundTrip(InternalStructure.DEFAULT, false);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testSerializeRoundTripToDefaultStructure", "params": [], "body": "                                                                            {\n        roundTrip(InternalStructure.DEFAULT, false);\n    }", "signature": "@Test\n    public void testSerializeRoundTripToDefaultStructure()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testSerializeRoundTripToFlatBuffersSingleArrayBackpressure() throws Exception {\n        roundTrip(InternalStructure.SINGLE_ARRAY, true);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testSerializeRoundTripToFlatBuffersSingleArrayBackpressure", "params": [], "body": "                                                                                              {\n        roundTrip(InternalStructure.SINGLE_ARRAY, true);\n    }", "signature": "@Test\n    public void testSerializeRoundTripToFlatBuffersSingleArrayBackpressure()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testSerializeRoundTripToDefaultStructureBackpressure() throws Exception {\n        roundTrip(InternalStructure.DEFAULT, true);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testSerializeRoundTripToDefaultStructureBackpressure", "params": [], "body": "                                                                                        {\n        roundTrip(InternalStructure.DEFAULT, true);\n    }", "signature": "@Test\n    public void testSerializeRoundTripToDefaultStructureBackpressure()"}, {"syntax_pass": true, "original_string": "    private void roundTrip(InternalStructure structure, boolean backpressure) throws Exception {\n        RTree<Object, Point> tree = RTree.star().maxChildren(10).create();\n        tree = tree.add(GreekEarthquakes.entries(Precision.SINGLE)).last().toBlocking().single();\n        long t = System.currentTimeMillis();\n        File file = new File(\"target/file\");\n        FileOutputStream os = new FileOutputStream(file);\n        Serializer<Object, Point> fbSerializer = createSerializer();\n\n        serialize(tree, t, file, os, fbSerializer);\n\n        deserialize(structure, file, fbSerializer, backpressure);\n    }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "name": "roundTrip", "params": [{"name": "structure", "type": "InternalStructure"}, {"name": "backpressure", "type": "boolean"}], "body": "                                                                                               {\n        RTree<Object, Point> tree = RTree.star().maxChildren(10).create();\n        tree = tree.add(GreekEarthquakes.entries(Precision.SINGLE)).last().toBlocking().single();\n        long t = System.currentTimeMillis();\n        File file = new File(\"target/file\");\n        FileOutputStream os = new FileOutputStream(file);\n        Serializer<Object, Point> fbSerializer = createSerializer();\n\n        serialize(tree, t, file, os, fbSerializer);\n\n        deserialize(structure, file, fbSerializer, backpressure);\n    }", "signature": "private void roundTrip(InternalStructure structure, boolean backpressure)"}, {"syntax_pass": true, "original_string": "    private static Serializer<Object, Point> createSerializer() {\n        Func1<Object, byte[]> serializer = new Func1<Object, byte[]>() {\n            @Override\n            public byte[] call(Object o) {\n                return EMPTY;\n            }\n        };\n        Func1<byte[], Object> deserializer = new Func1<byte[], Object>() {\n            @Override\n            public Object call(byte[] bytes) {\n                return null;\n            }\n        };\n        Serializer<Object, Point> fbSerializer = SerializerFlatBuffers.create(serializer,\n                deserializer);\n        return fbSerializer;\n    }", "docstring": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "Serializer<Object, Point>", "classes": []}, "name": "createSerializer", "params": [], "body": "                                                                {\n        Func1<Object, byte[]> serializer = new Func1<Object, byte[]>() {\n            @Override\n            public byte[] call(Object o) {\n                return EMPTY;\n            }\n        };\n        Func1<byte[], Object> deserializer = new Func1<byte[], Object>() {\n            @Override\n            public Object call(byte[] bytes) {\n                return null;\n            }\n        };\n        Serializer<Object, Point> fbSerializer = SerializerFlatBuffers.create(serializer,\n                deserializer);\n        return fbSerializer;\n    }", "signature": "private static Serializer<Object, Point> createSerializer()"}, {"syntax_pass": true, "original_string": "    private static void serialize(RTree<Object, Point> tree, long t, File file, FileOutputStream os,\n            Serializer<Object, Point> fbSerializer) throws IOException {\n        fbSerializer.write(tree, os);\n        os.close();\n        System.out.println(\"written in \" + (System.currentTimeMillis() - t) + \"ms, \" + \"file size=\"\n                + file.length() / 1000000.0 + \"MB\");\n        System.out.println(\"bytes per entry=\" + file.length() / tree.size());\n    }", "docstring": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "void", "classes": []}, "name": "serialize", "params": [{"name": "tree", "type": "RTree<Object, Point>"}, {"name": "t", "type": "long"}, {"name": "file", "type": "File"}, {"name": "os", "type": "FileOutputStream"}, {"name": "fbSerializer", "type": "Serializer<Object, Point>"}], "body": "                                                                       {\n        fbSerializer.write(tree, os);\n        os.close();\n        System.out.println(\"written in \" + (System.currentTimeMillis() - t) + \"ms, \" + \"file size=\"\n                + file.length() / 1000000.0 + \"MB\");\n        System.out.println(\"bytes per entry=\" + file.length() / tree.size());\n    }", "signature": "private static void serialize(RTree<Object, Point> tree, long t, File file, FileOutputStream os,\n            Serializer<Object, Point> fbSerializer)"}, {"syntax_pass": true, "original_string": "    private static void deserialize(InternalStructure structure, File file,\n            Serializer<Object, Point> fbSerializer, boolean backpressure) throws Exception {\n        long t = System.currentTimeMillis();\n        InputStream is = new FileInputStream(file);\n        t = System.currentTimeMillis();\n        RTree<Object, Point> tr = fbSerializer.read(is, file.length(), structure);\n        System.out.println(tr.root().get());\n\n        System.out.println(\"read in \" + (System.currentTimeMillis() - t) + \"ms\");\n        Observable<Entry<Object, Point>> o = tr.search(Geometries.rectangle(40, 27.0, 40.5, 27.5));\n        if (backpressure)\n            o = o.take(10000);\n        int found = o.count().toBlocking().single();\n        System.out.println(\"found=\" + found);\n        assertEquals(22, found);\n        System.out.println(tr.size());\n    }", "docstring": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "void", "classes": []}, "name": "deserialize", "params": [{"name": "structure", "type": "InternalStructure"}, {"name": "file", "type": "File"}, {"name": "fbSerializer", "type": "Serializer<Object, Point>"}, {"name": "backpressure", "type": "boolean"}], "body": "                                                                                           {\n        long t = System.currentTimeMillis();\n        InputStream is = new FileInputStream(file);\n        t = System.currentTimeMillis();\n        RTree<Object, Point> tr = fbSerializer.read(is, file.length(), structure);\n        System.out.println(tr.root().get());\n\n        System.out.println(\"read in \" + (System.currentTimeMillis() - t) + \"ms\");\n        Observable<Entry<Object, Point>> o = tr.search(Geometries.rectangle(40, 27.0, 40.5, 27.5));\n        if (backpressure)\n            o = o.take(10000);\n        int found = o.count().toBlocking().single();\n        System.out.println(\"found=\" + found);\n        assertEquals(22, found);\n        System.out.println(tr.size());\n    }", "signature": "private static void deserialize(InternalStructure structure, File file,\n            Serializer<Object, Point> fbSerializer, boolean backpressure)"}, {"syntax_pass": true, "original_string": "    @Test(expected = RuntimeException.class)\n    public void testInputStreamNotAsLongAsExpected() throws IOException {\n        SerializerFlatBuffers.readFully(new ByteArrayInputStream(new byte[10]), 12);\n    }", "docstring": "", "attributes": {"modifiers": "@Test(expected = RuntimeException.class)\n    public", "marker_annotations": [], "non_marker_annotations": ["@Test(expected = RuntimeException.class)", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "testInputStreamNotAsLongAsExpected", "params": [], "body": "                                                                        {\n        SerializerFlatBuffers.readFully(new ByteArrayInputStream(new byte[10]), 12);\n    }", "signature": "@Test(expected = RuntimeException.class)\n    public void testInputStreamNotAsLongAsExpected()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testInputStreamReturnsArrayInSmallChunks() throws IOException {\n        InputStream is = new InputStream() {\n\n            int i = 0;\n\n            @Override\n            public int read() throws IOException {\n                i += 1;\n                if (i == 1) {\n                    return 1;\n                } else if (i == 2) {\n                    throw new IOException();\n                } else {\n                    return 1;\n                }\n            }\n\n        };\n        byte[] b = SerializerFlatBuffers.readFully(is, 2);\n        assertEquals(2, b.length);\n        assertEquals(1, b[0]);\n        assertEquals(1, b[0]);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testInputStreamReturnsArrayInSmallChunks", "params": [], "body": "                                                                              {\n        InputStream is = new InputStream() {\n\n            int i = 0;\n\n            @Override\n            public int read() throws IOException {\n                i += 1;\n                if (i == 1) {\n                    return 1;\n                } else if (i == 2) {\n                    throw new IOException();\n                } else {\n                    return 1;\n                }\n            }\n\n        };\n        byte[] b = SerializerFlatBuffers.readFully(is, 2);\n        assertEquals(2, b.length);\n        assertEquals(1, b[0]);\n        assertEquals(1, b[0]);\n    }", "signature": "@Test\n    public void testInputStreamReturnsArrayInSmallChunks()"}, {"syntax_pass": true, "original_string": "    public static void main(String[] args) throws Exception {\n        // use this with jvisualvm and heap dump, find biggest objects to check\n        // memory usage of rtree\n        // deserialize(InternalStructure.FLATBUFFERS_SINGLE_ARRAY, new\n        // File(\"target/file\"),\n        // createSerializer());\n    }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "void", "classes": []}, "name": "main", "params": [{"name": "args", "type": "String[]"}], "body": "                                                            {\n        // use this with jvisualvm and heap dump, find biggest objects to check\n        // memory usage of rtree\n        // deserialize(InternalStructure.FLATBUFFERS_SINGLE_ARRAY, new\n        // File(\"target/file\"),\n        // createSerializer());\n    }", "signature": "public static void main(String[] args)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/com/github/davidmoten/rtree/fbs/FlatBuffersHelperTest.java", "original_string": "package com.github.davidmoten.rtree.fbs;\n\nimport org.junit.Test;\n\nimport com.github.davidmoten.junit.Asserts;\n\npublic class FlatBuffersHelperTest {\n\n    @Test\n    public void isUtilityClass() {\n        Asserts.assertIsUtilityClass(FlatBuffersHelper.class);\n    }\n\n}\n", "file_hash": "71f1e8cc406acec9c3edd5aa3ca33e88fae4d05cc8bfee2f586ec6512cab6709", "file_docstring": "", "contexts": ["package com.github.davidmoten.rtree.fbs;", "import org.junit.Test;", "import com.github.davidmoten.junit.Asserts;"], "methods": [], "classes": [{"original_string": "public class FlatBuffersHelperTest {\n\n    @Test\n    public void isUtilityClass() {\n        Asserts.assertIsUtilityClass(FlatBuffersHelper.class);\n    }\n\n}", "definition": "public class FlatBuffersHelperTest", "class_docstring": "", "name": "FlatBuffersHelperTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @Test\n    public void isUtilityClass() {\n        Asserts.assertIsUtilityClass(FlatBuffersHelper.class);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "isUtilityClass", "params": [], "body": "                                 {\n        Asserts.assertIsUtilityClass(FlatBuffersHelper.class);\n    }", "signature": "@Test\n    public void isUtilityClass()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/com/github/davidmoten/rtree/geometry/IntersectsTest.java", "original_string": "package com.github.davidmoten.rtree.geometry;\n\nimport static com.github.davidmoten.rtree.geometry.Geometries.circle;\nimport static com.github.davidmoten.rtree.geometry.Geometries.rectangle;\nimport static org.junit.Assert.assertFalse;\nimport static org.junit.Assert.assertTrue;\n\nimport org.junit.Test;\n\nimport com.github.davidmoten.junit.Asserts;\n\npublic class IntersectsTest {\n\n    @Test\n    public void testConstructorIsPrivate() {\n        Asserts.assertIsUtilityClass(Intersects.class);\n    }\n\n    @Test\n    public void testRectangleIntersectsCircle() {\n        assertTrue(\n                Intersects.rectangleIntersectsCircle.call(rectangle(0, 0, 0, 0), circle(0, 0, 1)));\n    }\n\n    @Test\n    public void testRectangleDoesNotIntersectCircle() {\n        assertFalse(Intersects.rectangleIntersectsCircle.call(rectangle(0, 0, 0, 0),\n                circle(100, 100, 1)));\n    }\n\n}\n", "file_hash": "694d4c7e5cbfc32a0b9288918265047235bdd2c63b8be718257f5982836b641b", "file_docstring": "", "contexts": ["package com.github.davidmoten.rtree.geometry;", "import static com.github.davidmoten.rtree.geometry.Geometries.circle;", "import static com.github.davidmoten.rtree.geometry.Geometries.rectangle;", "import static org.junit.Assert.assertFalse;", "import static org.junit.Assert.assertTrue;", "import org.junit.Test;", "import com.github.davidmoten.junit.Asserts;"], "methods": [], "classes": [{"original_string": "public class IntersectsTest {\n\n    @Test\n    public void testConstructorIsPrivate() {\n        Asserts.assertIsUtilityClass(Intersects.class);\n    }\n\n    @Test\n    public void testRectangleIntersectsCircle() {\n        assertTrue(\n                Intersects.rectangleIntersectsCircle.call(rectangle(0, 0, 0, 0), circle(0, 0, 1)));\n    }\n\n    @Test\n    public void testRectangleDoesNotIntersectCircle() {\n        assertFalse(Intersects.rectangleIntersectsCircle.call(rectangle(0, 0, 0, 0),\n                circle(100, 100, 1)));\n    }\n\n}", "definition": "public class IntersectsTest", "class_docstring": "", "name": "IntersectsTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @Test\n    public void testConstructorIsPrivate() {\n        Asserts.assertIsUtilityClass(Intersects.class);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testConstructorIsPrivate", "params": [], "body": "                                           {\n        Asserts.assertIsUtilityClass(Intersects.class);\n    }", "signature": "@Test\n    public void testConstructorIsPrivate()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testRectangleIntersectsCircle() {\n        assertTrue(\n                Intersects.rectangleIntersectsCircle.call(rectangle(0, 0, 0, 0), circle(0, 0, 1)));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testRectangleIntersectsCircle", "params": [], "body": "                                                {\n        assertTrue(\n                Intersects.rectangleIntersectsCircle.call(rectangle(0, 0, 0, 0), circle(0, 0, 1)));\n    }", "signature": "@Test\n    public void testRectangleIntersectsCircle()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testRectangleDoesNotIntersectCircle() {\n        assertFalse(Intersects.rectangleIntersectsCircle.call(rectangle(0, 0, 0, 0),\n                circle(100, 100, 1)));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testRectangleDoesNotIntersectCircle", "params": [], "body": "                                                      {\n        assertFalse(Intersects.rectangleIntersectsCircle.call(rectangle(0, 0, 0, 0),\n                circle(100, 100, 1)));\n    }", "signature": "@Test\n    public void testRectangleDoesNotIntersectCircle()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/com/github/davidmoten/rtree/geometry/GeometriesTest.java", "original_string": "package com.github.davidmoten.rtree.geometry;\n\nimport static org.junit.Assert.assertEquals;\n\nimport org.junit.Test;\n\nimport com.github.davidmoten.junit.Asserts;\n\npublic class GeometriesTest {\n\n    private static final double PRECISION = 0.0001;\n\n    @Test\n    public void testPrivateConstructorForCoverageOnly() {\n        Asserts.assertIsUtilityClass(Geometries.class);\n    }\n\n    @Test\n    public void testNormalizeLongitude() {\n        assertEquals(0, Geometries.normalizeLongitude(0), PRECISION);\n    }\n\n    @Test\n    public void testNormalizeLongitude2() {\n        assertEquals(89, Geometries.normalizeLongitude(89), PRECISION);\n    }\n\n    @Test\n    public void testNormalizeLongitude3() {\n        assertEquals(179, Geometries.normalizeLongitude(179), PRECISION);\n    }\n\n    @Test\n    public void testNormalizeLongitude3_1() {\n        assertEquals(-180, Geometries.normalizeLongitude(180), PRECISION);\n    }\n\n    @Test\n    public void testNormalizeLongitude3_2() {\n        assertEquals(-180, Geometries.normalizeLongitude(-180), PRECISION);\n    }\n\n    @Test\n    public void testNormalizeLongitude3_3() {\n        assertEquals(-179, Geometries.normalizeLongitude(-179), PRECISION);\n    }\n\n    @Test\n    public void testNormalizeLongitude3_4() {\n        assertEquals(179, Geometries.normalizeLongitude(-181), PRECISION);\n    }\n\n    @Test\n    public void testNormalizeLongitude4() {\n        assertEquals(-179, Geometries.normalizeLongitude(181), PRECISION);\n    }\n\n    @Test\n    public void testNormalizeLongitude5() {\n        assertEquals(-179, Geometries.normalizeLongitude(541), PRECISION);\n    }\n\n    @Test\n    public void testNormalizeLongitude2Neg() {\n        assertEquals(-89, Geometries.normalizeLongitude(-89), PRECISION);\n    }\n\n    @Test\n    public void testNormalizeLongitude3Neg() {\n        assertEquals(-179, Geometries.normalizeLongitude(-179), PRECISION);\n    }\n\n    @Test\n    public void testNormalizeLongitude4Neg() {\n        assertEquals(179, Geometries.normalizeLongitude(-181), PRECISION);\n    }\n\n    @Test\n    public void testNormalizeLongitude5Neg() {\n        assertEquals(179, Geometries.normalizeLongitude(-541), PRECISION);\n    }\n\n    @Test\n    public void testRectangleLatLong() {\n        Rectangle r = Geometries.rectangleGeographic(10, -10, 5, 10);\n        assertEquals(10, r.x1(), PRECISION);\n        assertEquals(365, r.x2(), PRECISION);\n        assertEquals(-10, r.y1(), PRECISION);\n        assertEquals(10, r.y2(), PRECISION);\n    }\n\n    @Test\n    public void testRectangleLatLong2() {\n        Rectangle r = Geometries.rectangleGeographic(5, -10, 10, 10);\n        assertEquals(5, r.x1(), PRECISION);\n        assertEquals(10, r.x2(), PRECISION);\n    }\n\n    @Test\n    public void testPointLatLong() {\n        Point point = Geometries.pointGeographic(181, 25);\n        assertEquals(-179, point.x(), PRECISION);\n        assertEquals(25, point.y(), PRECISION);\n    }\n}\n", "file_hash": "b3a7abd9f275aa60b10b98326f18a70f33779b77e0a959735983d4c61c81e5d7", "file_docstring": "", "contexts": ["package com.github.davidmoten.rtree.geometry;", "import static org.junit.Assert.assertEquals;", "import org.junit.Test;", "import com.github.davidmoten.junit.Asserts;"], "methods": [], "classes": [{"original_string": "public class GeometriesTest {\n\n    private static final double PRECISION = 0.0001;\n\n    @Test\n    public void testPrivateConstructorForCoverageOnly() {\n        Asserts.assertIsUtilityClass(Geometries.class);\n    }\n\n    @Test\n    public void testNormalizeLongitude() {\n        assertEquals(0, Geometries.normalizeLongitude(0), PRECISION);\n    }\n\n    @Test\n    public void testNormalizeLongitude2() {\n        assertEquals(89, Geometries.normalizeLongitude(89), PRECISION);\n    }\n\n    @Test\n    public void testNormalizeLongitude3() {\n        assertEquals(179, Geometries.normalizeLongitude(179), PRECISION);\n    }\n\n    @Test\n    public void testNormalizeLongitude3_1() {\n        assertEquals(-180, Geometries.normalizeLongitude(180), PRECISION);\n    }\n\n    @Test\n    public void testNormalizeLongitude3_2() {\n        assertEquals(-180, Geometries.normalizeLongitude(-180), PRECISION);\n    }\n\n    @Test\n    public void testNormalizeLongitude3_3() {\n        assertEquals(-179, Geometries.normalizeLongitude(-179), PRECISION);\n    }\n\n    @Test\n    public void testNormalizeLongitude3_4() {\n        assertEquals(179, Geometries.normalizeLongitude(-181), PRECISION);\n    }\n\n    @Test\n    public void testNormalizeLongitude4() {\n        assertEquals(-179, Geometries.normalizeLongitude(181), PRECISION);\n    }\n\n    @Test\n    public void testNormalizeLongitude5() {\n        assertEquals(-179, Geometries.normalizeLongitude(541), PRECISION);\n    }\n\n    @Test\n    public void testNormalizeLongitude2Neg() {\n        assertEquals(-89, Geometries.normalizeLongitude(-89), PRECISION);\n    }\n\n    @Test\n    public void testNormalizeLongitude3Neg() {\n        assertEquals(-179, Geometries.normalizeLongitude(-179), PRECISION);\n    }\n\n    @Test\n    public void testNormalizeLongitude4Neg() {\n        assertEquals(179, Geometries.normalizeLongitude(-181), PRECISION);\n    }\n\n    @Test\n    public void testNormalizeLongitude5Neg() {\n        assertEquals(179, Geometries.normalizeLongitude(-541), PRECISION);\n    }\n\n    @Test\n    public void testRectangleLatLong() {\n        Rectangle r = Geometries.rectangleGeographic(10, -10, 5, 10);\n        assertEquals(10, r.x1(), PRECISION);\n        assertEquals(365, r.x2(), PRECISION);\n        assertEquals(-10, r.y1(), PRECISION);\n        assertEquals(10, r.y2(), PRECISION);\n    }\n\n    @Test\n    public void testRectangleLatLong2() {\n        Rectangle r = Geometries.rectangleGeographic(5, -10, 10, 10);\n        assertEquals(5, r.x1(), PRECISION);\n        assertEquals(10, r.x2(), PRECISION);\n    }\n\n    @Test\n    public void testPointLatLong() {\n        Point point = Geometries.pointGeographic(181, 25);\n        assertEquals(-179, point.x(), PRECISION);\n        assertEquals(25, point.y(), PRECISION);\n    }\n}", "definition": "public class GeometriesTest", "class_docstring": "", "name": "GeometriesTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private static final double PRECISION = 0.0001;", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "double", "name": "PRECISION = 0.0001", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @Test\n    public void testPrivateConstructorForCoverageOnly() {\n        Asserts.assertIsUtilityClass(Geometries.class);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testPrivateConstructorForCoverageOnly", "params": [], "body": "                                                        {\n        Asserts.assertIsUtilityClass(Geometries.class);\n    }", "signature": "@Test\n    public void testPrivateConstructorForCoverageOnly()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testNormalizeLongitude() {\n        assertEquals(0, Geometries.normalizeLongitude(0), PRECISION);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testNormalizeLongitude", "params": [], "body": "                                         {\n        assertEquals(0, Geometries.normalizeLongitude(0), PRECISION);\n    }", "signature": "@Test\n    public void testNormalizeLongitude()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testNormalizeLongitude2() {\n        assertEquals(89, Geometries.normalizeLongitude(89), PRECISION);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testNormalizeLongitude2", "params": [], "body": "                                          {\n        assertEquals(89, Geometries.normalizeLongitude(89), PRECISION);\n    }", "signature": "@Test\n    public void testNormalizeLongitude2()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testNormalizeLongitude3() {\n        assertEquals(179, Geometries.normalizeLongitude(179), PRECISION);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testNormalizeLongitude3", "params": [], "body": "                                          {\n        assertEquals(179, Geometries.normalizeLongitude(179), PRECISION);\n    }", "signature": "@Test\n    public void testNormalizeLongitude3()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testNormalizeLongitude3_1() {\n        assertEquals(-180, Geometries.normalizeLongitude(180), PRECISION);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testNormalizeLongitude3_1", "params": [], "body": "                                            {\n        assertEquals(-180, Geometries.normalizeLongitude(180), PRECISION);\n    }", "signature": "@Test\n    public void testNormalizeLongitude3_1()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testNormalizeLongitude3_2() {\n        assertEquals(-180, Geometries.normalizeLongitude(-180), PRECISION);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testNormalizeLongitude3_2", "params": [], "body": "                                            {\n        assertEquals(-180, Geometries.normalizeLongitude(-180), PRECISION);\n    }", "signature": "@Test\n    public void testNormalizeLongitude3_2()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testNormalizeLongitude3_3() {\n        assertEquals(-179, Geometries.normalizeLongitude(-179), PRECISION);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testNormalizeLongitude3_3", "params": [], "body": "                                            {\n        assertEquals(-179, Geometries.normalizeLongitude(-179), PRECISION);\n    }", "signature": "@Test\n    public void testNormalizeLongitude3_3()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testNormalizeLongitude3_4() {\n        assertEquals(179, Geometries.normalizeLongitude(-181), PRECISION);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testNormalizeLongitude3_4", "params": [], "body": "                                            {\n        assertEquals(179, Geometries.normalizeLongitude(-181), PRECISION);\n    }", "signature": "@Test\n    public void testNormalizeLongitude3_4()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testNormalizeLongitude4() {\n        assertEquals(-179, Geometries.normalizeLongitude(181), PRECISION);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testNormalizeLongitude4", "params": [], "body": "                                          {\n        assertEquals(-179, Geometries.normalizeLongitude(181), PRECISION);\n    }", "signature": "@Test\n    public void testNormalizeLongitude4()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testNormalizeLongitude5() {\n        assertEquals(-179, Geometries.normalizeLongitude(541), PRECISION);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testNormalizeLongitude5", "params": [], "body": "                                          {\n        assertEquals(-179, Geometries.normalizeLongitude(541), PRECISION);\n    }", "signature": "@Test\n    public void testNormalizeLongitude5()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testNormalizeLongitude2Neg() {\n        assertEquals(-89, Geometries.normalizeLongitude(-89), PRECISION);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testNormalizeLongitude2Neg", "params": [], "body": "                                             {\n        assertEquals(-89, Geometries.normalizeLongitude(-89), PRECISION);\n    }", "signature": "@Test\n    public void testNormalizeLongitude2Neg()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testNormalizeLongitude3Neg() {\n        assertEquals(-179, Geometries.normalizeLongitude(-179), PRECISION);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testNormalizeLongitude3Neg", "params": [], "body": "                                             {\n        assertEquals(-179, Geometries.normalizeLongitude(-179), PRECISION);\n    }", "signature": "@Test\n    public void testNormalizeLongitude3Neg()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testNormalizeLongitude4Neg() {\n        assertEquals(179, Geometries.normalizeLongitude(-181), PRECISION);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testNormalizeLongitude4Neg", "params": [], "body": "                                             {\n        assertEquals(179, Geometries.normalizeLongitude(-181), PRECISION);\n    }", "signature": "@Test\n    public void testNormalizeLongitude4Neg()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testNormalizeLongitude5Neg() {\n        assertEquals(179, Geometries.normalizeLongitude(-541), PRECISION);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testNormalizeLongitude5Neg", "params": [], "body": "                                             {\n        assertEquals(179, Geometries.normalizeLongitude(-541), PRECISION);\n    }", "signature": "@Test\n    public void testNormalizeLongitude5Neg()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testRectangleLatLong() {\n        Rectangle r = Geometries.rectangleGeographic(10, -10, 5, 10);\n        assertEquals(10, r.x1(), PRECISION);\n        assertEquals(365, r.x2(), PRECISION);\n        assertEquals(-10, r.y1(), PRECISION);\n        assertEquals(10, r.y2(), PRECISION);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testRectangleLatLong", "params": [], "body": "                                       {\n        Rectangle r = Geometries.rectangleGeographic(10, -10, 5, 10);\n        assertEquals(10, r.x1(), PRECISION);\n        assertEquals(365, r.x2(), PRECISION);\n        assertEquals(-10, r.y1(), PRECISION);\n        assertEquals(10, r.y2(), PRECISION);\n    }", "signature": "@Test\n    public void testRectangleLatLong()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testRectangleLatLong2() {\n        Rectangle r = Geometries.rectangleGeographic(5, -10, 10, 10);\n        assertEquals(5, r.x1(), PRECISION);\n        assertEquals(10, r.x2(), PRECISION);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testRectangleLatLong2", "params": [], "body": "                                        {\n        Rectangle r = Geometries.rectangleGeographic(5, -10, 10, 10);\n        assertEquals(5, r.x1(), PRECISION);\n        assertEquals(10, r.x2(), PRECISION);\n    }", "signature": "@Test\n    public void testRectangleLatLong2()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testPointLatLong() {\n        Point point = Geometries.pointGeographic(181, 25);\n        assertEquals(-179, point.x(), PRECISION);\n        assertEquals(25, point.y(), PRECISION);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testPointLatLong", "params": [], "body": "                                   {\n        Point point = Geometries.pointGeographic(181, 25);\n        assertEquals(-179, point.x(), PRECISION);\n        assertEquals(25, point.y(), PRECISION);\n    }", "signature": "@Test\n    public void testPointLatLong()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/com/github/davidmoten/rtree/geometry/RectangleTest.java", "original_string": "package com.github.davidmoten.rtree.geometry;\n\nimport static com.github.davidmoten.rtree.geometry.Geometries.rectangle;\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertFalse;\nimport static org.junit.Assert.assertTrue;\n\nimport org.junit.Test;\n\npublic class RectangleTest {\n\n    private static final double PRECISION = 0.00001;\n\n    @Test\n    public void testDistanceToSelfIsZero() {\n        Rectangle r = rectangle(0, 0, 1, 1);\n        assertEquals(0, r.distance(r), PRECISION);\n    }\n\n    @Test(expected = IllegalArgumentException.class)\n    public void testXParametersWrongOrderThrowsException() {\n        rectangle(2, 0, 1, 1);\n    }\n\n    @Test(expected = IllegalArgumentException.class)\n    public void testYParametersWrongOrderThrowsException() {\n        rectangle(0, 2, 1, 1);\n    }\n\n    @Test\n    public void testDistanceToOverlapIsZero() {\n        Rectangle r = rectangle(0, 0, 2, 2);\n        Rectangle r2 = rectangle(1, 1, 3, 3);\n\n        assertEquals(0, r.distance(r2), PRECISION);\n        assertEquals(0, r2.distance(r), PRECISION);\n    }\n\n    @Test\n    public void testDistanceWhenSeparatedByXOnly() {\n        Rectangle r = rectangle(0, 0, 2, 2);\n        Rectangle r2 = rectangle(3, 0, 4, 2);\n\n        assertEquals(1, r.distance(r2), PRECISION);\n        assertEquals(1, r2.distance(r), PRECISION);\n    }\n\n    @Test\n    public void testDistanceWhenSeparatedByXOnlyAndOverlapOnY() {\n        Rectangle r = rectangle(0, 0, 2, 2);\n        Rectangle r2 = rectangle(3, 1.5f, 4, 3.5f);\n\n        assertEquals(1, r.distance(r2), PRECISION);\n        assertEquals(1, r2.distance(r), PRECISION);\n    }\n\n    @Test\n    public void testDistanceWhenSeparatedByDiagonally() {\n        Rectangle r = rectangle(0, 0, 2, 1);\n        Rectangle r2 = rectangle(3, 6, 10, 8);\n\n        assertEquals(Math.sqrt(26), r.distance(r2), PRECISION);\n        assertEquals(Math.sqrt(26), r2.distance(r), PRECISION);\n    }\n\n    @Test\n    public void testInequalityWithNull() {\n        assertFalse(rectangle(0, 0, 1, 1).equals(null));\n    }\n\n    @Test\n    public void testSimpleEquality() {\n        Rectangle r = rectangle(0, 0, 2, 1);\n        Rectangle r2 = rectangle(0, 0, 2, 1);\n\n        assertTrue(r.equals(r2));\n    }\n\n    @Test\n    public void testSimpleInEquality1() {\n        Rectangle r = rectangle(0, 0, 2, 1);\n        Rectangle r2 = rectangle(0, 0, 2, 2);\n\n        assertFalse(r.equals(r2));\n    }\n\n    @Test\n    public void testSimpleInEquality2() {\n        Rectangle r = rectangle(0, 0, 2, 1);\n        Rectangle r2 = rectangle(1, 0, 2, 1);\n\n        assertFalse(r.equals(r2));\n    }\n\n    @Test\n    public void testSimpleInEquality3() {\n        Rectangle r = rectangle(0, 0, 2, 1);\n        Rectangle r2 = rectangle(0, 1, 2, 1);\n\n        assertFalse(r.equals(r2));\n    }\n\n    @Test\n    public void testSimpleInEquality4() {\n        Rectangle r = rectangle(0, 0, 2, 2);\n        Rectangle r2 = rectangle(0, 0, 1, 2);\n\n        assertFalse(r.equals(r2));\n    }\n\n    @Test\n    public void testGeometry() {\n        Rectangle r = rectangle(0, 0, 2, 1);\n        assertTrue(r.equals(r.geometry()));\n    }\n\n    @Test\n    public void testIntersects() {\n        Rectangle a = rectangle(14, 14, 86, 37);\n        Rectangle b = rectangle(13, 23, 50, 80);\n        assertTrue(a.intersects(b));\n        assertTrue(b.intersects(a));\n    }\n\n    @Test\n    public void testIntersectsNoRectangleContainsCornerOfAnother() {\n        Rectangle a = rectangle(10, 10, 50, 50);\n        Rectangle b = rectangle(28.0, 4.0, 34.0, 85.0);\n        assertTrue(a.intersects(b));\n        assertTrue(b.intersects(a));\n    }\n\n    @Test\n    public void testIntersectsOneRectangleContainsTheOther() {\n        Rectangle a = rectangle(10, 10, 50, 50);\n        Rectangle b = rectangle(20, 20, 40, 40);\n        assertTrue(a.intersects(b));\n        assertTrue(b.intersects(a));\n    }\n\n    @Test\n    public void testIntersectsOneRectangleReturnsTrueDespiteZeroArea() {\n        Rectangle a = rectangle(10, 50, 50, 50);\n        Rectangle b = rectangle(20, 20, 60, 60);\n        assertTrue(a.intersects(b));\n        assertTrue(b.intersects(a));\n    }\n    \n    @Test\n    public void testContains() {\n        Rectangle r = rectangle(10, 20, 30, 40);\n        assertTrue(r.contains(20, 30));\n    }\n\n    @Test\n    public void testContainsReturnsFalseWhenLessThanMinY() {\n        Rectangle r = rectangle(10, 20, 30, 40);\n        assertFalse(r.contains(20, 19));\n    }\n\n    @Test\n    public void testContainsReturnsFalseWhenGreaterThanMaxY() {\n        Rectangle r = rectangle(10, 20, 30, 40);\n        assertFalse(r.contains(20, 41));\n    }\n\n    @Test\n    public void testContainsReturnsFalseWhenGreaterThanMaxX() {\n        Rectangle r = rectangle(10, 20, 30, 40);\n        assertFalse(r.contains(31, 30));\n    }\n\n    @Test\n    public void testContainsReturnsFalseWhenLessThanMinX() {\n        Rectangle r = rectangle(10, 20, 30, 40);\n        assertFalse(r.contains(9, 30));\n    }\n\n    @Test\n    public void testIntersectionAreWhenEqual() {\n        Rectangle a = rectangle(10, 10, 30, 20);\n        Rectangle b = rectangle(10, 10, 30, 20);\n        assertEquals(200f, a.intersectionArea(b), 0.0001);\n    }\n\n    @Test\n    public void testIntersectionAreaWhenDontIntersect() {\n        Rectangle a = rectangle(10, 10, 30, 20);\n        Rectangle b = rectangle(50, 50, 60, 60);\n        assertEquals(0f, a.intersectionArea(b), 0.0001);\n    }\n\n    @Test\n    public void testIntersectionAreaCornerIntersect() {\n        Rectangle a = rectangle(10, 10, 30, 20);\n        Rectangle b = rectangle(28, 17, 40, 40);\n        assertEquals(6f, a.intersectionArea(b), 0.0001);\n    }\n\n    @Test\n    public void testIntersectionAreaTopIntersect() {\n        Rectangle a = rectangle(10, 10, 30, 20);\n        Rectangle b = rectangle(8, 17, 40, 40);\n        assertEquals(60f, a.intersectionArea(b), 0.0001);\n    }\n\n}", "file_hash": "6abd0460e2d0c61acb04a76ad9f3135c2d797549330e15aecd59cc558f8603c0", "file_docstring": "", "contexts": ["package com.github.davidmoten.rtree.geometry;", "import static com.github.davidmoten.rtree.geometry.Geometries.rectangle;", "import static org.junit.Assert.assertEquals;", "import static org.junit.Assert.assertFalse;", "import static org.junit.Assert.assertTrue;", "import org.junit.Test;"], "methods": [], "classes": [{"original_string": "public class RectangleTest {\n\n    private static final double PRECISION = 0.00001;\n\n    @Test\n    public void testDistanceToSelfIsZero() {\n        Rectangle r = rectangle(0, 0, 1, 1);\n        assertEquals(0, r.distance(r), PRECISION);\n    }\n\n    @Test(expected = IllegalArgumentException.class)\n    public void testXParametersWrongOrderThrowsException() {\n        rectangle(2, 0, 1, 1);\n    }\n\n    @Test(expected = IllegalArgumentException.class)\n    public void testYParametersWrongOrderThrowsException() {\n        rectangle(0, 2, 1, 1);\n    }\n\n    @Test\n    public void testDistanceToOverlapIsZero() {\n        Rectangle r = rectangle(0, 0, 2, 2);\n        Rectangle r2 = rectangle(1, 1, 3, 3);\n\n        assertEquals(0, r.distance(r2), PRECISION);\n        assertEquals(0, r2.distance(r), PRECISION);\n    }\n\n    @Test\n    public void testDistanceWhenSeparatedByXOnly() {\n        Rectangle r = rectangle(0, 0, 2, 2);\n        Rectangle r2 = rectangle(3, 0, 4, 2);\n\n        assertEquals(1, r.distance(r2), PRECISION);\n        assertEquals(1, r2.distance(r), PRECISION);\n    }\n\n    @Test\n    public void testDistanceWhenSeparatedByXOnlyAndOverlapOnY() {\n        Rectangle r = rectangle(0, 0, 2, 2);\n        Rectangle r2 = rectangle(3, 1.5f, 4, 3.5f);\n\n        assertEquals(1, r.distance(r2), PRECISION);\n        assertEquals(1, r2.distance(r), PRECISION);\n    }\n\n    @Test\n    public void testDistanceWhenSeparatedByDiagonally() {\n        Rectangle r = rectangle(0, 0, 2, 1);\n        Rectangle r2 = rectangle(3, 6, 10, 8);\n\n        assertEquals(Math.sqrt(26), r.distance(r2), PRECISION);\n        assertEquals(Math.sqrt(26), r2.distance(r), PRECISION);\n    }\n\n    @Test\n    public void testInequalityWithNull() {\n        assertFalse(rectangle(0, 0, 1, 1).equals(null));\n    }\n\n    @Test\n    public void testSimpleEquality() {\n        Rectangle r = rectangle(0, 0, 2, 1);\n        Rectangle r2 = rectangle(0, 0, 2, 1);\n\n        assertTrue(r.equals(r2));\n    }\n\n    @Test\n    public void testSimpleInEquality1() {\n        Rectangle r = rectangle(0, 0, 2, 1);\n        Rectangle r2 = rectangle(0, 0, 2, 2);\n\n        assertFalse(r.equals(r2));\n    }\n\n    @Test\n    public void testSimpleInEquality2() {\n        Rectangle r = rectangle(0, 0, 2, 1);\n        Rectangle r2 = rectangle(1, 0, 2, 1);\n\n        assertFalse(r.equals(r2));\n    }\n\n    @Test\n    public void testSimpleInEquality3() {\n        Rectangle r = rectangle(0, 0, 2, 1);\n        Rectangle r2 = rectangle(0, 1, 2, 1);\n\n        assertFalse(r.equals(r2));\n    }\n\n    @Test\n    public void testSimpleInEquality4() {\n        Rectangle r = rectangle(0, 0, 2, 2);\n        Rectangle r2 = rectangle(0, 0, 1, 2);\n\n        assertFalse(r.equals(r2));\n    }\n\n    @Test\n    public void testGeometry() {\n        Rectangle r = rectangle(0, 0, 2, 1);\n        assertTrue(r.equals(r.geometry()));\n    }\n\n    @Test\n    public void testIntersects() {\n        Rectangle a = rectangle(14, 14, 86, 37);\n        Rectangle b = rectangle(13, 23, 50, 80);\n        assertTrue(a.intersects(b));\n        assertTrue(b.intersects(a));\n    }\n\n    @Test\n    public void testIntersectsNoRectangleContainsCornerOfAnother() {\n        Rectangle a = rectangle(10, 10, 50, 50);\n        Rectangle b = rectangle(28.0, 4.0, 34.0, 85.0);\n        assertTrue(a.intersects(b));\n        assertTrue(b.intersects(a));\n    }\n\n    @Test\n    public void testIntersectsOneRectangleContainsTheOther() {\n        Rectangle a = rectangle(10, 10, 50, 50);\n        Rectangle b = rectangle(20, 20, 40, 40);\n        assertTrue(a.intersects(b));\n        assertTrue(b.intersects(a));\n    }\n\n    @Test\n    public void testIntersectsOneRectangleReturnsTrueDespiteZeroArea() {\n        Rectangle a = rectangle(10, 50, 50, 50);\n        Rectangle b = rectangle(20, 20, 60, 60);\n        assertTrue(a.intersects(b));\n        assertTrue(b.intersects(a));\n    }\n    \n    @Test\n    public void testContains() {\n        Rectangle r = rectangle(10, 20, 30, 40);\n        assertTrue(r.contains(20, 30));\n    }\n\n    @Test\n    public void testContainsReturnsFalseWhenLessThanMinY() {\n        Rectangle r = rectangle(10, 20, 30, 40);\n        assertFalse(r.contains(20, 19));\n    }\n\n    @Test\n    public void testContainsReturnsFalseWhenGreaterThanMaxY() {\n        Rectangle r = rectangle(10, 20, 30, 40);\n        assertFalse(r.contains(20, 41));\n    }\n\n    @Test\n    public void testContainsReturnsFalseWhenGreaterThanMaxX() {\n        Rectangle r = rectangle(10, 20, 30, 40);\n        assertFalse(r.contains(31, 30));\n    }\n\n    @Test\n    public void testContainsReturnsFalseWhenLessThanMinX() {\n        Rectangle r = rectangle(10, 20, 30, 40);\n        assertFalse(r.contains(9, 30));\n    }\n\n    @Test\n    public void testIntersectionAreWhenEqual() {\n        Rectangle a = rectangle(10, 10, 30, 20);\n        Rectangle b = rectangle(10, 10, 30, 20);\n        assertEquals(200f, a.intersectionArea(b), 0.0001);\n    }\n\n    @Test\n    public void testIntersectionAreaWhenDontIntersect() {\n        Rectangle a = rectangle(10, 10, 30, 20);\n        Rectangle b = rectangle(50, 50, 60, 60);\n        assertEquals(0f, a.intersectionArea(b), 0.0001);\n    }\n\n    @Test\n    public void testIntersectionAreaCornerIntersect() {\n        Rectangle a = rectangle(10, 10, 30, 20);\n        Rectangle b = rectangle(28, 17, 40, 40);\n        assertEquals(6f, a.intersectionArea(b), 0.0001);\n    }\n\n    @Test\n    public void testIntersectionAreaTopIntersect() {\n        Rectangle a = rectangle(10, 10, 30, 20);\n        Rectangle b = rectangle(8, 17, 40, 40);\n        assertEquals(60f, a.intersectionArea(b), 0.0001);\n    }\n\n}", "definition": "public class RectangleTest", "class_docstring": "", "name": "RectangleTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private static final double PRECISION = 0.00001;", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "double", "name": "PRECISION = 0.00001", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @Test\n    public void testDistanceToSelfIsZero() {\n        Rectangle r = rectangle(0, 0, 1, 1);\n        assertEquals(0, r.distance(r), PRECISION);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testDistanceToSelfIsZero", "params": [], "body": "                                           {\n        Rectangle r = rectangle(0, 0, 1, 1);\n        assertEquals(0, r.distance(r), PRECISION);\n    }", "signature": "@Test\n    public void testDistanceToSelfIsZero()"}, {"syntax_pass": true, "original_string": "    @Test(expected = IllegalArgumentException.class)\n    public void testXParametersWrongOrderThrowsException() {\n        rectangle(2, 0, 1, 1);\n    }", "docstring": "", "attributes": {"modifiers": "@Test(expected = IllegalArgumentException.class)\n    public", "marker_annotations": [], "non_marker_annotations": ["@Test(expected = IllegalArgumentException.class)", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "testXParametersWrongOrderThrowsException", "params": [], "body": "                                                           {\n        rectangle(2, 0, 1, 1);\n    }", "signature": "@Test(expected = IllegalArgumentException.class)\n    public void testXParametersWrongOrderThrowsException()"}, {"syntax_pass": true, "original_string": "    @Test(expected = IllegalArgumentException.class)\n    public void testYParametersWrongOrderThrowsException() {\n        rectangle(0, 2, 1, 1);\n    }", "docstring": "", "attributes": {"modifiers": "@Test(expected = IllegalArgumentException.class)\n    public", "marker_annotations": [], "non_marker_annotations": ["@Test(expected = IllegalArgumentException.class)", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "testYParametersWrongOrderThrowsException", "params": [], "body": "                                                           {\n        rectangle(0, 2, 1, 1);\n    }", "signature": "@Test(expected = IllegalArgumentException.class)\n    public void testYParametersWrongOrderThrowsException()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testDistanceToOverlapIsZero() {\n        Rectangle r = rectangle(0, 0, 2, 2);\n        Rectangle r2 = rectangle(1, 1, 3, 3);\n\n        assertEquals(0, r.distance(r2), PRECISION);\n        assertEquals(0, r2.distance(r), PRECISION);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testDistanceToOverlapIsZero", "params": [], "body": "                                              {\n        Rectangle r = rectangle(0, 0, 2, 2);\n        Rectangle r2 = rectangle(1, 1, 3, 3);\n\n        assertEquals(0, r.distance(r2), PRECISION);\n        assertEquals(0, r2.distance(r), PRECISION);\n    }", "signature": "@Test\n    public void testDistanceToOverlapIsZero()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testDistanceWhenSeparatedByXOnly() {\n        Rectangle r = rectangle(0, 0, 2, 2);\n        Rectangle r2 = rectangle(3, 0, 4, 2);\n\n        assertEquals(1, r.distance(r2), PRECISION);\n        assertEquals(1, r2.distance(r), PRECISION);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testDistanceWhenSeparatedByXOnly", "params": [], "body": "                                                   {\n        Rectangle r = rectangle(0, 0, 2, 2);\n        Rectangle r2 = rectangle(3, 0, 4, 2);\n\n        assertEquals(1, r.distance(r2), PRECISION);\n        assertEquals(1, r2.distance(r), PRECISION);\n    }", "signature": "@Test\n    public void testDistanceWhenSeparatedByXOnly()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testDistanceWhenSeparatedByXOnlyAndOverlapOnY() {\n        Rectangle r = rectangle(0, 0, 2, 2);\n        Rectangle r2 = rectangle(3, 1.5f, 4, 3.5f);\n\n        assertEquals(1, r.distance(r2), PRECISION);\n        assertEquals(1, r2.distance(r), PRECISION);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testDistanceWhenSeparatedByXOnlyAndOverlapOnY", "params": [], "body": "                                                                {\n        Rectangle r = rectangle(0, 0, 2, 2);\n        Rectangle r2 = rectangle(3, 1.5f, 4, 3.5f);\n\n        assertEquals(1, r.distance(r2), PRECISION);\n        assertEquals(1, r2.distance(r), PRECISION);\n    }", "signature": "@Test\n    public void testDistanceWhenSeparatedByXOnlyAndOverlapOnY()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testDistanceWhenSeparatedByDiagonally() {\n        Rectangle r = rectangle(0, 0, 2, 1);\n        Rectangle r2 = rectangle(3, 6, 10, 8);\n\n        assertEquals(Math.sqrt(26), r.distance(r2), PRECISION);\n        assertEquals(Math.sqrt(26), r2.distance(r), PRECISION);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testDistanceWhenSeparatedByDiagonally", "params": [], "body": "                                                        {\n        Rectangle r = rectangle(0, 0, 2, 1);\n        Rectangle r2 = rectangle(3, 6, 10, 8);\n\n        assertEquals(Math.sqrt(26), r.distance(r2), PRECISION);\n        assertEquals(Math.sqrt(26), r2.distance(r), PRECISION);\n    }", "signature": "@Test\n    public void testDistanceWhenSeparatedByDiagonally()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testInequalityWithNull() {\n        assertFalse(rectangle(0, 0, 1, 1).equals(null));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testInequalityWithNull", "params": [], "body": "                                         {\n        assertFalse(rectangle(0, 0, 1, 1).equals(null));\n    }", "signature": "@Test\n    public void testInequalityWithNull()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testSimpleEquality() {\n        Rectangle r = rectangle(0, 0, 2, 1);\n        Rectangle r2 = rectangle(0, 0, 2, 1);\n\n        assertTrue(r.equals(r2));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testSimpleEquality", "params": [], "body": "                                     {\n        Rectangle r = rectangle(0, 0, 2, 1);\n        Rectangle r2 = rectangle(0, 0, 2, 1);\n\n        assertTrue(r.equals(r2));\n    }", "signature": "@Test\n    public void testSimpleEquality()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testSimpleInEquality1() {\n        Rectangle r = rectangle(0, 0, 2, 1);\n        Rectangle r2 = rectangle(0, 0, 2, 2);\n\n        assertFalse(r.equals(r2));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testSimpleInEquality1", "params": [], "body": "                                        {\n        Rectangle r = rectangle(0, 0, 2, 1);\n        Rectangle r2 = rectangle(0, 0, 2, 2);\n\n        assertFalse(r.equals(r2));\n    }", "signature": "@Test\n    public void testSimpleInEquality1()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testSimpleInEquality2() {\n        Rectangle r = rectangle(0, 0, 2, 1);\n        Rectangle r2 = rectangle(1, 0, 2, 1);\n\n        assertFalse(r.equals(r2));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testSimpleInEquality2", "params": [], "body": "                                        {\n        Rectangle r = rectangle(0, 0, 2, 1);\n        Rectangle r2 = rectangle(1, 0, 2, 1);\n\n        assertFalse(r.equals(r2));\n    }", "signature": "@Test\n    public void testSimpleInEquality2()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testSimpleInEquality3() {\n        Rectangle r = rectangle(0, 0, 2, 1);\n        Rectangle r2 = rectangle(0, 1, 2, 1);\n\n        assertFalse(r.equals(r2));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testSimpleInEquality3", "params": [], "body": "                                        {\n        Rectangle r = rectangle(0, 0, 2, 1);\n        Rectangle r2 = rectangle(0, 1, 2, 1);\n\n        assertFalse(r.equals(r2));\n    }", "signature": "@Test\n    public void testSimpleInEquality3()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testSimpleInEquality4() {\n        Rectangle r = rectangle(0, 0, 2, 2);\n        Rectangle r2 = rectangle(0, 0, 1, 2);\n\n        assertFalse(r.equals(r2));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testSimpleInEquality4", "params": [], "body": "                                        {\n        Rectangle r = rectangle(0, 0, 2, 2);\n        Rectangle r2 = rectangle(0, 0, 1, 2);\n\n        assertFalse(r.equals(r2));\n    }", "signature": "@Test\n    public void testSimpleInEquality4()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testGeometry() {\n        Rectangle r = rectangle(0, 0, 2, 1);\n        assertTrue(r.equals(r.geometry()));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testGeometry", "params": [], "body": "                               {\n        Rectangle r = rectangle(0, 0, 2, 1);\n        assertTrue(r.equals(r.geometry()));\n    }", "signature": "@Test\n    public void testGeometry()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testIntersects() {\n        Rectangle a = rectangle(14, 14, 86, 37);\n        Rectangle b = rectangle(13, 23, 50, 80);\n        assertTrue(a.intersects(b));\n        assertTrue(b.intersects(a));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testIntersects", "params": [], "body": "                                 {\n        Rectangle a = rectangle(14, 14, 86, 37);\n        Rectangle b = rectangle(13, 23, 50, 80);\n        assertTrue(a.intersects(b));\n        assertTrue(b.intersects(a));\n    }", "signature": "@Test\n    public void testIntersects()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testIntersectsNoRectangleContainsCornerOfAnother() {\n        Rectangle a = rectangle(10, 10, 50, 50);\n        Rectangle b = rectangle(28.0, 4.0, 34.0, 85.0);\n        assertTrue(a.intersects(b));\n        assertTrue(b.intersects(a));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testIntersectsNoRectangleContainsCornerOfAnother", "params": [], "body": "                                                                   {\n        Rectangle a = rectangle(10, 10, 50, 50);\n        Rectangle b = rectangle(28.0, 4.0, 34.0, 85.0);\n        assertTrue(a.intersects(b));\n        assertTrue(b.intersects(a));\n    }", "signature": "@Test\n    public void testIntersectsNoRectangleContainsCornerOfAnother()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testIntersectsOneRectangleContainsTheOther() {\n        Rectangle a = rectangle(10, 10, 50, 50);\n        Rectangle b = rectangle(20, 20, 40, 40);\n        assertTrue(a.intersects(b));\n        assertTrue(b.intersects(a));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testIntersectsOneRectangleContainsTheOther", "params": [], "body": "                                                             {\n        Rectangle a = rectangle(10, 10, 50, 50);\n        Rectangle b = rectangle(20, 20, 40, 40);\n        assertTrue(a.intersects(b));\n        assertTrue(b.intersects(a));\n    }", "signature": "@Test\n    public void testIntersectsOneRectangleContainsTheOther()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testIntersectsOneRectangleReturnsTrueDespiteZeroArea() {\n        Rectangle a = rectangle(10, 50, 50, 50);\n        Rectangle b = rectangle(20, 20, 60, 60);\n        assertTrue(a.intersects(b));\n        assertTrue(b.intersects(a));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testIntersectsOneRectangleReturnsTrueDespiteZeroArea", "params": [], "body": "                                                                       {\n        Rectangle a = rectangle(10, 50, 50, 50);\n        Rectangle b = rectangle(20, 20, 60, 60);\n        assertTrue(a.intersects(b));\n        assertTrue(b.intersects(a));\n    }", "signature": "@Test\n    public void testIntersectsOneRectangleReturnsTrueDespiteZeroArea()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testContains() {\n        Rectangle r = rectangle(10, 20, 30, 40);\n        assertTrue(r.contains(20, 30));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testContains", "params": [], "body": "                               {\n        Rectangle r = rectangle(10, 20, 30, 40);\n        assertTrue(r.contains(20, 30));\n    }", "signature": "@Test\n    public void testContains()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testContainsReturnsFalseWhenLessThanMinY() {\n        Rectangle r = rectangle(10, 20, 30, 40);\n        assertFalse(r.contains(20, 19));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testContainsReturnsFalseWhenLessThanMinY", "params": [], "body": "                                                           {\n        Rectangle r = rectangle(10, 20, 30, 40);\n        assertFalse(r.contains(20, 19));\n    }", "signature": "@Test\n    public void testContainsReturnsFalseWhenLessThanMinY()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testContainsReturnsFalseWhenGreaterThanMaxY() {\n        Rectangle r = rectangle(10, 20, 30, 40);\n        assertFalse(r.contains(20, 41));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testContainsReturnsFalseWhenGreaterThanMaxY", "params": [], "body": "                                                              {\n        Rectangle r = rectangle(10, 20, 30, 40);\n        assertFalse(r.contains(20, 41));\n    }", "signature": "@Test\n    public void testContainsReturnsFalseWhenGreaterThanMaxY()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testContainsReturnsFalseWhenGreaterThanMaxX() {\n        Rectangle r = rectangle(10, 20, 30, 40);\n        assertFalse(r.contains(31, 30));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testContainsReturnsFalseWhenGreaterThanMaxX", "params": [], "body": "                                                              {\n        Rectangle r = rectangle(10, 20, 30, 40);\n        assertFalse(r.contains(31, 30));\n    }", "signature": "@Test\n    public void testContainsReturnsFalseWhenGreaterThanMaxX()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testContainsReturnsFalseWhenLessThanMinX() {\n        Rectangle r = rectangle(10, 20, 30, 40);\n        assertFalse(r.contains(9, 30));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testContainsReturnsFalseWhenLessThanMinX", "params": [], "body": "                                                           {\n        Rectangle r = rectangle(10, 20, 30, 40);\n        assertFalse(r.contains(9, 30));\n    }", "signature": "@Test\n    public void testContainsReturnsFalseWhenLessThanMinX()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testIntersectionAreWhenEqual() {\n        Rectangle a = rectangle(10, 10, 30, 20);\n        Rectangle b = rectangle(10, 10, 30, 20);\n        assertEquals(200f, a.intersectionArea(b), 0.0001);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testIntersectionAreWhenEqual", "params": [], "body": "                                               {\n        Rectangle a = rectangle(10, 10, 30, 20);\n        Rectangle b = rectangle(10, 10, 30, 20);\n        assertEquals(200f, a.intersectionArea(b), 0.0001);\n    }", "signature": "@Test\n    public void testIntersectionAreWhenEqual()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testIntersectionAreaWhenDontIntersect() {\n        Rectangle a = rectangle(10, 10, 30, 20);\n        Rectangle b = rectangle(50, 50, 60, 60);\n        assertEquals(0f, a.intersectionArea(b), 0.0001);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testIntersectionAreaWhenDontIntersect", "params": [], "body": "                                                        {\n        Rectangle a = rectangle(10, 10, 30, 20);\n        Rectangle b = rectangle(50, 50, 60, 60);\n        assertEquals(0f, a.intersectionArea(b), 0.0001);\n    }", "signature": "@Test\n    public void testIntersectionAreaWhenDontIntersect()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testIntersectionAreaCornerIntersect() {\n        Rectangle a = rectangle(10, 10, 30, 20);\n        Rectangle b = rectangle(28, 17, 40, 40);\n        assertEquals(6f, a.intersectionArea(b), 0.0001);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testIntersectionAreaCornerIntersect", "params": [], "body": "                                                      {\n        Rectangle a = rectangle(10, 10, 30, 20);\n        Rectangle b = rectangle(28, 17, 40, 40);\n        assertEquals(6f, a.intersectionArea(b), 0.0001);\n    }", "signature": "@Test\n    public void testIntersectionAreaCornerIntersect()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testIntersectionAreaTopIntersect() {\n        Rectangle a = rectangle(10, 10, 30, 20);\n        Rectangle b = rectangle(8, 17, 40, 40);\n        assertEquals(60f, a.intersectionArea(b), 0.0001);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testIntersectionAreaTopIntersect", "params": [], "body": "                                                   {\n        Rectangle a = rectangle(10, 10, 30, 20);\n        Rectangle b = rectangle(8, 17, 40, 40);\n        assertEquals(60f, a.intersectionArea(b), 0.0001);\n    }", "signature": "@Test\n    public void testIntersectionAreaTopIntersect()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/com/github/davidmoten/rtree/geometry/CircleTest.java", "original_string": "package com.github.davidmoten.rtree.geometry;\n\nimport static com.github.davidmoten.rtree.geometry.Geometries.circle;\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertFalse;\nimport static org.junit.Assert.assertNotEquals;\nimport static org.junit.Assert.assertTrue;\n\nimport org.junit.Test;\n\npublic class CircleTest {\n    private static final double PRECISION = 0.000001;\n\n    @Test\n    public void testCoordinates() {\n        Circle circle = circle(1, 2, 3);\n        assertEquals(1, circle.x(), PRECISION);\n        assertEquals(2, circle.y(), PRECISION);\n    }\n\n    @Test\n    public void testDistance() {\n        Circle circle = circle(0, 0, 1);\n        Rectangle r = Geometries.rectangle(1, 1, 2, 2);\n        assertEquals(Math.sqrt(2) - 1, circle.distance(r), PRECISION);\n    }\n\n    @Test\n    public void testMbr() {\n        Circle circle = circle(1, 2, 3);\n        Rectangle r = Geometries.rectangle(-2, -1, 4, 5);\n        assertEquals(r, circle.mbr());\n    }\n\n    @Test\n    public void testEquality() {\n        Circle circle1 = circle(1, 2, 3);\n        Circle circle2 = circle(1, 2, 3);\n        assertEquals(circle1, circle2);\n    }\n\n    @Test\n    public void testInequalityRadius() {\n        Circle circle1 = circle(1, 2, 3);\n        Circle circle2 = circle(1, 2, 4);\n        assertNotEquals(circle1, circle2);\n    }\n\n    @Test\n    public void testInequalityX() {\n        Circle circle1 = circle(1, 2, 3);\n        Circle circle2 = circle(2, 2, 3);\n        assertNotEquals(circle1, circle2);\n    }\n\n    @Test\n    public void testInequalityY() {\n        Circle circle1 = circle(1, 2, 3);\n        Circle circle2 = circle(1, 3, 3);\n        assertNotEquals(circle1, circle2);\n    }\n\n    @Test\n    public void testInequalityWithNull() {\n        Circle circle = circle(1, 2, 3);\n        assertFalse(circle.equals(null));\n    }\n\n    @Test\n    public void testHashCode() {\n        Circle circle = circle(1, 2, 3);\n        assertEquals(1606448223, circle.hashCode());\n    }\n\n    @Test\n    public void testDistanceIsZeroWhenIntersects() {\n        Circle circle = circle(0, 0, 1);\n        assertTrue(circle.distance(Geometries.rectangle(0, 1, 0, 1)) == 0);\n    }\n\n    @Test\n    public void testIntersects2() {\n        Circle circle = circle(0, 0, 1);\n        assertTrue(circle.distance(Geometries.rectangle(0, 1.1, 0, 1.1)) != 0);\n    }\n\n    @Test\n    public void testIntersects3() {\n        Circle circle = circle(0, 0, 1);\n        assertTrue(circle.distance(Geometries.rectangle(1, 1, 1, 1)) != 0);\n    }\n\n    @Test\n    public void testIntersectsReturnsTrue() {\n        assertTrue(circle(0, 0, 1).intersects(Geometries.rectangle(0, 0, 1, 1)));\n    }\n\n    @Test\n    public void testIntersectsReturnsFalse() {\n        assertFalse(circle(0, 0, 1).intersects(Geometries.rectangle(10, 10, 11, 11)));\n    }\n\n    @Test\n    public void testIntersects() {\n        Circle a = circle(0, 0, 1);\n        Circle b = circle(0.1, 0.1, 1);\n        assertTrue(Intersects.circleIntersectsCircle.call(a, b));\n    }\n\n    @Test\n    public void testDoNotIntersect() {\n        Circle a = circle(0, 0, 1);\n        Circle b = circle(100, 100, 1);\n        assertFalse(Intersects.circleIntersectsCircle.call(a, b));\n    }\n\n    @Test\n    public void testIntersectsPoint() {\n        assertTrue(circle(0, 0, 1).intersects(Geometries.point(0, 0)));\n    }\n\n    @Test\n    public void testDoesNotIntersectPoint() {\n        assertFalse(circle(0, 0, 1).intersects(Geometries.point(100, 100)));\n    }\n}\n", "file_hash": "2c24b7b3d3f58d749626bc0c700a0c7662e9e3ec5321f8d5d327eb1a42cc2c86", "file_docstring": "", "contexts": ["package com.github.davidmoten.rtree.geometry;", "import static com.github.davidmoten.rtree.geometry.Geometries.circle;", "import static org.junit.Assert.assertEquals;", "import static org.junit.Assert.assertFalse;", "import static org.junit.Assert.assertNotEquals;", "import static org.junit.Assert.assertTrue;", "import org.junit.Test;"], "methods": [], "classes": [{"original_string": "public class CircleTest {\n    private static final double PRECISION = 0.000001;\n\n    @Test\n    public void testCoordinates() {\n        Circle circle = circle(1, 2, 3);\n        assertEquals(1, circle.x(), PRECISION);\n        assertEquals(2, circle.y(), PRECISION);\n    }\n\n    @Test\n    public void testDistance() {\n        Circle circle = circle(0, 0, 1);\n        Rectangle r = Geometries.rectangle(1, 1, 2, 2);\n        assertEquals(Math.sqrt(2) - 1, circle.distance(r), PRECISION);\n    }\n\n    @Test\n    public void testMbr() {\n        Circle circle = circle(1, 2, 3);\n        Rectangle r = Geometries.rectangle(-2, -1, 4, 5);\n        assertEquals(r, circle.mbr());\n    }\n\n    @Test\n    public void testEquality() {\n        Circle circle1 = circle(1, 2, 3);\n        Circle circle2 = circle(1, 2, 3);\n        assertEquals(circle1, circle2);\n    }\n\n    @Test\n    public void testInequalityRadius() {\n        Circle circle1 = circle(1, 2, 3);\n        Circle circle2 = circle(1, 2, 4);\n        assertNotEquals(circle1, circle2);\n    }\n\n    @Test\n    public void testInequalityX() {\n        Circle circle1 = circle(1, 2, 3);\n        Circle circle2 = circle(2, 2, 3);\n        assertNotEquals(circle1, circle2);\n    }\n\n    @Test\n    public void testInequalityY() {\n        Circle circle1 = circle(1, 2, 3);\n        Circle circle2 = circle(1, 3, 3);\n        assertNotEquals(circle1, circle2);\n    }\n\n    @Test\n    public void testInequalityWithNull() {\n        Circle circle = circle(1, 2, 3);\n        assertFalse(circle.equals(null));\n    }\n\n    @Test\n    public void testHashCode() {\n        Circle circle = circle(1, 2, 3);\n        assertEquals(1606448223, circle.hashCode());\n    }\n\n    @Test\n    public void testDistanceIsZeroWhenIntersects() {\n        Circle circle = circle(0, 0, 1);\n        assertTrue(circle.distance(Geometries.rectangle(0, 1, 0, 1)) == 0);\n    }\n\n    @Test\n    public void testIntersects2() {\n        Circle circle = circle(0, 0, 1);\n        assertTrue(circle.distance(Geometries.rectangle(0, 1.1, 0, 1.1)) != 0);\n    }\n\n    @Test\n    public void testIntersects3() {\n        Circle circle = circle(0, 0, 1);\n        assertTrue(circle.distance(Geometries.rectangle(1, 1, 1, 1)) != 0);\n    }\n\n    @Test\n    public void testIntersectsReturnsTrue() {\n        assertTrue(circle(0, 0, 1).intersects(Geometries.rectangle(0, 0, 1, 1)));\n    }\n\n    @Test\n    public void testIntersectsReturnsFalse() {\n        assertFalse(circle(0, 0, 1).intersects(Geometries.rectangle(10, 10, 11, 11)));\n    }\n\n    @Test\n    public void testIntersects() {\n        Circle a = circle(0, 0, 1);\n        Circle b = circle(0.1, 0.1, 1);\n        assertTrue(Intersects.circleIntersectsCircle.call(a, b));\n    }\n\n    @Test\n    public void testDoNotIntersect() {\n        Circle a = circle(0, 0, 1);\n        Circle b = circle(100, 100, 1);\n        assertFalse(Intersects.circleIntersectsCircle.call(a, b));\n    }\n\n    @Test\n    public void testIntersectsPoint() {\n        assertTrue(circle(0, 0, 1).intersects(Geometries.point(0, 0)));\n    }\n\n    @Test\n    public void testDoesNotIntersectPoint() {\n        assertFalse(circle(0, 0, 1).intersects(Geometries.point(100, 100)));\n    }\n}", "definition": "public class CircleTest", "class_docstring": "", "name": "CircleTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private static final double PRECISION = 0.000001;", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "double", "name": "PRECISION = 0.000001", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @Test\n    public void testCoordinates() {\n        Circle circle = circle(1, 2, 3);\n        assertEquals(1, circle.x(), PRECISION);\n        assertEquals(2, circle.y(), PRECISION);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testCoordinates", "params": [], "body": "                                  {\n        Circle circle = circle(1, 2, 3);\n        assertEquals(1, circle.x(), PRECISION);\n        assertEquals(2, circle.y(), PRECISION);\n    }", "signature": "@Test\n    public void testCoordinates()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testDistance() {\n        Circle circle = circle(0, 0, 1);\n        Rectangle r = Geometries.rectangle(1, 1, 2, 2);\n        assertEquals(Math.sqrt(2) - 1, circle.distance(r), PRECISION);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testDistance", "params": [], "body": "                               {\n        Circle circle = circle(0, 0, 1);\n        Rectangle r = Geometries.rectangle(1, 1, 2, 2);\n        assertEquals(Math.sqrt(2) - 1, circle.distance(r), PRECISION);\n    }", "signature": "@Test\n    public void testDistance()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testMbr() {\n        Circle circle = circle(1, 2, 3);\n        Rectangle r = Geometries.rectangle(-2, -1, 4, 5);\n        assertEquals(r, circle.mbr());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testMbr", "params": [], "body": "                          {\n        Circle circle = circle(1, 2, 3);\n        Rectangle r = Geometries.rectangle(-2, -1, 4, 5);\n        assertEquals(r, circle.mbr());\n    }", "signature": "@Test\n    public void testMbr()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testEquality() {\n        Circle circle1 = circle(1, 2, 3);\n        Circle circle2 = circle(1, 2, 3);\n        assertEquals(circle1, circle2);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testEquality", "params": [], "body": "                               {\n        Circle circle1 = circle(1, 2, 3);\n        Circle circle2 = circle(1, 2, 3);\n        assertEquals(circle1, circle2);\n    }", "signature": "@Test\n    public void testEquality()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testInequalityRadius() {\n        Circle circle1 = circle(1, 2, 3);\n        Circle circle2 = circle(1, 2, 4);\n        assertNotEquals(circle1, circle2);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testInequalityRadius", "params": [], "body": "                                       {\n        Circle circle1 = circle(1, 2, 3);\n        Circle circle2 = circle(1, 2, 4);\n        assertNotEquals(circle1, circle2);\n    }", "signature": "@Test\n    public void testInequalityRadius()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testInequalityX() {\n        Circle circle1 = circle(1, 2, 3);\n        Circle circle2 = circle(2, 2, 3);\n        assertNotEquals(circle1, circle2);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testInequalityX", "params": [], "body": "                                  {\n        Circle circle1 = circle(1, 2, 3);\n        Circle circle2 = circle(2, 2, 3);\n        assertNotEquals(circle1, circle2);\n    }", "signature": "@Test\n    public void testInequalityX()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testInequalityY() {\n        Circle circle1 = circle(1, 2, 3);\n        Circle circle2 = circle(1, 3, 3);\n        assertNotEquals(circle1, circle2);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testInequalityY", "params": [], "body": "                                  {\n        Circle circle1 = circle(1, 2, 3);\n        Circle circle2 = circle(1, 3, 3);\n        assertNotEquals(circle1, circle2);\n    }", "signature": "@Test\n    public void testInequalityY()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testInequalityWithNull() {\n        Circle circle = circle(1, 2, 3);\n        assertFalse(circle.equals(null));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testInequalityWithNull", "params": [], "body": "                                         {\n        Circle circle = circle(1, 2, 3);\n        assertFalse(circle.equals(null));\n    }", "signature": "@Test\n    public void testInequalityWithNull()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testHashCode() {\n        Circle circle = circle(1, 2, 3);\n        assertEquals(1606448223, circle.hashCode());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testHashCode", "params": [], "body": "                               {\n        Circle circle = circle(1, 2, 3);\n        assertEquals(1606448223, circle.hashCode());\n    }", "signature": "@Test\n    public void testHashCode()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testDistanceIsZeroWhenIntersects() {\n        Circle circle = circle(0, 0, 1);\n        assertTrue(circle.distance(Geometries.rectangle(0, 1, 0, 1)) == 0);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testDistanceIsZeroWhenIntersects", "params": [], "body": "                                                   {\n        Circle circle = circle(0, 0, 1);\n        assertTrue(circle.distance(Geometries.rectangle(0, 1, 0, 1)) == 0);\n    }", "signature": "@Test\n    public void testDistanceIsZeroWhenIntersects()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testIntersects2() {\n        Circle circle = circle(0, 0, 1);\n        assertTrue(circle.distance(Geometries.rectangle(0, 1.1, 0, 1.1)) != 0);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testIntersects2", "params": [], "body": "                                  {\n        Circle circle = circle(0, 0, 1);\n        assertTrue(circle.distance(Geometries.rectangle(0, 1.1, 0, 1.1)) != 0);\n    }", "signature": "@Test\n    public void testIntersects2()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testIntersects3() {\n        Circle circle = circle(0, 0, 1);\n        assertTrue(circle.distance(Geometries.rectangle(1, 1, 1, 1)) != 0);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testIntersects3", "params": [], "body": "                                  {\n        Circle circle = circle(0, 0, 1);\n        assertTrue(circle.distance(Geometries.rectangle(1, 1, 1, 1)) != 0);\n    }", "signature": "@Test\n    public void testIntersects3()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testIntersectsReturnsTrue() {\n        assertTrue(circle(0, 0, 1).intersects(Geometries.rectangle(0, 0, 1, 1)));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testIntersectsReturnsTrue", "params": [], "body": "                                            {\n        assertTrue(circle(0, 0, 1).intersects(Geometries.rectangle(0, 0, 1, 1)));\n    }", "signature": "@Test\n    public void testIntersectsReturnsTrue()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testIntersectsReturnsFalse() {\n        assertFalse(circle(0, 0, 1).intersects(Geometries.rectangle(10, 10, 11, 11)));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testIntersectsReturnsFalse", "params": [], "body": "                                             {\n        assertFalse(circle(0, 0, 1).intersects(Geometries.rectangle(10, 10, 11, 11)));\n    }", "signature": "@Test\n    public void testIntersectsReturnsFalse()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testIntersects() {\n        Circle a = circle(0, 0, 1);\n        Circle b = circle(0.1, 0.1, 1);\n        assertTrue(Intersects.circleIntersectsCircle.call(a, b));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testIntersects", "params": [], "body": "                                 {\n        Circle a = circle(0, 0, 1);\n        Circle b = circle(0.1, 0.1, 1);\n        assertTrue(Intersects.circleIntersectsCircle.call(a, b));\n    }", "signature": "@Test\n    public void testIntersects()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testDoNotIntersect() {\n        Circle a = circle(0, 0, 1);\n        Circle b = circle(100, 100, 1);\n        assertFalse(Intersects.circleIntersectsCircle.call(a, b));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testDoNotIntersect", "params": [], "body": "                                     {\n        Circle a = circle(0, 0, 1);\n        Circle b = circle(100, 100, 1);\n        assertFalse(Intersects.circleIntersectsCircle.call(a, b));\n    }", "signature": "@Test\n    public void testDoNotIntersect()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testIntersectsPoint() {\n        assertTrue(circle(0, 0, 1).intersects(Geometries.point(0, 0)));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testIntersectsPoint", "params": [], "body": "                                      {\n        assertTrue(circle(0, 0, 1).intersects(Geometries.point(0, 0)));\n    }", "signature": "@Test\n    public void testIntersectsPoint()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testDoesNotIntersectPoint() {\n        assertFalse(circle(0, 0, 1).intersects(Geometries.point(100, 100)));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testDoesNotIntersectPoint", "params": [], "body": "                                            {\n        assertFalse(circle(0, 0, 1).intersects(Geometries.point(100, 100)));\n    }", "signature": "@Test\n    public void testDoesNotIntersectPoint()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/com/github/davidmoten/rtree/geometry/PointTest.java", "original_string": "package com.github.davidmoten.rtree.geometry;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertFalse;\nimport static org.junit.Assert.assertTrue;\n\nimport org.junit.Test;\n\npublic class PointTest {\n\n\tprivate static final double PRECISION = 0.000001;\n\n\t@Test\n\tpublic void testCoordinates() {\n\t\tPoint point = Geometries.point(1, 2);\n\t\tassertEquals(1, point.x(), PRECISION);\n\t\tassertEquals(2, point.y(), PRECISION);\n\t}\n\n\t@Test\n\tpublic void testDistanceToRectangle() {\n\t\tPoint p1 = Geometries.point(1, 2);\n\t\tRectangle r = Geometries.rectangle(4, 6, 4, 6);\n\t\tassertEquals(5, p1.distance(r), PRECISION);\n\t}\n\n\t@Test\n\tpublic void testDistanceToPoint() {\n\t\tPoint p1 = Geometries.point(1, 2);\n\t\tPoint p2 = Geometries.point(4, 6);\n\t\tassertEquals(5, p1.distance(p2), PRECISION);\n\t}\n\n\t@Test\n\tpublic void testMbr() {\n\t\tPoint p = Geometries.point(1, 2);\n\t\tPoint p2 = Geometries.point(1, 2);\n\t\tassertEquals(p, p2);\n\t}\n\n\t@Test\n\tpublic void testPointIntersectsItself() {\n\t\tPoint p = Geometries.point(1, 2);\n\t\tassertTrue(p.distance(p.mbr()) == 0);\n\t}\n\n\t@Test\n\tpublic void testIntersectIsFalseWhenPointsDiffer() {\n\t\tPoint p1 = Geometries.point(1, 2);\n\t\tPoint p2 = Geometries.point(1, 2.000001);\n\t\tassertFalse(p1.distance(p2.mbr()) == 0);\n\t}\n\n\t@Test\n\tpublic void testEquality() {\n\t\tPoint p1 = Geometries.point(1, 2);\n\t\tPoint p2 = Geometries.point(1, 2);\n\t\tassertTrue(p1.equals(p2));\n\t}\n\n\t@Test\n\tpublic void testInequality() {\n\t\tPoint p1 = Geometries.point(1, 2);\n\t\tPoint p2 = Geometries.point(1, 3);\n\t\tassertFalse(p1.equals(p2));\n\t}\n\n\t@Test\n\tpublic void testInequalityToNull() {\n\t\tPoint p1 = Geometries.point(1, 2);\n\t\tassertFalse(p1.equals(null));\n\t}\n\n\t@Test\n\tpublic void testHashCode() {\n\t\tPoint p = Geometries.point(1, 2);\n\t\tassertEquals(-260045887, p.hashCode());\n\t}\n\n\t@Test\n\tpublic void testDoesNotContain() {\n\t\tPoint p = Geometries.point(1, 2);\n\t\tassertFalse(p.contains(1, 3));\n\t}\n\t\n\t@Test\n\tpublic void testContains() {\n\t\tPoint p = Geometries.point(1, 2);\n\t\tassertTrue(p.contains(1, 2));\n\t}\n}\n", "file_hash": "d9b6a960861446e09946bb32fd54ccf87a5d1ef15fb96a335e7ff00d8418e2df", "file_docstring": "", "contexts": ["package com.github.davidmoten.rtree.geometry;", "import static org.junit.Assert.assertEquals;", "import static org.junit.Assert.assertFalse;", "import static org.junit.Assert.assertTrue;", "import org.junit.Test;"], "methods": [], "classes": [{"original_string": "public class PointTest {\n\n\tprivate static final double PRECISION = 0.000001;\n\n\t@Test\n\tpublic void testCoordinates() {\n\t\tPoint point = Geometries.point(1, 2);\n\t\tassertEquals(1, point.x(), PRECISION);\n\t\tassertEquals(2, point.y(), PRECISION);\n\t}\n\n\t@Test\n\tpublic void testDistanceToRectangle() {\n\t\tPoint p1 = Geometries.point(1, 2);\n\t\tRectangle r = Geometries.rectangle(4, 6, 4, 6);\n\t\tassertEquals(5, p1.distance(r), PRECISION);\n\t}\n\n\t@Test\n\tpublic void testDistanceToPoint() {\n\t\tPoint p1 = Geometries.point(1, 2);\n\t\tPoint p2 = Geometries.point(4, 6);\n\t\tassertEquals(5, p1.distance(p2), PRECISION);\n\t}\n\n\t@Test\n\tpublic void testMbr() {\n\t\tPoint p = Geometries.point(1, 2);\n\t\tPoint p2 = Geometries.point(1, 2);\n\t\tassertEquals(p, p2);\n\t}\n\n\t@Test\n\tpublic void testPointIntersectsItself() {\n\t\tPoint p = Geometries.point(1, 2);\n\t\tassertTrue(p.distance(p.mbr()) == 0);\n\t}\n\n\t@Test\n\tpublic void testIntersectIsFalseWhenPointsDiffer() {\n\t\tPoint p1 = Geometries.point(1, 2);\n\t\tPoint p2 = Geometries.point(1, 2.000001);\n\t\tassertFalse(p1.distance(p2.mbr()) == 0);\n\t}\n\n\t@Test\n\tpublic void testEquality() {\n\t\tPoint p1 = Geometries.point(1, 2);\n\t\tPoint p2 = Geometries.point(1, 2);\n\t\tassertTrue(p1.equals(p2));\n\t}\n\n\t@Test\n\tpublic void testInequality() {\n\t\tPoint p1 = Geometries.point(1, 2);\n\t\tPoint p2 = Geometries.point(1, 3);\n\t\tassertFalse(p1.equals(p2));\n\t}\n\n\t@Test\n\tpublic void testInequalityToNull() {\n\t\tPoint p1 = Geometries.point(1, 2);\n\t\tassertFalse(p1.equals(null));\n\t}\n\n\t@Test\n\tpublic void testHashCode() {\n\t\tPoint p = Geometries.point(1, 2);\n\t\tassertEquals(-260045887, p.hashCode());\n\t}\n\n\t@Test\n\tpublic void testDoesNotContain() {\n\t\tPoint p = Geometries.point(1, 2);\n\t\tassertFalse(p.contains(1, 3));\n\t}\n\t\n\t@Test\n\tpublic void testContains() {\n\t\tPoint p = Geometries.point(1, 2);\n\t\tassertTrue(p.contains(1, 2));\n\t}\n}", "definition": "public class PointTest", "class_docstring": "", "name": "PointTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private static final double PRECISION = 0.000001;", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "double", "name": "PRECISION = 0.000001", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": " @Test\n\tpublic void testCoordinates() {\n\t\tPoint point = Geometries.point(1, 2);\n\t\tassertEquals(1, point.x(), PRECISION);\n\t\tassertEquals(2, point.y(), PRECISION);\n\t}", "docstring": "", "attributes": {"modifiers": "@Test\n\tpublic", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testCoordinates", "params": [], "body": "                               {\n\t\tPoint point = Geometries.point(1, 2);\n\t\tassertEquals(1, point.x(), PRECISION);\n\t\tassertEquals(2, point.y(), PRECISION);\n\t}", "signature": "@Test\n\tpublic void testCoordinates()"}, {"syntax_pass": true, "original_string": " @Test\n\tpublic void testDistanceToRectangle() {\n\t\tPoint p1 = Geometries.point(1, 2);\n\t\tRectangle r = Geometries.rectangle(4, 6, 4, 6);\n\t\tassertEquals(5, p1.distance(r), PRECISION);\n\t}", "docstring": "", "attributes": {"modifiers": "@Test\n\tpublic", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testDistanceToRectangle", "params": [], "body": "                                       {\n\t\tPoint p1 = Geometries.point(1, 2);\n\t\tRectangle r = Geometries.rectangle(4, 6, 4, 6);\n\t\tassertEquals(5, p1.distance(r), PRECISION);\n\t}", "signature": "@Test\n\tpublic void testDistanceToRectangle()"}, {"syntax_pass": true, "original_string": " @Test\n\tpublic void testDistanceToPoint() {\n\t\tPoint p1 = Geometries.point(1, 2);\n\t\tPoint p2 = Geometries.point(4, 6);\n\t\tassertEquals(5, p1.distance(p2), PRECISION);\n\t}", "docstring": "", "attributes": {"modifiers": "@Test\n\tpublic", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testDistanceToPoint", "params": [], "body": "                                   {\n\t\tPoint p1 = Geometries.point(1, 2);\n\t\tPoint p2 = Geometries.point(4, 6);\n\t\tassertEquals(5, p1.distance(p2), PRECISION);\n\t}", "signature": "@Test\n\tpublic void testDistanceToPoint()"}, {"syntax_pass": true, "original_string": " @Test\n\tpublic void testMbr() {\n\t\tPoint p = Geometries.point(1, 2);\n\t\tPoint p2 = Geometries.point(1, 2);\n\t\tassertEquals(p, p2);\n\t}", "docstring": "", "attributes": {"modifiers": "@Test\n\tpublic", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testMbr", "params": [], "body": "                       {\n\t\tPoint p = Geometries.point(1, 2);\n\t\tPoint p2 = Geometries.point(1, 2);\n\t\tassertEquals(p, p2);\n\t}", "signature": "@Test\n\tpublic void testMbr()"}, {"syntax_pass": true, "original_string": " @Test\n\tpublic void testPointIntersectsItself() {\n\t\tPoint p = Geometries.point(1, 2);\n\t\tassertTrue(p.distance(p.mbr()) == 0);\n\t}", "docstring": "", "attributes": {"modifiers": "@Test\n\tpublic", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testPointIntersectsItself", "params": [], "body": "                                         {\n\t\tPoint p = Geometries.point(1, 2);\n\t\tassertTrue(p.distance(p.mbr()) == 0);\n\t}", "signature": "@Test\n\tpublic void testPointIntersectsItself()"}, {"syntax_pass": true, "original_string": " @Test\n\tpublic void testIntersectIsFalseWhenPointsDiffer() {\n\t\tPoint p1 = Geometries.point(1, 2);\n\t\tPoint p2 = Geometries.point(1, 2.000001);\n\t\tassertFalse(p1.distance(p2.mbr()) == 0);\n\t}", "docstring": "", "attributes": {"modifiers": "@Test\n\tpublic", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testIntersectIsFalseWhenPointsDiffer", "params": [], "body": "                                                    {\n\t\tPoint p1 = Geometries.point(1, 2);\n\t\tPoint p2 = Geometries.point(1, 2.000001);\n\t\tassertFalse(p1.distance(p2.mbr()) == 0);\n\t}", "signature": "@Test\n\tpublic void testIntersectIsFalseWhenPointsDiffer()"}, {"syntax_pass": true, "original_string": " @Test\n\tpublic void testEquality() {\n\t\tPoint p1 = Geometries.point(1, 2);\n\t\tPoint p2 = Geometries.point(1, 2);\n\t\tassertTrue(p1.equals(p2));\n\t}", "docstring": "", "attributes": {"modifiers": "@Test\n\tpublic", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testEquality", "params": [], "body": "                            {\n\t\tPoint p1 = Geometries.point(1, 2);\n\t\tPoint p2 = Geometries.point(1, 2);\n\t\tassertTrue(p1.equals(p2));\n\t}", "signature": "@Test\n\tpublic void testEquality()"}, {"syntax_pass": true, "original_string": " @Test\n\tpublic void testInequality() {\n\t\tPoint p1 = Geometries.point(1, 2);\n\t\tPoint p2 = Geometries.point(1, 3);\n\t\tassertFalse(p1.equals(p2));\n\t}", "docstring": "", "attributes": {"modifiers": "@Test\n\tpublic", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testInequality", "params": [], "body": "                              {\n\t\tPoint p1 = Geometries.point(1, 2);\n\t\tPoint p2 = Geometries.point(1, 3);\n\t\tassertFalse(p1.equals(p2));\n\t}", "signature": "@Test\n\tpublic void testInequality()"}, {"syntax_pass": true, "original_string": " @Test\n\tpublic void testInequalityToNull() {\n\t\tPoint p1 = Geometries.point(1, 2);\n\t\tassertFalse(p1.equals(null));\n\t}", "docstring": "", "attributes": {"modifiers": "@Test\n\tpublic", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testInequalityToNull", "params": [], "body": "                                    {\n\t\tPoint p1 = Geometries.point(1, 2);\n\t\tassertFalse(p1.equals(null));\n\t}", "signature": "@Test\n\tpublic void testInequalityToNull()"}, {"syntax_pass": true, "original_string": " @Test\n\tpublic void testHashCode() {\n\t\tPoint p = Geometries.point(1, 2);\n\t\tassertEquals(-260045887, p.hashCode());\n\t}", "docstring": "", "attributes": {"modifiers": "@Test\n\tpublic", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testHashCode", "params": [], "body": "                            {\n\t\tPoint p = Geometries.point(1, 2);\n\t\tassertEquals(-260045887, p.hashCode());\n\t}", "signature": "@Test\n\tpublic void testHashCode()"}, {"syntax_pass": true, "original_string": " @Test\n\tpublic void testDoesNotContain() {\n\t\tPoint p = Geometries.point(1, 2);\n\t\tassertFalse(p.contains(1, 3));\n\t}", "docstring": "", "attributes": {"modifiers": "@Test\n\tpublic", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testDoesNotContain", "params": [], "body": "                                  {\n\t\tPoint p = Geometries.point(1, 2);\n\t\tassertFalse(p.contains(1, 3));\n\t}", "signature": "@Test\n\tpublic void testDoesNotContain()"}, {"syntax_pass": true, "original_string": " @Test\n\tpublic void testContains() {\n\t\tPoint p = Geometries.point(1, 2);\n\t\tassertTrue(p.contains(1, 2));\n\t}", "docstring": "", "attributes": {"modifiers": "@Test\n\tpublic", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testContains", "params": [], "body": "                            {\n\t\tPoint p = Geometries.point(1, 2);\n\t\tassertTrue(p.contains(1, 2));\n\t}", "signature": "@Test\n\tpublic void testContains()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/com/github/davidmoten/rtree/geometry/LineTest.java", "original_string": "package com.github.davidmoten.rtree.geometry;\n\nimport static com.github.davidmoten.rtree.geometry.Geometries.point;\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertFalse;\nimport static org.junit.Assert.assertTrue;\n\nimport java.awt.geom.Line2D;\n\nimport org.junit.Test;\n\npublic final class LineTest {\n\n    private static final double PRECISION = 0.00001;\n\n    @Test\n    public void testDoesIntersectOtherLine() {\n        Line a = Geometries.line(-1, 0, 1, 0);\n        Line b = Geometries.line(0, -1, 0, 1);\n        assertTrue(Intersects.lineIntersectsLine.call(a, b));\n    }\n\n    @Test\n    public void testDoesNotIntersectLine() {\n        Line a = Geometries.line(-1, 0, 1, 0);\n        Line b = Geometries.line(1.1, -1, 1.1, 1);\n        assertFalse(Intersects.lineIntersectsLine.call(a, b));\n    }\n\n    @Test\n    public void testDoesIntersectRectangle() {\n        Line a = Geometries.line(-1, 0, 1, 0);\n        Rectangle b = Geometries.rectangle(0.2, -0.5, 0.8, 0.5);\n        assertTrue(Intersects.lineIntersectsRectangle.call(a, b));\n    }\n\n    @Test\n    public void testDoesNotIntersectRectangle() {\n        Line a = Geometries.line(-1, 0, 1, 0);\n        Rectangle b = Geometries.rectangle(1.2, -0.5, 1.8, 0.5);\n        assertFalse(Intersects.lineIntersectsRectangle.call(a, b));\n    }\n\n    @Test\n    public void testLineIntersectsCircle() {\n        Line a = Geometries.line(-1, 0, 1, 0);\n        Circle c = Geometries.circle(0, 0.5, 1);\n        assertTrue(Intersects.lineIntersectsCircle.call(a, c));\n    }\n\n    @Test\n    public void testLineDoesNotIntersectCircle() {\n        Line a = Geometries.line(-1, 0, 1, 0);\n        Circle c = Geometries.circle(0, 0.5, 0.4);\n        assertFalse(Intersects.lineIntersectsCircle.call(a, c));\n    }\n\n    @Test\n    public void testLineDoesNotIntersectCircleEast() {\n        Line a = Geometries.line(-1, 0, 1, 0);\n        Circle c = Geometries.circle(1.5, 0, 0.4);\n        assertFalse(Intersects.lineIntersectsCircle.call(a, c));\n    }\n\n    @Test\n    public void testLineDoesIntersectCircleEast() {\n        Line a = Geometries.line(-1, 0, 1, 0);\n        Circle c = Geometries.circle(1.5, 0, 0.6);\n        assertTrue(Intersects.lineIntersectsCircle.call(a, c));\n    }\n\n    @Test\n    public void testLineDoesNotIntersectCircleWest() {\n        Line a = Geometries.line(-1, 0, 1, 0);\n        Circle c = Geometries.circle(-1.5, 0, 0.4);\n        assertFalse(Intersects.lineIntersectsCircle.call(a, c));\n    }\n\n    @Test\n    public void testLineDoesIntersectCircleWest() {\n        Line a = Geometries.line(-1, 0, 1, 0);\n        Circle c = Geometries.circle(-1.5, 0, 0.6);\n        assertTrue(Intersects.lineIntersectsCircle.call(a, c));\n    }\n\n    @Test\n    public void testLineDoesNotIntersectCircleNorth() {\n        Line a = Geometries.line(-1, 0, 1, 0);\n        Circle c = Geometries.circle(0, 1.5, 0.4);\n        assertFalse(Intersects.lineIntersectsCircle.call(a, c));\n    }\n\n    @Test\n    public void testLineDoesNotIntersectCircleSouth() {\n        Line a = Geometries.line(-1, 0, 1, 0);\n        Circle c = Geometries.circle(0, 1.5, 0.4);\n        assertFalse(Intersects.lineIntersectsCircle.call(a, c));\n    }\n\n    @Test\n    public void testLineDoesIntersectCircleSouth() {\n        Line a = Geometries.line(-1, 0, 1, 0);\n        Circle c = Geometries.circle(0, 1.5, 0.6);\n        assertFalse(Intersects.lineIntersectsCircle.call(a, c));\n    }\n\n    @Test\n    public void testLineMbr() {\n        Line a = Geometries.line(-2, 3, 1, -1);\n        Rectangle mbr = a.mbr();\n        assertEquals(-2, mbr.x1(), PRECISION);\n        assertEquals(-1, mbr.y1(), PRECISION);\n        assertEquals(1, mbr.x2(), PRECISION);\n        assertEquals(3, mbr.y2(), PRECISION);\n    }\n\n    @Test\n    public void testLineSameXWithinCircle() {\n        Line a = Geometries.line(1, 2, 1, 4);\n        Circle c = Geometries.circle(1, 3, 2);\n        assertTrue(Intersects.lineIntersectsCircle.call(a, c));\n    }\n\n    @Test\n    public void testLineIsPointWithinCircle() {\n        Line a = Geometries.line(1, 2, 1, 2);\n        Circle c = Geometries.circle(1, 3, 2);\n        assertTrue(Intersects.lineIntersectsCircle.call(a, c));\n    }\n\n    @Test\n    public void testLineIsPointOutsideCircle() {\n        Line a = Geometries.line(1, 10, 1, 10);\n        Circle c = Geometries.circle(1, 3, 2);\n        assertFalse(Intersects.lineIntersectsCircle.call(a, c));\n    }\n\n    @Test\n    public void testLineDistanceToRectangle() {\n        Line a = Geometries.line(1, 2, 1, 2);\n        Rectangle r = Geometries.rectangle(3, 3, 7, 7);\n        assertEquals(Math.sqrt(5), a.distance(r), PRECISION);\n    }\n\n    @Test\n    public void testLineDistanceToRectangleIsZeroWhenOneEndIsInside() {\n        Line a = Geometries.line(1, 2, 4, 4);\n        Rectangle r = Geometries.rectangle(3, 3, 7, 7);\n        assertEquals(0, a.distance(r), PRECISION);\n    }\n\n    @Test\n    public void testLineDistanceToRectangleIsZeroWhenOtherEndIsInside() {\n        Line a = Geometries.line(4, 4, 1, 2);\n        Rectangle r = Geometries.rectangle(3, 3, 7, 7);\n        assertEquals(0, a.distance(r), PRECISION);\n    }\n\n    @Test\n    public void testLineDistanceToRectangleIsZeroWhenContainsWestEdge() {\n        Line a = Geometries.line(3, 1, 3, 10);\n        Rectangle r = Geometries.rectangle(3, 3, 7, 7);\n        assertEquals(0, a.distance(r), PRECISION);\n    }\n\n    @Test\n    public void testLineDistanceToRectangleIsZeroWhenContainsNorthEdge() {\n        Line a = Geometries.line(2, 7, 10, 7);\n        Rectangle r = Geometries.rectangle(3, 3, 7, 7);\n        assertEquals(0, a.distance(r), PRECISION);\n    }\n\n    @Test\n    public void testLineDistanceToRectangleIsZeroWhenContainsSouthEdge() {\n        Line a = Geometries.line(2, 3, 10, 3);\n        Rectangle r = Geometries.rectangle(3, 3, 7, 7);\n        assertEquals(0, a.distance(r), PRECISION);\n    }\n\n    @Test\n    public void testLineDistanceToRectangleIsZeroWhenContainsEastEdge() {\n        Line a = Geometries.line(7, 1, 7, 10);\n        Rectangle r = Geometries.rectangle(3, 3, 7, 7);\n        assertEquals(0, a.distance(r), PRECISION);\n    }\n\n    @Test\n    public void testLineDoesNotIntersectsPoint() {\n        assertFalse(Geometries.line(1.5, 1.5, 2.6, 2.5).intersects(point(2, 2)));\n    }\n\n    @Test\n    public void testLineDoesIntersectPoint() {\n        assertTrue(Geometries.line(1.5, 1.5, 2.5, 2.5).intersects(point(2, 2)));\n    }\n    \n    @Test\n    public void testLineDoubleIntersectsWithHorizontalLine() {\n        {  // test expectation on Line2D.Double.intersectsLine which we depend on \n            Line2D.Double line = new Line2D.Double(35.0d, -25.0d, 45.0d, -25.0d);\n            assertTrue(line.intersectsLine(40.0d, -20.0d, 45.0d, -40.0d));\n        }\n        {\n            Line line = Geometries.line(40.0d, -20.0d, 45.0d, -40.0d);\n            Line horizontalLine = Geometries.line(35.0d, -25.0d, 45.0d, -25.0d);\n            \n            assertTrue(line.intersects(horizontalLine.mbr()));\n        }\n    }\n    \n    @Test\n    public void testLineFloatIntersectsWithHorizontalLine() {\n        {  // test expectation on Line2D.Double.intersectsLine which we depend on \n            Line2D.Float line = new Line2D.Float(35.0f, -25.0f, 45.0f, -25.0f);\n            assertTrue(line.intersectsLine(40.0f, -20.0f, 45.0f, -40.0f));\n        }\n        {\n            Line line = Geometries.line(40.0f, -20.0f, 45.0f, -40.0f);\n            Line horizontalLine = Geometries.line(35.0f, -25.0f, 45.0f, -25.0f);\n            \n            assertTrue(line.intersects(horizontalLine.mbr()));\n        }\n    }\n\n}\n", "file_hash": "bf703e3c49c6d5128bbfb3a9765cf223abdb58f6979e949e4fa168573f40f47c", "file_docstring": "", "contexts": ["package com.github.davidmoten.rtree.geometry;", "import static com.github.davidmoten.rtree.geometry.Geometries.point;", "import static org.junit.Assert.assertEquals;", "import static org.junit.Assert.assertFalse;", "import static org.junit.Assert.assertTrue;", "import java.awt.geom.Line2D;", "import org.junit.Test;"], "methods": [], "classes": [{"original_string": "public final class LineTest {\n\n    private static final double PRECISION = 0.00001;\n\n    @Test\n    public void testDoesIntersectOtherLine() {\n        Line a = Geometries.line(-1, 0, 1, 0);\n        Line b = Geometries.line(0, -1, 0, 1);\n        assertTrue(Intersects.lineIntersectsLine.call(a, b));\n    }\n\n    @Test\n    public void testDoesNotIntersectLine() {\n        Line a = Geometries.line(-1, 0, 1, 0);\n        Line b = Geometries.line(1.1, -1, 1.1, 1);\n        assertFalse(Intersects.lineIntersectsLine.call(a, b));\n    }\n\n    @Test\n    public void testDoesIntersectRectangle() {\n        Line a = Geometries.line(-1, 0, 1, 0);\n        Rectangle b = Geometries.rectangle(0.2, -0.5, 0.8, 0.5);\n        assertTrue(Intersects.lineIntersectsRectangle.call(a, b));\n    }\n\n    @Test\n    public void testDoesNotIntersectRectangle() {\n        Line a = Geometries.line(-1, 0, 1, 0);\n        Rectangle b = Geometries.rectangle(1.2, -0.5, 1.8, 0.5);\n        assertFalse(Intersects.lineIntersectsRectangle.call(a, b));\n    }\n\n    @Test\n    public void testLineIntersectsCircle() {\n        Line a = Geometries.line(-1, 0, 1, 0);\n        Circle c = Geometries.circle(0, 0.5, 1);\n        assertTrue(Intersects.lineIntersectsCircle.call(a, c));\n    }\n\n    @Test\n    public void testLineDoesNotIntersectCircle() {\n        Line a = Geometries.line(-1, 0, 1, 0);\n        Circle c = Geometries.circle(0, 0.5, 0.4);\n        assertFalse(Intersects.lineIntersectsCircle.call(a, c));\n    }\n\n    @Test\n    public void testLineDoesNotIntersectCircleEast() {\n        Line a = Geometries.line(-1, 0, 1, 0);\n        Circle c = Geometries.circle(1.5, 0, 0.4);\n        assertFalse(Intersects.lineIntersectsCircle.call(a, c));\n    }\n\n    @Test\n    public void testLineDoesIntersectCircleEast() {\n        Line a = Geometries.line(-1, 0, 1, 0);\n        Circle c = Geometries.circle(1.5, 0, 0.6);\n        assertTrue(Intersects.lineIntersectsCircle.call(a, c));\n    }\n\n    @Test\n    public void testLineDoesNotIntersectCircleWest() {\n        Line a = Geometries.line(-1, 0, 1, 0);\n        Circle c = Geometries.circle(-1.5, 0, 0.4);\n        assertFalse(Intersects.lineIntersectsCircle.call(a, c));\n    }\n\n    @Test\n    public void testLineDoesIntersectCircleWest() {\n        Line a = Geometries.line(-1, 0, 1, 0);\n        Circle c = Geometries.circle(-1.5, 0, 0.6);\n        assertTrue(Intersects.lineIntersectsCircle.call(a, c));\n    }\n\n    @Test\n    public void testLineDoesNotIntersectCircleNorth() {\n        Line a = Geometries.line(-1, 0, 1, 0);\n        Circle c = Geometries.circle(0, 1.5, 0.4);\n        assertFalse(Intersects.lineIntersectsCircle.call(a, c));\n    }\n\n    @Test\n    public void testLineDoesNotIntersectCircleSouth() {\n        Line a = Geometries.line(-1, 0, 1, 0);\n        Circle c = Geometries.circle(0, 1.5, 0.4);\n        assertFalse(Intersects.lineIntersectsCircle.call(a, c));\n    }\n\n    @Test\n    public void testLineDoesIntersectCircleSouth() {\n        Line a = Geometries.line(-1, 0, 1, 0);\n        Circle c = Geometries.circle(0, 1.5, 0.6);\n        assertFalse(Intersects.lineIntersectsCircle.call(a, c));\n    }\n\n    @Test\n    public void testLineMbr() {\n        Line a = Geometries.line(-2, 3, 1, -1);\n        Rectangle mbr = a.mbr();\n        assertEquals(-2, mbr.x1(), PRECISION);\n        assertEquals(-1, mbr.y1(), PRECISION);\n        assertEquals(1, mbr.x2(), PRECISION);\n        assertEquals(3, mbr.y2(), PRECISION);\n    }\n\n    @Test\n    public void testLineSameXWithinCircle() {\n        Line a = Geometries.line(1, 2, 1, 4);\n        Circle c = Geometries.circle(1, 3, 2);\n        assertTrue(Intersects.lineIntersectsCircle.call(a, c));\n    }\n\n    @Test\n    public void testLineIsPointWithinCircle() {\n        Line a = Geometries.line(1, 2, 1, 2);\n        Circle c = Geometries.circle(1, 3, 2);\n        assertTrue(Intersects.lineIntersectsCircle.call(a, c));\n    }\n\n    @Test\n    public void testLineIsPointOutsideCircle() {\n        Line a = Geometries.line(1, 10, 1, 10);\n        Circle c = Geometries.circle(1, 3, 2);\n        assertFalse(Intersects.lineIntersectsCircle.call(a, c));\n    }\n\n    @Test\n    public void testLineDistanceToRectangle() {\n        Line a = Geometries.line(1, 2, 1, 2);\n        Rectangle r = Geometries.rectangle(3, 3, 7, 7);\n        assertEquals(Math.sqrt(5), a.distance(r), PRECISION);\n    }\n\n    @Test\n    public void testLineDistanceToRectangleIsZeroWhenOneEndIsInside() {\n        Line a = Geometries.line(1, 2, 4, 4);\n        Rectangle r = Geometries.rectangle(3, 3, 7, 7);\n        assertEquals(0, a.distance(r), PRECISION);\n    }\n\n    @Test\n    public void testLineDistanceToRectangleIsZeroWhenOtherEndIsInside() {\n        Line a = Geometries.line(4, 4, 1, 2);\n        Rectangle r = Geometries.rectangle(3, 3, 7, 7);\n        assertEquals(0, a.distance(r), PRECISION);\n    }\n\n    @Test\n    public void testLineDistanceToRectangleIsZeroWhenContainsWestEdge() {\n        Line a = Geometries.line(3, 1, 3, 10);\n        Rectangle r = Geometries.rectangle(3, 3, 7, 7);\n        assertEquals(0, a.distance(r), PRECISION);\n    }\n\n    @Test\n    public void testLineDistanceToRectangleIsZeroWhenContainsNorthEdge() {\n        Line a = Geometries.line(2, 7, 10, 7);\n        Rectangle r = Geometries.rectangle(3, 3, 7, 7);\n        assertEquals(0, a.distance(r), PRECISION);\n    }\n\n    @Test\n    public void testLineDistanceToRectangleIsZeroWhenContainsSouthEdge() {\n        Line a = Geometries.line(2, 3, 10, 3);\n        Rectangle r = Geometries.rectangle(3, 3, 7, 7);\n        assertEquals(0, a.distance(r), PRECISION);\n    }\n\n    @Test\n    public void testLineDistanceToRectangleIsZeroWhenContainsEastEdge() {\n        Line a = Geometries.line(7, 1, 7, 10);\n        Rectangle r = Geometries.rectangle(3, 3, 7, 7);\n        assertEquals(0, a.distance(r), PRECISION);\n    }\n\n    @Test\n    public void testLineDoesNotIntersectsPoint() {\n        assertFalse(Geometries.line(1.5, 1.5, 2.6, 2.5).intersects(point(2, 2)));\n    }\n\n    @Test\n    public void testLineDoesIntersectPoint() {\n        assertTrue(Geometries.line(1.5, 1.5, 2.5, 2.5).intersects(point(2, 2)));\n    }\n    \n    @Test\n    public void testLineDoubleIntersectsWithHorizontalLine() {\n        {  // test expectation on Line2D.Double.intersectsLine which we depend on \n            Line2D.Double line = new Line2D.Double(35.0d, -25.0d, 45.0d, -25.0d);\n            assertTrue(line.intersectsLine(40.0d, -20.0d, 45.0d, -40.0d));\n        }\n        {\n            Line line = Geometries.line(40.0d, -20.0d, 45.0d, -40.0d);\n            Line horizontalLine = Geometries.line(35.0d, -25.0d, 45.0d, -25.0d);\n            \n            assertTrue(line.intersects(horizontalLine.mbr()));\n        }\n    }\n    \n    @Test\n    public void testLineFloatIntersectsWithHorizontalLine() {\n        {  // test expectation on Line2D.Double.intersectsLine which we depend on \n            Line2D.Float line = new Line2D.Float(35.0f, -25.0f, 45.0f, -25.0f);\n            assertTrue(line.intersectsLine(40.0f, -20.0f, 45.0f, -40.0f));\n        }\n        {\n            Line line = Geometries.line(40.0f, -20.0f, 45.0f, -40.0f);\n            Line horizontalLine = Geometries.line(35.0f, -25.0f, 45.0f, -25.0f);\n            \n            assertTrue(line.intersects(horizontalLine.mbr()));\n        }\n    }\n\n}", "definition": "public final class LineTest", "class_docstring": "", "name": "LineTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "fields": [{"attribute_expression": "private static final double PRECISION = 0.00001;", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "double", "name": "PRECISION = 0.00001", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @Test\n    public void testDoesIntersectOtherLine() {\n        Line a = Geometries.line(-1, 0, 1, 0);\n        Line b = Geometries.line(0, -1, 0, 1);\n        assertTrue(Intersects.lineIntersectsLine.call(a, b));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testDoesIntersectOtherLine", "params": [], "body": "                                             {\n        Line a = Geometries.line(-1, 0, 1, 0);\n        Line b = Geometries.line(0, -1, 0, 1);\n        assertTrue(Intersects.lineIntersectsLine.call(a, b));\n    }", "signature": "@Test\n    public void testDoesIntersectOtherLine()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testDoesNotIntersectLine() {\n        Line a = Geometries.line(-1, 0, 1, 0);\n        Line b = Geometries.line(1.1, -1, 1.1, 1);\n        assertFalse(Intersects.lineIntersectsLine.call(a, b));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testDoesNotIntersectLine", "params": [], "body": "                                           {\n        Line a = Geometries.line(-1, 0, 1, 0);\n        Line b = Geometries.line(1.1, -1, 1.1, 1);\n        assertFalse(Intersects.lineIntersectsLine.call(a, b));\n    }", "signature": "@Test\n    public void testDoesNotIntersectLine()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testDoesIntersectRectangle() {\n        Line a = Geometries.line(-1, 0, 1, 0);\n        Rectangle b = Geometries.rectangle(0.2, -0.5, 0.8, 0.5);\n        assertTrue(Intersects.lineIntersectsRectangle.call(a, b));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testDoesIntersectRectangle", "params": [], "body": "                                             {\n        Line a = Geometries.line(-1, 0, 1, 0);\n        Rectangle b = Geometries.rectangle(0.2, -0.5, 0.8, 0.5);\n        assertTrue(Intersects.lineIntersectsRectangle.call(a, b));\n    }", "signature": "@Test\n    public void testDoesIntersectRectangle()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testDoesNotIntersectRectangle() {\n        Line a = Geometries.line(-1, 0, 1, 0);\n        Rectangle b = Geometries.rectangle(1.2, -0.5, 1.8, 0.5);\n        assertFalse(Intersects.lineIntersectsRectangle.call(a, b));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testDoesNotIntersectRectangle", "params": [], "body": "                                                {\n        Line a = Geometries.line(-1, 0, 1, 0);\n        Rectangle b = Geometries.rectangle(1.2, -0.5, 1.8, 0.5);\n        assertFalse(Intersects.lineIntersectsRectangle.call(a, b));\n    }", "signature": "@Test\n    public void testDoesNotIntersectRectangle()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testLineIntersectsCircle() {\n        Line a = Geometries.line(-1, 0, 1, 0);\n        Circle c = Geometries.circle(0, 0.5, 1);\n        assertTrue(Intersects.lineIntersectsCircle.call(a, c));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testLineIntersectsCircle", "params": [], "body": "                                           {\n        Line a = Geometries.line(-1, 0, 1, 0);\n        Circle c = Geometries.circle(0, 0.5, 1);\n        assertTrue(Intersects.lineIntersectsCircle.call(a, c));\n    }", "signature": "@Test\n    public void testLineIntersectsCircle()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testLineDoesNotIntersectCircle() {\n        Line a = Geometries.line(-1, 0, 1, 0);\n        Circle c = Geometries.circle(0, 0.5, 0.4);\n        assertFalse(Intersects.lineIntersectsCircle.call(a, c));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testLineDoesNotIntersectCircle", "params": [], "body": "                                                 {\n        Line a = Geometries.line(-1, 0, 1, 0);\n        Circle c = Geometries.circle(0, 0.5, 0.4);\n        assertFalse(Intersects.lineIntersectsCircle.call(a, c));\n    }", "signature": "@Test\n    public void testLineDoesNotIntersectCircle()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testLineDoesNotIntersectCircleEast() {\n        Line a = Geometries.line(-1, 0, 1, 0);\n        Circle c = Geometries.circle(1.5, 0, 0.4);\n        assertFalse(Intersects.lineIntersectsCircle.call(a, c));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testLineDoesNotIntersectCircleEast", "params": [], "body": "                                                     {\n        Line a = Geometries.line(-1, 0, 1, 0);\n        Circle c = Geometries.circle(1.5, 0, 0.4);\n        assertFalse(Intersects.lineIntersectsCircle.call(a, c));\n    }", "signature": "@Test\n    public void testLineDoesNotIntersectCircleEast()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testLineDoesIntersectCircleEast() {\n        Line a = Geometries.line(-1, 0, 1, 0);\n        Circle c = Geometries.circle(1.5, 0, 0.6);\n        assertTrue(Intersects.lineIntersectsCircle.call(a, c));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testLineDoesIntersectCircleEast", "params": [], "body": "                                                  {\n        Line a = Geometries.line(-1, 0, 1, 0);\n        Circle c = Geometries.circle(1.5, 0, 0.6);\n        assertTrue(Intersects.lineIntersectsCircle.call(a, c));\n    }", "signature": "@Test\n    public void testLineDoesIntersectCircleEast()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testLineDoesNotIntersectCircleWest() {\n        Line a = Geometries.line(-1, 0, 1, 0);\n        Circle c = Geometries.circle(-1.5, 0, 0.4);\n        assertFalse(Intersects.lineIntersectsCircle.call(a, c));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testLineDoesNotIntersectCircleWest", "params": [], "body": "                                                     {\n        Line a = Geometries.line(-1, 0, 1, 0);\n        Circle c = Geometries.circle(-1.5, 0, 0.4);\n        assertFalse(Intersects.lineIntersectsCircle.call(a, c));\n    }", "signature": "@Test\n    public void testLineDoesNotIntersectCircleWest()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testLineDoesIntersectCircleWest() {\n        Line a = Geometries.line(-1, 0, 1, 0);\n        Circle c = Geometries.circle(-1.5, 0, 0.6);\n        assertTrue(Intersects.lineIntersectsCircle.call(a, c));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testLineDoesIntersectCircleWest", "params": [], "body": "                                                  {\n        Line a = Geometries.line(-1, 0, 1, 0);\n        Circle c = Geometries.circle(-1.5, 0, 0.6);\n        assertTrue(Intersects.lineIntersectsCircle.call(a, c));\n    }", "signature": "@Test\n    public void testLineDoesIntersectCircleWest()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testLineDoesNotIntersectCircleNorth() {\n        Line a = Geometries.line(-1, 0, 1, 0);\n        Circle c = Geometries.circle(0, 1.5, 0.4);\n        assertFalse(Intersects.lineIntersectsCircle.call(a, c));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testLineDoesNotIntersectCircleNorth", "params": [], "body": "                                                      {\n        Line a = Geometries.line(-1, 0, 1, 0);\n        Circle c = Geometries.circle(0, 1.5, 0.4);\n        assertFalse(Intersects.lineIntersectsCircle.call(a, c));\n    }", "signature": "@Test\n    public void testLineDoesNotIntersectCircleNorth()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testLineDoesNotIntersectCircleSouth() {\n        Line a = Geometries.line(-1, 0, 1, 0);\n        Circle c = Geometries.circle(0, 1.5, 0.4);\n        assertFalse(Intersects.lineIntersectsCircle.call(a, c));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testLineDoesNotIntersectCircleSouth", "params": [], "body": "                                                      {\n        Line a = Geometries.line(-1, 0, 1, 0);\n        Circle c = Geometries.circle(0, 1.5, 0.4);\n        assertFalse(Intersects.lineIntersectsCircle.call(a, c));\n    }", "signature": "@Test\n    public void testLineDoesNotIntersectCircleSouth()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testLineDoesIntersectCircleSouth() {\n        Line a = Geometries.line(-1, 0, 1, 0);\n        Circle c = Geometries.circle(0, 1.5, 0.6);\n        assertFalse(Intersects.lineIntersectsCircle.call(a, c));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testLineDoesIntersectCircleSouth", "params": [], "body": "                                                   {\n        Line a = Geometries.line(-1, 0, 1, 0);\n        Circle c = Geometries.circle(0, 1.5, 0.6);\n        assertFalse(Intersects.lineIntersectsCircle.call(a, c));\n    }", "signature": "@Test\n    public void testLineDoesIntersectCircleSouth()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testLineMbr() {\n        Line a = Geometries.line(-2, 3, 1, -1);\n        Rectangle mbr = a.mbr();\n        assertEquals(-2, mbr.x1(), PRECISION);\n        assertEquals(-1, mbr.y1(), PRECISION);\n        assertEquals(1, mbr.x2(), PRECISION);\n        assertEquals(3, mbr.y2(), PRECISION);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testLineMbr", "params": [], "body": "                              {\n        Line a = Geometries.line(-2, 3, 1, -1);\n        Rectangle mbr = a.mbr();\n        assertEquals(-2, mbr.x1(), PRECISION);\n        assertEquals(-1, mbr.y1(), PRECISION);\n        assertEquals(1, mbr.x2(), PRECISION);\n        assertEquals(3, mbr.y2(), PRECISION);\n    }", "signature": "@Test\n    public void testLineMbr()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testLineSameXWithinCircle() {\n        Line a = Geometries.line(1, 2, 1, 4);\n        Circle c = Geometries.circle(1, 3, 2);\n        assertTrue(Intersects.lineIntersectsCircle.call(a, c));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testLineSameXWithinCircle", "params": [], "body": "                                            {\n        Line a = Geometries.line(1, 2, 1, 4);\n        Circle c = Geometries.circle(1, 3, 2);\n        assertTrue(Intersects.lineIntersectsCircle.call(a, c));\n    }", "signature": "@Test\n    public void testLineSameXWithinCircle()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testLineIsPointWithinCircle() {\n        Line a = Geometries.line(1, 2, 1, 2);\n        Circle c = Geometries.circle(1, 3, 2);\n        assertTrue(Intersects.lineIntersectsCircle.call(a, c));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testLineIsPointWithinCircle", "params": [], "body": "                                              {\n        Line a = Geometries.line(1, 2, 1, 2);\n        Circle c = Geometries.circle(1, 3, 2);\n        assertTrue(Intersects.lineIntersectsCircle.call(a, c));\n    }", "signature": "@Test\n    public void testLineIsPointWithinCircle()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testLineIsPointOutsideCircle() {\n        Line a = Geometries.line(1, 10, 1, 10);\n        Circle c = Geometries.circle(1, 3, 2);\n        assertFalse(Intersects.lineIntersectsCircle.call(a, c));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testLineIsPointOutsideCircle", "params": [], "body": "                                               {\n        Line a = Geometries.line(1, 10, 1, 10);\n        Circle c = Geometries.circle(1, 3, 2);\n        assertFalse(Intersects.lineIntersectsCircle.call(a, c));\n    }", "signature": "@Test\n    public void testLineIsPointOutsideCircle()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testLineDistanceToRectangle() {\n        Line a = Geometries.line(1, 2, 1, 2);\n        Rectangle r = Geometries.rectangle(3, 3, 7, 7);\n        assertEquals(Math.sqrt(5), a.distance(r), PRECISION);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testLineDistanceToRectangle", "params": [], "body": "                                              {\n        Line a = Geometries.line(1, 2, 1, 2);\n        Rectangle r = Geometries.rectangle(3, 3, 7, 7);\n        assertEquals(Math.sqrt(5), a.distance(r), PRECISION);\n    }", "signature": "@Test\n    public void testLineDistanceToRectangle()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testLineDistanceToRectangleIsZeroWhenOneEndIsInside() {\n        Line a = Geometries.line(1, 2, 4, 4);\n        Rectangle r = Geometries.rectangle(3, 3, 7, 7);\n        assertEquals(0, a.distance(r), PRECISION);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testLineDistanceToRectangleIsZeroWhenOneEndIsInside", "params": [], "body": "                                                                      {\n        Line a = Geometries.line(1, 2, 4, 4);\n        Rectangle r = Geometries.rectangle(3, 3, 7, 7);\n        assertEquals(0, a.distance(r), PRECISION);\n    }", "signature": "@Test\n    public void testLineDistanceToRectangleIsZeroWhenOneEndIsInside()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testLineDistanceToRectangleIsZeroWhenOtherEndIsInside() {\n        Line a = Geometries.line(4, 4, 1, 2);\n        Rectangle r = Geometries.rectangle(3, 3, 7, 7);\n        assertEquals(0, a.distance(r), PRECISION);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testLineDistanceToRectangleIsZeroWhenOtherEndIsInside", "params": [], "body": "                                                                        {\n        Line a = Geometries.line(4, 4, 1, 2);\n        Rectangle r = Geometries.rectangle(3, 3, 7, 7);\n        assertEquals(0, a.distance(r), PRECISION);\n    }", "signature": "@Test\n    public void testLineDistanceToRectangleIsZeroWhenOtherEndIsInside()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testLineDistanceToRectangleIsZeroWhenContainsWestEdge() {\n        Line a = Geometries.line(3, 1, 3, 10);\n        Rectangle r = Geometries.rectangle(3, 3, 7, 7);\n        assertEquals(0, a.distance(r), PRECISION);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testLineDistanceToRectangleIsZeroWhenContainsWestEdge", "params": [], "body": "                                                                        {\n        Line a = Geometries.line(3, 1, 3, 10);\n        Rectangle r = Geometries.rectangle(3, 3, 7, 7);\n        assertEquals(0, a.distance(r), PRECISION);\n    }", "signature": "@Test\n    public void testLineDistanceToRectangleIsZeroWhenContainsWestEdge()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testLineDistanceToRectangleIsZeroWhenContainsNorthEdge() {\n        Line a = Geometries.line(2, 7, 10, 7);\n        Rectangle r = Geometries.rectangle(3, 3, 7, 7);\n        assertEquals(0, a.distance(r), PRECISION);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testLineDistanceToRectangleIsZeroWhenContainsNorthEdge", "params": [], "body": "                                                                         {\n        Line a = Geometries.line(2, 7, 10, 7);\n        Rectangle r = Geometries.rectangle(3, 3, 7, 7);\n        assertEquals(0, a.distance(r), PRECISION);\n    }", "signature": "@Test\n    public void testLineDistanceToRectangleIsZeroWhenContainsNorthEdge()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testLineDistanceToRectangleIsZeroWhenContainsSouthEdge() {\n        Line a = Geometries.line(2, 3, 10, 3);\n        Rectangle r = Geometries.rectangle(3, 3, 7, 7);\n        assertEquals(0, a.distance(r), PRECISION);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testLineDistanceToRectangleIsZeroWhenContainsSouthEdge", "params": [], "body": "                                                                         {\n        Line a = Geometries.line(2, 3, 10, 3);\n        Rectangle r = Geometries.rectangle(3, 3, 7, 7);\n        assertEquals(0, a.distance(r), PRECISION);\n    }", "signature": "@Test\n    public void testLineDistanceToRectangleIsZeroWhenContainsSouthEdge()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testLineDistanceToRectangleIsZeroWhenContainsEastEdge() {\n        Line a = Geometries.line(7, 1, 7, 10);\n        Rectangle r = Geometries.rectangle(3, 3, 7, 7);\n        assertEquals(0, a.distance(r), PRECISION);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testLineDistanceToRectangleIsZeroWhenContainsEastEdge", "params": [], "body": "                                                                        {\n        Line a = Geometries.line(7, 1, 7, 10);\n        Rectangle r = Geometries.rectangle(3, 3, 7, 7);\n        assertEquals(0, a.distance(r), PRECISION);\n    }", "signature": "@Test\n    public void testLineDistanceToRectangleIsZeroWhenContainsEastEdge()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testLineDoesNotIntersectsPoint() {\n        assertFalse(Geometries.line(1.5, 1.5, 2.6, 2.5).intersects(point(2, 2)));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testLineDoesNotIntersectsPoint", "params": [], "body": "                                                 {\n        assertFalse(Geometries.line(1.5, 1.5, 2.6, 2.5).intersects(point(2, 2)));\n    }", "signature": "@Test\n    public void testLineDoesNotIntersectsPoint()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testLineDoesIntersectPoint() {\n        assertTrue(Geometries.line(1.5, 1.5, 2.5, 2.5).intersects(point(2, 2)));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testLineDoesIntersectPoint", "params": [], "body": "                                             {\n        assertTrue(Geometries.line(1.5, 1.5, 2.5, 2.5).intersects(point(2, 2)));\n    }", "signature": "@Test\n    public void testLineDoesIntersectPoint()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testLineDoubleIntersectsWithHorizontalLine() {\n        {  // test expectation on Line2D.Double.intersectsLine which we depend on \n            Line2D.Double line = new Line2D.Double(35.0d, -25.0d, 45.0d, -25.0d);\n            assertTrue(line.intersectsLine(40.0d, -20.0d, 45.0d, -40.0d));\n        }\n        {\n            Line line = Geometries.line(40.0d, -20.0d, 45.0d, -40.0d);\n            Line horizontalLine = Geometries.line(35.0d, -25.0d, 45.0d, -25.0d);\n            \n            assertTrue(line.intersects(horizontalLine.mbr()));\n        }\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testLineDoubleIntersectsWithHorizontalLine", "params": [], "body": "                                                             {\n        {  // test expectation on Line2D.Double.intersectsLine which we depend on \n            Line2D.Double line = new Line2D.Double(35.0d, -25.0d, 45.0d, -25.0d);\n            assertTrue(line.intersectsLine(40.0d, -20.0d, 45.0d, -40.0d));\n        }\n        {\n            Line line = Geometries.line(40.0d, -20.0d, 45.0d, -40.0d);\n            Line horizontalLine = Geometries.line(35.0d, -25.0d, 45.0d, -25.0d);\n            \n            assertTrue(line.intersects(horizontalLine.mbr()));\n        }\n    }", "signature": "@Test\n    public void testLineDoubleIntersectsWithHorizontalLine()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testLineFloatIntersectsWithHorizontalLine() {\n        {  // test expectation on Line2D.Double.intersectsLine which we depend on \n            Line2D.Float line = new Line2D.Float(35.0f, -25.0f, 45.0f, -25.0f);\n            assertTrue(line.intersectsLine(40.0f, -20.0f, 45.0f, -40.0f));\n        }\n        {\n            Line line = Geometries.line(40.0f, -20.0f, 45.0f, -40.0f);\n            Line horizontalLine = Geometries.line(35.0f, -25.0f, 45.0f, -25.0f);\n            \n            assertTrue(line.intersects(horizontalLine.mbr()));\n        }\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testLineFloatIntersectsWithHorizontalLine", "params": [], "body": "                                                            {\n        {  // test expectation on Line2D.Double.intersectsLine which we depend on \n            Line2D.Float line = new Line2D.Float(35.0f, -25.0f, 45.0f, -25.0f);\n            assertTrue(line.intersectsLine(40.0f, -20.0f, 45.0f, -40.0f));\n        }\n        {\n            Line line = Geometries.line(40.0f, -20.0f, 45.0f, -40.0f);\n            Line horizontalLine = Geometries.line(35.0f, -25.0f, 45.0f, -25.0f);\n            \n            assertTrue(line.intersects(horizontalLine.mbr()));\n        }\n    }", "signature": "@Test\n    public void testLineFloatIntersectsWithHorizontalLine()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/com/github/davidmoten/rtree/geometry/internal/GeometryUtilTest.java", "original_string": "package com.github.davidmoten.rtree.geometry.internal;\n\nimport org.junit.Test;\n\nimport com.github.davidmoten.junit.Asserts;\n\npublic class GeometryUtilTest {\n    \n    @Test\n    public void isUtilityClass() {\n        Asserts.assertIsUtilityClass(GeometryUtil.class);\n    }\n\n}\n", "file_hash": "50dd121756eb5ede8e884b281e726243a0cb4b311fc446cea16dbfc356f9d75b", "file_docstring": "", "contexts": ["package com.github.davidmoten.rtree.geometry.internal;", "import org.junit.Test;", "import com.github.davidmoten.junit.Asserts;"], "methods": [], "classes": [{"original_string": "public class GeometryUtilTest {\n    \n    @Test\n    public void isUtilityClass() {\n        Asserts.assertIsUtilityClass(GeometryUtil.class);\n    }\n\n}", "definition": "public class GeometryUtilTest", "class_docstring": "", "name": "GeometryUtilTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @Test\n    public void isUtilityClass() {\n        Asserts.assertIsUtilityClass(GeometryUtil.class);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "isUtilityClass", "params": [], "body": "                                 {\n        Asserts.assertIsUtilityClass(GeometryUtil.class);\n    }", "signature": "@Test\n    public void isUtilityClass()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/com/github/davidmoten/rtree/internal/Line2D_linesIntersectTest.java", "original_string": "\npackage com.github.davidmoten.rtree.internal;\n\nimport static org.junit.Assert.assertFalse;\nimport static org.junit.Assert.assertTrue;\nimport org.junit.Test;\n\npublic class Line2D_linesIntersectTest {\n\n    @Test\n    public void testLinesIntersect_IntersectingLines() {\n        assertTrue(Line2D.linesIntersect(0, 0, 2, 2, 0, 2, 2, 0));\n    }\n\n    @Test\n    public void testLinesIntersect_NonIntersectingLines() {\n        assertFalse(Line2D.linesIntersect(0, 0, 2, 2, 3, 3, 4, 4));\n    }\n\n    @Test\n    public void testLinesIntersect_CollinearNonIntersectingLines() {\n        assertFalse(Line2D.linesIntersect(0, 0, 2, 2, 3, 3, 5, 5));\n    }\n\n    @Test\n    public void testLinesIntersect_TouchingAtEndpoint() {\n        assertTrue(Line2D.linesIntersect(0, 0, 2, 2, 2, 2, 4, 4));\n    }\n}\n", "file_hash": "50e414eb6c6f48e8d6de7d8de4517dc289d4e994fa670f5767371e7ca02ee3b1", "file_docstring": "", "contexts": ["package com.github.davidmoten.rtree.internal;", "import static org.junit.Assert.assertFalse;", "import static org.junit.Assert.assertTrue;", "import org.junit.Test;"], "methods": [], "classes": [{"original_string": "public class Line2D_linesIntersectTest {\n\n    @Test\n    public void testLinesIntersect_IntersectingLines() {\n        assertTrue(Line2D.linesIntersect(0, 0, 2, 2, 0, 2, 2, 0));\n    }\n\n    @Test\n    public void testLinesIntersect_NonIntersectingLines() {\n        assertFalse(Line2D.linesIntersect(0, 0, 2, 2, 3, 3, 4, 4));\n    }\n\n    @Test\n    public void testLinesIntersect_CollinearNonIntersectingLines() {\n        assertFalse(Line2D.linesIntersect(0, 0, 2, 2, 3, 3, 5, 5));\n    }\n\n    @Test\n    public void testLinesIntersect_TouchingAtEndpoint() {\n        assertTrue(Line2D.linesIntersect(0, 0, 2, 2, 2, 2, 4, 4));\n    }\n}", "definition": "public class Line2D_linesIntersectTest", "class_docstring": "", "name": "Line2D_linesIntersectTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @Test\n    public void testLinesIntersect_IntersectingLines() {\n        assertTrue(Line2D.linesIntersect(0, 0, 2, 2, 0, 2, 2, 0));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testLinesIntersect_IntersectingLines", "params": [], "body": "                                                       {\n        assertTrue(Line2D.linesIntersect(0, 0, 2, 2, 0, 2, 2, 0));\n    }", "signature": "@Test\n    public void testLinesIntersect_IntersectingLines()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testLinesIntersect_NonIntersectingLines() {\n        assertFalse(Line2D.linesIntersect(0, 0, 2, 2, 3, 3, 4, 4));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testLinesIntersect_NonIntersectingLines", "params": [], "body": "                                                          {\n        assertFalse(Line2D.linesIntersect(0, 0, 2, 2, 3, 3, 4, 4));\n    }", "signature": "@Test\n    public void testLinesIntersect_NonIntersectingLines()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testLinesIntersect_CollinearNonIntersectingLines() {\n        assertFalse(Line2D.linesIntersect(0, 0, 2, 2, 3, 3, 5, 5));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testLinesIntersect_CollinearNonIntersectingLines", "params": [], "body": "                                                                   {\n        assertFalse(Line2D.linesIntersect(0, 0, 2, 2, 3, 3, 5, 5));\n    }", "signature": "@Test\n    public void testLinesIntersect_CollinearNonIntersectingLines()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testLinesIntersect_TouchingAtEndpoint() {\n        assertTrue(Line2D.linesIntersect(0, 0, 2, 2, 2, 2, 4, 4));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testLinesIntersect_TouchingAtEndpoint", "params": [], "body": "                                                        {\n        assertTrue(Line2D.linesIntersect(0, 0, 2, 2, 2, 2, 4, 4));\n    }", "signature": "@Test\n    public void testLinesIntersect_TouchingAtEndpoint()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/com/github/davidmoten/rtree/internal/NonLeafDefault_geometryTest.java", "original_string": "\npackage com.github.davidmoten.rtree.internal;\n\nimport static org.junit.Assert.assertEquals;\n\nimport java.util.Collections;\nimport java.util.List;\n\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport com.github.davidmoten.rtree.Context;\nimport com.github.davidmoten.rtree.Node;\nimport com.github.davidmoten.rtree.geometry.Geometry;\nimport com.github.davidmoten.rtree.geometry.Rectangle;\nimport com.github.davidmoten.rtree.internal.Util;\n\npublic class NonLeafDefault_geometryTest {\n\n    private NonLeafDefault<Object, Rectangle> nonLeaf;\n    private Rectangle expectedMbr;\n\n    @Before\n    public void setUp() {\n        Rectangle childMbr = Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util.mbr(Collections.singleton(Util", "file_hash": "45f928adcbcfc90928f4096ca2a6b3987b5b0d0f7b02652ba609ce37c18614e2", "file_docstring": "", "contexts": ["package com.github.davidmoten.rtree.internal;", "import static org.junit.Assert.assertEquals;", "import java.util.Collections;", "import java.util.List;", "import org.junit.Before;", "import org.junit.Test;", "import com.github.davidmoten.rtree.Context;", "import com.github.davidmoten.rtree.Node;", "import com.github.davidmoten.rtree.geometry.Geometry;", "import com.github.davidmoten.rtree.geometry.Rectangle;", "import com.github.davidmoten.rtree.internal.Util;"], "methods": [], "classes": [], "interfaces": [], "records": []}, {"relative_path": "src/test/java/com/github/davidmoten/rtree/internal/Line2D_ptSegDistSqTest.java", "original_string": "\npackage com.github.davidmoten.rtree.internal;\n\nimport static org.junit.Assert.assertEquals;\nimport org.junit.Test;\n\npublic class Line2D_ptSegDistSqTest {\n\n    @Test\n    public void testPtSegDistSq_PointOnSideOfX1Y1() {\n        double result = Line2D.ptSegDistSq(0, 0, 2, 2, -1, -1);\n        assertEquals(2.0, result, 0.0001);\n    }\n\n    @Test\n    public void testPtSegDistSq_PointOnSideOfX2Y2() {\n        double result = Line2D.ptSegDistSq(0, 0, 2, 2, 3, 3);\n        assertEquals(2.0, result, 0.0001);\n    }\n\n    @Test\n    public void testPtSegDistSq_PointBetweenX1Y1AndX2Y2() {\n        double result = Line2D.ptSegDistSq(0, 0, 2, 2, 1, 1);\n        assertEquals(0.0, result, 0.0001);\n    }\n}\n", "file_hash": "1e48512940918d594ff82ff1e0045996eff7c9845721212ce31c5024b423c5a4", "file_docstring": "", "contexts": ["package com.github.davidmoten.rtree.internal;", "import static org.junit.Assert.assertEquals;", "import org.junit.Test;"], "methods": [], "classes": [{"original_string": "public class Line2D_ptSegDistSqTest {\n\n    @Test\n    public void testPtSegDistSq_PointOnSideOfX1Y1() {\n        double result = Line2D.ptSegDistSq(0, 0, 2, 2, -1, -1);\n        assertEquals(2.0, result, 0.0001);\n    }\n\n    @Test\n    public void testPtSegDistSq_PointOnSideOfX2Y2() {\n        double result = Line2D.ptSegDistSq(0, 0, 2, 2, 3, 3);\n        assertEquals(2.0, result, 0.0001);\n    }\n\n    @Test\n    public void testPtSegDistSq_PointBetweenX1Y1AndX2Y2() {\n        double result = Line2D.ptSegDistSq(0, 0, 2, 2, 1, 1);\n        assertEquals(0.0, result, 0.0001);\n    }\n}", "definition": "public class Line2D_ptSegDistSqTest", "class_docstring": "", "name": "Line2D_ptSegDistSqTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @Test\n    public void testPtSegDistSq_PointOnSideOfX1Y1() {\n        double result = Line2D.ptSegDistSq(0, 0, 2, 2, -1, -1);\n        assertEquals(2.0, result, 0.0001);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testPtSegDistSq_PointOnSideOfX1Y1", "params": [], "body": "                                                    {\n        double result = Line2D.ptSegDistSq(0, 0, 2, 2, -1, -1);\n        assertEquals(2.0, result, 0.0001);\n    }", "signature": "@Test\n    public void testPtSegDistSq_PointOnSideOfX1Y1()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testPtSegDistSq_PointOnSideOfX2Y2() {\n        double result = Line2D.ptSegDistSq(0, 0, 2, 2, 3, 3);\n        assertEquals(2.0, result, 0.0001);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testPtSegDistSq_PointOnSideOfX2Y2", "params": [], "body": "                                                    {\n        double result = Line2D.ptSegDistSq(0, 0, 2, 2, 3, 3);\n        assertEquals(2.0, result, 0.0001);\n    }", "signature": "@Test\n    public void testPtSegDistSq_PointOnSideOfX2Y2()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testPtSegDistSq_PointBetweenX1Y1AndX2Y2() {\n        double result = Line2D.ptSegDistSq(0, 0, 2, 2, 1, 1);\n        assertEquals(0.0, result, 0.0001);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testPtSegDistSq_PointBetweenX1Y1AndX2Y2", "params": [], "body": "                                                          {\n        double result = Line2D.ptSegDistSq(0, 0, 2, 2, 1, 1);\n        assertEquals(0.0, result, 0.0001);\n    }", "signature": "@Test\n    public void testPtSegDistSq_PointBetweenX1Y1AndX2Y2()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/com/github/davidmoten/rtree/internal/RectangleUtilTest.java", "original_string": "package com.github.davidmoten.rtree.internal;\n\nimport org.junit.Test;\n\nimport com.github.davidmoten.junit.Asserts;\n\npublic class RectangleUtilTest {\n\n    @Test\n    public void isUtilityClass() {\n        Asserts.assertIsUtilityClass(RectangleUtil.class);\n    }\n\n}\n", "file_hash": "c4fc4e60cb1e2f48188a4422cb91a75a33adf12f81b4f5adf8540a874fe11cac", "file_docstring": "", "contexts": ["package com.github.davidmoten.rtree.internal;", "import org.junit.Test;", "import com.github.davidmoten.junit.Asserts;"], "methods": [], "classes": [{"original_string": "public class RectangleUtilTest {\n\n    @Test\n    public void isUtilityClass() {\n        Asserts.assertIsUtilityClass(RectangleUtil.class);\n    }\n\n}", "definition": "public class RectangleUtilTest", "class_docstring": "", "name": "RectangleUtilTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @Test\n    public void isUtilityClass() {\n        Asserts.assertIsUtilityClass(RectangleUtil.class);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "isUtilityClass", "params": [], "body": "                                 {\n        Asserts.assertIsUtilityClass(RectangleUtil.class);\n    }", "signature": "@Test\n    public void isUtilityClass()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/com/github/davidmoten/rtree/internal/Util_addTest.java", "original_string": "\npackage com.github.davidmoten.rtree.internal;\n\nimport org.junit.Test;\nimport java.util.Arrays;\nimport java.util.List;\nimport static org.junit.Assert.assertEquals;\n\npublic class Util_addTest {\n\n    @Test\n    public void testAdd() {\n        List<Integer> list = Arrays.asList(1, 2, 3);\n        Integer element = 4;\n        List<Integer> result = Util.add(list, element);\n        assertEquals(Arrays.asList(1, 2, 3, 4), result);\n    }\n}\n", "file_hash": "caebd806509b7284ff5ef7bdd0f4bba60b9eeab652bbba7f5a70800a01bb18a0", "file_docstring": "", "contexts": ["package com.github.davidmoten.rtree.internal;", "import org.junit.Test;", "import java.util.Arrays;", "import java.util.List;", "import static org.junit.Assert.assertEquals;"], "methods": [], "classes": [{"original_string": "public class Util_addTest {\n\n    @Test\n    public void testAdd() {\n        List<Integer> list = Arrays.asList(1, 2, 3);\n        Integer element = 4;\n        List<Integer> result = Util.add(list, element);\n        assertEquals(Arrays.asList(1, 2, 3, 4), result);\n    }\n}", "definition": "public class Util_addTest", "class_docstring": "", "name": "Util_addTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @Test\n    public void testAdd() {\n        List<Integer> list = Arrays.asList(1, 2, 3);\n        Integer element = 4;\n        List<Integer> result = Util.add(list, element);\n        assertEquals(Arrays.asList(1, 2, 3, 4), result);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testAdd", "params": [], "body": "                          {\n        List<Integer> list = Arrays.asList(1, 2, 3);\n        Integer element = 4;\n        List<Integer> result = Util.add(list, element);\n        assertEquals(Arrays.asList(1, 2, 3, 4), result);\n    }", "signature": "@Test\n    public void testAdd()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/com/github/davidmoten/rtree/internal/NonLeafHelperTest.java", "original_string": "package com.github.davidmoten.rtree.internal;\n\nimport org.junit.Test;\n\nimport com.github.davidmoten.junit.Asserts;\n\npublic class NonLeafHelperTest {\n    @Test\n    public void isUtilityClass() {\n        Asserts.assertIsUtilityClass(NonLeafHelper.class);\n    }\n}\n", "file_hash": "157a1332910684a7abbc7d825725bc3d9c7e4b9876faa636c4d86bb36214fafd", "file_docstring": "", "contexts": ["package com.github.davidmoten.rtree.internal;", "import org.junit.Test;", "import com.github.davidmoten.junit.Asserts;"], "methods": [], "classes": [{"original_string": "public class NonLeafHelperTest {\n    @Test\n    public void isUtilityClass() {\n        Asserts.assertIsUtilityClass(NonLeafHelper.class);\n    }\n}", "definition": "public class NonLeafHelperTest", "class_docstring": "", "name": "NonLeafHelperTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @Test\n    public void isUtilityClass() {\n        Asserts.assertIsUtilityClass(NonLeafHelper.class);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "isUtilityClass", "params": [], "body": "                                 {\n        Asserts.assertIsUtilityClass(NonLeafHelper.class);\n    }", "signature": "@Test\n    public void isUtilityClass()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/com/github/davidmoten/rtree/internal/Util_mbrTest.java", "original_string": "\npackage com.github.davidmoten.rtree.internal;\n\nimport com.github.davidmoten.rtree.geometry.Geometries;\nimport com.github.davidmoten.rtree.geometry.HasGeometry;\nimport com.github.davidmoten.rtree.geometry.Rectangle;\nimport org.junit.Test;\n\nimport java.util.Arrays;\nimport java.util.Collection;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.mockito.Mockito.mock;\nimport static org.mockito.Mockito.when;\n\npublic class Util_mbrTest {\n\n    @Test\n    public void testMbrWithSingleItem() {\n        HasGeometry item = mock(HasGeometry.class);\n        Rectangle rect = mock(Rectangle.class);\n        when(item.geometry()).thenReturn(rect);\n        when(rect.mbr()).thenReturn(rect);\n        when(rect.x1()).thenReturn(1.0);\n        when(rect.y1()).thenReturn(2.0);\n        when(rect.x2()).thenReturn(3.0);\n        when(rect.y2()).thenReturn(4.0);\n        when(rect.isDoublePrecision()).thenReturn(false);\n\n        Collection<? extends HasGeometry> items = Arrays.asList(item);\n        Rectangle result = Util.mbr(items);\n\n        assertEquals(Geometries.rectangle(1.0f, 2.0f, 3.0f, 4.0f), result);\n    }\n\n    @Test(expected = IllegalArgumentException.class)\n    public void testMbrWithEmptyCollection() {\n        Collection<? extends HasGeometry> items = Arrays.asList();\n        Util.mbr(items);\n    }\n\n    @Test\n    public void testMbrWithDoublePrecision() {\n        HasGeometry item1 = mock(HasGeometry.class);\n        Rectangle rect1 = mock(Rectangle.class);\n        when(item1.geometry()).thenReturn(rect1);\n        when(rect1.mbr()).thenReturn(rect1);\n        when(rect1.x1()).thenReturn(1.0);\n        when(rect1.y1()).thenReturn(2.0);\n        when(rect1.x2()).thenReturn(3.0);\n        when(rect1.y2()).thenReturn(4.0);\n        when(rect1.isDoublePrecision()).thenReturn(false);\n\n        HasGeometry item2 = mock(HasGeometry.class);\n        Rectangle rect2 = mock(Rectangle.class);\n        when(item2.geometry()).thenReturn(rect2);\n        when(rect2.mbr()).thenReturn(rect2);\n        when(rect2.x1()).thenReturn(0.0);\n        when(rect2.y1()).thenReturn(1.0);\n        when(rect2.x2()).thenReturn(2.0);\n        when(rect2.y2()).thenReturn(3.0);\n        when(rect2.isDoublePrecision()).thenReturn(true);\n\n        Collection<? extends HasGeometry> items = Arrays.asList(item1, item2);\n        Rectangle result = Util.mbr(items);\n\n        assertEquals(Geometries.rectangle(0.0, 1.0, 3.0, 4.0), result);\n    }\n}\n", "file_hash": "e58bbd2322c50121de7a9746aa6586f91562eddc4e9830fd397afacf63c73bfb", "file_docstring": "", "contexts": ["package com.github.davidmoten.rtree.internal;", "import com.github.davidmoten.rtree.geometry.Geometries;", "import com.github.davidmoten.rtree.geometry.HasGeometry;", "import com.github.davidmoten.rtree.geometry.Rectangle;", "import org.junit.Test;", "import java.util.Arrays;", "import java.util.Collection;", "import static org.junit.Assert.assertEquals;", "import static org.mockito.Mockito.mock;", "import static org.mockito.Mockito.when;"], "methods": [], "classes": [{"original_string": "public class Util_mbrTest {\n\n    @Test\n    public void testMbrWithSingleItem() {\n        HasGeometry item = mock(HasGeometry.class);\n        Rectangle rect = mock(Rectangle.class);\n        when(item.geometry()).thenReturn(rect);\n        when(rect.mbr()).thenReturn(rect);\n        when(rect.x1()).thenReturn(1.0);\n        when(rect.y1()).thenReturn(2.0);\n        when(rect.x2()).thenReturn(3.0);\n        when(rect.y2()).thenReturn(4.0);\n        when(rect.isDoublePrecision()).thenReturn(false);\n\n        Collection<? extends HasGeometry> items = Arrays.asList(item);\n        Rectangle result = Util.mbr(items);\n\n        assertEquals(Geometries.rectangle(1.0f, 2.0f, 3.0f, 4.0f), result);\n    }\n\n    @Test(expected = IllegalArgumentException.class)\n    public void testMbrWithEmptyCollection() {\n        Collection<? extends HasGeometry> items = Arrays.asList();\n        Util.mbr(items);\n    }\n\n    @Test\n    public void testMbrWithDoublePrecision() {\n        HasGeometry item1 = mock(HasGeometry.class);\n        Rectangle rect1 = mock(Rectangle.class);\n        when(item1.geometry()).thenReturn(rect1);\n        when(rect1.mbr()).thenReturn(rect1);\n        when(rect1.x1()).thenReturn(1.0);\n        when(rect1.y1()).thenReturn(2.0);\n        when(rect1.x2()).thenReturn(3.0);\n        when(rect1.y2()).thenReturn(4.0);\n        when(rect1.isDoublePrecision()).thenReturn(false);\n\n        HasGeometry item2 = mock(HasGeometry.class);\n        Rectangle rect2 = mock(Rectangle.class);\n        when(item2.geometry()).thenReturn(rect2);\n        when(rect2.mbr()).thenReturn(rect2);\n        when(rect2.x1()).thenReturn(0.0);\n        when(rect2.y1()).thenReturn(1.0);\n        when(rect2.x2()).thenReturn(2.0);\n        when(rect2.y2()).thenReturn(3.0);\n        when(rect2.isDoublePrecision()).thenReturn(true);\n\n        Collection<? extends HasGeometry> items = Arrays.asList(item1, item2);\n        Rectangle result = Util.mbr(items);\n\n        assertEquals(Geometries.rectangle(0.0, 1.0, 3.0, 4.0), result);\n    }\n}", "definition": "public class Util_mbrTest", "class_docstring": "", "name": "Util_mbrTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @Test\n    public void testMbrWithSingleItem() {\n        HasGeometry item = mock(HasGeometry.class);\n        Rectangle rect = mock(Rectangle.class);\n        when(item.geometry()).thenReturn(rect);\n        when(rect.mbr()).thenReturn(rect);\n        when(rect.x1()).thenReturn(1.0);\n        when(rect.y1()).thenReturn(2.0);\n        when(rect.x2()).thenReturn(3.0);\n        when(rect.y2()).thenReturn(4.0);\n        when(rect.isDoublePrecision()).thenReturn(false);\n\n        Collection<? extends HasGeometry> items = Arrays.asList(item);\n        Rectangle result = Util.mbr(items);\n\n        assertEquals(Geometries.rectangle(1.0f, 2.0f, 3.0f, 4.0f), result);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testMbrWithSingleItem", "params": [], "body": "                                        {\n        HasGeometry item = mock(HasGeometry.class);\n        Rectangle rect = mock(Rectangle.class);\n        when(item.geometry()).thenReturn(rect);\n        when(rect.mbr()).thenReturn(rect);\n        when(rect.x1()).thenReturn(1.0);\n        when(rect.y1()).thenReturn(2.0);\n        when(rect.x2()).thenReturn(3.0);\n        when(rect.y2()).thenReturn(4.0);\n        when(rect.isDoublePrecision()).thenReturn(false);\n\n        Collection<? extends HasGeometry> items = Arrays.asList(item);\n        Rectangle result = Util.mbr(items);\n\n        assertEquals(Geometries.rectangle(1.0f, 2.0f, 3.0f, 4.0f), result);\n    }", "signature": "@Test\n    public void testMbrWithSingleItem()"}, {"syntax_pass": true, "original_string": "    @Test(expected = IllegalArgumentException.class)\n    public void testMbrWithEmptyCollection() {\n        Collection<? extends HasGeometry> items = Arrays.asList();\n        Util.mbr(items);\n    }", "docstring": "", "attributes": {"modifiers": "@Test(expected = IllegalArgumentException.class)\n    public", "marker_annotations": [], "non_marker_annotations": ["@Test(expected = IllegalArgumentException.class)", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "testMbrWithEmptyCollection", "params": [], "body": "                                             {\n        Collection<? extends HasGeometry> items = Arrays.asList();\n        Util.mbr(items);\n    }", "signature": "@Test(expected = IllegalArgumentException.class)\n    public void testMbrWithEmptyCollection()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testMbrWithDoublePrecision() {\n        HasGeometry item1 = mock(HasGeometry.class);\n        Rectangle rect1 = mock(Rectangle.class);\n        when(item1.geometry()).thenReturn(rect1);\n        when(rect1.mbr()).thenReturn(rect1);\n        when(rect1.x1()).thenReturn(1.0);\n        when(rect1.y1()).thenReturn(2.0);\n        when(rect1.x2()).thenReturn(3.0);\n        when(rect1.y2()).thenReturn(4.0);\n        when(rect1.isDoublePrecision()).thenReturn(false);\n\n        HasGeometry item2 = mock(HasGeometry.class);\n        Rectangle rect2 = mock(Rectangle.class);\n        when(item2.geometry()).thenReturn(rect2);\n        when(rect2.mbr()).thenReturn(rect2);\n        when(rect2.x1()).thenReturn(0.0);\n        when(rect2.y1()).thenReturn(1.0);\n        when(rect2.x2()).thenReturn(2.0);\n        when(rect2.y2()).thenReturn(3.0);\n        when(rect2.isDoublePrecision()).thenReturn(true);\n\n        Collection<? extends HasGeometry> items = Arrays.asList(item1, item2);\n        Rectangle result = Util.mbr(items);\n\n        assertEquals(Geometries.rectangle(0.0, 1.0, 3.0, 4.0), result);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testMbrWithDoublePrecision", "params": [], "body": "                                             {\n        HasGeometry item1 = mock(HasGeometry.class);\n        Rectangle rect1 = mock(Rectangle.class);\n        when(item1.geometry()).thenReturn(rect1);\n        when(rect1.mbr()).thenReturn(rect1);\n        when(rect1.x1()).thenReturn(1.0);\n        when(rect1.y1()).thenReturn(2.0);\n        when(rect1.x2()).thenReturn(3.0);\n        when(rect1.y2()).thenReturn(4.0);\n        when(rect1.isDoublePrecision()).thenReturn(false);\n\n        HasGeometry item2 = mock(HasGeometry.class);\n        Rectangle rect2 = mock(Rectangle.class);\n        when(item2.geometry()).thenReturn(rect2);\n        when(rect2.mbr()).thenReturn(rect2);\n        when(rect2.x1()).thenReturn(0.0);\n        when(rect2.y1()).thenReturn(1.0);\n        when(rect2.x2()).thenReturn(2.0);\n        when(rect2.y2()).thenReturn(3.0);\n        when(rect2.isDoublePrecision()).thenReturn(true);\n\n        Collection<? extends HasGeometry> items = Arrays.asList(item1, item2);\n        Rectangle result = Util.mbr(items);\n\n        assertEquals(Geometries.rectangle(0.0, 1.0, 3.0, 4.0), result);\n    }", "signature": "@Test\n    public void testMbrWithDoublePrecision()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/com/github/davidmoten/rtree/internal/LeafHelperTest.java", "original_string": "package com.github.davidmoten.rtree.internal;\n\nimport org.junit.Test;\n\nimport com.github.davidmoten.junit.Asserts;\n\npublic class LeafHelperTest {\n\n    @Test\n    public void isUtilityClass() {\n        Asserts.assertIsUtilityClass(LeafHelper.class);\n    }\n\n}\n", "file_hash": "6ce2f99387765b2642a450198d25258cd3d5cbdf3d841cd79f78ee5694551c91", "file_docstring": "", "contexts": ["package com.github.davidmoten.rtree.internal;", "import org.junit.Test;", "import com.github.davidmoten.junit.Asserts;"], "methods": [], "classes": [{"original_string": "public class LeafHelperTest {\n\n    @Test\n    public void isUtilityClass() {\n        Asserts.assertIsUtilityClass(LeafHelper.class);\n    }\n\n}", "definition": "public class LeafHelperTest", "class_docstring": "", "name": "LeafHelperTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @Test\n    public void isUtilityClass() {\n        Asserts.assertIsUtilityClass(LeafHelper.class);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "isUtilityClass", "params": [], "body": "                                 {\n        Asserts.assertIsUtilityClass(LeafHelper.class);\n    }", "signature": "@Test\n    public void isUtilityClass()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/com/github/davidmoten/rtree/internal/Util_removeTest.java", "original_string": "\npackage com.github.davidmoten.rtree.internal;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertTrue;\n\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\n\nimport org.junit.Test;\n\npublic class Util_removeTest {\n\n    @Test\n    public void testRemoveElementsFromList() {\n        List<Integer> list = Arrays.asList(1, 2, 3, 4, 5);\n        List<Integer> elementsToRemove = Arrays.asList(2, 4);\n        List<Integer> expected = Arrays.asList(1, 3, 5);\n\n        List<Integer> result = Util.remove(list, elementsToRemove);\n\n        assertEquals(expected, result);\n    }\n\n    @Test\n    public void testRemoveAllElementsFromList() {\n        List<Integer> list = Arrays.asList(1, 2, 3, 4, 5);\n        List<Integer> elementsToRemove = Arrays.asList(1, 2, 3, 4, 5);\n        List<Integer> expected = Collections.emptyList();\n\n        List<Integer> result = Util.remove(list, elementsToRemove);\n\n        assertEquals(expected, result);\n    }\n\n    @Test\n    public void testRemoveNoElementsFromList() {\n        List<Integer> list = Arrays.asList(1, 2, 3, 4, 5);\n        List<Integer> elementsToRemove = Collections.emptyList();\n        List<Integer> expected = Arrays.asList(1, 2, 3, 4, 5);\n\n        List<Integer> result = Util.remove(list, elementsToRemove);\n\n        assertEquals(expected, result);\n    }\n\n    @Test\n    public void testRemoveNonExistentElementsFromList() {\n        List<Integer> list = Arrays.asList(1, 2, 3, 4, 5);\n        List<Integer> elementsToRemove = Arrays.asList(6, 7);\n        List<Integer> expected = Arrays.asList(1, 2, 3, 4, 5);\n\n        List<Integer> result = Util.remove(list, elementsToRemove);\n\n        assertEquals(expected, result);\n    }\n}\n", "file_hash": "4510fc743acd93b634e6d213dfd87be906f7b46f18daed1e0783d633c449651f", "file_docstring": "", "contexts": ["package com.github.davidmoten.rtree.internal;", "import static org.junit.Assert.assertEquals;", "import static org.junit.Assert.assertTrue;", "import java.util.Arrays;", "import java.util.Collections;", "import java.util.List;", "import org.junit.Test;"], "methods": [], "classes": [{"original_string": "public class Util_removeTest {\n\n    @Test\n    public void testRemoveElementsFromList() {\n        List<Integer> list = Arrays.asList(1, 2, 3, 4, 5);\n        List<Integer> elementsToRemove = Arrays.asList(2, 4);\n        List<Integer> expected = Arrays.asList(1, 3, 5);\n\n        List<Integer> result = Util.remove(list, elementsToRemove);\n\n        assertEquals(expected, result);\n    }\n\n    @Test\n    public void testRemoveAllElementsFromList() {\n        List<Integer> list = Arrays.asList(1, 2, 3, 4, 5);\n        List<Integer> elementsToRemove = Arrays.asList(1, 2, 3, 4, 5);\n        List<Integer> expected = Collections.emptyList();\n\n        List<Integer> result = Util.remove(list, elementsToRemove);\n\n        assertEquals(expected, result);\n    }\n\n    @Test\n    public void testRemoveNoElementsFromList() {\n        List<Integer> list = Arrays.asList(1, 2, 3, 4, 5);\n        List<Integer> elementsToRemove = Collections.emptyList();\n        List<Integer> expected = Arrays.asList(1, 2, 3, 4, 5);\n\n        List<Integer> result = Util.remove(list, elementsToRemove);\n\n        assertEquals(expected, result);\n    }\n\n    @Test\n    public void testRemoveNonExistentElementsFromList() {\n        List<Integer> list = Arrays.asList(1, 2, 3, 4, 5);\n        List<Integer> elementsToRemove = Arrays.asList(6, 7);\n        List<Integer> expected = Arrays.asList(1, 2, 3, 4, 5);\n\n        List<Integer> result = Util.remove(list, elementsToRemove);\n\n        assertEquals(expected, result);\n    }\n}", "definition": "public class Util_removeTest", "class_docstring": "", "name": "Util_removeTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @Test\n    public void testRemoveElementsFromList() {\n        List<Integer> list = Arrays.asList(1, 2, 3, 4, 5);\n        List<Integer> elementsToRemove = Arrays.asList(2, 4);\n        List<Integer> expected = Arrays.asList(1, 3, 5);\n\n        List<Integer> result = Util.remove(list, elementsToRemove);\n\n        assertEquals(expected, result);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testRemoveElementsFromList", "params": [], "body": "                                             {\n        List<Integer> list = Arrays.asList(1, 2, 3, 4, 5);\n        List<Integer> elementsToRemove = Arrays.asList(2, 4);\n        List<Integer> expected = Arrays.asList(1, 3, 5);\n\n        List<Integer> result = Util.remove(list, elementsToRemove);\n\n        assertEquals(expected, result);\n    }", "signature": "@Test\n    public void testRemoveElementsFromList()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testRemoveAllElementsFromList() {\n        List<Integer> list = Arrays.asList(1, 2, 3, 4, 5);\n        List<Integer> elementsToRemove = Arrays.asList(1, 2, 3, 4, 5);\n        List<Integer> expected = Collections.emptyList();\n\n        List<Integer> result = Util.remove(list, elementsToRemove);\n\n        assertEquals(expected, result);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testRemoveAllElementsFromList", "params": [], "body": "                                                {\n        List<Integer> list = Arrays.asList(1, 2, 3, 4, 5);\n        List<Integer> elementsToRemove = Arrays.asList(1, 2, 3, 4, 5);\n        List<Integer> expected = Collections.emptyList();\n\n        List<Integer> result = Util.remove(list, elementsToRemove);\n\n        assertEquals(expected, result);\n    }", "signature": "@Test\n    public void testRemoveAllElementsFromList()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testRemoveNoElementsFromList() {\n        List<Integer> list = Arrays.asList(1, 2, 3, 4, 5);\n        List<Integer> elementsToRemove = Collections.emptyList();\n        List<Integer> expected = Arrays.asList(1, 2, 3, 4, 5);\n\n        List<Integer> result = Util.remove(list, elementsToRemove);\n\n        assertEquals(expected, result);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testRemoveNoElementsFromList", "params": [], "body": "                                               {\n        List<Integer> list = Arrays.asList(1, 2, 3, 4, 5);\n        List<Integer> elementsToRemove = Collections.emptyList();\n        List<Integer> expected = Arrays.asList(1, 2, 3, 4, 5);\n\n        List<Integer> result = Util.remove(list, elementsToRemove);\n\n        assertEquals(expected, result);\n    }", "signature": "@Test\n    public void testRemoveNoElementsFromList()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testRemoveNonExistentElementsFromList() {\n        List<Integer> list = Arrays.asList(1, 2, 3, 4, 5);\n        List<Integer> elementsToRemove = Arrays.asList(6, 7);\n        List<Integer> expected = Arrays.asList(1, 2, 3, 4, 5);\n\n        List<Integer> result = Util.remove(list, elementsToRemove);\n\n        assertEquals(expected, result);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testRemoveNonExistentElementsFromList", "params": [], "body": "                                                        {\n        List<Integer> list = Arrays.asList(1, 2, 3, 4, 5);\n        List<Integer> elementsToRemove = Arrays.asList(6, 7);\n        List<Integer> expected = Arrays.asList(1, 2, 3, 4, 5);\n\n        List<Integer> result = Util.remove(list, elementsToRemove);\n\n        assertEquals(expected, result);\n    }", "signature": "@Test\n    public void testRemoveNonExistentElementsFromList()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/com/github/davidmoten/rtree/internal/Line2D_ptSegDistTest.java", "original_string": "\npackage com.github.davidmoten.rtree.internal;\n\nimport static org.junit.Assert.assertEquals;\nimport org.junit.Test;\n\npublic class Line2D_ptSegDistTest {\n\n    @Test\n    public void testPtSegDist() {\n        double result = Line2D.ptSegDist(0, 0, 1, 1, 0, 1);\n        assertEquals(Math.sqrt(2) / 2, result, 0.0001);\n    }\n}\n", "file_hash": "11d4b16894b48fa0c0e20f9e56b08986c6b523c3b60808226fe084ac7cb7bd71", "file_docstring": "", "contexts": ["package com.github.davidmoten.rtree.internal;", "import static org.junit.Assert.assertEquals;", "import org.junit.Test;"], "methods": [], "classes": [{"original_string": "public class Line2D_ptSegDistTest {\n\n    @Test\n    public void testPtSegDist() {\n        double result = Line2D.ptSegDist(0, 0, 1, 1, 0, 1);\n        assertEquals(Math.sqrt(2) / 2, result, 0.0001);\n    }\n}", "definition": "public class Line2D_ptSegDistTest", "class_docstring": "", "name": "Line2D_ptSegDistTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @Test\n    public void testPtSegDist() {\n        double result = Line2D.ptSegDist(0, 0, 1, 1, 0, 1);\n        assertEquals(Math.sqrt(2) / 2, result, 0.0001);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testPtSegDist", "params": [], "body": "                                {\n        double result = Line2D.ptSegDist(0, 0, 1, 1, 0, 1);\n        assertEquals(Math.sqrt(2) / 2, result, 0.0001);\n    }", "signature": "@Test\n    public void testPtSegDist()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/com/github/davidmoten/rtree/internal/util/BoundedPriorityQueueTest.java", "original_string": "package com.github.davidmoten.rtree.internal.util;\n\nimport static com.github.davidmoten.rtree.internal.util.BoundedPriorityQueue.create;\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertTrue;\n\nimport java.util.Comparator;\n\nimport org.junit.Test;\n\nimport com.github.davidmoten.guavamini.Sets;\n\npublic class BoundedPriorityQueueTest {\n\n    private static final Comparator<Integer> comparator = new Comparator<Integer>() {\n\n        @Override\n        public int compare(Integer o1, Integer o2) {\n            return o1.compareTo(o2);\n        }\n    };\n\n    @Test\n    public void emptyQueueAsListIsEmpty() {\n        BoundedPriorityQueue<Integer> q = create(2, comparator);\n        assertTrue(q.asList().isEmpty());\n    }\n\n    @Test\n    public void singleItemReturnsSingleItem() {\n        BoundedPriorityQueue<Integer> q = create(2, comparator);\n        q.add(1);\n        assertEquals(Sets.newHashSet(1), Sets.newHashSet(q.asList()));\n    }\n\n    @Test\n    public void twoItemsReturnsSingleItemWhenMaxIsOne() {\n        BoundedPriorityQueue<Integer> q = create(1, comparator);\n        q.add(1);\n        q.add(2);\n        assertEquals(Sets.newHashSet(1), Sets.newHashSet(q.asList()));\n    }\n\n    @Test\n    public void twoItemsReturnsSingleItemWhenMaxIsOneInputOrderFlipped() {\n        BoundedPriorityQueue<Integer> q = create(1, comparator);\n        q.add(2);\n        q.add(1);\n        assertEquals(Sets.newHashSet(1), Sets.newHashSet(q.asList()));\n    }\n\n    @Test\n    public void threeItemsReturnsTwoItemsWhenMaxIsOneInputOrderFlipped() {\n        BoundedPriorityQueue<Integer> q = create(2, comparator);\n        q.add(3);\n        q.add(2);\n        q.add(1);\n        assertEquals(Sets.newHashSet(1, 2), Sets.newHashSet(q.asList()));\n    }\n\n    @Test\n    public void threeItemsReturnsTwoItemsWhenMaxIsOneInputOrderIncreasing() {\n        BoundedPriorityQueue<Integer> q = create(2, comparator);\n        q.add(1);\n        q.add(2);\n        q.add(3);\n        assertEquals(Sets.newHashSet(1, 2), Sets.newHashSet(q.asList()));\n    }\n\n    @Test\n    public void threeItemsReturnsTwoItemsWhenMaxIsOneInputOrderMixed() {\n        BoundedPriorityQueue<Integer> q = create(2, comparator);\n        q.add(3);\n        q.add(1);\n        q.add(2);\n        assertEquals(Sets.newHashSet(1, 2), Sets.newHashSet(q.asList()));\n    }\n\n    @Test\n    public void threeItemsReturnsTwoItemsWhenMaxIsOneInputOrderMixed2() {\n        BoundedPriorityQueue<Integer> q = create(2, comparator);\n        q.add(1);\n        q.add(3);\n        q.add(2);\n        assertEquals(Sets.newHashSet(1, 2), Sets.newHashSet(q.asList()));\n    }\n\n    @Test\n    public void threeItemsReturnsThreeItemsWhenMaxIsOneInputOrderFlipped() {\n        BoundedPriorityQueue<Integer> q = create(10, comparator);\n        q.add(3);\n        q.add(2);\n        q.add(1);\n        assertEquals(Sets.newHashSet(1, 2, 3), Sets.newHashSet(q.asList()));\n    }\n\n    @Test\n    public void threeItemsReturnsThreeItemsWhenMaxIsOneInputOrderIncreasing() {\n        BoundedPriorityQueue<Integer> q = create(10, comparator);\n        q.add(1);\n        q.add(2);\n        q.add(3);\n        assertEquals(Sets.newHashSet(1, 2, 3), Sets.newHashSet(q.asList()));\n    }\n\n    @Test\n    public void threeItemsReturnsThreeItemsWhenMaxIsOneInputOrderMixed() {\n        BoundedPriorityQueue<Integer> q = create(10, comparator);\n        q.add(3);\n        q.add(1);\n        q.add(2);\n        assertEquals(Sets.newHashSet(1, 2, 3), Sets.newHashSet(q.asList()));\n    }\n\n    @Test\n    public void threeItemsReturnsThreeItemsWhenMaxIsOneInputOrderMixed2() {\n        BoundedPriorityQueue<Integer> q = create(10, comparator);\n        q.add(1);\n        q.add(3);\n        q.add(2);\n        assertEquals(Sets.newHashSet(1, 2, 3), Sets.newHashSet(q.asList()));\n    }\n    \n    @Test(expected=IllegalArgumentException.class)\n    public void testInstantiateWithNegativeSizeThrowsIAE() {\n        create(-1, comparator);\n    }\n    \n    @Test(expected=IllegalArgumentException.class)\n    public void testInstantiateWithZeroSizeThrowsIAE() {\n        create(0, comparator);\n    }\n\n    @Test(expected=NullPointerException.class)\n    public void testAddNullThrowsNPE() {\n        BoundedPriorityQueue<Integer> q = create(10, comparator);\n        q.add(null);\n    }\n    \n}\n", "file_hash": "3a68237ce191e0577caf97a8cbc0e1bd3d6584ac8a54a3d47be9b8832aabf379", "file_docstring": "", "contexts": ["package com.github.davidmoten.rtree.internal.util;", "import static com.github.davidmoten.rtree.internal.util.BoundedPriorityQueue.create;", "import static org.junit.Assert.assertEquals;", "import static org.junit.Assert.assertTrue;", "import java.util.Comparator;", "import org.junit.Test;", "import com.github.davidmoten.guavamini.Sets;"], "methods": [], "classes": [{"original_string": "public class BoundedPriorityQueueTest {\n\n    private static final Comparator<Integer> comparator = new Comparator<Integer>() {\n\n        @Override\n        public int compare(Integer o1, Integer o2) {\n            return o1.compareTo(o2);\n        }\n    };\n\n    @Test\n    public void emptyQueueAsListIsEmpty() {\n        BoundedPriorityQueue<Integer> q = create(2, comparator);\n        assertTrue(q.asList().isEmpty());\n    }\n\n    @Test\n    public void singleItemReturnsSingleItem() {\n        BoundedPriorityQueue<Integer> q = create(2, comparator);\n        q.add(1);\n        assertEquals(Sets.newHashSet(1), Sets.newHashSet(q.asList()));\n    }\n\n    @Test\n    public void twoItemsReturnsSingleItemWhenMaxIsOne() {\n        BoundedPriorityQueue<Integer> q = create(1, comparator);\n        q.add(1);\n        q.add(2);\n        assertEquals(Sets.newHashSet(1), Sets.newHashSet(q.asList()));\n    }\n\n    @Test\n    public void twoItemsReturnsSingleItemWhenMaxIsOneInputOrderFlipped() {\n        BoundedPriorityQueue<Integer> q = create(1, comparator);\n        q.add(2);\n        q.add(1);\n        assertEquals(Sets.newHashSet(1), Sets.newHashSet(q.asList()));\n    }\n\n    @Test\n    public void threeItemsReturnsTwoItemsWhenMaxIsOneInputOrderFlipped() {\n        BoundedPriorityQueue<Integer> q = create(2, comparator);\n        q.add(3);\n        q.add(2);\n        q.add(1);\n        assertEquals(Sets.newHashSet(1, 2), Sets.newHashSet(q.asList()));\n    }\n\n    @Test\n    public void threeItemsReturnsTwoItemsWhenMaxIsOneInputOrderIncreasing() {\n        BoundedPriorityQueue<Integer> q = create(2, comparator);\n        q.add(1);\n        q.add(2);\n        q.add(3);\n        assertEquals(Sets.newHashSet(1, 2), Sets.newHashSet(q.asList()));\n    }\n\n    @Test\n    public void threeItemsReturnsTwoItemsWhenMaxIsOneInputOrderMixed() {\n        BoundedPriorityQueue<Integer> q = create(2, comparator);\n        q.add(3);\n        q.add(1);\n        q.add(2);\n        assertEquals(Sets.newHashSet(1, 2), Sets.newHashSet(q.asList()));\n    }\n\n    @Test\n    public void threeItemsReturnsTwoItemsWhenMaxIsOneInputOrderMixed2() {\n        BoundedPriorityQueue<Integer> q = create(2, comparator);\n        q.add(1);\n        q.add(3);\n        q.add(2);\n        assertEquals(Sets.newHashSet(1, 2), Sets.newHashSet(q.asList()));\n    }\n\n    @Test\n    public void threeItemsReturnsThreeItemsWhenMaxIsOneInputOrderFlipped() {\n        BoundedPriorityQueue<Integer> q = create(10, comparator);\n        q.add(3);\n        q.add(2);\n        q.add(1);\n        assertEquals(Sets.newHashSet(1, 2, 3), Sets.newHashSet(q.asList()));\n    }\n\n    @Test\n    public void threeItemsReturnsThreeItemsWhenMaxIsOneInputOrderIncreasing() {\n        BoundedPriorityQueue<Integer> q = create(10, comparator);\n        q.add(1);\n        q.add(2);\n        q.add(3);\n        assertEquals(Sets.newHashSet(1, 2, 3), Sets.newHashSet(q.asList()));\n    }\n\n    @Test\n    public void threeItemsReturnsThreeItemsWhenMaxIsOneInputOrderMixed() {\n        BoundedPriorityQueue<Integer> q = create(10, comparator);\n        q.add(3);\n        q.add(1);\n        q.add(2);\n        assertEquals(Sets.newHashSet(1, 2, 3), Sets.newHashSet(q.asList()));\n    }\n\n    @Test\n    public void threeItemsReturnsThreeItemsWhenMaxIsOneInputOrderMixed2() {\n        BoundedPriorityQueue<Integer> q = create(10, comparator);\n        q.add(1);\n        q.add(3);\n        q.add(2);\n        assertEquals(Sets.newHashSet(1, 2, 3), Sets.newHashSet(q.asList()));\n    }\n    \n    @Test(expected=IllegalArgumentException.class)\n    public void testInstantiateWithNegativeSizeThrowsIAE() {\n        create(-1, comparator);\n    }\n    \n    @Test(expected=IllegalArgumentException.class)\n    public void testInstantiateWithZeroSizeThrowsIAE() {\n        create(0, comparator);\n    }\n\n    @Test(expected=NullPointerException.class)\n    public void testAddNullThrowsNPE() {\n        BoundedPriorityQueue<Integer> q = create(10, comparator);\n        q.add(null);\n    }\n    \n}", "definition": "public class BoundedPriorityQueueTest", "class_docstring": "", "name": "BoundedPriorityQueueTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private static final Comparator<Integer> comparator = new Comparator<Integer>() {\n\n        @Override\n        public int compare(Integer o1, Integer o2) {\n            return o1.compareTo(o2);\n        }\n    };", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Comparator<Integer>", "name": "comparator = new Comparator<Integer>() {\n\n        @Override\n        public int compare(Integer o1, Integer o2) {\n            return o1.compareTo(o2);\n        }\n    }", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @Test\n    public void emptyQueueAsListIsEmpty() {\n        BoundedPriorityQueue<Integer> q = create(2, comparator);\n        assertTrue(q.asList().isEmpty());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "emptyQueueAsListIsEmpty", "params": [], "body": "                                          {\n        BoundedPriorityQueue<Integer> q = create(2, comparator);\n        assertTrue(q.asList().isEmpty());\n    }", "signature": "@Test\n    public void emptyQueueAsListIsEmpty()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void singleItemReturnsSingleItem() {\n        BoundedPriorityQueue<Integer> q = create(2, comparator);\n        q.add(1);\n        assertEquals(Sets.newHashSet(1), Sets.newHashSet(q.asList()));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "singleItemReturnsSingleItem", "params": [], "body": "                                              {\n        BoundedPriorityQueue<Integer> q = create(2, comparator);\n        q.add(1);\n        assertEquals(Sets.newHashSet(1), Sets.newHashSet(q.asList()));\n    }", "signature": "@Test\n    public void singleItemReturnsSingleItem()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void twoItemsReturnsSingleItemWhenMaxIsOne() {\n        BoundedPriorityQueue<Integer> q = create(1, comparator);\n        q.add(1);\n        q.add(2);\n        assertEquals(Sets.newHashSet(1), Sets.newHashSet(q.asList()));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "twoItemsReturnsSingleItemWhenMaxIsOne", "params": [], "body": "                                                        {\n        BoundedPriorityQueue<Integer> q = create(1, comparator);\n        q.add(1);\n        q.add(2);\n        assertEquals(Sets.newHashSet(1), Sets.newHashSet(q.asList()));\n    }", "signature": "@Test\n    public void twoItemsReturnsSingleItemWhenMaxIsOne()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void twoItemsReturnsSingleItemWhenMaxIsOneInputOrderFlipped() {\n        BoundedPriorityQueue<Integer> q = create(1, comparator);\n        q.add(2);\n        q.add(1);\n        assertEquals(Sets.newHashSet(1), Sets.newHashSet(q.asList()));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "twoItemsReturnsSingleItemWhenMaxIsOneInputOrderFlipped", "params": [], "body": "                                                                         {\n        BoundedPriorityQueue<Integer> q = create(1, comparator);\n        q.add(2);\n        q.add(1);\n        assertEquals(Sets.newHashSet(1), Sets.newHashSet(q.asList()));\n    }", "signature": "@Test\n    public void twoItemsReturnsSingleItemWhenMaxIsOneInputOrderFlipped()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void threeItemsReturnsTwoItemsWhenMaxIsOneInputOrderFlipped() {\n        BoundedPriorityQueue<Integer> q = create(2, comparator);\n        q.add(3);\n        q.add(2);\n        q.add(1);\n        assertEquals(Sets.newHashSet(1, 2), Sets.newHashSet(q.asList()));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "threeItemsReturnsTwoItemsWhenMaxIsOneInputOrderFlipped", "params": [], "body": "                                                                         {\n        BoundedPriorityQueue<Integer> q = create(2, comparator);\n        q.add(3);\n        q.add(2);\n        q.add(1);\n        assertEquals(Sets.newHashSet(1, 2), Sets.newHashSet(q.asList()));\n    }", "signature": "@Test\n    public void threeItemsReturnsTwoItemsWhenMaxIsOneInputOrderFlipped()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void threeItemsReturnsTwoItemsWhenMaxIsOneInputOrderIncreasing() {\n        BoundedPriorityQueue<Integer> q = create(2, comparator);\n        q.add(1);\n        q.add(2);\n        q.add(3);\n        assertEquals(Sets.newHashSet(1, 2), Sets.newHashSet(q.asList()));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "threeItemsReturnsTwoItemsWhenMaxIsOneInputOrderIncreasing", "params": [], "body": "                                                                            {\n        BoundedPriorityQueue<Integer> q = create(2, comparator);\n        q.add(1);\n        q.add(2);\n        q.add(3);\n        assertEquals(Sets.newHashSet(1, 2), Sets.newHashSet(q.asList()));\n    }", "signature": "@Test\n    public void threeItemsReturnsTwoItemsWhenMaxIsOneInputOrderIncreasing()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void threeItemsReturnsTwoItemsWhenMaxIsOneInputOrderMixed() {\n        BoundedPriorityQueue<Integer> q = create(2, comparator);\n        q.add(3);\n        q.add(1);\n        q.add(2);\n        assertEquals(Sets.newHashSet(1, 2), Sets.newHashSet(q.asList()));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "threeItemsReturnsTwoItemsWhenMaxIsOneInputOrderMixed", "params": [], "body": "                                                                       {\n        BoundedPriorityQueue<Integer> q = create(2, comparator);\n        q.add(3);\n        q.add(1);\n        q.add(2);\n        assertEquals(Sets.newHashSet(1, 2), Sets.newHashSet(q.asList()));\n    }", "signature": "@Test\n    public void threeItemsReturnsTwoItemsWhenMaxIsOneInputOrderMixed()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void threeItemsReturnsTwoItemsWhenMaxIsOneInputOrderMixed2() {\n        BoundedPriorityQueue<Integer> q = create(2, comparator);\n        q.add(1);\n        q.add(3);\n        q.add(2);\n        assertEquals(Sets.newHashSet(1, 2), Sets.newHashSet(q.asList()));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "threeItemsReturnsTwoItemsWhenMaxIsOneInputOrderMixed2", "params": [], "body": "                                                                        {\n        BoundedPriorityQueue<Integer> q = create(2, comparator);\n        q.add(1);\n        q.add(3);\n        q.add(2);\n        assertEquals(Sets.newHashSet(1, 2), Sets.newHashSet(q.asList()));\n    }", "signature": "@Test\n    public void threeItemsReturnsTwoItemsWhenMaxIsOneInputOrderMixed2()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void threeItemsReturnsThreeItemsWhenMaxIsOneInputOrderFlipped() {\n        BoundedPriorityQueue<Integer> q = create(10, comparator);\n        q.add(3);\n        q.add(2);\n        q.add(1);\n        assertEquals(Sets.newHashSet(1, 2, 3), Sets.newHashSet(q.asList()));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "threeItemsReturnsThreeItemsWhenMaxIsOneInputOrderFlipped", "params": [], "body": "                                                                           {\n        BoundedPriorityQueue<Integer> q = create(10, comparator);\n        q.add(3);\n        q.add(2);\n        q.add(1);\n        assertEquals(Sets.newHashSet(1, 2, 3), Sets.newHashSet(q.asList()));\n    }", "signature": "@Test\n    public void threeItemsReturnsThreeItemsWhenMaxIsOneInputOrderFlipped()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void threeItemsReturnsThreeItemsWhenMaxIsOneInputOrderIncreasing() {\n        BoundedPriorityQueue<Integer> q = create(10, comparator);\n        q.add(1);\n        q.add(2);\n        q.add(3);\n        assertEquals(Sets.newHashSet(1, 2, 3), Sets.newHashSet(q.asList()));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "threeItemsReturnsThreeItemsWhenMaxIsOneInputOrderIncreasing", "params": [], "body": "                                                                              {\n        BoundedPriorityQueue<Integer> q = create(10, comparator);\n        q.add(1);\n        q.add(2);\n        q.add(3);\n        assertEquals(Sets.newHashSet(1, 2, 3), Sets.newHashSet(q.asList()));\n    }", "signature": "@Test\n    public void threeItemsReturnsThreeItemsWhenMaxIsOneInputOrderIncreasing()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void threeItemsReturnsThreeItemsWhenMaxIsOneInputOrderMixed() {\n        BoundedPriorityQueue<Integer> q = create(10, comparator);\n        q.add(3);\n        q.add(1);\n        q.add(2);\n        assertEquals(Sets.newHashSet(1, 2, 3), Sets.newHashSet(q.asList()));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "threeItemsReturnsThreeItemsWhenMaxIsOneInputOrderMixed", "params": [], "body": "                                                                         {\n        BoundedPriorityQueue<Integer> q = create(10, comparator);\n        q.add(3);\n        q.add(1);\n        q.add(2);\n        assertEquals(Sets.newHashSet(1, 2, 3), Sets.newHashSet(q.asList()));\n    }", "signature": "@Test\n    public void threeItemsReturnsThreeItemsWhenMaxIsOneInputOrderMixed()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void threeItemsReturnsThreeItemsWhenMaxIsOneInputOrderMixed2() {\n        BoundedPriorityQueue<Integer> q = create(10, comparator);\n        q.add(1);\n        q.add(3);\n        q.add(2);\n        assertEquals(Sets.newHashSet(1, 2, 3), Sets.newHashSet(q.asList()));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "threeItemsReturnsThreeItemsWhenMaxIsOneInputOrderMixed2", "params": [], "body": "                                                                          {\n        BoundedPriorityQueue<Integer> q = create(10, comparator);\n        q.add(1);\n        q.add(3);\n        q.add(2);\n        assertEquals(Sets.newHashSet(1, 2, 3), Sets.newHashSet(q.asList()));\n    }", "signature": "@Test\n    public void threeItemsReturnsThreeItemsWhenMaxIsOneInputOrderMixed2()"}, {"syntax_pass": true, "original_string": "    @Test(expected=IllegalArgumentException.class)\n    public void testInstantiateWithNegativeSizeThrowsIAE() {\n        create(-1, comparator);\n    }", "docstring": "", "attributes": {"modifiers": "@Test(expected=IllegalArgumentException.class)\n    public", "marker_annotations": [], "non_marker_annotations": ["@Test(expected=IllegalArgumentException.class)", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "testInstantiateWithNegativeSizeThrowsIAE", "params": [], "body": "                                                           {\n        create(-1, comparator);\n    }", "signature": "@Test(expected=IllegalArgumentException.class)\n    public void testInstantiateWithNegativeSizeThrowsIAE()"}, {"syntax_pass": true, "original_string": "    @Test(expected=IllegalArgumentException.class)\n    public void testInstantiateWithZeroSizeThrowsIAE() {\n        create(0, comparator);\n    }", "docstring": "", "attributes": {"modifiers": "@Test(expected=IllegalArgumentException.class)\n    public", "marker_annotations": [], "non_marker_annotations": ["@Test(expected=IllegalArgumentException.class)", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "testInstantiateWithZeroSizeThrowsIAE", "params": [], "body": "                                                       {\n        create(0, comparator);\n    }", "signature": "@Test(expected=IllegalArgumentException.class)\n    public void testInstantiateWithZeroSizeThrowsIAE()"}, {"syntax_pass": true, "original_string": "    @Test(expected=NullPointerException.class)\n    public void testAddNullThrowsNPE() {\n        BoundedPriorityQueue<Integer> q = create(10, comparator);\n        q.add(null);\n    }", "docstring": "", "attributes": {"modifiers": "@Test(expected=NullPointerException.class)\n    public", "marker_annotations": [], "non_marker_annotations": ["@Test(expected=NullPointerException.class)", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "testAddNullThrowsNPE", "params": [], "body": "                                       {\n        BoundedPriorityQueue<Integer> q = create(10, comparator);\n        q.add(null);\n    }", "signature": "@Test(expected=NullPointerException.class)\n    public void testAddNullThrowsNPE()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/com/github/davidmoten/rtree/internal/util/ImmutableStack_popTest.java", "original_string": "\npackage com.github.davidmoten.rtree.internal.util;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertTrue;\nimport org.junit.Test;\n\npublic class ImmutableStack_popTest {\n\n    @Test\n    public void testPopOnNonEmptyStack() {\n        ImmutableStack<Integer> stack = ImmutableStack.create(1).push(2);\n        ImmutableStack<Integer> poppedStack = stack.pop();\n        assertEquals(Integer.valueOf(1), poppedStack.peek());\n    }\n\n    @Test(expected = RuntimeException.class)\n    public void testPopOnEmptyStack() {\n        ImmutableStack<Integer> emptyStack = ImmutableStack.empty();\n        emptyStack.pop();\n    }\n}\n", "file_hash": "37c83ebbe58654f70ff4c1fab84ec9decb1413939ba19cda47233fa545dab99a", "file_docstring": "", "contexts": ["package com.github.davidmoten.rtree.internal.util;", "import static org.junit.Assert.assertEquals;", "import static org.junit.Assert.assertTrue;", "import org.junit.Test;"], "methods": [], "classes": [{"original_string": "public class ImmutableStack_popTest {\n\n    @Test\n    public void testPopOnNonEmptyStack() {\n        ImmutableStack<Integer> stack = ImmutableStack.create(1).push(2);\n        ImmutableStack<Integer> poppedStack = stack.pop();\n        assertEquals(Integer.valueOf(1), poppedStack.peek());\n    }\n\n    @Test(expected = RuntimeException.class)\n    public void testPopOnEmptyStack() {\n        ImmutableStack<Integer> emptyStack = ImmutableStack.empty();\n        emptyStack.pop();\n    }\n}", "definition": "public class ImmutableStack_popTest", "class_docstring": "", "name": "ImmutableStack_popTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @Test\n    public void testPopOnNonEmptyStack() {\n        ImmutableStack<Integer> stack = ImmutableStack.create(1).push(2);\n        ImmutableStack<Integer> poppedStack = stack.pop();\n        assertEquals(Integer.valueOf(1), poppedStack.peek());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testPopOnNonEmptyStack", "params": [], "body": "                                         {\n        ImmutableStack<Integer> stack = ImmutableStack.create(1).push(2);\n        ImmutableStack<Integer> poppedStack = stack.pop();\n        assertEquals(Integer.valueOf(1), poppedStack.peek());\n    }", "signature": "@Test\n    public void testPopOnNonEmptyStack()"}, {"syntax_pass": true, "original_string": "    @Test(expected = RuntimeException.class)\n    public void testPopOnEmptyStack() {\n        ImmutableStack<Integer> emptyStack = ImmutableStack.empty();\n        emptyStack.pop();\n    }", "docstring": "", "attributes": {"modifiers": "@Test(expected = RuntimeException.class)\n    public", "marker_annotations": [], "non_marker_annotations": ["@Test(expected = RuntimeException.class)", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "testPopOnEmptyStack", "params": [], "body": "                                      {\n        ImmutableStack<Integer> emptyStack = ImmutableStack.empty();\n        emptyStack.pop();\n    }", "signature": "@Test(expected = RuntimeException.class)\n    public void testPopOnEmptyStack()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/com/github/davidmoten/rtree/internal/util/ObjectsHelperTest.java", "original_string": "package com.github.davidmoten.rtree.internal.util;\n\nimport static org.junit.Assert.assertFalse;\nimport static org.junit.Assert.assertTrue;\n\nimport org.junit.Test;\n\npublic class ObjectsHelperTest {\n\n    @Test\n    public void testAsClassIsAbsentIfNull() {\n        assertFalse(ObjectsHelper.asClass(null, Integer.class).isPresent());\n    }\n\n    @Test\n    public void testAsClassIsAbsentIfDifferentClass() {\n        assertFalse(ObjectsHelper.asClass(1, String.class).isPresent());\n    }\n\n    @Test\n    public void testAsClassIsPresentIfSameTypeAndNotNull() {\n        assertTrue(ObjectsHelper.asClass(1, Integer.class).isPresent());\n    }\n\n    @Test\n    public void coverPrivateConstructor() {\n        ObjectsHelper.instantiateForTestCoveragePurposesOnly();\n    }\n}\n", "file_hash": "f6eea68db3f088db0e8e3393cfa9f81007f632342b12584f7b32be754f1db51a", "file_docstring": "", "contexts": ["package com.github.davidmoten.rtree.internal.util;", "import static org.junit.Assert.assertFalse;", "import static org.junit.Assert.assertTrue;", "import org.junit.Test;"], "methods": [], "classes": [{"original_string": "public class ObjectsHelperTest {\n\n    @Test\n    public void testAsClassIsAbsentIfNull() {\n        assertFalse(ObjectsHelper.asClass(null, Integer.class).isPresent());\n    }\n\n    @Test\n    public void testAsClassIsAbsentIfDifferentClass() {\n        assertFalse(ObjectsHelper.asClass(1, String.class).isPresent());\n    }\n\n    @Test\n    public void testAsClassIsPresentIfSameTypeAndNotNull() {\n        assertTrue(ObjectsHelper.asClass(1, Integer.class).isPresent());\n    }\n\n    @Test\n    public void coverPrivateConstructor() {\n        ObjectsHelper.instantiateForTestCoveragePurposesOnly();\n    }\n}", "definition": "public class ObjectsHelperTest", "class_docstring": "", "name": "ObjectsHelperTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @Test\n    public void testAsClassIsAbsentIfNull() {\n        assertFalse(ObjectsHelper.asClass(null, Integer.class).isPresent());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testAsClassIsAbsentIfNull", "params": [], "body": "                                            {\n        assertFalse(ObjectsHelper.asClass(null, Integer.class).isPresent());\n    }", "signature": "@Test\n    public void testAsClassIsAbsentIfNull()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testAsClassIsAbsentIfDifferentClass() {\n        assertFalse(ObjectsHelper.asClass(1, String.class).isPresent());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testAsClassIsAbsentIfDifferentClass", "params": [], "body": "                                                      {\n        assertFalse(ObjectsHelper.asClass(1, String.class).isPresent());\n    }", "signature": "@Test\n    public void testAsClassIsAbsentIfDifferentClass()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testAsClassIsPresentIfSameTypeAndNotNull() {\n        assertTrue(ObjectsHelper.asClass(1, Integer.class).isPresent());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testAsClassIsPresentIfSameTypeAndNotNull", "params": [], "body": "                                                           {\n        assertTrue(ObjectsHelper.asClass(1, Integer.class).isPresent());\n    }", "signature": "@Test\n    public void testAsClassIsPresentIfSameTypeAndNotNull()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void coverPrivateConstructor() {\n        ObjectsHelper.instantiateForTestCoveragePurposesOnly();\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "coverPrivateConstructor", "params": [], "body": "                                          {\n        ObjectsHelper.instantiateForTestCoveragePurposesOnly();\n    }", "signature": "@Test\n    public void coverPrivateConstructor()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/com/github/davidmoten/rtree/internal/util/ObjectsHelper_asClassTest.java", "original_string": "\npackage com.github.davidmoten.rtree.internal.util;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertFalse;\nimport static org.junit.Assert.assertTrue;\n\nimport java.util.Optional;\n\nimport org.junit.Test;\n\npublic class ObjectsHelper_asClassTest {\n\n    @Test\n    public void testAsClassWithNullObject() {\n        Optional<String> result = ObjectsHelper.asClass(null, String.class);\n        assertFalse(result.isPresent());\n    }\n\n    @Test\n    public void testAsClassWithIncorrectClass() {\n        Optional<String> result = ObjectsHelper.asClass(123, String.class);\n        assertFalse(result.isPresent());\n    }\n\n    @Test\n    public void testAsClassWithCorrectClass() {\n        Optional<String> result = ObjectsHelper.asClass(\"test\", String.class);\n        assertTrue(result.isPresent());\n        assertEquals(\"test\", result.get());\n    }\n\n    @Test\n    public void coverPrivateConstructor() {\n        ObjectsHelper.instantiateForTestCoveragePurposesOnly();\n    }\n}\n", "file_hash": "d455b4bbe5455124ac3dd666827a4153138256bd8af8d416a00f5663890bfdc2", "file_docstring": "", "contexts": ["package com.github.davidmoten.rtree.internal.util;", "import static org.junit.Assert.assertEquals;", "import static org.junit.Assert.assertFalse;", "import static org.junit.Assert.assertTrue;", "import java.util.Optional;", "import org.junit.Test;"], "methods": [], "classes": [{"original_string": "public class ObjectsHelper_asClassTest {\n\n    @Test\n    public void testAsClassWithNullObject() {\n        Optional<String> result = ObjectsHelper.asClass(null, String.class);\n        assertFalse(result.isPresent());\n    }\n\n    @Test\n    public void testAsClassWithIncorrectClass() {\n        Optional<String> result = ObjectsHelper.asClass(123, String.class);\n        assertFalse(result.isPresent());\n    }\n\n    @Test\n    public void testAsClassWithCorrectClass() {\n        Optional<String> result = ObjectsHelper.asClass(\"test\", String.class);\n        assertTrue(result.isPresent());\n        assertEquals(\"test\", result.get());\n    }\n\n    @Test\n    public void coverPrivateConstructor() {\n        ObjectsHelper.instantiateForTestCoveragePurposesOnly();\n    }\n}", "definition": "public class ObjectsHelper_asClassTest", "class_docstring": "", "name": "ObjectsHelper_asClassTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @Test\n    public void testAsClassWithNullObject() {\n        Optional<String> result = ObjectsHelper.asClass(null, String.class);\n        assertFalse(result.isPresent());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testAsClassWithNullObject", "params": [], "body": "                                            {\n        Optional<String> result = ObjectsHelper.asClass(null, String.class);\n        assertFalse(result.isPresent());\n    }", "signature": "@Test\n    public void testAsClassWithNullObject()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testAsClassWithIncorrectClass() {\n        Optional<String> result = ObjectsHelper.asClass(123, String.class);\n        assertFalse(result.isPresent());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testAsClassWithIncorrectClass", "params": [], "body": "                                                {\n        Optional<String> result = ObjectsHelper.asClass(123, String.class);\n        assertFalse(result.isPresent());\n    }", "signature": "@Test\n    public void testAsClassWithIncorrectClass()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testAsClassWithCorrectClass() {\n        Optional<String> result = ObjectsHelper.asClass(\"test\", String.class);\n        assertTrue(result.isPresent());\n        assertEquals(\"test\", result.get());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testAsClassWithCorrectClass", "params": [], "body": "                                              {\n        Optional<String> result = ObjectsHelper.asClass(\"test\", String.class);\n        assertTrue(result.isPresent());\n        assertEquals(\"test\", result.get());\n    }", "signature": "@Test\n    public void testAsClassWithCorrectClass()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void coverPrivateConstructor() {\n        ObjectsHelper.instantiateForTestCoveragePurposesOnly();\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "coverPrivateConstructor", "params": [], "body": "                                          {\n        ObjectsHelper.instantiateForTestCoveragePurposesOnly();\n    }", "signature": "@Test\n    public void coverPrivateConstructor()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/com/github/davidmoten/rtree/internal/util/ImmutableStackTest.java", "original_string": "package com.github.davidmoten.rtree.internal.util;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertFalse;\nimport static org.junit.Assert.assertTrue;\n\nimport java.util.Iterator;\n\nimport org.junit.Test;\n\npublic class ImmutableStackTest {\n\n    private final Object a = new Object();\n    private final Object b = new Object();\n\n    @Test\n    public void testNewStackIsEmpty() {\n        ImmutableStack<Object> s = ImmutableStack.empty();\n        assertTrue(s.isEmpty());\n    }\n\n    @Test(expected = RuntimeException.class)\n    public void testPopOnEmptyStackThrowsException() {\n        ImmutableStack.empty().pop();\n    }\n\n    @Test(expected = RuntimeException.class)\n    public void testPeekOnEmptyStackThrowsException() {\n        ImmutableStack.empty().peek();\n    }\n\n    @Test(expected = RuntimeException.class)\n    public void testRemoveThrowsException() {\n        ImmutableStack.empty().push(a).iterator().remove();\n    }\n\n    @Test\n    public void testStackIsEmptyAfterPushThenPop() {\n        assertTrue(ImmutableStack.empty().push(new Object()).pop().isEmpty());\n    }\n\n    @Test\n    public void testPeekGivesLastPushed() {\n        assertEquals(b, ImmutableStack.empty().push(a).push(b).peek());\n    }\n\n    @Test\n    public void testPopPeekGivesSecondLastPushed() {\n        assertEquals(a, ImmutableStack.empty().push(a).push(b).pop().peek());\n    }\n\n    @Test\n    public void testIteratorWhenEmpty() {\n        assertFalse(ImmutableStack.empty().iterator().hasNext());\n    }\n\n    @Test\n    public void testIteratorWhenHasOneItem() {\n        assertTrue(ImmutableStack.empty().push(a).iterator().hasNext());\n    }\n\n    @Test\n    public void testIteratorReturnsOneItem() {\n        assertEquals(a, ImmutableStack.empty().push(a).iterator().next());\n    }\n\n    @Test\n    public void testIteratorReturnsLastPushedFirst() {\n        assertEquals(b, ImmutableStack.empty().push(a).push(b).iterator().next());\n    }\n\n    @Test\n    public void testIteratorReturnsTwoItemsInOrderOfPop() {\n        Iterator<Object> it = ImmutableStack.empty().push(a).push(b).iterator();\n        assertEquals(b, it.next());\n        assertEquals(a, it.next());\n        assertFalse(it.hasNext());\n    }\n\n}\n", "file_hash": "cd5807ed3cbd0deffaae2ded0c0055e094931306256c93ee0764a8949400ffb0", "file_docstring": "", "contexts": ["package com.github.davidmoten.rtree.internal.util;", "import static org.junit.Assert.assertEquals;", "import static org.junit.Assert.assertFalse;", "import static org.junit.Assert.assertTrue;", "import java.util.Iterator;", "import org.junit.Test;"], "methods": [], "classes": [{"original_string": "public class ImmutableStackTest {\n\n    private final Object a = new Object();\n    private final Object b = new Object();\n\n    @Test\n    public void testNewStackIsEmpty() {\n        ImmutableStack<Object> s = ImmutableStack.empty();\n        assertTrue(s.isEmpty());\n    }\n\n    @Test(expected = RuntimeException.class)\n    public void testPopOnEmptyStackThrowsException() {\n        ImmutableStack.empty().pop();\n    }\n\n    @Test(expected = RuntimeException.class)\n    public void testPeekOnEmptyStackThrowsException() {\n        ImmutableStack.empty().peek();\n    }\n\n    @Test(expected = RuntimeException.class)\n    public void testRemoveThrowsException() {\n        ImmutableStack.empty().push(a).iterator().remove();\n    }\n\n    @Test\n    public void testStackIsEmptyAfterPushThenPop() {\n        assertTrue(ImmutableStack.empty().push(new Object()).pop().isEmpty());\n    }\n\n    @Test\n    public void testPeekGivesLastPushed() {\n        assertEquals(b, ImmutableStack.empty().push(a).push(b).peek());\n    }\n\n    @Test\n    public void testPopPeekGivesSecondLastPushed() {\n        assertEquals(a, ImmutableStack.empty().push(a).push(b).pop().peek());\n    }\n\n    @Test\n    public void testIteratorWhenEmpty() {\n        assertFalse(ImmutableStack.empty().iterator().hasNext());\n    }\n\n    @Test\n    public void testIteratorWhenHasOneItem() {\n        assertTrue(ImmutableStack.empty().push(a).iterator().hasNext());\n    }\n\n    @Test\n    public void testIteratorReturnsOneItem() {\n        assertEquals(a, ImmutableStack.empty().push(a).iterator().next());\n    }\n\n    @Test\n    public void testIteratorReturnsLastPushedFirst() {\n        assertEquals(b, ImmutableStack.empty().push(a).push(b).iterator().next());\n    }\n\n    @Test\n    public void testIteratorReturnsTwoItemsInOrderOfPop() {\n        Iterator<Object> it = ImmutableStack.empty().push(a).push(b).iterator();\n        assertEquals(b, it.next());\n        assertEquals(a, it.next());\n        assertFalse(it.hasNext());\n    }\n\n}", "definition": "public class ImmutableStackTest", "class_docstring": "", "name": "ImmutableStackTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private final Object a = new Object();", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Object", "name": "a = new Object()", "syntax_pass": true}, {"attribute_expression": "private final Object b = new Object();", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Object", "name": "b = new Object()", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @Test\n    public void testNewStackIsEmpty() {\n        ImmutableStack<Object> s = ImmutableStack.empty();\n        assertTrue(s.isEmpty());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testNewStackIsEmpty", "params": [], "body": "                                      {\n        ImmutableStack<Object> s = ImmutableStack.empty();\n        assertTrue(s.isEmpty());\n    }", "signature": "@Test\n    public void testNewStackIsEmpty()"}, {"syntax_pass": true, "original_string": "    @Test(expected = RuntimeException.class)\n    public void testPopOnEmptyStackThrowsException() {\n        ImmutableStack.empty().pop();\n    }", "docstring": "", "attributes": {"modifiers": "@Test(expected = RuntimeException.class)\n    public", "marker_annotations": [], "non_marker_annotations": ["@Test(expected = RuntimeException.class)", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "testPopOnEmptyStackThrowsException", "params": [], "body": "                                                     {\n        ImmutableStack.empty().pop();\n    }", "signature": "@Test(expected = RuntimeException.class)\n    public void testPopOnEmptyStackThrowsException()"}, {"syntax_pass": true, "original_string": "    @Test(expected = RuntimeException.class)\n    public void testPeekOnEmptyStackThrowsException() {\n        ImmutableStack.empty().peek();\n    }", "docstring": "", "attributes": {"modifiers": "@Test(expected = RuntimeException.class)\n    public", "marker_annotations": [], "non_marker_annotations": ["@Test(expected = RuntimeException.class)", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "testPeekOnEmptyStackThrowsException", "params": [], "body": "                                                      {\n        ImmutableStack.empty().peek();\n    }", "signature": "@Test(expected = RuntimeException.class)\n    public void testPeekOnEmptyStackThrowsException()"}, {"syntax_pass": true, "original_string": "    @Test(expected = RuntimeException.class)\n    public void testRemoveThrowsException() {\n        ImmutableStack.empty().push(a).iterator().remove();\n    }", "docstring": "", "attributes": {"modifiers": "@Test(expected = RuntimeException.class)\n    public", "marker_annotations": [], "non_marker_annotations": ["@Test(expected = RuntimeException.class)", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "testRemoveThrowsException", "params": [], "body": "                                            {\n        ImmutableStack.empty().push(a).iterator().remove();\n    }", "signature": "@Test(expected = RuntimeException.class)\n    public void testRemoveThrowsException()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testStackIsEmptyAfterPushThenPop() {\n        assertTrue(ImmutableStack.empty().push(new Object()).pop().isEmpty());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testStackIsEmptyAfterPushThenPop", "params": [], "body": "                                                   {\n        assertTrue(ImmutableStack.empty().push(new Object()).pop().isEmpty());\n    }", "signature": "@Test\n    public void testStackIsEmptyAfterPushThenPop()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testPeekGivesLastPushed() {\n        assertEquals(b, ImmutableStack.empty().push(a).push(b).peek());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testPeekGivesLastPushed", "params": [], "body": "                                          {\n        assertEquals(b, ImmutableStack.empty().push(a).push(b).peek());\n    }", "signature": "@Test\n    public void testPeekGivesLastPushed()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testPopPeekGivesSecondLastPushed() {\n        assertEquals(a, ImmutableStack.empty().push(a).push(b).pop().peek());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testPopPeekGivesSecondLastPushed", "params": [], "body": "                                                   {\n        assertEquals(a, ImmutableStack.empty().push(a).push(b).pop().peek());\n    }", "signature": "@Test\n    public void testPopPeekGivesSecondLastPushed()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testIteratorWhenEmpty() {\n        assertFalse(ImmutableStack.empty().iterator().hasNext());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testIteratorWhenEmpty", "params": [], "body": "                                        {\n        assertFalse(ImmutableStack.empty().iterator().hasNext());\n    }", "signature": "@Test\n    public void testIteratorWhenEmpty()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testIteratorWhenHasOneItem() {\n        assertTrue(ImmutableStack.empty().push(a).iterator().hasNext());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testIteratorWhenHasOneItem", "params": [], "body": "                                             {\n        assertTrue(ImmutableStack.empty().push(a).iterator().hasNext());\n    }", "signature": "@Test\n    public void testIteratorWhenHasOneItem()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testIteratorReturnsOneItem() {\n        assertEquals(a, ImmutableStack.empty().push(a).iterator().next());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testIteratorReturnsOneItem", "params": [], "body": "                                             {\n        assertEquals(a, ImmutableStack.empty().push(a).iterator().next());\n    }", "signature": "@Test\n    public void testIteratorReturnsOneItem()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testIteratorReturnsLastPushedFirst() {\n        assertEquals(b, ImmutableStack.empty().push(a).push(b).iterator().next());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testIteratorReturnsLastPushedFirst", "params": [], "body": "                                                     {\n        assertEquals(b, ImmutableStack.empty().push(a).push(b).iterator().next());\n    }", "signature": "@Test\n    public void testIteratorReturnsLastPushedFirst()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testIteratorReturnsTwoItemsInOrderOfPop() {\n        Iterator<Object> it = ImmutableStack.empty().push(a).push(b).iterator();\n        assertEquals(b, it.next());\n        assertEquals(a, it.next());\n        assertFalse(it.hasNext());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testIteratorReturnsTwoItemsInOrderOfPop", "params": [], "body": "                                                          {\n        Iterator<Object> it = ImmutableStack.empty().push(a).push(b).iterator();\n        assertEquals(b, it.next());\n        assertEquals(a, it.next());\n        assertFalse(it.hasNext());\n    }", "signature": "@Test\n    public void testIteratorReturnsTwoItemsInOrderOfPop()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/com/github/davidmoten/rtree/internal/util/ImmutableStack_iteratorTest.java", "original_string": "\npackage com.github.davidmoten.rtree.internal.util;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertFalse;\nimport static org.junit.Assert.assertTrue;\n\nimport java.util.Iterator;\n\nimport org.junit.Before;\nimport org.junit.Test;\n\npublic class ImmutableStack_iteratorTest {\n    private ImmutableStack<String> stack;\n\n    @Before\n    public void setUp() {\n        stack = ImmutableStack.empty();\n    }\n\n    @Test\n    public void testIteratorWithNonEmptyStack() {\n        stack = stack.push(\"a\").push(\"b\").push(\"c\");\n        Iterator<String> iterator = stack.iterator();\n\n        assertTrue(iterator.hasNext());\n        assertEquals(\"c\", iterator.next());\n        assertTrue(iterator.hasNext());\n        assertEquals(\"b\", iterator.next());\n        assertTrue(iterator.hasNext());\n        assertEquals(\"a\", iterator.next());\n        assertFalse(iterator.hasNext());\n    }\n\n    @Test\n    public void testIteratorWithEmptyStack() {\n        Iterator<String> iterator = stack.iterator();\n\n        assertFalse(iterator.hasNext());\n    }\n}\n", "file_hash": "0b6366a7b052ff45a061dc2f0be00ca0e8f2a748bac333fc8dcd3b66c843920e", "file_docstring": "", "contexts": ["package com.github.davidmoten.rtree.internal.util;", "import static org.junit.Assert.assertEquals;", "import static org.junit.Assert.assertFalse;", "import static org.junit.Assert.assertTrue;", "import java.util.Iterator;", "import org.junit.Before;", "import org.junit.Test;"], "methods": [], "classes": [{"original_string": "public class ImmutableStack_iteratorTest {\n    private ImmutableStack<String> stack;\n\n    @Before\n    public void setUp() {\n        stack = ImmutableStack.empty();\n    }\n\n    @Test\n    public void testIteratorWithNonEmptyStack() {\n        stack = stack.push(\"a\").push(\"b\").push(\"c\");\n        Iterator<String> iterator = stack.iterator();\n\n        assertTrue(iterator.hasNext());\n        assertEquals(\"c\", iterator.next());\n        assertTrue(iterator.hasNext());\n        assertEquals(\"b\", iterator.next());\n        assertTrue(iterator.hasNext());\n        assertEquals(\"a\", iterator.next());\n        assertFalse(iterator.hasNext());\n    }\n\n    @Test\n    public void testIteratorWithEmptyStack() {\n        Iterator<String> iterator = stack.iterator();\n\n        assertFalse(iterator.hasNext());\n    }\n}", "definition": "public class ImmutableStack_iteratorTest", "class_docstring": "", "name": "ImmutableStack_iteratorTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private ImmutableStack<String> stack;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "ImmutableStack<String>", "name": "stack", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @Before\n    public void setUp() {\n        stack = ImmutableStack.empty();\n    }", "docstring": "", "attributes": {"modifiers": "@Before\n    public", "marker_annotations": ["@Before"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setUp", "params": [], "body": "                        {\n        stack = ImmutableStack.empty();\n    }", "signature": "@Before\n    public void setUp()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testIteratorWithNonEmptyStack() {\n        stack = stack.push(\"a\").push(\"b\").push(\"c\");\n        Iterator<String> iterator = stack.iterator();\n\n        assertTrue(iterator.hasNext());\n        assertEquals(\"c\", iterator.next());\n        assertTrue(iterator.hasNext());\n        assertEquals(\"b\", iterator.next());\n        assertTrue(iterator.hasNext());\n        assertEquals(\"a\", iterator.next());\n        assertFalse(iterator.hasNext());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testIteratorWithNonEmptyStack", "params": [], "body": "                                                {\n        stack = stack.push(\"a\").push(\"b\").push(\"c\");\n        Iterator<String> iterator = stack.iterator();\n\n        assertTrue(iterator.hasNext());\n        assertEquals(\"c\", iterator.next());\n        assertTrue(iterator.hasNext());\n        assertEquals(\"b\", iterator.next());\n        assertTrue(iterator.hasNext());\n        assertEquals(\"a\", iterator.next());\n        assertFalse(iterator.hasNext());\n    }", "signature": "@Test\n    public void testIteratorWithNonEmptyStack()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testIteratorWithEmptyStack() {\n        Iterator<String> iterator = stack.iterator();\n\n        assertFalse(iterator.hasNext());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testIteratorWithEmptyStack", "params": [], "body": "                                             {\n        Iterator<String> iterator = stack.iterator();\n\n        assertFalse(iterator.hasNext());\n    }", "signature": "@Test\n    public void testIteratorWithEmptyStack()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/com/github/davidmoten/rtree/internal/util/BoundedPriorityQueue_asOrderedListTest.java", "original_string": "\npackage com.github.davidmoten.rtree.internal.util;\n\nimport static com.github.davidmoten.rtree.internal.util.BoundedPriorityQueue.create;\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertTrue;\n\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.List;\n\nimport org.junit.Before;\nimport org.junit.Test;\n\npublic class BoundedPriorityQueue_asOrderedListTest {\n\n    private static final Comparator<Integer> comparator = Comparator.naturalOrder();\n    private BoundedPriorityQueue<Integer> queue;\n\n    @Before\n    public void setUp() {\n        queue = create(3, comparator);\n    }\n\n    @Test\n    public void testAsOrderedListWithEmptyQueue() {\n        List<Integer> result = queue.asOrderedList();\n        assertTrue(result.isEmpty());\n    }\n\n    @Test\n    public void testAsOrderedListWithSingleElement() {\n        queue.add(5);\n        List<Integer> result = queue.asOrderedList();\n        assertEquals(Arrays.asList(5), result);\n    }\n\n    @Test\n    public void testAsOrderedListWithMultipleElements() {\n        queue.add(5);\n        queue.add(3);\n        queue.add(7);\n        List<Integer> result = queue.asOrderedList();\n        assertEquals(Arrays.asList(3, 5, 7), result);\n    }\n}\n", "file_hash": "951dc697cd60eb66344be0febff2110899be2ebdfe717e345ddd970c2164e51f", "file_docstring": "", "contexts": ["package com.github.davidmoten.rtree.internal.util;", "import static com.github.davidmoten.rtree.internal.util.BoundedPriorityQueue.create;", "import static org.junit.Assert.assertEquals;", "import static org.junit.Assert.assertTrue;", "import java.util.Arrays;", "import java.util.Comparator;", "import java.util.List;", "import org.junit.Before;", "import org.junit.Test;"], "methods": [], "classes": [{"original_string": "public class BoundedPriorityQueue_asOrderedListTest {\n\n    private static final Comparator<Integer> comparator = Comparator.naturalOrder();\n    private BoundedPriorityQueue<Integer> queue;\n\n    @Before\n    public void setUp() {\n        queue = create(3, comparator);\n    }\n\n    @Test\n    public void testAsOrderedListWithEmptyQueue() {\n        List<Integer> result = queue.asOrderedList();\n        assertTrue(result.isEmpty());\n    }\n\n    @Test\n    public void testAsOrderedListWithSingleElement() {\n        queue.add(5);\n        List<Integer> result = queue.asOrderedList();\n        assertEquals(Arrays.asList(5), result);\n    }\n\n    @Test\n    public void testAsOrderedListWithMultipleElements() {\n        queue.add(5);\n        queue.add(3);\n        queue.add(7);\n        List<Integer> result = queue.asOrderedList();\n        assertEquals(Arrays.asList(3, 5, 7), result);\n    }\n}", "definition": "public class BoundedPriorityQueue_asOrderedListTest", "class_docstring": "", "name": "BoundedPriorityQueue_asOrderedListTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private static final Comparator<Integer> comparator = Comparator.naturalOrder();", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Comparator<Integer>", "name": "comparator = Comparator.naturalOrder()", "syntax_pass": true}, {"attribute_expression": "private BoundedPriorityQueue<Integer> queue;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "BoundedPriorityQueue<Integer>", "name": "queue", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @Before\n    public void setUp() {\n        queue = create(3, comparator);\n    }", "docstring": "", "attributes": {"modifiers": "@Before\n    public", "marker_annotations": ["@Before"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setUp", "params": [], "body": "                        {\n        queue = create(3, comparator);\n    }", "signature": "@Before\n    public void setUp()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testAsOrderedListWithEmptyQueue() {\n        List<Integer> result = queue.asOrderedList();\n        assertTrue(result.isEmpty());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testAsOrderedListWithEmptyQueue", "params": [], "body": "                                                  {\n        List<Integer> result = queue.asOrderedList();\n        assertTrue(result.isEmpty());\n    }", "signature": "@Test\n    public void testAsOrderedListWithEmptyQueue()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testAsOrderedListWithSingleElement() {\n        queue.add(5);\n        List<Integer> result = queue.asOrderedList();\n        assertEquals(Arrays.asList(5), result);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testAsOrderedListWithSingleElement", "params": [], "body": "                                                     {\n        queue.add(5);\n        List<Integer> result = queue.asOrderedList();\n        assertEquals(Arrays.asList(5), result);\n    }", "signature": "@Test\n    public void testAsOrderedListWithSingleElement()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testAsOrderedListWithMultipleElements() {\n        queue.add(5);\n        queue.add(3);\n        queue.add(7);\n        List<Integer> result = queue.asOrderedList();\n        assertEquals(Arrays.asList(3, 5, 7), result);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testAsOrderedListWithMultipleElements", "params": [], "body": "                                                        {\n        queue.add(5);\n        queue.add(3);\n        queue.add(7);\n        List<Integer> result = queue.asOrderedList();\n        assertEquals(Arrays.asList(3, 5, 7), result);\n    }", "signature": "@Test\n    public void testAsOrderedListWithMultipleElements()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/com/github/davidmoten/rtree/internal/util/ImmutableStack_emptyTest.java", "original_string": "\npackage com.github.davidmoten.rtree.internal.util;\n\nimport static org.junit.Assert.assertTrue;\nimport org.junit.Test;\n\npublic class ImmutableStack_emptyTest {\n\n    @Test\n    public void testEmptyStackIsEmpty() {\n        ImmutableStack<Object> emptyStack = ImmutableStack.empty();\n        assertTrue(emptyStack.isEmpty());\n    }\n}\n", "file_hash": "6fd2fc407932fba08fd7db429225c6bd8829ac7d68c41554398e5f4db9ce1831", "file_docstring": "", "contexts": ["package com.github.davidmoten.rtree.internal.util;", "import static org.junit.Assert.assertTrue;", "import org.junit.Test;"], "methods": [], "classes": [{"original_string": "public class ImmutableStack_emptyTest {\n\n    @Test\n    public void testEmptyStackIsEmpty() {\n        ImmutableStack<Object> emptyStack = ImmutableStack.empty();\n        assertTrue(emptyStack.isEmpty());\n    }\n}", "definition": "public class ImmutableStack_emptyTest", "class_docstring": "", "name": "ImmutableStack_emptyTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @Test\n    public void testEmptyStackIsEmpty() {\n        ImmutableStack<Object> emptyStack = ImmutableStack.empty();\n        assertTrue(emptyStack.isEmpty());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testEmptyStackIsEmpty", "params": [], "body": "                                        {\n        ImmutableStack<Object> emptyStack = ImmutableStack.empty();\n        assertTrue(emptyStack.isEmpty());\n    }", "signature": "@Test\n    public void testEmptyStackIsEmpty()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/com/github/davidmoten/rtree/internal/util/ImmutableStack_peekTest.java", "original_string": "\npackage com.github.davidmoten.rtree.internal.util;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertTrue;\nimport org.junit.Test;\n\npublic class ImmutableStack_peekTest {\n\n    @Test\n    public void testPeekOnNonEmptyStack() {\n        ImmutableStack<String> stack = ImmutableStack.<String>empty().push(\"element\");\n        assertEquals(\"element\", stack.peek());\n    }\n\n    @Test(expected = RuntimeException.class)\n    public void testPeekOnEmptyStack() {\n        ImmutableStack<String> stack = ImmutableStack.<String>empty();\n        stack.peek(); // This should throw a RuntimeException\n    }\n}\n", "file_hash": "6f8955f72061ee452d933108ac8fcb08710efc7d588cac4cc9e8c29947b579be", "file_docstring": "", "contexts": ["package com.github.davidmoten.rtree.internal.util;", "import static org.junit.Assert.assertEquals;", "import static org.junit.Assert.assertTrue;", "import org.junit.Test;"], "methods": [], "classes": [{"original_string": "public class ImmutableStack_peekTest {\n\n    @Test\n    public void testPeekOnNonEmptyStack() {\n        ImmutableStack<String> stack = ImmutableStack.<String>empty().push(\"element\");\n        assertEquals(\"element\", stack.peek());\n    }\n\n    @Test(expected = RuntimeException.class)\n    public void testPeekOnEmptyStack() {\n        ImmutableStack<String> stack = ImmutableStack.<String>empty();\n        stack.peek(); // This should throw a RuntimeException\n    }\n}", "definition": "public class ImmutableStack_peekTest", "class_docstring": "", "name": "ImmutableStack_peekTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @Test\n    public void testPeekOnNonEmptyStack() {\n        ImmutableStack<String> stack = ImmutableStack.<String>empty().push(\"element\");\n        assertEquals(\"element\", stack.peek());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testPeekOnNonEmptyStack", "params": [], "body": "                                          {\n        ImmutableStack<String> stack = ImmutableStack.<String>empty().push(\"element\");\n        assertEquals(\"element\", stack.peek());\n    }", "signature": "@Test\n    public void testPeekOnNonEmptyStack()"}, {"syntax_pass": true, "original_string": "    @Test(expected = RuntimeException.class)\n    public void testPeekOnEmptyStack() {\n        ImmutableStack<String> stack = ImmutableStack.<String>empty();\n        stack.peek(); // This should throw a RuntimeException\n    }", "docstring": "", "attributes": {"modifiers": "@Test(expected = RuntimeException.class)\n    public", "marker_annotations": [], "non_marker_annotations": ["@Test(expected = RuntimeException.class)", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "testPeekOnEmptyStack", "params": [], "body": "                                       {\n        ImmutableStack<String> stack = ImmutableStack.<String>empty();\n        stack.peek(); // This should throw a RuntimeException\n    }", "signature": "@Test(expected = RuntimeException.class)\n    public void testPeekOnEmptyStack()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/com/github/davidmoten/internal/operators/OperatorBoundedPriorityQueueTest.java", "original_string": "package com.github.davidmoten.internal.operators;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertFalse;\nimport static org.junit.Assert.assertTrue;\n\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.List;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\nimport org.junit.Test;\n\nimport com.github.davidmoten.rtree.RTree;\nimport com.github.davidmoten.rtree.geometry.Geometries;\nimport com.github.davidmoten.rtree.geometry.Line;\nimport com.github.davidmoten.rtree.internal.operators.OperatorBoundedPriorityQueue;\n\nimport rx.Observable;\nimport rx.Observable.OnSubscribe;\nimport rx.Subscriber;\n\npublic class OperatorBoundedPriorityQueueTest {\n\n    private static Comparator<Integer> integerComparator = (i1, i2) -> i1.compareTo(i2);\n\n    @Test\n    public void testPriority() {\n        List<Integer> list = Observable.range(1, 5)\n                .lift(new OperatorBoundedPriorityQueue<Integer>(2, integerComparator)).toSortedList()\n                .toBlocking().single();\n        assertEquals(Arrays.asList(1, 2), list);\n    }\n\n    @Test\n    public void testUnsubscribeAfterFirst() {\n        final AtomicBoolean completed = new AtomicBoolean(false);\n        Observable.range(1, 5)\n                // go through priority queue\n                .lift(new OperatorBoundedPriorityQueue<Integer>(2, integerComparator))\n                // subscribe\n                .subscribe(new Subscriber<Integer>() {\n\n                    @Override\n                    public void onCompleted() {\n                        completed.set(true);\n                    }\n\n                    @Override\n                    public void onError(Throwable e) {\n                    }\n\n                    @Override\n                    public void onNext(Integer t) {\n                        unsubscribe();\n                    }\n                });\n        assertFalse(completed.get());\n    }\n\n    @Test\n    public void testUnsubscribeAfterLastButBeforeCompletedCalled() {\n        final AtomicBoolean completed = new AtomicBoolean(false);\n        Observable.range(1, 5)\n                // go through priority queue\n                .lift(new OperatorBoundedPriorityQueue<Integer>(2, integerComparator))\n                // subscribe\n                .subscribe(new Subscriber<Integer>() {\n\n                    int i = 0;\n\n                    @Override\n                    public void onCompleted() {\n                        completed.set(true);\n                    }\n\n                    @Override\n                    public void onError(Throwable e) {\n                    }\n\n                    @Override\n                    public void onNext(Integer t) {\n                        i++;\n                        if (i == 2)\n                            unsubscribe();\n                    }\n                });\n        assertFalse(completed.get());\n    }\n\n    @Test\n    public void testError() {\n        final AtomicBoolean completed = new AtomicBoolean(false);\n        final AtomicBoolean error = new AtomicBoolean(false);\n        Observable.<Integer> error(new RuntimeException())\n                // go through priority queue\n                .lift(new OperatorBoundedPriorityQueue<Integer>(2, integerComparator))\n                // subscribe\n                .subscribe(new Subscriber<Integer>() {\n\n                    @Override\n                    public void onCompleted() {\n                        completed.set(true);\n                    }\n\n                    @Override\n                    public void onError(Throwable e) {\n                        error.set(true);\n                    }\n\n                    @Override\n                    public void onNext(Integer t) {\n\n                    }\n                });\n        assertFalse(completed.get());\n        assertTrue(error.get());\n    }\n\n    @Test\n    public void testErrorCalledJustAfterUnsubscribe() {\n        final AtomicBoolean error = new AtomicBoolean(false);\n        final Subscriber<Integer> subscriber = new Subscriber<Integer>() {\n\n            @Override\n            public void onCompleted() {\n            }\n\n            @Override\n            public void onError(Throwable e) {\n                error.set(true);\n            }\n\n            @Override\n            public void onNext(Integer t) {\n            }\n        };\n        Observable.create(new OnSubscribe<Integer>() {\n\n            @Override\n            public void call(Subscriber<? super Integer> sub) {\n                sub.onNext(1);\n                subscriber.unsubscribe();\n                sub.onError(new RuntimeException());\n            }\n        })\n                // go through priority queue\n                .lift(new OperatorBoundedPriorityQueue<Integer>(1, integerComparator))\n                // subscribe\n                .subscribe(subscriber);\n        assertFalse(error.get());\n    }\n\n    @Test\n    public void testUnsubscribeCalledAfterFirst() {\n        final AtomicBoolean completed = new AtomicBoolean(false);\n        final AtomicBoolean next = new AtomicBoolean(false);\n        final Subscriber<Integer> subscriber = new Subscriber<Integer>() {\n\n            @Override\n            public void onCompleted() {\n                completed.set(true);\n            }\n\n            @Override\n            public void onError(Throwable e) {\n            }\n\n            @Override\n            public void onNext(Integer t) {\n                next.set(true);\n            }\n        };\n        Observable.create(new OnSubscribe<Integer>() {\n\n            @Override\n            public void call(Subscriber<? super Integer> sub) {\n                sub.onNext(1);\n                subscriber.unsubscribe();\n                sub.onNext(2);\n                sub.onCompleted();\n            }\n        })\n                // go through priority queue\n                .lift(new OperatorBoundedPriorityQueue<Integer>(1, integerComparator))\n                // subscribe\n                .subscribe(subscriber);\n        assertFalse(completed.get());\n        assertFalse(next.get());\n    }\n\n    @Test(timeout = 3000)\n    public void testOperatorShouldRequestMaxFromUpstream() {\n        RTree<String, Line> tree = RTree.star().create();\n        for (int i = 0; i < 5; ++i) {\n            tree = tree.add(String.format(\"Hello %d\", i), Geometries.line(-i, -i, 5 + i, i));\n        }\n        tree.nearest(Geometries.point(2, 0.4), Double.MAX_VALUE, 1).toBlocking().single();\n    }\n\n}\n", "file_hash": "e85546f285325650bacc4e2c459f30646b112f74f519acc460affdeb7a1ee968", "file_docstring": "", "contexts": ["package com.github.davidmoten.internal.operators;", "import static org.junit.Assert.assertEquals;", "import static org.junit.Assert.assertFalse;", "import static org.junit.Assert.assertTrue;", "import java.util.Arrays;", "import java.util.Comparator;", "import java.util.List;", "import java.util.concurrent.atomic.AtomicBoolean;", "import org.junit.Test;", "import com.github.davidmoten.rtree.RTree;", "import com.github.davidmoten.rtree.geometry.Geometries;", "import com.github.davidmoten.rtree.geometry.Line;", "import com.github.davidmoten.rtree.internal.operators.OperatorBoundedPriorityQueue;", "import rx.Observable;", "import rx.Observable.OnSubscribe;", "import rx.Subscriber;"], "methods": [], "classes": [{"original_string": "public class OperatorBoundedPriorityQueueTest {\n\n    private static Comparator<Integer> integerComparator = (i1, i2) -> i1.compareTo(i2);\n\n    @Test\n    public void testPriority() {\n        List<Integer> list = Observable.range(1, 5)\n                .lift(new OperatorBoundedPriorityQueue<Integer>(2, integerComparator)).toSortedList()\n                .toBlocking().single();\n        assertEquals(Arrays.asList(1, 2), list);\n    }\n\n    @Test\n    public void testUnsubscribeAfterFirst() {\n        final AtomicBoolean completed = new AtomicBoolean(false);\n        Observable.range(1, 5)\n                // go through priority queue\n                .lift(new OperatorBoundedPriorityQueue<Integer>(2, integerComparator))\n                // subscribe\n                .subscribe(new Subscriber<Integer>() {\n\n                    @Override\n                    public void onCompleted() {\n                        completed.set(true);\n                    }\n\n                    @Override\n                    public void onError(Throwable e) {\n                    }\n\n                    @Override\n                    public void onNext(Integer t) {\n                        unsubscribe();\n                    }\n                });\n        assertFalse(completed.get());\n    }\n\n    @Test\n    public void testUnsubscribeAfterLastButBeforeCompletedCalled() {\n        final AtomicBoolean completed = new AtomicBoolean(false);\n        Observable.range(1, 5)\n                // go through priority queue\n                .lift(new OperatorBoundedPriorityQueue<Integer>(2, integerComparator))\n                // subscribe\n                .subscribe(new Subscriber<Integer>() {\n\n                    int i = 0;\n\n                    @Override\n                    public void onCompleted() {\n                        completed.set(true);\n                    }\n\n                    @Override\n                    public void onError(Throwable e) {\n                    }\n\n                    @Override\n                    public void onNext(Integer t) {\n                        i++;\n                        if (i == 2)\n                            unsubscribe();\n                    }\n                });\n        assertFalse(completed.get());\n    }\n\n    @Test\n    public void testError() {\n        final AtomicBoolean completed = new AtomicBoolean(false);\n        final AtomicBoolean error = new AtomicBoolean(false);\n        Observable.<Integer> error(new RuntimeException())\n                // go through priority queue\n                .lift(new OperatorBoundedPriorityQueue<Integer>(2, integerComparator))\n                // subscribe\n                .subscribe(new Subscriber<Integer>() {\n\n                    @Override\n                    public void onCompleted() {\n                        completed.set(true);\n                    }\n\n                    @Override\n                    public void onError(Throwable e) {\n                        error.set(true);\n                    }\n\n                    @Override\n                    public void onNext(Integer t) {\n\n                    }\n                });\n        assertFalse(completed.get());\n        assertTrue(error.get());\n    }\n\n    @Test\n    public void testErrorCalledJustAfterUnsubscribe() {\n        final AtomicBoolean error = new AtomicBoolean(false);\n        final Subscriber<Integer> subscriber = new Subscriber<Integer>() {\n\n            @Override\n            public void onCompleted() {\n            }\n\n            @Override\n            public void onError(Throwable e) {\n                error.set(true);\n            }\n\n            @Override\n            public void onNext(Integer t) {\n            }\n        };\n        Observable.create(new OnSubscribe<Integer>() {\n\n            @Override\n            public void call(Subscriber<? super Integer> sub) {\n                sub.onNext(1);\n                subscriber.unsubscribe();\n                sub.onError(new RuntimeException());\n            }\n        })\n                // go through priority queue\n                .lift(new OperatorBoundedPriorityQueue<Integer>(1, integerComparator))\n                // subscribe\n                .subscribe(subscriber);\n        assertFalse(error.get());\n    }\n\n    @Test\n    public void testUnsubscribeCalledAfterFirst() {\n        final AtomicBoolean completed = new AtomicBoolean(false);\n        final AtomicBoolean next = new AtomicBoolean(false);\n        final Subscriber<Integer> subscriber = new Subscriber<Integer>() {\n\n            @Override\n            public void onCompleted() {\n                completed.set(true);\n            }\n\n            @Override\n            public void onError(Throwable e) {\n            }\n\n            @Override\n            public void onNext(Integer t) {\n                next.set(true);\n            }\n        };\n        Observable.create(new OnSubscribe<Integer>() {\n\n            @Override\n            public void call(Subscriber<? super Integer> sub) {\n                sub.onNext(1);\n                subscriber.unsubscribe();\n                sub.onNext(2);\n                sub.onCompleted();\n            }\n        })\n                // go through priority queue\n                .lift(new OperatorBoundedPriorityQueue<Integer>(1, integerComparator))\n                // subscribe\n                .subscribe(subscriber);\n        assertFalse(completed.get());\n        assertFalse(next.get());\n    }\n\n    @Test(timeout = 3000)\n    public void testOperatorShouldRequestMaxFromUpstream() {\n        RTree<String, Line> tree = RTree.star().create();\n        for (int i = 0; i < 5; ++i) {\n            tree = tree.add(String.format(\"Hello %d\", i), Geometries.line(-i, -i, 5 + i, i));\n        }\n        tree.nearest(Geometries.point(2, 0.4), Double.MAX_VALUE, 1).toBlocking().single();\n    }\n\n}", "definition": "public class OperatorBoundedPriorityQueueTest", "class_docstring": "", "name": "OperatorBoundedPriorityQueueTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private static Comparator<Integer> integerComparator = (i1, i2) -> i1.compareTo(i2);", "docstring": "", "modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "type": "Comparator<Integer>", "name": "integerComparator = (i1, i2) -> i1.compareTo(i2)", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @Test\n    public void testPriority() {\n        List<Integer> list = Observable.range(1, 5)\n                .lift(new OperatorBoundedPriorityQueue<Integer>(2, integerComparator)).toSortedList()\n                .toBlocking().single();\n        assertEquals(Arrays.asList(1, 2), list);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testPriority", "params": [], "body": "                               {\n        List<Integer> list = Observable.range(1, 5)\n                .lift(new OperatorBoundedPriorityQueue<Integer>(2, integerComparator)).toSortedList()\n                .toBlocking().single();\n        assertEquals(Arrays.asList(1, 2), list);\n    }", "signature": "@Test\n    public void testPriority()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testUnsubscribeAfterFirst() {\n        final AtomicBoolean completed = new AtomicBoolean(false);\n        Observable.range(1, 5)\n                // go through priority queue\n                .lift(new OperatorBoundedPriorityQueue<Integer>(2, integerComparator))\n                // subscribe\n                .subscribe(new Subscriber<Integer>() {\n\n                    @Override\n                    public void onCompleted() {\n                        completed.set(true);\n                    }\n\n                    @Override\n                    public void onError(Throwable e) {\n                    }\n\n                    @Override\n                    public void onNext(Integer t) {\n                        unsubscribe();\n                    }\n                });\n        assertFalse(completed.get());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testUnsubscribeAfterFirst", "params": [], "body": "                                            {\n        final AtomicBoolean completed = new AtomicBoolean(false);\n        Observable.range(1, 5)\n                // go through priority queue\n                .lift(new OperatorBoundedPriorityQueue<Integer>(2, integerComparator))\n                // subscribe\n                .subscribe(new Subscriber<Integer>() {\n\n                    @Override\n                    public void onCompleted() {\n                        completed.set(true);\n                    }\n\n                    @Override\n                    public void onError(Throwable e) {\n                    }\n\n                    @Override\n                    public void onNext(Integer t) {\n                        unsubscribe();\n                    }\n                });\n        assertFalse(completed.get());\n    }", "signature": "@Test\n    public void testUnsubscribeAfterFirst()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testUnsubscribeAfterLastButBeforeCompletedCalled() {\n        final AtomicBoolean completed = new AtomicBoolean(false);\n        Observable.range(1, 5)\n                // go through priority queue\n                .lift(new OperatorBoundedPriorityQueue<Integer>(2, integerComparator))\n                // subscribe\n                .subscribe(new Subscriber<Integer>() {\n\n                    int i = 0;\n\n                    @Override\n                    public void onCompleted() {\n                        completed.set(true);\n                    }\n\n                    @Override\n                    public void onError(Throwable e) {\n                    }\n\n                    @Override\n                    public void onNext(Integer t) {\n                        i++;\n                        if (i == 2)\n                            unsubscribe();\n                    }\n                });\n        assertFalse(completed.get());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testUnsubscribeAfterLastButBeforeCompletedCalled", "params": [], "body": "                                                                   {\n        final AtomicBoolean completed = new AtomicBoolean(false);\n        Observable.range(1, 5)\n                // go through priority queue\n                .lift(new OperatorBoundedPriorityQueue<Integer>(2, integerComparator))\n                // subscribe\n                .subscribe(new Subscriber<Integer>() {\n\n                    int i = 0;\n\n                    @Override\n                    public void onCompleted() {\n                        completed.set(true);\n                    }\n\n                    @Override\n                    public void onError(Throwable e) {\n                    }\n\n                    @Override\n                    public void onNext(Integer t) {\n                        i++;\n                        if (i == 2)\n                            unsubscribe();\n                    }\n                });\n        assertFalse(completed.get());\n    }", "signature": "@Test\n    public void testUnsubscribeAfterLastButBeforeCompletedCalled()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testError() {\n        final AtomicBoolean completed = new AtomicBoolean(false);\n        final AtomicBoolean error = new AtomicBoolean(false);\n        Observable.<Integer> error(new RuntimeException())\n                // go through priority queue\n                .lift(new OperatorBoundedPriorityQueue<Integer>(2, integerComparator))\n                // subscribe\n                .subscribe(new Subscriber<Integer>() {\n\n                    @Override\n                    public void onCompleted() {\n                        completed.set(true);\n                    }\n\n                    @Override\n                    public void onError(Throwable e) {\n                        error.set(true);\n                    }\n\n                    @Override\n                    public void onNext(Integer t) {\n\n                    }\n                });\n        assertFalse(completed.get());\n        assertTrue(error.get());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testError", "params": [], "body": "                            {\n        final AtomicBoolean completed = new AtomicBoolean(false);\n        final AtomicBoolean error = new AtomicBoolean(false);\n        Observable.<Integer> error(new RuntimeException())\n                // go through priority queue\n                .lift(new OperatorBoundedPriorityQueue<Integer>(2, integerComparator))\n                // subscribe\n                .subscribe(new Subscriber<Integer>() {\n\n                    @Override\n                    public void onCompleted() {\n                        completed.set(true);\n                    }\n\n                    @Override\n                    public void onError(Throwable e) {\n                        error.set(true);\n                    }\n\n                    @Override\n                    public void onNext(Integer t) {\n\n                    }\n                });\n        assertFalse(completed.get());\n        assertTrue(error.get());\n    }", "signature": "@Test\n    public void testError()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testErrorCalledJustAfterUnsubscribe() {\n        final AtomicBoolean error = new AtomicBoolean(false);\n        final Subscriber<Integer> subscriber = new Subscriber<Integer>() {\n\n            @Override\n            public void onCompleted() {\n            }\n\n            @Override\n            public void onError(Throwable e) {\n                error.set(true);\n            }\n\n            @Override\n            public void onNext(Integer t) {\n            }\n        };\n        Observable.create(new OnSubscribe<Integer>() {\n\n            @Override\n            public void call(Subscriber<? super Integer> sub) {\n                sub.onNext(1);\n                subscriber.unsubscribe();\n                sub.onError(new RuntimeException());\n            }\n        })\n                // go through priority queue\n                .lift(new OperatorBoundedPriorityQueue<Integer>(1, integerComparator))\n                // subscribe\n                .subscribe(subscriber);\n        assertFalse(error.get());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testErrorCalledJustAfterUnsubscribe", "params": [], "body": "                                                      {\n        final AtomicBoolean error = new AtomicBoolean(false);\n        final Subscriber<Integer> subscriber = new Subscriber<Integer>() {\n\n            @Override\n            public void onCompleted() {\n            }\n\n            @Override\n            public void onError(Throwable e) {\n                error.set(true);\n            }\n\n            @Override\n            public void onNext(Integer t) {\n            }\n        };\n        Observable.create(new OnSubscribe<Integer>() {\n\n            @Override\n            public void call(Subscriber<? super Integer> sub) {\n                sub.onNext(1);\n                subscriber.unsubscribe();\n                sub.onError(new RuntimeException());\n            }\n        })\n                // go through priority queue\n                .lift(new OperatorBoundedPriorityQueue<Integer>(1, integerComparator))\n                // subscribe\n                .subscribe(subscriber);\n        assertFalse(error.get());\n    }", "signature": "@Test\n    public void testErrorCalledJustAfterUnsubscribe()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testUnsubscribeCalledAfterFirst() {\n        final AtomicBoolean completed = new AtomicBoolean(false);\n        final AtomicBoolean next = new AtomicBoolean(false);\n        final Subscriber<Integer> subscriber = new Subscriber<Integer>() {\n\n            @Override\n            public void onCompleted() {\n                completed.set(true);\n            }\n\n            @Override\n            public void onError(Throwable e) {\n            }\n\n            @Override\n            public void onNext(Integer t) {\n                next.set(true);\n            }\n        };\n        Observable.create(new OnSubscribe<Integer>() {\n\n            @Override\n            public void call(Subscriber<? super Integer> sub) {\n                sub.onNext(1);\n                subscriber.unsubscribe();\n                sub.onNext(2);\n                sub.onCompleted();\n            }\n        })\n                // go through priority queue\n                .lift(new OperatorBoundedPriorityQueue<Integer>(1, integerComparator))\n                // subscribe\n                .subscribe(subscriber);\n        assertFalse(completed.get());\n        assertFalse(next.get());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testUnsubscribeCalledAfterFirst", "params": [], "body": "                                                  {\n        final AtomicBoolean completed = new AtomicBoolean(false);\n        final AtomicBoolean next = new AtomicBoolean(false);\n        final Subscriber<Integer> subscriber = new Subscriber<Integer>() {\n\n            @Override\n            public void onCompleted() {\n                completed.set(true);\n            }\n\n            @Override\n            public void onError(Throwable e) {\n            }\n\n            @Override\n            public void onNext(Integer t) {\n                next.set(true);\n            }\n        };\n        Observable.create(new OnSubscribe<Integer>() {\n\n            @Override\n            public void call(Subscriber<? super Integer> sub) {\n                sub.onNext(1);\n                subscriber.unsubscribe();\n                sub.onNext(2);\n                sub.onCompleted();\n            }\n        })\n                // go through priority queue\n                .lift(new OperatorBoundedPriorityQueue<Integer>(1, integerComparator))\n                // subscribe\n                .subscribe(subscriber);\n        assertFalse(completed.get());\n        assertFalse(next.get());\n    }", "signature": "@Test\n    public void testUnsubscribeCalledAfterFirst()"}, {"syntax_pass": true, "original_string": "    @Test(timeout = 3000)\n    public void testOperatorShouldRequestMaxFromUpstream() {\n        RTree<String, Line> tree = RTree.star().create();\n        for (int i = 0; i < 5; ++i) {\n            tree = tree.add(String.format(\"Hello %d\", i), Geometries.line(-i, -i, 5 + i, i));\n        }\n        tree.nearest(Geometries.point(2, 0.4), Double.MAX_VALUE, 1).toBlocking().single();\n    }", "docstring": "", "attributes": {"modifiers": "@Test(timeout = 3000)\n    public", "marker_annotations": [], "non_marker_annotations": ["@Test(timeout = 3000)", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "testOperatorShouldRequestMaxFromUpstream", "params": [], "body": "                                                           {\n        RTree<String, Line> tree = RTree.star().create();\n        for (int i = 0; i < 5; ++i) {\n            tree = tree.add(String.format(\"Hello %d\", i), Geometries.line(-i, -i, 5 + i, i));\n        }\n        tree.nearest(Geometries.point(2, 0.4), Double.MAX_VALUE, 1).toBlocking().single();\n    }", "signature": "@Test(timeout = 3000)\n    public void testOperatorShouldRequestMaxFromUpstream()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/com/github/davidmoten/rtree/SelectorRStar.java", "original_string": "package com.github.davidmoten.rtree;\n\nimport java.util.List;\n\nimport com.github.davidmoten.rtree.geometry.Geometry;\n\n/**\n * Uses minimal overlap area selector for leaf nodes and minimal areea increase\n * selector for non-leaf nodes.\n */\npublic final class SelectorRStar implements Selector {\n\n    private static Selector overlapAreaSelector = new SelectorMinimalOverlapArea();\n    private static Selector areaIncreaseSelector = new SelectorMinimalAreaIncrease();\n\n    @Override\n    public <T, S extends Geometry> Node<T, S> select(Geometry g, List<? extends Node<T, S>> nodes) {\n        boolean leafNodes = nodes.get(0) instanceof Leaf;\n        if (leafNodes)\n            return overlapAreaSelector.select(g, nodes);\n        else\n            return areaIncreaseSelector.select(g, nodes);\n    }\n\n}\n", "file_hash": "67525a0af6df554b6b8d1e2c84e0ac37c627a82a3d50f511b545cf4ba61f3650", "file_docstring": "", "contexts": ["package com.github.davidmoten.rtree;", "import java.util.List;", "import com.github.davidmoten.rtree.geometry.Geometry;"], "methods": [], "classes": [{"original_string": "public final class SelectorRStar implements Selector {\n\n    private static Selector overlapAreaSelector = new SelectorMinimalOverlapArea();\n    private static Selector areaIncreaseSelector = new SelectorMinimalAreaIncrease();\n\n    @Override\n    public <T, S extends Geometry> Node<T, S> select(Geometry g, List<? extends Node<T, S>> nodes) {\n        boolean leafNodes = nodes.get(0) instanceof Leaf;\n        if (leafNodes)\n            return overlapAreaSelector.select(g, nodes);\n        else\n            return areaIncreaseSelector.select(g, nodes);\n    }\n\n}", "definition": "public final class SelectorRStar implements Selector", "class_docstring": "\nUses minimal overlap area selector for leaf nodes and minimal areea increase\nselector for non-leaf nodes.\n", "name": "SelectorRStar", "super_interfaces": ["Selector"], "superclasses": "", "attributes": {"modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "fields": [{"attribute_expression": "private static Selector overlapAreaSelector = new SelectorMinimalOverlapArea();", "docstring": "", "modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "type": "Selector", "name": "overlapAreaSelector = new SelectorMinimalOverlapArea()", "syntax_pass": true}, {"attribute_expression": "private static Selector areaIncreaseSelector = new SelectorMinimalAreaIncrease();", "docstring": "", "modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "type": "Selector", "name": "areaIncreaseSelector = new SelectorMinimalAreaIncrease()", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @Override\n    public <T, S extends Geometry> Node<T, S> select(Geometry g, List<? extends Node<T, S>> nodes) {\n        boolean leafNodes = nodes.get(0) instanceof Leaf;\n        if (leafNodes)\n            return overlapAreaSelector.select(g, nodes);\n        else\n            return areaIncreaseSelector.select(g, nodes);\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Node<T, S>", "classes": []}, "name": "select", "params": [{"name": "g", "type": "Geometry"}, {"name": "nodes", "type": "List<? extends Node<T, S>>"}], "body": "                                                                                                   {\n        boolean leafNodes = nodes.get(0) instanceof Leaf;\n        if (leafNodes)\n            return overlapAreaSelector.select(g, nodes);\n        else\n            return areaIncreaseSelector.select(g, nodes);\n    }", "signature": "@Override\n    public <T, S extends Geometry> Node<T, S> select(Geometry g, List<? extends Node<T, S>> nodes)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/com/github/davidmoten/rtree/InternalStructure.java", "original_string": "package com.github.davidmoten.rtree;\n\npublic enum InternalStructure {\n\n    /**\n     * <P>\n     * Tree structure where nodes are stored in a single linear array and\n     * extracted on demand. This is a memory saving option (work on one-third\n     * the space) with some access performance penalties compared to the DEFAULT\n     * structure (assume one-tenth for search throughput).\n     * \n     * <p>\n     * Suited most for a static dataset loaded from storage because additions\n     * and deletions are not made to the single underlying array but rather\n     * combines the array with an object graph. Deletions are not recovered from\n     * the single array and after enough of them happen the datastructure should\n     * be rewritten to a new array to recover space.\n     * \n     */\n    SINGLE_ARRAY,\n\n    /**\n     * Tree structure using an object graph. Offers maximal performance for\n     * search/addition/deletion but consumes more memory than SINGLE_ARRAY.\n     */\n    DEFAULT;\n\n}\n", "file_hash": "85ed43375ef223696e587d7cab27de90d102140a0943c0056695e3001c73e993", "file_docstring": "", "contexts": ["package com.github.davidmoten.rtree;"], "methods": [], "classes": [], "interfaces": [], "records": []}, {"relative_path": "src/main/java/com/github/davidmoten/rtree/NonLeafFactory.java", "original_string": "package com.github.davidmoten.rtree;\n\nimport java.util.List;\n\nimport com.github.davidmoten.rtree.geometry.Geometry;\n\npublic interface NonLeafFactory<T, S extends Geometry> {\n\n    NonLeaf<T, S> createNonLeaf(List<? extends Node<T, S>> children, Context<T, S> context);\n}\n", "file_hash": "ff22a50bc75789c8b4ef7679afd5749148ed2c77d82cb086da00daa82fcffad3", "file_docstring": "", "contexts": ["package com.github.davidmoten.rtree;", "import java.util.List;", "import com.github.davidmoten.rtree.geometry.Geometry;"], "methods": [], "classes": [], "interfaces": [{"original_string": "public interface NonLeafFactory<T, S extends Geometry> {\n\n    NonLeaf<T, S> createNonLeaf(List<? extends Node<T, S>> children, Context<T, S> context);\n}", "definition": "public interface NonLeafFactory<T, S extends Geometry>", "interface_docstring": "", "name": "NonLeafFactory", "extends_interfaces": [], "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    NonLeaf<T, S> createNonLeaf(List<? extends Node<T, S>> children, Context<T, S> context);", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "NonLeaf<T, S>", "classes": []}, "name": "createNonLeaf", "params": [{"name": "children", "type": "List<? extends Node<T, S>>"}, {"name": "context", "type": "Context<T, S>"}], "body": "", "signature": "NonLeaf<T, S> createNonLeaf(List<? extends Node<T, S>> children, Context<T, S> context)"}]}], "records": []}, {"relative_path": "src/main/java/com/github/davidmoten/rtree/SelectorMinimalOverlapArea.java", "original_string": "package com.github.davidmoten.rtree;\n\nimport static java.util.Collections.min;\n\nimport java.util.List;\n\nimport com.github.davidmoten.rtree.geometry.Geometry;\nimport com.github.davidmoten.rtree.internal.Comparators;\n\npublic final class SelectorMinimalOverlapArea implements Selector {\n\n    @Override\n    public <T, S extends Geometry> Node<T, S> select(Geometry g, List<? extends Node<T, S>> nodes) {\n        return min(nodes,\n                Comparators.overlapAreaThenAreaIncreaseThenAreaComparator(g.mbr(), nodes));\n    }\n\n}\n", "file_hash": "b2186bcb0f492efc43e24029b067518c5cdeab1047175b589392d07ae76e3d36", "file_docstring": "", "contexts": ["package com.github.davidmoten.rtree;", "import static java.util.Collections.min;", "import java.util.List;", "import com.github.davidmoten.rtree.geometry.Geometry;", "import com.github.davidmoten.rtree.internal.Comparators;"], "methods": [], "classes": [{"original_string": "public final class SelectorMinimalOverlapArea implements Selector {\n\n    @Override\n    public <T, S extends Geometry> Node<T, S> select(Geometry g, List<? extends Node<T, S>> nodes) {\n        return min(nodes,\n                Comparators.overlapAreaThenAreaIncreaseThenAreaComparator(g.mbr(), nodes));\n    }\n\n}", "definition": "public final class SelectorMinimalOverlapArea implements Selector", "class_docstring": "", "name": "SelectorMinimalOverlapArea", "super_interfaces": ["Selector"], "superclasses": "", "attributes": {"modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @Override\n    public <T, S extends Geometry> Node<T, S> select(Geometry g, List<? extends Node<T, S>> nodes) {\n        return min(nodes,\n                Comparators.overlapAreaThenAreaIncreaseThenAreaComparator(g.mbr(), nodes));\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Node<T, S>", "classes": []}, "name": "select", "params": [{"name": "g", "type": "Geometry"}, {"name": "nodes", "type": "List<? extends Node<T, S>>"}], "body": "                                                                                                   {\n        return min(nodes,\n                Comparators.overlapAreaThenAreaIncreaseThenAreaComparator(g.mbr(), nodes));\n    }", "signature": "@Override\n    public <T, S extends Geometry> Node<T, S> select(Geometry g, List<? extends Node<T, S>> nodes)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/com/github/davidmoten/rtree/NodePosition.java", "original_string": "package com.github.davidmoten.rtree;\n\nimport com.github.davidmoten.guavamini.Preconditions;\nimport com.github.davidmoten.rtree.geometry.Geometry;\n\nfinal class NodePosition<T, S extends Geometry> {\n\n    private final Node<T, S> node;\n    private final int position;\n\n    NodePosition(Node<T, S> node, int position) {\n        Preconditions.checkNotNull(node);\n        this.node = node;\n        this.position = position;\n    }\n\n    Node<T, S> node() {\n        return node;\n    }\n\n    int position() {\n        return position;\n    }\n\n    NodePosition<T, S> nextPosition() {\n        return new NodePosition<T, S>(node, position + 1);\n    }\n\n    @Override\n    public String toString() {\n        String builder = \"NodePosition [node=\" +\n                node +\n                \", position=\" +\n                position +\n                \"]\";\n        return builder;\n    }\n\n}\n", "file_hash": "dcf38284b15a713eb970edc54a369ee9682047bd9b3d666459cc546b5601a01b", "file_docstring": "", "contexts": ["package com.github.davidmoten.rtree;", "import com.github.davidmoten.guavamini.Preconditions;", "import com.github.davidmoten.rtree.geometry.Geometry;"], "methods": [], "classes": [{"original_string": "final class NodePosition<T, S extends Geometry> {\n\n    private final Node<T, S> node;\n    private final int position;\n\n    NodePosition(Node<T, S> node, int position) {\n        Preconditions.checkNotNull(node);\n        this.node = node;\n        this.position = position;\n    }\n\n    Node<T, S> node() {\n        return node;\n    }\n\n    int position() {\n        return position;\n    }\n\n    NodePosition<T, S> nextPosition() {\n        return new NodePosition<T, S>(node, position + 1);\n    }\n\n    @Override\n    public String toString() {\n        String builder = \"NodePosition [node=\" +\n                node +\n                \", position=\" +\n                position +\n                \"]\";\n        return builder;\n    }\n\n}", "definition": "final class NodePosition<T, S extends Geometry>", "class_docstring": "", "name": "NodePosition", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "fields": [{"attribute_expression": "private final Node<T, S> node;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Node<T, S>", "name": "node", "syntax_pass": true}, {"attribute_expression": "private final int position;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "int", "name": "position", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    NodePosition(Node<T, S> node, int position) {\n        Preconditions.checkNotNull(node);\n        this.node = node;\n        this.position = position;\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "NodePosition", "params": [{"name": "node", "type": "Node<T, S>"}, {"name": "position", "type": "int"}], "body": "                                                {\n        Preconditions.checkNotNull(node);\n        this.node = node;\n        this.position = position;\n    }", "signature": "NodePosition(Node<T, S> node, int position)"}, {"syntax_pass": true, "original_string": "    Node<T, S> node() {\n        return node;\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "Node<T, S>", "classes": []}, "name": "node", "params": [], "body": "                      {\n        return node;\n    }", "signature": "Node<T, S> node()"}, {"syntax_pass": true, "original_string": "    int position() {\n        return position;\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "int", "classes": []}, "name": "position", "params": [], "body": "                   {\n        return position;\n    }", "signature": "int position()"}, {"syntax_pass": true, "original_string": "    NodePosition<T, S> nextPosition() {\n        return new NodePosition<T, S>(node, position + 1);\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "NodePosition<T, S>", "classes": []}, "name": "nextPosition", "params": [], "body": "                                      {\n        return new NodePosition<T, S>(node, position + 1);\n    }", "signature": "NodePosition<T, S> nextPosition()"}, {"syntax_pass": true, "original_string": "    @Override\n    public String toString() {\n        String builder = \"NodePosition [node=\" +\n                node +\n                \", position=\" +\n                position +\n                \"]\";\n        return builder;\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "toString", "params": [], "body": "                             {\n        String builder = \"NodePosition [node=\" +\n                node +\n                \", position=\" +\n                position +\n                \"]\";\n        return builder;\n    }", "signature": "@Override\n    public String toString()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/com/github/davidmoten/rtree/Serializer.java", "original_string": "package com.github.davidmoten.rtree;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\n\nimport com.github.davidmoten.rtree.geometry.Geometry;\n\npublic interface Serializer<T, S extends Geometry> {\n\n    void write(RTree<T, S> tree, OutputStream os) throws IOException;\n\n    RTree<T, S> read(InputStream is, long sizeBytes, InternalStructure structure)\n            throws IOException;\n\n}", "file_hash": "66dbf372382a8f11419b483a1464cfecb92c70cc5dbb149e17ac9476df60b865", "file_docstring": "", "contexts": ["package com.github.davidmoten.rtree;", "import java.io.IOException;", "import java.io.InputStream;", "import java.io.OutputStream;", "import com.github.davidmoten.rtree.geometry.Geometry;"], "methods": [], "classes": [], "interfaces": [{"original_string": "public interface Serializer<T, S extends Geometry> {\n\n    void write(RTree<T, S> tree, OutputStream os) throws IOException;\n\n    RTree<T, S> read(InputStream is, long sizeBytes, InternalStructure structure)\n            throws IOException;\n\n}", "definition": "public interface Serializer<T, S extends Geometry>", "interface_docstring": "", "name": "Serializer", "extends_interfaces": [], "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    void write(RTree<T, S> tree, OutputStream os) throws IOException;", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "name": "write", "params": [{"name": "tree", "type": "RTree<T, S>"}, {"name": "os", "type": "OutputStream"}], "body": "", "signature": "void write(RTree<T, S> tree, OutputStream os)"}, {"syntax_pass": true, "original_string": "    RTree<T, S> read(InputStream is, long sizeBytes, InternalStructure structure)\n            throws IOException;", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "RTree<T, S>", "classes": []}, "name": "read", "params": [{"name": "is", "type": "InputStream"}, {"name": "sizeBytes", "type": "long"}, {"name": "structure", "type": "InternalStructure"}], "body": "", "signature": "RTree<T, S> read(InputStream is, long sizeBytes, InternalStructure structure)"}]}], "records": []}, {"relative_path": "src/main/java/com/github/davidmoten/rtree/Visualizer.java", "original_string": "package com.github.davidmoten.rtree;\n\nimport java.awt.AlphaComposite;\nimport java.awt.BasicStroke;\nimport java.awt.Color;\nimport java.awt.Graphics2D;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.util.*;\n\nimport com.github.davidmoten.rtree.geometry.Geometry;\nimport com.github.davidmoten.rtree.geometry.Rectangle;\n\npublic final class Visualizer {\n\n    private final RTree<?, Geometry> tree;\n    private final int width;\n    private final int height;\n    private final Rectangle view;\n    private final int maxDepth;\n\n    Visualizer(RTree<?, Geometry> tree, int width, int height, Rectangle view) {\n        this.tree = tree;\n        this.width = width;\n        this.height = height;\n        this.view = view;\n        this.maxDepth = calculateMaxDepth(tree.root());\n    }\n\n    private static <R, S extends Geometry> int calculateMaxDepth(\n            Optional<? extends Node<R, S>> root) {\n        if (!root.isPresent()) {\n            return 0;\n        } else {\n            return calculateDepth(root.get(), 0);\n        }\n    }\n\n    private static <R, S extends Geometry> int calculateDepth(Node<R, S> node, int depth) {\n        if (node instanceof Leaf) {\n            return depth + 1;\n        } else {\n            return calculateDepth(((NonLeaf<R, S>) node).child(0), depth + 1);\n        }\n    }\n\n    public BufferedImage createImage() {\n        final BufferedImage image = new BufferedImage(width, height, BufferedImage.TYPE_INT_ARGB);\n        final Graphics2D g = (Graphics2D) image.getGraphics();\n        g.setBackground(Color.white);\n        g.clearRect(0, 0, width, height);\n        g.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, 0.75f));\n\n        if (tree.root().isPresent()) {\n            final List<RectangleDepth> nodeDepths = getNodeDepthsSortedByDepth(tree.root().get());\n            drawNode(g, nodeDepths);\n        }\n        return image;\n    }\n\n    private <T, S extends Geometry> List<RectangleDepth> getNodeDepthsSortedByDepth(\n            Node<T, S> root) {\n        final List<RectangleDepth> list = getRectangleDepths(root, 0);\n        list.sort(Comparator.comparing(RectangleDepth::getDepth));\n        return list;\n    }\n\n    private <T, S extends Geometry> List<RectangleDepth> getRectangleDepths(Node<T, S> node,\n            int depth) {\n        final List<RectangleDepth> list = new ArrayList<RectangleDepth>();\n        list.add(new RectangleDepth(node.geometry().mbr(), depth));\n        if (node instanceof Leaf) {\n            final Leaf<T, S> leaf = (Leaf<T, S>) node;\n            for (final Entry<T, S> entry : leaf.entries()) {\n                list.add(new RectangleDepth(entry.geometry().mbr(), depth + 2));\n            }\n        } else {\n            final NonLeaf<T, S> n = (NonLeaf<T, S>) node;\n            for (int i = 0; i < n.count(); i++) {\n                list.addAll(getRectangleDepths(n.child(i), depth + 1));\n            }\n        }\n        return list;\n    }\n\n    private void drawNode(Graphics2D g, List<RectangleDepth> nodes) {\n        for (final RectangleDepth node : nodes) {\n            final Color color = Color.getHSBColor(node.getDepth() / (maxDepth + 1f), 1f, 1f);\n            g.setStroke(new BasicStroke(Math.max(0.5f, maxDepth - node.getDepth() + 1 - 1)));\n            g.setColor(color);\n            final Rectangle r = node.getRectangle();\n            drawRectangle(g, r);\n        }\n    }\n\n    private void drawRectangle(Graphics2D g, Rectangle r) {\n        final double x1 = (r.x1() - view.x1()) / (view.x2() - view.x1()) * width;\n        final double y1 = (r.y1() - view.y1()) / (view.y2() - view.y1()) * height;\n        final double x2 = (r.x2() - view.x1()) / (view.x2() - view.x1()) * width;\n        final double y2 = (r.y2() - view.y1()) / (view.y2() - view.y1()) * height;\n        g.drawRect(rnd(x1), rnd(y1), Math.max(rnd(x2 - x1), 1), Math.max(rnd(y2 - y1), 1));\n    }\n\n    private static int rnd(double d) {\n        return (int) Math.round(d);\n    }\n\n    public void save(File file, String imageFormat) {\n        ImageSaver.save(createImage(), file, imageFormat);\n    }\n\n    public void save(String filename, String imageFormat) {\n        save(new File(filename), imageFormat);\n    }\n\n    public void save(String filename) {\n        save(new File(filename), \"PNG\");\n    }\n}\n", "file_hash": "c56866ac439c2f117f6492de4561595b72db6c0680a77031205088a83bfcd55a", "file_docstring": "", "contexts": ["package com.github.davidmoten.rtree;", "import java.awt.AlphaComposite;", "import java.awt.BasicStroke;", "import java.awt.Color;", "import java.awt.Graphics2D;", "import java.awt.image.BufferedImage;", "import java.io.File;", "import java.util.*;", "import com.github.davidmoten.rtree.geometry.Geometry;", "import com.github.davidmoten.rtree.geometry.Rectangle;"], "methods": [], "classes": [{"original_string": "public final class Visualizer {\n\n    private final RTree<?, Geometry> tree;\n    private final int width;\n    private final int height;\n    private final Rectangle view;\n    private final int maxDepth;\n\n    Visualizer(RTree<?, Geometry> tree, int width, int height, Rectangle view) {\n        this.tree = tree;\n        this.width = width;\n        this.height = height;\n        this.view = view;\n        this.maxDepth = calculateMaxDepth(tree.root());\n    }\n\n    private static <R, S extends Geometry> int calculateMaxDepth(\n            Optional<? extends Node<R, S>> root) {\n        if (!root.isPresent()) {\n            return 0;\n        } else {\n            return calculateDepth(root.get(), 0);\n        }\n    }\n\n    private static <R, S extends Geometry> int calculateDepth(Node<R, S> node, int depth) {\n        if (node instanceof Leaf) {\n            return depth + 1;\n        } else {\n            return calculateDepth(((NonLeaf<R, S>) node).child(0), depth + 1);\n        }\n    }\n\n    public BufferedImage createImage() {\n        final BufferedImage image = new BufferedImage(width, height, BufferedImage.TYPE_INT_ARGB);\n        final Graphics2D g = (Graphics2D) image.getGraphics();\n        g.setBackground(Color.white);\n        g.clearRect(0, 0, width, height);\n        g.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, 0.75f));\n\n        if (tree.root().isPresent()) {\n            final List<RectangleDepth> nodeDepths = getNodeDepthsSortedByDepth(tree.root().get());\n            drawNode(g, nodeDepths);\n        }\n        return image;\n    }\n\n    private <T, S extends Geometry> List<RectangleDepth> getNodeDepthsSortedByDepth(\n            Node<T, S> root) {\n        final List<RectangleDepth> list = getRectangleDepths(root, 0);\n        list.sort(Comparator.comparing(RectangleDepth::getDepth));\n        return list;\n    }\n\n    private <T, S extends Geometry> List<RectangleDepth> getRectangleDepths(Node<T, S> node,\n            int depth) {\n        final List<RectangleDepth> list = new ArrayList<RectangleDepth>();\n        list.add(new RectangleDepth(node.geometry().mbr(), depth));\n        if (node instanceof Leaf) {\n            final Leaf<T, S> leaf = (Leaf<T, S>) node;\n            for (final Entry<T, S> entry : leaf.entries()) {\n                list.add(new RectangleDepth(entry.geometry().mbr(), depth + 2));\n            }\n        } else {\n            final NonLeaf<T, S> n = (NonLeaf<T, S>) node;\n            for (int i = 0; i < n.count(); i++) {\n                list.addAll(getRectangleDepths(n.child(i), depth + 1));\n            }\n        }\n        return list;\n    }\n\n    private void drawNode(Graphics2D g, List<RectangleDepth> nodes) {\n        for (final RectangleDepth node : nodes) {\n            final Color color = Color.getHSBColor(node.getDepth() / (maxDepth + 1f), 1f, 1f);\n            g.setStroke(new BasicStroke(Math.max(0.5f, maxDepth - node.getDepth() + 1 - 1)));\n            g.setColor(color);\n            final Rectangle r = node.getRectangle();\n            drawRectangle(g, r);\n        }\n    }\n\n    private void drawRectangle(Graphics2D g, Rectangle r) {\n        final double x1 = (r.x1() - view.x1()) / (view.x2() - view.x1()) * width;\n        final double y1 = (r.y1() - view.y1()) / (view.y2() - view.y1()) * height;\n        final double x2 = (r.x2() - view.x1()) / (view.x2() - view.x1()) * width;\n        final double y2 = (r.y2() - view.y1()) / (view.y2() - view.y1()) * height;\n        g.drawRect(rnd(x1), rnd(y1), Math.max(rnd(x2 - x1), 1), Math.max(rnd(y2 - y1), 1));\n    }\n\n    private static int rnd(double d) {\n        return (int) Math.round(d);\n    }\n\n    public void save(File file, String imageFormat) {\n        ImageSaver.save(createImage(), file, imageFormat);\n    }\n\n    public void save(String filename, String imageFormat) {\n        save(new File(filename), imageFormat);\n    }\n\n    public void save(String filename) {\n        save(new File(filename), \"PNG\");\n    }\n}", "definition": "public final class Visualizer", "class_docstring": "", "name": "Visualizer", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "fields": [{"attribute_expression": "private final RTree<?, Geometry> tree;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "RTree<?, Geometry>", "name": "tree", "syntax_pass": true}, {"attribute_expression": "private final int width;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "int", "name": "width", "syntax_pass": true}, {"attribute_expression": "private final int height;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "int", "name": "height", "syntax_pass": true}, {"attribute_expression": "private final Rectangle view;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Rectangle", "name": "view", "syntax_pass": true}, {"attribute_expression": "private final int maxDepth;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "int", "name": "maxDepth", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    Visualizer(RTree<?, Geometry> tree, int width, int height, Rectangle view) {\n        this.tree = tree;\n        this.width = width;\n        this.height = height;\n        this.view = view;\n        this.maxDepth = calculateMaxDepth(tree.root());\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "Visualizer", "params": [{"name": "tree", "type": "RTree<?, Geometry>"}, {"name": "width", "type": "int"}, {"name": "height", "type": "int"}, {"name": "view", "type": "Rectangle"}], "body": "                                                                               {\n        this.tree = tree;\n        this.width = width;\n        this.height = height;\n        this.view = view;\n        this.maxDepth = calculateMaxDepth(tree.root());\n    }", "signature": "Visualizer(RTree<?, Geometry> tree, int width, int height, Rectangle view)"}, {"syntax_pass": true, "original_string": "    private static <R, S extends Geometry> int calculateMaxDepth(\n            Optional<? extends Node<R, S>> root) {\n        if (!root.isPresent()) {\n            return 0;\n        } else {\n            return calculateDepth(root.get(), 0);\n        }\n    }", "docstring": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "int", "classes": []}, "name": "calculateMaxDepth", "params": [{"name": "root", "type": "Optional<? extends Node<R, S>>"}], "body": "                                                 {\n        if (!root.isPresent()) {\n            return 0;\n        } else {\n            return calculateDepth(root.get(), 0);\n        }\n    }", "signature": "private static <R, S extends Geometry> int calculateMaxDepth(\n            Optional<? extends Node<R, S>> root)"}, {"syntax_pass": true, "original_string": "    private static <R, S extends Geometry> int calculateDepth(Node<R, S> node, int depth) {\n        if (node instanceof Leaf) {\n            return depth + 1;\n        } else {\n            return calculateDepth(((NonLeaf<R, S>) node).child(0), depth + 1);\n        }\n    }", "docstring": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "int", "classes": []}, "name": "calculateDepth", "params": [{"name": "node", "type": "Node<R, S>"}, {"name": "depth", "type": "int"}], "body": "                                                                                          {\n        if (node instanceof Leaf) {\n            return depth + 1;\n        } else {\n            return calculateDepth(((NonLeaf<R, S>) node).child(0), depth + 1);\n        }\n    }", "signature": "private static <R, S extends Geometry> int calculateDepth(Node<R, S> node, int depth)"}, {"syntax_pass": true, "original_string": "    public BufferedImage createImage() {\n        final BufferedImage image = new BufferedImage(width, height, BufferedImage.TYPE_INT_ARGB);\n        final Graphics2D g = (Graphics2D) image.getGraphics();\n        g.setBackground(Color.white);\n        g.clearRect(0, 0, width, height);\n        g.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, 0.75f));\n\n        if (tree.root().isPresent()) {\n            final List<RectangleDepth> nodeDepths = getNodeDepthsSortedByDepth(tree.root().get());\n            drawNode(g, nodeDepths);\n        }\n        return image;\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "BufferedImage", "classes": []}, "name": "createImage", "params": [], "body": "                                       {\n        final BufferedImage image = new BufferedImage(width, height, BufferedImage.TYPE_INT_ARGB);\n        final Graphics2D g = (Graphics2D) image.getGraphics();\n        g.setBackground(Color.white);\n        g.clearRect(0, 0, width, height);\n        g.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, 0.75f));\n\n        if (tree.root().isPresent()) {\n            final List<RectangleDepth> nodeDepths = getNodeDepthsSortedByDepth(tree.root().get());\n            drawNode(g, nodeDepths);\n        }\n        return image;\n    }", "signature": "public BufferedImage createImage()"}, {"syntax_pass": true, "original_string": "    private <T, S extends Geometry> List<RectangleDepth> getNodeDepthsSortedByDepth(\n            Node<T, S> root) {\n        final List<RectangleDepth> list = getRectangleDepths(root, 0);\n        list.sort(Comparator.comparing(RectangleDepth::getDepth));\n        return list;\n    }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "List<RectangleDepth>", "classes": []}, "name": "getNodeDepthsSortedByDepth", "params": [{"name": "root", "type": "Node<T, S>"}], "body": "                             {\n        final List<RectangleDepth> list = getRectangleDepths(root, 0);\n        list.sort(Comparator.comparing(RectangleDepth::getDepth));\n        return list;\n    }", "signature": "private <T, S extends Geometry> List<RectangleDepth> getNodeDepthsSortedByDepth(\n            Node<T, S> root)"}, {"syntax_pass": true, "original_string": "    private <T, S extends Geometry> List<RectangleDepth> getRectangleDepths(Node<T, S> node,\n            int depth) {\n        final List<RectangleDepth> list = new ArrayList<RectangleDepth>();\n        list.add(new RectangleDepth(node.geometry().mbr(), depth));\n        if (node instanceof Leaf) {\n            final Leaf<T, S> leaf = (Leaf<T, S>) node;\n            for (final Entry<T, S> entry : leaf.entries()) {\n                list.add(new RectangleDepth(entry.geometry().mbr(), depth + 2));\n            }\n        } else {\n            final NonLeaf<T, S> n = (NonLeaf<T, S>) node;\n            for (int i = 0; i < n.count(); i++) {\n                list.addAll(getRectangleDepths(n.child(i), depth + 1));\n            }\n        }\n        return list;\n    }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "List<RectangleDepth>", "classes": []}, "name": "getRectangleDepths", "params": [{"name": "node", "type": "Node<T, S>"}, {"name": "depth", "type": "int"}], "body": "                       {\n        final List<RectangleDepth> list = new ArrayList<RectangleDepth>();\n        list.add(new RectangleDepth(node.geometry().mbr(), depth));\n        if (node instanceof Leaf) {\n            final Leaf<T, S> leaf = (Leaf<T, S>) node;\n            for (final Entry<T, S> entry : leaf.entries()) {\n                list.add(new RectangleDepth(entry.geometry().mbr(), depth + 2));\n            }\n        } else {\n            final NonLeaf<T, S> n = (NonLeaf<T, S>) node;\n            for (int i = 0; i < n.count(); i++) {\n                list.addAll(getRectangleDepths(n.child(i), depth + 1));\n            }\n        }\n        return list;\n    }", "signature": "private <T, S extends Geometry> List<RectangleDepth> getRectangleDepths(Node<T, S> node,\n            int depth)"}, {"syntax_pass": true, "original_string": "    private void drawNode(Graphics2D g, List<RectangleDepth> nodes) {\n        for (final RectangleDepth node : nodes) {\n            final Color color = Color.getHSBColor(node.getDepth() / (maxDepth + 1f), 1f, 1f);\n            g.setStroke(new BasicStroke(Math.max(0.5f, maxDepth - node.getDepth() + 1 - 1)));\n            g.setColor(color);\n            final Rectangle r = node.getRectangle();\n            drawRectangle(g, r);\n        }\n    }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "name": "drawNode", "params": [{"name": "g", "type": "Graphics2D"}, {"name": "nodes", "type": "List<RectangleDepth>"}], "body": "                                                                    {\n        for (final RectangleDepth node : nodes) {\n            final Color color = Color.getHSBColor(node.getDepth() / (maxDepth + 1f), 1f, 1f);\n            g.setStroke(new BasicStroke(Math.max(0.5f, maxDepth - node.getDepth() + 1 - 1)));\n            g.setColor(color);\n            final Rectangle r = node.getRectangle();\n            drawRectangle(g, r);\n        }\n    }", "signature": "private void drawNode(Graphics2D g, List<RectangleDepth> nodes)"}, {"syntax_pass": true, "original_string": "    private void drawRectangle(Graphics2D g, Rectangle r) {\n        final double x1 = (r.x1() - view.x1()) / (view.x2() - view.x1()) * width;\n        final double y1 = (r.y1() - view.y1()) / (view.y2() - view.y1()) * height;\n        final double x2 = (r.x2() - view.x1()) / (view.x2() - view.x1()) * width;\n        final double y2 = (r.y2() - view.y1()) / (view.y2() - view.y1()) * height;\n        g.drawRect(rnd(x1), rnd(y1), Math.max(rnd(x2 - x1), 1), Math.max(rnd(y2 - y1), 1));\n    }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "name": "drawRectangle", "params": [{"name": "g", "type": "Graphics2D"}, {"name": "r", "type": "Rectangle"}], "body": "                                                          {\n        final double x1 = (r.x1() - view.x1()) / (view.x2() - view.x1()) * width;\n        final double y1 = (r.y1() - view.y1()) / (view.y2() - view.y1()) * height;\n        final double x2 = (r.x2() - view.x1()) / (view.x2() - view.x1()) * width;\n        final double y2 = (r.y2() - view.y1()) / (view.y2() - view.y1()) * height;\n        g.drawRect(rnd(x1), rnd(y1), Math.max(rnd(x2 - x1), 1), Math.max(rnd(y2 - y1), 1));\n    }", "signature": "private void drawRectangle(Graphics2D g, Rectangle r)"}, {"syntax_pass": true, "original_string": "    private static int rnd(double d) {\n        return (int) Math.round(d);\n    }", "docstring": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "int", "classes": []}, "name": "rnd", "params": [{"name": "d", "type": "double"}], "body": "                                     {\n        return (int) Math.round(d);\n    }", "signature": "private static int rnd(double d)"}, {"syntax_pass": true, "original_string": "    public void save(File file, String imageFormat) {\n        ImageSaver.save(createImage(), file, imageFormat);\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "save", "params": [{"name": "file", "type": "File"}, {"name": "imageFormat", "type": "String"}], "body": "                                                    {\n        ImageSaver.save(createImage(), file, imageFormat);\n    }", "signature": "public void save(File file, String imageFormat)"}, {"syntax_pass": true, "original_string": "    public void save(String filename, String imageFormat) {\n        save(new File(filename), imageFormat);\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "save", "params": [{"name": "filename", "type": "String"}, {"name": "imageFormat", "type": "String"}], "body": "                                                          {\n        save(new File(filename), imageFormat);\n    }", "signature": "public void save(String filename, String imageFormat)"}, {"syntax_pass": true, "original_string": "    public void save(String filename) {\n        save(new File(filename), \"PNG\");\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "save", "params": [{"name": "filename", "type": "String"}], "body": "                                      {\n        save(new File(filename), \"PNG\");\n    }", "signature": "public void save(String filename)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/com/github/davidmoten/rtree/Serializers.java", "original_string": "package com.github.davidmoten.rtree;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.Serializable;\nimport java.nio.charset.Charset;\n\nimport com.esotericsoftware.kryo.Kryo;\nimport com.github.davidmoten.guavamini.Preconditions;\nimport com.github.davidmoten.rtree.fbs.SerializerFlatBuffers;\nimport com.github.davidmoten.rtree.geometry.Geometry;\nimport com.github.davidmoten.rtree.internal.Functions;\nimport com.github.davidmoten.rtree.kryo.SerializerKryo;\n\nimport rx.functions.Func0;\nimport rx.functions.Func1;\n\npublic final class Serializers {\n\n    private Serializers() {\n        // prevent instantiation\n    }\n\n    public static class SerializerBuilder {\n\n        private Method method = Method.FLATBUFFERS;\n\n        private SerializerBuilder() {\n\n        }\n\n        public <T> SerializerTypedBuilder<T> serializer(Func1<? super T, byte[]> serializer) {\n            return new SerializerTypedBuilder<T>(serializer, null, method);\n        }\n\n        public <T> SerializerTypedBuilder<T> deserializer(Func1<byte[], ? extends T> deserializer) {\n            return new SerializerTypedBuilder<T>(null, deserializer, method);\n        }\n\n        public <S extends Geometry> Serializer<String, S> string(Charset charset) {\n            Func1<String, byte[]> serializer = createStringSerializer(charset);\n            Func1<byte[], String> deserializer = createStringDeserializer(charset);\n            return new SerializerTypedBuilder<String>(serializer, deserializer, method).create();\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        public <T extends Serializable, S extends Geometry> Serializer<T, S> javaIo() {\n            Func1<T, byte[]> serializer = (Func1<T, byte[]>) javaIoSerializer();\n            Func1<byte[], T> deserializer = (Func1<byte[], T>) javaIoDeserializer();\n            return new SerializerTypedBuilder<T>(serializer, deserializer, method).create();\n        }\n\n        public <S extends Geometry> Serializer<String, S> utf8() {\n            return string(Charset.forName(\"UTF-8\"));\n        }\n\n        public <S extends Geometry> Serializer<byte[], S> bytes() {\n            Func1<byte[], byte[]> serializer = Functions.identity();\n            Func1<byte[], byte[]> deserializer = Functions.identity();\n            return new SerializerTypedBuilder<byte[]>(serializer, deserializer, method).create();\n        }\n\n        public SerializerBuilder method(Method method) {\n            this.method = method;\n            return this;\n        }\n\n    }\n\n    public static final class SerializerTypedBuilder<T> {\n\n        private Func1<? super T, byte[]> serializer;\n        private Func1<byte[], ? extends T> deserializer;\n        private Method method;\n        private Func0<Kryo> kryoFactory = new Func0<Kryo>() {\n            @Override\n            public Kryo call() {\n                return new Kryo();\n            }\n        };\n\n        private SerializerTypedBuilder(Func1<? super T, byte[]> serializer,\n                Func1<byte[], ? extends T> deserializer, Method method) {\n            this.serializer = serializer;\n            this.deserializer = deserializer;\n            this.method = method;\n        }\n\n        public SerializerTypedBuilder<T> serializer(Func1<? super T, byte[]> serializer) {\n            this.serializer = serializer;\n            return this;\n        }\n\n        public SerializerTypedBuilder<T> deserializer(Func1<byte[], ? extends T> deserializer) {\n            this.deserializer = deserializer;\n            return this;\n        }\n\n        public SerializerTypedBuilder<T> method(Method method) {\n            // TODO remove this check when kryo ready\n            Preconditions.checkArgument(method != Method.KRYO,\n                    \"kryo serialization not implemented yet\");\n            this.method = method;\n            return this;\n        }\n\n        // TODO enable when ready\n        @SuppressWarnings(\"unused\")\n        private SerializerTypedBuilder<T> kryo(Func0<Kryo> kryoFactory) {\n            this.method = Method.KRYO;\n            this.kryoFactory = kryoFactory;\n            return this;\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        public <S extends Geometry> Serializer<T, S> create() {\n            if (method == Method.FLATBUFFERS) {\n                if (serializer == null) {\n                    serializer = (Func1<T, byte[]>) javaIoSerializer();\n                }\n                if (deserializer == null) {\n                    deserializer = (Func1<byte[], T>) javaIoDeserializer();\n                }\n                return SerializerFlatBuffers.create(serializer, deserializer);\n            } else {\n                return SerializerKryo.create(serializer, deserializer, kryoFactory);\n            }\n        }\n\n    }\n\n    public static <T, S extends Geometry> SerializerBuilder flatBuffers() {\n        return new SerializerBuilder().method(Method.FLATBUFFERS);\n    }\n\n    public enum Method {\n        FLATBUFFERS, KRYO;\n    }\n\n    private static Func1<String, byte[]> createStringSerializer(final Charset charset) {\n        return new Func1<String, byte[]>() {\n            @Override\n            public byte[] call(String s) {\n                return s.getBytes(charset);\n            }\n        };\n    }\n\n    private static <T> Func1<byte[], String> createStringDeserializer(final Charset charset) {\n        return new Func1<byte[], String>() {\n            @Override\n            public String call(byte[] bytes) {\n                return new String(bytes, charset);\n            }\n        };\n    }\n\n    private static Func1<Serializable, byte[]> javaIoSerializer() {\n        return new Func1<Serializable, byte[]>() {\n            @Override\n            public byte[] call(Serializable o) {\n                ByteArrayOutputStream bytes = new ByteArrayOutputStream();\n                ObjectOutputStream oos = null;\n                try {\n                    oos = new ObjectOutputStream(bytes);\n                    oos.writeObject(o);\n                    oos.close();\n                    return bytes.toByteArray();\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                } finally {\n                    try {\n                        if (oos != null)\n                            oos.close();\n                    } catch (IOException e) {\n                        // ignore\n                    }\n                }\n            }\n        };\n    }\n\n    private static Func1<byte[], Serializable> javaIoDeserializer() {\n        return new Func1<byte[], Serializable>() {\n            @Override\n            public Serializable call(byte[] bytes) {\n                ByteArrayInputStream is = new ByteArrayInputStream(bytes);\n                ObjectInputStream ois = null;\n                try {\n                    ois = new ObjectInputStream(is);\n                    return (Serializable) ois.readObject();\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                } catch (ClassNotFoundException e) {\n                    throw new RuntimeException(e);\n                } finally {\n                    if (ois != null)\n                        try {\n                            ois.close();\n                        } catch (IOException e) {\n                            // ignore\n                        }\n                }\n            }\n        };\n    }\n\n}\n", "file_hash": "72df8fe0acddf07627576324879bac8cb759d01f997ad7d88dd235cec6d0a937", "file_docstring": "", "contexts": ["package com.github.davidmoten.rtree;", "import java.io.ByteArrayInputStream;", "import java.io.ByteArrayOutputStream;", "import java.io.IOException;", "import java.io.ObjectInputStream;", "import java.io.ObjectOutputStream;", "import java.io.Serializable;", "import java.nio.charset.Charset;", "import com.esotericsoftware.kryo.Kryo;", "import com.github.davidmoten.guavamini.Preconditions;", "import com.github.davidmoten.rtree.fbs.SerializerFlatBuffers;", "import com.github.davidmoten.rtree.geometry.Geometry;", "import com.github.davidmoten.rtree.internal.Functions;", "import com.github.davidmoten.rtree.kryo.SerializerKryo;", "import rx.functions.Func0;", "import rx.functions.Func1;"], "methods": [], "classes": [{"original_string": "public final class Serializers {\n\n    private Serializers() {\n        // prevent instantiation\n    }\n\n    public static class SerializerBuilder {\n\n        private Method method = Method.FLATBUFFERS;\n\n        private SerializerBuilder() {\n\n        }\n\n        public <T> SerializerTypedBuilder<T> serializer(Func1<? super T, byte[]> serializer) {\n            return new SerializerTypedBuilder<T>(serializer, null, method);\n        }\n\n        public <T> SerializerTypedBuilder<T> deserializer(Func1<byte[], ? extends T> deserializer) {\n            return new SerializerTypedBuilder<T>(null, deserializer, method);\n        }\n\n        public <S extends Geometry> Serializer<String, S> string(Charset charset) {\n            Func1<String, byte[]> serializer = createStringSerializer(charset);\n            Func1<byte[], String> deserializer = createStringDeserializer(charset);\n            return new SerializerTypedBuilder<String>(serializer, deserializer, method).create();\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        public <T extends Serializable, S extends Geometry> Serializer<T, S> javaIo() {\n            Func1<T, byte[]> serializer = (Func1<T, byte[]>) javaIoSerializer();\n            Func1<byte[], T> deserializer = (Func1<byte[], T>) javaIoDeserializer();\n            return new SerializerTypedBuilder<T>(serializer, deserializer, method).create();\n        }\n\n        public <S extends Geometry> Serializer<String, S> utf8() {\n            return string(Charset.forName(\"UTF-8\"));\n        }\n\n        public <S extends Geometry> Serializer<byte[], S> bytes() {\n            Func1<byte[], byte[]> serializer = Functions.identity();\n            Func1<byte[], byte[]> deserializer = Functions.identity();\n            return new SerializerTypedBuilder<byte[]>(serializer, deserializer, method).create();\n        }\n\n        public SerializerBuilder method(Method method) {\n            this.method = method;\n            return this;\n        }\n\n    }\n\n    public static final class SerializerTypedBuilder<T> {\n\n        private Func1<? super T, byte[]> serializer;\n        private Func1<byte[], ? extends T> deserializer;\n        private Method method;\n        private Func0<Kryo> kryoFactory = new Func0<Kryo>() {\n            @Override\n            public Kryo call() {\n                return new Kryo();\n            }\n        };\n\n        private SerializerTypedBuilder(Func1<? super T, byte[]> serializer,\n                Func1<byte[], ? extends T> deserializer, Method method) {\n            this.serializer = serializer;\n            this.deserializer = deserializer;\n            this.method = method;\n        }\n\n        public SerializerTypedBuilder<T> serializer(Func1<? super T, byte[]> serializer) {\n            this.serializer = serializer;\n            return this;\n        }\n\n        public SerializerTypedBuilder<T> deserializer(Func1<byte[], ? extends T> deserializer) {\n            this.deserializer = deserializer;\n            return this;\n        }\n\n        public SerializerTypedBuilder<T> method(Method method) {\n            // TODO remove this check when kryo ready\n            Preconditions.checkArgument(method != Method.KRYO,\n                    \"kryo serialization not implemented yet\");\n            this.method = method;\n            return this;\n        }\n\n        // TODO enable when ready\n        @SuppressWarnings(\"unused\")\n        private SerializerTypedBuilder<T> kryo(Func0<Kryo> kryoFactory) {\n            this.method = Method.KRYO;\n            this.kryoFactory = kryoFactory;\n            return this;\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        public <S extends Geometry> Serializer<T, S> create() {\n            if (method == Method.FLATBUFFERS) {\n                if (serializer == null) {\n                    serializer = (Func1<T, byte[]>) javaIoSerializer();\n                }\n                if (deserializer == null) {\n                    deserializer = (Func1<byte[], T>) javaIoDeserializer();\n                }\n                return SerializerFlatBuffers.create(serializer, deserializer);\n            } else {\n                return SerializerKryo.create(serializer, deserializer, kryoFactory);\n            }\n        }\n\n    }\n\n    public static <T, S extends Geometry> SerializerBuilder flatBuffers() {\n        return new SerializerBuilder().method(Method.FLATBUFFERS);\n    }\n\n    public enum Method {\n        FLATBUFFERS, KRYO;\n    }\n\n    private static Func1<String, byte[]> createStringSerializer(final Charset charset) {\n        return new Func1<String, byte[]>() {\n            @Override\n            public byte[] call(String s) {\n                return s.getBytes(charset);\n            }\n        };\n    }\n\n    private static <T> Func1<byte[], String> createStringDeserializer(final Charset charset) {\n        return new Func1<byte[], String>() {\n            @Override\n            public String call(byte[] bytes) {\n                return new String(bytes, charset);\n            }\n        };\n    }\n\n    private static Func1<Serializable, byte[]> javaIoSerializer() {\n        return new Func1<Serializable, byte[]>() {\n            @Override\n            public byte[] call(Serializable o) {\n                ByteArrayOutputStream bytes = new ByteArrayOutputStream();\n                ObjectOutputStream oos = null;\n                try {\n                    oos = new ObjectOutputStream(bytes);\n                    oos.writeObject(o);\n                    oos.close();\n                    return bytes.toByteArray();\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                } finally {\n                    try {\n                        if (oos != null)\n                            oos.close();\n                    } catch (IOException e) {\n                        // ignore\n                    }\n                }\n            }\n        };\n    }\n\n    private static Func1<byte[], Serializable> javaIoDeserializer() {\n        return new Func1<byte[], Serializable>() {\n            @Override\n            public Serializable call(byte[] bytes) {\n                ByteArrayInputStream is = new ByteArrayInputStream(bytes);\n                ObjectInputStream ois = null;\n                try {\n                    ois = new ObjectInputStream(is);\n                    return (Serializable) ois.readObject();\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                } catch (ClassNotFoundException e) {\n                    throw new RuntimeException(e);\n                } finally {\n                    if (ois != null)\n                        try {\n                            ois.close();\n                        } catch (IOException e) {\n                            // ignore\n                        }\n                }\n            }\n        };\n    }\n\n}", "definition": "public final class Serializers", "class_docstring": "", "name": "Serializers", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "fields": [], "classes": [{"original_string": "    public static class SerializerBuilder {\n\n        private Method method = Method.FLATBUFFERS;\n\n        private SerializerBuilder() {\n\n        }\n\n        public <T> SerializerTypedBuilder<T> serializer(Func1<? super T, byte[]> serializer) {\n            return new SerializerTypedBuilder<T>(serializer, null, method);\n        }\n\n        public <T> SerializerTypedBuilder<T> deserializer(Func1<byte[], ? extends T> deserializer) {\n            return new SerializerTypedBuilder<T>(null, deserializer, method);\n        }\n\n        public <S extends Geometry> Serializer<String, S> string(Charset charset) {\n            Func1<String, byte[]> serializer = createStringSerializer(charset);\n            Func1<byte[], String> deserializer = createStringDeserializer(charset);\n            return new SerializerTypedBuilder<String>(serializer, deserializer, method).create();\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        public <T extends Serializable, S extends Geometry> Serializer<T, S> javaIo() {\n            Func1<T, byte[]> serializer = (Func1<T, byte[]>) javaIoSerializer();\n            Func1<byte[], T> deserializer = (Func1<byte[], T>) javaIoDeserializer();\n            return new SerializerTypedBuilder<T>(serializer, deserializer, method).create();\n        }\n\n        public <S extends Geometry> Serializer<String, S> utf8() {\n            return string(Charset.forName(\"UTF-8\"));\n        }\n\n        public <S extends Geometry> Serializer<byte[], S> bytes() {\n            Func1<byte[], byte[]> serializer = Functions.identity();\n            Func1<byte[], byte[]> deserializer = Functions.identity();\n            return new SerializerTypedBuilder<byte[]>(serializer, deserializer, method).create();\n        }\n\n        public SerializerBuilder method(Method method) {\n            this.method = method;\n            return this;\n        }\n\n    }", "definition": "    public static class SerializerBuilder", "class_docstring": "", "name": "SerializerBuilder", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [{"attribute_expression": "private Method method = Method.FLATBUFFERS;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Method", "name": "method = Method.FLATBUFFERS", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        private SerializerBuilder() {\n\n        }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "", "classes": []}, "name": "SerializerBuilder", "params": [], "body": "                                    {\n\n        }", "signature": "private SerializerBuilder()"}, {"syntax_pass": true, "original_string": "        public <T> SerializerTypedBuilder<T> serializer(Func1<? super T, byte[]> serializer) {\n            return new SerializerTypedBuilder<T>(serializer, null, method);\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "SerializerTypedBuilder<T>", "classes": []}, "name": "serializer", "params": [{"name": "serializer", "type": "Func1<? super T, byte[]>"}], "body": "                                                                                             {\n            return new SerializerTypedBuilder<T>(serializer, null, method);\n        }", "signature": "public <T> SerializerTypedBuilder<T> serializer(Func1<? super T, byte[]> serializer)"}, {"syntax_pass": true, "original_string": "        public <T> SerializerTypedBuilder<T> deserializer(Func1<byte[], ? extends T> deserializer) {\n            return new SerializerTypedBuilder<T>(null, deserializer, method);\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "SerializerTypedBuilder<T>", "classes": []}, "name": "deserializer", "params": [{"name": "deserializer", "type": "Func1<byte[], ? extends T>"}], "body": "                                                                                                   {\n            return new SerializerTypedBuilder<T>(null, deserializer, method);\n        }", "signature": "public <T> SerializerTypedBuilder<T> deserializer(Func1<byte[], ? extends T> deserializer)"}, {"syntax_pass": true, "original_string": "        public <S extends Geometry> Serializer<String, S> string(Charset charset) {\n            Func1<String, byte[]> serializer = createStringSerializer(charset);\n            Func1<byte[], String> deserializer = createStringDeserializer(charset);\n            return new SerializerTypedBuilder<String>(serializer, deserializer, method).create();\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Serializer<String, S>", "classes": []}, "name": "string", "params": [{"name": "charset", "type": "Charset"}], "body": "                                                                                  {\n            Func1<String, byte[]> serializer = createStringSerializer(charset);\n            Func1<byte[], String> deserializer = createStringDeserializer(charset);\n            return new SerializerTypedBuilder<String>(serializer, deserializer, method).create();\n        }", "signature": "public <S extends Geometry> Serializer<String, S> string(Charset charset)"}, {"syntax_pass": true, "original_string": "        @SuppressWarnings(\"unchecked\")\n        public <T extends Serializable, S extends Geometry> Serializer<T, S> javaIo() {\n            Func1<T, byte[]> serializer = (Func1<T, byte[]>) javaIoSerializer();\n            Func1<byte[], T> deserializer = (Func1<byte[], T>) javaIoDeserializer();\n            return new SerializerTypedBuilder<T>(serializer, deserializer, method).create();\n        }", "docstring": "", "attributes": {"modifiers": "@SuppressWarnings(\"unchecked\")\n        public", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings(\"unchecked\")", "public"], "comments": [], "return_type": "Serializer<T, S>", "classes": []}, "name": "javaIo", "params": [], "body": "                                                                                      {\n            Func1<T, byte[]> serializer = (Func1<T, byte[]>) javaIoSerializer();\n            Func1<byte[], T> deserializer = (Func1<byte[], T>) javaIoDeserializer();\n            return new SerializerTypedBuilder<T>(serializer, deserializer, method).create();\n        }", "signature": "@SuppressWarnings(\"unchecked\")\n        public <T extends Serializable, S extends Geometry> Serializer<T, S> javaIo()"}, {"syntax_pass": true, "original_string": "        public <S extends Geometry> Serializer<String, S> utf8() {\n            return string(Charset.forName(\"UTF-8\"));\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Serializer<String, S>", "classes": []}, "name": "utf8", "params": [], "body": "                                                                 {\n            return string(Charset.forName(\"UTF-8\"));\n        }", "signature": "public <S extends Geometry> Serializer<String, S> utf8()"}, {"syntax_pass": true, "original_string": "        public <S extends Geometry> Serializer<byte[], S> bytes() {\n            Func1<byte[], byte[]> serializer = Functions.identity();\n            Func1<byte[], byte[]> deserializer = Functions.identity();\n            return new SerializerTypedBuilder<byte[]>(serializer, deserializer, method).create();\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Serializer<byte[], S>", "classes": []}, "name": "bytes", "params": [], "body": "                                                                  {\n            Func1<byte[], byte[]> serializer = Functions.identity();\n            Func1<byte[], byte[]> deserializer = Functions.identity();\n            return new SerializerTypedBuilder<byte[]>(serializer, deserializer, method).create();\n        }", "signature": "public <S extends Geometry> Serializer<byte[], S> bytes()"}, {"syntax_pass": true, "original_string": "        public SerializerBuilder method(Method method) {\n            this.method = method;\n            return this;\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "SerializerBuilder", "classes": []}, "name": "method", "params": [{"name": "method", "type": "Method"}], "body": "                                                       {\n            this.method = method;\n            return this;\n        }", "signature": "public SerializerBuilder method(Method method)"}]}, {"original_string": "    public static final class SerializerTypedBuilder<T> {\n\n        private Func1<? super T, byte[]> serializer;\n        private Func1<byte[], ? extends T> deserializer;\n        private Method method;\n        private Func0<Kryo> kryoFactory = new Func0<Kryo>() {\n            @Override\n            public Kryo call() {\n                return new Kryo();\n            }\n        };\n\n        private SerializerTypedBuilder(Func1<? super T, byte[]> serializer,\n                Func1<byte[], ? extends T> deserializer, Method method) {\n            this.serializer = serializer;\n            this.deserializer = deserializer;\n            this.method = method;\n        }\n\n        public SerializerTypedBuilder<T> serializer(Func1<? super T, byte[]> serializer) {\n            this.serializer = serializer;\n            return this;\n        }\n\n        public SerializerTypedBuilder<T> deserializer(Func1<byte[], ? extends T> deserializer) {\n            this.deserializer = deserializer;\n            return this;\n        }\n\n        public SerializerTypedBuilder<T> method(Method method) {\n            // TODO remove this check when kryo ready\n            Preconditions.checkArgument(method != Method.KRYO,\n                    \"kryo serialization not implemented yet\");\n            this.method = method;\n            return this;\n        }\n\n        // TODO enable when ready\n        @SuppressWarnings(\"unused\")\n        private SerializerTypedBuilder<T> kryo(Func0<Kryo> kryoFactory) {\n            this.method = Method.KRYO;\n            this.kryoFactory = kryoFactory;\n            return this;\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        public <S extends Geometry> Serializer<T, S> create() {\n            if (method == Method.FLATBUFFERS) {\n                if (serializer == null) {\n                    serializer = (Func1<T, byte[]>) javaIoSerializer();\n                }\n                if (deserializer == null) {\n                    deserializer = (Func1<byte[], T>) javaIoDeserializer();\n                }\n                return SerializerFlatBuffers.create(serializer, deserializer);\n            } else {\n                return SerializerKryo.create(serializer, deserializer, kryoFactory);\n            }\n        }\n\n    }", "definition": "    public static final class SerializerTypedBuilder<T>", "class_docstring": "", "name": "SerializerTypedBuilder", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "fields": [{"attribute_expression": "private Func1<? super T, byte[]> serializer;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Func1<? super T, byte[]>", "name": "serializer", "syntax_pass": true}, {"attribute_expression": "private Func1<byte[], ? extends T> deserializer;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Func1<byte[], ? extends T>", "name": "deserializer", "syntax_pass": true}, {"attribute_expression": "private Method method;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Method", "name": "method", "syntax_pass": true}, {"attribute_expression": "private Func0<Kryo> kryoFactory = new Func0<Kryo>() {\n            @Override\n            public Kryo call() {\n                return new Kryo();\n            }\n        };", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Func0<Kryo>", "name": "kryoFactory = new Func0<Kryo>() {\n            @Override\n            public Kryo call() {\n                return new Kryo();\n            }\n        }", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        private SerializerTypedBuilder(Func1<? super T, byte[]> serializer,\n                Func1<byte[], ? extends T> deserializer, Method method) {\n            this.serializer = serializer;\n            this.deserializer = deserializer;\n            this.method = method;\n        }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "", "classes": []}, "name": "SerializerTypedBuilder", "params": [{"name": "serializer", "type": "Func1<? super T, byte[]>"}, {"name": "deserializer", "type": "Func1<byte[], ? extends T>"}, {"name": "method", "type": "Method"}], "body": "                                                                        {\n            this.serializer = serializer;\n            this.deserializer = deserializer;\n            this.method = method;\n        }", "signature": "private SerializerTypedBuilder(Func1<? super T, byte[]> serializer,\n                Func1<byte[], ? extends T> deserializer, Method method)"}, {"syntax_pass": true, "original_string": "        public SerializerTypedBuilder<T> serializer(Func1<? super T, byte[]> serializer) {\n            this.serializer = serializer;\n            return this;\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "SerializerTypedBuilder<T>", "classes": []}, "name": "serializer", "params": [{"name": "serializer", "type": "Func1<? super T, byte[]>"}], "body": "                                                                                         {\n            this.serializer = serializer;\n            return this;\n        }", "signature": "public SerializerTypedBuilder<T> serializer(Func1<? super T, byte[]> serializer)"}, {"syntax_pass": true, "original_string": "        public SerializerTypedBuilder<T> deserializer(Func1<byte[], ? extends T> deserializer) {\n            this.deserializer = deserializer;\n            return this;\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "SerializerTypedBuilder<T>", "classes": []}, "name": "deserializer", "params": [{"name": "deserializer", "type": "Func1<byte[], ? extends T>"}], "body": "                                                                                               {\n            this.deserializer = deserializer;\n            return this;\n        }", "signature": "public SerializerTypedBuilder<T> deserializer(Func1<byte[], ? extends T> deserializer)"}, {"syntax_pass": true, "original_string": "        public SerializerTypedBuilder<T> method(Method method) {\n            // TODO remove this check when kryo ready\n            Preconditions.checkArgument(method != Method.KRYO,\n                    \"kryo serialization not implemented yet\");\n            this.method = method;\n            return this;\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "SerializerTypedBuilder<T>", "classes": []}, "name": "method", "params": [{"name": "method", "type": "Method"}], "body": "                                                               {\n            // TODO remove this check when kryo ready\n            Preconditions.checkArgument(method != Method.KRYO,\n                    \"kryo serialization not implemented yet\");\n            this.method = method;\n            return this;\n        }", "signature": "public SerializerTypedBuilder<T> method(Method method)"}, {"syntax_pass": true, "original_string": "        @SuppressWarnings(\"unused\")\n        private SerializerTypedBuilder<T> kryo(Func0<Kryo> kryoFactory) {\n            this.method = Method.KRYO;\n            this.kryoFactory = kryoFactory;\n            return this;\n        }", "docstring": " TODO enable when ready", "attributes": {"modifiers": "@SuppressWarnings(\"unused\")\n        private", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings(\"unused\")", "private"], "comments": [], "return_type": "SerializerTypedBuilder<T>", "classes": []}, "name": "kryo", "params": [{"name": "kryoFactory", "type": "Func0<Kryo>"}], "body": "                                                                        {\n            this.method = Method.KRYO;\n            this.kryoFactory = kryoFactory;\n            return this;\n        }", "signature": "@SuppressWarnings(\"unused\")\n        private SerializerTypedBuilder<T> kryo(Func0<Kryo> kryoFactory)"}, {"syntax_pass": true, "original_string": "        @SuppressWarnings(\"unchecked\")\n        public <S extends Geometry> Serializer<T, S> create() {\n            if (method == Method.FLATBUFFERS) {\n                if (serializer == null) {\n                    serializer = (Func1<T, byte[]>) javaIoSerializer();\n                }\n                if (deserializer == null) {\n                    deserializer = (Func1<byte[], T>) javaIoDeserializer();\n                }\n                return SerializerFlatBuffers.create(serializer, deserializer);\n            } else {\n                return SerializerKryo.create(serializer, deserializer, kryoFactory);\n            }\n        }", "docstring": "", "attributes": {"modifiers": "@SuppressWarnings(\"unchecked\")\n        public", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings(\"unchecked\")", "public"], "comments": [], "return_type": "Serializer<T, S>", "classes": []}, "name": "create", "params": [], "body": "                                                              {\n            if (method == Method.FLATBUFFERS) {\n                if (serializer == null) {\n                    serializer = (Func1<T, byte[]>) javaIoSerializer();\n                }\n                if (deserializer == null) {\n                    deserializer = (Func1<byte[], T>) javaIoDeserializer();\n                }\n                return SerializerFlatBuffers.create(serializer, deserializer);\n            } else {\n                return SerializerKryo.create(serializer, deserializer, kryoFactory);\n            }\n        }", "signature": "@SuppressWarnings(\"unchecked\")\n        public <S extends Geometry> Serializer<T, S> create()"}]}]}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    private Serializers() {\n        // prevent instantiation\n    }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "", "classes": []}, "name": "Serializers", "params": [], "body": "                          {\n        // prevent instantiation\n    }", "signature": "private Serializers()"}, {"syntax_pass": true, "original_string": "    public static <T, S extends Geometry> SerializerBuilder flatBuffers() {\n        return new SerializerBuilder().method(Method.FLATBUFFERS);\n    }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "SerializerBuilder", "classes": []}, "name": "flatBuffers", "params": [], "body": "                                                                          {\n        return new SerializerBuilder().method(Method.FLATBUFFERS);\n    }", "signature": "public static <T, S extends Geometry> SerializerBuilder flatBuffers()"}, {"syntax_pass": true, "original_string": "    private static Func1<String, byte[]> createStringSerializer(final Charset charset) {\n        return new Func1<String, byte[]>() {\n            @Override\n            public byte[] call(String s) {\n                return s.getBytes(charset);\n            }\n        };\n    }", "docstring": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "Func1<String, byte[]>", "classes": []}, "name": "createStringSerializer", "params": [{"name": "charset", "type": "Charset"}], "body": "                                                                                       {\n        return new Func1<String, byte[]>() {\n            @Override\n            public byte[] call(String s) {\n                return s.getBytes(charset);\n            }\n        };\n    }", "signature": "private static Func1<String, byte[]> createStringSerializer(final Charset charset)"}, {"syntax_pass": true, "original_string": "    private static <T> Func1<byte[], String> createStringDeserializer(final Charset charset) {\n        return new Func1<byte[], String>() {\n            @Override\n            public String call(byte[] bytes) {\n                return new String(bytes, charset);\n            }\n        };\n    }", "docstring": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "Func1<byte[], String>", "classes": []}, "name": "createStringDeserializer", "params": [{"name": "charset", "type": "Charset"}], "body": "                                                                                             {\n        return new Func1<byte[], String>() {\n            @Override\n            public String call(byte[] bytes) {\n                return new String(bytes, charset);\n            }\n        };\n    }", "signature": "private static <T> Func1<byte[], String> createStringDeserializer(final Charset charset)"}, {"syntax_pass": true, "original_string": "    private static Func1<Serializable, byte[]> javaIoSerializer() {\n        return new Func1<Serializable, byte[]>() {\n            @Override\n            public byte[] call(Serializable o) {\n                ByteArrayOutputStream bytes = new ByteArrayOutputStream();\n                ObjectOutputStream oos = null;\n                try {\n                    oos = new ObjectOutputStream(bytes);\n                    oos.writeObject(o);\n                    oos.close();\n                    return bytes.toByteArray();\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                } finally {\n                    try {\n                        if (oos != null)\n                            oos.close();\n                    } catch (IOException e) {\n                        // ignore\n                    }\n                }\n            }\n        };\n    }", "docstring": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "Func1<Serializable, byte[]>", "classes": []}, "name": "javaIoSerializer", "params": [], "body": "                                                                  {\n        return new Func1<Serializable, byte[]>() {\n            @Override\n            public byte[] call(Serializable o) {\n                ByteArrayOutputStream bytes = new ByteArrayOutputStream();\n                ObjectOutputStream oos = null;\n                try {\n                    oos = new ObjectOutputStream(bytes);\n                    oos.writeObject(o);\n                    oos.close();\n                    return bytes.toByteArray();\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                } finally {\n                    try {\n                        if (oos != null)\n                            oos.close();\n                    } catch (IOException e) {\n                        // ignore\n                    }\n                }\n            }\n        };\n    }", "signature": "private static Func1<Serializable, byte[]> javaIoSerializer()"}, {"syntax_pass": true, "original_string": "    private static Func1<byte[], Serializable> javaIoDeserializer() {\n        return new Func1<byte[], Serializable>() {\n            @Override\n            public Serializable call(byte[] bytes) {\n                ByteArrayInputStream is = new ByteArrayInputStream(bytes);\n                ObjectInputStream ois = null;\n                try {\n                    ois = new ObjectInputStream(is);\n                    return (Serializable) ois.readObject();\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                } catch (ClassNotFoundException e) {\n                    throw new RuntimeException(e);\n                } finally {\n                    if (ois != null)\n                        try {\n                            ois.close();\n                        } catch (IOException e) {\n                            // ignore\n                        }\n                }\n            }\n        };\n    }", "docstring": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "Func1<byte[], Serializable>", "classes": []}, "name": "javaIoDeserializer", "params": [], "body": "                                                                    {\n        return new Func1<byte[], Serializable>() {\n            @Override\n            public Serializable call(byte[] bytes) {\n                ByteArrayInputStream is = new ByteArrayInputStream(bytes);\n                ObjectInputStream ois = null;\n                try {\n                    ois = new ObjectInputStream(is);\n                    return (Serializable) ois.readObject();\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                } catch (ClassNotFoundException e) {\n                    throw new RuntimeException(e);\n                } finally {\n                    if (ois != null)\n                        try {\n                            ois.close();\n                        } catch (IOException e) {\n                            // ignore\n                        }\n                }\n            }\n        };\n    }", "signature": "private static Func1<byte[], Serializable> javaIoDeserializer()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/com/github/davidmoten/rtree/SplitterRStar.java", "original_string": "package com.github.davidmoten.rtree;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.List;\n\nimport com.github.davidmoten.guavamini.Preconditions;\nimport com.github.davidmoten.guavamini.annotations.VisibleForTesting;\nimport com.github.davidmoten.rtree.geometry.HasGeometry;\nimport com.github.davidmoten.rtree.geometry.ListPair;\n\npublic final class SplitterRStar implements Splitter {\n\n    private final Comparator<ListPair<?>> comparator;\n\n    public SplitterRStar() {\n        this.comparator = new Comparator<ListPair<?>>() {\n\n            @Override\n            public int compare(ListPair<?> p1, ListPair<?> p2) {\n                // check overlap first then areaSum\n                int value = Double.compare(overlap(p1), overlap(p2));\n                if (value == 0) {\n                    return Double.compare(p1.areaSum(), p2.areaSum());\n                } else {\n                    return value;\n                }\n            }\n        };\n    }\n\n    @Override\n    public <T extends HasGeometry> ListPair<T> split(List<T> items, int minSize) {\n        Preconditions.checkArgument(!items.isEmpty());\n        // sort nodes into increasing x, calculate min overlap where both groups\n        // have more than minChildren\n\n        // compute S the sum of all margin-values of the lists above\n        // the list with the least S is then used to find minimum overlap\n\n        List<ListPair<T>> pairs = null;\n        double lowestMarginSum = Double.POSITIVE_INFINITY;\n        List<T> list = null;\n        for (SortType sortType : SortType.values()) {\n            if (list == null) {\n                list = new ArrayList<T>(items);\n            }\n            Collections.sort(list, comparator(sortType));\n            List<ListPair<T>> p = getPairs(minSize, list);\n            double marginSum = marginValueSum(p);\n            if (marginSum <= lowestMarginSum) {\n                lowestMarginSum = marginSum;\n                pairs = p;\n                // because p uses subViews of list we need to create a new one\n                // for further comparisons\n                list = null;\n            }\n        }\n        return Collections.min(pairs, comparator);\n    }\n\n    private static Comparator<HasGeometry> comparator(SortType sortType) {\n        switch (sortType) {\n        case X_LOWER:\n            return INCREASING_X_LOWER;\n        case X_UPPER:\n            return INCREASING_X_UPPER;\n        case Y_LOWER:\n            return INCREASING_Y_LOWER;\n        case Y_UPPER:\n            return INCREASING_Y_UPPER;\n        default:\n            throw new IllegalArgumentException(\"unknown SortType \" + sortType);\n        }\n    }\n\n    private enum SortType {\n        X_LOWER, X_UPPER, Y_LOWER, Y_UPPER;\n    }\n\n    private static <T extends HasGeometry> double marginValueSum(List<ListPair<T>> list) {\n        double sum = 0;\n        for (ListPair<T> p : list)\n            sum += p.marginSum();\n        return sum;\n    }\n\n    @VisibleForTesting\n    static <T extends HasGeometry> List<ListPair<T>> getPairs(int minSize, List<T> list) {\n        List<ListPair<T>> pairs = new ArrayList<ListPair<T>>(list.size() - 2 * minSize + 1);\n        for (int i = minSize; i < list.size() - minSize + 1; i++) {\n            // Note that subList returns a view of list so creating list1 and\n            // list2 doesn't\n            // necessarily incur array allocation costs.\n            List<T> list1 = list.subList(0, i);\n            List<T> list2 = list.subList(i, list.size());\n            ListPair<T> pair = new ListPair<T>(list1, list2);\n            pairs.add(pair);\n        }\n        return pairs;\n    }\n\n    private static final Comparator<HasGeometry> INCREASING_X_LOWER = new Comparator<HasGeometry>() {\n\n        @Override\n        public int compare(HasGeometry n1, HasGeometry n2) {\n            return Double.compare(n1.geometry().mbr().x1(), n2.geometry().mbr().x1());\n        }\n    };\n\n    private static final Comparator<HasGeometry> INCREASING_X_UPPER = new Comparator<HasGeometry>() {\n\n        @Override\n        public int compare(HasGeometry n1, HasGeometry n2) {\n            return Double.compare(n1.geometry().mbr().x2(), n2.geometry().mbr().x2());\n        }\n    };\n\n    private static final Comparator<HasGeometry> INCREASING_Y_LOWER = new Comparator<HasGeometry>() {\n\n        @Override\n        public int compare(HasGeometry n1, HasGeometry n2) {\n            return Double.compare(n1.geometry().mbr().y1(), n2.geometry().mbr().y1());\n        }\n    };\n\n    private static final Comparator<HasGeometry> INCREASING_Y_UPPER = new Comparator<HasGeometry>() {\n\n        @Override\n        public int compare(HasGeometry n1, HasGeometry n2) {\n            return Double.compare(n1.geometry().mbr().y2(), n2.geometry().mbr().y2());\n        }\n    };\n\n    private static double overlap(ListPair<? extends HasGeometry> pair) {\n        return pair.group1().geometry().mbr().intersectionArea(pair.group2().geometry().mbr());\n    }\n\n}\n", "file_hash": "04e6584adb24e03e2303e203ad94e25957a30ed5087a9d0e880286505b0d889d", "file_docstring": "", "contexts": ["package com.github.davidmoten.rtree;", "import java.util.ArrayList;", "import java.util.Collections;", "import java.util.Comparator;", "import java.util.List;", "import com.github.davidmoten.guavamini.Preconditions;", "import com.github.davidmoten.guavamini.annotations.VisibleForTesting;", "import com.github.davidmoten.rtree.geometry.HasGeometry;", "import com.github.davidmoten.rtree.geometry.ListPair;"], "methods": [], "classes": [{"original_string": "public final class SplitterRStar implements Splitter {\n\n    private final Comparator<ListPair<?>> comparator;\n\n    public SplitterRStar() {\n        this.comparator = new Comparator<ListPair<?>>() {\n\n            @Override\n            public int compare(ListPair<?> p1, ListPair<?> p2) {\n                // check overlap first then areaSum\n                int value = Double.compare(overlap(p1), overlap(p2));\n                if (value == 0) {\n                    return Double.compare(p1.areaSum(), p2.areaSum());\n                } else {\n                    return value;\n                }\n            }\n        };\n    }\n\n    @Override\n    public <T extends HasGeometry> ListPair<T> split(List<T> items, int minSize) {\n        Preconditions.checkArgument(!items.isEmpty());\n        // sort nodes into increasing x, calculate min overlap where both groups\n        // have more than minChildren\n\n        // compute S the sum of all margin-values of the lists above\n        // the list with the least S is then used to find minimum overlap\n\n        List<ListPair<T>> pairs = null;\n        double lowestMarginSum = Double.POSITIVE_INFINITY;\n        List<T> list = null;\n        for (SortType sortType : SortType.values()) {\n            if (list == null) {\n                list = new ArrayList<T>(items);\n            }\n            Collections.sort(list, comparator(sortType));\n            List<ListPair<T>> p = getPairs(minSize, list);\n            double marginSum = marginValueSum(p);\n            if (marginSum <= lowestMarginSum) {\n                lowestMarginSum = marginSum;\n                pairs = p;\n                // because p uses subViews of list we need to create a new one\n                // for further comparisons\n                list = null;\n            }\n        }\n        return Collections.min(pairs, comparator);\n    }\n\n    private static Comparator<HasGeometry> comparator(SortType sortType) {\n        switch (sortType) {\n        case X_LOWER:\n            return INCREASING_X_LOWER;\n        case X_UPPER:\n            return INCREASING_X_UPPER;\n        case Y_LOWER:\n            return INCREASING_Y_LOWER;\n        case Y_UPPER:\n            return INCREASING_Y_UPPER;\n        default:\n            throw new IllegalArgumentException(\"unknown SortType \" + sortType);\n        }\n    }\n\n    private enum SortType {\n        X_LOWER, X_UPPER, Y_LOWER, Y_UPPER;\n    }\n\n    private static <T extends HasGeometry> double marginValueSum(List<ListPair<T>> list) {\n        double sum = 0;\n        for (ListPair<T> p : list)\n            sum += p.marginSum();\n        return sum;\n    }\n\n    @VisibleForTesting\n    static <T extends HasGeometry> List<ListPair<T>> getPairs(int minSize, List<T> list) {\n        List<ListPair<T>> pairs = new ArrayList<ListPair<T>>(list.size() - 2 * minSize + 1);\n        for (int i = minSize; i < list.size() - minSize + 1; i++) {\n            // Note that subList returns a view of list so creating list1 and\n            // list2 doesn't\n            // necessarily incur array allocation costs.\n            List<T> list1 = list.subList(0, i);\n            List<T> list2 = list.subList(i, list.size());\n            ListPair<T> pair = new ListPair<T>(list1, list2);\n            pairs.add(pair);\n        }\n        return pairs;\n    }\n\n    private static final Comparator<HasGeometry> INCREASING_X_LOWER = new Comparator<HasGeometry>() {\n\n        @Override\n        public int compare(HasGeometry n1, HasGeometry n2) {\n            return Double.compare(n1.geometry().mbr().x1(), n2.geometry().mbr().x1());\n        }\n    };\n\n    private static final Comparator<HasGeometry> INCREASING_X_UPPER = new Comparator<HasGeometry>() {\n\n        @Override\n        public int compare(HasGeometry n1, HasGeometry n2) {\n            return Double.compare(n1.geometry().mbr().x2(), n2.geometry().mbr().x2());\n        }\n    };\n\n    private static final Comparator<HasGeometry> INCREASING_Y_LOWER = new Comparator<HasGeometry>() {\n\n        @Override\n        public int compare(HasGeometry n1, HasGeometry n2) {\n            return Double.compare(n1.geometry().mbr().y1(), n2.geometry().mbr().y1());\n        }\n    };\n\n    private static final Comparator<HasGeometry> INCREASING_Y_UPPER = new Comparator<HasGeometry>() {\n\n        @Override\n        public int compare(HasGeometry n1, HasGeometry n2) {\n            return Double.compare(n1.geometry().mbr().y2(), n2.geometry().mbr().y2());\n        }\n    };\n\n    private static double overlap(ListPair<? extends HasGeometry> pair) {\n        return pair.group1().geometry().mbr().intersectionArea(pair.group2().geometry().mbr());\n    }\n\n}", "definition": "public final class SplitterRStar implements Splitter", "class_docstring": "", "name": "SplitterRStar", "super_interfaces": ["Splitter"], "superclasses": "", "attributes": {"modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "fields": [{"attribute_expression": "private final Comparator<ListPair<?>> comparator;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Comparator<ListPair<?>>", "name": "comparator", "syntax_pass": true}, {"attribute_expression": "private static final Comparator<HasGeometry> INCREASING_X_LOWER = new Comparator<HasGeometry>() {\n\n        @Override\n        public int compare(HasGeometry n1, HasGeometry n2) {\n            return Double.compare(n1.geometry().mbr().x1(), n2.geometry().mbr().x1());\n        }\n    };", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Comparator<HasGeometry>", "name": "INCREASING_X_LOWER = new Comparator<HasGeometry>() {\n\n        @Override\n        public int compare(HasGeometry n1, HasGeometry n2) {\n            return Double.compare(n1.geometry().mbr().x1(), n2.geometry().mbr().x1());\n        }\n    }", "syntax_pass": true}, {"attribute_expression": "private static final Comparator<HasGeometry> INCREASING_X_UPPER = new Comparator<HasGeometry>() {\n\n        @Override\n        public int compare(HasGeometry n1, HasGeometry n2) {\n            return Double.compare(n1.geometry().mbr().x2(), n2.geometry().mbr().x2());\n        }\n    };", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Comparator<HasGeometry>", "name": "INCREASING_X_UPPER = new Comparator<HasGeometry>() {\n\n        @Override\n        public int compare(HasGeometry n1, HasGeometry n2) {\n            return Double.compare(n1.geometry().mbr().x2(), n2.geometry().mbr().x2());\n        }\n    }", "syntax_pass": true}, {"attribute_expression": "private static final Comparator<HasGeometry> INCREASING_Y_LOWER = new Comparator<HasGeometry>() {\n\n        @Override\n        public int compare(HasGeometry n1, HasGeometry n2) {\n            return Double.compare(n1.geometry().mbr().y1(), n2.geometry().mbr().y1());\n        }\n    };", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Comparator<HasGeometry>", "name": "INCREASING_Y_LOWER = new Comparator<HasGeometry>() {\n\n        @Override\n        public int compare(HasGeometry n1, HasGeometry n2) {\n            return Double.compare(n1.geometry().mbr().y1(), n2.geometry().mbr().y1());\n        }\n    }", "syntax_pass": true}, {"attribute_expression": "private static final Comparator<HasGeometry> INCREASING_Y_UPPER = new Comparator<HasGeometry>() {\n\n        @Override\n        public int compare(HasGeometry n1, HasGeometry n2) {\n            return Double.compare(n1.geometry().mbr().y2(), n2.geometry().mbr().y2());\n        }\n    };", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Comparator<HasGeometry>", "name": "INCREASING_Y_UPPER = new Comparator<HasGeometry>() {\n\n        @Override\n        public int compare(HasGeometry n1, HasGeometry n2) {\n            return Double.compare(n1.geometry().mbr().y2(), n2.geometry().mbr().y2());\n        }\n    }", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    public SplitterRStar() {\n        this.comparator = new Comparator<ListPair<?>>() {\n\n            @Override\n            public int compare(ListPair<?> p1, ListPair<?> p2) {\n                // check overlap first then areaSum\n                int value = Double.compare(overlap(p1), overlap(p2));\n                if (value == 0) {\n                    return Double.compare(p1.areaSum(), p2.areaSum());\n                } else {\n                    return value;\n                }\n            }\n        };\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "SplitterRStar", "params": [], "body": "                           {\n        this.comparator = new Comparator<ListPair<?>>() {\n\n            @Override\n            public int compare(ListPair<?> p1, ListPair<?> p2) {\n                // check overlap first then areaSum\n                int value = Double.compare(overlap(p1), overlap(p2));\n                if (value == 0) {\n                    return Double.compare(p1.areaSum(), p2.areaSum());\n                } else {\n                    return value;\n                }\n            }\n        };\n    }", "signature": "public SplitterRStar()"}, {"syntax_pass": true, "original_string": "    @Override\n    public <T extends HasGeometry> ListPair<T> split(List<T> items, int minSize) {\n        Preconditions.checkArgument(!items.isEmpty());\n        // sort nodes into increasing x, calculate min overlap where both groups\n        // have more than minChildren\n\n        // compute S the sum of all margin-values of the lists above\n        // the list with the least S is then used to find minimum overlap\n\n        List<ListPair<T>> pairs = null;\n        double lowestMarginSum = Double.POSITIVE_INFINITY;\n        List<T> list = null;\n        for (SortType sortType : SortType.values()) {\n            if (list == null) {\n                list = new ArrayList<T>(items);\n            }\n            Collections.sort(list, comparator(sortType));\n            List<ListPair<T>> p = getPairs(minSize, list);\n            double marginSum = marginValueSum(p);\n            if (marginSum <= lowestMarginSum) {\n                lowestMarginSum = marginSum;\n                pairs = p;\n                // because p uses subViews of list we need to create a new one\n                // for further comparisons\n                list = null;\n            }\n        }\n        return Collections.min(pairs, comparator);\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "ListPair<T>", "classes": []}, "name": "split", "params": [{"name": "items", "type": "List<T>"}, {"name": "minSize", "type": "int"}], "body": "                                                                                 {\n        Preconditions.checkArgument(!items.isEmpty());\n        // sort nodes into increasing x, calculate min overlap where both groups\n        // have more than minChildren\n\n        // compute S the sum of all margin-values of the lists above\n        // the list with the least S is then used to find minimum overlap\n\n        List<ListPair<T>> pairs = null;\n        double lowestMarginSum = Double.POSITIVE_INFINITY;\n        List<T> list = null;\n        for (SortType sortType : SortType.values()) {\n            if (list == null) {\n                list = new ArrayList<T>(items);\n            }\n            Collections.sort(list, comparator(sortType));\n            List<ListPair<T>> p = getPairs(minSize, list);\n            double marginSum = marginValueSum(p);\n            if (marginSum <= lowestMarginSum) {\n                lowestMarginSum = marginSum;\n                pairs = p;\n                // because p uses subViews of list we need to create a new one\n                // for further comparisons\n                list = null;\n            }\n        }\n        return Collections.min(pairs, comparator);\n    }", "signature": "@Override\n    public <T extends HasGeometry> ListPair<T> split(List<T> items, int minSize)"}, {"syntax_pass": true, "original_string": "    private static Comparator<HasGeometry> comparator(SortType sortType) {\n        switch (sortType) {\n        case X_LOWER:\n            return INCREASING_X_LOWER;\n        case X_UPPER:\n            return INCREASING_X_UPPER;\n        case Y_LOWER:\n            return INCREASING_Y_LOWER;\n        case Y_UPPER:\n            return INCREASING_Y_UPPER;\n        default:\n            throw new IllegalArgumentException(\"unknown SortType \" + sortType);\n        }\n    }", "docstring": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "Comparator<HasGeometry>", "classes": []}, "name": "comparator", "params": [{"name": "sortType", "type": "SortType"}], "body": "                                                                         {\n        switch (sortType) {\n        case X_LOWER:\n            return INCREASING_X_LOWER;\n        case X_UPPER:\n            return INCREASING_X_UPPER;\n        case Y_LOWER:\n            return INCREASING_Y_LOWER;\n        case Y_UPPER:\n            return INCREASING_Y_UPPER;\n        default:\n            throw new IllegalArgumentException(\"unknown SortType \" + sortType);\n        }\n    }", "signature": "private static Comparator<HasGeometry> comparator(SortType sortType)"}, {"syntax_pass": true, "original_string": "    private static <T extends HasGeometry> double marginValueSum(List<ListPair<T>> list) {\n        double sum = 0;\n        for (ListPair<T> p : list)\n            sum += p.marginSum();\n        return sum;\n    }", "docstring": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "double", "classes": []}, "name": "marginValueSum", "params": [{"name": "list", "type": "List<ListPair<T>>"}], "body": "                                                                                         {\n        double sum = 0;\n        for (ListPair<T> p : list)\n            sum += p.marginSum();\n        return sum;\n    }", "signature": "private static <T extends HasGeometry> double marginValueSum(List<ListPair<T>> list)"}, {"syntax_pass": true, "original_string": "    @VisibleForTesting\n    static <T extends HasGeometry> List<ListPair<T>> getPairs(int minSize, List<T> list) {\n        List<ListPair<T>> pairs = new ArrayList<ListPair<T>>(list.size() - 2 * minSize + 1);\n        for (int i = minSize; i < list.size() - minSize + 1; i++) {\n            // Note that subList returns a view of list so creating list1 and\n            // list2 doesn't\n            // necessarily incur array allocation costs.\n            List<T> list1 = list.subList(0, i);\n            List<T> list2 = list.subList(i, list.size());\n            ListPair<T> pair = new ListPair<T>(list1, list2);\n            pairs.add(pair);\n        }\n        return pairs;\n    }", "docstring": "", "attributes": {"modifiers": "@VisibleForTesting\n    static", "marker_annotations": ["@VisibleForTesting"], "non_marker_annotations": ["static"], "comments": [], "return_type": "List<ListPair<T>>", "classes": []}, "name": "getPairs", "params": [{"name": "minSize", "type": "int"}, {"name": "list", "type": "List<T>"}], "body": "                                                                                         {\n        List<ListPair<T>> pairs = new ArrayList<ListPair<T>>(list.size() - 2 * minSize + 1);\n        for (int i = minSize; i < list.size() - minSize + 1; i++) {\n            // Note that subList returns a view of list so creating list1 and\n            // list2 doesn't\n            // necessarily incur array allocation costs.\n            List<T> list1 = list.subList(0, i);\n            List<T> list2 = list.subList(i, list.size());\n            ListPair<T> pair = new ListPair<T>(list1, list2);\n            pairs.add(pair);\n        }\n        return pairs;\n    }", "signature": "@VisibleForTesting\n    static <T extends HasGeometry> List<ListPair<T>> getPairs(int minSize, List<T> list)"}, {"syntax_pass": true, "original_string": "    private static double overlap(ListPair<? extends HasGeometry> pair) {\n        return pair.group1().geometry().mbr().intersectionArea(pair.group2().geometry().mbr());\n    }", "docstring": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "double", "classes": []}, "name": "overlap", "params": [{"name": "pair", "type": "ListPair<? extends HasGeometry>"}], "body": "                                                                        {\n        return pair.group1().geometry().mbr().intersectionArea(pair.group2().geometry().mbr());\n    }", "signature": "private static double overlap(ListPair<? extends HasGeometry> pair)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/com/github/davidmoten/rtree/Splitter.java", "original_string": "package com.github.davidmoten.rtree;\n\nimport java.util.List;\n\nimport com.github.davidmoten.rtree.geometry.HasGeometry;\nimport com.github.davidmoten.rtree.geometry.ListPair;\n\npublic interface Splitter {\n\n    /**\n     * Splits a list of items into two lists of at least minSize.\n     * \n     * @param <T>\n     *            geometry type\n     * @param items\n     *            list of items to split\n     * @param minSize\n     *            min size of each list\n     * @return two lists\n     */\n    <T extends HasGeometry> ListPair<T> split(List<T> items, int minSize);\n}\n", "file_hash": "b226ff43b7cfefd66c72f297ec762ef40e83e899696b9e0fa3d4262c70115916", "file_docstring": "", "contexts": ["package com.github.davidmoten.rtree;", "import java.util.List;", "import com.github.davidmoten.rtree.geometry.HasGeometry;", "import com.github.davidmoten.rtree.geometry.ListPair;"], "methods": [], "classes": [], "interfaces": [{"original_string": "public interface Splitter {\n\n    /**\n     * Splits a list of items into two lists of at least minSize.\n     * \n     * @param <T>\n     *            geometry type\n     * @param items\n     *            list of items to split\n     * @param minSize\n     *            min size of each list\n     * @return two lists\n     */\n    <T extends HasGeometry> ListPair<T> split(List<T> items, int minSize);\n}", "definition": "public interface Splitter", "interface_docstring": "", "name": "Splitter", "extends_interfaces": [], "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    <T extends HasGeometry> ListPair<T> split(List<T> items, int minSize);", "docstring": "\nSplits a list of items into two lists of at least minSize.\n\n@param <T>\n           geometry type\n@param items\n           list of items to split\n@param minSize\n           min size of each list\n@return two lists\n", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "ListPair<T>", "classes": []}, "name": "split", "params": [{"name": "items", "type": "List<T>"}, {"name": "minSize", "type": "int"}], "body": "", "signature": "<T extends HasGeometry> ListPair<T> split(List<T> items, int minSize)"}]}], "records": []}, {"relative_path": "src/main/java/com/github/davidmoten/rtree/ImageSaver.java", "original_string": "package com.github.davidmoten.rtree;\n\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.util.concurrent.Callable;\n\nimport javax.imageio.ImageIO;\n\nfinal class ImageSaver {\n\n    private ImageSaver() {\n        // prevent instantiation\n    }\n\n    static void save(final BufferedImage image, final File file, final String imageFormat) {\n        // this is an ugly workaround to achieve 100% coverage (the pesky\n        // IOException catch)\n        // The performance hit of making this allocation should be negligible\n        // compared to the cost of IO\n        Callable<Void> callable = new Callable<Void>() {\n            @Override\n            public Void call() throws Exception {\n                ImageIO.write(image, imageFormat, file);\n                return null;\n            }\n        };\n        run(callable);\n    }\n\n    static void run(Callable<Void> callable) {\n        try {\n            callable.call();\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n}\n", "file_hash": "99adbf836d0fd66edaad06d2338555e4a240b40f12fbfbd87cca6a67103eca51", "file_docstring": "", "contexts": ["package com.github.davidmoten.rtree;", "import java.awt.image.BufferedImage;", "import java.io.File;", "import java.util.concurrent.Callable;", "import javax.imageio.ImageIO;"], "methods": [], "classes": [{"original_string": "final class ImageSaver {\n\n    private ImageSaver() {\n        // prevent instantiation\n    }\n\n    static void save(final BufferedImage image, final File file, final String imageFormat) {\n        // this is an ugly workaround to achieve 100% coverage (the pesky\n        // IOException catch)\n        // The performance hit of making this allocation should be negligible\n        // compared to the cost of IO\n        Callable<Void> callable = new Callable<Void>() {\n            @Override\n            public Void call() throws Exception {\n                ImageIO.write(image, imageFormat, file);\n                return null;\n            }\n        };\n        run(callable);\n    }\n\n    static void run(Callable<Void> callable) {\n        try {\n            callable.call();\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n}", "definition": "final class ImageSaver", "class_docstring": "", "name": "ImageSaver", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    private ImageSaver() {\n        // prevent instantiation\n    }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "", "classes": []}, "name": "ImageSaver", "params": [], "body": "                         {\n        // prevent instantiation\n    }", "signature": "private ImageSaver()"}, {"syntax_pass": true, "original_string": "    static void save(final BufferedImage image, final File file, final String imageFormat) {\n        // this is an ugly workaround to achieve 100% coverage (the pesky\n        // IOException catch)\n        // The performance hit of making this allocation should be negligible\n        // compared to the cost of IO\n        Callable<Void> callable = new Callable<Void>() {\n            @Override\n            public Void call() throws Exception {\n                ImageIO.write(image, imageFormat, file);\n                return null;\n            }\n        };\n        run(callable);\n    }", "docstring": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "void", "classes": []}, "name": "save", "params": [{"name": "image", "type": "BufferedImage"}, {"name": "file", "type": "File"}, {"name": "imageFormat", "type": "String"}], "body": "                                                                                           {\n        // this is an ugly workaround to achieve 100% coverage (the pesky\n        // IOException catch)\n        // The performance hit of making this allocation should be negligible\n        // compared to the cost of IO\n        Callable<Void> callable = new Callable<Void>() {\n            @Override\n            public Void call() throws Exception {\n                ImageIO.write(image, imageFormat, file);\n                return null;\n            }\n        };\n        run(callable);\n    }", "signature": "static void save(final BufferedImage image, final File file, final String imageFormat)"}, {"syntax_pass": true, "original_string": "    static void run(Callable<Void> callable) {\n        try {\n            callable.call();\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }", "docstring": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "void", "classes": []}, "name": "run", "params": [{"name": "callable", "type": "Callable<Void>"}], "body": "                                             {\n        try {\n            callable.call();\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }", "signature": "static void run(Callable<Void> callable)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/com/github/davidmoten/rtree/EntryFactory.java", "original_string": "package com.github.davidmoten.rtree;\n\nimport com.github.davidmoten.rtree.geometry.Geometry;\n\npublic interface EntryFactory<T,S extends Geometry> {\n    Entry<T,S> createEntry(T value, S geometry);\n}\n", "file_hash": "b343893307f2db36aa3a91ae279f2162c48fd439088286435fe2d19881c308e9", "file_docstring": "", "contexts": ["package com.github.davidmoten.rtree;", "import com.github.davidmoten.rtree.geometry.Geometry;"], "methods": [], "classes": [], "interfaces": [{"original_string": "public interface EntryFactory<T,S extends Geometry> {\n    Entry<T,S> createEntry(T value, S geometry);\n}", "definition": "public interface EntryFactory<T,S extends Geometry>", "interface_docstring": "", "name": "EntryFactory", "extends_interfaces": [], "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    Entry<T,S> createEntry(T value, S geometry);", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "Entry<T,S>", "classes": []}, "name": "createEntry", "params": [{"name": "value", "type": "T"}, {"name": "geometry", "type": "S"}], "body": "", "signature": "Entry<T,S> createEntry(T value, S geometry)"}]}], "records": []}, {"relative_path": "src/main/java/com/github/davidmoten/rtree/Factories.java", "original_string": "package com.github.davidmoten.rtree;\n\nimport com.github.davidmoten.rtree.geometry.Geometry;\nimport com.github.davidmoten.rtree.internal.FactoryDefault;\n\npublic final class Factories {\n\n    private Factories() {\n        // prevent instantiation\n    }\n\n    public static <T, S extends Geometry> Factory<T, S> defaultFactory() {\n        return FactoryDefault.instance();\n    }\n}\n", "file_hash": "4c880ecb2f2cce0ea81a1a73aea35bfbb18398f41b42a7998fb503e4eb7bf9ff", "file_docstring": "", "contexts": ["package com.github.davidmoten.rtree;", "import com.github.davidmoten.rtree.geometry.Geometry;", "import com.github.davidmoten.rtree.internal.FactoryDefault;"], "methods": [], "classes": [{"original_string": "public final class Factories {\n\n    private Factories() {\n        // prevent instantiation\n    }\n\n    public static <T, S extends Geometry> Factory<T, S> defaultFactory() {\n        return FactoryDefault.instance();\n    }\n}", "definition": "public final class Factories", "class_docstring": "", "name": "Factories", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    private Factories() {\n        // prevent instantiation\n    }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "", "classes": []}, "name": "Factories", "params": [], "body": "                        {\n        // prevent instantiation\n    }", "signature": "private Factories()"}, {"syntax_pass": true, "original_string": "    public static <T, S extends Geometry> Factory<T, S> defaultFactory() {\n        return FactoryDefault.instance();\n    }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Factory<T, S>", "classes": []}, "name": "defaultFactory", "params": [], "body": "                                                                         {\n        return FactoryDefault.instance();\n    }", "signature": "public static <T, S extends Geometry> Factory<T, S> defaultFactory()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/com/github/davidmoten/rtree/LeafFactory.java", "original_string": "package com.github.davidmoten.rtree;\n\nimport java.util.List;\n\nimport com.github.davidmoten.rtree.geometry.Geometry;\n\npublic interface LeafFactory<T, S extends Geometry> {\n    Leaf<T, S> createLeaf(List<Entry<T, S>> entries, Context<T, S> context);\n}\n", "file_hash": "44c9bf0393510b9268bc652d5cb9bee2592db2427e9f43d1ecbb039a28b7efdd", "file_docstring": "", "contexts": ["package com.github.davidmoten.rtree;", "import java.util.List;", "import com.github.davidmoten.rtree.geometry.Geometry;"], "methods": [], "classes": [], "interfaces": [{"original_string": "public interface LeafFactory<T, S extends Geometry> {\n    Leaf<T, S> createLeaf(List<Entry<T, S>> entries, Context<T, S> context);\n}", "definition": "public interface LeafFactory<T, S extends Geometry>", "interface_docstring": "", "name": "LeafFactory", "extends_interfaces": [], "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    Leaf<T, S> createLeaf(List<Entry<T, S>> entries, Context<T, S> context);", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "Leaf<T, S>", "classes": []}, "name": "createLeaf", "params": [{"name": "entries", "type": "List<Entry<T, S>>"}, {"name": "context", "type": "Context<T, S>"}], "body": "", "signature": "Leaf<T, S> createLeaf(List<Entry<T, S>> entries, Context<T, S> context)"}]}], "records": []}, {"relative_path": "src/main/java/com/github/davidmoten/rtree/Leaf.java", "original_string": "package com.github.davidmoten.rtree;\n\nimport java.util.List;\n\nimport com.github.davidmoten.rtree.geometry.Geometry;\n\npublic interface Leaf<T, S extends Geometry> extends Node<T, S> {\n\n    List<Entry<T, S>> entries();\n\n    /**\n     * Returns the ith entry (0-based). This method should be preferred for\n     * performance reasons when only one entry is required (in comparison to\n     * {@code entries().get(i)}).\n     * \n     * @param i\n     *            0-based index\n     * @return ith entry\n     */\n    Entry<T, S> entry(int i);\n\n}", "file_hash": "253fde6f8ba2d5194502dda1320feb78e6592cc613acac9e180cd44e9238ff6c", "file_docstring": "", "contexts": ["package com.github.davidmoten.rtree;", "import java.util.List;", "import com.github.davidmoten.rtree.geometry.Geometry;"], "methods": [], "classes": [], "interfaces": [{"original_string": "public interface Leaf<T, S extends Geometry> extends Node<T, S> {\n\n    List<Entry<T, S>> entries();\n\n    /**\n     * Returns the ith entry (0-based). This method should be preferred for\n     * performance reasons when only one entry is required (in comparison to\n     * {@code entries().get(i)}).\n     * \n     * @param i\n     *            0-based index\n     * @return ith entry\n     */\n    Entry<T, S> entry(int i);\n\n}", "definition": "public interface Leaf<T, S extends Geometry> extends Node<T, S>", "interface_docstring": "", "name": "Leaf", "extends_interfaces": ["Node<T, S>"], "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    List<Entry<T, S>> entries();", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "List<Entry<T, S>>", "classes": []}, "name": "entries", "params": [], "body": "", "signature": "List<Entry<T, S>> entries()"}, {"syntax_pass": true, "original_string": "    Entry<T, S> entry(int i);", "docstring": "\nReturns the ith entry (0-based). This method should be preferred for\nperformance reasons when only one entry is required (in comparison to\n{@code entries().get(i)}).\n\n@param i\n           0-based index\n@return ith entry\n", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "Entry<T, S>", "classes": []}, "name": "entry", "params": [{"name": "i", "type": "int"}], "body": "", "signature": "Entry<T, S> entry(int i)"}]}], "records": []}, {"relative_path": "src/main/java/com/github/davidmoten/rtree/RectangleDepth.java", "original_string": "package com.github.davidmoten.rtree;\n\nimport com.github.davidmoten.rtree.geometry.Rectangle;\n\nfinal class RectangleDepth {\n    private final Rectangle rectangle;\n    private final int depth;\n\n    RectangleDepth(Rectangle rectangle, int depth) {\n        super();\n        this.rectangle = rectangle;\n        this.depth = depth;\n    }\n\n    Rectangle getRectangle() {\n        return rectangle;\n    }\n\n    int getDepth() {\n        return depth;\n    }\n\n}\n", "file_hash": "e3b1cb50911188c033dc6bdb3646d3d39437201079165c50375ba07f0c62a4f3", "file_docstring": "", "contexts": ["package com.github.davidmoten.rtree;", "import com.github.davidmoten.rtree.geometry.Rectangle;"], "methods": [], "classes": [{"original_string": "final class RectangleDepth {\n    private final Rectangle rectangle;\n    private final int depth;\n\n    RectangleDepth(Rectangle rectangle, int depth) {\n        super();\n        this.rectangle = rectangle;\n        this.depth = depth;\n    }\n\n    Rectangle getRectangle() {\n        return rectangle;\n    }\n\n    int getDepth() {\n        return depth;\n    }\n\n}", "definition": "final class RectangleDepth", "class_docstring": "", "name": "RectangleDepth", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "fields": [{"attribute_expression": "private final Rectangle rectangle;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Rectangle", "name": "rectangle", "syntax_pass": true}, {"attribute_expression": "private final int depth;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "int", "name": "depth", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    RectangleDepth(Rectangle rectangle, int depth) {\n        super();\n        this.rectangle = rectangle;\n        this.depth = depth;\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "RectangleDepth", "params": [{"name": "rectangle", "type": "Rectangle"}, {"name": "depth", "type": "int"}], "body": "                                                   {\n        super();\n        this.rectangle = rectangle;\n        this.depth = depth;\n    }", "signature": "RectangleDepth(Rectangle rectangle, int depth)"}, {"syntax_pass": true, "original_string": "    Rectangle getRectangle() {\n        return rectangle;\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "Rectangle", "classes": []}, "name": "getRectangle", "params": [], "body": "                             {\n        return rectangle;\n    }", "signature": "Rectangle getRectangle()"}, {"syntax_pass": true, "original_string": "    int getDepth() {\n        return depth;\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "int", "classes": []}, "name": "getDepth", "params": [], "body": "                   {\n        return depth;\n    }", "signature": "int getDepth()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/com/github/davidmoten/rtree/Context.java", "original_string": "package com.github.davidmoten.rtree;\n\nimport com.github.davidmoten.guavamini.Preconditions;\nimport com.github.davidmoten.rtree.geometry.Geometry;\n\n/**\n * Configures an RTree prior to instantiation of an {@link RTree}.\n * @param <T> value type\n * @param <S> geometry type\n */\npublic final class Context<T, S extends Geometry> {\n\n    private final int maxChildren;\n    private final int minChildren;\n    private final Splitter splitter;\n    private final Selector selector;\n    private final Factory<T, S> factory;\n\n    /**\n     * Constructor.\n     * \n     * @param minChildren\n     *            minimum number of children per node (at least 1)\n     * @param maxChildren\n     *            max number of children per node (minimum is 3)\n     * @param selector\n     *            algorithm to select search path\n     * @param splitter\n     *            algorithm to split the children across two new nodes\n     * @param factory\n     *            node creation factory\n     */\n    public Context(int minChildren, int maxChildren, Selector selector, Splitter splitter,\n            Factory<T, S> factory) {\n        Preconditions.checkNotNull(splitter);\n        Preconditions.checkNotNull(selector);\n        Preconditions.checkArgument(maxChildren > 2);\n        Preconditions.checkArgument(minChildren >= 1);\n        Preconditions.checkArgument(minChildren < maxChildren);\n        Preconditions.checkNotNull(factory);\n        this.selector = selector;\n        this.maxChildren = maxChildren;\n        this.minChildren = minChildren;\n        this.splitter = splitter;\n        this.factory = factory;\n    }\n\n    public int maxChildren() {\n        return maxChildren;\n    }\n\n    public int minChildren() {\n        return minChildren;\n    }\n\n    public Splitter splitter() {\n        return splitter;\n    }\n\n    public Selector selector() {\n        return selector;\n    }\n\n    public Factory<T, S> factory() {\n        return factory;\n    }\n\n}\n", "file_hash": "0305032a3eb01fd3bb2f2333d4ec3f100aeb62ce00130c6640bc3922826ee96d", "file_docstring": "", "contexts": ["package com.github.davidmoten.rtree;", "import com.github.davidmoten.guavamini.Preconditions;", "import com.github.davidmoten.rtree.geometry.Geometry;"], "methods": [], "classes": [{"original_string": "public final class Context<T, S extends Geometry> {\n\n    private final int maxChildren;\n    private final int minChildren;\n    private final Splitter splitter;\n    private final Selector selector;\n    private final Factory<T, S> factory;\n\n    /**\n     * Constructor.\n     * \n     * @param minChildren\n     *            minimum number of children per node (at least 1)\n     * @param maxChildren\n     *            max number of children per node (minimum is 3)\n     * @param selector\n     *            algorithm to select search path\n     * @param splitter\n     *            algorithm to split the children across two new nodes\n     * @param factory\n     *            node creation factory\n     */\n    public Context(int minChildren, int maxChildren, Selector selector, Splitter splitter,\n            Factory<T, S> factory) {\n        Preconditions.checkNotNull(splitter);\n        Preconditions.checkNotNull(selector);\n        Preconditions.checkArgument(maxChildren > 2);\n        Preconditions.checkArgument(minChildren >= 1);\n        Preconditions.checkArgument(minChildren < maxChildren);\n        Preconditions.checkNotNull(factory);\n        this.selector = selector;\n        this.maxChildren = maxChildren;\n        this.minChildren = minChildren;\n        this.splitter = splitter;\n        this.factory = factory;\n    }\n\n    public int maxChildren() {\n        return maxChildren;\n    }\n\n    public int minChildren() {\n        return minChildren;\n    }\n\n    public Splitter splitter() {\n        return splitter;\n    }\n\n    public Selector selector() {\n        return selector;\n    }\n\n    public Factory<T, S> factory() {\n        return factory;\n    }\n\n}", "definition": "public final class Context<T, S extends Geometry>", "class_docstring": "\nConfigures an RTree prior to instantiation of an {@link RTree}.\n@param <T> value type\n@param <S> geometry type\n", "name": "Context", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "fields": [{"attribute_expression": "private final int maxChildren;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "int", "name": "maxChildren", "syntax_pass": true}, {"attribute_expression": "private final int minChildren;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "int", "name": "minChildren", "syntax_pass": true}, {"attribute_expression": "private final Splitter splitter;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Splitter", "name": "splitter", "syntax_pass": true}, {"attribute_expression": "private final Selector selector;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Selector", "name": "selector", "syntax_pass": true}, {"attribute_expression": "private final Factory<T, S> factory;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Factory<T, S>", "name": "factory", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    public Context(int minChildren, int maxChildren, Selector selector, Splitter splitter,\n            Factory<T, S> factory) {\n        Preconditions.checkNotNull(splitter);\n        Preconditions.checkNotNull(selector);\n        Preconditions.checkArgument(maxChildren > 2);\n        Preconditions.checkArgument(minChildren >= 1);\n        Preconditions.checkArgument(minChildren < maxChildren);\n        Preconditions.checkNotNull(factory);\n        this.selector = selector;\n        this.maxChildren = maxChildren;\n        this.minChildren = minChildren;\n        this.splitter = splitter;\n        this.factory = factory;\n    }", "docstring": "\nConstructor.\n\n@param minChildren\n           minimum number of children per node (at least 1)\n@param maxChildren\n           max number of children per node (minimum is 3)\n@param selector\n           algorithm to select search path\n@param splitter\n           algorithm to split the children across two new nodes\n@param factory\n           node creation factory\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "Context", "params": [{"name": "minChildren", "type": "int"}, {"name": "maxChildren", "type": "int"}, {"name": "selector", "type": "Selector"}, {"name": "splitter", "type": "Splitter"}, {"name": "factory", "type": "Factory<T, S>"}], "body": "                                   {\n        Preconditions.checkNotNull(splitter);\n        Preconditions.checkNotNull(selector);\n        Preconditions.checkArgument(maxChildren > 2);\n        Preconditions.checkArgument(minChildren >= 1);\n        Preconditions.checkArgument(minChildren < maxChildren);\n        Preconditions.checkNotNull(factory);\n        this.selector = selector;\n        this.maxChildren = maxChildren;\n        this.minChildren = minChildren;\n        this.splitter = splitter;\n        this.factory = factory;\n    }", "signature": "public Context(int minChildren, int maxChildren, Selector selector, Splitter splitter,\n            Factory<T, S> factory)"}, {"syntax_pass": true, "original_string": "    public int maxChildren() {\n        return maxChildren;\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "maxChildren", "params": [], "body": "                             {\n        return maxChildren;\n    }", "signature": "public int maxChildren()"}, {"syntax_pass": true, "original_string": "    public int minChildren() {\n        return minChildren;\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "minChildren", "params": [], "body": "                             {\n        return minChildren;\n    }", "signature": "public int minChildren()"}, {"syntax_pass": true, "original_string": "    public Splitter splitter() {\n        return splitter;\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Splitter", "classes": []}, "name": "splitter", "params": [], "body": "                               {\n        return splitter;\n    }", "signature": "public Splitter splitter()"}, {"syntax_pass": true, "original_string": "    public Selector selector() {\n        return selector;\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Selector", "classes": []}, "name": "selector", "params": [], "body": "                               {\n        return selector;\n    }", "signature": "public Selector selector()"}, {"syntax_pass": true, "original_string": "    public Factory<T, S> factory() {\n        return factory;\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Factory<T, S>", "classes": []}, "name": "factory", "params": [], "body": "                                   {\n        return factory;\n    }", "signature": "public Factory<T, S> factory()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/com/github/davidmoten/rtree/OnSubscribeSearch.java", "original_string": "package com.github.davidmoten.rtree;\n\nimport java.util.concurrent.atomic.AtomicLong;\n\nimport com.github.davidmoten.guavamini.annotations.VisibleForTesting;\nimport com.github.davidmoten.rtree.geometry.Geometry;\nimport com.github.davidmoten.rtree.internal.util.ImmutableStack;\n\nimport rx.Observable.OnSubscribe;\nimport rx.Producer;\nimport rx.Subscriber;\nimport rx.functions.Func1;\n\nfinal class OnSubscribeSearch<T, S extends Geometry> implements OnSubscribe<Entry<T, S>> {\n\n    private final Node<T, S> node;\n    private final Func1<? super Geometry, Boolean> condition;\n\n    OnSubscribeSearch(Node<T, S> node, Func1<? super Geometry, Boolean> condition) {\n        this.node = node;\n        this.condition = condition;\n    }\n\n    @Override\n    public void call(Subscriber<? super Entry<T, S>> subscriber) {\n        subscriber.setProducer(new SearchProducer<T, S>(node, condition, subscriber));\n    }\n\n    @VisibleForTesting\n    static class SearchProducer<T, S extends Geometry> implements Producer {\n\n        private final Subscriber<? super Entry<T, S>> subscriber;\n        private final Node<T, S> node;\n        private final Func1<? super Geometry, Boolean> condition;\n        private volatile ImmutableStack<NodePosition<T, S>> stack;\n        private final AtomicLong requested = new AtomicLong(0);\n\n        SearchProducer(Node<T, S> node, Func1<? super Geometry, Boolean> condition,\n                Subscriber<? super Entry<T, S>> subscriber) {\n            this.node = node;\n            this.condition = condition;\n            this.subscriber = subscriber;\n            stack = ImmutableStack.create(new NodePosition<T, S>(node, 0));\n        }\n\n        @Override\n        public void request(long n) {\n            try {\n                if (n <= 0 || requested.get() == Long.MAX_VALUE)\n                    // none requested or already started with fast path\n                    return;\n                else if (n == Long.MAX_VALUE && requested.compareAndSet(0, Long.MAX_VALUE)) {\n                    // fast path\n                    requestAll();\n                } else\n                    requestSome(n);\n            } catch (RuntimeException e) {\n                subscriber.onError(e);\n            }\n        }\n\n        private void requestAll() {\n            node.searchWithoutBackpressure(condition, subscriber);\n            if (!subscriber.isUnsubscribed())\n                subscriber.onCompleted();\n        }\n\n        private void requestSome(long n) {\n            // back pressure path\n            // this algorithm copied roughly from\n            // rxjava-core/OnSubscribeFromIterable.java\n\n            // rxjava used AtomicLongFieldUpdater instead of AtomicLong\n            // but benchmarks showed no benefit here so reverted to AtomicLong\n            long previousCount = getAndAddRequest(requested, n);\n            if (previousCount == 0) {\n                // don't touch stack every time during the loop because\n                // is a volatile and every write forces a thread memory\n                // cache flush\n                ImmutableStack<NodePosition<T, S>> st = stack;\n                while (true) {\n                    // minimize atomic reads by assigning to a variable here\n                    long r = requested.get();\n                    st = Backpressure.search(condition, subscriber, st, r);\n                    if (st.isEmpty()) {\n                        // release some state for gc (although empty stack so not very significant)\n                        stack = null;\n                        if (!subscriber.isUnsubscribed()) {\n                            subscriber.onCompleted();\n                        }\n                        return;\n                    } else {\n                        stack = st;\n                        if (requested.addAndGet(-r) == 0)\n                            return;\n                    }\n                }\n\n            }\n        }\n    }\n    \n    /**\n     * Adds {@code n} to {@code requested} and returns the value prior to\n     * addition once the addition is successful (uses CAS semantics). If\n     * overflows then sets {@code requested} field to {@code Long.MAX_VALUE}.\n     * \n     * @param requested\n     *            atomic field updater for a request count\n     * @param n\n     *            the number of requests to add to the requested count\n     * @return requested value just prior to successful addition\n     */\n    private static long getAndAddRequest(AtomicLong requested, long n) {\n        // add n to field but check for overflow\n        while (true) {\n            long current = requested.get();\n            long next = current + n;\n            // check for overflow\n            if (next < 0) {\n                next = Long.MAX_VALUE;\n            }\n            if (requested.compareAndSet(current, next)) {\n                return current;\n            }\n        }\n    }\n\n}\n", "file_hash": "8badc70c6842d63d6a9fa1f01598101800bf7eb39580cc590398bd87c6c1f075", "file_docstring": "", "contexts": ["package com.github.davidmoten.rtree;", "import java.util.concurrent.atomic.AtomicLong;", "import com.github.davidmoten.guavamini.annotations.VisibleForTesting;", "import com.github.davidmoten.rtree.geometry.Geometry;", "import com.github.davidmoten.rtree.internal.util.ImmutableStack;", "import rx.Observable.OnSubscribe;", "import rx.Producer;", "import rx.Subscriber;", "import rx.functions.Func1;"], "methods": [], "classes": [{"original_string": "final class OnSubscribeSearch<T, S extends Geometry> implements OnSubscribe<Entry<T, S>> {\n\n    private final Node<T, S> node;\n    private final Func1<? super Geometry, Boolean> condition;\n\n    OnSubscribeSearch(Node<T, S> node, Func1<? super Geometry, Boolean> condition) {\n        this.node = node;\n        this.condition = condition;\n    }\n\n    @Override\n    public void call(Subscriber<? super Entry<T, S>> subscriber) {\n        subscriber.setProducer(new SearchProducer<T, S>(node, condition, subscriber));\n    }\n\n    @VisibleForTesting\n    static class SearchProducer<T, S extends Geometry> implements Producer {\n\n        private final Subscriber<? super Entry<T, S>> subscriber;\n        private final Node<T, S> node;\n        private final Func1<? super Geometry, Boolean> condition;\n        private volatile ImmutableStack<NodePosition<T, S>> stack;\n        private final AtomicLong requested = new AtomicLong(0);\n\n        SearchProducer(Node<T, S> node, Func1<? super Geometry, Boolean> condition,\n                Subscriber<? super Entry<T, S>> subscriber) {\n            this.node = node;\n            this.condition = condition;\n            this.subscriber = subscriber;\n            stack = ImmutableStack.create(new NodePosition<T, S>(node, 0));\n        }\n\n        @Override\n        public void request(long n) {\n            try {\n                if (n <= 0 || requested.get() == Long.MAX_VALUE)\n                    // none requested or already started with fast path\n                    return;\n                else if (n == Long.MAX_VALUE && requested.compareAndSet(0, Long.MAX_VALUE)) {\n                    // fast path\n                    requestAll();\n                } else\n                    requestSome(n);\n            } catch (RuntimeException e) {\n                subscriber.onError(e);\n            }\n        }\n\n        private void requestAll() {\n            node.searchWithoutBackpressure(condition, subscriber);\n            if (!subscriber.isUnsubscribed())\n                subscriber.onCompleted();\n        }\n\n        private void requestSome(long n) {\n            // back pressure path\n            // this algorithm copied roughly from\n            // rxjava-core/OnSubscribeFromIterable.java\n\n            // rxjava used AtomicLongFieldUpdater instead of AtomicLong\n            // but benchmarks showed no benefit here so reverted to AtomicLong\n            long previousCount = getAndAddRequest(requested, n);\n            if (previousCount == 0) {\n                // don't touch stack every time during the loop because\n                // is a volatile and every write forces a thread memory\n                // cache flush\n                ImmutableStack<NodePosition<T, S>> st = stack;\n                while (true) {\n                    // minimize atomic reads by assigning to a variable here\n                    long r = requested.get();\n                    st = Backpressure.search(condition, subscriber, st, r);\n                    if (st.isEmpty()) {\n                        // release some state for gc (although empty stack so not very significant)\n                        stack = null;\n                        if (!subscriber.isUnsubscribed()) {\n                            subscriber.onCompleted();\n                        }\n                        return;\n                    } else {\n                        stack = st;\n                        if (requested.addAndGet(-r) == 0)\n                            return;\n                    }\n                }\n\n            }\n        }\n    }\n    \n    /**\n     * Adds {@code n} to {@code requested} and returns the value prior to\n     * addition once the addition is successful (uses CAS semantics). If\n     * overflows then sets {@code requested} field to {@code Long.MAX_VALUE}.\n     * \n     * @param requested\n     *            atomic field updater for a request count\n     * @param n\n     *            the number of requests to add to the requested count\n     * @return requested value just prior to successful addition\n     */\n    private static long getAndAddRequest(AtomicLong requested, long n) {\n        // add n to field but check for overflow\n        while (true) {\n            long current = requested.get();\n            long next = current + n;\n            // check for overflow\n            if (next < 0) {\n                next = Long.MAX_VALUE;\n            }\n            if (requested.compareAndSet(current, next)) {\n                return current;\n            }\n        }\n    }\n\n}", "definition": "final class OnSubscribeSearch<T, S extends Geometry> implements OnSubscribe<Entry<T, S>>", "class_docstring": "", "name": "OnSubscribeSearch", "super_interfaces": ["OnSubscribe<Entry<T, S>>"], "superclasses": "", "attributes": {"modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "fields": [{"attribute_expression": "private final Node<T, S> node;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Node<T, S>", "name": "node", "syntax_pass": true}, {"attribute_expression": "private final Func1<? super Geometry, Boolean> condition;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Func1<? super Geometry, Boolean>", "name": "condition", "syntax_pass": true}], "classes": [{"original_string": "    @VisibleForTesting\n    static class SearchProducer<T, S extends Geometry> implements Producer {\n\n        private final Subscriber<? super Entry<T, S>> subscriber;\n        private final Node<T, S> node;\n        private final Func1<? super Geometry, Boolean> condition;\n        private volatile ImmutableStack<NodePosition<T, S>> stack;\n        private final AtomicLong requested = new AtomicLong(0);\n\n        SearchProducer(Node<T, S> node, Func1<? super Geometry, Boolean> condition,\n                Subscriber<? super Entry<T, S>> subscriber) {\n            this.node = node;\n            this.condition = condition;\n            this.subscriber = subscriber;\n            stack = ImmutableStack.create(new NodePosition<T, S>(node, 0));\n        }\n\n        @Override\n        public void request(long n) {\n            try {\n                if (n <= 0 || requested.get() == Long.MAX_VALUE)\n                    // none requested or already started with fast path\n                    return;\n                else if (n == Long.MAX_VALUE && requested.compareAndSet(0, Long.MAX_VALUE)) {\n                    // fast path\n                    requestAll();\n                } else\n                    requestSome(n);\n            } catch (RuntimeException e) {\n                subscriber.onError(e);\n            }\n        }\n\n        private void requestAll() {\n            node.searchWithoutBackpressure(condition, subscriber);\n            if (!subscriber.isUnsubscribed())\n                subscriber.onCompleted();\n        }\n\n        private void requestSome(long n) {\n            // back pressure path\n            // this algorithm copied roughly from\n            // rxjava-core/OnSubscribeFromIterable.java\n\n            // rxjava used AtomicLongFieldUpdater instead of AtomicLong\n            // but benchmarks showed no benefit here so reverted to AtomicLong\n            long previousCount = getAndAddRequest(requested, n);\n            if (previousCount == 0) {\n                // don't touch stack every time during the loop because\n                // is a volatile and every write forces a thread memory\n                // cache flush\n                ImmutableStack<NodePosition<T, S>> st = stack;\n                while (true) {\n                    // minimize atomic reads by assigning to a variable here\n                    long r = requested.get();\n                    st = Backpressure.search(condition, subscriber, st, r);\n                    if (st.isEmpty()) {\n                        // release some state for gc (although empty stack so not very significant)\n                        stack = null;\n                        if (!subscriber.isUnsubscribed()) {\n                            subscriber.onCompleted();\n                        }\n                        return;\n                    } else {\n                        stack = st;\n                        if (requested.addAndGet(-r) == 0)\n                            return;\n                    }\n                }\n\n            }\n        }\n    }", "definition": "    @VisibleForTesting\n    static class SearchProducer<T, S extends Geometry> implements Producer", "class_docstring": "", "name": "SearchProducer", "super_interfaces": ["Producer"], "superclasses": "", "attributes": {"modifiers": "@VisibleForTesting\n    static", "marker_annotations": ["@VisibleForTesting"], "non_marker_annotations": ["static"], "comments": [], "fields": [{"attribute_expression": "private final Subscriber<? super Entry<T, S>> subscriber;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Subscriber<? super Entry<T, S>>", "name": "subscriber", "syntax_pass": true}, {"attribute_expression": "private final Node<T, S> node;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Node<T, S>", "name": "node", "syntax_pass": true}, {"attribute_expression": "private final Func1<? super Geometry, Boolean> condition;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Func1<? super Geometry, Boolean>", "name": "condition", "syntax_pass": true}, {"attribute_expression": "private volatile ImmutableStack<NodePosition<T, S>> stack;", "docstring": "", "modifiers": "private volatile", "marker_annotations": [], "non_marker_annotations": ["private", "volatile"], "comments": [], "type": "ImmutableStack<NodePosition<T, S>>", "name": "stack", "syntax_pass": true}, {"attribute_expression": "private final AtomicLong requested = new AtomicLong(0);", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "AtomicLong", "name": "requested = new AtomicLong(0)", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        SearchProducer(Node<T, S> node, Func1<? super Geometry, Boolean> condition,\n                Subscriber<? super Entry<T, S>> subscriber) {\n            this.node = node;\n            this.condition = condition;\n            this.subscriber = subscriber;\n            stack = ImmutableStack.create(new NodePosition<T, S>(node, 0));\n        }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "SearchProducer", "params": [{"name": "node", "type": "Node<T, S>"}, {"name": "condition", "type": "Func1<? super Geometry, Boolean>"}, {"name": "subscriber", "type": "Subscriber<? super Entry<T, S>>"}], "body": "                                                            {\n            this.node = node;\n            this.condition = condition;\n            this.subscriber = subscriber;\n            stack = ImmutableStack.create(new NodePosition<T, S>(node, 0));\n        }", "signature": "SearchProducer(Node<T, S> node, Func1<? super Geometry, Boolean> condition,\n                Subscriber<? super Entry<T, S>> subscriber)"}, {"syntax_pass": true, "original_string": "        @Override\n        public void request(long n) {\n            try {\n                if (n <= 0 || requested.get() == Long.MAX_VALUE)\n                    // none requested or already started with fast path\n                    return;\n                else if (n == Long.MAX_VALUE && requested.compareAndSet(0, Long.MAX_VALUE)) {\n                    // fast path\n                    requestAll();\n                } else\n                    requestSome(n);\n            } catch (RuntimeException e) {\n                subscriber.onError(e);\n            }\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "request", "params": [{"name": "n", "type": "long"}], "body": "                                    {\n            try {\n                if (n <= 0 || requested.get() == Long.MAX_VALUE)\n                    // none requested or already started with fast path\n                    return;\n                else if (n == Long.MAX_VALUE && requested.compareAndSet(0, Long.MAX_VALUE)) {\n                    // fast path\n                    requestAll();\n                } else\n                    requestSome(n);\n            } catch (RuntimeException e) {\n                subscriber.onError(e);\n            }\n        }", "signature": "@Override\n        public void request(long n)"}, {"syntax_pass": true, "original_string": "        private void requestAll() {\n            node.searchWithoutBackpressure(condition, subscriber);\n            if (!subscriber.isUnsubscribed())\n                subscriber.onCompleted();\n        }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "name": "requestAll", "params": [], "body": "                                  {\n            node.searchWithoutBackpressure(condition, subscriber);\n            if (!subscriber.isUnsubscribed())\n                subscriber.onCompleted();\n        }", "signature": "private void requestAll()"}, {"syntax_pass": true, "original_string": "        private void requestSome(long n) {\n            // back pressure path\n            // this algorithm copied roughly from\n            // rxjava-core/OnSubscribeFromIterable.java\n\n            // rxjava used AtomicLongFieldUpdater instead of AtomicLong\n            // but benchmarks showed no benefit here so reverted to AtomicLong\n            long previousCount = getAndAddRequest(requested, n);\n            if (previousCount == 0) {\n                // don't touch stack every time during the loop because\n                // is a volatile and every write forces a thread memory\n                // cache flush\n                ImmutableStack<NodePosition<T, S>> st = stack;\n                while (true) {\n                    // minimize atomic reads by assigning to a variable here\n                    long r = requested.get();\n                    st = Backpressure.search(condition, subscriber, st, r);\n                    if (st.isEmpty()) {\n                        // release some state for gc (although empty stack so not very significant)\n                        stack = null;\n                        if (!subscriber.isUnsubscribed()) {\n                            subscriber.onCompleted();\n                        }\n                        return;\n                    } else {\n                        stack = st;\n                        if (requested.addAndGet(-r) == 0)\n                            return;\n                    }\n                }\n\n            }\n        }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "name": "requestSome", "params": [{"name": "n", "type": "long"}], "body": "                                         {\n            // back pressure path\n            // this algorithm copied roughly from\n            // rxjava-core/OnSubscribeFromIterable.java\n\n            // rxjava used AtomicLongFieldUpdater instead of AtomicLong\n            // but benchmarks showed no benefit here so reverted to AtomicLong\n            long previousCount = getAndAddRequest(requested, n);\n            if (previousCount == 0) {\n                // don't touch stack every time during the loop because\n                // is a volatile and every write forces a thread memory\n                // cache flush\n                ImmutableStack<NodePosition<T, S>> st = stack;\n                while (true) {\n                    // minimize atomic reads by assigning to a variable here\n                    long r = requested.get();\n                    st = Backpressure.search(condition, subscriber, st, r);\n                    if (st.isEmpty()) {\n                        // release some state for gc (although empty stack so not very significant)\n                        stack = null;\n                        if (!subscriber.isUnsubscribed()) {\n                            subscriber.onCompleted();\n                        }\n                        return;\n                    } else {\n                        stack = st;\n                        if (requested.addAndGet(-r) == 0)\n                            return;\n                    }\n                }\n\n            }\n        }", "signature": "private void requestSome(long n)"}]}]}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    OnSubscribeSearch(Node<T, S> node, Func1<? super Geometry, Boolean> condition) {\n        this.node = node;\n        this.condition = condition;\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "OnSubscribeSearch", "params": [{"name": "node", "type": "Node<T, S>"}, {"name": "condition", "type": "Func1<? super Geometry, Boolean>"}], "body": "                                                                                   {\n        this.node = node;\n        this.condition = condition;\n    }", "signature": "OnSubscribeSearch(Node<T, S> node, Func1<? super Geometry, Boolean> condition)"}, {"syntax_pass": true, "original_string": "    @Override\n    public void call(Subscriber<? super Entry<T, S>> subscriber) {\n        subscriber.setProducer(new SearchProducer<T, S>(node, condition, subscriber));\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "call", "params": [{"name": "subscriber", "type": "Subscriber<? super Entry<T, S>>"}], "body": "                                                                 {\n        subscriber.setProducer(new SearchProducer<T, S>(node, condition, subscriber));\n    }", "signature": "@Override\n    public void call(Subscriber<? super Entry<T, S>> subscriber)"}, {"syntax_pass": true, "original_string": "    private static long getAndAddRequest(AtomicLong requested, long n) {\n        // add n to field but check for overflow\n        while (true) {\n            long current = requested.get();\n            long next = current + n;\n            // check for overflow\n            if (next < 0) {\n                next = Long.MAX_VALUE;\n            }\n            if (requested.compareAndSet(current, next)) {\n                return current;\n            }\n        }\n    }", "docstring": "\nAdds {@code n} to {@code requested} and returns the value prior to\naddition once the addition is successful (uses CAS semantics). If\noverflows then sets {@code requested} field to {@code Long.MAX_VALUE}.\n\n@param requested\n           atomic field updater for a request count\n@param n\n           the number of requests to add to the requested count\n@return requested value just prior to successful addition\n", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "long", "classes": []}, "name": "getAndAddRequest", "params": [{"name": "requested", "type": "AtomicLong"}, {"name": "n", "type": "long"}], "body": "                                                                       {\n        // add n to field but check for overflow\n        while (true) {\n            long current = requested.get();\n            long next = current + n;\n            // check for overflow\n            if (next < 0) {\n                next = Long.MAX_VALUE;\n            }\n            if (requested.compareAndSet(current, next)) {\n                return current;\n            }\n        }\n    }", "signature": "private static long getAndAddRequest(AtomicLong requested, long n)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/com/github/davidmoten/rtree/Entries.java", "original_string": "package com.github.davidmoten.rtree;\n\nimport com.github.davidmoten.rtree.geometry.Geometry;\nimport com.github.davidmoten.rtree.internal.EntryDefault;\n\npublic final class Entries {\n\n    private Entries() {\n        // prevent instantiation\n    }\n    \n    public static <T, S extends Geometry> Entry<T,S> entry(T object, S geometry) {\n        return EntryDefault.entry(object, geometry);\n    }\n    \n}\n", "file_hash": "6ed53e30dd54334db9ca909092b86917d34c22a69d44622fae5e4195ab49f8a0", "file_docstring": "", "contexts": ["package com.github.davidmoten.rtree;", "import com.github.davidmoten.rtree.geometry.Geometry;", "import com.github.davidmoten.rtree.internal.EntryDefault;"], "methods": [], "classes": [{"original_string": "public final class Entries {\n\n    private Entries() {\n        // prevent instantiation\n    }\n    \n    public static <T, S extends Geometry> Entry<T,S> entry(T object, S geometry) {\n        return EntryDefault.entry(object, geometry);\n    }\n    \n}", "definition": "public final class Entries", "class_docstring": "", "name": "Entries", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    private Entries() {\n        // prevent instantiation\n    }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "", "classes": []}, "name": "Entries", "params": [], "body": "                      {\n        // prevent instantiation\n    }", "signature": "private Entries()"}, {"syntax_pass": true, "original_string": "    public static <T, S extends Geometry> Entry<T,S> entry(T object, S geometry) {\n        return EntryDefault.entry(object, geometry);\n    }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Entry<T,S>", "classes": []}, "name": "entry", "params": [{"name": "object", "type": "T"}, {"name": "geometry", "type": "S"}], "body": "                                                                                 {\n        return EntryDefault.entry(object, geometry);\n    }", "signature": "public static <T, S extends Geometry> Entry<T,S> entry(T object, S geometry)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/com/github/davidmoten/rtree/Factory.java", "original_string": "package com.github.davidmoten.rtree;\n\nimport com.github.davidmoten.rtree.geometry.Geometry;\n\npublic interface Factory<T, S extends Geometry>\n        extends LeafFactory<T, S>, NonLeafFactory<T, S>, EntryFactory<T,S> {\n}\n", "file_hash": "0f3d8776e1f0123ce10ed2a33bc25aa510b765f3a2325c22116c4a25e83841fb", "file_docstring": "", "contexts": ["package com.github.davidmoten.rtree;", "import com.github.davidmoten.rtree.geometry.Geometry;"], "methods": [], "classes": [], "interfaces": [{"original_string": "public interface Factory<T, S extends Geometry>\n        extends LeafFactory<T, S>, NonLeafFactory<T, S>, EntryFactory<T,S> {\n}", "definition": "public interface Factory<T, S extends Geometry>\n        extends LeafFactory<T, S>, NonLeafFactory<T, S>, EntryFactory<T,S>", "interface_docstring": "", "name": "Factory", "extends_interfaces": ["LeafFactory<T, S>", "NonLeafFactory<T, S>", "EntryFactory<T,S>"], "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": []}, "syntax_pass": true, "methods": []}], "records": []}, {"relative_path": "src/main/java/com/github/davidmoten/rtree/Selector.java", "original_string": "package com.github.davidmoten.rtree;\n\nimport java.util.List;\n\nimport com.github.davidmoten.rtree.geometry.Geometry;\n\n/**\n * The heuristic used on insert to select which node to add an Entry to.\n * \n */\npublic interface Selector {\n\n    /**\n     * Returns the node from a list of nodes that an object with the given\n     * geometry would be added to.\n     * \n     * @param <T>\n     *            type of value of entry in tree\n     * @param <S>\n     *            type of geometry of entry in tree\n     * @param g\n     *            geometry\n     * @param nodes\n     *            nodes to select from\n     * @return one of the given nodes\n     */\n    <T, S extends Geometry> Node<T, S> select(Geometry g, List<? extends Node<T, S>> nodes);\n\n}\n", "file_hash": "beb3c74e95159a7b1b20606426b0f78ce0d7682bd488bc151d6a9cb8d3b061db", "file_docstring": "\nThe heuristic used on insert to select which node to add an Entry to.\n\n", "contexts": ["package com.github.davidmoten.rtree;", "import java.util.List;", "import com.github.davidmoten.rtree.geometry.Geometry;"], "methods": [], "classes": [], "interfaces": [{"original_string": "public interface Selector {\n\n    /**\n     * Returns the node from a list of nodes that an object with the given\n     * geometry would be added to.\n     * \n     * @param <T>\n     *            type of value of entry in tree\n     * @param <S>\n     *            type of geometry of entry in tree\n     * @param g\n     *            geometry\n     * @param nodes\n     *            nodes to select from\n     * @return one of the given nodes\n     */\n    <T, S extends Geometry> Node<T, S> select(Geometry g, List<? extends Node<T, S>> nodes);\n\n}", "definition": "public interface Selector", "interface_docstring": "\nThe heuristic used on insert to select which node to add an Entry to.\n\n", "name": "Selector", "extends_interfaces": [], "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    <T, S extends Geometry> Node<T, S> select(Geometry g, List<? extends Node<T, S>> nodes);", "docstring": "\nReturns the node from a list of nodes that an object with the given\ngeometry would be added to.\n\n@param <T>\n           type of value of entry in tree\n@param <S>\n           type of geometry of entry in tree\n@param g\n           geometry\n@param nodes\n           nodes to select from\n@return one of the given nodes\n", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "Node<T, S>", "classes": []}, "name": "select", "params": [{"name": "g", "type": "Geometry"}, {"name": "nodes", "type": "List<? extends Node<T, S>>"}], "body": "", "signature": "<T, S extends Geometry> Node<T, S> select(Geometry g, List<? extends Node<T, S>> nodes)"}]}], "records": []}, {"relative_path": "src/main/java/com/github/davidmoten/rtree/SerializerHelper.java", "original_string": "package com.github.davidmoten.rtree;\n\nimport com.github.davidmoten.rtree.geometry.Geometry;\n\nimport java.util.Optional;\n\npublic final class SerializerHelper {\n    \n    private SerializerHelper() {\n        // prevent instantiation\n    }\n\n    public static <T, S extends Geometry> RTree<T, S> create(Optional<Node<T, S>> root, int size,\n            Context<T, S> context) {\n        return RTree.create(root, size, context);\n    }\n\n}\n", "file_hash": "8b56ca8a18b23f5469eeac92dcfdcb6cb3040dfdac66e62c4b6985feb71971b7", "file_docstring": "", "contexts": ["package com.github.davidmoten.rtree;", "import com.github.davidmoten.rtree.geometry.Geometry;", "import java.util.Optional;"], "methods": [], "classes": [{"original_string": "public final class SerializerHelper {\n    \n    private SerializerHelper() {\n        // prevent instantiation\n    }\n\n    public static <T, S extends Geometry> RTree<T, S> create(Optional<Node<T, S>> root, int size,\n            Context<T, S> context) {\n        return RTree.create(root, size, context);\n    }\n\n}", "definition": "public final class SerializerHelper", "class_docstring": "", "name": "SerializerHelper", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    private SerializerHelper() {\n        // prevent instantiation\n    }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "", "classes": []}, "name": "SerializerHelper", "params": [], "body": "                               {\n        // prevent instantiation\n    }", "signature": "private SerializerHelper()"}, {"syntax_pass": true, "original_string": "    public static <T, S extends Geometry> RTree<T, S> create(Optional<Node<T, S>> root, int size,\n            Context<T, S> context) {\n        return RTree.create(root, size, context);\n    }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "RTree<T, S>", "classes": []}, "name": "create", "params": [{"name": "root", "type": "Optional<Node<T, S>>"}, {"name": "size", "type": "int"}, {"name": "context", "type": "Context<T, S>"}], "body": "                                   {\n        return RTree.create(root, size, context);\n    }", "signature": "public static <T, S extends Geometry> RTree<T, S> create(Optional<Node<T, S>> root, int size,\n            Context<T, S> context)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/com/github/davidmoten/rtree/SelectorMinimalAreaIncrease.java", "original_string": "package com.github.davidmoten.rtree;\n\nimport static java.util.Collections.min;\n\nimport java.util.List;\n\nimport com.github.davidmoten.rtree.geometry.Geometry;\nimport com.github.davidmoten.rtree.internal.Comparators;\n\n/**\n * Uses minimal area increase to select a node from a list.\n *\n */\npublic final class SelectorMinimalAreaIncrease implements Selector {\n\n    @Override\n    public <T, S extends Geometry> Node<T, S> select(Geometry g, List<? extends Node<T, S>> nodes) {\n        return min(nodes, Comparators.areaIncreaseThenAreaComparator(g.mbr()));\n    }\n}\n", "file_hash": "fb44ce52fca5f8e4f91f1193f7aca31df411134776836c6715c6743d68362e74", "file_docstring": "", "contexts": ["package com.github.davidmoten.rtree;", "import static java.util.Collections.min;", "import java.util.List;", "import com.github.davidmoten.rtree.geometry.Geometry;", "import com.github.davidmoten.rtree.internal.Comparators;"], "methods": [], "classes": [{"original_string": "public final class SelectorMinimalAreaIncrease implements Selector {\n\n    @Override\n    public <T, S extends Geometry> Node<T, S> select(Geometry g, List<? extends Node<T, S>> nodes) {\n        return min(nodes, Comparators.areaIncreaseThenAreaComparator(g.mbr()));\n    }\n}", "definition": "public final class SelectorMinimalAreaIncrease implements Selector", "class_docstring": "\nUses minimal area increase to select a node from a list.\n\n", "name": "SelectorMinimalAreaIncrease", "super_interfaces": ["Selector"], "superclasses": "", "attributes": {"modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @Override\n    public <T, S extends Geometry> Node<T, S> select(Geometry g, List<? extends Node<T, S>> nodes) {\n        return min(nodes, Comparators.areaIncreaseThenAreaComparator(g.mbr()));\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Node<T, S>", "classes": []}, "name": "select", "params": [{"name": "g", "type": "Geometry"}, {"name": "nodes", "type": "List<? extends Node<T, S>>"}], "body": "                                                                                                   {\n        return min(nodes, Comparators.areaIncreaseThenAreaComparator(g.mbr()));\n    }", "signature": "@Override\n    public <T, S extends Geometry> Node<T, S> select(Geometry g, List<? extends Node<T, S>> nodes)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/com/github/davidmoten/rtree/SplitterQuadratic.java", "original_string": "package com.github.davidmoten.rtree;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Optional;\n\nimport com.github.davidmoten.guavamini.Lists;\nimport com.github.davidmoten.guavamini.Preconditions;\nimport com.github.davidmoten.guavamini.annotations.VisibleForTesting;\nimport com.github.davidmoten.rtree.geometry.HasGeometry;\nimport com.github.davidmoten.rtree.geometry.ListPair;\nimport com.github.davidmoten.rtree.geometry.Rectangle;\nimport com.github.davidmoten.rtree.internal.Util;\nimport com.github.davidmoten.rtree.internal.util.Pair;\n\nimport static java.util.Optional.of;\n\npublic final class SplitterQuadratic implements Splitter {\n\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public <T extends HasGeometry> ListPair<T> split(List<T> items, int minSize) {\n        Preconditions.checkArgument(items.size() >= 2);\n\n        // according to\n        // http://en.wikipedia.org/wiki/R-tree#Splitting_an_overflowing_node\n\n        // find the worst combination pairwise in the list and use them to start\n        // the two groups\n        final Pair<T> worstCombination = worstCombination(items);\n\n        // worst combination to have in the same node is now e1,e2.\n\n        // establish a group around e1 and another group around e2\n        final List<T> group1 = Lists.newArrayList(worstCombination.value1());\n        final List<T> group2 = Lists.newArrayList(worstCombination.value2());\n\n        final List<T> remaining = new ArrayList<T>(items);\n        remaining.remove(worstCombination.value1());\n        remaining.remove(worstCombination.value2());\n\n        final int minGroupSize = items.size() / 2;\n\n        // now add the remainder to the groups using least mbr area increase\n        // except in the case where minimumSize would be contradicted\n        while (remaining.size() > 0) {\n            assignRemaining(group1, group2, remaining, minGroupSize);\n        }\n        return new ListPair<T>(group1, group2);\n    }\n\n    private <T extends HasGeometry> void assignRemaining(final List<T> group1, final List<T> group2,\n            final List<T> remaining, final int minGroupSize) {\n        final Rectangle mbr1 = Util.mbr(group1);\n        final Rectangle mbr2 = Util.mbr(group2);\n        final T item1 = getBestCandidateForGroup(remaining, group1, mbr1);\n        final T item2 = getBestCandidateForGroup(remaining, group2, mbr2);\n        final boolean area1LessThanArea2 = item1.geometry().mbr().add(mbr1).area() <= item2\n                .geometry().mbr().add(mbr2).area();\n\n        if (area1LessThanArea2 && (group2.size() + remaining.size() - 1 >= minGroupSize)\n                || !area1LessThanArea2 && (group1.size() + remaining.size() == minGroupSize)) {\n            group1.add(item1);\n            remaining.remove(item1);\n        } else {\n            group2.add(item2);\n            remaining.remove(item2);\n        }\n    }\n\n    @VisibleForTesting\n    static <T extends HasGeometry> T getBestCandidateForGroup(List<T> list, List<T> group,\n            Rectangle groupMbr) {\n        // TODO reduce allocations by not using Optional\n        Optional<T> minEntry = Optional.empty();\n        Optional<Double> minArea = Optional.empty();\n        for (final T entry : list) {\n            double area = groupMbr.add(entry.geometry().mbr()).area();\n            if (!minArea.isPresent() || area < minArea.get()) {\n                minArea = of(area);\n                minEntry = of(entry);\n            }\n        }\n        return minEntry.get();\n    }\n\n    @VisibleForTesting\n    static <T extends HasGeometry> Pair<T> worstCombination(List<T> items) {\n        //TODO reduce allocations by not using Optional\n        Optional<T> e1 = Optional.empty();\n        Optional<T> e2 = Optional.empty();\n        {\n            Optional<Double> maxArea = Optional.empty();\n            for (int i = 0; i < items.size(); i++) {\n                for (int j = i + 1; j < items.size(); j++) {\n                    T entry1 = items.get(i);\n                    T entry2 = items.get(j);\n                    final double area = entry1.geometry().mbr().add(entry2.geometry().mbr()).area();\n                    if (!maxArea.isPresent() || area > maxArea.get()) {\n                        e1 = of(entry1);\n                        e2 = of(entry2);\n                        maxArea = of(area);\n                    }\n                }\n            }\n        }\n        if (e1.isPresent()) {\n            return new Pair<>(e1.get(), e2.get());\n        } else {\n            // all items are the same item\n            return new Pair<>(items.get(0), items.get(1));\n        }\n    }\n}\n", "file_hash": "c85dcc75ee17dc1651fe24bbf243f4ac3fd2baa75491baa0f097deabcc2b7a57", "file_docstring": "", "contexts": ["package com.github.davidmoten.rtree;", "import java.util.ArrayList;", "import java.util.List;", "import java.util.Optional;", "import com.github.davidmoten.guavamini.Lists;", "import com.github.davidmoten.guavamini.Preconditions;", "import com.github.davidmoten.guavamini.annotations.VisibleForTesting;", "import com.github.davidmoten.rtree.geometry.HasGeometry;", "import com.github.davidmoten.rtree.geometry.ListPair;", "import com.github.davidmoten.rtree.geometry.Rectangle;", "import com.github.davidmoten.rtree.internal.Util;", "import com.github.davidmoten.rtree.internal.util.Pair;", "import static java.util.Optional.of;"], "methods": [], "classes": [{"original_string": "public final class SplitterQuadratic implements Splitter {\n\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public <T extends HasGeometry> ListPair<T> split(List<T> items, int minSize) {\n        Preconditions.checkArgument(items.size() >= 2);\n\n        // according to\n        // http://en.wikipedia.org/wiki/R-tree#Splitting_an_overflowing_node\n\n        // find the worst combination pairwise in the list and use them to start\n        // the two groups\n        final Pair<T> worstCombination = worstCombination(items);\n\n        // worst combination to have in the same node is now e1,e2.\n\n        // establish a group around e1 and another group around e2\n        final List<T> group1 = Lists.newArrayList(worstCombination.value1());\n        final List<T> group2 = Lists.newArrayList(worstCombination.value2());\n\n        final List<T> remaining = new ArrayList<T>(items);\n        remaining.remove(worstCombination.value1());\n        remaining.remove(worstCombination.value2());\n\n        final int minGroupSize = items.size() / 2;\n\n        // now add the remainder to the groups using least mbr area increase\n        // except in the case where minimumSize would be contradicted\n        while (remaining.size() > 0) {\n            assignRemaining(group1, group2, remaining, minGroupSize);\n        }\n        return new ListPair<T>(group1, group2);\n    }\n\n    private <T extends HasGeometry> void assignRemaining(final List<T> group1, final List<T> group2,\n            final List<T> remaining, final int minGroupSize) {\n        final Rectangle mbr1 = Util.mbr(group1);\n        final Rectangle mbr2 = Util.mbr(group2);\n        final T item1 = getBestCandidateForGroup(remaining, group1, mbr1);\n        final T item2 = getBestCandidateForGroup(remaining, group2, mbr2);\n        final boolean area1LessThanArea2 = item1.geometry().mbr().add(mbr1).area() <= item2\n                .geometry().mbr().add(mbr2).area();\n\n        if (area1LessThanArea2 && (group2.size() + remaining.size() - 1 >= minGroupSize)\n                || !area1LessThanArea2 && (group1.size() + remaining.size() == minGroupSize)) {\n            group1.add(item1);\n            remaining.remove(item1);\n        } else {\n            group2.add(item2);\n            remaining.remove(item2);\n        }\n    }\n\n    @VisibleForTesting\n    static <T extends HasGeometry> T getBestCandidateForGroup(List<T> list, List<T> group,\n            Rectangle groupMbr) {\n        // TODO reduce allocations by not using Optional\n        Optional<T> minEntry = Optional.empty();\n        Optional<Double> minArea = Optional.empty();\n        for (final T entry : list) {\n            double area = groupMbr.add(entry.geometry().mbr()).area();\n            if (!minArea.isPresent() || area < minArea.get()) {\n                minArea = of(area);\n                minEntry = of(entry);\n            }\n        }\n        return minEntry.get();\n    }\n\n    @VisibleForTesting\n    static <T extends HasGeometry> Pair<T> worstCombination(List<T> items) {\n        //TODO reduce allocations by not using Optional\n        Optional<T> e1 = Optional.empty();\n        Optional<T> e2 = Optional.empty();\n        {\n            Optional<Double> maxArea = Optional.empty();\n            for (int i = 0; i < items.size(); i++) {\n                for (int j = i + 1; j < items.size(); j++) {\n                    T entry1 = items.get(i);\n                    T entry2 = items.get(j);\n                    final double area = entry1.geometry().mbr().add(entry2.geometry().mbr()).area();\n                    if (!maxArea.isPresent() || area > maxArea.get()) {\n                        e1 = of(entry1);\n                        e2 = of(entry2);\n                        maxArea = of(area);\n                    }\n                }\n            }\n        }\n        if (e1.isPresent()) {\n            return new Pair<>(e1.get(), e2.get());\n        } else {\n            // all items are the same item\n            return new Pair<>(items.get(0), items.get(1));\n        }\n    }\n}", "definition": "public final class SplitterQuadratic implements Splitter", "class_docstring": "", "name": "SplitterQuadratic", "super_interfaces": ["Splitter"], "superclasses": "", "attributes": {"modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @SuppressWarnings(\"unchecked\")\n    @Override\n    public <T extends HasGeometry> ListPair<T> split(List<T> items, int minSize) {\n        Preconditions.checkArgument(items.size() >= 2);\n\n        // according to\n        // http://en.wikipedia.org/wiki/R-tree#Splitting_an_overflowing_node\n\n        // find the worst combination pairwise in the list and use them to start\n        // the two groups\n        final Pair<T> worstCombination = worstCombination(items);\n\n        // worst combination to have in the same node is now e1,e2.\n\n        // establish a group around e1 and another group around e2\n        final List<T> group1 = Lists.newArrayList(worstCombination.value1());\n        final List<T> group2 = Lists.newArrayList(worstCombination.value2());\n\n        final List<T> remaining = new ArrayList<T>(items);\n        remaining.remove(worstCombination.value1());\n        remaining.remove(worstCombination.value2());\n\n        final int minGroupSize = items.size() / 2;\n\n        // now add the remainder to the groups using least mbr area increase\n        // except in the case where minimumSize would be contradicted\n        while (remaining.size() > 0) {\n            assignRemaining(group1, group2, remaining, minGroupSize);\n        }\n        return new ListPair<T>(group1, group2);\n    }", "docstring": "", "attributes": {"modifiers": "@SuppressWarnings(\"unchecked\")\n    @Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["@SuppressWarnings(\"unchecked\")", "public"], "comments": [], "return_type": "ListPair<T>", "classes": []}, "name": "split", "params": [{"name": "items", "type": "List<T>"}, {"name": "minSize", "type": "int"}], "body": "                                                                                 {\n        Preconditions.checkArgument(items.size() >= 2);\n\n        // according to\n        // http://en.wikipedia.org/wiki/R-tree#Splitting_an_overflowing_node\n\n        // find the worst combination pairwise in the list and use them to start\n        // the two groups\n        final Pair<T> worstCombination = worstCombination(items);\n\n        // worst combination to have in the same node is now e1,e2.\n\n        // establish a group around e1 and another group around e2\n        final List<T> group1 = Lists.newArrayList(worstCombination.value1());\n        final List<T> group2 = Lists.newArrayList(worstCombination.value2());\n\n        final List<T> remaining = new ArrayList<T>(items);\n        remaining.remove(worstCombination.value1());\n        remaining.remove(worstCombination.value2());\n\n        final int minGroupSize = items.size() / 2;\n\n        // now add the remainder to the groups using least mbr area increase\n        // except in the case where minimumSize would be contradicted\n        while (remaining.size() > 0) {\n            assignRemaining(group1, group2, remaining, minGroupSize);\n        }\n        return new ListPair<T>(group1, group2);\n    }", "signature": "@SuppressWarnings(\"unchecked\")\n    @Override\n    public <T extends HasGeometry> ListPair<T> split(List<T> items, int minSize)"}, {"syntax_pass": true, "original_string": "    private <T extends HasGeometry> void assignRemaining(final List<T> group1, final List<T> group2,\n            final List<T> remaining, final int minGroupSize) {\n        final Rectangle mbr1 = Util.mbr(group1);\n        final Rectangle mbr2 = Util.mbr(group2);\n        final T item1 = getBestCandidateForGroup(remaining, group1, mbr1);\n        final T item2 = getBestCandidateForGroup(remaining, group2, mbr2);\n        final boolean area1LessThanArea2 = item1.geometry().mbr().add(mbr1).area() <= item2\n                .geometry().mbr().add(mbr2).area();\n\n        if (area1LessThanArea2 && (group2.size() + remaining.size() - 1 >= minGroupSize)\n                || !area1LessThanArea2 && (group1.size() + remaining.size() == minGroupSize)) {\n            group1.add(item1);\n            remaining.remove(item1);\n        } else {\n            group2.add(item2);\n            remaining.remove(item2);\n        }\n    }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "name": "assignRemaining", "params": [{"name": "group1", "type": "List<T>"}, {"name": "group2", "type": "List<T>"}, {"name": "remaining", "type": "List<T>"}, {"name": "minGroupSize", "type": "int"}], "body": "                                                             {\n        final Rectangle mbr1 = Util.mbr(group1);\n        final Rectangle mbr2 = Util.mbr(group2);\n        final T item1 = getBestCandidateForGroup(remaining, group1, mbr1);\n        final T item2 = getBestCandidateForGroup(remaining, group2, mbr2);\n        final boolean area1LessThanArea2 = item1.geometry().mbr().add(mbr1).area() <= item2\n                .geometry().mbr().add(mbr2).area();\n\n        if (area1LessThanArea2 && (group2.size() + remaining.size() - 1 >= minGroupSize)\n                || !area1LessThanArea2 && (group1.size() + remaining.size() == minGroupSize)) {\n            group1.add(item1);\n            remaining.remove(item1);\n        } else {\n            group2.add(item2);\n            remaining.remove(item2);\n        }\n    }", "signature": "private <T extends HasGeometry> void assignRemaining(final List<T> group1, final List<T> group2,\n            final List<T> remaining, final int minGroupSize)"}, {"syntax_pass": true, "original_string": "    @VisibleForTesting\n    static <T extends HasGeometry> T getBestCandidateForGroup(List<T> list, List<T> group,\n            Rectangle groupMbr) {\n        // TODO reduce allocations by not using Optional\n        Optional<T> minEntry = Optional.empty();\n        Optional<Double> minArea = Optional.empty();\n        for (final T entry : list) {\n            double area = groupMbr.add(entry.geometry().mbr()).area();\n            if (!minArea.isPresent() || area < minArea.get()) {\n                minArea = of(area);\n                minEntry = of(entry);\n            }\n        }\n        return minEntry.get();\n    }", "docstring": "", "attributes": {"modifiers": "@VisibleForTesting\n    static", "marker_annotations": ["@VisibleForTesting"], "non_marker_annotations": ["static"], "comments": [], "return_type": "T", "classes": []}, "name": "getBestCandidateForGroup", "params": [{"name": "list", "type": "List<T>"}, {"name": "group", "type": "List<T>"}, {"name": "groupMbr", "type": "Rectangle"}], "body": "                                {\n        // TODO reduce allocations by not using Optional\n        Optional<T> minEntry = Optional.empty();\n        Optional<Double> minArea = Optional.empty();\n        for (final T entry : list) {\n            double area = groupMbr.add(entry.geometry().mbr()).area();\n            if (!minArea.isPresent() || area < minArea.get()) {\n                minArea = of(area);\n                minEntry = of(entry);\n            }\n        }\n        return minEntry.get();\n    }", "signature": "@VisibleForTesting\n    static <T extends HasGeometry> T getBestCandidateForGroup(List<T> list, List<T> group,\n            Rectangle groupMbr)"}, {"syntax_pass": true, "original_string": "    @VisibleForTesting\n    static <T extends HasGeometry> Pair<T> worstCombination(List<T> items) {\n        //TODO reduce allocations by not using Optional\n        Optional<T> e1 = Optional.empty();\n        Optional<T> e2 = Optional.empty();\n        {\n            Optional<Double> maxArea = Optional.empty();\n            for (int i = 0; i < items.size(); i++) {\n                for (int j = i + 1; j < items.size(); j++) {\n                    T entry1 = items.get(i);\n                    T entry2 = items.get(j);\n                    final double area = entry1.geometry().mbr().add(entry2.geometry().mbr()).area();\n                    if (!maxArea.isPresent() || area > maxArea.get()) {\n                        e1 = of(entry1);\n                        e2 = of(entry2);\n                        maxArea = of(area);\n                    }\n                }\n            }\n        }\n        if (e1.isPresent()) {\n            return new Pair<>(e1.get(), e2.get());\n        } else {\n            // all items are the same item\n            return new Pair<>(items.get(0), items.get(1));\n        }\n    }", "docstring": "", "attributes": {"modifiers": "@VisibleForTesting\n    static", "marker_annotations": ["@VisibleForTesting"], "non_marker_annotations": ["static"], "comments": [], "return_type": "Pair<T>", "classes": []}, "name": "worstCombination", "params": [{"name": "items", "type": "List<T>"}], "body": "                                                                           {\n        //TODO reduce allocations by not using Optional\n        Optional<T> e1 = Optional.empty();\n        Optional<T> e2 = Optional.empty();\n        {\n            Optional<Double> maxArea = Optional.empty();\n            for (int i = 0; i < items.size(); i++) {\n                for (int j = i + 1; j < items.size(); j++) {\n                    T entry1 = items.get(i);\n                    T entry2 = items.get(j);\n                    final double area = entry1.geometry().mbr().add(entry2.geometry().mbr()).area();\n                    if (!maxArea.isPresent() || area > maxArea.get()) {\n                        e1 = of(entry1);\n                        e2 = of(entry2);\n                        maxArea = of(area);\n                    }\n                }\n            }\n        }\n        if (e1.isPresent()) {\n            return new Pair<>(e1.get(), e2.get());\n        } else {\n            // all items are the same item\n            return new Pair<>(items.get(0), items.get(1));\n        }\n    }", "signature": "@VisibleForTesting\n    static <T extends HasGeometry> Pair<T> worstCombination(List<T> items)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/com/github/davidmoten/rtree/Backpressure.java", "original_string": "package com.github.davidmoten.rtree;\n\nimport com.github.davidmoten.rtree.geometry.Geometry;\nimport com.github.davidmoten.rtree.internal.util.ImmutableStack;\n\nimport rx.Subscriber;\nimport rx.functions.Func1;\n\n/**\n * Utility methods for controlling backpressure of the tree search.\n */\nfinal class Backpressure {\n\n    private Backpressure() {\n        // prevent instantiation\n    }\n\n    static <T, S extends Geometry> ImmutableStack<NodePosition<T, S>> search(\n            final Func1<? super Geometry, Boolean> condition,\n            final Subscriber<? super Entry<T, S>> subscriber,\n            final ImmutableStack<NodePosition<T, S>> stack, final long request) {\n        StackAndRequest<NodePosition<T, S>> state = StackAndRequest.create(stack, request);\n        return searchAndReturnStack(condition, subscriber, state);\n    }\n\n    private static <S extends Geometry, T> ImmutableStack<NodePosition<T, S>> searchAndReturnStack(\n            final Func1<? super Geometry, Boolean> condition,\n            final Subscriber<? super Entry<T, S>> subscriber,\n            StackAndRequest<NodePosition<T, S>> state) {\n\n        while (!state.stack.isEmpty()) {\n            NodePosition<T, S> np = state.stack.peek();\n            if (subscriber.isUnsubscribed())\n                return ImmutableStack.empty();\n            else if (state.request <= 0)\n                return state.stack;\n            else if (np.position() == np.node().count()) {\n                // handle after last in node\n                state = StackAndRequest.create(searchAfterLastInNode(state.stack), state.request);\n            } else if (np.node() instanceof NonLeaf) {\n                // handle non-leaf\n                state = StackAndRequest.create(searchNonLeaf(condition, state.stack, np),\n                        state.request);\n            } else {\n                // handle leaf\n                state = searchLeaf(condition, subscriber, state, np);\n            }\n        }\n        return state.stack;\n    }\n\n    private static class StackAndRequest<T> {\n        private final ImmutableStack<T> stack;\n        private final long request;\n\n        StackAndRequest(ImmutableStack<T> stack, long request) {\n            this.stack = stack;\n            this.request = request;\n        }\n\n        static <T> StackAndRequest<T> create(ImmutableStack<T> stack, long request) {\n            return new StackAndRequest<T>(stack, request);\n        }\n\n    }\n\n    private static <T, S extends Geometry> StackAndRequest<NodePosition<T, S>> searchLeaf(\n            final Func1<? super Geometry, Boolean> condition,\n            final Subscriber<? super Entry<T, S>> subscriber,\n            StackAndRequest<NodePosition<T, S>> state, NodePosition<T, S> np) {\n        final long nextRequest;\n        Entry<T, S> entry = ((Leaf<T, S>) np.node()).entry(np.position());\n        if (condition.call(entry.geometry())) {\n            subscriber.onNext(entry);\n            nextRequest = state.request - 1;\n        } else\n            nextRequest = state.request;\n        return StackAndRequest.create(state.stack.pop().push(np.nextPosition()), nextRequest);\n    }\n\n    private static <S extends Geometry, T> ImmutableStack<NodePosition<T, S>> searchNonLeaf(\n            final Func1<? super Geometry, Boolean> condition,\n            ImmutableStack<NodePosition<T, S>> stack, NodePosition<T, S> np) {\n        Node<T, S> child = ((NonLeaf<T, S>) np.node()).child(np.position());\n        if (condition.call(child.geometry())) {\n            stack = stack.push(new NodePosition<T, S>(child, 0));\n        } else {\n            stack = stack.pop().push(np.nextPosition());\n        }\n        return stack;\n    }\n\n    private static <S extends Geometry, T> ImmutableStack<NodePosition<T, S>> searchAfterLastInNode(\n            ImmutableStack<NodePosition<T, S>> stack) {\n        ImmutableStack<NodePosition<T, S>> stack2 = stack.pop();\n        if (stack2.isEmpty())\n            stack = stack2;\n        else {\n            NodePosition<T, S> previous = stack2.peek();\n            stack = stack2.pop().push(previous.nextPosition());\n        }\n        return stack;\n    }\n\n}\n", "file_hash": "3a684b08715db55b37afe0bf4d3b079e6291bf2f2526231d6a57ceddbb33fc1a", "file_docstring": "", "contexts": ["package com.github.davidmoten.rtree;", "import com.github.davidmoten.rtree.geometry.Geometry;", "import com.github.davidmoten.rtree.internal.util.ImmutableStack;", "import rx.Subscriber;", "import rx.functions.Func1;"], "methods": [], "classes": [{"original_string": "final class Backpressure {\n\n    private Backpressure() {\n        // prevent instantiation\n    }\n\n    static <T, S extends Geometry> ImmutableStack<NodePosition<T, S>> search(\n            final Func1<? super Geometry, Boolean> condition,\n            final Subscriber<? super Entry<T, S>> subscriber,\n            final ImmutableStack<NodePosition<T, S>> stack, final long request) {\n        StackAndRequest<NodePosition<T, S>> state = StackAndRequest.create(stack, request);\n        return searchAndReturnStack(condition, subscriber, state);\n    }\n\n    private static <S extends Geometry, T> ImmutableStack<NodePosition<T, S>> searchAndReturnStack(\n            final Func1<? super Geometry, Boolean> condition,\n            final Subscriber<? super Entry<T, S>> subscriber,\n            StackAndRequest<NodePosition<T, S>> state) {\n\n        while (!state.stack.isEmpty()) {\n            NodePosition<T, S> np = state.stack.peek();\n            if (subscriber.isUnsubscribed())\n                return ImmutableStack.empty();\n            else if (state.request <= 0)\n                return state.stack;\n            else if (np.position() == np.node().count()) {\n                // handle after last in node\n                state = StackAndRequest.create(searchAfterLastInNode(state.stack), state.request);\n            } else if (np.node() instanceof NonLeaf) {\n                // handle non-leaf\n                state = StackAndRequest.create(searchNonLeaf(condition, state.stack, np),\n                        state.request);\n            } else {\n                // handle leaf\n                state = searchLeaf(condition, subscriber, state, np);\n            }\n        }\n        return state.stack;\n    }\n\n    private static class StackAndRequest<T> {\n        private final ImmutableStack<T> stack;\n        private final long request;\n\n        StackAndRequest(ImmutableStack<T> stack, long request) {\n            this.stack = stack;\n            this.request = request;\n        }\n\n        static <T> StackAndRequest<T> create(ImmutableStack<T> stack, long request) {\n            return new StackAndRequest<T>(stack, request);\n        }\n\n    }\n\n    private static <T, S extends Geometry> StackAndRequest<NodePosition<T, S>> searchLeaf(\n            final Func1<? super Geometry, Boolean> condition,\n            final Subscriber<? super Entry<T, S>> subscriber,\n            StackAndRequest<NodePosition<T, S>> state, NodePosition<T, S> np) {\n        final long nextRequest;\n        Entry<T, S> entry = ((Leaf<T, S>) np.node()).entry(np.position());\n        if (condition.call(entry.geometry())) {\n            subscriber.onNext(entry);\n            nextRequest = state.request - 1;\n        } else\n            nextRequest = state.request;\n        return StackAndRequest.create(state.stack.pop().push(np.nextPosition()), nextRequest);\n    }\n\n    private static <S extends Geometry, T> ImmutableStack<NodePosition<T, S>> searchNonLeaf(\n            final Func1<? super Geometry, Boolean> condition,\n            ImmutableStack<NodePosition<T, S>> stack, NodePosition<T, S> np) {\n        Node<T, S> child = ((NonLeaf<T, S>) np.node()).child(np.position());\n        if (condition.call(child.geometry())) {\n            stack = stack.push(new NodePosition<T, S>(child, 0));\n        } else {\n            stack = stack.pop().push(np.nextPosition());\n        }\n        return stack;\n    }\n\n    private static <S extends Geometry, T> ImmutableStack<NodePosition<T, S>> searchAfterLastInNode(\n            ImmutableStack<NodePosition<T, S>> stack) {\n        ImmutableStack<NodePosition<T, S>> stack2 = stack.pop();\n        if (stack2.isEmpty())\n            stack = stack2;\n        else {\n            NodePosition<T, S> previous = stack2.peek();\n            stack = stack2.pop().push(previous.nextPosition());\n        }\n        return stack;\n    }\n\n}", "definition": "final class Backpressure", "class_docstring": "\nUtility methods for controlling backpressure of the tree search.\n", "name": "Backpressure", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "fields": [], "classes": [{"original_string": "    private static class StackAndRequest<T> {\n        private final ImmutableStack<T> stack;\n        private final long request;\n\n        StackAndRequest(ImmutableStack<T> stack, long request) {\n            this.stack = stack;\n            this.request = request;\n        }\n\n        static <T> StackAndRequest<T> create(ImmutableStack<T> stack, long request) {\n            return new StackAndRequest<T>(stack, request);\n        }\n\n    }", "definition": "    private static class StackAndRequest<T>", "class_docstring": "", "name": "StackAndRequest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "fields": [{"attribute_expression": "private final ImmutableStack<T> stack;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "ImmutableStack<T>", "name": "stack", "syntax_pass": true}, {"attribute_expression": "private final long request;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "long", "name": "request", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        StackAndRequest(ImmutableStack<T> stack, long request) {\n            this.stack = stack;\n            this.request = request;\n        }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "StackAndRequest", "params": [{"name": "stack", "type": "ImmutableStack<T>"}, {"name": "request", "type": "long"}], "body": "                                                               {\n            this.stack = stack;\n            this.request = request;\n        }", "signature": "StackAndRequest(ImmutableStack<T> stack, long request)"}, {"syntax_pass": true, "original_string": "        static <T> StackAndRequest<T> create(ImmutableStack<T> stack, long request) {\n            return new StackAndRequest<T>(stack, request);\n        }", "docstring": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "StackAndRequest<T>", "classes": []}, "name": "create", "params": [{"name": "stack", "type": "ImmutableStack<T>"}, {"name": "request", "type": "long"}], "body": "                                                                                    {\n            return new StackAndRequest<T>(stack, request);\n        }", "signature": "static <T> StackAndRequest<T> create(ImmutableStack<T> stack, long request)"}]}]}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    private Backpressure() {\n        // prevent instantiation\n    }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "", "classes": []}, "name": "Backpressure", "params": [], "body": "                           {\n        // prevent instantiation\n    }", "signature": "private Backpressure()"}, {"syntax_pass": true, "original_string": "    static <T, S extends Geometry> ImmutableStack<NodePosition<T, S>> search(\n            final Func1<? super Geometry, Boolean> condition,\n            final Subscriber<? super Entry<T, S>> subscriber,\n            final ImmutableStack<NodePosition<T, S>> stack, final long request) {\n        StackAndRequest<NodePosition<T, S>> state = StackAndRequest.create(stack, request);\n        return searchAndReturnStack(condition, subscriber, state);\n    }", "docstring": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "ImmutableStack<NodePosition<T, S>>", "classes": []}, "name": "search", "params": [{"name": "condition", "type": "Func1<? super Geometry, Boolean>"}, {"name": "subscriber", "type": "Subscriber<? super Entry<T, S>>"}, {"name": "stack", "type": "ImmutableStack<NodePosition<T, S>>"}, {"name": "request", "type": "long"}], "body": "                                                                                {\n        StackAndRequest<NodePosition<T, S>> state = StackAndRequest.create(stack, request);\n        return searchAndReturnStack(condition, subscriber, state);\n    }", "signature": "static <T, S extends Geometry> ImmutableStack<NodePosition<T, S>> search(\n            final Func1<? super Geometry, Boolean> condition,\n            final Subscriber<? super Entry<T, S>> subscriber,\n            final ImmutableStack<NodePosition<T, S>> stack, final long request)"}, {"syntax_pass": true, "original_string": "    private static <S extends Geometry, T> ImmutableStack<NodePosition<T, S>> searchAndReturnStack(\n            final Func1<? super Geometry, Boolean> condition,\n            final Subscriber<? super Entry<T, S>> subscriber,\n            StackAndRequest<NodePosition<T, S>> state) {\n\n        while (!state.stack.isEmpty()) {\n            NodePosition<T, S> np = state.stack.peek();\n            if (subscriber.isUnsubscribed())\n                return ImmutableStack.empty();\n            else if (state.request <= 0)\n                return state.stack;\n            else if (np.position() == np.node().count()) {\n                // handle after last in node\n                state = StackAndRequest.create(searchAfterLastInNode(state.stack), state.request);\n            } else if (np.node() instanceof NonLeaf) {\n                // handle non-leaf\n                state = StackAndRequest.create(searchNonLeaf(condition, state.stack, np),\n                        state.request);\n            } else {\n                // handle leaf\n                state = searchLeaf(condition, subscriber, state, np);\n            }\n        }\n        return state.stack;\n    }", "docstring": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "ImmutableStack<NodePosition<T, S>>", "classes": []}, "name": "searchAndReturnStack", "params": [{"name": "condition", "type": "Func1<? super Geometry, Boolean>"}, {"name": "subscriber", "type": "Subscriber<? super Entry<T, S>>"}, {"name": "state", "type": "StackAndRequest<NodePosition<T, S>>"}], "body": "                                                       {\n\n        while (!state.stack.isEmpty()) {\n            NodePosition<T, S> np = state.stack.peek();\n            if (subscriber.isUnsubscribed())\n                return ImmutableStack.empty();\n            else if (state.request <= 0)\n                return state.stack;\n            else if (np.position() == np.node().count()) {\n                // handle after last in node\n                state = StackAndRequest.create(searchAfterLastInNode(state.stack), state.request);\n            } else if (np.node() instanceof NonLeaf) {\n                // handle non-leaf\n                state = StackAndRequest.create(searchNonLeaf(condition, state.stack, np),\n                        state.request);\n            } else {\n                // handle leaf\n                state = searchLeaf(condition, subscriber, state, np);\n            }\n        }\n        return state.stack;\n    }", "signature": "private static <S extends Geometry, T> ImmutableStack<NodePosition<T, S>> searchAndReturnStack(\n            final Func1<? super Geometry, Boolean> condition,\n            final Subscriber<? super Entry<T, S>> subscriber,\n            StackAndRequest<NodePosition<T, S>> state)"}, {"syntax_pass": true, "original_string": "    private static <T, S extends Geometry> StackAndRequest<NodePosition<T, S>> searchLeaf(\n            final Func1<? super Geometry, Boolean> condition,\n            final Subscriber<? super Entry<T, S>> subscriber,\n            StackAndRequest<NodePosition<T, S>> state, NodePosition<T, S> np) {\n        final long nextRequest;\n        Entry<T, S> entry = ((Leaf<T, S>) np.node()).entry(np.position());\n        if (condition.call(entry.geometry())) {\n            subscriber.onNext(entry);\n            nextRequest = state.request - 1;\n        } else\n            nextRequest = state.request;\n        return StackAndRequest.create(state.stack.pop().push(np.nextPosition()), nextRequest);\n    }", "docstring": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "StackAndRequest<NodePosition<T, S>>", "classes": []}, "name": "searchLeaf", "params": [{"name": "condition", "type": "Func1<? super Geometry, Boolean>"}, {"name": "subscriber", "type": "Subscriber<? super Entry<T, S>>"}, {"name": "state", "type": "StackAndRequest<NodePosition<T, S>>"}, {"name": "np", "type": "NodePosition<T, S>"}], "body": "                                                                              {\n        final long nextRequest;\n        Entry<T, S> entry = ((Leaf<T, S>) np.node()).entry(np.position());\n        if (condition.call(entry.geometry())) {\n            subscriber.onNext(entry);\n            nextRequest = state.request - 1;\n        } else\n            nextRequest = state.request;\n        return StackAndRequest.create(state.stack.pop().push(np.nextPosition()), nextRequest);\n    }", "signature": "private static <T, S extends Geometry> StackAndRequest<NodePosition<T, S>> searchLeaf(\n            final Func1<? super Geometry, Boolean> condition,\n            final Subscriber<? super Entry<T, S>> subscriber,\n            StackAndRequest<NodePosition<T, S>> state, NodePosition<T, S> np)"}, {"syntax_pass": true, "original_string": "    private static <S extends Geometry, T> ImmutableStack<NodePosition<T, S>> searchNonLeaf(\n            final Func1<? super Geometry, Boolean> condition,\n            ImmutableStack<NodePosition<T, S>> stack, NodePosition<T, S> np) {\n        Node<T, S> child = ((NonLeaf<T, S>) np.node()).child(np.position());\n        if (condition.call(child.geometry())) {\n            stack = stack.push(new NodePosition<T, S>(child, 0));\n        } else {\n            stack = stack.pop().push(np.nextPosition());\n        }\n        return stack;\n    }", "docstring": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "ImmutableStack<NodePosition<T, S>>", "classes": []}, "name": "searchNonLeaf", "params": [{"name": "condition", "type": "Func1<? super Geometry, Boolean>"}, {"name": "stack", "type": "ImmutableStack<NodePosition<T, S>>"}, {"name": "np", "type": "NodePosition<T, S>"}], "body": "                                                                             {\n        Node<T, S> child = ((NonLeaf<T, S>) np.node()).child(np.position());\n        if (condition.call(child.geometry())) {\n            stack = stack.push(new NodePosition<T, S>(child, 0));\n        } else {\n            stack = stack.pop().push(np.nextPosition());\n        }\n        return stack;\n    }", "signature": "private static <S extends Geometry, T> ImmutableStack<NodePosition<T, S>> searchNonLeaf(\n            final Func1<? super Geometry, Boolean> condition,\n            ImmutableStack<NodePosition<T, S>> stack, NodePosition<T, S> np)"}, {"syntax_pass": true, "original_string": "    private static <S extends Geometry, T> ImmutableStack<NodePosition<T, S>> searchAfterLastInNode(\n            ImmutableStack<NodePosition<T, S>> stack) {\n        ImmutableStack<NodePosition<T, S>> stack2 = stack.pop();\n        if (stack2.isEmpty())\n            stack = stack2;\n        else {\n            NodePosition<T, S> previous = stack2.peek();\n            stack = stack2.pop().push(previous.nextPosition());\n        }\n        return stack;\n    }", "docstring": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "ImmutableStack<NodePosition<T, S>>", "classes": []}, "name": "searchAfterLastInNode", "params": [{"name": "stack", "type": "ImmutableStack<NodePosition<T, S>>"}], "body": "                                                      {\n        ImmutableStack<NodePosition<T, S>> stack2 = stack.pop();\n        if (stack2.isEmpty())\n            stack = stack2;\n        else {\n            NodePosition<T, S> previous = stack2.peek();\n            stack = stack2.pop().push(previous.nextPosition());\n        }\n        return stack;\n    }", "signature": "private static <S extends Geometry, T> ImmutableStack<NodePosition<T, S>> searchAfterLastInNode(\n            ImmutableStack<NodePosition<T, S>> stack)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/com/github/davidmoten/rtree/Node.java", "original_string": "package com.github.davidmoten.rtree;\n\nimport java.util.List;\n\nimport com.github.davidmoten.rtree.geometry.Geometry;\nimport com.github.davidmoten.rtree.geometry.HasGeometry;\nimport com.github.davidmoten.rtree.internal.NodeAndEntries;\n\nimport rx.Subscriber;\nimport rx.functions.Func1;\n\npublic interface Node<T, S extends Geometry> extends HasGeometry {\n\n    List<Node<T, S>> add(Entry<? extends T, ? extends S> entry);\n\n    NodeAndEntries<T, S> delete(Entry<? extends T, ? extends S> entry, boolean all);\n\n    /**\n     * Run when a search requests Long.MAX_VALUE results. This is the\n     * no-backpressure fast path.\n     * \n     * @param criterion\n     *            function that returns true if the geometry is a search match\n     * @param subscriber\n     *            the subscriber to report search findings to\n     */\n    void searchWithoutBackpressure(Func1<? super Geometry, Boolean> criterion,\n            Subscriber<? super Entry<T, S>> subscriber);\n\n    int count();\n\n    Context<T, S> context();\n\n}\n", "file_hash": "7387ab7e1eccf57af09275e3d4a084150f6b880e631b3fe8bc9b17ae1ca7efaa", "file_docstring": "", "contexts": ["package com.github.davidmoten.rtree;", "import java.util.List;", "import com.github.davidmoten.rtree.geometry.Geometry;", "import com.github.davidmoten.rtree.geometry.HasGeometry;", "import com.github.davidmoten.rtree.internal.NodeAndEntries;", "import rx.Subscriber;", "import rx.functions.Func1;"], "methods": [], "classes": [], "interfaces": [{"original_string": "public interface Node<T, S extends Geometry> extends HasGeometry {\n\n    List<Node<T, S>> add(Entry<? extends T, ? extends S> entry);\n\n    NodeAndEntries<T, S> delete(Entry<? extends T, ? extends S> entry, boolean all);\n\n    /**\n     * Run when a search requests Long.MAX_VALUE results. This is the\n     * no-backpressure fast path.\n     * \n     * @param criterion\n     *            function that returns true if the geometry is a search match\n     * @param subscriber\n     *            the subscriber to report search findings to\n     */\n    void searchWithoutBackpressure(Func1<? super Geometry, Boolean> criterion,\n            Subscriber<? super Entry<T, S>> subscriber);\n\n    int count();\n\n    Context<T, S> context();\n\n}", "definition": "public interface Node<T, S extends Geometry> extends HasGeometry", "interface_docstring": "", "name": "Node", "extends_interfaces": ["HasGeometry"], "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    List<Node<T, S>> add(Entry<? extends T, ? extends S> entry);", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "List<Node<T, S>>", "classes": []}, "name": "add", "params": [{"name": "entry", "type": "Entry<? extends T, ? extends S>"}], "body": "", "signature": "List<Node<T, S>> add(Entry<? extends T, ? extends S> entry)"}, {"syntax_pass": true, "original_string": "    NodeAndEntries<T, S> delete(Entry<? extends T, ? extends S> entry, boolean all);", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "NodeAndEntries<T, S>", "classes": []}, "name": "delete", "params": [{"name": "entry", "type": "Entry<? extends T, ? extends S>"}, {"name": "all", "type": "boolean"}], "body": "", "signature": "NodeAndEntries<T, S> delete(Entry<? extends T, ? extends S> entry, boolean all)"}, {"syntax_pass": true, "original_string": "    void searchWithoutBackpressure(Func1<? super Geometry, Boolean> criterion,\n            Subscriber<? super Entry<T, S>> subscriber);", "docstring": "\nRun when a search requests Long.MAX_VALUE results. This is the\nno-backpressure fast path.\n\n@param criterion\n           function that returns true if the geometry is a search match\n@param subscriber\n           the subscriber to report search findings to\n", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "name": "searchWithoutBackpressure", "params": [{"name": "criterion", "type": "Func1<? super Geometry, Boolean>"}, {"name": "subscriber", "type": "Subscriber<? super Entry<T, S>>"}], "body": "", "signature": "void searchWithoutBackpressure(Func1<? super Geometry, Boolean> criterion,\n            Subscriber<? super Entry<T, S>> subscriber)"}, {"syntax_pass": true, "original_string": "    int count();", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "int", "classes": []}, "name": "count", "params": [], "body": "", "signature": "int count()"}, {"syntax_pass": true, "original_string": "    Context<T, S> context();", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "Context<T, S>", "classes": []}, "name": "context", "params": [], "body": "", "signature": "Context<T, S> context()"}]}], "records": []}, {"relative_path": "src/main/java/com/github/davidmoten/rtree/Entry.java", "original_string": "package com.github.davidmoten.rtree;\n\nimport com.github.davidmoten.rtree.geometry.Geometry;\nimport com.github.davidmoten.rtree.geometry.HasGeometry;\n\npublic interface Entry<T, S extends Geometry> extends HasGeometry {\n\n    T value();\n\n    @Override\n    S geometry();\n\n}", "file_hash": "9436bf412ffdae3e1f50129fbdd505dd2abbe1b58d1f03cbefab9d90bcacc3cb", "file_docstring": "", "contexts": ["package com.github.davidmoten.rtree;", "import com.github.davidmoten.rtree.geometry.Geometry;", "import com.github.davidmoten.rtree.geometry.HasGeometry;"], "methods": [], "classes": [], "interfaces": [{"original_string": "public interface Entry<T, S extends Geometry> extends HasGeometry {\n\n    T value();\n\n    @Override\n    S geometry();\n\n}", "definition": "public interface Entry<T, S extends Geometry> extends HasGeometry", "interface_docstring": "", "name": "Entry", "extends_interfaces": ["HasGeometry"], "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    T value();", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "T", "classes": []}, "name": "value", "params": [], "body": "", "signature": "T value()"}, {"syntax_pass": true, "original_string": "    @Override\n    S geometry();", "docstring": "", "attributes": {"modifiers": "@Override", "marker_annotations": ["@Override"], "non_marker_annotations": [], "comments": [], "return_type": "S", "classes": []}, "name": "geometry", "params": [], "body": "", "signature": "@Override\n    S geometry()"}]}], "records": []}, {"relative_path": "src/main/java/com/github/davidmoten/rtree/RTree.java", "original_string": "package com.github.davidmoten.rtree;\n\nimport static com.github.davidmoten.rtree.geometry.Geometries.rectangle;\nimport static java.util.Optional.of;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.List;\nimport java.util.Optional;\n\nimport com.github.davidmoten.guavamini.Lists;\nimport com.github.davidmoten.guavamini.annotations.VisibleForTesting;\nimport com.github.davidmoten.rtree.geometry.Circle;\nimport com.github.davidmoten.rtree.geometry.Geometry;\nimport com.github.davidmoten.rtree.geometry.HasGeometry;\nimport com.github.davidmoten.rtree.geometry.Intersects;\nimport com.github.davidmoten.rtree.geometry.Line;\nimport com.github.davidmoten.rtree.geometry.Point;\nimport com.github.davidmoten.rtree.geometry.Rectangle;\nimport com.github.davidmoten.rtree.internal.Comparators;\nimport com.github.davidmoten.rtree.internal.NodeAndEntries;\nimport com.github.davidmoten.rtree.internal.operators.OperatorBoundedPriorityQueue;\n\nimport rx.Observable;\nimport rx.functions.Func1;\nimport rx.functions.Func2;\n\n/**\n * Immutable in-memory 2D R-Tree with configurable splitter heuristic.\n *\n * @param <T>\n *            the entry value type\n * @param <S>\n *            the entry geometry type\n */\npublic final class RTree<T, S extends Geometry> {\n\n    public static final Rectangle ZERO_RECTANGLE = rectangle(0, 0, 0, 0);\n    private final Optional<? extends Node<T, S>> root;\n    private final Context<T, S> context;\n\n    /**\n     * Benchmarks show that this is a good choice for up to O(10,000) entries when\n     * using Quadratic splitter (Guttman).\n     */\n    public static final int MAX_CHILDREN_DEFAULT_GUTTMAN = 4;\n\n    /**\n     * Benchmarks show that this is the sweet spot for up to O(10,000) entries when\n     * using R*-tree heuristics.\n     */\n    public static final int MAX_CHILDREN_DEFAULT_STAR = 4;\n\n    /**\n     * Current size in Entries of the RTree.\n     */\n    private final int size;\n    private static final Func2<Optional<Rectangle>, Entry<Object, Geometry>, Optional<Rectangle>> RECTANGLE_ACCUMULATOR =\n            (rectangle, entry) ->\n                    rectangle.map(value -> Optional.of(value.add(entry.geometry().mbr())))\n                            .orElseGet(() -> Optional.of(entry.geometry().mbr()));\n\n    /**\n     * Constructor.\n     *\n     * @param root\n     *            the root node of the tree if present\n     * @param context\n     *            options for the R-tree\n     */\n    private RTree(Optional<? extends Node<T, S>> root, int size, Context<T, S> context) {\n        this.root = root;\n        this.size = size;\n        this.context = context;\n    }\n\n    private RTree() {\n        this(Optional.empty(), 0, null);\n    }\n\n    /**\n     * Constructor.\n     * \n     * @param root\n     *            the root node of the R-tree\n     * @param context\n     *            options for the R-tree\n     */\n    private RTree(Node<T, S> root, int size, Context<T, S> context) {\n        this(of(root), size, context);\n    }\n\n    static <T, S extends Geometry> RTree<T, S> create(Optional<? extends Node<T, S>> root, int size,\n            Context<T, S> context) {\n        return new RTree<T, S>(root, size, context);\n    }\n\n    /**\n     * Returns a new Builder instance for {@link RTree}. Defaults to\n     * maxChildren=128, minChildren=64, splitter=QuadraticSplitter.\n     * \n     * @param <T>\n     *            the value type of the entries in the tree\n     * @param <S>\n     *            the geometry type of the entries in the tree\n     * @return a new RTree instance\n     */\n    public static <T, S extends Geometry> RTree<T, S> create() {\n        return new Builder().create();\n    }\n\n    /**\n     * Construct an Rtree through STR bulk loading. Default to maxChildren=128,\n     * minChildren=64 and fill nodes by a factor of 0.7\n     * \n     * @param entries\n     *            entries to add to the R-tree\n     *\n     * @param <T>\n     *            the value type of the entries in the tree\n     * @param <S>\n     *            the geometry type of the entries in the tree\n     * @return a new RTree instance\n     */\n    public static <T, S extends Geometry> RTree<T, S> create(List<Entry<T, S>> entries) {\n        return new Builder().create(entries);\n    }\n\n    /**\n     * The tree is scanned for depth and the depth returned. This involves recursing\n     * down to the leaf level of the tree to get the current depth. Should be\n     * <code>log(n)</code> in complexity.\n     * \n     * @return depth of the R-tree\n     */\n    public int calculateDepth() {\n        return calculateDepth(root);\n    }\n\n    private static <T, S extends Geometry> int calculateDepth(Optional<? extends Node<T, S>> root) {\n        return root.map(node -> calculateDepth(node, 0)).orElse(0);\n    }\n\n    private static <T, S extends Geometry> int calculateDepth(Node<T, S> node, int depth) {\n        if (node instanceof Leaf) {\n            return depth + 1;\n        } else {\n            return calculateDepth(((NonLeaf<T, S>) node).child(0), depth + 1);\n        }\n    }\n\n    /**\n     * When the number of children in an R-tree node drops below this number the\n     * node is deleted and the children are added on to the R-tree again.\n     * \n     * @param minChildren\n     *            less than this number of children in a node triggers a node\n     *            deletion and redistribution of its members\n     * @return builder\n     */\n    public static Builder minChildren(int minChildren) {\n        return new Builder().minChildren(minChildren);\n    }\n\n    /**\n     * Sets the max number of children in an R-tree node.\n     * \n     * @param maxChildren\n     *            max number of children in an R-tree node\n     * @return builder\n     */\n    public static Builder maxChildren(int maxChildren) {\n        return new Builder().maxChildren(maxChildren);\n    }\n\n    /**\n     * Sets the {@link Splitter} to use when maxChildren is reached.\n     * \n     * @param splitter\n     *            the splitter algorithm to use\n     * @return builder\n     */\n    public static Builder splitter(Splitter splitter) {\n        return new Builder().splitter(splitter);\n    }\n\n    /**\n     * Sets the node {@link Selector} which decides which branches to follow when\n     * inserting or searching.\n     * \n     * @param selector\n     *            determines which branches to follow when inserting or searching\n     * @return builder\n     */\n    public static Builder selector(Selector selector) {\n        return new Builder().selector(selector);\n    }\n\n    /**\n     * Sets the splitter to {@link SplitterRStar} and selector to\n     * {@link SelectorRStar} and defaults to minChildren=10.\n     * \n     * @return builder\n     */\n    public static Builder star() {\n        return new Builder().star();\n    }\n\n    /**\n     * RTree Builder.\n     */\n    public static class Builder {\n\n        /**\n         * According to http://dbs.mathematik.uni-marburg.de/publications/myPapers\n         * /1990/BKSS90.pdf (R*-tree paper), best filling ratio is 0.4 for both\n         * quadratic split and R*-tree split.\n         */\n        private static final double DEFAULT_FILLING_FACTOR = 0.4;\n        private static final double DEFAULT_LOADING_FACTOR = 0.7;\n        private Optional<Integer> maxChildren = Optional.empty();\n        private Optional<Integer> minChildren = Optional.empty();\n        private Splitter splitter = new SplitterQuadratic();\n        private Selector selector = new SelectorMinimalAreaIncrease();\n        private double loadingFactor;\n        private boolean star = false;\n        private Factory<Object, Geometry> factory = Factories.defaultFactory();\n\n        private Builder() {\n            loadingFactor = DEFAULT_LOADING_FACTOR;\n        }\n\n        /**\n         * The factor is used as the fill ratio during bulk loading.\n         * \n         * @param factor\n         *            loading factor\n         * @return this\n         */\n        public Builder loadingFactor(double factor) {\n            this.loadingFactor = factor;\n            return this;\n        }\n\n        /**\n         * When the number of children in an R-tree node drops below this number the\n         * node is deleted and the children are added on to the R-tree again.\n         * \n         * @param minChildren\n         *            less than this number of children in a node triggers a\n         *            redistribution of its children.\n         * @return builder\n         */\n        public Builder minChildren(int minChildren) {\n            this.minChildren = of(minChildren);\n            return this;\n        }\n\n        /**\n         * Sets the max number of children in an R-tree node.\n         * \n         * @param maxChildren\n         *            max number of children in R-tree node.\n         * @return builder\n         */\n        public Builder maxChildren(int maxChildren) {\n            this.maxChildren = of(maxChildren);\n            return this;\n        }\n\n        /**\n         * Sets the {@link Splitter} to use when maxChildren is reached.\n         * \n         * @param splitter\n         *            node splitting method to use\n         * @return builder\n         */\n        public Builder splitter(Splitter splitter) {\n            this.splitter = splitter;\n            return this;\n        }\n\n        /**\n         * Sets the node {@link Selector} which decides which branches to follow when\n         * inserting or searching.\n         * \n         * @param selector\n         *            selects the branch to follow when inserting or searching\n         * @return builder\n         */\n        public Builder selector(Selector selector) {\n            this.selector = selector;\n            return this;\n        }\n\n        /**\n         * Sets the splitter to {@link SplitterRStar} and selector to\n         * {@link SelectorRStar} and defaults to minChildren=10.\n         * \n         * @return builder\n         */\n        public Builder star() {\n            selector = new SelectorRStar();\n            splitter = new SplitterRStar();\n            star = true;\n            return this;\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        public Builder factory(Factory<?, ? extends Geometry> factory) {\n            // TODO could change the signature of Builder to have types to\n            // support this method but would be breaking change for existing\n            // clients\n            this.factory = (Factory<Object, Geometry>) factory;\n            return this;\n        }\n\n        /**\n         * Builds the {@link RTree}.\n         * \n         * @param <T>\n         *            value type\n         * @param <S>\n         *            geometry type\n         * @return RTree\n         */\n        @SuppressWarnings(\"unchecked\")\n        public <T, S extends Geometry> RTree<T, S> create() {\n            setDefaultCapacity();\n\n            return new RTree<T, S>(Optional.<Node<T, S>>empty(), 0,\n                    new Context<T, S>(minChildren.get(), maxChildren.get(), selector, splitter,\n                            (Factory<T, S>) factory));\n        }\n\n        /**\n         * Create an RTree by bulk loading, using the STR method. STR: a simple and\n         * efficient algorithm for R-tree packing\n         * http://ieeexplore.ieee.org/abstract/document/582015/\n         * <p>\n         * Note: this method mutates the input entries, the internal order of the List\n         * may be changed.\n         * </p>\n         * \n         * @param entries\n         *            entries to be added to the r-tree\n         * @return a loaded RTree\n         */\n        @SuppressWarnings(\"unchecked\")\n        public <T, S extends Geometry> RTree<T, S> create(List<Entry<T, S>> entries) {\n            setDefaultCapacity();\n\n            Context<T, S> context = new Context<T, S>(minChildren.get(), maxChildren.get(),\n                    selector, splitter, (Factory<T, S>) factory);\n            return packingSTR(entries, true, entries.size(), context);\n        }\n\n        private void setDefaultCapacity() {\n            if (!maxChildren.isPresent()) {\n                if (star) {\n                    maxChildren = Optional.of(MAX_CHILDREN_DEFAULT_STAR);\n                } else {\n                    maxChildren = Optional.of(MAX_CHILDREN_DEFAULT_GUTTMAN);\n                }\n            }\n            if (!minChildren.isPresent()) {\n                minChildren = Optional.of((int) Math.round(maxChildren.get() * DEFAULT_FILLING_FACTOR));\n            }\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        private <T, S extends Geometry> RTree<T, S> packingSTR(List<? extends HasGeometry> objects,\n                boolean isLeaf, int size, Context<T, S> context) {\n            int capacity = (int) Math.round(maxChildren.get() * loadingFactor);\n            int nodeCount = (int) Math.ceil(1.0 * objects.size() / capacity);\n\n            if (nodeCount == 0) {\n                return create();\n            } else if (nodeCount == 1) {\n                Node<T, S> root;\n                if (isLeaf) {\n                    root = context.factory().createLeaf((List<Entry<T, S>>) objects, context);\n                } else {\n                    root = context.factory().createNonLeaf((List<Node<T, S>>) objects, context);\n                }\n                return new RTree<T, S>(of(root), size, context);\n            }\n\n            int nodePerSlice = (int) Math.ceil(Math.sqrt(nodeCount));\n            int sliceCapacity = nodePerSlice * capacity;\n            int sliceCount = (int) Math.ceil(1.0 * objects.size() / sliceCapacity);\n            Collections.sort(objects, new MidComparator((short) 0));\n\n            List<Node<T, S>> nodes = new ArrayList<Node<T, S>>(nodeCount);\n            for (int s = 0; s < sliceCount; s++) {\n                @SuppressWarnings(\"rawtypes\")\n                List slice = objects.subList(s * sliceCapacity,\n                        Math.min((s + 1) * sliceCapacity, objects.size()));\n                Collections.sort(slice, new MidComparator((short) 1));\n\n                for (int i = 0; i < slice.size(); i += capacity) {\n                    if (isLeaf) {\n                        List<Entry<T, S>> entries = slice.subList(i,\n                                Math.min(slice.size(), i + capacity));\n                        Node<T, S> leaf = context.factory().createLeaf(entries, context);\n                        nodes.add(leaf);\n                    } else {\n                        List<Node<T, S>> children = slice.subList(i,\n                                Math.min(slice.size(), i + capacity));\n                        Node<T, S> nonleaf = context.factory().createNonLeaf(children, context);\n                        nodes.add(nonleaf);\n                    }\n                }\n            }\n            return packingSTR(nodes, false, size, context);\n        }\n\n        private static final class MidComparator implements Comparator<HasGeometry> {\n            private final short dimension; // leave space for multiple dimensions, 0 for x, 1 for y,\n                                           // ...\n\n            public MidComparator(short dim) {\n                dimension = dim;\n            }\n\n            @Override\n            public int compare(HasGeometry o1, HasGeometry o2) {\n                return Double.compare(mid(o1), mid(o2));\n            }\n\n            private double mid(HasGeometry o) {\n                Rectangle mbr = o.geometry().mbr();\n                if (dimension == 0)\n                    return (mbr.x1() + mbr.x2()) / 2;\n                else\n                    return (mbr.y1() + mbr.y2()) / 2;\n            }\n        }\n\n    }\n\n    /**\n     * Returns an immutable copy of the RTree with the addition of given entry.\n     * \n     * @param entry\n     *            item to add to the R-tree.\n     * @return a new immutable R-tree including the new entry\n     */\n    @SuppressWarnings(\"unchecked\")\n    public RTree<T, S> add(Entry<? extends T, ? extends S> entry) {\n        if (root.isPresent()) {\n            List<Node<T, S>> nodes = root.get().add(entry);\n            Node<T, S> node;\n            if (nodes.size() == 1)\n                node = nodes.get(0);\n            else {\n                node = context.factory().createNonLeaf(nodes, context);\n            }\n            return new RTree<T, S>(node, size + 1, context);\n        } else {\n            Leaf<T, S> node = context.factory().createLeaf(Lists.newArrayList((Entry<T, S>) entry),\n                    context);\n            return new RTree<T, S>(node, size + 1, context);\n        }\n    }\n\n    /**\n     * Returns an immutable copy of the RTree with the addition of an entry\n     * comprised of the given value and Geometry.\n     * \n     * @param value\n     *            the value of the {@link Entry} to be added\n     * @param geometry\n     *            the geometry of the {@link Entry} to be added\n     * @return a new immutable R-tree including the new entry\n     */\n    public RTree<T, S> add(T value, S geometry) {\n        return add(context.factory().createEntry(value, geometry));\n    }\n\n    /**\n     * Returns an immutable RTree with the current entries and the additional\n     * entries supplied as a parameter.\n     * \n     * @param entries\n     *            entries to add\n     * @return R-tree with entries added\n     */\n    public RTree<T, S> add(Iterable<Entry<T, S>> entries) {\n        RTree<T, S> tree = this;\n        for (Entry<T, S> entry : entries)\n            tree = tree.add(entry);\n        return tree;\n    }\n\n    /**\n     * Returns the Observable sequence of trees created by progressively adding\n     * entries.\n     * \n     * @param entries\n     *            the entries to add\n     * @return a sequence of trees\n     */\n    public Observable<RTree<T, S>> add(Observable<Entry<T, S>> entries) {\n        return entries.scan(this, (tree, entry) -> tree.add(entry));\n    }\n\n    /**\n     * Returns the Observable sequence of trees created by progressively deleting\n     * entries.\n     * \n     * @param entries\n     *            the entries to add\n     * @param all\n     *            if true delete all matching otherwise just first matching\n     * @return a sequence of trees\n     */\n    public Observable<RTree<T, S>> delete(Observable<Entry<T, S>> entries, final boolean all) {\n        return entries.scan(this, new Func2<RTree<T, S>, Entry<T, S>, RTree<T, S>>() {\n\n            @Override\n            public RTree<T, S> call(RTree<T, S> tree, Entry<T, S> entry) {\n                return tree.delete(entry, all);\n            }\n        });\n    }\n\n    /**\n     * Returns a new R-tree with the given entries deleted. If <code>all</code> is\n     * false deletes only one if exists. If <code>all</code> is true deletes all\n     * matching entries.\n     * \n     * @param entries\n     *            entries to delete\n     * @param all\n     *            if false deletes one if exists else deletes all\n     * @return R-tree with entries deleted\n     */\n    public RTree<T, S> delete(Iterable<Entry<T, S>> entries, boolean all) {\n        RTree<T, S> tree = this;\n        for (Entry<T, S> entry : entries)\n            tree = tree.delete(entry, all);\n        return tree;\n    }\n\n    /**\n     * Returns a new R-tree with the given entries deleted but only one matching\n     * occurence of each entry is deleted.\n     * \n     * @param entries\n     *            entries to delete\n     * @return R-tree with entries deleted up to one matching occurence per entry\n     */\n    public RTree<T, S> delete(Iterable<Entry<T, S>> entries) {\n        RTree<T, S> tree = this;\n        for (Entry<T, S> entry : entries)\n            tree = tree.delete(entry);\n        return tree;\n    }\n\n    /**\n     * If <code>all</code> is false deletes one entry matching the given value and\n     * Geometry. If <code>all</code> is true deletes all entries matching the given\n     * value and geometry. This method has no effect if the entry is not present.\n     * The entry must match on both value and geometry to be deleted.\n     * \n     * @param value\n     *            the value of the {@link Entry} to be deleted\n     * @param geometry\n     *            the geometry of the {@link Entry} to be deleted\n     * @param all\n     *            if false deletes one if exists else deletes all\n     * @return a new immutable R-tree without one or many instances of the specified\n     *         entry if it exists otherwise returns the original RTree object\n     */\n    public RTree<T, S> delete(T value, S geometry, boolean all) {\n        return delete(context.factory().createEntry(value, geometry), all);\n    }\n\n    /**\n     * Deletes maximum one entry matching the given value and geometry. This method\n     * has no effect if the entry is not present. The entry must match on both value\n     * and geometry to be deleted.\n     * \n     * @param value\n     *            the value to be matched for deletion\n     * @param geometry\n     *            the geometry to be matched for deletion\n     * @return an immutable RTree without one entry (if found) matching the given\n     *         value and geometry\n     */\n    public RTree<T, S> delete(T value, S geometry) {\n        return delete(context.factory().createEntry(value, geometry), false);\n    }\n\n    /**\n     * Deletes one or all matching entries depending on the value of\n     * <code>all</code>. If multiple copies of the entry are in the R-tree only one\n     * will be deleted if all is false otherwise all matching entries will be\n     * deleted. The entry must match on both value and geometry to be deleted.\n     * \n     * @param entry\n     *            the {@link Entry} to be deleted\n     * @param all\n     *            if true deletes all matches otherwise deletes first found\n     * @return a new immutable R-tree without one instance of the specified entry\n     */\n    public RTree<T, S> delete(Entry<? extends T, ? extends S> entry, boolean all) {\n        if (root.isPresent()) {\n            NodeAndEntries<T, S> nodeAndEntries = root.get().delete(entry, all);\n            if (nodeAndEntries.node().isPresent() && nodeAndEntries.node().get() == root.get())\n                return this;\n            else\n                return new RTree<T, S>(nodeAndEntries.node(),\n                        size - nodeAndEntries.countDeleted() - nodeAndEntries.entriesToAdd().size(),\n                        context).add(nodeAndEntries.entriesToAdd());\n        } else\n            return this;\n    }\n\n    /**\n     * Deletes one entry if it exists, returning an immutable copy of the RTree\n     * without that entry. If multiple copies of the entry are in the R-tree only\n     * one will be deleted. The entry must match on both value and geometry to be\n     * deleted.\n     * \n     * @param entry\n     *            the {@link Entry} to be deleted\n     * @return a new immutable R-tree without one instance of the specified entry\n     */\n    public RTree<T, S> delete(Entry<? extends T, ? extends S> entry) {\n        return delete(entry, false);\n    }\n\n    /**\n     * <p>\n     * Returns an Observable sequence of {@link Entry} that satisfy the given\n     * condition. Note that this method is well-behaved only if:\n     *\n     * \n     * <p>\n     * {@code condition(g)} is true for {@link Geometry} g implies\n     * {@code condition(r)} is true for the minimum bounding rectangles of the\n     * ancestor nodes.\n     * \n     * <p>\n     * {@code distance(g) < D} is an example of such a condition.\n     * \n     * \n     * @param condition\n     *            return Entries whose geometry satisfies the given condition\n     * @return sequence of matching entries\n     */\n    @VisibleForTesting\n    Observable<Entry<T, S>> search(Func1<? super Geometry, Boolean> condition) {\n        return root\n                .map(node -> Observable.unsafeCreate(new OnSubscribeSearch<>(node, condition)))\n                .orElseGet(Observable::empty);\n    }\n\n    /**\n     * Returns a predicate function that indicates if {@link Geometry} intersects\n     * with a given rectangle.\n     * \n     * @param r\n     *            the rectangle to check intersection with\n     * @return whether the geometry and the rectangle intersect\n     */\n    public static Func1<Geometry, Boolean> intersects(final Rectangle r) {\n        return g -> g.intersects(r);\n    }\n\n    /**\n     * Returns the always true predicate. See {@link RTree#entries()} for example\n     * use.\n     */\n    private static final Func1<Geometry, Boolean> ALWAYS_TRUE = rectangle -> true;\n\n    /**\n     * Returns an {@link Observable} sequence of all {@link Entry}s in the R-tree\n     * whose minimum bounding rectangle intersects with the given rectangle.\n     * \n     * @param r\n     *            rectangle to check intersection with the entry mbr\n     * @return entries that intersect with the rectangle r\n     */\n    public Observable<Entry<T, S>> search(final Rectangle r) {\n        return search(intersects(r));\n    }\n\n    /**\n     * Returns an {@link Observable} sequence of all {@link Entry}s in the R-tree\n     * whose minimum bounding rectangle intersects with the given point.\n     * \n     * @param p\n     *            point to check intersection with the entry mbr\n     * @return entries that intersect with the point p\n     */\n    public Observable<Entry<T, S>> search(final Point p) {\n        return search(p.mbr());\n    }\n\n    public Observable<Entry<T, S>> search(Circle circle) {\n        return search(circle, Intersects.geometryIntersectsCircle);\n    }\n\n    public Observable<Entry<T, S>> search(Line line) {\n        return search(line, Intersects.geometryIntersectsLine);\n    }\n\n    /**\n     * Returns an {@link Observable} sequence of all {@link Entry}s in the R-tree\n     * whose minimum bounding rectangles are strictly less than maxDistance from the\n     * given rectangle.\n     * \n     * @param r\n     *            rectangle to measure distance from\n     * @param maxDistance\n     *            entries returned must be within this distance from rectangle r\n     * @return the sequence of matching entries\n     */\n    public Observable<Entry<T, S>> search(final Rectangle r, final double maxDistance) {\n        return search(g -> g.distance(r) < maxDistance);\n    }\n\n    /**\n     * Returns the intersections with the the given (arbitrary) geometry using an\n     * intersection function to filter the search results returned from a search of\n     * the mbr of <code>g</code>.\n     * \n     * @param <R>\n     *            type of geometry being searched for intersection with\n     * @param g\n     *            geometry being searched for intersection with\n     * @param intersects\n     *            function to determine if the two geometries intersect\n     * @return a sequence of entries that intersect with g\n     */\n    public <R extends Geometry> Observable<Entry<T, S>> search(final R g,\n                                                               final Func2<? super S, ? super R, Boolean> intersects) {\n        return search(g.mbr()).filter(entry -> intersects.call(entry.geometry(), g));\n    }\n\n    /**\n     * Returns all entries strictly less than <code>maxDistance</code> from the\n     * given geometry. Because the geometry may be of an arbitrary type it is\n     * necessary to also pass a distance function.\n     * \n     * @param <R>\n     *            type of the geometry being searched for\n     * @param g\n     *            geometry to search for entries within maxDistance of\n     * @param maxDistance\n     *            strict max distance that entries must be from g\n     * @param distance\n     *            function to calculate the distance between geometries of type S\n     *            and R.\n     * @return entries strictly less than maxDistance from g\n     */\n    public <R extends Geometry> Observable<Entry<T, S>> search(final R g, final double maxDistance,\n        final Func2<? super S, ? super R, Double> distance) {\n        // just use the mbr initially\n        return search(entry -> entry.distance(g.mbr()) < maxDistance)\n                // refine with distance function\n                .filter(entry -> distance.call(entry.geometry(), g) < maxDistance);\n    }\n\n    /**\n     * Returns an {@link Observable} sequence of all {@link Entry}s in the R-tree\n     * whose minimum bounding rectangles are within maxDistance from the given\n     * point.\n     * \n     * @param p\n     *            point to measure distance from\n     * @param maxDistance\n     *            entries returned must be within this distance from point p\n     * @return the sequence of matching entries\n     */\n    public Observable<Entry<T, S>> search(final Point p, final double maxDistance) {\n        return search(p.mbr(), maxDistance);\n    }\n\n    /**\n     * Returns the nearest k entries (k=maxCount) to the given rectangle where the\n     * entries are strictly less than a given maximum distance from the rectangle.\n     * \n     * @param r\n     *            rectangle\n     * @param maxDistance\n     *            max distance of returned entries from the rectangle\n     * @param maxCount\n     *            max number of entries to return\n     * @return nearest entries to maxCount, in ascending order of distance\n     */\n    public Observable<Entry<T, S>> nearest(final Rectangle r, final double maxDistance,\n            int maxCount) {\n        return search(r, maxDistance).lift(new OperatorBoundedPriorityQueue<Entry<T, S>>(maxCount,\n                Comparators.<T, S>ascendingDistance(r)));\n    }\n\n    /**\n     * Returns the nearest k entries (k=maxCount) to the given point where the\n     * entries are strictly less than a given maximum distance from the point.\n     * \n     * @param p\n     *            point\n     * @param maxDistance\n     *            max distance of returned entries from the point\n     * @param maxCount\n     *            max number of entries to return\n     * @return nearest entries to maxCount, in ascending order of distance\n     */\n    public Observable<Entry<T, S>> nearest(final Point p, final double maxDistance, int maxCount) {\n        return nearest(p.mbr(), maxDistance, maxCount);\n    }\n\n    /**\n     * Returns all entries in the tree as an {@link Observable} sequence.\n     * \n     * @return all entries in the R-tree\n     */\n    public Observable<Entry<T, S>> entries() {\n        return search(ALWAYS_TRUE);\n    }\n\n    /**\n     * Returns a {@link Visualizer} for an image of given width and height and\n     * restricted to the given view of the coordinates. The points in the view are\n     * scaled to match the aspect ratio defined by the width and height.\n     * \n     * @param width\n     *            of the image in pixels\n     * @param height\n     *            of the image in pixels\n     * @param view\n     *            using the coordinate system of the entries\n     * @return visualizer\n     */\n    @SuppressWarnings(\"unchecked\")\n    public Visualizer visualize(int width, int height, Rectangle view) {\n        return new Visualizer((RTree<?, Geometry>) this, width, height, view);\n    }\n\n    /**\n     * Returns a {@link Visualizer} for an image of given width and height and\n     * restricted to the the smallest view that fully contains the coordinates. The\n     * points in the view are scaled to match the aspect ratio defined by the width\n     * and height.\n     * \n     * @param width\n     *            of the image in pixels\n     * @param height\n     *            of the image in pixels\n     * @return visualizer\n     */\n    public Visualizer visualize(int width, int height) {\n        return visualize(width, height, calculateMaxView(this));\n    }\n\n    private Rectangle calculateMaxView(RTree<T, S> tree) {\n        @SuppressWarnings(\"unchecked\")\n        Func2<Optional<Rectangle>, Entry<T, S>, Optional<Rectangle>> ra = //\n                (Func2<Optional<Rectangle>, Entry<T, S>, Optional<Rectangle>>) //\n                (Func2<?,?,?>) //\n                RECTANGLE_ACCUMULATOR;\n        return tree.entries()\n                .reduce(Optional.empty(), ra)\n                .toBlocking().single()\n                .orElse(ZERO_RECTANGLE);\n    }\n\n    public Optional<? extends Node<T, S>> root() {\n        return root;\n    }\n\n    /**\n     * If the RTree has no entries returns {@link Optional#absent} otherwise returns\n     * the minimum bounding rectangle of all entries in the RTree.\n     * \n     * @return minimum bounding rectangle of all entries in RTree\n     */\n    public Optional<Rectangle> mbr() {\n        return root.map(r -> r.geometry().mbr());\n    }\n\n    /**\n     * Returns true if and only if the R-tree is empty of entries.\n     * \n     * @return is R-tree empty\n     */\n    public boolean isEmpty() {\n        return size == 0;\n    }\n\n    /**\n     * Returns the number of entries in the RTree.\n     * \n     * @return the number of entries\n     */\n    public int size() {\n        return size;\n    }\n\n    /**\n     * Returns a {@link Context} containing the configuration of the RTree at the\n     * time of instantiation.\n     * \n     * @return the configuration of the RTree prior to instantiation\n     */\n    public Context<T, S> context() {\n        return context;\n    }\n\n    /**\n     * Returns a human readable form of the RTree. Here's an example:\n     * \n     * <pre>\n     * mbr=Rectangle [x1=10.0, y1=4.0, x2=62.0, y2=85.0]\n     *   mbr=Rectangle [x1=28.0, y1=4.0, x2=34.0, y2=85.0]\n     *     entry=Entry [value=2, geometry=Point [x=29.0, y=4.0]]\n     *     entry=Entry [value=1, geometry=Point [x=28.0, y=19.0]]\n     *     entry=Entry [value=4, geometry=Point [x=34.0, y=85.0]]\n     *   mbr=Rectangle [x1=10.0, y1=45.0, x2=62.0, y2=63.0]\n     *     entry=Entry [value=5, geometry=Point [x=62.0, y=45.0]]\n     *     entry=Entry [value=3, geometry=Point [x=10.0, y=63.0]]\n     * </pre>\n     * \n     * @return a string representation of the RTree\n     */\n    public String asString() {\n        if (!root.isPresent())\n            return \"\";\n        else\n            return asString(root.get(), \"\");\n    }\n\n    private static final String MARGIN_INCREMENT = \"  \";\n\n    private String asString(Node<T, S> node, String margin) {\n        StringBuilder s = new StringBuilder();\n        s.append(margin);\n        s.append(\"mbr=\");\n        s.append(node.geometry());\n        s.append('\\n');\n        if (node instanceof NonLeaf) {\n            NonLeaf<T, S> n = (NonLeaf<T, S>) node;\n            for (int i = 0; i < n.count(); i++) {\n                Node<T, S> child = n.child(i);\n                s.append(asString(child, margin + MARGIN_INCREMENT));\n            }\n        } else {\n            Leaf<T, S> leaf = (Leaf<T, S>) node;\n\n            for (Entry<T, S> entry : leaf.entries()) {\n                s.append(margin);\n                s.append(MARGIN_INCREMENT);\n                s.append(\"entry=\");\n                s.append(entry);\n                s.append('\\n');\n            }\n        }\n        return s.toString();\n    }\n\n}\n", "file_hash": "7dd3131efac929e479d767ce722ab05589ca368816a6bee67c0e03a09ebabc90", "file_docstring": "", "contexts": ["package com.github.davidmoten.rtree;", "import static com.github.davidmoten.rtree.geometry.Geometries.rectangle;", "import static java.util.Optional.of;", "import java.util.ArrayList;", "import java.util.Collections;", "import java.util.Comparator;", "import java.util.List;", "import java.util.Optional;", "import com.github.davidmoten.guavamini.Lists;", "import com.github.davidmoten.guavamini.annotations.VisibleForTesting;", "import com.github.davidmoten.rtree.geometry.Circle;", "import com.github.davidmoten.rtree.geometry.Geometry;", "import com.github.davidmoten.rtree.geometry.HasGeometry;", "import com.github.davidmoten.rtree.geometry.Intersects;", "import com.github.davidmoten.rtree.geometry.Line;", "import com.github.davidmoten.rtree.geometry.Point;", "import com.github.davidmoten.rtree.geometry.Rectangle;", "import com.github.davidmoten.rtree.internal.Comparators;", "import com.github.davidmoten.rtree.internal.NodeAndEntries;", "import com.github.davidmoten.rtree.internal.operators.OperatorBoundedPriorityQueue;", "import rx.Observable;", "import rx.functions.Func1;", "import rx.functions.Func2;"], "methods": [], "classes": [{"original_string": "public final class RTree<T, S extends Geometry> {\n\n    public static final Rectangle ZERO_RECTANGLE = rectangle(0, 0, 0, 0);\n    private final Optional<? extends Node<T, S>> root;\n    private final Context<T, S> context;\n\n    /**\n     * Benchmarks show that this is a good choice for up to O(10,000) entries when\n     * using Quadratic splitter (Guttman).\n     */\n    public static final int MAX_CHILDREN_DEFAULT_GUTTMAN = 4;\n\n    /**\n     * Benchmarks show that this is the sweet spot for up to O(10,000) entries when\n     * using R*-tree heuristics.\n     */\n    public static final int MAX_CHILDREN_DEFAULT_STAR = 4;\n\n    /**\n     * Current size in Entries of the RTree.\n     */\n    private final int size;\n    private static final Func2<Optional<Rectangle>, Entry<Object, Geometry>, Optional<Rectangle>> RECTANGLE_ACCUMULATOR =\n            (rectangle, entry) ->\n                    rectangle.map(value -> Optional.of(value.add(entry.geometry().mbr())))\n                            .orElseGet(() -> Optional.of(entry.geometry().mbr()));\n\n    /**\n     * Constructor.\n     *\n     * @param root\n     *            the root node of the tree if present\n     * @param context\n     *            options for the R-tree\n     */\n    private RTree(Optional<? extends Node<T, S>> root, int size, Context<T, S> context) {\n        this.root = root;\n        this.size = size;\n        this.context = context;\n    }\n\n    private RTree() {\n        this(Optional.empty(), 0, null);\n    }\n\n    /**\n     * Constructor.\n     * \n     * @param root\n     *            the root node of the R-tree\n     * @param context\n     *            options for the R-tree\n     */\n    private RTree(Node<T, S> root, int size, Context<T, S> context) {\n        this(of(root), size, context);\n    }\n\n    static <T, S extends Geometry> RTree<T, S> create(Optional<? extends Node<T, S>> root, int size,\n            Context<T, S> context) {\n        return new RTree<T, S>(root, size, context);\n    }\n\n    /**\n     * Returns a new Builder instance for {@link RTree}. Defaults to\n     * maxChildren=128, minChildren=64, splitter=QuadraticSplitter.\n     * \n     * @param <T>\n     *            the value type of the entries in the tree\n     * @param <S>\n     *            the geometry type of the entries in the tree\n     * @return a new RTree instance\n     */\n    public static <T, S extends Geometry> RTree<T, S> create() {\n        return new Builder().create();\n    }\n\n    /**\n     * Construct an Rtree through STR bulk loading. Default to maxChildren=128,\n     * minChildren=64 and fill nodes by a factor of 0.7\n     * \n     * @param entries\n     *            entries to add to the R-tree\n     *\n     * @param <T>\n     *            the value type of the entries in the tree\n     * @param <S>\n     *            the geometry type of the entries in the tree\n     * @return a new RTree instance\n     */\n    public static <T, S extends Geometry> RTree<T, S> create(List<Entry<T, S>> entries) {\n        return new Builder().create(entries);\n    }\n\n    /**\n     * The tree is scanned for depth and the depth returned. This involves recursing\n     * down to the leaf level of the tree to get the current depth. Should be\n     * <code>log(n)</code> in complexity.\n     * \n     * @return depth of the R-tree\n     */\n    public int calculateDepth() {\n        return calculateDepth(root);\n    }\n\n    private static <T, S extends Geometry> int calculateDepth(Optional<? extends Node<T, S>> root) {\n        return root.map(node -> calculateDepth(node, 0)).orElse(0);\n    }\n\n    private static <T, S extends Geometry> int calculateDepth(Node<T, S> node, int depth) {\n        if (node instanceof Leaf) {\n            return depth + 1;\n        } else {\n            return calculateDepth(((NonLeaf<T, S>) node).child(0), depth + 1);\n        }\n    }\n\n    /**\n     * When the number of children in an R-tree node drops below this number the\n     * node is deleted and the children are added on to the R-tree again.\n     * \n     * @param minChildren\n     *            less than this number of children in a node triggers a node\n     *            deletion and redistribution of its members\n     * @return builder\n     */\n    public static Builder minChildren(int minChildren) {\n        return new Builder().minChildren(minChildren);\n    }\n\n    /**\n     * Sets the max number of children in an R-tree node.\n     * \n     * @param maxChildren\n     *            max number of children in an R-tree node\n     * @return builder\n     */\n    public static Builder maxChildren(int maxChildren) {\n        return new Builder().maxChildren(maxChildren);\n    }\n\n    /**\n     * Sets the {@link Splitter} to use when maxChildren is reached.\n     * \n     * @param splitter\n     *            the splitter algorithm to use\n     * @return builder\n     */\n    public static Builder splitter(Splitter splitter) {\n        return new Builder().splitter(splitter);\n    }\n\n    /**\n     * Sets the node {@link Selector} which decides which branches to follow when\n     * inserting or searching.\n     * \n     * @param selector\n     *            determines which branches to follow when inserting or searching\n     * @return builder\n     */\n    public static Builder selector(Selector selector) {\n        return new Builder().selector(selector);\n    }\n\n    /**\n     * Sets the splitter to {@link SplitterRStar} and selector to\n     * {@link SelectorRStar} and defaults to minChildren=10.\n     * \n     * @return builder\n     */\n    public static Builder star() {\n        return new Builder().star();\n    }\n\n    /**\n     * RTree Builder.\n     */\n    public static class Builder {\n\n        /**\n         * According to http://dbs.mathematik.uni-marburg.de/publications/myPapers\n         * /1990/BKSS90.pdf (R*-tree paper), best filling ratio is 0.4 for both\n         * quadratic split and R*-tree split.\n         */\n        private static final double DEFAULT_FILLING_FACTOR = 0.4;\n        private static final double DEFAULT_LOADING_FACTOR = 0.7;\n        private Optional<Integer> maxChildren = Optional.empty();\n        private Optional<Integer> minChildren = Optional.empty();\n        private Splitter splitter = new SplitterQuadratic();\n        private Selector selector = new SelectorMinimalAreaIncrease();\n        private double loadingFactor;\n        private boolean star = false;\n        private Factory<Object, Geometry> factory = Factories.defaultFactory();\n\n        private Builder() {\n            loadingFactor = DEFAULT_LOADING_FACTOR;\n        }\n\n        /**\n         * The factor is used as the fill ratio during bulk loading.\n         * \n         * @param factor\n         *            loading factor\n         * @return this\n         */\n        public Builder loadingFactor(double factor) {\n            this.loadingFactor = factor;\n            return this;\n        }\n\n        /**\n         * When the number of children in an R-tree node drops below this number the\n         * node is deleted and the children are added on to the R-tree again.\n         * \n         * @param minChildren\n         *            less than this number of children in a node triggers a\n         *            redistribution of its children.\n         * @return builder\n         */\n        public Builder minChildren(int minChildren) {\n            this.minChildren = of(minChildren);\n            return this;\n        }\n\n        /**\n         * Sets the max number of children in an R-tree node.\n         * \n         * @param maxChildren\n         *            max number of children in R-tree node.\n         * @return builder\n         */\n        public Builder maxChildren(int maxChildren) {\n            this.maxChildren = of(maxChildren);\n            return this;\n        }\n\n        /**\n         * Sets the {@link Splitter} to use when maxChildren is reached.\n         * \n         * @param splitter\n         *            node splitting method to use\n         * @return builder\n         */\n        public Builder splitter(Splitter splitter) {\n            this.splitter = splitter;\n            return this;\n        }\n\n        /**\n         * Sets the node {@link Selector} which decides which branches to follow when\n         * inserting or searching.\n         * \n         * @param selector\n         *            selects the branch to follow when inserting or searching\n         * @return builder\n         */\n        public Builder selector(Selector selector) {\n            this.selector = selector;\n            return this;\n        }\n\n        /**\n         * Sets the splitter to {@link SplitterRStar} and selector to\n         * {@link SelectorRStar} and defaults to minChildren=10.\n         * \n         * @return builder\n         */\n        public Builder star() {\n            selector = new SelectorRStar();\n            splitter = new SplitterRStar();\n            star = true;\n            return this;\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        public Builder factory(Factory<?, ? extends Geometry> factory) {\n            // TODO could change the signature of Builder to have types to\n            // support this method but would be breaking change for existing\n            // clients\n            this.factory = (Factory<Object, Geometry>) factory;\n            return this;\n        }\n\n        /**\n         * Builds the {@link RTree}.\n         * \n         * @param <T>\n         *            value type\n         * @param <S>\n         *            geometry type\n         * @return RTree\n         */\n        @SuppressWarnings(\"unchecked\")\n        public <T, S extends Geometry> RTree<T, S> create() {\n            setDefaultCapacity();\n\n            return new RTree<T, S>(Optional.<Node<T, S>>empty(), 0,\n                    new Context<T, S>(minChildren.get(), maxChildren.get(), selector, splitter,\n                            (Factory<T, S>) factory));\n        }\n\n        /**\n         * Create an RTree by bulk loading, using the STR method. STR: a simple and\n         * efficient algorithm for R-tree packing\n         * http://ieeexplore.ieee.org/abstract/document/582015/\n         * <p>\n         * Note: this method mutates the input entries, the internal order of the List\n         * may be changed.\n         * </p>\n         * \n         * @param entries\n         *            entries to be added to the r-tree\n         * @return a loaded RTree\n         */\n        @SuppressWarnings(\"unchecked\")\n        public <T, S extends Geometry> RTree<T, S> create(List<Entry<T, S>> entries) {\n            setDefaultCapacity();\n\n            Context<T, S> context = new Context<T, S>(minChildren.get(), maxChildren.get(),\n                    selector, splitter, (Factory<T, S>) factory);\n            return packingSTR(entries, true, entries.size(), context);\n        }\n\n        private void setDefaultCapacity() {\n            if (!maxChildren.isPresent()) {\n                if (star) {\n                    maxChildren = Optional.of(MAX_CHILDREN_DEFAULT_STAR);\n                } else {\n                    maxChildren = Optional.of(MAX_CHILDREN_DEFAULT_GUTTMAN);\n                }\n            }\n            if (!minChildren.isPresent()) {\n                minChildren = Optional.of((int) Math.round(maxChildren.get() * DEFAULT_FILLING_FACTOR));\n            }\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        private <T, S extends Geometry> RTree<T, S> packingSTR(List<? extends HasGeometry> objects,\n                boolean isLeaf, int size, Context<T, S> context) {\n            int capacity = (int) Math.round(maxChildren.get() * loadingFactor);\n            int nodeCount = (int) Math.ceil(1.0 * objects.size() / capacity);\n\n            if (nodeCount == 0) {\n                return create();\n            } else if (nodeCount == 1) {\n                Node<T, S> root;\n                if (isLeaf) {\n                    root = context.factory().createLeaf((List<Entry<T, S>>) objects, context);\n                } else {\n                    root = context.factory().createNonLeaf((List<Node<T, S>>) objects, context);\n                }\n                return new RTree<T, S>(of(root), size, context);\n            }\n\n            int nodePerSlice = (int) Math.ceil(Math.sqrt(nodeCount));\n            int sliceCapacity = nodePerSlice * capacity;\n            int sliceCount = (int) Math.ceil(1.0 * objects.size() / sliceCapacity);\n            Collections.sort(objects, new MidComparator((short) 0));\n\n            List<Node<T, S>> nodes = new ArrayList<Node<T, S>>(nodeCount);\n            for (int s = 0; s < sliceCount; s++) {\n                @SuppressWarnings(\"rawtypes\")\n                List slice = objects.subList(s * sliceCapacity,\n                        Math.min((s + 1) * sliceCapacity, objects.size()));\n                Collections.sort(slice, new MidComparator((short) 1));\n\n                for (int i = 0; i < slice.size(); i += capacity) {\n                    if (isLeaf) {\n                        List<Entry<T, S>> entries = slice.subList(i,\n                                Math.min(slice.size(), i + capacity));\n                        Node<T, S> leaf = context.factory().createLeaf(entries, context);\n                        nodes.add(leaf);\n                    } else {\n                        List<Node<T, S>> children = slice.subList(i,\n                                Math.min(slice.size(), i + capacity));\n                        Node<T, S> nonleaf = context.factory().createNonLeaf(children, context);\n                        nodes.add(nonleaf);\n                    }\n                }\n            }\n            return packingSTR(nodes, false, size, context);\n        }\n\n        private static final class MidComparator implements Comparator<HasGeometry> {\n            private final short dimension; // leave space for multiple dimensions, 0 for x, 1 for y,\n                                           // ...\n\n            public MidComparator(short dim) {\n                dimension = dim;\n            }\n\n            @Override\n            public int compare(HasGeometry o1, HasGeometry o2) {\n                return Double.compare(mid(o1), mid(o2));\n            }\n\n            private double mid(HasGeometry o) {\n                Rectangle mbr = o.geometry().mbr();\n                if (dimension == 0)\n                    return (mbr.x1() + mbr.x2()) / 2;\n                else\n                    return (mbr.y1() + mbr.y2()) / 2;\n            }\n        }\n\n    }\n\n    /**\n     * Returns an immutable copy of the RTree with the addition of given entry.\n     * \n     * @param entry\n     *            item to add to the R-tree.\n     * @return a new immutable R-tree including the new entry\n     */\n    @SuppressWarnings(\"unchecked\")\n    public RTree<T, S> add(Entry<? extends T, ? extends S> entry) {\n        if (root.isPresent()) {\n            List<Node<T, S>> nodes = root.get().add(entry);\n            Node<T, S> node;\n            if (nodes.size() == 1)\n                node = nodes.get(0);\n            else {\n                node = context.factory().createNonLeaf(nodes, context);\n            }\n            return new RTree<T, S>(node, size + 1, context);\n        } else {\n            Leaf<T, S> node = context.factory().createLeaf(Lists.newArrayList((Entry<T, S>) entry),\n                    context);\n            return new RTree<T, S>(node, size + 1, context);\n        }\n    }\n\n    /**\n     * Returns an immutable copy of the RTree with the addition of an entry\n     * comprised of the given value and Geometry.\n     * \n     * @param value\n     *            the value of the {@link Entry} to be added\n     * @param geometry\n     *            the geometry of the {@link Entry} to be added\n     * @return a new immutable R-tree including the new entry\n     */\n    public RTree<T, S> add(T value, S geometry) {\n        return add(context.factory().createEntry(value, geometry));\n    }\n\n    /**\n     * Returns an immutable RTree with the current entries and the additional\n     * entries supplied as a parameter.\n     * \n     * @param entries\n     *            entries to add\n     * @return R-tree with entries added\n     */\n    public RTree<T, S> add(Iterable<Entry<T, S>> entries) {\n        RTree<T, S> tree = this;\n        for (Entry<T, S> entry : entries)\n            tree = tree.add(entry);\n        return tree;\n    }\n\n    /**\n     * Returns the Observable sequence of trees created by progressively adding\n     * entries.\n     * \n     * @param entries\n     *            the entries to add\n     * @return a sequence of trees\n     */\n    public Observable<RTree<T, S>> add(Observable<Entry<T, S>> entries) {\n        return entries.scan(this, (tree, entry) -> tree.add(entry));\n    }\n\n    /**\n     * Returns the Observable sequence of trees created by progressively deleting\n     * entries.\n     * \n     * @param entries\n     *            the entries to add\n     * @param all\n     *            if true delete all matching otherwise just first matching\n     * @return a sequence of trees\n     */\n    public Observable<RTree<T, S>> delete(Observable<Entry<T, S>> entries, final boolean all) {\n        return entries.scan(this, new Func2<RTree<T, S>, Entry<T, S>, RTree<T, S>>() {\n\n            @Override\n            public RTree<T, S> call(RTree<T, S> tree, Entry<T, S> entry) {\n                return tree.delete(entry, all);\n            }\n        });\n    }\n\n    /**\n     * Returns a new R-tree with the given entries deleted. If <code>all</code> is\n     * false deletes only one if exists. If <code>all</code> is true deletes all\n     * matching entries.\n     * \n     * @param entries\n     *            entries to delete\n     * @param all\n     *            if false deletes one if exists else deletes all\n     * @return R-tree with entries deleted\n     */\n    public RTree<T, S> delete(Iterable<Entry<T, S>> entries, boolean all) {\n        RTree<T, S> tree = this;\n        for (Entry<T, S> entry : entries)\n            tree = tree.delete(entry, all);\n        return tree;\n    }\n\n    /**\n     * Returns a new R-tree with the given entries deleted but only one matching\n     * occurence of each entry is deleted.\n     * \n     * @param entries\n     *            entries to delete\n     * @return R-tree with entries deleted up to one matching occurence per entry\n     */\n    public RTree<T, S> delete(Iterable<Entry<T, S>> entries) {\n        RTree<T, S> tree = this;\n        for (Entry<T, S> entry : entries)\n            tree = tree.delete(entry);\n        return tree;\n    }\n\n    /**\n     * If <code>all</code> is false deletes one entry matching the given value and\n     * Geometry. If <code>all</code> is true deletes all entries matching the given\n     * value and geometry. This method has no effect if the entry is not present.\n     * The entry must match on both value and geometry to be deleted.\n     * \n     * @param value\n     *            the value of the {@link Entry} to be deleted\n     * @param geometry\n     *            the geometry of the {@link Entry} to be deleted\n     * @param all\n     *            if false deletes one if exists else deletes all\n     * @return a new immutable R-tree without one or many instances of the specified\n     *         entry if it exists otherwise returns the original RTree object\n     */\n    public RTree<T, S> delete(T value, S geometry, boolean all) {\n        return delete(context.factory().createEntry(value, geometry), all);\n    }\n\n    /**\n     * Deletes maximum one entry matching the given value and geometry. This method\n     * has no effect if the entry is not present. The entry must match on both value\n     * and geometry to be deleted.\n     * \n     * @param value\n     *            the value to be matched for deletion\n     * @param geometry\n     *            the geometry to be matched for deletion\n     * @return an immutable RTree without one entry (if found) matching the given\n     *         value and geometry\n     */\n    public RTree<T, S> delete(T value, S geometry) {\n        return delete(context.factory().createEntry(value, geometry), false);\n    }\n\n    /**\n     * Deletes one or all matching entries depending on the value of\n     * <code>all</code>. If multiple copies of the entry are in the R-tree only one\n     * will be deleted if all is false otherwise all matching entries will be\n     * deleted. The entry must match on both value and geometry to be deleted.\n     * \n     * @param entry\n     *            the {@link Entry} to be deleted\n     * @param all\n     *            if true deletes all matches otherwise deletes first found\n     * @return a new immutable R-tree without one instance of the specified entry\n     */\n    public RTree<T, S> delete(Entry<? extends T, ? extends S> entry, boolean all) {\n        if (root.isPresent()) {\n            NodeAndEntries<T, S> nodeAndEntries = root.get().delete(entry, all);\n            if (nodeAndEntries.node().isPresent() && nodeAndEntries.node().get() == root.get())\n                return this;\n            else\n                return new RTree<T, S>(nodeAndEntries.node(),\n                        size - nodeAndEntries.countDeleted() - nodeAndEntries.entriesToAdd().size(),\n                        context).add(nodeAndEntries.entriesToAdd());\n        } else\n            return this;\n    }\n\n    /**\n     * Deletes one entry if it exists, returning an immutable copy of the RTree\n     * without that entry. If multiple copies of the entry are in the R-tree only\n     * one will be deleted. The entry must match on both value and geometry to be\n     * deleted.\n     * \n     * @param entry\n     *            the {@link Entry} to be deleted\n     * @return a new immutable R-tree without one instance of the specified entry\n     */\n    public RTree<T, S> delete(Entry<? extends T, ? extends S> entry) {\n        return delete(entry, false);\n    }\n\n    /**\n     * <p>\n     * Returns an Observable sequence of {@link Entry} that satisfy the given\n     * condition. Note that this method is well-behaved only if:\n     *\n     * \n     * <p>\n     * {@code condition(g)} is true for {@link Geometry} g implies\n     * {@code condition(r)} is true for the minimum bounding rectangles of the\n     * ancestor nodes.\n     * \n     * <p>\n     * {@code distance(g) < D} is an example of such a condition.\n     * \n     * \n     * @param condition\n     *            return Entries whose geometry satisfies the given condition\n     * @return sequence of matching entries\n     */\n    @VisibleForTesting\n    Observable<Entry<T, S>> search(Func1<? super Geometry, Boolean> condition) {\n        return root\n                .map(node -> Observable.unsafeCreate(new OnSubscribeSearch<>(node, condition)))\n                .orElseGet(Observable::empty);\n    }\n\n    /**\n     * Returns a predicate function that indicates if {@link Geometry} intersects\n     * with a given rectangle.\n     * \n     * @param r\n     *            the rectangle to check intersection with\n     * @return whether the geometry and the rectangle intersect\n     */\n    public static Func1<Geometry, Boolean> intersects(final Rectangle r) {\n        return g -> g.intersects(r);\n    }\n\n    /**\n     * Returns the always true predicate. See {@link RTree#entries()} for example\n     * use.\n     */\n    private static final Func1<Geometry, Boolean> ALWAYS_TRUE = rectangle -> true;\n\n    /**\n     * Returns an {@link Observable} sequence of all {@link Entry}s in the R-tree\n     * whose minimum bounding rectangle intersects with the given rectangle.\n     * \n     * @param r\n     *            rectangle to check intersection with the entry mbr\n     * @return entries that intersect with the rectangle r\n     */\n    public Observable<Entry<T, S>> search(final Rectangle r) {\n        return search(intersects(r));\n    }\n\n    /**\n     * Returns an {@link Observable} sequence of all {@link Entry}s in the R-tree\n     * whose minimum bounding rectangle intersects with the given point.\n     * \n     * @param p\n     *            point to check intersection with the entry mbr\n     * @return entries that intersect with the point p\n     */\n    public Observable<Entry<T, S>> search(final Point p) {\n        return search(p.mbr());\n    }\n\n    public Observable<Entry<T, S>> search(Circle circle) {\n        return search(circle, Intersects.geometryIntersectsCircle);\n    }\n\n    public Observable<Entry<T, S>> search(Line line) {\n        return search(line, Intersects.geometryIntersectsLine);\n    }\n\n    /**\n     * Returns an {@link Observable} sequence of all {@link Entry}s in the R-tree\n     * whose minimum bounding rectangles are strictly less than maxDistance from the\n     * given rectangle.\n     * \n     * @param r\n     *            rectangle to measure distance from\n     * @param maxDistance\n     *            entries returned must be within this distance from rectangle r\n     * @return the sequence of matching entries\n     */\n    public Observable<Entry<T, S>> search(final Rectangle r, final double maxDistance) {\n        return search(g -> g.distance(r) < maxDistance);\n    }\n\n    /**\n     * Returns the intersections with the the given (arbitrary) geometry using an\n     * intersection function to filter the search results returned from a search of\n     * the mbr of <code>g</code>.\n     * \n     * @param <R>\n     *            type of geometry being searched for intersection with\n     * @param g\n     *            geometry being searched for intersection with\n     * @param intersects\n     *            function to determine if the two geometries intersect\n     * @return a sequence of entries that intersect with g\n     */\n    public <R extends Geometry> Observable<Entry<T, S>> search(final R g,\n                                                               final Func2<? super S, ? super R, Boolean> intersects) {\n        return search(g.mbr()).filter(entry -> intersects.call(entry.geometry(), g));\n    }\n\n    /**\n     * Returns all entries strictly less than <code>maxDistance</code> from the\n     * given geometry. Because the geometry may be of an arbitrary type it is\n     * necessary to also pass a distance function.\n     * \n     * @param <R>\n     *            type of the geometry being searched for\n     * @param g\n     *            geometry to search for entries within maxDistance of\n     * @param maxDistance\n     *            strict max distance that entries must be from g\n     * @param distance\n     *            function to calculate the distance between geometries of type S\n     *            and R.\n     * @return entries strictly less than maxDistance from g\n     */\n    public <R extends Geometry> Observable<Entry<T, S>> search(final R g, final double maxDistance,\n        final Func2<? super S, ? super R, Double> distance) {\n        // just use the mbr initially\n        return search(entry -> entry.distance(g.mbr()) < maxDistance)\n                // refine with distance function\n                .filter(entry -> distance.call(entry.geometry(), g) < maxDistance);\n    }\n\n    /**\n     * Returns an {@link Observable} sequence of all {@link Entry}s in the R-tree\n     * whose minimum bounding rectangles are within maxDistance from the given\n     * point.\n     * \n     * @param p\n     *            point to measure distance from\n     * @param maxDistance\n     *            entries returned must be within this distance from point p\n     * @return the sequence of matching entries\n     */\n    public Observable<Entry<T, S>> search(final Point p, final double maxDistance) {\n        return search(p.mbr(), maxDistance);\n    }\n\n    /**\n     * Returns the nearest k entries (k=maxCount) to the given rectangle where the\n     * entries are strictly less than a given maximum distance from the rectangle.\n     * \n     * @param r\n     *            rectangle\n     * @param maxDistance\n     *            max distance of returned entries from the rectangle\n     * @param maxCount\n     *            max number of entries to return\n     * @return nearest entries to maxCount, in ascending order of distance\n     */\n    public Observable<Entry<T, S>> nearest(final Rectangle r, final double maxDistance,\n            int maxCount) {\n        return search(r, maxDistance).lift(new OperatorBoundedPriorityQueue<Entry<T, S>>(maxCount,\n                Comparators.<T, S>ascendingDistance(r)));\n    }\n\n    /**\n     * Returns the nearest k entries (k=maxCount) to the given point where the\n     * entries are strictly less than a given maximum distance from the point.\n     * \n     * @param p\n     *            point\n     * @param maxDistance\n     *            max distance of returned entries from the point\n     * @param maxCount\n     *            max number of entries to return\n     * @return nearest entries to maxCount, in ascending order of distance\n     */\n    public Observable<Entry<T, S>> nearest(final Point p, final double maxDistance, int maxCount) {\n        return nearest(p.mbr(), maxDistance, maxCount);\n    }\n\n    /**\n     * Returns all entries in the tree as an {@link Observable} sequence.\n     * \n     * @return all entries in the R-tree\n     */\n    public Observable<Entry<T, S>> entries() {\n        return search(ALWAYS_TRUE);\n    }\n\n    /**\n     * Returns a {@link Visualizer} for an image of given width and height and\n     * restricted to the given view of the coordinates. The points in the view are\n     * scaled to match the aspect ratio defined by the width and height.\n     * \n     * @param width\n     *            of the image in pixels\n     * @param height\n     *            of the image in pixels\n     * @param view\n     *            using the coordinate system of the entries\n     * @return visualizer\n     */\n    @SuppressWarnings(\"unchecked\")\n    public Visualizer visualize(int width, int height, Rectangle view) {\n        return new Visualizer((RTree<?, Geometry>) this, width, height, view);\n    }\n\n    /**\n     * Returns a {@link Visualizer} for an image of given width and height and\n     * restricted to the the smallest view that fully contains the coordinates. The\n     * points in the view are scaled to match the aspect ratio defined by the width\n     * and height.\n     * \n     * @param width\n     *            of the image in pixels\n     * @param height\n     *            of the image in pixels\n     * @return visualizer\n     */\n    public Visualizer visualize(int width, int height) {\n        return visualize(width, height, calculateMaxView(this));\n    }\n\n    private Rectangle calculateMaxView(RTree<T, S> tree) {\n        @SuppressWarnings(\"unchecked\")\n        Func2<Optional<Rectangle>, Entry<T, S>, Optional<Rectangle>> ra = //\n                (Func2<Optional<Rectangle>, Entry<T, S>, Optional<Rectangle>>) //\n                (Func2<?,?,?>) //\n                RECTANGLE_ACCUMULATOR;\n        return tree.entries()\n                .reduce(Optional.empty(), ra)\n                .toBlocking().single()\n                .orElse(ZERO_RECTANGLE);\n    }\n\n    public Optional<? extends Node<T, S>> root() {\n        return root;\n    }\n\n    /**\n     * If the RTree has no entries returns {@link Optional#absent} otherwise returns\n     * the minimum bounding rectangle of all entries in the RTree.\n     * \n     * @return minimum bounding rectangle of all entries in RTree\n     */\n    public Optional<Rectangle> mbr() {\n        return root.map(r -> r.geometry().mbr());\n    }\n\n    /**\n     * Returns true if and only if the R-tree is empty of entries.\n     * \n     * @return is R-tree empty\n     */\n    public boolean isEmpty() {\n        return size == 0;\n    }\n\n    /**\n     * Returns the number of entries in the RTree.\n     * \n     * @return the number of entries\n     */\n    public int size() {\n        return size;\n    }\n\n    /**\n     * Returns a {@link Context} containing the configuration of the RTree at the\n     * time of instantiation.\n     * \n     * @return the configuration of the RTree prior to instantiation\n     */\n    public Context<T, S> context() {\n        return context;\n    }\n\n    /**\n     * Returns a human readable form of the RTree. Here's an example:\n     * \n     * <pre>\n     * mbr=Rectangle [x1=10.0, y1=4.0, x2=62.0, y2=85.0]\n     *   mbr=Rectangle [x1=28.0, y1=4.0, x2=34.0, y2=85.0]\n     *     entry=Entry [value=2, geometry=Point [x=29.0, y=4.0]]\n     *     entry=Entry [value=1, geometry=Point [x=28.0, y=19.0]]\n     *     entry=Entry [value=4, geometry=Point [x=34.0, y=85.0]]\n     *   mbr=Rectangle [x1=10.0, y1=45.0, x2=62.0, y2=63.0]\n     *     entry=Entry [value=5, geometry=Point [x=62.0, y=45.0]]\n     *     entry=Entry [value=3, geometry=Point [x=10.0, y=63.0]]\n     * </pre>\n     * \n     * @return a string representation of the RTree\n     */\n    public String asString() {\n        if (!root.isPresent())\n            return \"\";\n        else\n            return asString(root.get(), \"\");\n    }\n\n    private static final String MARGIN_INCREMENT = \"  \";\n\n    private String asString(Node<T, S> node, String margin) {\n        StringBuilder s = new StringBuilder();\n        s.append(margin);\n        s.append(\"mbr=\");\n        s.append(node.geometry());\n        s.append('\\n');\n        if (node instanceof NonLeaf) {\n            NonLeaf<T, S> n = (NonLeaf<T, S>) node;\n            for (int i = 0; i < n.count(); i++) {\n                Node<T, S> child = n.child(i);\n                s.append(asString(child, margin + MARGIN_INCREMENT));\n            }\n        } else {\n            Leaf<T, S> leaf = (Leaf<T, S>) node;\n\n            for (Entry<T, S> entry : leaf.entries()) {\n                s.append(margin);\n                s.append(MARGIN_INCREMENT);\n                s.append(\"entry=\");\n                s.append(entry);\n                s.append('\\n');\n            }\n        }\n        return s.toString();\n    }\n\n}", "definition": "public final class RTree<T, S extends Geometry>", "class_docstring": "\nImmutable in-memory 2D R-Tree with configurable splitter heuristic.\n\n@param <T>\n           the entry value type\n@param <S>\n           the entry geometry type\n", "name": "RTree", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "fields": [{"attribute_expression": "public static final Rectangle ZERO_RECTANGLE = rectangle(0, 0, 0, 0);", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "Rectangle", "name": "ZERO_RECTANGLE = rectangle(0, 0, 0, 0)", "syntax_pass": true}, {"attribute_expression": "private final Optional<? extends Node<T, S>> root;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Optional<? extends Node<T, S>>", "name": "root", "syntax_pass": true}, {"attribute_expression": "private final Context<T, S> context;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Context<T, S>", "name": "context", "syntax_pass": true}, {"attribute_expression": "public static final int MAX_CHILDREN_DEFAULT_GUTTMAN = 4;", "docstring": "\nBenchmarks show that this is a good choice for up to O(10,000) entries when\nusing Quadratic splitter (Guttman).\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "int", "name": "MAX_CHILDREN_DEFAULT_GUTTMAN = 4", "syntax_pass": true}, {"attribute_expression": "public static final int MAX_CHILDREN_DEFAULT_STAR = 4;", "docstring": "\nBenchmarks show that this is the sweet spot for up to O(10,000) entries when\nusing R*-tree heuristics.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "int", "name": "MAX_CHILDREN_DEFAULT_STAR = 4", "syntax_pass": true}, {"attribute_expression": "private final int size;", "docstring": "\nCurrent size in Entries of the RTree.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "int", "name": "size", "syntax_pass": true}, {"attribute_expression": "private static final Func2<Optional<Rectangle>, Entry<Object, Geometry>, Optional<Rectangle>> RECTANGLE_ACCUMULATOR =\n            (rectangle, entry) ->\n                    rectangle.map(value -> Optional.of(value.add(entry.geometry().mbr())))\n                            .orElseGet(() -> Optional.of(entry.geometry().mbr()));", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Func2<Optional<Rectangle>, Entry<Object, Geometry>, Optional<Rectangle>>", "name": "RECTANGLE_ACCUMULATOR =\n            (rectangle, entry) ->\n                    rectangle.map(value -> Optional.of(value.add(entry.geometry().mbr())))\n                            .orElseGet(() -> Optional.of(entry.geometry().mbr()))", "syntax_pass": true}, {"attribute_expression": "private static final Func1<Geometry, Boolean> ALWAYS_TRUE = rectangle -> true;", "docstring": "\nReturns the always true predicate. See {@link RTree#entries()} for example\nuse.\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Func1<Geometry, Boolean>", "name": "ALWAYS_TRUE = rectangle -> true", "syntax_pass": true}, {"attribute_expression": "private static final String MARGIN_INCREMENT = \"  \";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "MARGIN_INCREMENT = \"  \"", "syntax_pass": true}], "classes": [{"original_string": "    public static class Builder {\n\n        /**\n         * According to http://dbs.mathematik.uni-marburg.de/publications/myPapers\n         * /1990/BKSS90.pdf (R*-tree paper), best filling ratio is 0.4 for both\n         * quadratic split and R*-tree split.\n         */\n        private static final double DEFAULT_FILLING_FACTOR = 0.4;\n        private static final double DEFAULT_LOADING_FACTOR = 0.7;\n        private Optional<Integer> maxChildren = Optional.empty();\n        private Optional<Integer> minChildren = Optional.empty();\n        private Splitter splitter = new SplitterQuadratic();\n        private Selector selector = new SelectorMinimalAreaIncrease();\n        private double loadingFactor;\n        private boolean star = false;\n        private Factory<Object, Geometry> factory = Factories.defaultFactory();\n\n        private Builder() {\n            loadingFactor = DEFAULT_LOADING_FACTOR;\n        }\n\n        /**\n         * The factor is used as the fill ratio during bulk loading.\n         * \n         * @param factor\n         *            loading factor\n         * @return this\n         */\n        public Builder loadingFactor(double factor) {\n            this.loadingFactor = factor;\n            return this;\n        }\n\n        /**\n         * When the number of children in an R-tree node drops below this number the\n         * node is deleted and the children are added on to the R-tree again.\n         * \n         * @param minChildren\n         *            less than this number of children in a node triggers a\n         *            redistribution of its children.\n         * @return builder\n         */\n        public Builder minChildren(int minChildren) {\n            this.minChildren = of(minChildren);\n            return this;\n        }\n\n        /**\n         * Sets the max number of children in an R-tree node.\n         * \n         * @param maxChildren\n         *            max number of children in R-tree node.\n         * @return builder\n         */\n        public Builder maxChildren(int maxChildren) {\n            this.maxChildren = of(maxChildren);\n            return this;\n        }\n\n        /**\n         * Sets the {@link Splitter} to use when maxChildren is reached.\n         * \n         * @param splitter\n         *            node splitting method to use\n         * @return builder\n         */\n        public Builder splitter(Splitter splitter) {\n            this.splitter = splitter;\n            return this;\n        }\n\n        /**\n         * Sets the node {@link Selector} which decides which branches to follow when\n         * inserting or searching.\n         * \n         * @param selector\n         *            selects the branch to follow when inserting or searching\n         * @return builder\n         */\n        public Builder selector(Selector selector) {\n            this.selector = selector;\n            return this;\n        }\n\n        /**\n         * Sets the splitter to {@link SplitterRStar} and selector to\n         * {@link SelectorRStar} and defaults to minChildren=10.\n         * \n         * @return builder\n         */\n        public Builder star() {\n            selector = new SelectorRStar();\n            splitter = new SplitterRStar();\n            star = true;\n            return this;\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        public Builder factory(Factory<?, ? extends Geometry> factory) {\n            // TODO could change the signature of Builder to have types to\n            // support this method but would be breaking change for existing\n            // clients\n            this.factory = (Factory<Object, Geometry>) factory;\n            return this;\n        }\n\n        /**\n         * Builds the {@link RTree}.\n         * \n         * @param <T>\n         *            value type\n         * @param <S>\n         *            geometry type\n         * @return RTree\n         */\n        @SuppressWarnings(\"unchecked\")\n        public <T, S extends Geometry> RTree<T, S> create() {\n            setDefaultCapacity();\n\n            return new RTree<T, S>(Optional.<Node<T, S>>empty(), 0,\n                    new Context<T, S>(minChildren.get(), maxChildren.get(), selector, splitter,\n                            (Factory<T, S>) factory));\n        }\n\n        /**\n         * Create an RTree by bulk loading, using the STR method. STR: a simple and\n         * efficient algorithm for R-tree packing\n         * http://ieeexplore.ieee.org/abstract/document/582015/\n         * <p>\n         * Note: this method mutates the input entries, the internal order of the List\n         * may be changed.\n         * </p>\n         * \n         * @param entries\n         *            entries to be added to the r-tree\n         * @return a loaded RTree\n         */\n        @SuppressWarnings(\"unchecked\")\n        public <T, S extends Geometry> RTree<T, S> create(List<Entry<T, S>> entries) {\n            setDefaultCapacity();\n\n            Context<T, S> context = new Context<T, S>(minChildren.get(), maxChildren.get(),\n                    selector, splitter, (Factory<T, S>) factory);\n            return packingSTR(entries, true, entries.size(), context);\n        }\n\n        private void setDefaultCapacity() {\n            if (!maxChildren.isPresent()) {\n                if (star) {\n                    maxChildren = Optional.of(MAX_CHILDREN_DEFAULT_STAR);\n                } else {\n                    maxChildren = Optional.of(MAX_CHILDREN_DEFAULT_GUTTMAN);\n                }\n            }\n            if (!minChildren.isPresent()) {\n                minChildren = Optional.of((int) Math.round(maxChildren.get() * DEFAULT_FILLING_FACTOR));\n            }\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        private <T, S extends Geometry> RTree<T, S> packingSTR(List<? extends HasGeometry> objects,\n                boolean isLeaf, int size, Context<T, S> context) {\n            int capacity = (int) Math.round(maxChildren.get() * loadingFactor);\n            int nodeCount = (int) Math.ceil(1.0 * objects.size() / capacity);\n\n            if (nodeCount == 0) {\n                return create();\n            } else if (nodeCount == 1) {\n                Node<T, S> root;\n                if (isLeaf) {\n                    root = context.factory().createLeaf((List<Entry<T, S>>) objects, context);\n                } else {\n                    root = context.factory().createNonLeaf((List<Node<T, S>>) objects, context);\n                }\n                return new RTree<T, S>(of(root), size, context);\n            }\n\n            int nodePerSlice = (int) Math.ceil(Math.sqrt(nodeCount));\n            int sliceCapacity = nodePerSlice * capacity;\n            int sliceCount = (int) Math.ceil(1.0 * objects.size() / sliceCapacity);\n            Collections.sort(objects, new MidComparator((short) 0));\n\n            List<Node<T, S>> nodes = new ArrayList<Node<T, S>>(nodeCount);\n            for (int s = 0; s < sliceCount; s++) {\n                @SuppressWarnings(\"rawtypes\")\n                List slice = objects.subList(s * sliceCapacity,\n                        Math.min((s + 1) * sliceCapacity, objects.size()));\n                Collections.sort(slice, new MidComparator((short) 1));\n\n                for (int i = 0; i < slice.size(); i += capacity) {\n                    if (isLeaf) {\n                        List<Entry<T, S>> entries = slice.subList(i,\n                                Math.min(slice.size(), i + capacity));\n                        Node<T, S> leaf = context.factory().createLeaf(entries, context);\n                        nodes.add(leaf);\n                    } else {\n                        List<Node<T, S>> children = slice.subList(i,\n                                Math.min(slice.size(), i + capacity));\n                        Node<T, S> nonleaf = context.factory().createNonLeaf(children, context);\n                        nodes.add(nonleaf);\n                    }\n                }\n            }\n            return packingSTR(nodes, false, size, context);\n        }\n\n        private static final class MidComparator implements Comparator<HasGeometry> {\n            private final short dimension; // leave space for multiple dimensions, 0 for x, 1 for y,\n                                           // ...\n\n            public MidComparator(short dim) {\n                dimension = dim;\n            }\n\n            @Override\n            public int compare(HasGeometry o1, HasGeometry o2) {\n                return Double.compare(mid(o1), mid(o2));\n            }\n\n            private double mid(HasGeometry o) {\n                Rectangle mbr = o.geometry().mbr();\n                if (dimension == 0)\n                    return (mbr.x1() + mbr.x2()) / 2;\n                else\n                    return (mbr.y1() + mbr.y2()) / 2;\n            }\n        }\n\n    }", "definition": "    public static class Builder", "class_docstring": "\nRTree Builder.\n", "name": "Builder", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [{"attribute_expression": "private static final double DEFAULT_FILLING_FACTOR = 0.4;", "docstring": "\nAccording to http://dbs.mathematik.uni-marburg.de/publications/myPapers\n/1990/BKSS90.pdf (R*-tree paper), best filling ratio is 0.4 for both\nquadratic split and R*-tree split.\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "double", "name": "DEFAULT_FILLING_FACTOR = 0.4", "syntax_pass": true}, {"attribute_expression": "private static final double DEFAULT_LOADING_FACTOR = 0.7;", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "double", "name": "DEFAULT_LOADING_FACTOR = 0.7", "syntax_pass": true}, {"attribute_expression": "private Optional<Integer> maxChildren = Optional.empty();", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Optional<Integer>", "name": "maxChildren = Optional.empty()", "syntax_pass": true}, {"attribute_expression": "private Optional<Integer> minChildren = Optional.empty();", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Optional<Integer>", "name": "minChildren = Optional.empty()", "syntax_pass": true}, {"attribute_expression": "private Splitter splitter = new SplitterQuadratic();", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Splitter", "name": "splitter = new SplitterQuadratic()", "syntax_pass": true}, {"attribute_expression": "private Selector selector = new SelectorMinimalAreaIncrease();", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Selector", "name": "selector = new SelectorMinimalAreaIncrease()", "syntax_pass": true}, {"attribute_expression": "private double loadingFactor;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "double", "name": "loadingFactor", "syntax_pass": true}, {"attribute_expression": "private boolean star = false;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "boolean", "name": "star = false", "syntax_pass": true}, {"attribute_expression": "private Factory<Object, Geometry> factory = Factories.defaultFactory();", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Factory<Object, Geometry>", "name": "factory = Factories.defaultFactory()", "syntax_pass": true}], "classes": [{"original_string": "        private static final class MidComparator implements Comparator<HasGeometry> {\n            private final short dimension; // leave space for multiple dimensions, 0 for x, 1 for y,\n                                           // ...\n\n            public MidComparator(short dim) {\n                dimension = dim;\n            }\n\n            @Override\n            public int compare(HasGeometry o1, HasGeometry o2) {\n                return Double.compare(mid(o1), mid(o2));\n            }\n\n            private double mid(HasGeometry o) {\n                Rectangle mbr = o.geometry().mbr();\n                if (dimension == 0)\n                    return (mbr.x1() + mbr.x2()) / 2;\n                else\n                    return (mbr.y1() + mbr.y2()) / 2;\n            }\n        }", "definition": "        private static final class MidComparator implements Comparator<HasGeometry>", "class_docstring": "", "name": "MidComparator", "super_interfaces": ["Comparator<HasGeometry>"], "superclasses": "", "attributes": {"modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "fields": [{"attribute_expression": "private final short dimension;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "short", "name": "dimension", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "            public MidComparator(short dim) {\n                dimension = dim;\n            }", "docstring": " ...", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "MidComparator", "params": [{"name": "dim", "type": "short"}], "body": "                                            {\n                dimension = dim;\n            }", "signature": "public MidComparator(short dim)"}, {"syntax_pass": true, "original_string": "            @Override\n            public int compare(HasGeometry o1, HasGeometry o2) {\n                return Double.compare(mid(o1), mid(o2));\n            }", "docstring": "", "attributes": {"modifiers": "@Override\n            public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "compare", "params": [{"name": "o1", "type": "HasGeometry"}, {"name": "o2", "type": "HasGeometry"}], "body": "                                                               {\n                return Double.compare(mid(o1), mid(o2));\n            }", "signature": "@Override\n            public int compare(HasGeometry o1, HasGeometry o2)"}, {"syntax_pass": true, "original_string": "            private double mid(HasGeometry o) {\n                Rectangle mbr = o.geometry().mbr();\n                if (dimension == 0)\n                    return (mbr.x1() + mbr.x2()) / 2;\n                else\n                    return (mbr.y1() + mbr.y2()) / 2;\n            }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "double", "classes": []}, "name": "mid", "params": [{"name": "o", "type": "HasGeometry"}], "body": "                                              {\n                Rectangle mbr = o.geometry().mbr();\n                if (dimension == 0)\n                    return (mbr.x1() + mbr.x2()) / 2;\n                else\n                    return (mbr.y1() + mbr.y2()) / 2;\n            }", "signature": "private double mid(HasGeometry o)"}]}]}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        private Builder() {\n            loadingFactor = DEFAULT_LOADING_FACTOR;\n        }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "", "classes": []}, "name": "Builder", "params": [], "body": "                          {\n            loadingFactor = DEFAULT_LOADING_FACTOR;\n        }", "signature": "private Builder()"}, {"syntax_pass": true, "original_string": "        public Builder loadingFactor(double factor) {\n            this.loadingFactor = factor;\n            return this;\n        }", "docstring": "\nThe factor is used as the fill ratio during bulk loading.\n\n@param factor\n           loading factor\n@return this\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Builder", "classes": []}, "name": "loadingFactor", "params": [{"name": "factor", "type": "double"}], "body": "                                                    {\n            this.loadingFactor = factor;\n            return this;\n        }", "signature": "public Builder loadingFactor(double factor)"}, {"syntax_pass": true, "original_string": "        public Builder minChildren(int minChildren) {\n            this.minChildren = of(minChildren);\n            return this;\n        }", "docstring": "\nWhen the number of children in an R-tree node drops below this number the\nnode is deleted and the children are added on to the R-tree again.\n\n@param minChildren\n           less than this number of children in a node triggers a\n           redistribution of its children.\n@return builder\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Builder", "classes": []}, "name": "minChildren", "params": [{"name": "minChildren", "type": "int"}], "body": "                                                    {\n            this.minChildren = of(minChildren);\n            return this;\n        }", "signature": "public Builder minChildren(int minChildren)"}, {"syntax_pass": true, "original_string": "        public Builder maxChildren(int maxChildren) {\n            this.maxChildren = of(maxChildren);\n            return this;\n        }", "docstring": "\nSets the max number of children in an R-tree node.\n\n@param maxChildren\n           max number of children in R-tree node.\n@return builder\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Builder", "classes": []}, "name": "maxChildren", "params": [{"name": "maxChildren", "type": "int"}], "body": "                                                    {\n            this.maxChildren = of(maxChildren);\n            return this;\n        }", "signature": "public Builder maxChildren(int maxChildren)"}, {"syntax_pass": true, "original_string": "        public Builder splitter(Splitter splitter) {\n            this.splitter = splitter;\n            return this;\n        }", "docstring": "\nSets the {@link Splitter} to use when maxChildren is reached.\n\n@param splitter\n           node splitting method to use\n@return builder\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Builder", "classes": []}, "name": "splitter", "params": [{"name": "splitter", "type": "Splitter"}], "body": "                                                   {\n            this.splitter = splitter;\n            return this;\n        }", "signature": "public Builder splitter(Splitter splitter)"}, {"syntax_pass": true, "original_string": "        public Builder selector(Selector selector) {\n            this.selector = selector;\n            return this;\n        }", "docstring": "\nSets the node {@link Selector} which decides which branches to follow when\ninserting or searching.\n\n@param selector\n           selects the branch to follow when inserting or searching\n@return builder\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Builder", "classes": []}, "name": "selector", "params": [{"name": "selector", "type": "Selector"}], "body": "                                                   {\n            this.selector = selector;\n            return this;\n        }", "signature": "public Builder selector(Selector selector)"}, {"syntax_pass": true, "original_string": "        public Builder star() {\n            selector = new SelectorRStar();\n            splitter = new SplitterRStar();\n            star = true;\n            return this;\n        }", "docstring": "\nSets the splitter to {@link SplitterRStar} and selector to\n{@link SelectorRStar} and defaults to minChildren=10.\n\n@return builder\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Builder", "classes": []}, "name": "star", "params": [], "body": "                              {\n            selector = new SelectorRStar();\n            splitter = new SplitterRStar();\n            star = true;\n            return this;\n        }", "signature": "public Builder star()"}, {"syntax_pass": true, "original_string": "        @SuppressWarnings(\"unchecked\")\n        public Builder factory(Factory<?, ? extends Geometry> factory) {\n            // TODO could change the signature of Builder to have types to\n            // support this method but would be breaking change for existing\n            // clients\n            this.factory = (Factory<Object, Geometry>) factory;\n            return this;\n        }", "docstring": "", "attributes": {"modifiers": "@SuppressWarnings(\"unchecked\")\n        public", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings(\"unchecked\")", "public"], "comments": [], "return_type": "Builder", "classes": []}, "name": "factory", "params": [{"name": "factory", "type": "Factory<?, ? extends Geometry>"}], "body": "                                                                       {\n            // TODO could change the signature of Builder to have types to\n            // support this method but would be breaking change for existing\n            // clients\n            this.factory = (Factory<Object, Geometry>) factory;\n            return this;\n        }", "signature": "@SuppressWarnings(\"unchecked\")\n        public Builder factory(Factory<?, ? extends Geometry> factory)"}, {"syntax_pass": true, "original_string": "        @SuppressWarnings(\"unchecked\")\n        public <T, S extends Geometry> RTree<T, S> create() {\n            setDefaultCapacity();\n\n            return new RTree<T, S>(Optional.<Node<T, S>>empty(), 0,\n                    new Context<T, S>(minChildren.get(), maxChildren.get(), selector, splitter,\n                            (Factory<T, S>) factory));\n        }", "docstring": "\nBuilds the {@link RTree}.\n\n@param <T>\n           value type\n@param <S>\n           geometry type\n@return RTree\n", "attributes": {"modifiers": "@SuppressWarnings(\"unchecked\")\n        public", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings(\"unchecked\")", "public"], "comments": [], "return_type": "RTree<T, S>", "classes": []}, "name": "create", "params": [], "body": "                                                            {\n            setDefaultCapacity();\n\n            return new RTree<T, S>(Optional.<Node<T, S>>empty(), 0,\n                    new Context<T, S>(minChildren.get(), maxChildren.get(), selector, splitter,\n                            (Factory<T, S>) factory));\n        }", "signature": "@SuppressWarnings(\"unchecked\")\n        public <T, S extends Geometry> RTree<T, S> create()"}, {"syntax_pass": true, "original_string": "        @SuppressWarnings(\"unchecked\")\n        public <T, S extends Geometry> RTree<T, S> create(List<Entry<T, S>> entries) {\n            setDefaultCapacity();\n\n            Context<T, S> context = new Context<T, S>(minChildren.get(), maxChildren.get(),\n                    selector, splitter, (Factory<T, S>) factory);\n            return packingSTR(entries, true, entries.size(), context);\n        }", "docstring": "\nCreate an RTree by bulk loading, using the STR method. STR: a simple and\nefficient algorithm for R-tree packing\nhttp://ieeexplore.ieee.org/abstract/document/582015/\n<p>\nNote: this method mutates the input entries, the internal order of the List\nmay be changed.\n</p>\n\n@param entries\n           entries to be added to the r-tree\n@return a loaded RTree\n", "attributes": {"modifiers": "@SuppressWarnings(\"unchecked\")\n        public", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings(\"unchecked\")", "public"], "comments": [], "return_type": "RTree<T, S>", "classes": []}, "name": "create", "params": [{"name": "entries", "type": "List<Entry<T, S>>"}], "body": "                                                                                     {\n            setDefaultCapacity();\n\n            Context<T, S> context = new Context<T, S>(minChildren.get(), maxChildren.get(),\n                    selector, splitter, (Factory<T, S>) factory);\n            return packingSTR(entries, true, entries.size(), context);\n        }", "signature": "@SuppressWarnings(\"unchecked\")\n        public <T, S extends Geometry> RTree<T, S> create(List<Entry<T, S>> entries)"}, {"syntax_pass": true, "original_string": "        private void setDefaultCapacity() {\n            if (!maxChildren.isPresent()) {\n                if (star) {\n                    maxChildren = Optional.of(MAX_CHILDREN_DEFAULT_STAR);\n                } else {\n                    maxChildren = Optional.of(MAX_CHILDREN_DEFAULT_GUTTMAN);\n                }\n            }\n            if (!minChildren.isPresent()) {\n                minChildren = Optional.of((int) Math.round(maxChildren.get() * DEFAULT_FILLING_FACTOR));\n            }\n        }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "name": "setDefaultCapacity", "params": [], "body": "                                          {\n            if (!maxChildren.isPresent()) {\n                if (star) {\n                    maxChildren = Optional.of(MAX_CHILDREN_DEFAULT_STAR);\n                } else {\n                    maxChildren = Optional.of(MAX_CHILDREN_DEFAULT_GUTTMAN);\n                }\n            }\n            if (!minChildren.isPresent()) {\n                minChildren = Optional.of((int) Math.round(maxChildren.get() * DEFAULT_FILLING_FACTOR));\n            }\n        }", "signature": "private void setDefaultCapacity()"}, {"syntax_pass": true, "original_string": "        @SuppressWarnings(\"unchecked\")\n        private <T, S extends Geometry> RTree<T, S> packingSTR(List<? extends HasGeometry> objects,\n                boolean isLeaf, int size, Context<T, S> context) {\n            int capacity = (int) Math.round(maxChildren.get() * loadingFactor);\n            int nodeCount = (int) Math.ceil(1.0 * objects.size() / capacity);\n\n            if (nodeCount == 0) {\n                return create();\n            } else if (nodeCount == 1) {\n                Node<T, S> root;\n                if (isLeaf) {\n                    root = context.factory().createLeaf((List<Entry<T, S>>) objects, context);\n                } else {\n                    root = context.factory().createNonLeaf((List<Node<T, S>>) objects, context);\n                }\n                return new RTree<T, S>(of(root), size, context);\n            }\n\n            int nodePerSlice = (int) Math.ceil(Math.sqrt(nodeCount));\n            int sliceCapacity = nodePerSlice * capacity;\n            int sliceCount = (int) Math.ceil(1.0 * objects.size() / sliceCapacity);\n            Collections.sort(objects, new MidComparator((short) 0));\n\n            List<Node<T, S>> nodes = new ArrayList<Node<T, S>>(nodeCount);\n            for (int s = 0; s < sliceCount; s++) {\n                @SuppressWarnings(\"rawtypes\")\n                List slice = objects.subList(s * sliceCapacity,\n                        Math.min((s + 1) * sliceCapacity, objects.size()));\n                Collections.sort(slice, new MidComparator((short) 1));\n\n                for (int i = 0; i < slice.size(); i += capacity) {\n                    if (isLeaf) {\n                        List<Entry<T, S>> entries = slice.subList(i,\n                                Math.min(slice.size(), i + capacity));\n                        Node<T, S> leaf = context.factory().createLeaf(entries, context);\n                        nodes.add(leaf);\n                    } else {\n                        List<Node<T, S>> children = slice.subList(i,\n                                Math.min(slice.size(), i + capacity));\n                        Node<T, S> nonleaf = context.factory().createNonLeaf(children, context);\n                        nodes.add(nonleaf);\n                    }\n                }\n            }\n            return packingSTR(nodes, false, size, context);\n        }", "docstring": "", "attributes": {"modifiers": "@SuppressWarnings(\"unchecked\")\n        private", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings(\"unchecked\")", "private"], "comments": [], "return_type": "RTree<T, S>", "classes": []}, "name": "packingSTR", "params": [{"name": "objects", "type": "List<? extends HasGeometry>"}, {"name": "isLeaf", "type": "boolean"}, {"name": "size", "type": "int"}, {"name": "context", "type": "Context<T, S>"}], "body": "                                                                 {\n            int capacity = (int) Math.round(maxChildren.get() * loadingFactor);\n            int nodeCount = (int) Math.ceil(1.0 * objects.size() / capacity);\n\n            if (nodeCount == 0) {\n                return create();\n            } else if (nodeCount == 1) {\n                Node<T, S> root;\n                if (isLeaf) {\n                    root = context.factory().createLeaf((List<Entry<T, S>>) objects, context);\n                } else {\n                    root = context.factory().createNonLeaf((List<Node<T, S>>) objects, context);\n                }\n                return new RTree<T, S>(of(root), size, context);\n            }\n\n            int nodePerSlice = (int) Math.ceil(Math.sqrt(nodeCount));\n            int sliceCapacity = nodePerSlice * capacity;\n            int sliceCount = (int) Math.ceil(1.0 * objects.size() / sliceCapacity);\n            Collections.sort(objects, new MidComparator((short) 0));\n\n            List<Node<T, S>> nodes = new ArrayList<Node<T, S>>(nodeCount);\n            for (int s = 0; s < sliceCount; s++) {\n                @SuppressWarnings(\"rawtypes\")\n                List slice = objects.subList(s * sliceCapacity,\n                        Math.min((s + 1) * sliceCapacity, objects.size()));\n                Collections.sort(slice, new MidComparator((short) 1));\n\n                for (int i = 0; i < slice.size(); i += capacity) {\n                    if (isLeaf) {\n                        List<Entry<T, S>> entries = slice.subList(i,\n                                Math.min(slice.size(), i + capacity));\n                        Node<T, S> leaf = context.factory().createLeaf(entries, context);\n                        nodes.add(leaf);\n                    } else {\n                        List<Node<T, S>> children = slice.subList(i,\n                                Math.min(slice.size(), i + capacity));\n                        Node<T, S> nonleaf = context.factory().createNonLeaf(children, context);\n                        nodes.add(nonleaf);\n                    }\n                }\n            }\n            return packingSTR(nodes, false, size, context);\n        }", "signature": "@SuppressWarnings(\"unchecked\")\n        private <T, S extends Geometry> RTree<T, S> packingSTR(List<? extends HasGeometry> objects,\n                boolean isLeaf, int size, Context<T, S> context)"}]}]}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    private RTree(Optional<? extends Node<T, S>> root, int size, Context<T, S> context) {\n        this.root = root;\n        this.size = size;\n        this.context = context;\n    }", "docstring": "\nConstructor.\n\n@param root\n           the root node of the tree if present\n@param context\n           options for the R-tree\n", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "", "classes": []}, "name": "RTree", "params": [{"name": "root", "type": "Optional<? extends Node<T, S>>"}, {"name": "size", "type": "int"}, {"name": "context", "type": "Context<T, S>"}], "body": "                                                                                        {\n        this.root = root;\n        this.size = size;\n        this.context = context;\n    }", "signature": "private RTree(Optional<? extends Node<T, S>> root, int size, Context<T, S> context)"}, {"syntax_pass": true, "original_string": "    private RTree() {\n        this(Optional.empty(), 0, null);\n    }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "", "classes": []}, "name": "RTree", "params": [], "body": "                    {\n        this(Optional.empty(), 0, null);\n    }", "signature": "private RTree()"}, {"syntax_pass": true, "original_string": "    private RTree(Node<T, S> root, int size, Context<T, S> context) {\n        this(of(root), size, context);\n    }", "docstring": "\nConstructor.\n\n@param root\n           the root node of the R-tree\n@param context\n           options for the R-tree\n", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "", "classes": []}, "name": "RTree", "params": [{"name": "root", "type": "Node<T, S>"}, {"name": "size", "type": "int"}, {"name": "context", "type": "Context<T, S>"}], "body": "                                                                    {\n        this(of(root), size, context);\n    }", "signature": "private RTree(Node<T, S> root, int size, Context<T, S> context)"}, {"syntax_pass": true, "original_string": "    static <T, S extends Geometry> RTree<T, S> create(Optional<? extends Node<T, S>> root, int size,\n            Context<T, S> context) {\n        return new RTree<T, S>(root, size, context);\n    }", "docstring": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "RTree<T, S>", "classes": []}, "name": "create", "params": [{"name": "root", "type": "Optional<? extends Node<T, S>>"}, {"name": "size", "type": "int"}, {"name": "context", "type": "Context<T, S>"}], "body": "                                   {\n        return new RTree<T, S>(root, size, context);\n    }", "signature": "static <T, S extends Geometry> RTree<T, S> create(Optional<? extends Node<T, S>> root, int size,\n            Context<T, S> context)"}, {"syntax_pass": true, "original_string": "    public static <T, S extends Geometry> RTree<T, S> create() {\n        return new Builder().create();\n    }", "docstring": "\nReturns a new Builder instance for {@link RTree}. Defaults to\nmaxChildren=128, minChildren=64, splitter=QuadraticSplitter.\n\n@param <T>\n           the value type of the entries in the tree\n@param <S>\n           the geometry type of the entries in the tree\n@return a new RTree instance\n", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "RTree<T, S>", "classes": []}, "name": "create", "params": [], "body": "                                                               {\n        return new Builder().create();\n    }", "signature": "public static <T, S extends Geometry> RTree<T, S> create()"}, {"syntax_pass": true, "original_string": "    public static <T, S extends Geometry> RTree<T, S> create(List<Entry<T, S>> entries) {\n        return new Builder().create(entries);\n    }", "docstring": "\nConstruct an Rtree through STR bulk loading. Default to maxChildren=128,\nminChildren=64 and fill nodes by a factor of 0.7\n\n@param entries\n           entries to add to the R-tree\n\n@param <T>\n           the value type of the entries in the tree\n@param <S>\n           the geometry type of the entries in the tree\n@return a new RTree instance\n", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "RTree<T, S>", "classes": []}, "name": "create", "params": [{"name": "entries", "type": "List<Entry<T, S>>"}], "body": "                                                                                        {\n        return new Builder().create(entries);\n    }", "signature": "public static <T, S extends Geometry> RTree<T, S> create(List<Entry<T, S>> entries)"}, {"syntax_pass": true, "original_string": "    public int calculateDepth() {\n        return calculateDepth(root);\n    }", "docstring": "\nThe tree is scanned for depth and the depth returned. This involves recursing\ndown to the leaf level of the tree to get the current depth. Should be\n<code>log(n)</code> in complexity.\n\n@return depth of the R-tree\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "calculateDepth", "params": [], "body": "                                {\n        return calculateDepth(root);\n    }", "signature": "public int calculateDepth()"}, {"syntax_pass": true, "original_string": "    private static <T, S extends Geometry> int calculateDepth(Optional<? extends Node<T, S>> root) {\n        return root.map(node -> calculateDepth(node, 0)).orElse(0);\n    }", "docstring": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "int", "classes": []}, "name": "calculateDepth", "params": [{"name": "root", "type": "Optional<? extends Node<T, S>>"}], "body": "                                                                                                   {\n        return root.map(node -> calculateDepth(node, 0)).orElse(0);\n    }", "signature": "private static <T, S extends Geometry> int calculateDepth(Optional<? extends Node<T, S>> root)"}, {"syntax_pass": true, "original_string": "    private static <T, S extends Geometry> int calculateDepth(Node<T, S> node, int depth) {\n        if (node instanceof Leaf) {\n            return depth + 1;\n        } else {\n            return calculateDepth(((NonLeaf<T, S>) node).child(0), depth + 1);\n        }\n    }", "docstring": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "int", "classes": []}, "name": "calculateDepth", "params": [{"name": "node", "type": "Node<T, S>"}, {"name": "depth", "type": "int"}], "body": "                                                                                          {\n        if (node instanceof Leaf) {\n            return depth + 1;\n        } else {\n            return calculateDepth(((NonLeaf<T, S>) node).child(0), depth + 1);\n        }\n    }", "signature": "private static <T, S extends Geometry> int calculateDepth(Node<T, S> node, int depth)"}, {"syntax_pass": true, "original_string": "    public static Builder minChildren(int minChildren) {\n        return new Builder().minChildren(minChildren);\n    }", "docstring": "\nWhen the number of children in an R-tree node drops below this number the\nnode is deleted and the children are added on to the R-tree again.\n\n@param minChildren\n           less than this number of children in a node triggers a node\n           deletion and redistribution of its members\n@return builder\n", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Builder", "classes": []}, "name": "minChildren", "params": [{"name": "minChildren", "type": "int"}], "body": "                                                       {\n        return new Builder().minChildren(minChildren);\n    }", "signature": "public static Builder minChildren(int minChildren)"}, {"syntax_pass": true, "original_string": "    public static Builder maxChildren(int maxChildren) {\n        return new Builder().maxChildren(maxChildren);\n    }", "docstring": "\nSets the max number of children in an R-tree node.\n\n@param maxChildren\n           max number of children in an R-tree node\n@return builder\n", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Builder", "classes": []}, "name": "maxChildren", "params": [{"name": "maxChildren", "type": "int"}], "body": "                                                       {\n        return new Builder().maxChildren(maxChildren);\n    }", "signature": "public static Builder maxChildren(int maxChildren)"}, {"syntax_pass": true, "original_string": "    public static Builder splitter(Splitter splitter) {\n        return new Builder().splitter(splitter);\n    }", "docstring": "\nSets the {@link Splitter} to use when maxChildren is reached.\n\n@param splitter\n           the splitter algorithm to use\n@return builder\n", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Builder", "classes": []}, "name": "splitter", "params": [{"name": "splitter", "type": "Splitter"}], "body": "                                                      {\n        return new Builder().splitter(splitter);\n    }", "signature": "public static Builder splitter(Splitter splitter)"}, {"syntax_pass": true, "original_string": "    public static Builder selector(Selector selector) {\n        return new Builder().selector(selector);\n    }", "docstring": "\nSets the node {@link Selector} which decides which branches to follow when\ninserting or searching.\n\n@param selector\n           determines which branches to follow when inserting or searching\n@return builder\n", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Builder", "classes": []}, "name": "selector", "params": [{"name": "selector", "type": "Selector"}], "body": "                                                      {\n        return new Builder().selector(selector);\n    }", "signature": "public static Builder selector(Selector selector)"}, {"syntax_pass": true, "original_string": "    public static Builder star() {\n        return new Builder().star();\n    }", "docstring": "\nSets the splitter to {@link SplitterRStar} and selector to\n{@link SelectorRStar} and defaults to minChildren=10.\n\n@return builder\n", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Builder", "classes": []}, "name": "star", "params": [], "body": "                                 {\n        return new Builder().star();\n    }", "signature": "public static Builder star()"}, {"syntax_pass": true, "original_string": "    @SuppressWarnings(\"unchecked\")\n    public RTree<T, S> add(Entry<? extends T, ? extends S> entry) {\n        if (root.isPresent()) {\n            List<Node<T, S>> nodes = root.get().add(entry);\n            Node<T, S> node;\n            if (nodes.size() == 1)\n                node = nodes.get(0);\n            else {\n                node = context.factory().createNonLeaf(nodes, context);\n            }\n            return new RTree<T, S>(node, size + 1, context);\n        } else {\n            Leaf<T, S> node = context.factory().createLeaf(Lists.newArrayList((Entry<T, S>) entry),\n                    context);\n            return new RTree<T, S>(node, size + 1, context);\n        }\n    }", "docstring": "\nReturns an immutable copy of the RTree with the addition of given entry.\n\n@param entry\n           item to add to the R-tree.\n@return a new immutable R-tree including the new entry\n", "attributes": {"modifiers": "@SuppressWarnings(\"unchecked\")\n    public", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings(\"unchecked\")", "public"], "comments": [], "return_type": "RTree<T, S>", "classes": []}, "name": "add", "params": [{"name": "entry", "type": "Entry<? extends T, ? extends S>"}], "body": "                                                                  {\n        if (root.isPresent()) {\n            List<Node<T, S>> nodes = root.get().add(entry);\n            Node<T, S> node;\n            if (nodes.size() == 1)\n                node = nodes.get(0);\n            else {\n                node = context.factory().createNonLeaf(nodes, context);\n            }\n            return new RTree<T, S>(node, size + 1, context);\n        } else {\n            Leaf<T, S> node = context.factory().createLeaf(Lists.newArrayList((Entry<T, S>) entry),\n                    context);\n            return new RTree<T, S>(node, size + 1, context);\n        }\n    }", "signature": "@SuppressWarnings(\"unchecked\")\n    public RTree<T, S> add(Entry<? extends T, ? extends S> entry)"}, {"syntax_pass": true, "original_string": "    public RTree<T, S> add(T value, S geometry) {\n        return add(context.factory().createEntry(value, geometry));\n    }", "docstring": "\nReturns an immutable copy of the RTree with the addition of an entry\ncomprised of the given value and Geometry.\n\n@param value\n           the value of the {@link Entry} to be added\n@param geometry\n           the geometry of the {@link Entry} to be added\n@return a new immutable R-tree including the new entry\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "RTree<T, S>", "classes": []}, "name": "add", "params": [{"name": "value", "type": "T"}, {"name": "geometry", "type": "S"}], "body": "                                                {\n        return add(context.factory().createEntry(value, geometry));\n    }", "signature": "public RTree<T, S> add(T value, S geometry)"}, {"syntax_pass": true, "original_string": "    public RTree<T, S> add(Iterable<Entry<T, S>> entries) {\n        RTree<T, S> tree = this;\n        for (Entry<T, S> entry : entries)\n            tree = tree.add(entry);\n        return tree;\n    }", "docstring": "\nReturns an immutable RTree with the current entries and the additional\nentries supplied as a parameter.\n\n@param entries\n           entries to add\n@return R-tree with entries added\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "RTree<T, S>", "classes": []}, "name": "add", "params": [{"name": "entries", "type": "Iterable<Entry<T, S>>"}], "body": "                                                          {\n        RTree<T, S> tree = this;\n        for (Entry<T, S> entry : entries)\n            tree = tree.add(entry);\n        return tree;\n    }", "signature": "public RTree<T, S> add(Iterable<Entry<T, S>> entries)"}, {"syntax_pass": true, "original_string": "    public Observable<RTree<T, S>> add(Observable<Entry<T, S>> entries) {\n        return entries.scan(this, (tree, entry) -> tree.add(entry));\n    }", "docstring": "\nReturns the Observable sequence of trees created by progressively adding\nentries.\n\n@param entries\n           the entries to add\n@return a sequence of trees\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Observable<RTree<T, S>>", "classes": []}, "name": "add", "params": [{"name": "entries", "type": "Observable<Entry<T, S>>"}], "body": "                                                                        {\n        return entries.scan(this, (tree, entry) -> tree.add(entry));\n    }", "signature": "public Observable<RTree<T, S>> add(Observable<Entry<T, S>> entries)"}, {"syntax_pass": true, "original_string": "    public Observable<RTree<T, S>> delete(Observable<Entry<T, S>> entries, final boolean all) {\n        return entries.scan(this, new Func2<RTree<T, S>, Entry<T, S>, RTree<T, S>>() {\n\n            @Override\n            public RTree<T, S> call(RTree<T, S> tree, Entry<T, S> entry) {\n                return tree.delete(entry, all);\n            }\n        });\n    }", "docstring": "\nReturns the Observable sequence of trees created by progressively deleting\nentries.\n\n@param entries\n           the entries to add\n@param all\n           if true delete all matching otherwise just first matching\n@return a sequence of trees\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Observable<RTree<T, S>>", "classes": []}, "name": "delete", "params": [{"name": "entries", "type": "Observable<Entry<T, S>>"}, {"name": "all", "type": "boolean"}], "body": "                                                                                              {\n        return entries.scan(this, new Func2<RTree<T, S>, Entry<T, S>, RTree<T, S>>() {\n\n            @Override\n            public RTree<T, S> call(RTree<T, S> tree, Entry<T, S> entry) {\n                return tree.delete(entry, all);\n            }\n        });\n    }", "signature": "public Observable<RTree<T, S>> delete(Observable<Entry<T, S>> entries, final boolean all)"}, {"syntax_pass": true, "original_string": "    public RTree<T, S> delete(Iterable<Entry<T, S>> entries, boolean all) {\n        RTree<T, S> tree = this;\n        for (Entry<T, S> entry : entries)\n            tree = tree.delete(entry, all);\n        return tree;\n    }", "docstring": "\nReturns a new R-tree with the given entries deleted. If <code>all</code> is\nfalse deletes only one if exists. If <code>all</code> is true deletes all\nmatching entries.\n\n@param entries\n           entries to delete\n@param all\n           if false deletes one if exists else deletes all\n@return R-tree with entries deleted\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "RTree<T, S>", "classes": []}, "name": "delete", "params": [{"name": "entries", "type": "Iterable<Entry<T, S>>"}, {"name": "all", "type": "boolean"}], "body": "                                                                          {\n        RTree<T, S> tree = this;\n        for (Entry<T, S> entry : entries)\n            tree = tree.delete(entry, all);\n        return tree;\n    }", "signature": "public RTree<T, S> delete(Iterable<Entry<T, S>> entries, boolean all)"}, {"syntax_pass": true, "original_string": "    public RTree<T, S> delete(Iterable<Entry<T, S>> entries) {\n        RTree<T, S> tree = this;\n        for (Entry<T, S> entry : entries)\n            tree = tree.delete(entry);\n        return tree;\n    }", "docstring": "\nReturns a new R-tree with the given entries deleted but only one matching\noccurence of each entry is deleted.\n\n@param entries\n           entries to delete\n@return R-tree with entries deleted up to one matching occurence per entry\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "RTree<T, S>", "classes": []}, "name": "delete", "params": [{"name": "entries", "type": "Iterable<Entry<T, S>>"}], "body": "                                                             {\n        RTree<T, S> tree = this;\n        for (Entry<T, S> entry : entries)\n            tree = tree.delete(entry);\n        return tree;\n    }", "signature": "public RTree<T, S> delete(Iterable<Entry<T, S>> entries)"}, {"syntax_pass": true, "original_string": "    public RTree<T, S> delete(T value, S geometry, boolean all) {\n        return delete(context.factory().createEntry(value, geometry), all);\n    }", "docstring": "\nIf <code>all</code> is false deletes one entry matching the given value and\nGeometry. If <code>all</code> is true deletes all entries matching the given\nvalue and geometry. This method has no effect if the entry is not present.\nThe entry must match on both value and geometry to be deleted.\n\n@param value\n           the value of the {@link Entry} to be deleted\n@param geometry\n           the geometry of the {@link Entry} to be deleted\n@param all\n           if false deletes one if exists else deletes all\n@return a new immutable R-tree without one or many instances of the specified\n        entry if it exists otherwise returns the original RTree object\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "RTree<T, S>", "classes": []}, "name": "delete", "params": [{"name": "value", "type": "T"}, {"name": "geometry", "type": "S"}, {"name": "all", "type": "boolean"}], "body": "                                                                {\n        return delete(context.factory().createEntry(value, geometry), all);\n    }", "signature": "public RTree<T, S> delete(T value, S geometry, boolean all)"}, {"syntax_pass": true, "original_string": "    public RTree<T, S> delete(T value, S geometry) {\n        return delete(context.factory().createEntry(value, geometry), false);\n    }", "docstring": "\nDeletes maximum one entry matching the given value and geometry. This method\nhas no effect if the entry is not present. The entry must match on both value\nand geometry to be deleted.\n\n@param value\n           the value to be matched for deletion\n@param geometry\n           the geometry to be matched for deletion\n@return an immutable RTree without one entry (if found) matching the given\n        value and geometry\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "RTree<T, S>", "classes": []}, "name": "delete", "params": [{"name": "value", "type": "T"}, {"name": "geometry", "type": "S"}], "body": "                                                   {\n        return delete(context.factory().createEntry(value, geometry), false);\n    }", "signature": "public RTree<T, S> delete(T value, S geometry)"}, {"syntax_pass": true, "original_string": "    public RTree<T, S> delete(Entry<? extends T, ? extends S> entry, boolean all) {\n        if (root.isPresent()) {\n            NodeAndEntries<T, S> nodeAndEntries = root.get().delete(entry, all);\n            if (nodeAndEntries.node().isPresent() && nodeAndEntries.node().get() == root.get())\n                return this;\n            else\n                return new RTree<T, S>(nodeAndEntries.node(),\n                        size - nodeAndEntries.countDeleted() - nodeAndEntries.entriesToAdd().size(),\n                        context).add(nodeAndEntries.entriesToAdd());\n        } else\n            return this;\n    }", "docstring": "\nDeletes one or all matching entries depending on the value of\n<code>all</code>. If multiple copies of the entry are in the R-tree only one\nwill be deleted if all is false otherwise all matching entries will be\ndeleted. The entry must match on both value and geometry to be deleted.\n\n@param entry\n           the {@link Entry} to be deleted\n@param all\n           if true deletes all matches otherwise deletes first found\n@return a new immutable R-tree without one instance of the specified entry\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "RTree<T, S>", "classes": []}, "name": "delete", "params": [{"name": "entry", "type": "Entry<? extends T, ? extends S>"}, {"name": "all", "type": "boolean"}], "body": "                                                                                  {\n        if (root.isPresent()) {\n            NodeAndEntries<T, S> nodeAndEntries = root.get().delete(entry, all);\n            if (nodeAndEntries.node().isPresent() && nodeAndEntries.node().get() == root.get())\n                return this;\n            else\n                return new RTree<T, S>(nodeAndEntries.node(),\n                        size - nodeAndEntries.countDeleted() - nodeAndEntries.entriesToAdd().size(),\n                        context).add(nodeAndEntries.entriesToAdd());\n        } else\n            return this;\n    }", "signature": "public RTree<T, S> delete(Entry<? extends T, ? extends S> entry, boolean all)"}, {"syntax_pass": true, "original_string": "    public RTree<T, S> delete(Entry<? extends T, ? extends S> entry) {\n        return delete(entry, false);\n    }", "docstring": "\nDeletes one entry if it exists, returning an immutable copy of the RTree\nwithout that entry. If multiple copies of the entry are in the R-tree only\none will be deleted. The entry must match on both value and geometry to be\ndeleted.\n\n@param entry\n           the {@link Entry} to be deleted\n@return a new immutable R-tree without one instance of the specified entry\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "RTree<T, S>", "classes": []}, "name": "delete", "params": [{"name": "entry", "type": "Entry<? extends T, ? extends S>"}], "body": "                                                                     {\n        return delete(entry, false);\n    }", "signature": "public RTree<T, S> delete(Entry<? extends T, ? extends S> entry)"}, {"syntax_pass": true, "original_string": "    @VisibleForTesting\n    Observable<Entry<T, S>> search(Func1<? super Geometry, Boolean> condition) {\n        return root\n                .map(node -> Observable.unsafeCreate(new OnSubscribeSearch<>(node, condition)))\n                .orElseGet(Observable::empty);\n    }", "docstring": "\n<p>\nReturns an Observable sequence of {@link Entry} that satisfy the given\ncondition. Note that this method is well-behaved only if:\n\n\n<p>\n{@code condition(g)} is true for {@link Geometry} g implies\n{@code condition(r)} is true for the minimum bounding rectangles of the\nancestor nodes.\n\n<p>\n{@code distance(g) < D} is an example of such a condition.\n\n\n@param condition\n           return Entries whose geometry satisfies the given condition\n@return sequence of matching entries\n", "attributes": {"modifiers": "@VisibleForTesting", "marker_annotations": ["@VisibleForTesting"], "non_marker_annotations": [], "comments": [], "return_type": "Observable<Entry<T, S>>", "classes": []}, "name": "search", "params": [{"name": "condition", "type": "Func1<? super Geometry, Boolean>"}], "body": "                                                                               {\n        return root\n                .map(node -> Observable.unsafeCreate(new OnSubscribeSearch<>(node, condition)))\n                .orElseGet(Observable::empty);\n    }", "signature": "@VisibleForTesting\n    Observable<Entry<T, S>> search(Func1<? super Geometry, Boolean> condition)"}, {"syntax_pass": true, "original_string": "    public static Func1<Geometry, Boolean> intersects(final Rectangle r) {\n        return g -> g.intersects(r);\n    }", "docstring": "\nReturns a predicate function that indicates if {@link Geometry} intersects\nwith a given rectangle.\n\n@param r\n           the rectangle to check intersection with\n@return whether the geometry and the rectangle intersect\n", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Func1<Geometry, Boolean>", "classes": []}, "name": "intersects", "params": [{"name": "r", "type": "Rectangle"}], "body": "                                                                         {\n        return g -> g.intersects(r);\n    }", "signature": "public static Func1<Geometry, Boolean> intersects(final Rectangle r)"}, {"syntax_pass": true, "original_string": "    public Observable<Entry<T, S>> search(final Rectangle r) {\n        return search(intersects(r));\n    }", "docstring": "\nReturns an {@link Observable} sequence of all {@link Entry}s in the R-tree\nwhose minimum bounding rectangle intersects with the given rectangle.\n\n@param r\n           rectangle to check intersection with the entry mbr\n@return entries that intersect with the rectangle r\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Observable<Entry<T, S>>", "classes": []}, "name": "search", "params": [{"name": "r", "type": "Rectangle"}], "body": "                                                             {\n        return search(intersects(r));\n    }", "signature": "public Observable<Entry<T, S>> search(final Rectangle r)"}, {"syntax_pass": true, "original_string": "    public Observable<Entry<T, S>> search(final Point p) {\n        return search(p.mbr());\n    }", "docstring": "\nReturns an {@link Observable} sequence of all {@link Entry}s in the R-tree\nwhose minimum bounding rectangle intersects with the given point.\n\n@param p\n           point to check intersection with the entry mbr\n@return entries that intersect with the point p\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Observable<Entry<T, S>>", "classes": []}, "name": "search", "params": [{"name": "p", "type": "Point"}], "body": "                                                         {\n        return search(p.mbr());\n    }", "signature": "public Observable<Entry<T, S>> search(final Point p)"}, {"syntax_pass": true, "original_string": "    public Observable<Entry<T, S>> search(Circle circle) {\n        return search(circle, Intersects.geometryIntersectsCircle);\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Observable<Entry<T, S>>", "classes": []}, "name": "search", "params": [{"name": "circle", "type": "Circle"}], "body": "                                                         {\n        return search(circle, Intersects.geometryIntersectsCircle);\n    }", "signature": "public Observable<Entry<T, S>> search(Circle circle)"}, {"syntax_pass": true, "original_string": "    public Observable<Entry<T, S>> search(Line line) {\n        return search(line, Intersects.geometryIntersectsLine);\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Observable<Entry<T, S>>", "classes": []}, "name": "search", "params": [{"name": "line", "type": "Line"}], "body": "                                                     {\n        return search(line, Intersects.geometryIntersectsLine);\n    }", "signature": "public Observable<Entry<T, S>> search(Line line)"}, {"syntax_pass": true, "original_string": "    public Observable<Entry<T, S>> search(final Rectangle r, final double maxDistance) {\n        return search(g -> g.distance(r) < maxDistance);\n    }", "docstring": "\nReturns an {@link Observable} sequence of all {@link Entry}s in the R-tree\nwhose minimum bounding rectangles are strictly less than maxDistance from the\ngiven rectangle.\n\n@param r\n           rectangle to measure distance from\n@param maxDistance\n           entries returned must be within this distance from rectangle r\n@return the sequence of matching entries\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Observable<Entry<T, S>>", "classes": []}, "name": "search", "params": [{"name": "r", "type": "Rectangle"}, {"name": "maxDistance", "type": "double"}], "body": "                                                                                       {\n        return search(g -> g.distance(r) < maxDistance);\n    }", "signature": "public Observable<Entry<T, S>> search(final Rectangle r, final double maxDistance)"}, {"syntax_pass": true, "original_string": "    public <R extends Geometry> Observable<Entry<T, S>> search(final R g,\n                                                               final Func2<? super S, ? super R, Boolean> intersects) {\n        return search(g.mbr()).filter(entry -> intersects.call(entry.geometry(), g));\n    }", "docstring": "\nReturns the intersections with the the given (arbitrary) geometry using an\nintersection function to filter the search results returned from a search of\nthe mbr of <code>g</code>.\n\n@param <R>\n           type of geometry being searched for intersection with\n@param g\n           geometry being searched for intersection with\n@param intersects\n           function to determine if the two geometries intersect\n@return a sequence of entries that intersect with g\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Observable<Entry<T, S>>", "classes": []}, "name": "search", "params": [{"name": "g", "type": "R"}, {"name": "intersects", "type": "Func2<? super S, ? super R, Boolean>"}], "body": "                                                                                                                      {\n        return search(g.mbr()).filter(entry -> intersects.call(entry.geometry(), g));\n    }", "signature": "public <R extends Geometry> Observable<Entry<T, S>> search(final R g,\n                                                               final Func2<? super S, ? super R, Boolean> intersects)"}, {"syntax_pass": true, "original_string": "    public <R extends Geometry> Observable<Entry<T, S>> search(final R g, final double maxDistance,\n        final Func2<? super S, ? super R, Double> distance) {\n        // just use the mbr initially\n        return search(entry -> entry.distance(g.mbr()) < maxDistance)\n                // refine with distance function\n                .filter(entry -> distance.call(entry.geometry(), g) < maxDistance);\n    }", "docstring": "\nReturns all entries strictly less than <code>maxDistance</code> from the\ngiven geometry. Because the geometry may be of an arbitrary type it is\nnecessary to also pass a distance function.\n\n@param <R>\n           type of the geometry being searched for\n@param g\n           geometry to search for entries within maxDistance of\n@param maxDistance\n           strict max distance that entries must be from g\n@param distance\n           function to calculate the distance between geometries of type S\n           and R.\n@return entries strictly less than maxDistance from g\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Observable<Entry<T, S>>", "classes": []}, "name": "search", "params": [{"name": "g", "type": "R"}, {"name": "maxDistance", "type": "double"}, {"name": "distance", "type": "Func2<? super S, ? super R, Double>"}], "body": "                                                            {\n        // just use the mbr initially\n        return search(entry -> entry.distance(g.mbr()) < maxDistance)\n                // refine with distance function\n                .filter(entry -> distance.call(entry.geometry(), g) < maxDistance);\n    }", "signature": "public <R extends Geometry> Observable<Entry<T, S>> search(final R g, final double maxDistance,\n        final Func2<? super S, ? super R, Double> distance)"}, {"syntax_pass": true, "original_string": "    public Observable<Entry<T, S>> search(final Point p, final double maxDistance) {\n        return search(p.mbr(), maxDistance);\n    }", "docstring": "\nReturns an {@link Observable} sequence of all {@link Entry}s in the R-tree\nwhose minimum bounding rectangles are within maxDistance from the given\npoint.\n\n@param p\n           point to measure distance from\n@param maxDistance\n           entries returned must be within this distance from point p\n@return the sequence of matching entries\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Observable<Entry<T, S>>", "classes": []}, "name": "search", "params": [{"name": "p", "type": "Point"}, {"name": "maxDistance", "type": "double"}], "body": "                                                                                   {\n        return search(p.mbr(), maxDistance);\n    }", "signature": "public Observable<Entry<T, S>> search(final Point p, final double maxDistance)"}, {"syntax_pass": true, "original_string": "    public Observable<Entry<T, S>> nearest(final Rectangle r, final double maxDistance,\n            int maxCount) {\n        return search(r, maxDistance).lift(new OperatorBoundedPriorityQueue<Entry<T, S>>(maxCount,\n                Comparators.<T, S>ascendingDistance(r)));\n    }", "docstring": "\nReturns the nearest k entries (k=maxCount) to the given rectangle where the\nentries are strictly less than a given maximum distance from the rectangle.\n\n@param r\n           rectangle\n@param maxDistance\n           max distance of returned entries from the rectangle\n@param maxCount\n           max number of entries to return\n@return nearest entries to maxCount, in ascending order of distance\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Observable<Entry<T, S>>", "classes": []}, "name": "nearest", "params": [{"name": "r", "type": "Rectangle"}, {"name": "maxDistance", "type": "double"}, {"name": "maxCount", "type": "int"}], "body": "                          {\n        return search(r, maxDistance).lift(new OperatorBoundedPriorityQueue<Entry<T, S>>(maxCount,\n                Comparators.<T, S>ascendingDistance(r)));\n    }", "signature": "public Observable<Entry<T, S>> nearest(final Rectangle r, final double maxDistance,\n            int maxCount)"}, {"syntax_pass": true, "original_string": "    public Observable<Entry<T, S>> nearest(final Point p, final double maxDistance, int maxCount) {\n        return nearest(p.mbr(), maxDistance, maxCount);\n    }", "docstring": "\nReturns the nearest k entries (k=maxCount) to the given point where the\nentries are strictly less than a given maximum distance from the point.\n\n@param p\n           point\n@param maxDistance\n           max distance of returned entries from the point\n@param maxCount\n           max number of entries to return\n@return nearest entries to maxCount, in ascending order of distance\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Observable<Entry<T, S>>", "classes": []}, "name": "nearest", "params": [{"name": "p", "type": "Point"}, {"name": "maxDistance", "type": "double"}, {"name": "maxCount", "type": "int"}], "body": "                                                                                                  {\n        return nearest(p.mbr(), maxDistance, maxCount);\n    }", "signature": "public Observable<Entry<T, S>> nearest(final Point p, final double maxDistance, int maxCount)"}, {"syntax_pass": true, "original_string": "    public Observable<Entry<T, S>> entries() {\n        return search(ALWAYS_TRUE);\n    }", "docstring": "\nReturns all entries in the tree as an {@link Observable} sequence.\n\n@return all entries in the R-tree\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Observable<Entry<T, S>>", "classes": []}, "name": "entries", "params": [], "body": "                                             {\n        return search(ALWAYS_TRUE);\n    }", "signature": "public Observable<Entry<T, S>> entries()"}, {"syntax_pass": true, "original_string": "    @SuppressWarnings(\"unchecked\")\n    public Visualizer visualize(int width, int height, Rectangle view) {\n        return new Visualizer((RTree<?, Geometry>) this, width, height, view);\n    }", "docstring": "\nReturns a {@link Visualizer} for an image of given width and height and\nrestricted to the given view of the coordinates. The points in the view are\nscaled to match the aspect ratio defined by the width and height.\n\n@param width\n           of the image in pixels\n@param height\n           of the image in pixels\n@param view\n           using the coordinate system of the entries\n@return visualizer\n", "attributes": {"modifiers": "@SuppressWarnings(\"unchecked\")\n    public", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings(\"unchecked\")", "public"], "comments": [], "return_type": "Visualizer", "classes": []}, "name": "visualize", "params": [{"name": "width", "type": "int"}, {"name": "height", "type": "int"}, {"name": "view", "type": "Rectangle"}], "body": "                                                                       {\n        return new Visualizer((RTree<?, Geometry>) this, width, height, view);\n    }", "signature": "@SuppressWarnings(\"unchecked\")\n    public Visualizer visualize(int width, int height, Rectangle view)"}, {"syntax_pass": true, "original_string": "    public Visualizer visualize(int width, int height) {\n        return visualize(width, height, calculateMaxView(this));\n    }", "docstring": "\nReturns a {@link Visualizer} for an image of given width and height and\nrestricted to the the smallest view that fully contains the coordinates. The\npoints in the view are scaled to match the aspect ratio defined by the width\nand height.\n\n@param width\n           of the image in pixels\n@param height\n           of the image in pixels\n@return visualizer\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Visualizer", "classes": []}, "name": "visualize", "params": [{"name": "width", "type": "int"}, {"name": "height", "type": "int"}], "body": "                                                       {\n        return visualize(width, height, calculateMaxView(this));\n    }", "signature": "public Visualizer visualize(int width, int height)"}, {"syntax_pass": true, "original_string": "    private Rectangle calculateMaxView(RTree<T, S> tree) {\n        @SuppressWarnings(\"unchecked\")\n        Func2<Optional<Rectangle>, Entry<T, S>, Optional<Rectangle>> ra = //\n                (Func2<Optional<Rectangle>, Entry<T, S>, Optional<Rectangle>>) //\n                (Func2<?,?,?>) //\n                RECTANGLE_ACCUMULATOR;\n        return tree.entries()\n                .reduce(Optional.empty(), ra)\n                .toBlocking().single()\n                .orElse(ZERO_RECTANGLE);\n    }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "Rectangle", "classes": []}, "name": "calculateMaxView", "params": [{"name": "tree", "type": "RTree<T, S>"}], "body": "                                                         {\n        @SuppressWarnings(\"unchecked\")\n        Func2<Optional<Rectangle>, Entry<T, S>, Optional<Rectangle>> ra = //\n                (Func2<Optional<Rectangle>, Entry<T, S>, Optional<Rectangle>>) //\n                (Func2<?,?,?>) //\n                RECTANGLE_ACCUMULATOR;\n        return tree.entries()\n                .reduce(Optional.empty(), ra)\n                .toBlocking().single()\n                .orElse(ZERO_RECTANGLE);\n    }", "signature": "private Rectangle calculateMaxView(RTree<T, S> tree)"}, {"syntax_pass": true, "original_string": "    public Optional<? extends Node<T, S>> root() {\n        return root;\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Optional<? extends Node<T, S>>", "classes": []}, "name": "root", "params": [], "body": "                                                 {\n        return root;\n    }", "signature": "public Optional<? extends Node<T, S>> root()"}, {"syntax_pass": true, "original_string": "    public Optional<Rectangle> mbr() {\n        return root.map(r -> r.geometry().mbr());\n    }", "docstring": "\nIf the RTree has no entries returns {@link Optional#absent} otherwise returns\nthe minimum bounding rectangle of all entries in the RTree.\n\n@return minimum bounding rectangle of all entries in RTree\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Optional<Rectangle>", "classes": []}, "name": "mbr", "params": [], "body": "                                     {\n        return root.map(r -> r.geometry().mbr());\n    }", "signature": "public Optional<Rectangle> mbr()"}, {"syntax_pass": true, "original_string": "    public boolean isEmpty() {\n        return size == 0;\n    }", "docstring": "\nReturns true if and only if the R-tree is empty of entries.\n\n@return is R-tree empty\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isEmpty", "params": [], "body": "                             {\n        return size == 0;\n    }", "signature": "public boolean isEmpty()"}, {"syntax_pass": true, "original_string": "    public int size() {\n        return size;\n    }", "docstring": "\nReturns the number of entries in the RTree.\n\n@return the number of entries\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "size", "params": [], "body": "                      {\n        return size;\n    }", "signature": "public int size()"}, {"syntax_pass": true, "original_string": "    public Context<T, S> context() {\n        return context;\n    }", "docstring": "\nReturns a {@link Context} containing the configuration of the RTree at the\ntime of instantiation.\n\n@return the configuration of the RTree prior to instantiation\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Context<T, S>", "classes": []}, "name": "context", "params": [], "body": "                                   {\n        return context;\n    }", "signature": "public Context<T, S> context()"}, {"syntax_pass": true, "original_string": "    public String asString() {\n        if (!root.isPresent())\n            return \"\";\n        else\n            return asString(root.get(), \"\");\n    }", "docstring": "\nReturns a human readable form of the RTree. Here's an example:\n\n<pre>\nmbr=Rectangle [x1=10.0, y1=4.0, x2=62.0, y2=85.0]\n  mbr=Rectangle [x1=28.0, y1=4.0, x2=34.0, y2=85.0]\n    entry=Entry [value=2, geometry=Point [x=29.0, y=4.0]]\n    entry=Entry [value=1, geometry=Point [x=28.0, y=19.0]]\n    entry=Entry [value=4, geometry=Point [x=34.0, y=85.0]]\n  mbr=Rectangle [x1=10.0, y1=45.0, x2=62.0, y2=63.0]\n    entry=Entry [value=5, geometry=Point [x=62.0, y=45.0]]\n    entry=Entry [value=3, geometry=Point [x=10.0, y=63.0]]\n</pre>\n\n@return a string representation of the RTree\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "asString", "params": [], "body": "                             {\n        if (!root.isPresent())\n            return \"\";\n        else\n            return asString(root.get(), \"\");\n    }", "signature": "public String asString()"}, {"syntax_pass": true, "original_string": "    private String asString(Node<T, S> node, String margin) {\n        StringBuilder s = new StringBuilder();\n        s.append(margin);\n        s.append(\"mbr=\");\n        s.append(node.geometry());\n        s.append('\\n');\n        if (node instanceof NonLeaf) {\n            NonLeaf<T, S> n = (NonLeaf<T, S>) node;\n            for (int i = 0; i < n.count(); i++) {\n                Node<T, S> child = n.child(i);\n                s.append(asString(child, margin + MARGIN_INCREMENT));\n            }\n        } else {\n            Leaf<T, S> leaf = (Leaf<T, S>) node;\n\n            for (Entry<T, S> entry : leaf.entries()) {\n                s.append(margin);\n                s.append(MARGIN_INCREMENT);\n                s.append(\"entry=\");\n                s.append(entry);\n                s.append('\\n');\n            }\n        }\n        return s.toString();\n    }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "String", "classes": []}, "name": "asString", "params": [{"name": "node", "type": "Node<T, S>"}, {"name": "margin", "type": "String"}], "body": "                                                            {\n        StringBuilder s = new StringBuilder();\n        s.append(margin);\n        s.append(\"mbr=\");\n        s.append(node.geometry());\n        s.append('\\n');\n        if (node instanceof NonLeaf) {\n            NonLeaf<T, S> n = (NonLeaf<T, S>) node;\n            for (int i = 0; i < n.count(); i++) {\n                Node<T, S> child = n.child(i);\n                s.append(asString(child, margin + MARGIN_INCREMENT));\n            }\n        } else {\n            Leaf<T, S> leaf = (Leaf<T, S>) node;\n\n            for (Entry<T, S> entry : leaf.entries()) {\n                s.append(margin);\n                s.append(MARGIN_INCREMENT);\n                s.append(\"entry=\");\n                s.append(entry);\n                s.append('\\n');\n            }\n        }\n        return s.toString();\n    }", "signature": "private String asString(Node<T, S> node, String margin)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/com/github/davidmoten/rtree/NonLeaf.java", "original_string": "package com.github.davidmoten.rtree;\n\nimport java.util.List;\n\nimport com.github.davidmoten.rtree.geometry.Geometry;\n\npublic interface NonLeaf<T, S extends Geometry> extends Node<T, S> {\n\n    Node<T, S> child(int i);\n\n    /**\n     * Returns a list of children nodes. For accessing individual children the\n     * child(int) method should be used to ensure good performance. To avoid\n     * copying an existing list though this method can be used.\n     * \n     * @return list of children nodes\n     */\n    List<Node<T, S>> children();\n\n}", "file_hash": "393e0af6fc8d303110607d7ca7b50703c35ceb4cd9f27d1412ab95c91afad6cf", "file_docstring": "", "contexts": ["package com.github.davidmoten.rtree;", "import java.util.List;", "import com.github.davidmoten.rtree.geometry.Geometry;"], "methods": [], "classes": [], "interfaces": [{"original_string": "public interface NonLeaf<T, S extends Geometry> extends Node<T, S> {\n\n    Node<T, S> child(int i);\n\n    /**\n     * Returns a list of children nodes. For accessing individual children the\n     * child(int) method should be used to ensure good performance. To avoid\n     * copying an existing list though this method can be used.\n     * \n     * @return list of children nodes\n     */\n    List<Node<T, S>> children();\n\n}", "definition": "public interface NonLeaf<T, S extends Geometry> extends Node<T, S>", "interface_docstring": "", "name": "NonLeaf", "extends_interfaces": ["Node<T, S>"], "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    Node<T, S> child(int i);", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "Node<T, S>", "classes": []}, "name": "child", "params": [{"name": "i", "type": "int"}], "body": "", "signature": "Node<T, S> child(int i)"}, {"syntax_pass": true, "original_string": "    List<Node<T, S>> children();", "docstring": "\nReturns a list of children nodes. For accessing individual children the\nchild(int) method should be used to ensure good performance. To avoid\ncopying an existing list though this method can be used.\n\n@return list of children nodes\n", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "List<Node<T, S>>", "classes": []}, "name": "children", "params": [], "body": "", "signature": "List<Node<T, S>> children()"}]}], "records": []}, {"relative_path": "src/main/java/com/github/davidmoten/rtree/fbs/SerializerFlatBuffers.java", "original_string": "package com.github.davidmoten.rtree.fbs;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.nio.ByteBuffer;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Optional;\n\nimport com.github.davidmoten.guavamini.annotations.VisibleForTesting;\nimport com.github.davidmoten.rtree.Context;\nimport com.github.davidmoten.rtree.Entry;\nimport com.github.davidmoten.rtree.InternalStructure;\nimport com.github.davidmoten.rtree.Leaf;\nimport com.github.davidmoten.rtree.Node;\nimport com.github.davidmoten.rtree.NonLeaf;\nimport com.github.davidmoten.rtree.RTree;\nimport com.github.davidmoten.rtree.SelectorRStar;\nimport com.github.davidmoten.rtree.Serializer;\nimport com.github.davidmoten.rtree.SerializerHelper;\nimport com.github.davidmoten.rtree.SplitterRStar;\nimport com.github.davidmoten.rtree.fbs.generated.BoundsType_;\nimport com.github.davidmoten.rtree.fbs.generated.Bounds_;\nimport com.github.davidmoten.rtree.fbs.generated.BoxDouble_;\nimport com.github.davidmoten.rtree.fbs.generated.BoxFloat_;\nimport com.github.davidmoten.rtree.fbs.generated.Context_;\nimport com.github.davidmoten.rtree.fbs.generated.Node_;\nimport com.github.davidmoten.rtree.fbs.generated.Tree_;\nimport com.github.davidmoten.rtree.geometry.Geometries;\nimport com.github.davidmoten.rtree.geometry.Geometry;\nimport com.github.davidmoten.rtree.geometry.Rectangle;\nimport com.github.davidmoten.rtree.internal.LeafDefault;\nimport com.github.davidmoten.rtree.internal.NonLeafDefault;\nimport com.google.flatbuffers.FlatBufferBuilder;\n\nimport rx.functions.Func1;\n\npublic final class SerializerFlatBuffers<T, S extends Geometry> implements Serializer<T, S> {\n\n    private final FactoryFlatBuffers<T, S> factory;\n\n    private SerializerFlatBuffers(Func1<? super T, byte[]> serializer,\n            Func1<byte[], ? extends T> deserializer) {\n        this.factory = new FactoryFlatBuffers<T, S>(serializer, deserializer);\n    }\n\n    public static <T, S extends Geometry> Serializer<T, S> create(\n            Func1<? super T, byte[]> serializer, Func1<byte[], ? extends T> deserializer) {\n        return new SerializerFlatBuffers<T, S>(serializer, deserializer);\n    }\n\n    @Override\n    public void write(RTree<T, S> tree, OutputStream os) throws IOException {\n        FlatBufferBuilder builder = new FlatBufferBuilder();\n        final Rectangle mbb;\n        if (tree.root().isPresent()) {\n            mbb = tree.root().get().geometry().mbr();\n        } else {\n            mbb = Geometries.rectangle(0, 0, 0, 0);\n        }\n        int b = toBounds(builder, mbb);\n        Context_.startContext_(builder);\n        Context_.addBounds(builder, b);\n        Context_.addMinChildren(builder, tree.context().minChildren());\n        Context_.addMaxChildren(builder, tree.context().maxChildren());\n        int c = Context_.endContext_(builder);\n        final int n;\n        if (tree.root().isPresent()) {\n            n = addNode(tree.root().get(), builder, factory.serializer());\n        } else {\n            // won't be used\n            n = 0;\n        }\n        // int t = Tree_.createTree_(builder, c, n, tree.size());\n        Tree_.startTree_(builder);\n        Tree_.addContext(builder, c);\n        Tree_.addSize(builder, tree.size());\n        if (tree.size() > 0) {\n            Tree_.addRoot(builder, n);\n        }\n        int t = Tree_.endTree_(builder);\n        Tree_.finishTree_Buffer(builder, t);\n\n        ByteBuffer bb = builder.dataBuffer();\n        os.write(bb.array(), bb.position(), bb.remaining());\n    }\n\n    private static int toBounds(FlatBufferBuilder builder, final Rectangle r) {\n        Bounds_.startBounds_(builder);\n        if (r.isDoublePrecision()) {\n            Bounds_.addType(builder, BoundsType_.BoundsDouble);\n            int box = BoxDouble_.createBoxDouble_(builder, r.x1(), r.y1(), r.x2(), r.y2());\n            Bounds_.addBoxDouble(builder, box);\n        } else {\n            Bounds_.addType(builder, BoundsType_.BoundsFloat);\n            int box = BoxFloat_.createBoxFloat_(builder, (float) r.x1(), (float) r.y1(),\n                    (float) r.x2(), (float) r.y2());\n            Bounds_.addBoxFloat(builder, box);\n        }\n        return Bounds_.endBounds_(builder);\n    }\n\n    private static <T, S extends Geometry> int addNode(Node<T, S> node, FlatBufferBuilder builder,\n            Func1<? super T, byte[]> serializer) {\n        if (node instanceof Leaf) {\n            Leaf<T, S> leaf = (Leaf<T, S>) node;\n            return FlatBuffersHelper.addEntries(leaf.entries(), builder, serializer);\n        } else {\n            NonLeaf<T, S> nonLeaf = (NonLeaf<T, S>) node;\n            int[] nodes = new int[nonLeaf.count()];\n            for (int i = 0; i < nonLeaf.count(); i++) {\n                Node<T, S> child = nonLeaf.child(i);\n                nodes[i] = addNode(child, builder, serializer);\n            }\n            int ch = Node_.createChildrenVector(builder, nodes);\n            Rectangle mbb = nonLeaf.geometry().mbr();\n            int b = toBounds(builder, mbb);\n            Node_.startNode_(builder);\n            Node_.addChildren(builder, ch);\n            Node_.addMbb(builder, b);\n            return Node_.endNode_(builder);\n        }\n    }\n\n    @Override\n    public RTree<T, S> read(InputStream is, long sizeBytes, InternalStructure structure)\n            throws IOException {\n        byte[] bytes = readFully(is, (int) sizeBytes);\n        Tree_ t = Tree_.getRootAsTree_(ByteBuffer.wrap(bytes));\n        Context<T, S> context = new Context<T, S>(t.context().minChildren(),\n                t.context().maxChildren(), new SelectorRStar(), new SplitterRStar(), factory);\n        Node_ node = t.root();\n        if (node == null) {\n            return SerializerHelper.create(Optional.empty(), 0, context);\n        } else {\n            final Node<T, S> root;\n            if (structure == InternalStructure.SINGLE_ARRAY) {\n                if (node.childrenLength() > 0) {\n                    root = new NonLeafFlatBuffers<T, S>(node, context, factory.deserializer());\n                } else {\n                    root = new LeafFlatBuffers<T, S>(node, context, factory.deserializer());\n                }\n            } else {\n                root = toNodeDefault(node, context, factory.deserializer());\n            }\n            return SerializerHelper.create(Optional.of(root), (int) t.size(), context);\n        }\n    }\n\n    private static <T, S extends Geometry> Node<T, S> toNodeDefault(Node_ node,\n            Context<T, S> context, Func1<byte[], ? extends T> deserializer) {\n        int numChildren = node.childrenLength();\n        if (numChildren > 0) {\n            List<Node<T, S>> children = new ArrayList<Node<T, S>>(numChildren);\n            for (int i = 0; i < numChildren; i++) {\n                children.add(toNodeDefault(node.children(i), context, deserializer));\n            }\n            return new NonLeafDefault<T, S>(children, context);\n        } else {\n            List<Entry<T, S>> entries = FlatBuffersHelper.createEntries(node, deserializer);\n            return new LeafDefault<T, S>(entries, context);\n        }\n    }\n\n    @VisibleForTesting\n    static byte[] readFully(InputStream is, int numBytes) throws IOException {\n        byte[] b = new byte[numBytes];\n        int count = 0;\n        do {\n            int n = is.read(b, count, numBytes - count);\n            if (n > 0) {\n                count += n;\n            } else {\n                throw new RuntimeException(\"unexpected\");\n            }\n        } while (count < numBytes);\n        return b;\n    }\n\n}\n", "file_hash": "e3e35e026bfc744baf9bc201dafab343f39d703bf77116c97ed1ab5f1cdbb4a5", "file_docstring": "", "contexts": ["package com.github.davidmoten.rtree.fbs;", "import java.io.IOException;", "import java.io.InputStream;", "import java.io.OutputStream;", "import java.nio.ByteBuffer;", "import java.util.ArrayList;", "import java.util.List;", "import java.util.Optional;", "import com.github.davidmoten.guavamini.annotations.VisibleForTesting;", "import com.github.davidmoten.rtree.Context;", "import com.github.davidmoten.rtree.Entry;", "import com.github.davidmoten.rtree.InternalStructure;", "import com.github.davidmoten.rtree.Leaf;", "import com.github.davidmoten.rtree.Node;", "import com.github.davidmoten.rtree.NonLeaf;", "import com.github.davidmoten.rtree.RTree;", "import com.github.davidmoten.rtree.SelectorRStar;", "import com.github.davidmoten.rtree.Serializer;", "import com.github.davidmoten.rtree.SerializerHelper;", "import com.github.davidmoten.rtree.SplitterRStar;", "import com.github.davidmoten.rtree.fbs.generated.BoundsType_;", "import com.github.davidmoten.rtree.fbs.generated.Bounds_;", "import com.github.davidmoten.rtree.fbs.generated.BoxDouble_;", "import com.github.davidmoten.rtree.fbs.generated.BoxFloat_;", "import com.github.davidmoten.rtree.fbs.generated.Context_;", "import com.github.davidmoten.rtree.fbs.generated.Node_;", "import com.github.davidmoten.rtree.fbs.generated.Tree_;", "import com.github.davidmoten.rtree.geometry.Geometries;", "import com.github.davidmoten.rtree.geometry.Geometry;", "import com.github.davidmoten.rtree.geometry.Rectangle;", "import com.github.davidmoten.rtree.internal.LeafDefault;", "import com.github.davidmoten.rtree.internal.NonLeafDefault;", "import com.google.flatbuffers.FlatBufferBuilder;", "import rx.functions.Func1;"], "methods": [], "classes": [{"original_string": "public final class SerializerFlatBuffers<T, S extends Geometry> implements Serializer<T, S> {\n\n    private final FactoryFlatBuffers<T, S> factory;\n\n    private SerializerFlatBuffers(Func1<? super T, byte[]> serializer,\n            Func1<byte[], ? extends T> deserializer) {\n        this.factory = new FactoryFlatBuffers<T, S>(serializer, deserializer);\n    }\n\n    public static <T, S extends Geometry> Serializer<T, S> create(\n            Func1<? super T, byte[]> serializer, Func1<byte[], ? extends T> deserializer) {\n        return new SerializerFlatBuffers<T, S>(serializer, deserializer);\n    }\n\n    @Override\n    public void write(RTree<T, S> tree, OutputStream os) throws IOException {\n        FlatBufferBuilder builder = new FlatBufferBuilder();\n        final Rectangle mbb;\n        if (tree.root().isPresent()) {\n            mbb = tree.root().get().geometry().mbr();\n        } else {\n            mbb = Geometries.rectangle(0, 0, 0, 0);\n        }\n        int b = toBounds(builder, mbb);\n        Context_.startContext_(builder);\n        Context_.addBounds(builder, b);\n        Context_.addMinChildren(builder, tree.context().minChildren());\n        Context_.addMaxChildren(builder, tree.context().maxChildren());\n        int c = Context_.endContext_(builder);\n        final int n;\n        if (tree.root().isPresent()) {\n            n = addNode(tree.root().get(), builder, factory.serializer());\n        } else {\n            // won't be used\n            n = 0;\n        }\n        // int t = Tree_.createTree_(builder, c, n, tree.size());\n        Tree_.startTree_(builder);\n        Tree_.addContext(builder, c);\n        Tree_.addSize(builder, tree.size());\n        if (tree.size() > 0) {\n            Tree_.addRoot(builder, n);\n        }\n        int t = Tree_.endTree_(builder);\n        Tree_.finishTree_Buffer(builder, t);\n\n        ByteBuffer bb = builder.dataBuffer();\n        os.write(bb.array(), bb.position(), bb.remaining());\n    }\n\n    private static int toBounds(FlatBufferBuilder builder, final Rectangle r) {\n        Bounds_.startBounds_(builder);\n        if (r.isDoublePrecision()) {\n            Bounds_.addType(builder, BoundsType_.BoundsDouble);\n            int box = BoxDouble_.createBoxDouble_(builder, r.x1(), r.y1(), r.x2(), r.y2());\n            Bounds_.addBoxDouble(builder, box);\n        } else {\n            Bounds_.addType(builder, BoundsType_.BoundsFloat);\n            int box = BoxFloat_.createBoxFloat_(builder, (float) r.x1(), (float) r.y1(),\n                    (float) r.x2(), (float) r.y2());\n            Bounds_.addBoxFloat(builder, box);\n        }\n        return Bounds_.endBounds_(builder);\n    }\n\n    private static <T, S extends Geometry> int addNode(Node<T, S> node, FlatBufferBuilder builder,\n            Func1<? super T, byte[]> serializer) {\n        if (node instanceof Leaf) {\n            Leaf<T, S> leaf = (Leaf<T, S>) node;\n            return FlatBuffersHelper.addEntries(leaf.entries(), builder, serializer);\n        } else {\n            NonLeaf<T, S> nonLeaf = (NonLeaf<T, S>) node;\n            int[] nodes = new int[nonLeaf.count()];\n            for (int i = 0; i < nonLeaf.count(); i++) {\n                Node<T, S> child = nonLeaf.child(i);\n                nodes[i] = addNode(child, builder, serializer);\n            }\n            int ch = Node_.createChildrenVector(builder, nodes);\n            Rectangle mbb = nonLeaf.geometry().mbr();\n            int b = toBounds(builder, mbb);\n            Node_.startNode_(builder);\n            Node_.addChildren(builder, ch);\n            Node_.addMbb(builder, b);\n            return Node_.endNode_(builder);\n        }\n    }\n\n    @Override\n    public RTree<T, S> read(InputStream is, long sizeBytes, InternalStructure structure)\n            throws IOException {\n        byte[] bytes = readFully(is, (int) sizeBytes);\n        Tree_ t = Tree_.getRootAsTree_(ByteBuffer.wrap(bytes));\n        Context<T, S> context = new Context<T, S>(t.context().minChildren(),\n                t.context().maxChildren(), new SelectorRStar(), new SplitterRStar(), factory);\n        Node_ node = t.root();\n        if (node == null) {\n            return SerializerHelper.create(Optional.empty(), 0, context);\n        } else {\n            final Node<T, S> root;\n            if (structure == InternalStructure.SINGLE_ARRAY) {\n                if (node.childrenLength() > 0) {\n                    root = new NonLeafFlatBuffers<T, S>(node, context, factory.deserializer());\n                } else {\n                    root = new LeafFlatBuffers<T, S>(node, context, factory.deserializer());\n                }\n            } else {\n                root = toNodeDefault(node, context, factory.deserializer());\n            }\n            return SerializerHelper.create(Optional.of(root), (int) t.size(), context);\n        }\n    }\n\n    private static <T, S extends Geometry> Node<T, S> toNodeDefault(Node_ node,\n            Context<T, S> context, Func1<byte[], ? extends T> deserializer) {\n        int numChildren = node.childrenLength();\n        if (numChildren > 0) {\n            List<Node<T, S>> children = new ArrayList<Node<T, S>>(numChildren);\n            for (int i = 0; i < numChildren; i++) {\n                children.add(toNodeDefault(node.children(i), context, deserializer));\n            }\n            return new NonLeafDefault<T, S>(children, context);\n        } else {\n            List<Entry<T, S>> entries = FlatBuffersHelper.createEntries(node, deserializer);\n            return new LeafDefault<T, S>(entries, context);\n        }\n    }\n\n    @VisibleForTesting\n    static byte[] readFully(InputStream is, int numBytes) throws IOException {\n        byte[] b = new byte[numBytes];\n        int count = 0;\n        do {\n            int n = is.read(b, count, numBytes - count);\n            if (n > 0) {\n                count += n;\n            } else {\n                throw new RuntimeException(\"unexpected\");\n            }\n        } while (count < numBytes);\n        return b;\n    }\n\n}", "definition": "public final class SerializerFlatBuffers<T, S extends Geometry> implements Serializer<T, S>", "class_docstring": "", "name": "SerializerFlatBuffers", "super_interfaces": ["Serializer<T, S>"], "superclasses": "", "attributes": {"modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "fields": [{"attribute_expression": "private final FactoryFlatBuffers<T, S> factory;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "FactoryFlatBuffers<T, S>", "name": "factory", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    private SerializerFlatBuffers(Func1<? super T, byte[]> serializer,\n            Func1<byte[], ? extends T> deserializer) {\n        this.factory = new FactoryFlatBuffers<T, S>(serializer, deserializer);\n    }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "", "classes": []}, "name": "SerializerFlatBuffers", "params": [{"name": "serializer", "type": "Func1<? super T, byte[]>"}, {"name": "deserializer", "type": "Func1<byte[], ? extends T>"}], "body": "                                                     {\n        this.factory = new FactoryFlatBuffers<T, S>(serializer, deserializer);\n    }", "signature": "private SerializerFlatBuffers(Func1<? super T, byte[]> serializer,\n            Func1<byte[], ? extends T> deserializer)"}, {"syntax_pass": true, "original_string": "    public static <T, S extends Geometry> Serializer<T, S> create(\n            Func1<? super T, byte[]> serializer, Func1<byte[], ? extends T> deserializer) {\n        return new SerializerFlatBuffers<T, S>(serializer, deserializer);\n    }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Serializer<T, S>", "classes": []}, "name": "create", "params": [{"name": "serializer", "type": "Func1<? super T, byte[]>"}, {"name": "deserializer", "type": "Func1<byte[], ? extends T>"}], "body": "                                                                                          {\n        return new SerializerFlatBuffers<T, S>(serializer, deserializer);\n    }", "signature": "public static <T, S extends Geometry> Serializer<T, S> create(\n            Func1<? super T, byte[]> serializer, Func1<byte[], ? extends T> deserializer)"}, {"syntax_pass": true, "original_string": "    @Override\n    public void write(RTree<T, S> tree, OutputStream os) throws IOException {\n        FlatBufferBuilder builder = new FlatBufferBuilder();\n        final Rectangle mbb;\n        if (tree.root().isPresent()) {\n            mbb = tree.root().get().geometry().mbr();\n        } else {\n            mbb = Geometries.rectangle(0, 0, 0, 0);\n        }\n        int b = toBounds(builder, mbb);\n        Context_.startContext_(builder);\n        Context_.addBounds(builder, b);\n        Context_.addMinChildren(builder, tree.context().minChildren());\n        Context_.addMaxChildren(builder, tree.context().maxChildren());\n        int c = Context_.endContext_(builder);\n        final int n;\n        if (tree.root().isPresent()) {\n            n = addNode(tree.root().get(), builder, factory.serializer());\n        } else {\n            // won't be used\n            n = 0;\n        }\n        // int t = Tree_.createTree_(builder, c, n, tree.size());\n        Tree_.startTree_(builder);\n        Tree_.addContext(builder, c);\n        Tree_.addSize(builder, tree.size());\n        if (tree.size() > 0) {\n            Tree_.addRoot(builder, n);\n        }\n        int t = Tree_.endTree_(builder);\n        Tree_.finishTree_Buffer(builder, t);\n\n        ByteBuffer bb = builder.dataBuffer();\n        os.write(bb.array(), bb.position(), bb.remaining());\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "write", "params": [{"name": "tree", "type": "RTree<T, S>"}, {"name": "os", "type": "OutputStream"}], "body": "                                                                            {\n        FlatBufferBuilder builder = new FlatBufferBuilder();\n        final Rectangle mbb;\n        if (tree.root().isPresent()) {\n            mbb = tree.root().get().geometry().mbr();\n        } else {\n            mbb = Geometries.rectangle(0, 0, 0, 0);\n        }\n        int b = toBounds(builder, mbb);\n        Context_.startContext_(builder);\n        Context_.addBounds(builder, b);\n        Context_.addMinChildren(builder, tree.context().minChildren());\n        Context_.addMaxChildren(builder, tree.context().maxChildren());\n        int c = Context_.endContext_(builder);\n        final int n;\n        if (tree.root().isPresent()) {\n            n = addNode(tree.root().get(), builder, factory.serializer());\n        } else {\n            // won't be used\n            n = 0;\n        }\n        // int t = Tree_.createTree_(builder, c, n, tree.size());\n        Tree_.startTree_(builder);\n        Tree_.addContext(builder, c);\n        Tree_.addSize(builder, tree.size());\n        if (tree.size() > 0) {\n            Tree_.addRoot(builder, n);\n        }\n        int t = Tree_.endTree_(builder);\n        Tree_.finishTree_Buffer(builder, t);\n\n        ByteBuffer bb = builder.dataBuffer();\n        os.write(bb.array(), bb.position(), bb.remaining());\n    }", "signature": "@Override\n    public void write(RTree<T, S> tree, OutputStream os)"}, {"syntax_pass": true, "original_string": "    private static int toBounds(FlatBufferBuilder builder, final Rectangle r) {\n        Bounds_.startBounds_(builder);\n        if (r.isDoublePrecision()) {\n            Bounds_.addType(builder, BoundsType_.BoundsDouble);\n            int box = BoxDouble_.createBoxDouble_(builder, r.x1(), r.y1(), r.x2(), r.y2());\n            Bounds_.addBoxDouble(builder, box);\n        } else {\n            Bounds_.addType(builder, BoundsType_.BoundsFloat);\n            int box = BoxFloat_.createBoxFloat_(builder, (float) r.x1(), (float) r.y1(),\n                    (float) r.x2(), (float) r.y2());\n            Bounds_.addBoxFloat(builder, box);\n        }\n        return Bounds_.endBounds_(builder);\n    }", "docstring": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "int", "classes": []}, "name": "toBounds", "params": [{"name": "builder", "type": "FlatBufferBuilder"}, {"name": "r", "type": "Rectangle"}], "body": "                                                                              {\n        Bounds_.startBounds_(builder);\n        if (r.isDoublePrecision()) {\n            Bounds_.addType(builder, BoundsType_.BoundsDouble);\n            int box = BoxDouble_.createBoxDouble_(builder, r.x1(), r.y1(), r.x2(), r.y2());\n            Bounds_.addBoxDouble(builder, box);\n        } else {\n            Bounds_.addType(builder, BoundsType_.BoundsFloat);\n            int box = BoxFloat_.createBoxFloat_(builder, (float) r.x1(), (float) r.y1(),\n                    (float) r.x2(), (float) r.y2());\n            Bounds_.addBoxFloat(builder, box);\n        }\n        return Bounds_.endBounds_(builder);\n    }", "signature": "private static int toBounds(FlatBufferBuilder builder, final Rectangle r)"}, {"syntax_pass": true, "original_string": "    private static <T, S extends Geometry> int addNode(Node<T, S> node, FlatBufferBuilder builder,\n            Func1<? super T, byte[]> serializer) {\n        if (node instanceof Leaf) {\n            Leaf<T, S> leaf = (Leaf<T, S>) node;\n            return FlatBuffersHelper.addEntries(leaf.entries(), builder, serializer);\n        } else {\n            NonLeaf<T, S> nonLeaf = (NonLeaf<T, S>) node;\n            int[] nodes = new int[nonLeaf.count()];\n            for (int i = 0; i < nonLeaf.count(); i++) {\n                Node<T, S> child = nonLeaf.child(i);\n                nodes[i] = addNode(child, builder, serializer);\n            }\n            int ch = Node_.createChildrenVector(builder, nodes);\n            Rectangle mbb = nonLeaf.geometry().mbr();\n            int b = toBounds(builder, mbb);\n            Node_.startNode_(builder);\n            Node_.addChildren(builder, ch);\n            Node_.addMbb(builder, b);\n            return Node_.endNode_(builder);\n        }\n    }", "docstring": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "int", "classes": []}, "name": "addNode", "params": [{"name": "node", "type": "Node<T, S>"}, {"name": "builder", "type": "FlatBufferBuilder"}, {"name": "serializer", "type": "Func1<? super T, byte[]>"}], "body": "                                                 {\n        if (node instanceof Leaf) {\n            Leaf<T, S> leaf = (Leaf<T, S>) node;\n            return FlatBuffersHelper.addEntries(leaf.entries(), builder, serializer);\n        } else {\n            NonLeaf<T, S> nonLeaf = (NonLeaf<T, S>) node;\n            int[] nodes = new int[nonLeaf.count()];\n            for (int i = 0; i < nonLeaf.count(); i++) {\n                Node<T, S> child = nonLeaf.child(i);\n                nodes[i] = addNode(child, builder, serializer);\n            }\n            int ch = Node_.createChildrenVector(builder, nodes);\n            Rectangle mbb = nonLeaf.geometry().mbr();\n            int b = toBounds(builder, mbb);\n            Node_.startNode_(builder);\n            Node_.addChildren(builder, ch);\n            Node_.addMbb(builder, b);\n            return Node_.endNode_(builder);\n        }\n    }", "signature": "private static <T, S extends Geometry> int addNode(Node<T, S> node, FlatBufferBuilder builder,\n            Func1<? super T, byte[]> serializer)"}, {"syntax_pass": true, "original_string": "    @Override\n    public RTree<T, S> read(InputStream is, long sizeBytes, InternalStructure structure)\n            throws IOException {\n        byte[] bytes = readFully(is, (int) sizeBytes);\n        Tree_ t = Tree_.getRootAsTree_(ByteBuffer.wrap(bytes));\n        Context<T, S> context = new Context<T, S>(t.context().minChildren(),\n                t.context().maxChildren(), new SelectorRStar(), new SplitterRStar(), factory);\n        Node_ node = t.root();\n        if (node == null) {\n            return SerializerHelper.create(Optional.empty(), 0, context);\n        } else {\n            final Node<T, S> root;\n            if (structure == InternalStructure.SINGLE_ARRAY) {\n                if (node.childrenLength() > 0) {\n                    root = new NonLeafFlatBuffers<T, S>(node, context, factory.deserializer());\n                } else {\n                    root = new LeafFlatBuffers<T, S>(node, context, factory.deserializer());\n                }\n            } else {\n                root = toNodeDefault(node, context, factory.deserializer());\n            }\n            return SerializerHelper.create(Optional.of(root), (int) t.size(), context);\n        }\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "RTree<T, S>", "classes": []}, "name": "read", "params": [{"name": "is", "type": "InputStream"}, {"name": "sizeBytes", "type": "long"}, {"name": "structure", "type": "InternalStructure"}], "body": "                               {\n        byte[] bytes = readFully(is, (int) sizeBytes);\n        Tree_ t = Tree_.getRootAsTree_(ByteBuffer.wrap(bytes));\n        Context<T, S> context = new Context<T, S>(t.context().minChildren(),\n                t.context().maxChildren(), new SelectorRStar(), new SplitterRStar(), factory);\n        Node_ node = t.root();\n        if (node == null) {\n            return SerializerHelper.create(Optional.empty(), 0, context);\n        } else {\n            final Node<T, S> root;\n            if (structure == InternalStructure.SINGLE_ARRAY) {\n                if (node.childrenLength() > 0) {\n                    root = new NonLeafFlatBuffers<T, S>(node, context, factory.deserializer());\n                } else {\n                    root = new LeafFlatBuffers<T, S>(node, context, factory.deserializer());\n                }\n            } else {\n                root = toNodeDefault(node, context, factory.deserializer());\n            }\n            return SerializerHelper.create(Optional.of(root), (int) t.size(), context);\n        }\n    }", "signature": "@Override\n    public RTree<T, S> read(InputStream is, long sizeBytes, InternalStructure structure)"}, {"syntax_pass": true, "original_string": "    private static <T, S extends Geometry> Node<T, S> toNodeDefault(Node_ node,\n            Context<T, S> context, Func1<byte[], ? extends T> deserializer) {\n        int numChildren = node.childrenLength();\n        if (numChildren > 0) {\n            List<Node<T, S>> children = new ArrayList<Node<T, S>>(numChildren);\n            for (int i = 0; i < numChildren; i++) {\n                children.add(toNodeDefault(node.children(i), context, deserializer));\n            }\n            return new NonLeafDefault<T, S>(children, context);\n        } else {\n            List<Entry<T, S>> entries = FlatBuffersHelper.createEntries(node, deserializer);\n            return new LeafDefault<T, S>(entries, context);\n        }\n    }", "docstring": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "Node<T, S>", "classes": []}, "name": "toNodeDefault", "params": [{"name": "node", "type": "Node_"}, {"name": "context", "type": "Context<T, S>"}, {"name": "deserializer", "type": "Func1<byte[], ? extends T>"}], "body": "                                                                            {\n        int numChildren = node.childrenLength();\n        if (numChildren > 0) {\n            List<Node<T, S>> children = new ArrayList<Node<T, S>>(numChildren);\n            for (int i = 0; i < numChildren; i++) {\n                children.add(toNodeDefault(node.children(i), context, deserializer));\n            }\n            return new NonLeafDefault<T, S>(children, context);\n        } else {\n            List<Entry<T, S>> entries = FlatBuffersHelper.createEntries(node, deserializer);\n            return new LeafDefault<T, S>(entries, context);\n        }\n    }", "signature": "private static <T, S extends Geometry> Node<T, S> toNodeDefault(Node_ node,\n            Context<T, S> context, Func1<byte[], ? extends T> deserializer)"}, {"syntax_pass": true, "original_string": "    @VisibleForTesting\n    static byte[] readFully(InputStream is, int numBytes) throws IOException {\n        byte[] b = new byte[numBytes];\n        int count = 0;\n        do {\n            int n = is.read(b, count, numBytes - count);\n            if (n > 0) {\n                count += n;\n            } else {\n                throw new RuntimeException(\"unexpected\");\n            }\n        } while (count < numBytes);\n        return b;\n    }", "docstring": "", "attributes": {"modifiers": "@VisibleForTesting\n    static", "marker_annotations": ["@VisibleForTesting"], "non_marker_annotations": ["static"], "comments": [], "return_type": "byte[]", "classes": []}, "name": "readFully", "params": [{"name": "is", "type": "InputStream"}, {"name": "numBytes", "type": "int"}], "body": "                                                                             {\n        byte[] b = new byte[numBytes];\n        int count = 0;\n        do {\n            int n = is.read(b, count, numBytes - count);\n            if (n > 0) {\n                count += n;\n            } else {\n                throw new RuntimeException(\"unexpected\");\n            }\n        } while (count < numBytes);\n        return b;\n    }", "signature": "@VisibleForTesting\n    static byte[] readFully(InputStream is, int numBytes)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/com/github/davidmoten/rtree/fbs/NonLeafFlatBuffers.java", "original_string": "package com.github.davidmoten.rtree.fbs;\n\nimport static com.github.davidmoten.rtree.fbs.FlatBuffersHelper.createBox;\nimport static com.github.davidmoten.rtree.fbs.FlatBuffersHelper.parseObject;\nimport static com.github.davidmoten.rtree.fbs.FlatBuffersHelper.toGeometry;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport com.github.davidmoten.guavamini.Preconditions;\nimport com.github.davidmoten.rtree.Context;\nimport com.github.davidmoten.rtree.Entries;\nimport com.github.davidmoten.rtree.Entry;\nimport com.github.davidmoten.rtree.Node;\nimport com.github.davidmoten.rtree.NonLeaf;\nimport com.github.davidmoten.rtree.fbs.generated.BoundsType_;\nimport com.github.davidmoten.rtree.fbs.generated.Bounds_;\nimport com.github.davidmoten.rtree.fbs.generated.BoxDouble_;\nimport com.github.davidmoten.rtree.fbs.generated.BoxFloat_;\nimport com.github.davidmoten.rtree.fbs.generated.Entry_;\nimport com.github.davidmoten.rtree.fbs.generated.Geometry_;\nimport com.github.davidmoten.rtree.fbs.generated.Node_;\nimport com.github.davidmoten.rtree.geometry.Geometries;\nimport com.github.davidmoten.rtree.geometry.Geometry;\nimport com.github.davidmoten.rtree.geometry.Rectangle;\nimport com.github.davidmoten.rtree.internal.NodeAndEntries;\nimport com.github.davidmoten.rtree.internal.NonLeafHelper;\n\nimport rx.Subscriber;\nimport rx.functions.Func1;\n\nfinal class NonLeafFlatBuffers<T, S extends Geometry> implements NonLeaf<T, S> {\n\n    private final Node_ node;\n    private final Context<T, S> context;\n    private final Func1<byte[], ? extends T> deserializer;\n\n    NonLeafFlatBuffers(Node_ node, Context<T, S> context, Func1<byte[], ? extends T> deserializer) {\n        Preconditions.checkNotNull(node);\n        // remove precondition because reduces performance\n        // Preconditions.checkArgument(node.childrenLength() > 0);\n        this.node = node;\n        this.context = context;\n        this.deserializer = deserializer;\n    }\n\n    @Override\n    public List<Node<T, S>> add(Entry<? extends T, ? extends S> entry) {\n        return NonLeafHelper.add(entry, this);\n    }\n\n    @Override\n    public NodeAndEntries<T, S> delete(Entry<? extends T, ? extends S> entry, boolean all) {\n        return NonLeafHelper.delete(entry, all, this);\n    }\n\n    @Override\n    public void searchWithoutBackpressure(Func1<? super Geometry, Boolean> criterion,\n            Subscriber<? super Entry<T, S>> subscriber) {\n        // pass through entry and geometry and box instances to be reused for\n        // flatbuffers extraction this reduces allocation/gc costs (but of\n        // course introduces some mutable ugliness into the codebase)\n        searchWithoutBackpressure(node, criterion, subscriber, deserializer, new Entry_(),\n                new Geometry_(), new Bounds_());\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private static <T, S extends Geometry> void searchWithoutBackpressure(Node_ node,\n            Func1<? super Geometry, Boolean> criterion, Subscriber<? super Entry<T, S>> subscriber,\n            Func1<byte[], ? extends T> deserializer, Entry_ entry, Geometry_ geometry,\n            Bounds_ bounds) {\n        {\n            // write bounds from node to bounds variable\n            node.mbb(bounds);\n            final Rectangle rect;\n            if (bounds.type() == BoundsType_.BoundsDouble) {\n                BoxDouble_ b = bounds.boxDouble();\n                rect = Geometries.rectangle(b.minX(), b.minY(), b.maxX(), b.maxY());\n            } else {\n                BoxFloat_ b = bounds.boxFloat();\n                rect = Geometries.rectangle(b.minX(), b.minY(), b.maxX(), b.maxY());\n            }\n            if (!criterion.call(rect)) {\n                return;\n            }\n        }\n        int numChildren = node.childrenLength();\n        // reduce allocations by reusing objects\n        Node_ child = new Node_();\n        if (numChildren > 0) {\n            for (int i = 0; i < numChildren; i++) {\n                if (subscriber.isUnsubscribed())\n                    return;\n                node.children(child, i);\n                searchWithoutBackpressure(child, criterion, subscriber, deserializer, entry,\n                        geometry, bounds);\n            }\n        } else {\n            int numEntries = node.entriesLength();\n            // reduce allocations by reusing objects\n            // check all entries\n            for (int i = 0; i < numEntries; i++) {\n                if (subscriber.isUnsubscribed())\n                    return;\n                // set entry\n                node.entries(entry, i);\n                // set geometry\n                entry.geometry(geometry);\n                final Geometry g = toGeometry(geometry);\n                if (criterion.call(g)) {\n                    T t = parseObject(deserializer, entry);\n                    Entry<T, S> ent = Entries.entry(t, (S) g);\n                    subscriber.onNext(ent);\n                }\n            }\n        }\n\n    }\n\n    private List<Node<T, S>> createChildren() {\n\n        // reduce allocations by resusing objects\n        int numChildren = node.childrenLength();\n        List<Node<T, S>> children = new ArrayList<Node<T, S>>(numChildren);\n        for (int i = 0; i < numChildren; i++) {\n            Node_ child = node.children(i);\n            if (child.childrenLength() > 0) {\n                children.add(new NonLeafFlatBuffers<T, S>(child, context, deserializer));\n            } else {\n                children.add(new LeafFlatBuffers<T, S>(child, context, deserializer));\n            }\n        }\n        return children;\n    }\n\n    @Override\n    public int count() {\n        return node.childrenLength();\n    }\n\n    @Override\n    public Context<T, S> context() {\n        return context;\n    }\n\n    @Override\n    public Geometry geometry() {\n        return FlatBuffersHelper.createBox(node.mbb());\n    }\n\n    @Override\n    public Node<T, S> child(int i) {\n        Node_ child = node.children(i);\n        if (child.childrenLength() > 0)\n            return new NonLeafFlatBuffers<T, S>(child, context, deserializer);\n        else\n            return new LeafFlatBuffers<T, S>(child, context, deserializer);\n    }\n\n    @Override\n    public List<Node<T, S>> children() {\n        return createChildren();\n    }\n\n    @Override\n    public String toString() {\n        return \"Node [\" + (node.childrenLength() > 0 ? \"NonLeaf\" : \"Leaf\") + \",\"\n                + createBox(node.mbb()).toString() + \"]\";\n    }\n\n}\n", "file_hash": "d81e2c6c3d483202975c797ad50c323af2a5783c1422df6c4e516bc2aa4c40cc", "file_docstring": "", "contexts": ["package com.github.davidmoten.rtree.fbs;", "import static com.github.davidmoten.rtree.fbs.FlatBuffersHelper.createBox;", "import static com.github.davidmoten.rtree.fbs.FlatBuffersHelper.parseObject;", "import static com.github.davidmoten.rtree.fbs.FlatBuffersHelper.toGeometry;", "import java.util.ArrayList;", "import java.util.List;", "import com.github.davidmoten.guavamini.Preconditions;", "import com.github.davidmoten.rtree.Context;", "import com.github.davidmoten.rtree.Entries;", "import com.github.davidmoten.rtree.Entry;", "import com.github.davidmoten.rtree.Node;", "import com.github.davidmoten.rtree.NonLeaf;", "import com.github.davidmoten.rtree.fbs.generated.BoundsType_;", "import com.github.davidmoten.rtree.fbs.generated.Bounds_;", "import com.github.davidmoten.rtree.fbs.generated.BoxDouble_;", "import com.github.davidmoten.rtree.fbs.generated.BoxFloat_;", "import com.github.davidmoten.rtree.fbs.generated.Entry_;", "import com.github.davidmoten.rtree.fbs.generated.Geometry_;", "import com.github.davidmoten.rtree.fbs.generated.Node_;", "import com.github.davidmoten.rtree.geometry.Geometries;", "import com.github.davidmoten.rtree.geometry.Geometry;", "import com.github.davidmoten.rtree.geometry.Rectangle;", "import com.github.davidmoten.rtree.internal.NodeAndEntries;", "import com.github.davidmoten.rtree.internal.NonLeafHelper;", "import rx.Subscriber;", "import rx.functions.Func1;"], "methods": [], "classes": [{"original_string": "final class NonLeafFlatBuffers<T, S extends Geometry> implements NonLeaf<T, S> {\n\n    private final Node_ node;\n    private final Context<T, S> context;\n    private final Func1<byte[], ? extends T> deserializer;\n\n    NonLeafFlatBuffers(Node_ node, Context<T, S> context, Func1<byte[], ? extends T> deserializer) {\n        Preconditions.checkNotNull(node);\n        // remove precondition because reduces performance\n        // Preconditions.checkArgument(node.childrenLength() > 0);\n        this.node = node;\n        this.context = context;\n        this.deserializer = deserializer;\n    }\n\n    @Override\n    public List<Node<T, S>> add(Entry<? extends T, ? extends S> entry) {\n        return NonLeafHelper.add(entry, this);\n    }\n\n    @Override\n    public NodeAndEntries<T, S> delete(Entry<? extends T, ? extends S> entry, boolean all) {\n        return NonLeafHelper.delete(entry, all, this);\n    }\n\n    @Override\n    public void searchWithoutBackpressure(Func1<? super Geometry, Boolean> criterion,\n            Subscriber<? super Entry<T, S>> subscriber) {\n        // pass through entry and geometry and box instances to be reused for\n        // flatbuffers extraction this reduces allocation/gc costs (but of\n        // course introduces some mutable ugliness into the codebase)\n        searchWithoutBackpressure(node, criterion, subscriber, deserializer, new Entry_(),\n                new Geometry_(), new Bounds_());\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private static <T, S extends Geometry> void searchWithoutBackpressure(Node_ node,\n            Func1<? super Geometry, Boolean> criterion, Subscriber<? super Entry<T, S>> subscriber,\n            Func1<byte[], ? extends T> deserializer, Entry_ entry, Geometry_ geometry,\n            Bounds_ bounds) {\n        {\n            // write bounds from node to bounds variable\n            node.mbb(bounds);\n            final Rectangle rect;\n            if (bounds.type() == BoundsType_.BoundsDouble) {\n                BoxDouble_ b = bounds.boxDouble();\n                rect = Geometries.rectangle(b.minX(), b.minY(), b.maxX(), b.maxY());\n            } else {\n                BoxFloat_ b = bounds.boxFloat();\n                rect = Geometries.rectangle(b.minX(), b.minY(), b.maxX(), b.maxY());\n            }\n            if (!criterion.call(rect)) {\n                return;\n            }\n        }\n        int numChildren = node.childrenLength();\n        // reduce allocations by reusing objects\n        Node_ child = new Node_();\n        if (numChildren > 0) {\n            for (int i = 0; i < numChildren; i++) {\n                if (subscriber.isUnsubscribed())\n                    return;\n                node.children(child, i);\n                searchWithoutBackpressure(child, criterion, subscriber, deserializer, entry,\n                        geometry, bounds);\n            }\n        } else {\n            int numEntries = node.entriesLength();\n            // reduce allocations by reusing objects\n            // check all entries\n            for (int i = 0; i < numEntries; i++) {\n                if (subscriber.isUnsubscribed())\n                    return;\n                // set entry\n                node.entries(entry, i);\n                // set geometry\n                entry.geometry(geometry);\n                final Geometry g = toGeometry(geometry);\n                if (criterion.call(g)) {\n                    T t = parseObject(deserializer, entry);\n                    Entry<T, S> ent = Entries.entry(t, (S) g);\n                    subscriber.onNext(ent);\n                }\n            }\n        }\n\n    }\n\n    private List<Node<T, S>> createChildren() {\n\n        // reduce allocations by resusing objects\n        int numChildren = node.childrenLength();\n        List<Node<T, S>> children = new ArrayList<Node<T, S>>(numChildren);\n        for (int i = 0; i < numChildren; i++) {\n            Node_ child = node.children(i);\n            if (child.childrenLength() > 0) {\n                children.add(new NonLeafFlatBuffers<T, S>(child, context, deserializer));\n            } else {\n                children.add(new LeafFlatBuffers<T, S>(child, context, deserializer));\n            }\n        }\n        return children;\n    }\n\n    @Override\n    public int count() {\n        return node.childrenLength();\n    }\n\n    @Override\n    public Context<T, S> context() {\n        return context;\n    }\n\n    @Override\n    public Geometry geometry() {\n        return FlatBuffersHelper.createBox(node.mbb());\n    }\n\n    @Override\n    public Node<T, S> child(int i) {\n        Node_ child = node.children(i);\n        if (child.childrenLength() > 0)\n            return new NonLeafFlatBuffers<T, S>(child, context, deserializer);\n        else\n            return new LeafFlatBuffers<T, S>(child, context, deserializer);\n    }\n\n    @Override\n    public List<Node<T, S>> children() {\n        return createChildren();\n    }\n\n    @Override\n    public String toString() {\n        return \"Node [\" + (node.childrenLength() > 0 ? \"NonLeaf\" : \"Leaf\") + \",\"\n                + createBox(node.mbb()).toString() + \"]\";\n    }\n\n}", "definition": "final class NonLeafFlatBuffers<T, S extends Geometry> implements NonLeaf<T, S>", "class_docstring": "", "name": "NonLeafFlatBuffers", "super_interfaces": ["NonLeaf<T, S>"], "superclasses": "", "attributes": {"modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "fields": [{"attribute_expression": "private final Node_ node;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Node_", "name": "node", "syntax_pass": true}, {"attribute_expression": "private final Context<T, S> context;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Context<T, S>", "name": "context", "syntax_pass": true}, {"attribute_expression": "private final Func1<byte[], ? extends T> deserializer;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Func1<byte[], ? extends T>", "name": "deserializer", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    NonLeafFlatBuffers(Node_ node, Context<T, S> context, Func1<byte[], ? extends T> deserializer) {\n        Preconditions.checkNotNull(node);\n        // remove precondition because reduces performance\n        // Preconditions.checkArgument(node.childrenLength() > 0);\n        this.node = node;\n        this.context = context;\n        this.deserializer = deserializer;\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "NonLeafFlatBuffers", "params": [{"name": "node", "type": "Node_"}, {"name": "context", "type": "Context<T, S>"}, {"name": "deserializer", "type": "Func1<byte[], ? extends T>"}], "body": "                                                                                                   {\n        Preconditions.checkNotNull(node);\n        // remove precondition because reduces performance\n        // Preconditions.checkArgument(node.childrenLength() > 0);\n        this.node = node;\n        this.context = context;\n        this.deserializer = deserializer;\n    }", "signature": "NonLeafFlatBuffers(Node_ node, Context<T, S> context, Func1<byte[], ? extends T> deserializer)"}, {"syntax_pass": true, "original_string": "    @Override\n    public List<Node<T, S>> add(Entry<? extends T, ? extends S> entry) {\n        return NonLeafHelper.add(entry, this);\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "List<Node<T, S>>", "classes": []}, "name": "add", "params": [{"name": "entry", "type": "Entry<? extends T, ? extends S>"}], "body": "                                                                       {\n        return NonLeafHelper.add(entry, this);\n    }", "signature": "@Override\n    public List<Node<T, S>> add(Entry<? extends T, ? extends S> entry)"}, {"syntax_pass": true, "original_string": "    @Override\n    public NodeAndEntries<T, S> delete(Entry<? extends T, ? extends S> entry, boolean all) {\n        return NonLeafHelper.delete(entry, all, this);\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "NodeAndEntries<T, S>", "classes": []}, "name": "delete", "params": [{"name": "entry", "type": "Entry<? extends T, ? extends S>"}, {"name": "all", "type": "boolean"}], "body": "                                                                                           {\n        return NonLeafHelper.delete(entry, all, this);\n    }", "signature": "@Override\n    public NodeAndEntries<T, S> delete(Entry<? extends T, ? extends S> entry, boolean all)"}, {"syntax_pass": true, "original_string": "    @Override\n    public void searchWithoutBackpressure(Func1<? super Geometry, Boolean> criterion,\n            Subscriber<? super Entry<T, S>> subscriber) {\n        // pass through entry and geometry and box instances to be reused for\n        // flatbuffers extraction this reduces allocation/gc costs (but of\n        // course introduces some mutable ugliness into the codebase)\n        searchWithoutBackpressure(node, criterion, subscriber, deserializer, new Entry_(),\n                new Geometry_(), new Bounds_());\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "searchWithoutBackpressure", "params": [{"name": "criterion", "type": "Func1<? super Geometry, Boolean>"}, {"name": "subscriber", "type": "Subscriber<? super Entry<T, S>>"}], "body": "                                                        {\n        // pass through entry and geometry and box instances to be reused for\n        // flatbuffers extraction this reduces allocation/gc costs (but of\n        // course introduces some mutable ugliness into the codebase)\n        searchWithoutBackpressure(node, criterion, subscriber, deserializer, new Entry_(),\n                new Geometry_(), new Bounds_());\n    }", "signature": "@Override\n    public void searchWithoutBackpressure(Func1<? super Geometry, Boolean> criterion,\n            Subscriber<? super Entry<T, S>> subscriber)"}, {"syntax_pass": true, "original_string": "    @SuppressWarnings(\"unchecked\")\n    private static <T, S extends Geometry> void searchWithoutBackpressure(Node_ node,\n            Func1<? super Geometry, Boolean> criterion, Subscriber<? super Entry<T, S>> subscriber,\n            Func1<byte[], ? extends T> deserializer, Entry_ entry, Geometry_ geometry,\n            Bounds_ bounds) {\n        {\n            // write bounds from node to bounds variable\n            node.mbb(bounds);\n            final Rectangle rect;\n            if (bounds.type() == BoundsType_.BoundsDouble) {\n                BoxDouble_ b = bounds.boxDouble();\n                rect = Geometries.rectangle(b.minX(), b.minY(), b.maxX(), b.maxY());\n            } else {\n                BoxFloat_ b = bounds.boxFloat();\n                rect = Geometries.rectangle(b.minX(), b.minY(), b.maxX(), b.maxY());\n            }\n            if (!criterion.call(rect)) {\n                return;\n            }\n        }\n        int numChildren = node.childrenLength();\n        // reduce allocations by reusing objects\n        Node_ child = new Node_();\n        if (numChildren > 0) {\n            for (int i = 0; i < numChildren; i++) {\n                if (subscriber.isUnsubscribed())\n                    return;\n                node.children(child, i);\n                searchWithoutBackpressure(child, criterion, subscriber, deserializer, entry,\n                        geometry, bounds);\n            }\n        } else {\n            int numEntries = node.entriesLength();\n            // reduce allocations by reusing objects\n            // check all entries\n            for (int i = 0; i < numEntries; i++) {\n                if (subscriber.isUnsubscribed())\n                    return;\n                // set entry\n                node.entries(entry, i);\n                // set geometry\n                entry.geometry(geometry);\n                final Geometry g = toGeometry(geometry);\n                if (criterion.call(g)) {\n                    T t = parseObject(deserializer, entry);\n                    Entry<T, S> ent = Entries.entry(t, (S) g);\n                    subscriber.onNext(ent);\n                }\n            }\n        }\n\n    }", "docstring": "", "attributes": {"modifiers": "@SuppressWarnings(\"unchecked\")\n    private static", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings(\"unchecked\")", "private", "static"], "comments": [], "return_type": "void", "classes": []}, "name": "searchWithoutBackpressure", "params": [{"name": "node", "type": "Node_"}, {"name": "criterion", "type": "Func1<? super Geometry, Boolean>"}, {"name": "subscriber", "type": "Subscriber<? super Entry<T, S>>"}, {"name": "deserializer", "type": "Func1<byte[], ? extends T>"}, {"name": "entry", "type": "Entry_"}, {"name": "geometry", "type": "Geometry_"}, {"name": "bounds", "type": "Bounds_"}], "body": "                            {\n        {\n            // write bounds from node to bounds variable\n            node.mbb(bounds);\n            final Rectangle rect;\n            if (bounds.type() == BoundsType_.BoundsDouble) {\n                BoxDouble_ b = bounds.boxDouble();\n                rect = Geometries.rectangle(b.minX(), b.minY(), b.maxX(), b.maxY());\n            } else {\n                BoxFloat_ b = bounds.boxFloat();\n                rect = Geometries.rectangle(b.minX(), b.minY(), b.maxX(), b.maxY());\n            }\n            if (!criterion.call(rect)) {\n                return;\n            }\n        }\n        int numChildren = node.childrenLength();\n        // reduce allocations by reusing objects\n        Node_ child = new Node_();\n        if (numChildren > 0) {\n            for (int i = 0; i < numChildren; i++) {\n                if (subscriber.isUnsubscribed())\n                    return;\n                node.children(child, i);\n                searchWithoutBackpressure(child, criterion, subscriber, deserializer, entry,\n                        geometry, bounds);\n            }\n        } else {\n            int numEntries = node.entriesLength();\n            // reduce allocations by reusing objects\n            // check all entries\n            for (int i = 0; i < numEntries; i++) {\n                if (subscriber.isUnsubscribed())\n                    return;\n                // set entry\n                node.entries(entry, i);\n                // set geometry\n                entry.geometry(geometry);\n                final Geometry g = toGeometry(geometry);\n                if (criterion.call(g)) {\n                    T t = parseObject(deserializer, entry);\n                    Entry<T, S> ent = Entries.entry(t, (S) g);\n                    subscriber.onNext(ent);\n                }\n            }\n        }\n\n    }", "signature": "@SuppressWarnings(\"unchecked\")\n    private static <T, S extends Geometry> void searchWithoutBackpressure(Node_ node,\n            Func1<? super Geometry, Boolean> criterion, Subscriber<? super Entry<T, S>> subscriber,\n            Func1<byte[], ? extends T> deserializer, Entry_ entry, Geometry_ geometry,\n            Bounds_ bounds)"}, {"syntax_pass": true, "original_string": "    private List<Node<T, S>> createChildren() {\n\n        // reduce allocations by resusing objects\n        int numChildren = node.childrenLength();\n        List<Node<T, S>> children = new ArrayList<Node<T, S>>(numChildren);\n        for (int i = 0; i < numChildren; i++) {\n            Node_ child = node.children(i);\n            if (child.childrenLength() > 0) {\n                children.add(new NonLeafFlatBuffers<T, S>(child, context, deserializer));\n            } else {\n                children.add(new LeafFlatBuffers<T, S>(child, context, deserializer));\n            }\n        }\n        return children;\n    }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "List<Node<T, S>>", "classes": []}, "name": "createChildren", "params": [], "body": "                                              {\n\n        // reduce allocations by resusing objects\n        int numChildren = node.childrenLength();\n        List<Node<T, S>> children = new ArrayList<Node<T, S>>(numChildren);\n        for (int i = 0; i < numChildren; i++) {\n            Node_ child = node.children(i);\n            if (child.childrenLength() > 0) {\n                children.add(new NonLeafFlatBuffers<T, S>(child, context, deserializer));\n            } else {\n                children.add(new LeafFlatBuffers<T, S>(child, context, deserializer));\n            }\n        }\n        return children;\n    }", "signature": "private List<Node<T, S>> createChildren()"}, {"syntax_pass": true, "original_string": "    @Override\n    public int count() {\n        return node.childrenLength();\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "count", "params": [], "body": "                       {\n        return node.childrenLength();\n    }", "signature": "@Override\n    public int count()"}, {"syntax_pass": true, "original_string": "    @Override\n    public Context<T, S> context() {\n        return context;\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Context<T, S>", "classes": []}, "name": "context", "params": [], "body": "                                   {\n        return context;\n    }", "signature": "@Override\n    public Context<T, S> context()"}, {"syntax_pass": true, "original_string": "    @Override\n    public Geometry geometry() {\n        return FlatBuffersHelper.createBox(node.mbb());\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Geometry", "classes": []}, "name": "geometry", "params": [], "body": "                               {\n        return FlatBuffersHelper.createBox(node.mbb());\n    }", "signature": "@Override\n    public Geometry geometry()"}, {"syntax_pass": true, "original_string": "    @Override\n    public Node<T, S> child(int i) {\n        Node_ child = node.children(i);\n        if (child.childrenLength() > 0)\n            return new NonLeafFlatBuffers<T, S>(child, context, deserializer);\n        else\n            return new LeafFlatBuffers<T, S>(child, context, deserializer);\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Node<T, S>", "classes": []}, "name": "child", "params": [{"name": "i", "type": "int"}], "body": "                                   {\n        Node_ child = node.children(i);\n        if (child.childrenLength() > 0)\n            return new NonLeafFlatBuffers<T, S>(child, context, deserializer);\n        else\n            return new LeafFlatBuffers<T, S>(child, context, deserializer);\n    }", "signature": "@Override\n    public Node<T, S> child(int i)"}, {"syntax_pass": true, "original_string": "    @Override\n    public List<Node<T, S>> children() {\n        return createChildren();\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "List<Node<T, S>>", "classes": []}, "name": "children", "params": [], "body": "                                       {\n        return createChildren();\n    }", "signature": "@Override\n    public List<Node<T, S>> children()"}, {"syntax_pass": true, "original_string": "    @Override\n    public String toString() {\n        return \"Node [\" + (node.childrenLength() > 0 ? \"NonLeaf\" : \"Leaf\") + \",\"\n                + createBox(node.mbb()).toString() + \"]\";\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "toString", "params": [], "body": "                             {\n        return \"Node [\" + (node.childrenLength() > 0 ? \"NonLeaf\" : \"Leaf\") + \",\"\n                + createBox(node.mbb()).toString() + \"]\";\n    }", "signature": "@Override\n    public String toString()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/com/github/davidmoten/rtree/fbs/LeafFlatBuffers.java", "original_string": "package com.github.davidmoten.rtree.fbs;\n\nimport java.util.List;\n\nimport com.github.davidmoten.rtree.Context;\nimport com.github.davidmoten.rtree.Entry;\nimport com.github.davidmoten.rtree.Leaf;\nimport com.github.davidmoten.rtree.Node;\nimport com.github.davidmoten.rtree.fbs.generated.BoundsType_;\nimport com.github.davidmoten.rtree.fbs.generated.Bounds_;\nimport com.github.davidmoten.rtree.fbs.generated.BoxDouble_;\nimport com.github.davidmoten.rtree.fbs.generated.BoxFloat_;\nimport com.github.davidmoten.rtree.fbs.generated.Node_;\nimport com.github.davidmoten.rtree.geometry.Geometries;\nimport com.github.davidmoten.rtree.geometry.Geometry;\nimport com.github.davidmoten.rtree.internal.LeafHelper;\nimport com.github.davidmoten.rtree.internal.NodeAndEntries;\nimport com.google.flatbuffers.FlatBufferBuilder;\n\nimport rx.Subscriber;\nimport rx.functions.Func1;\n\nfinal class LeafFlatBuffers<T, S extends Geometry> implements Leaf<T, S> {\n\n    private final Node_ node;\n    private final Context<T, S> context;\n    private final Func1<byte[], ? extends T> deserializer;\n\n    LeafFlatBuffers(List<Entry<T, S>> entries, Context<T, S> context,\n            Func1<? super T, byte[]> serializer, Func1<byte[], ? extends T> deserializer) {\n        this(createNode(entries, serializer), context, deserializer);\n    }\n\n    LeafFlatBuffers(Node_ node, Context<T, S> context, Func1<byte[], ? extends T> deserializer) {\n        this.context = context;\n        this.deserializer = deserializer;\n        this.node = node;\n    }\n\n    private static <T, S extends Geometry> Node_ createNode(List<Entry<T, S>> entries,\n            Func1<? super T, byte[]> serializer) {\n        FlatBufferBuilder builder = new FlatBufferBuilder(0);\n        builder.finish(FlatBuffersHelper.addEntries(entries, builder, serializer));\n        return Node_.getRootAsNode_(builder.dataBuffer());\n    }\n\n    @Override\n    public List<Node<T, S>> add(Entry<? extends T, ? extends S> entry) {\n        return LeafHelper.add(entry, this);\n    }\n\n    @Override\n    public NodeAndEntries<T, S> delete(Entry<? extends T, ? extends S> entry, boolean all) {\n        return LeafHelper.delete(entry, all, this);\n    }\n\n    @Override\n    public void searchWithoutBackpressure(Func1<? super Geometry, Boolean> condition,\n            Subscriber<? super Entry<T, S>> subscriber) {\n        // only called when the root of the tree is a Leaf\n        // normally the searchWithoutBackpressure is executed completely within the\n        // NonLeafFlatBuffers class to reduce object creation\n        LeafHelper.search(condition, subscriber, this);\n    }\n\n    @Override\n    public int count() {\n        return node.entriesLength();\n    }\n\n    @Override\n    public Context<T, S> context() {\n        return context;\n    }\n\n    @Override\n    public Geometry geometry() {\n        Bounds_ b = node.mbb();\n        // create on demand to reduce memory use (though not gc pressure)\n        if (b.type() == BoundsType_.BoundsDouble) {\n            BoxDouble_ r = b.boxDouble();\n            return Geometries.rectangle(r.minX(), r.minY(), r.maxX(), r.maxY());\n        } else {\n            BoxFloat_ r = b.boxFloat();\n            return Geometries.rectangle(r.minX(), r.minY(), r.maxX(), r.maxY());\n        }\n    }\n\n    @Override\n    public List<Entry<T, S>> entries() {\n        return FlatBuffersHelper.createEntries(node, deserializer);\n    }\n\n    @Override\n    public Entry<T, S> entry(int i) {\n        return FlatBuffersHelper.createEntry(node, deserializer, i);\n    }\n\n}\n", "file_hash": "2f9dc3c3d5993dfc4099a1268e9a17e859edf44e090cee46a5ae39e124ce1cb8", "file_docstring": "", "contexts": ["package com.github.davidmoten.rtree.fbs;", "import java.util.List;", "import com.github.davidmoten.rtree.Context;", "import com.github.davidmoten.rtree.Entry;", "import com.github.davidmoten.rtree.Leaf;", "import com.github.davidmoten.rtree.Node;", "import com.github.davidmoten.rtree.fbs.generated.BoundsType_;", "import com.github.davidmoten.rtree.fbs.generated.Bounds_;", "import com.github.davidmoten.rtree.fbs.generated.BoxDouble_;", "import com.github.davidmoten.rtree.fbs.generated.BoxFloat_;", "import com.github.davidmoten.rtree.fbs.generated.Node_;", "import com.github.davidmoten.rtree.geometry.Geometries;", "import com.github.davidmoten.rtree.geometry.Geometry;", "import com.github.davidmoten.rtree.internal.LeafHelper;", "import com.github.davidmoten.rtree.internal.NodeAndEntries;", "import com.google.flatbuffers.FlatBufferBuilder;", "import rx.Subscriber;", "import rx.functions.Func1;"], "methods": [], "classes": [{"original_string": "final class LeafFlatBuffers<T, S extends Geometry> implements Leaf<T, S> {\n\n    private final Node_ node;\n    private final Context<T, S> context;\n    private final Func1<byte[], ? extends T> deserializer;\n\n    LeafFlatBuffers(List<Entry<T, S>> entries, Context<T, S> context,\n            Func1<? super T, byte[]> serializer, Func1<byte[], ? extends T> deserializer) {\n        this(createNode(entries, serializer), context, deserializer);\n    }\n\n    LeafFlatBuffers(Node_ node, Context<T, S> context, Func1<byte[], ? extends T> deserializer) {\n        this.context = context;\n        this.deserializer = deserializer;\n        this.node = node;\n    }\n\n    private static <T, S extends Geometry> Node_ createNode(List<Entry<T, S>> entries,\n            Func1<? super T, byte[]> serializer) {\n        FlatBufferBuilder builder = new FlatBufferBuilder(0);\n        builder.finish(FlatBuffersHelper.addEntries(entries, builder, serializer));\n        return Node_.getRootAsNode_(builder.dataBuffer());\n    }\n\n    @Override\n    public List<Node<T, S>> add(Entry<? extends T, ? extends S> entry) {\n        return LeafHelper.add(entry, this);\n    }\n\n    @Override\n    public NodeAndEntries<T, S> delete(Entry<? extends T, ? extends S> entry, boolean all) {\n        return LeafHelper.delete(entry, all, this);\n    }\n\n    @Override\n    public void searchWithoutBackpressure(Func1<? super Geometry, Boolean> condition,\n            Subscriber<? super Entry<T, S>> subscriber) {\n        // only called when the root of the tree is a Leaf\n        // normally the searchWithoutBackpressure is executed completely within the\n        // NonLeafFlatBuffers class to reduce object creation\n        LeafHelper.search(condition, subscriber, this);\n    }\n\n    @Override\n    public int count() {\n        return node.entriesLength();\n    }\n\n    @Override\n    public Context<T, S> context() {\n        return context;\n    }\n\n    @Override\n    public Geometry geometry() {\n        Bounds_ b = node.mbb();\n        // create on demand to reduce memory use (though not gc pressure)\n        if (b.type() == BoundsType_.BoundsDouble) {\n            BoxDouble_ r = b.boxDouble();\n            return Geometries.rectangle(r.minX(), r.minY(), r.maxX(), r.maxY());\n        } else {\n            BoxFloat_ r = b.boxFloat();\n            return Geometries.rectangle(r.minX(), r.minY(), r.maxX(), r.maxY());\n        }\n    }\n\n    @Override\n    public List<Entry<T, S>> entries() {\n        return FlatBuffersHelper.createEntries(node, deserializer);\n    }\n\n    @Override\n    public Entry<T, S> entry(int i) {\n        return FlatBuffersHelper.createEntry(node, deserializer, i);\n    }\n\n}", "definition": "final class LeafFlatBuffers<T, S extends Geometry> implements Leaf<T, S>", "class_docstring": "", "name": "LeafFlatBuffers", "super_interfaces": ["Leaf<T, S>"], "superclasses": "", "attributes": {"modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "fields": [{"attribute_expression": "private final Node_ node;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Node_", "name": "node", "syntax_pass": true}, {"attribute_expression": "private final Context<T, S> context;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Context<T, S>", "name": "context", "syntax_pass": true}, {"attribute_expression": "private final Func1<byte[], ? extends T> deserializer;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Func1<byte[], ? extends T>", "name": "deserializer", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    LeafFlatBuffers(List<Entry<T, S>> entries, Context<T, S> context,\n            Func1<? super T, byte[]> serializer, Func1<byte[], ? extends T> deserializer) {\n        this(createNode(entries, serializer), context, deserializer);\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "LeafFlatBuffers", "params": [{"name": "entries", "type": "List<Entry<T, S>>"}, {"name": "context", "type": "Context<T, S>"}, {"name": "serializer", "type": "Func1<? super T, byte[]>"}, {"name": "deserializer", "type": "Func1<byte[], ? extends T>"}], "body": "                                                                                          {\n        this(createNode(entries, serializer), context, deserializer);\n    }", "signature": "LeafFlatBuffers(List<Entry<T, S>> entries, Context<T, S> context,\n            Func1<? super T, byte[]> serializer, Func1<byte[], ? extends T> deserializer)"}, {"syntax_pass": true, "original_string": "    LeafFlatBuffers(Node_ node, Context<T, S> context, Func1<byte[], ? extends T> deserializer) {\n        this.context = context;\n        this.deserializer = deserializer;\n        this.node = node;\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "LeafFlatBuffers", "params": [{"name": "node", "type": "Node_"}, {"name": "context", "type": "Context<T, S>"}, {"name": "deserializer", "type": "Func1<byte[], ? extends T>"}], "body": "                                                                                                {\n        this.context = context;\n        this.deserializer = deserializer;\n        this.node = node;\n    }", "signature": "LeafFlatBuffers(Node_ node, Context<T, S> context, Func1<byte[], ? extends T> deserializer)"}, {"syntax_pass": true, "original_string": "    private static <T, S extends Geometry> Node_ createNode(List<Entry<T, S>> entries,\n            Func1<? super T, byte[]> serializer) {\n        FlatBufferBuilder builder = new FlatBufferBuilder(0);\n        builder.finish(FlatBuffersHelper.addEntries(entries, builder, serializer));\n        return Node_.getRootAsNode_(builder.dataBuffer());\n    }", "docstring": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "Node_", "classes": []}, "name": "createNode", "params": [{"name": "entries", "type": "List<Entry<T, S>>"}, {"name": "serializer", "type": "Func1<? super T, byte[]>"}], "body": "                                                 {\n        FlatBufferBuilder builder = new FlatBufferBuilder(0);\n        builder.finish(FlatBuffersHelper.addEntries(entries, builder, serializer));\n        return Node_.getRootAsNode_(builder.dataBuffer());\n    }", "signature": "private static <T, S extends Geometry> Node_ createNode(List<Entry<T, S>> entries,\n            Func1<? super T, byte[]> serializer)"}, {"syntax_pass": true, "original_string": "    @Override\n    public List<Node<T, S>> add(Entry<? extends T, ? extends S> entry) {\n        return LeafHelper.add(entry, this);\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "List<Node<T, S>>", "classes": []}, "name": "add", "params": [{"name": "entry", "type": "Entry<? extends T, ? extends S>"}], "body": "                                                                       {\n        return LeafHelper.add(entry, this);\n    }", "signature": "@Override\n    public List<Node<T, S>> add(Entry<? extends T, ? extends S> entry)"}, {"syntax_pass": true, "original_string": "    @Override\n    public NodeAndEntries<T, S> delete(Entry<? extends T, ? extends S> entry, boolean all) {\n        return LeafHelper.delete(entry, all, this);\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "NodeAndEntries<T, S>", "classes": []}, "name": "delete", "params": [{"name": "entry", "type": "Entry<? extends T, ? extends S>"}, {"name": "all", "type": "boolean"}], "body": "                                                                                           {\n        return LeafHelper.delete(entry, all, this);\n    }", "signature": "@Override\n    public NodeAndEntries<T, S> delete(Entry<? extends T, ? extends S> entry, boolean all)"}, {"syntax_pass": true, "original_string": "    @Override\n    public void searchWithoutBackpressure(Func1<? super Geometry, Boolean> condition,\n            Subscriber<? super Entry<T, S>> subscriber) {\n        // only called when the root of the tree is a Leaf\n        // normally the searchWithoutBackpressure is executed completely within the\n        // NonLeafFlatBuffers class to reduce object creation\n        LeafHelper.search(condition, subscriber, this);\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "searchWithoutBackpressure", "params": [{"name": "condition", "type": "Func1<? super Geometry, Boolean>"}, {"name": "subscriber", "type": "Subscriber<? super Entry<T, S>>"}], "body": "                                                        {\n        // only called when the root of the tree is a Leaf\n        // normally the searchWithoutBackpressure is executed completely within the\n        // NonLeafFlatBuffers class to reduce object creation\n        LeafHelper.search(condition, subscriber, this);\n    }", "signature": "@Override\n    public void searchWithoutBackpressure(Func1<? super Geometry, Boolean> condition,\n            Subscriber<? super Entry<T, S>> subscriber)"}, {"syntax_pass": true, "original_string": "    @Override\n    public int count() {\n        return node.entriesLength();\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "count", "params": [], "body": "                       {\n        return node.entriesLength();\n    }", "signature": "@Override\n    public int count()"}, {"syntax_pass": true, "original_string": "    @Override\n    public Context<T, S> context() {\n        return context;\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Context<T, S>", "classes": []}, "name": "context", "params": [], "body": "                                   {\n        return context;\n    }", "signature": "@Override\n    public Context<T, S> context()"}, {"syntax_pass": true, "original_string": "    @Override\n    public Geometry geometry() {\n        Bounds_ b = node.mbb();\n        // create on demand to reduce memory use (though not gc pressure)\n        if (b.type() == BoundsType_.BoundsDouble) {\n            BoxDouble_ r = b.boxDouble();\n            return Geometries.rectangle(r.minX(), r.minY(), r.maxX(), r.maxY());\n        } else {\n            BoxFloat_ r = b.boxFloat();\n            return Geometries.rectangle(r.minX(), r.minY(), r.maxX(), r.maxY());\n        }\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Geometry", "classes": []}, "name": "geometry", "params": [], "body": "                               {\n        Bounds_ b = node.mbb();\n        // create on demand to reduce memory use (though not gc pressure)\n        if (b.type() == BoundsType_.BoundsDouble) {\n            BoxDouble_ r = b.boxDouble();\n            return Geometries.rectangle(r.minX(), r.minY(), r.maxX(), r.maxY());\n        } else {\n            BoxFloat_ r = b.boxFloat();\n            return Geometries.rectangle(r.minX(), r.minY(), r.maxX(), r.maxY());\n        }\n    }", "signature": "@Override\n    public Geometry geometry()"}, {"syntax_pass": true, "original_string": "    @Override\n    public List<Entry<T, S>> entries() {\n        return FlatBuffersHelper.createEntries(node, deserializer);\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "List<Entry<T, S>>", "classes": []}, "name": "entries", "params": [], "body": "                                       {\n        return FlatBuffersHelper.createEntries(node, deserializer);\n    }", "signature": "@Override\n    public List<Entry<T, S>> entries()"}, {"syntax_pass": true, "original_string": "    @Override\n    public Entry<T, S> entry(int i) {\n        return FlatBuffersHelper.createEntry(node, deserializer, i);\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Entry<T, S>", "classes": []}, "name": "entry", "params": [{"name": "i", "type": "int"}], "body": "                                    {\n        return FlatBuffersHelper.createEntry(node, deserializer, i);\n    }", "signature": "@Override\n    public Entry<T, S> entry(int i)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/com/github/davidmoten/rtree/fbs/FlatBuffersHelper.java", "original_string": "package com.github.davidmoten.rtree.fbs;\n\nimport java.nio.ByteBuffer;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\nimport com.github.davidmoten.guavamini.Preconditions;\nimport com.github.davidmoten.rtree.Entries;\nimport com.github.davidmoten.rtree.Entry;\nimport com.github.davidmoten.rtree.fbs.generated.BoundsType_;\nimport com.github.davidmoten.rtree.fbs.generated.Bounds_;\nimport com.github.davidmoten.rtree.fbs.generated.BoxDouble_;\nimport com.github.davidmoten.rtree.fbs.generated.BoxFloat_;\nimport com.github.davidmoten.rtree.fbs.generated.CircleDouble_;\nimport com.github.davidmoten.rtree.fbs.generated.CircleFloat_;\nimport com.github.davidmoten.rtree.fbs.generated.Entry_;\nimport com.github.davidmoten.rtree.fbs.generated.GeometryType_;\nimport com.github.davidmoten.rtree.fbs.generated.Geometry_;\nimport com.github.davidmoten.rtree.fbs.generated.LineDouble_;\nimport com.github.davidmoten.rtree.fbs.generated.LineFloat_;\nimport com.github.davidmoten.rtree.fbs.generated.Node_;\nimport com.github.davidmoten.rtree.fbs.generated.PointDouble_;\nimport com.github.davidmoten.rtree.fbs.generated.PointFloat_;\nimport com.github.davidmoten.rtree.geometry.Circle;\nimport com.github.davidmoten.rtree.geometry.Geometries;\nimport com.github.davidmoten.rtree.geometry.Geometry;\nimport com.github.davidmoten.rtree.geometry.Line;\nimport com.github.davidmoten.rtree.geometry.Point;\nimport com.github.davidmoten.rtree.geometry.Rectangle;\nimport com.github.davidmoten.rtree.internal.Util;\nimport com.google.flatbuffers.FlatBufferBuilder;\n\nimport rx.functions.Func1;\n\nfinal class FlatBuffersHelper {\n\n    private FlatBuffersHelper() {\n        // prevent instantiation\n    }\n\n    static <T, S extends Geometry> int addEntries(List<Entry<T, S>> entries,\n            FlatBufferBuilder builder, Func1<? super T, byte[]> serializer) {\n        int[] entries2 = new int[entries.size()];\n        for (int i = 0; i < entries.size(); i++) {\n            Geometry g = entries.get(i).geometry();\n            final int geom;\n            final byte geomType;\n            // Must check Point before Rectangle because Point is instance of\n            // Rectangle\n            if (g instanceof Point) {\n                Point p = (Point) g;\n                if (p.isDoublePrecision()) {\n                    geom = PointDouble_.createPointDouble_(builder, p.x(), p.y());\n                    geomType = GeometryType_.PointDouble;\n                } else {\n                    geom = PointFloat_.createPointFloat_(builder, (float) p.x(), (float) p.y());\n                    geomType = GeometryType_.PointFloat;\n                }\n            } else if (g instanceof Rectangle) {\n                Rectangle b = (Rectangle) g;\n                if (b.isDoublePrecision()) {\n                    geom = BoxDouble_.createBoxDouble_(builder, b.x1(), b.y1(), b.x2(), b.y2());\n                    geomType = GeometryType_.BoxDouble;\n                } else {\n                    geom = BoxFloat_.createBoxFloat_(builder, (float) b.x1(), (float) b.y1(),\n                            (float) b.x2(), (float) b.y2());\n                    geomType = GeometryType_.BoxFloat;\n                }\n            } else if (g instanceof Circle) {\n                Circle c = (Circle) g;\n                if (c.isDoublePrecision()) {\n                    geom = CircleDouble_.createCircleDouble_(builder, c.x(), c.y(), c.radius());\n                    geomType = GeometryType_.CircleDouble;\n                } else {\n                    geom = CircleFloat_.createCircleFloat_(builder, (float) c.x(), (float) c.y(),\n                            (float) c.radius());\n                    geomType = GeometryType_.CircleFloat;\n                }\n            } else if (g instanceof Line) {\n                Line c = (Line) g;\n                if (c.isDoublePrecision()) {\n                    geom = LineDouble_.createLineDouble_(builder, c.x1(), c.y1(), c.x2(), c.y2());\n                    geomType = GeometryType_.LineDouble;\n                } else {\n                    geom = LineFloat_.createLineFloat_(builder, (float) c.x1(), (float) c.y1(),\n                            (float) c.x2(), (float) c.y2());\n                    geomType = GeometryType_.LineFloat;\n                }\n            } else\n                throw new RuntimeException(\"unexpected\");\n\n            Geometry_.startGeometry_(builder);\n            if (geomType == GeometryType_.BoxFloat) {\n                Geometry_.addBoxFloat(builder, geom);\n            } else if (geomType == GeometryType_.BoxDouble) {\n                Geometry_.addBoxDouble(builder, geom);\n            } else if (geomType == GeometryType_.PointFloat) {\n                Geometry_.addPointFloat(builder, geom);\n            } else if (geomType == GeometryType_.PointDouble) {\n                Geometry_.addPointDouble(builder, geom);\n            } else if (geomType == GeometryType_.CircleFloat) {\n                Geometry_.addCircleFloat(builder, geom);\n            } else if (geomType == GeometryType_.CircleDouble) {\n                Geometry_.addCircleDouble(builder, geom);\n            } else if (geomType == GeometryType_.LineFloat) {\n                Geometry_.addLineFloat(builder, geom);\n            } else if (geomType == GeometryType_.LineDouble) {\n                Geometry_.addLineDouble(builder, geom);\n            } else\n                throw new RuntimeException(\"unexpected\");\n\n            Geometry_.addType(builder, geomType);\n            int geo = Geometry_.endGeometry_(builder);\n            int obj = Entry_.createObjectVector(builder, serializer.call(entries.get(i).value()));\n            entries2[i] = Entry_.createEntry_(builder, geo, obj);\n        }\n\n        int ents = Node_.createEntriesVector(builder, entries2);\n\n        Rectangle mbb = Util.mbr(entries);\n        Bounds_.startBounds_(builder);\n        if (mbb.isDoublePrecision()) {\n            int b = BoxDouble_.createBoxDouble_(builder, mbb.x1(), mbb.y1(), mbb.x2(), mbb.y2());\n            Bounds_.addBoxDouble(builder, b);\n            Bounds_.addType(builder, BoundsType_.BoundsDouble);\n        } else {\n            int b = BoxFloat_.createBoxFloat_(builder, (float) mbb.x1(), (float) mbb.y1(),\n                    (float) mbb.x2(), (float) mbb.y2());\n            Bounds_.addBoxFloat(builder, b);\n            Bounds_.addType(builder, BoundsType_.BoundsFloat);\n        }\n        int bounds = Bounds_.endBounds_(builder);\n\n        Node_.startNode_(builder);\n        Node_.addMbb(builder, bounds);\n        Node_.addEntries(builder, ents);\n        return Node_.endNode_(builder);\n\n    }\n\n    static <T, S extends Geometry> List<Entry<T, S>> createEntries(Node_ node,\n            Func1<byte[], ? extends T> deserializer) {\n        int numEntries = node.entriesLength();\n        List<Entry<T, S>> entries = new ArrayList<Entry<T, S>>(numEntries);\n        Preconditions.checkArgument(numEntries > 0);\n        Entry_ entry = new Entry_();\n        Geometry_ geom = new Geometry_();\n        for (int i = 0; i < numEntries; i++) {\n            Entry<T, S> ent = createEntry(node, deserializer, entry, geom, i);\n            entries.add(ent);\n        }\n        return entries;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private static <T, S extends Geometry> Entry<T, S> createEntry(Node_ node,\n            Func1<byte[], ? extends T> deserializer, Entry_ entry, Geometry_ geom, int i) {\n        node.entries(entry, i);\n        entry.geometry(geom);\n        final Geometry g = toGeometry(geom);\n        return Entries.entry(parseObject(deserializer, entry), (S) g);\n    }\n\n    static <T, S extends Geometry> Entry<T, S> createEntry(Node_ node,\n            Func1<byte[], ? extends T> deserializer, int i) {\n        return createEntry(node, deserializer, new Entry_(), new Geometry_(), i);\n    }\n\n    static <T> T parseObject(Func1<byte[], ? extends T> deserializer, Entry_ entry) {\n        ByteBuffer bb = entry.objectAsByteBuffer();\n        if (bb == null) {\n            return null;\n        } else {\n            byte[] bytes = Arrays.copyOfRange(bb.array(), bb.position(), bb.limit());\n            T t = deserializer.call(bytes);\n            return t;\n        }\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    static <S extends Geometry> S toGeometry(Geometry_ g) {\n        final Geometry result;\n        byte type = g.type();\n        if (type == GeometryType_.BoxFloat) {\n            result = createBox(g.boxFloat());\n        } else if (type == GeometryType_.BoxDouble) {\n            result = createBox(g.boxDouble());\n        } else if (type == GeometryType_.PointFloat) {\n            PointFloat_ p = g.pointFloat();\n            result = Geometries.point(p.x(), p.y());\n        } else if (type == GeometryType_.PointDouble) {\n            PointDouble_ p = g.pointDouble();\n            result = Geometries.point(p.x(), p.y());\n        } else if (type == GeometryType_.CircleFloat) {\n            CircleFloat_ c = g.circleFloat();\n            result = Geometries.circle(c.x(), c.y(), c.radius());\n        } else if (type == GeometryType_.CircleDouble) {\n            CircleDouble_ c = g.circleDouble();\n            result = Geometries.circle(c.x(), c.y(), c.radius());\n        } else if (type == GeometryType_.LineFloat) {\n            result = createLine(g.lineFloat());\n        } else if (type == GeometryType_.LineDouble) {\n            result = createLine(g.lineDouble());\n        } else\n            throw new RuntimeException(\"unexpected\");\n        return (S) result;\n    }\n\n    private static Geometry createBox(BoxDouble_ b) {\n        return Geometries.rectangle(b.minX(), b.minY(), b.maxX(), b.maxY());\n    }\n\n    private static Geometry createBox(BoxFloat_ b) {\n        return Geometries.rectangle(b.minX(), b.minY(), b.maxX(), b.maxY());\n    }\n\n    static Rectangle createBox(Bounds_ b) {\n        if (b.type() == BoundsType_.BoundsDouble) {\n            BoxDouble_ r = b.boxDouble();\n            return Geometries.rectangle(r.minX(), r.minY(), r.maxX(), r.maxY());\n        } else {\n            BoxFloat_ r = b.boxFloat();\n            return Geometries.rectangle(r.minX(), r.minY(), r.maxX(), r.maxY());\n        }\n    }\n\n    static Line createLine(BoxFloat_ b) {\n        return Geometries.line(b.minX(), b.minY(), b.maxX(), b.maxY());\n    }\n\n    static Line createLine(BoxDouble_ b) {\n        return Geometries.line(b.minX(), b.minY(), b.maxX(), b.maxY());\n    }\n\n}", "file_hash": "2e5fd571ccf240034e7b5eb310ac8550c01b79070340e3d73fb569e916a7657b", "file_docstring": "", "contexts": ["package com.github.davidmoten.rtree.fbs;", "import java.nio.ByteBuffer;", "import java.util.ArrayList;", "import java.util.Arrays;", "import java.util.List;", "import com.github.davidmoten.guavamini.Preconditions;", "import com.github.davidmoten.rtree.Entries;", "import com.github.davidmoten.rtree.Entry;", "import com.github.davidmoten.rtree.fbs.generated.BoundsType_;", "import com.github.davidmoten.rtree.fbs.generated.Bounds_;", "import com.github.davidmoten.rtree.fbs.generated.BoxDouble_;", "import com.github.davidmoten.rtree.fbs.generated.BoxFloat_;", "import com.github.davidmoten.rtree.fbs.generated.CircleDouble_;", "import com.github.davidmoten.rtree.fbs.generated.CircleFloat_;", "import com.github.davidmoten.rtree.fbs.generated.Entry_;", "import com.github.davidmoten.rtree.fbs.generated.GeometryType_;", "import com.github.davidmoten.rtree.fbs.generated.Geometry_;", "import com.github.davidmoten.rtree.fbs.generated.LineDouble_;", "import com.github.davidmoten.rtree.fbs.generated.LineFloat_;", "import com.github.davidmoten.rtree.fbs.generated.Node_;", "import com.github.davidmoten.rtree.fbs.generated.PointDouble_;", "import com.github.davidmoten.rtree.fbs.generated.PointFloat_;", "import com.github.davidmoten.rtree.geometry.Circle;", "import com.github.davidmoten.rtree.geometry.Geometries;", "import com.github.davidmoten.rtree.geometry.Geometry;", "import com.github.davidmoten.rtree.geometry.Line;", "import com.github.davidmoten.rtree.geometry.Point;", "import com.github.davidmoten.rtree.geometry.Rectangle;", "import com.github.davidmoten.rtree.internal.Util;", "import com.google.flatbuffers.FlatBufferBuilder;", "import rx.functions.Func1;"], "methods": [], "classes": [{"original_string": "final class FlatBuffersHelper {\n\n    private FlatBuffersHelper() {\n        // prevent instantiation\n    }\n\n    static <T, S extends Geometry> int addEntries(List<Entry<T, S>> entries,\n            FlatBufferBuilder builder, Func1<? super T, byte[]> serializer) {\n        int[] entries2 = new int[entries.size()];\n        for (int i = 0; i < entries.size(); i++) {\n            Geometry g = entries.get(i).geometry();\n            final int geom;\n            final byte geomType;\n            // Must check Point before Rectangle because Point is instance of\n            // Rectangle\n            if (g instanceof Point) {\n                Point p = (Point) g;\n                if (p.isDoublePrecision()) {\n                    geom = PointDouble_.createPointDouble_(builder, p.x(), p.y());\n                    geomType = GeometryType_.PointDouble;\n                } else {\n                    geom = PointFloat_.createPointFloat_(builder, (float) p.x(), (float) p.y());\n                    geomType = GeometryType_.PointFloat;\n                }\n            } else if (g instanceof Rectangle) {\n                Rectangle b = (Rectangle) g;\n                if (b.isDoublePrecision()) {\n                    geom = BoxDouble_.createBoxDouble_(builder, b.x1(), b.y1(), b.x2(), b.y2());\n                    geomType = GeometryType_.BoxDouble;\n                } else {\n                    geom = BoxFloat_.createBoxFloat_(builder, (float) b.x1(), (float) b.y1(),\n                            (float) b.x2(), (float) b.y2());\n                    geomType = GeometryType_.BoxFloat;\n                }\n            } else if (g instanceof Circle) {\n                Circle c = (Circle) g;\n                if (c.isDoublePrecision()) {\n                    geom = CircleDouble_.createCircleDouble_(builder, c.x(), c.y(), c.radius());\n                    geomType = GeometryType_.CircleDouble;\n                } else {\n                    geom = CircleFloat_.createCircleFloat_(builder, (float) c.x(), (float) c.y(),\n                            (float) c.radius());\n                    geomType = GeometryType_.CircleFloat;\n                }\n            } else if (g instanceof Line) {\n                Line c = (Line) g;\n                if (c.isDoublePrecision()) {\n                    geom = LineDouble_.createLineDouble_(builder, c.x1(), c.y1(), c.x2(), c.y2());\n                    geomType = GeometryType_.LineDouble;\n                } else {\n                    geom = LineFloat_.createLineFloat_(builder, (float) c.x1(), (float) c.y1(),\n                            (float) c.x2(), (float) c.y2());\n                    geomType = GeometryType_.LineFloat;\n                }\n            } else\n                throw new RuntimeException(\"unexpected\");\n\n            Geometry_.startGeometry_(builder);\n            if (geomType == GeometryType_.BoxFloat) {\n                Geometry_.addBoxFloat(builder, geom);\n            } else if (geomType == GeometryType_.BoxDouble) {\n                Geometry_.addBoxDouble(builder, geom);\n            } else if (geomType == GeometryType_.PointFloat) {\n                Geometry_.addPointFloat(builder, geom);\n            } else if (geomType == GeometryType_.PointDouble) {\n                Geometry_.addPointDouble(builder, geom);\n            } else if (geomType == GeometryType_.CircleFloat) {\n                Geometry_.addCircleFloat(builder, geom);\n            } else if (geomType == GeometryType_.CircleDouble) {\n                Geometry_.addCircleDouble(builder, geom);\n            } else if (geomType == GeometryType_.LineFloat) {\n                Geometry_.addLineFloat(builder, geom);\n            } else if (geomType == GeometryType_.LineDouble) {\n                Geometry_.addLineDouble(builder, geom);\n            } else\n                throw new RuntimeException(\"unexpected\");\n\n            Geometry_.addType(builder, geomType);\n            int geo = Geometry_.endGeometry_(builder);\n            int obj = Entry_.createObjectVector(builder, serializer.call(entries.get(i).value()));\n            entries2[i] = Entry_.createEntry_(builder, geo, obj);\n        }\n\n        int ents = Node_.createEntriesVector(builder, entries2);\n\n        Rectangle mbb = Util.mbr(entries);\n        Bounds_.startBounds_(builder);\n        if (mbb.isDoublePrecision()) {\n            int b = BoxDouble_.createBoxDouble_(builder, mbb.x1(), mbb.y1(), mbb.x2(), mbb.y2());\n            Bounds_.addBoxDouble(builder, b);\n            Bounds_.addType(builder, BoundsType_.BoundsDouble);\n        } else {\n            int b = BoxFloat_.createBoxFloat_(builder, (float) mbb.x1(), (float) mbb.y1(),\n                    (float) mbb.x2(), (float) mbb.y2());\n            Bounds_.addBoxFloat(builder, b);\n            Bounds_.addType(builder, BoundsType_.BoundsFloat);\n        }\n        int bounds = Bounds_.endBounds_(builder);\n\n        Node_.startNode_(builder);\n        Node_.addMbb(builder, bounds);\n        Node_.addEntries(builder, ents);\n        return Node_.endNode_(builder);\n\n    }\n\n    static <T, S extends Geometry> List<Entry<T, S>> createEntries(Node_ node,\n            Func1<byte[], ? extends T> deserializer) {\n        int numEntries = node.entriesLength();\n        List<Entry<T, S>> entries = new ArrayList<Entry<T, S>>(numEntries);\n        Preconditions.checkArgument(numEntries > 0);\n        Entry_ entry = new Entry_();\n        Geometry_ geom = new Geometry_();\n        for (int i = 0; i < numEntries; i++) {\n            Entry<T, S> ent = createEntry(node, deserializer, entry, geom, i);\n            entries.add(ent);\n        }\n        return entries;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private static <T, S extends Geometry> Entry<T, S> createEntry(Node_ node,\n            Func1<byte[], ? extends T> deserializer, Entry_ entry, Geometry_ geom, int i) {\n        node.entries(entry, i);\n        entry.geometry(geom);\n        final Geometry g = toGeometry(geom);\n        return Entries.entry(parseObject(deserializer, entry), (S) g);\n    }\n\n    static <T, S extends Geometry> Entry<T, S> createEntry(Node_ node,\n            Func1<byte[], ? extends T> deserializer, int i) {\n        return createEntry(node, deserializer, new Entry_(), new Geometry_(), i);\n    }\n\n    static <T> T parseObject(Func1<byte[], ? extends T> deserializer, Entry_ entry) {\n        ByteBuffer bb = entry.objectAsByteBuffer();\n        if (bb == null) {\n            return null;\n        } else {\n            byte[] bytes = Arrays.copyOfRange(bb.array(), bb.position(), bb.limit());\n            T t = deserializer.call(bytes);\n            return t;\n        }\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    static <S extends Geometry> S toGeometry(Geometry_ g) {\n        final Geometry result;\n        byte type = g.type();\n        if (type == GeometryType_.BoxFloat) {\n            result = createBox(g.boxFloat());\n        } else if (type == GeometryType_.BoxDouble) {\n            result = createBox(g.boxDouble());\n        } else if (type == GeometryType_.PointFloat) {\n            PointFloat_ p = g.pointFloat();\n            result = Geometries.point(p.x(), p.y());\n        } else if (type == GeometryType_.PointDouble) {\n            PointDouble_ p = g.pointDouble();\n            result = Geometries.point(p.x(), p.y());\n        } else if (type == GeometryType_.CircleFloat) {\n            CircleFloat_ c = g.circleFloat();\n            result = Geometries.circle(c.x(), c.y(), c.radius());\n        } else if (type == GeometryType_.CircleDouble) {\n            CircleDouble_ c = g.circleDouble();\n            result = Geometries.circle(c.x(), c.y(), c.radius());\n        } else if (type == GeometryType_.LineFloat) {\n            result = createLine(g.lineFloat());\n        } else if (type == GeometryType_.LineDouble) {\n            result = createLine(g.lineDouble());\n        } else\n            throw new RuntimeException(\"unexpected\");\n        return (S) result;\n    }\n\n    private static Geometry createBox(BoxDouble_ b) {\n        return Geometries.rectangle(b.minX(), b.minY(), b.maxX(), b.maxY());\n    }\n\n    private static Geometry createBox(BoxFloat_ b) {\n        return Geometries.rectangle(b.minX(), b.minY(), b.maxX(), b.maxY());\n    }\n\n    static Rectangle createBox(Bounds_ b) {\n        if (b.type() == BoundsType_.BoundsDouble) {\n            BoxDouble_ r = b.boxDouble();\n            return Geometries.rectangle(r.minX(), r.minY(), r.maxX(), r.maxY());\n        } else {\n            BoxFloat_ r = b.boxFloat();\n            return Geometries.rectangle(r.minX(), r.minY(), r.maxX(), r.maxY());\n        }\n    }\n\n    static Line createLine(BoxFloat_ b) {\n        return Geometries.line(b.minX(), b.minY(), b.maxX(), b.maxY());\n    }\n\n    static Line createLine(BoxDouble_ b) {\n        return Geometries.line(b.minX(), b.minY(), b.maxX(), b.maxY());\n    }\n\n}", "definition": "final class FlatBuffersHelper", "class_docstring": "", "name": "FlatBuffersHelper", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    private FlatBuffersHelper() {\n        // prevent instantiation\n    }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "", "classes": []}, "name": "FlatBuffersHelper", "params": [], "body": "                                {\n        // prevent instantiation\n    }", "signature": "private FlatBuffersHelper()"}, {"syntax_pass": true, "original_string": "    static <T, S extends Geometry> int addEntries(List<Entry<T, S>> entries,\n            FlatBufferBuilder builder, Func1<? super T, byte[]> serializer) {\n        int[] entries2 = new int[entries.size()];\n        for (int i = 0; i < entries.size(); i++) {\n            Geometry g = entries.get(i).geometry();\n            final int geom;\n            final byte geomType;\n            // Must check Point before Rectangle because Point is instance of\n            // Rectangle\n            if (g instanceof Point) {\n                Point p = (Point) g;\n                if (p.isDoublePrecision()) {\n                    geom = PointDouble_.createPointDouble_(builder, p.x(), p.y());\n                    geomType = GeometryType_.PointDouble;\n                } else {\n                    geom = PointFloat_.createPointFloat_(builder, (float) p.x(), (float) p.y());\n                    geomType = GeometryType_.PointFloat;\n                }\n            } else if (g instanceof Rectangle) {\n                Rectangle b = (Rectangle) g;\n                if (b.isDoublePrecision()) {\n                    geom = BoxDouble_.createBoxDouble_(builder, b.x1(), b.y1(), b.x2(), b.y2());\n                    geomType = GeometryType_.BoxDouble;\n                } else {\n                    geom = BoxFloat_.createBoxFloat_(builder, (float) b.x1(), (float) b.y1(),\n                            (float) b.x2(), (float) b.y2());\n                    geomType = GeometryType_.BoxFloat;\n                }\n            } else if (g instanceof Circle) {\n                Circle c = (Circle) g;\n                if (c.isDoublePrecision()) {\n                    geom = CircleDouble_.createCircleDouble_(builder, c.x(), c.y(), c.radius());\n                    geomType = GeometryType_.CircleDouble;\n                } else {\n                    geom = CircleFloat_.createCircleFloat_(builder, (float) c.x(), (float) c.y(),\n                            (float) c.radius());\n                    geomType = GeometryType_.CircleFloat;\n                }\n            } else if (g instanceof Line) {\n                Line c = (Line) g;\n                if (c.isDoublePrecision()) {\n                    geom = LineDouble_.createLineDouble_(builder, c.x1(), c.y1(), c.x2(), c.y2());\n                    geomType = GeometryType_.LineDouble;\n                } else {\n                    geom = LineFloat_.createLineFloat_(builder, (float) c.x1(), (float) c.y1(),\n                            (float) c.x2(), (float) c.y2());\n                    geomType = GeometryType_.LineFloat;\n                }\n            } else\n                throw new RuntimeException(\"unexpected\");\n\n            Geometry_.startGeometry_(builder);\n            if (geomType == GeometryType_.BoxFloat) {\n                Geometry_.addBoxFloat(builder, geom);\n            } else if (geomType == GeometryType_.BoxDouble) {\n                Geometry_.addBoxDouble(builder, geom);\n            } else if (geomType == GeometryType_.PointFloat) {\n                Geometry_.addPointFloat(builder, geom);\n            } else if (geomType == GeometryType_.PointDouble) {\n                Geometry_.addPointDouble(builder, geom);\n            } else if (geomType == GeometryType_.CircleFloat) {\n                Geometry_.addCircleFloat(builder, geom);\n            } else if (geomType == GeometryType_.CircleDouble) {\n                Geometry_.addCircleDouble(builder, geom);\n            } else if (geomType == GeometryType_.LineFloat) {\n                Geometry_.addLineFloat(builder, geom);\n            } else if (geomType == GeometryType_.LineDouble) {\n                Geometry_.addLineDouble(builder, geom);\n            } else\n                throw new RuntimeException(\"unexpected\");\n\n            Geometry_.addType(builder, geomType);\n            int geo = Geometry_.endGeometry_(builder);\n            int obj = Entry_.createObjectVector(builder, serializer.call(entries.get(i).value()));\n            entries2[i] = Entry_.createEntry_(builder, geo, obj);\n        }\n\n        int ents = Node_.createEntriesVector(builder, entries2);\n\n        Rectangle mbb = Util.mbr(entries);\n        Bounds_.startBounds_(builder);\n        if (mbb.isDoublePrecision()) {\n            int b = BoxDouble_.createBoxDouble_(builder, mbb.x1(), mbb.y1(), mbb.x2(), mbb.y2());\n            Bounds_.addBoxDouble(builder, b);\n            Bounds_.addType(builder, BoundsType_.BoundsDouble);\n        } else {\n            int b = BoxFloat_.createBoxFloat_(builder, (float) mbb.x1(), (float) mbb.y1(),\n                    (float) mbb.x2(), (float) mbb.y2());\n            Bounds_.addBoxFloat(builder, b);\n            Bounds_.addType(builder, BoundsType_.BoundsFloat);\n        }\n        int bounds = Bounds_.endBounds_(builder);\n\n        Node_.startNode_(builder);\n        Node_.addMbb(builder, bounds);\n        Node_.addEntries(builder, ents);\n        return Node_.endNode_(builder);\n\n    }", "docstring": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "int", "classes": []}, "name": "addEntries", "params": [{"name": "entries", "type": "List<Entry<T, S>>"}, {"name": "builder", "type": "FlatBufferBuilder"}, {"name": "serializer", "type": "Func1<? super T, byte[]>"}], "body": "                                                                            {\n        int[] entries2 = new int[entries.size()];\n        for (int i = 0; i < entries.size(); i++) {\n            Geometry g = entries.get(i).geometry();\n            final int geom;\n            final byte geomType;\n            // Must check Point before Rectangle because Point is instance of\n            // Rectangle\n            if (g instanceof Point) {\n                Point p = (Point) g;\n                if (p.isDoublePrecision()) {\n                    geom = PointDouble_.createPointDouble_(builder, p.x(), p.y());\n                    geomType = GeometryType_.PointDouble;\n                } else {\n                    geom = PointFloat_.createPointFloat_(builder, (float) p.x(), (float) p.y());\n                    geomType = GeometryType_.PointFloat;\n                }\n            } else if (g instanceof Rectangle) {\n                Rectangle b = (Rectangle) g;\n                if (b.isDoublePrecision()) {\n                    geom = BoxDouble_.createBoxDouble_(builder, b.x1(), b.y1(), b.x2(), b.y2());\n                    geomType = GeometryType_.BoxDouble;\n                } else {\n                    geom = BoxFloat_.createBoxFloat_(builder, (float) b.x1(), (float) b.y1(),\n                            (float) b.x2(), (float) b.y2());\n                    geomType = GeometryType_.BoxFloat;\n                }\n            } else if (g instanceof Circle) {\n                Circle c = (Circle) g;\n                if (c.isDoublePrecision()) {\n                    geom = CircleDouble_.createCircleDouble_(builder, c.x(), c.y(), c.radius());\n                    geomType = GeometryType_.CircleDouble;\n                } else {\n                    geom = CircleFloat_.createCircleFloat_(builder, (float) c.x(), (float) c.y(),\n                            (float) c.radius());\n                    geomType = GeometryType_.CircleFloat;\n                }\n            } else if (g instanceof Line) {\n                Line c = (Line) g;\n                if (c.isDoublePrecision()) {\n                    geom = LineDouble_.createLineDouble_(builder, c.x1(), c.y1(), c.x2(), c.y2());\n                    geomType = GeometryType_.LineDouble;\n                } else {\n                    geom = LineFloat_.createLineFloat_(builder, (float) c.x1(), (float) c.y1(),\n                            (float) c.x2(), (float) c.y2());\n                    geomType = GeometryType_.LineFloat;\n                }\n            } else\n                throw new RuntimeException(\"unexpected\");\n\n            Geometry_.startGeometry_(builder);\n            if (geomType == GeometryType_.BoxFloat) {\n                Geometry_.addBoxFloat(builder, geom);\n            } else if (geomType == GeometryType_.BoxDouble) {\n                Geometry_.addBoxDouble(builder, geom);\n            } else if (geomType == GeometryType_.PointFloat) {\n                Geometry_.addPointFloat(builder, geom);\n            } else if (geomType == GeometryType_.PointDouble) {\n                Geometry_.addPointDouble(builder, geom);\n            } else if (geomType == GeometryType_.CircleFloat) {\n                Geometry_.addCircleFloat(builder, geom);\n            } else if (geomType == GeometryType_.CircleDouble) {\n                Geometry_.addCircleDouble(builder, geom);\n            } else if (geomType == GeometryType_.LineFloat) {\n                Geometry_.addLineFloat(builder, geom);\n            } else if (geomType == GeometryType_.LineDouble) {\n                Geometry_.addLineDouble(builder, geom);\n            } else\n                throw new RuntimeException(\"unexpected\");\n\n            Geometry_.addType(builder, geomType);\n            int geo = Geometry_.endGeometry_(builder);\n            int obj = Entry_.createObjectVector(builder, serializer.call(entries.get(i).value()));\n            entries2[i] = Entry_.createEntry_(builder, geo, obj);\n        }\n\n        int ents = Node_.createEntriesVector(builder, entries2);\n\n        Rectangle mbb = Util.mbr(entries);\n        Bounds_.startBounds_(builder);\n        if (mbb.isDoublePrecision()) {\n            int b = BoxDouble_.createBoxDouble_(builder, mbb.x1(), mbb.y1(), mbb.x2(), mbb.y2());\n            Bounds_.addBoxDouble(builder, b);\n            Bounds_.addType(builder, BoundsType_.BoundsDouble);\n        } else {\n            int b = BoxFloat_.createBoxFloat_(builder, (float) mbb.x1(), (float) mbb.y1(),\n                    (float) mbb.x2(), (float) mbb.y2());\n            Bounds_.addBoxFloat(builder, b);\n            Bounds_.addType(builder, BoundsType_.BoundsFloat);\n        }\n        int bounds = Bounds_.endBounds_(builder);\n\n        Node_.startNode_(builder);\n        Node_.addMbb(builder, bounds);\n        Node_.addEntries(builder, ents);\n        return Node_.endNode_(builder);\n\n    }", "signature": "static <T, S extends Geometry> int addEntries(List<Entry<T, S>> entries,\n            FlatBufferBuilder builder, Func1<? super T, byte[]> serializer)"}, {"syntax_pass": true, "original_string": "    static <T, S extends Geometry> List<Entry<T, S>> createEntries(Node_ node,\n            Func1<byte[], ? extends T> deserializer) {\n        int numEntries = node.entriesLength();\n        List<Entry<T, S>> entries = new ArrayList<Entry<T, S>>(numEntries);\n        Preconditions.checkArgument(numEntries > 0);\n        Entry_ entry = new Entry_();\n        Geometry_ geom = new Geometry_();\n        for (int i = 0; i < numEntries; i++) {\n            Entry<T, S> ent = createEntry(node, deserializer, entry, geom, i);\n            entries.add(ent);\n        }\n        return entries;\n    }", "docstring": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "List<Entry<T, S>>", "classes": []}, "name": "createEntries", "params": [{"name": "node", "type": "Node_"}, {"name": "deserializer", "type": "Func1<byte[], ? extends T>"}], "body": "                                                     {\n        int numEntries = node.entriesLength();\n        List<Entry<T, S>> entries = new ArrayList<Entry<T, S>>(numEntries);\n        Preconditions.checkArgument(numEntries > 0);\n        Entry_ entry = new Entry_();\n        Geometry_ geom = new Geometry_();\n        for (int i = 0; i < numEntries; i++) {\n            Entry<T, S> ent = createEntry(node, deserializer, entry, geom, i);\n            entries.add(ent);\n        }\n        return entries;\n    }", "signature": "static <T, S extends Geometry> List<Entry<T, S>> createEntries(Node_ node,\n            Func1<byte[], ? extends T> deserializer)"}, {"syntax_pass": true, "original_string": "    @SuppressWarnings(\"unchecked\")\n    private static <T, S extends Geometry> Entry<T, S> createEntry(Node_ node,\n            Func1<byte[], ? extends T> deserializer, Entry_ entry, Geometry_ geom, int i) {\n        node.entries(entry, i);\n        entry.geometry(geom);\n        final Geometry g = toGeometry(geom);\n        return Entries.entry(parseObject(deserializer, entry), (S) g);\n    }", "docstring": "", "attributes": {"modifiers": "@SuppressWarnings(\"unchecked\")\n    private static", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings(\"unchecked\")", "private", "static"], "comments": [], "return_type": "Entry<T, S>", "classes": []}, "name": "createEntry", "params": [{"name": "node", "type": "Node_"}, {"name": "deserializer", "type": "Func1<byte[], ? extends T>"}, {"name": "entry", "type": "Entry_"}, {"name": "geom", "type": "Geometry_"}, {"name": "i", "type": "int"}], "body": "                                                                                          {\n        node.entries(entry, i);\n        entry.geometry(geom);\n        final Geometry g = toGeometry(geom);\n        return Entries.entry(parseObject(deserializer, entry), (S) g);\n    }", "signature": "@SuppressWarnings(\"unchecked\")\n    private static <T, S extends Geometry> Entry<T, S> createEntry(Node_ node,\n            Func1<byte[], ? extends T> deserializer, Entry_ entry, Geometry_ geom, int i)"}, {"syntax_pass": true, "original_string": "    static <T, S extends Geometry> Entry<T, S> createEntry(Node_ node,\n            Func1<byte[], ? extends T> deserializer, int i) {\n        return createEntry(node, deserializer, new Entry_(), new Geometry_(), i);\n    }", "docstring": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "Entry<T, S>", "classes": []}, "name": "createEntry", "params": [{"name": "node", "type": "Node_"}, {"name": "deserializer", "type": "Func1<byte[], ? extends T>"}, {"name": "i", "type": "int"}], "body": "                                                            {\n        return createEntry(node, deserializer, new Entry_(), new Geometry_(), i);\n    }", "signature": "static <T, S extends Geometry> Entry<T, S> createEntry(Node_ node,\n            Func1<byte[], ? extends T> deserializer, int i)"}, {"syntax_pass": true, "original_string": "    static <T> T parseObject(Func1<byte[], ? extends T> deserializer, Entry_ entry) {\n        ByteBuffer bb = entry.objectAsByteBuffer();\n        if (bb == null) {\n            return null;\n        } else {\n            byte[] bytes = Arrays.copyOfRange(bb.array(), bb.position(), bb.limit());\n            T t = deserializer.call(bytes);\n            return t;\n        }\n    }", "docstring": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "T", "classes": []}, "name": "parseObject", "params": [{"name": "deserializer", "type": "Func1<byte[], ? extends T>"}, {"name": "entry", "type": "Entry_"}], "body": "                                                                                    {\n        ByteBuffer bb = entry.objectAsByteBuffer();\n        if (bb == null) {\n            return null;\n        } else {\n            byte[] bytes = Arrays.copyOfRange(bb.array(), bb.position(), bb.limit());\n            T t = deserializer.call(bytes);\n            return t;\n        }\n    }", "signature": "static <T> T parseObject(Func1<byte[], ? extends T> deserializer, Entry_ entry)"}, {"syntax_pass": true, "original_string": "    @SuppressWarnings(\"unchecked\")\n    static <S extends Geometry> S toGeometry(Geometry_ g) {\n        final Geometry result;\n        byte type = g.type();\n        if (type == GeometryType_.BoxFloat) {\n            result = createBox(g.boxFloat());\n        } else if (type == GeometryType_.BoxDouble) {\n            result = createBox(g.boxDouble());\n        } else if (type == GeometryType_.PointFloat) {\n            PointFloat_ p = g.pointFloat();\n            result = Geometries.point(p.x(), p.y());\n        } else if (type == GeometryType_.PointDouble) {\n            PointDouble_ p = g.pointDouble();\n            result = Geometries.point(p.x(), p.y());\n        } else if (type == GeometryType_.CircleFloat) {\n            CircleFloat_ c = g.circleFloat();\n            result = Geometries.circle(c.x(), c.y(), c.radius());\n        } else if (type == GeometryType_.CircleDouble) {\n            CircleDouble_ c = g.circleDouble();\n            result = Geometries.circle(c.x(), c.y(), c.radius());\n        } else if (type == GeometryType_.LineFloat) {\n            result = createLine(g.lineFloat());\n        } else if (type == GeometryType_.LineDouble) {\n            result = createLine(g.lineDouble());\n        } else\n            throw new RuntimeException(\"unexpected\");\n        return (S) result;\n    }", "docstring": "", "attributes": {"modifiers": "@SuppressWarnings(\"unchecked\")\n    static", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings(\"unchecked\")", "static"], "comments": [], "return_type": "S", "classes": []}, "name": "toGeometry", "params": [{"name": "g", "type": "Geometry_"}], "body": "                                                          {\n        final Geometry result;\n        byte type = g.type();\n        if (type == GeometryType_.BoxFloat) {\n            result = createBox(g.boxFloat());\n        } else if (type == GeometryType_.BoxDouble) {\n            result = createBox(g.boxDouble());\n        } else if (type == GeometryType_.PointFloat) {\n            PointFloat_ p = g.pointFloat();\n            result = Geometries.point(p.x(), p.y());\n        } else if (type == GeometryType_.PointDouble) {\n            PointDouble_ p = g.pointDouble();\n            result = Geometries.point(p.x(), p.y());\n        } else if (type == GeometryType_.CircleFloat) {\n            CircleFloat_ c = g.circleFloat();\n            result = Geometries.circle(c.x(), c.y(), c.radius());\n        } else if (type == GeometryType_.CircleDouble) {\n            CircleDouble_ c = g.circleDouble();\n            result = Geometries.circle(c.x(), c.y(), c.radius());\n        } else if (type == GeometryType_.LineFloat) {\n            result = createLine(g.lineFloat());\n        } else if (type == GeometryType_.LineDouble) {\n            result = createLine(g.lineDouble());\n        } else\n            throw new RuntimeException(\"unexpected\");\n        return (S) result;\n    }", "signature": "@SuppressWarnings(\"unchecked\")\n    static <S extends Geometry> S toGeometry(Geometry_ g)"}, {"syntax_pass": true, "original_string": "    private static Geometry createBox(BoxDouble_ b) {\n        return Geometries.rectangle(b.minX(), b.minY(), b.maxX(), b.maxY());\n    }", "docstring": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "Geometry", "classes": []}, "name": "createBox", "params": [{"name": "b", "type": "BoxDouble_"}], "body": "                                                    {\n        return Geometries.rectangle(b.minX(), b.minY(), b.maxX(), b.maxY());\n    }", "signature": "private static Geometry createBox(BoxDouble_ b)"}, {"syntax_pass": true, "original_string": "    private static Geometry createBox(BoxFloat_ b) {\n        return Geometries.rectangle(b.minX(), b.minY(), b.maxX(), b.maxY());\n    }", "docstring": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "Geometry", "classes": []}, "name": "createBox", "params": [{"name": "b", "type": "BoxFloat_"}], "body": "                                                   {\n        return Geometries.rectangle(b.minX(), b.minY(), b.maxX(), b.maxY());\n    }", "signature": "private static Geometry createBox(BoxFloat_ b)"}, {"syntax_pass": true, "original_string": "    static Rectangle createBox(Bounds_ b) {\n        if (b.type() == BoundsType_.BoundsDouble) {\n            BoxDouble_ r = b.boxDouble();\n            return Geometries.rectangle(r.minX(), r.minY(), r.maxX(), r.maxY());\n        } else {\n            BoxFloat_ r = b.boxFloat();\n            return Geometries.rectangle(r.minX(), r.minY(), r.maxX(), r.maxY());\n        }\n    }", "docstring": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "Rectangle", "classes": []}, "name": "createBox", "params": [{"name": "b", "type": "Bounds_"}], "body": "                                          {\n        if (b.type() == BoundsType_.BoundsDouble) {\n            BoxDouble_ r = b.boxDouble();\n            return Geometries.rectangle(r.minX(), r.minY(), r.maxX(), r.maxY());\n        } else {\n            BoxFloat_ r = b.boxFloat();\n            return Geometries.rectangle(r.minX(), r.minY(), r.maxX(), r.maxY());\n        }\n    }", "signature": "static Rectangle createBox(Bounds_ b)"}, {"syntax_pass": true, "original_string": "    static Line createLine(BoxFloat_ b) {\n        return Geometries.line(b.minX(), b.minY(), b.maxX(), b.maxY());\n    }", "docstring": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "Line", "classes": []}, "name": "createLine", "params": [{"name": "b", "type": "BoxFloat_"}], "body": "                                        {\n        return Geometries.line(b.minX(), b.minY(), b.maxX(), b.maxY());\n    }", "signature": "static Line createLine(BoxFloat_ b)"}, {"syntax_pass": true, "original_string": "    static Line createLine(BoxDouble_ b) {\n        return Geometries.line(b.minX(), b.minY(), b.maxX(), b.maxY());\n    }", "docstring": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "Line", "classes": []}, "name": "createLine", "params": [{"name": "b", "type": "BoxDouble_"}], "body": "                                         {\n        return Geometries.line(b.minX(), b.minY(), b.maxX(), b.maxY());\n    }", "signature": "static Line createLine(BoxDouble_ b)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/com/github/davidmoten/rtree/fbs/FactoryFlatBuffers.java", "original_string": "package com.github.davidmoten.rtree.fbs;\n\n\nimport java.util.List;\n\nimport com.github.davidmoten.guavamini.Preconditions;\nimport com.github.davidmoten.rtree.Context;\nimport com.github.davidmoten.rtree.Entries;\nimport com.github.davidmoten.rtree.Entry;\nimport com.github.davidmoten.rtree.Factory;\nimport com.github.davidmoten.rtree.Leaf;\nimport com.github.davidmoten.rtree.Node;\nimport com.github.davidmoten.rtree.NonLeaf;\nimport com.github.davidmoten.rtree.geometry.Geometry;\nimport com.github.davidmoten.rtree.internal.FactoryDefault;\nimport com.github.davidmoten.rtree.internal.NonLeafDefault;\n\nimport rx.functions.Func1;\n\n/**\n * Conserves memory in comparison to {@link FactoryDefault} especially for\n * larger {@code maxChildren} by saving Leaf objects to byte arrays and using\n * FlatBuffers to access the byte array.\n *\n * @param <T>\n *            the object type\n * @param <S>\n *            the geometry type\n */\npublic final class FactoryFlatBuffers<T, S extends Geometry> implements Factory<T, S> {\n    private final Func1<? super T, byte[]> serializer;\n    private final Func1<byte[], ? extends T> deserializer;\n\n    public FactoryFlatBuffers(Func1<? super T, byte[]> serializer, Func1<byte[], ? extends T> deserializer) {\n        Preconditions.checkNotNull(serializer);\n        Preconditions.checkNotNull(deserializer);\n        this.serializer = serializer;\n        this.deserializer = deserializer;\n    }\n\n    @Override\n    public Leaf<T, S> createLeaf(List<Entry<T, S>> entries, Context<T, S> context) {\n        return new LeafFlatBuffers<T, S>(entries, context, serializer, deserializer);\n    }\n\n    @Override\n    public NonLeaf<T, S> createNonLeaf(List<? extends Node<T, S>> children, Context<T, S> context) {\n        return new NonLeafDefault<T, S>(children, context);\n    }\n\n    @Override\n    public Entry<T, S> createEntry(T value, S geometry) {\n        return Entries.entry(value, geometry);\n    }\n\n    public Func1<? super T, byte[]> serializer() {\n        return serializer;\n    }\n\n    public Func1<byte[], ? extends T> deserializer() {\n        return deserializer;\n    }\n\n}\n", "file_hash": "d55b75e6dfc6fd30c509aab51e49ced465c38a4af31e72b0dd6cb5bd7dc13e93", "file_docstring": "", "contexts": ["package com.github.davidmoten.rtree.fbs;", "import java.util.List;", "import com.github.davidmoten.guavamini.Preconditions;", "import com.github.davidmoten.rtree.Context;", "import com.github.davidmoten.rtree.Entries;", "import com.github.davidmoten.rtree.Entry;", "import com.github.davidmoten.rtree.Factory;", "import com.github.davidmoten.rtree.Leaf;", "import com.github.davidmoten.rtree.Node;", "import com.github.davidmoten.rtree.NonLeaf;", "import com.github.davidmoten.rtree.geometry.Geometry;", "import com.github.davidmoten.rtree.internal.FactoryDefault;", "import com.github.davidmoten.rtree.internal.NonLeafDefault;", "import rx.functions.Func1;"], "methods": [], "classes": [{"original_string": "public final class FactoryFlatBuffers<T, S extends Geometry> implements Factory<T, S> {\n    private final Func1<? super T, byte[]> serializer;\n    private final Func1<byte[], ? extends T> deserializer;\n\n    public FactoryFlatBuffers(Func1<? super T, byte[]> serializer, Func1<byte[], ? extends T> deserializer) {\n        Preconditions.checkNotNull(serializer);\n        Preconditions.checkNotNull(deserializer);\n        this.serializer = serializer;\n        this.deserializer = deserializer;\n    }\n\n    @Override\n    public Leaf<T, S> createLeaf(List<Entry<T, S>> entries, Context<T, S> context) {\n        return new LeafFlatBuffers<T, S>(entries, context, serializer, deserializer);\n    }\n\n    @Override\n    public NonLeaf<T, S> createNonLeaf(List<? extends Node<T, S>> children, Context<T, S> context) {\n        return new NonLeafDefault<T, S>(children, context);\n    }\n\n    @Override\n    public Entry<T, S> createEntry(T value, S geometry) {\n        return Entries.entry(value, geometry);\n    }\n\n    public Func1<? super T, byte[]> serializer() {\n        return serializer;\n    }\n\n    public Func1<byte[], ? extends T> deserializer() {\n        return deserializer;\n    }\n\n}", "definition": "public final class FactoryFlatBuffers<T, S extends Geometry> implements Factory<T, S>", "class_docstring": "\nConserves memory in comparison to {@link FactoryDefault} especially for\nlarger {@code maxChildren} by saving Leaf objects to byte arrays and using\nFlatBuffers to access the byte array.\n\n@param <T>\n           the object type\n@param <S>\n           the geometry type\n", "name": "FactoryFlatBuffers", "super_interfaces": ["Factory<T, S>"], "superclasses": "", "attributes": {"modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "fields": [{"attribute_expression": "private final Func1<? super T, byte[]> serializer;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Func1<? super T, byte[]>", "name": "serializer", "syntax_pass": true}, {"attribute_expression": "private final Func1<byte[], ? extends T> deserializer;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Func1<byte[], ? extends T>", "name": "deserializer", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    public FactoryFlatBuffers(Func1<? super T, byte[]> serializer, Func1<byte[], ? extends T> deserializer) {\n        Preconditions.checkNotNull(serializer);\n        Preconditions.checkNotNull(deserializer);\n        this.serializer = serializer;\n        this.deserializer = deserializer;\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "FactoryFlatBuffers", "params": [{"name": "serializer", "type": "Func1<? super T, byte[]>"}, {"name": "deserializer", "type": "Func1<byte[], ? extends T>"}], "body": "                                                                                                            {\n        Preconditions.checkNotNull(serializer);\n        Preconditions.checkNotNull(deserializer);\n        this.serializer = serializer;\n        this.deserializer = deserializer;\n    }", "signature": "public FactoryFlatBuffers(Func1<? super T, byte[]> serializer, Func1<byte[], ? extends T> deserializer)"}, {"syntax_pass": true, "original_string": "    @Override\n    public Leaf<T, S> createLeaf(List<Entry<T, S>> entries, Context<T, S> context) {\n        return new LeafFlatBuffers<T, S>(entries, context, serializer, deserializer);\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Leaf<T, S>", "classes": []}, "name": "createLeaf", "params": [{"name": "entries", "type": "List<Entry<T, S>>"}, {"name": "context", "type": "Context<T, S>"}], "body": "                                                                                   {\n        return new LeafFlatBuffers<T, S>(entries, context, serializer, deserializer);\n    }", "signature": "@Override\n    public Leaf<T, S> createLeaf(List<Entry<T, S>> entries, Context<T, S> context)"}, {"syntax_pass": true, "original_string": "    @Override\n    public NonLeaf<T, S> createNonLeaf(List<? extends Node<T, S>> children, Context<T, S> context) {\n        return new NonLeafDefault<T, S>(children, context);\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "NonLeaf<T, S>", "classes": []}, "name": "createNonLeaf", "params": [{"name": "children", "type": "List<? extends Node<T, S>>"}, {"name": "context", "type": "Context<T, S>"}], "body": "                                                                                                   {\n        return new NonLeafDefault<T, S>(children, context);\n    }", "signature": "@Override\n    public NonLeaf<T, S> createNonLeaf(List<? extends Node<T, S>> children, Context<T, S> context)"}, {"syntax_pass": true, "original_string": "    @Override\n    public Entry<T, S> createEntry(T value, S geometry) {\n        return Entries.entry(value, geometry);\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Entry<T, S>", "classes": []}, "name": "createEntry", "params": [{"name": "value", "type": "T"}, {"name": "geometry", "type": "S"}], "body": "                                                        {\n        return Entries.entry(value, geometry);\n    }", "signature": "@Override\n    public Entry<T, S> createEntry(T value, S geometry)"}, {"syntax_pass": true, "original_string": "    public Func1<? super T, byte[]> serializer() {\n        return serializer;\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Func1<? super T, byte[]>", "classes": []}, "name": "serializer", "params": [], "body": "                                                 {\n        return serializer;\n    }", "signature": "public Func1<? super T, byte[]> serializer()"}, {"syntax_pass": true, "original_string": "    public Func1<byte[], ? extends T> deserializer() {\n        return deserializer;\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Func1<byte[], ? extends T>", "classes": []}, "name": "deserializer", "params": [], "body": "                                                     {\n        return deserializer;\n    }", "signature": "public Func1<byte[], ? extends T> deserializer()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/com/github/davidmoten/rtree/fbs/generated/BoxFloat_.java", "original_string": "// automatically generated by the FlatBuffers compiler, do not modify\n\npackage com.github.davidmoten.rtree.fbs.generated;\n\nimport java.nio.*;\nimport java.lang.*;\nimport java.util.*;\nimport com.google.flatbuffers.*;\n\n@SuppressWarnings(\"unused\")\npublic final class BoxFloat_ extends Struct {\n  public void __init(int _i, ByteBuffer _bb) { __reset(_i, _bb); }\n  public BoxFloat_ __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }\n\n  public float minX() { return bb.getFloat(bb_pos + 0); }\n  public float minY() { return bb.getFloat(bb_pos + 4); }\n  public float maxX() { return bb.getFloat(bb_pos + 8); }\n  public float maxY() { return bb.getFloat(bb_pos + 12); }\n\n  public static int createBoxFloat_(FlatBufferBuilder builder, float minX, float minY, float maxX, float maxY) {\n    builder.prep(4, 16);\n    builder.putFloat(maxY);\n    builder.putFloat(maxX);\n    builder.putFloat(minY);\n    builder.putFloat(minX);\n    return builder.offset();\n  }\n\n  public static final class Vector extends BaseVector {\n    public Vector __assign(int _vector, int _element_size, ByteBuffer _bb) { __reset(_vector, _element_size, _bb); return this; }\n\n    public BoxFloat_ get(int j) { return get(new BoxFloat_(), j); }\n    public BoxFloat_ get(BoxFloat_ obj, int j) {  return obj.__assign(__element(j), bb); }\n  }\n}\n\n", "file_hash": "cc050bfbd47af881bb341ce0affb2931347cf232a2090d3f5ff59f337f552ea5", "file_docstring": " automatically generated by the FlatBuffers compiler, do not modify", "contexts": ["package com.github.davidmoten.rtree.fbs.generated;", "import java.nio.*;", "import java.lang.*;", "import java.util.*;", "import com.google.flatbuffers.*;"], "methods": [], "classes": [{"original_string": "@SuppressWarnings(\"unused\")\npublic final class BoxFloat_ extends Struct {\n  public void __init(int _i, ByteBuffer _bb) { __reset(_i, _bb); }\n  public BoxFloat_ __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }\n\n  public float minX() { return bb.getFloat(bb_pos + 0); }\n  public float minY() { return bb.getFloat(bb_pos + 4); }\n  public float maxX() { return bb.getFloat(bb_pos + 8); }\n  public float maxY() { return bb.getFloat(bb_pos + 12); }\n\n  public static int createBoxFloat_(FlatBufferBuilder builder, float minX, float minY, float maxX, float maxY) {\n    builder.prep(4, 16);\n    builder.putFloat(maxY);\n    builder.putFloat(maxX);\n    builder.putFloat(minY);\n    builder.putFloat(minX);\n    return builder.offset();\n  }\n\n  public static final class Vector extends BaseVector {\n    public Vector __assign(int _vector, int _element_size, ByteBuffer _bb) { __reset(_vector, _element_size, _bb); return this; }\n\n    public BoxFloat_ get(int j) { return get(new BoxFloat_(), j); }\n    public BoxFloat_ get(BoxFloat_ obj, int j) {  return obj.__assign(__element(j), bb); }\n  }\n}", "definition": "@SuppressWarnings(\"unused\")\npublic final class BoxFloat_ extends Struct", "class_docstring": "", "name": "BoxFloat_", "super_interfaces": [], "superclasses": "Struct", "attributes": {"modifiers": "@SuppressWarnings(\"unused\")\npublic final", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings(\"unused\")", "public", "final"], "comments": [], "fields": [], "classes": [{"original_string": "  public static final class Vector extends BaseVector {\n    public Vector __assign(int _vector, int _element_size, ByteBuffer _bb) { __reset(_vector, _element_size, _bb); return this; }\n\n    public BoxFloat_ get(int j) { return get(new BoxFloat_(), j); }\n    public BoxFloat_ get(BoxFloat_ obj, int j) {  return obj.__assign(__element(j), bb); }\n  }", "definition": "  public static final class Vector extends BaseVector", "class_docstring": "", "name": "Vector", "super_interfaces": [], "superclasses": "BaseVector", "attributes": {"modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    public Vector __assign(int _vector, int _element_size, ByteBuffer _bb) { __reset(_vector, _element_size, _bb); return this; }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Vector", "classes": []}, "name": "__assign", "params": [{"name": "_vector", "type": "int"}, {"name": "_element_size", "type": "int"}, {"name": "_bb", "type": "ByteBuffer"}], "body": "                                                                           { __reset(_vector, _element_size, _bb); return this; }", "signature": "public Vector __assign(int _vector, int _element_size, ByteBuffer _bb)"}, {"syntax_pass": true, "original_string": "    public BoxFloat_ get(int j) { return get(new BoxFloat_(), j); }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "BoxFloat_", "classes": []}, "name": "get", "params": [{"name": "j", "type": "int"}], "body": "                                { return get(new BoxFloat_(), j); }", "signature": "public BoxFloat_ get(int j)"}, {"syntax_pass": true, "original_string": "    public BoxFloat_ get(BoxFloat_ obj, int j) {  return obj.__assign(__element(j), bb); }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "BoxFloat_", "classes": []}, "name": "get", "params": [{"name": "obj", "type": "BoxFloat_"}, {"name": "j", "type": "int"}], "body": "                                               {  return obj.__assign(__element(j), bb); }", "signature": "public BoxFloat_ get(BoxFloat_ obj, int j)"}]}]}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "  public void __init(int _i, ByteBuffer _bb) { __reset(_i, _bb); }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "__init", "params": [{"name": "_i", "type": "int"}, {"name": "_bb", "type": "ByteBuffer"}], "body": "                                             { __reset(_i, _bb); }", "signature": "public void __init(int _i, ByteBuffer _bb)"}, {"syntax_pass": true, "original_string": "  public BoxFloat_ __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "BoxFloat_", "classes": []}, "name": "__assign", "params": [{"name": "_i", "type": "int"}, {"name": "_bb", "type": "ByteBuffer"}], "body": "                                                    { __init(_i, _bb); return this; }", "signature": "public BoxFloat_ __assign(int _i, ByteBuffer _bb)"}, {"syntax_pass": true, "original_string": "  public float minX() { return bb.getFloat(bb_pos + 0); }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "float", "classes": []}, "name": "minX", "params": [], "body": "                      { return bb.getFloat(bb_pos + 0); }", "signature": "public float minX()"}, {"syntax_pass": true, "original_string": "  public float minY() { return bb.getFloat(bb_pos + 4); }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "float", "classes": []}, "name": "minY", "params": [], "body": "                      { return bb.getFloat(bb_pos + 4); }", "signature": "public float minY()"}, {"syntax_pass": true, "original_string": "  public float maxX() { return bb.getFloat(bb_pos + 8); }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "float", "classes": []}, "name": "maxX", "params": [], "body": "                      { return bb.getFloat(bb_pos + 8); }", "signature": "public float maxX()"}, {"syntax_pass": true, "original_string": "  public float maxY() { return bb.getFloat(bb_pos + 12); }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "float", "classes": []}, "name": "maxY", "params": [], "body": "                      { return bb.getFloat(bb_pos + 12); }", "signature": "public float maxY()"}, {"syntax_pass": true, "original_string": "  public static int createBoxFloat_(FlatBufferBuilder builder, float minX, float minY, float maxX, float maxY) {\n    builder.prep(4, 16);\n    builder.putFloat(maxY);\n    builder.putFloat(maxX);\n    builder.putFloat(minY);\n    builder.putFloat(minX);\n    return builder.offset();\n  }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "int", "classes": []}, "name": "createBoxFloat_", "params": [{"name": "builder", "type": "FlatBufferBuilder"}, {"name": "minX", "type": "float"}, {"name": "minY", "type": "float"}, {"name": "maxX", "type": "float"}, {"name": "maxY", "type": "float"}], "body": "                                                                                                               {\n    builder.prep(4, 16);\n    builder.putFloat(maxY);\n    builder.putFloat(maxX);\n    builder.putFloat(minY);\n    builder.putFloat(minX);\n    return builder.offset();\n  }", "signature": "public static int createBoxFloat_(FlatBufferBuilder builder, float minX, float minY, float maxX, float maxY)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/com/github/davidmoten/rtree/fbs/generated/PointDouble_.java", "original_string": "// automatically generated by the FlatBuffers compiler, do not modify\n\npackage com.github.davidmoten.rtree.fbs.generated;\n\nimport java.nio.*;\nimport java.lang.*;\nimport java.util.*;\nimport com.google.flatbuffers.*;\n\n@SuppressWarnings(\"unused\")\npublic final class PointDouble_ extends Struct {\n  public void __init(int _i, ByteBuffer _bb) { __reset(_i, _bb); }\n  public PointDouble_ __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }\n\n  public double x() { return bb.getDouble(bb_pos + 0); }\n  public double y() { return bb.getDouble(bb_pos + 8); }\n\n  public static int createPointDouble_(FlatBufferBuilder builder, double x, double y) {\n    builder.prep(8, 16);\n    builder.putDouble(y);\n    builder.putDouble(x);\n    return builder.offset();\n  }\n\n  public static final class Vector extends BaseVector {\n    public Vector __assign(int _vector, int _element_size, ByteBuffer _bb) { __reset(_vector, _element_size, _bb); return this; }\n\n    public PointDouble_ get(int j) { return get(new PointDouble_(), j); }\n    public PointDouble_ get(PointDouble_ obj, int j) {  return obj.__assign(__element(j), bb); }\n  }\n}\n\n", "file_hash": "6af2fa2b8640f9fc265aa147cb02bda0187fb48e7096c642a6c3de9f0f77087b", "file_docstring": " automatically generated by the FlatBuffers compiler, do not modify", "contexts": ["package com.github.davidmoten.rtree.fbs.generated;", "import java.nio.*;", "import java.lang.*;", "import java.util.*;", "import com.google.flatbuffers.*;"], "methods": [], "classes": [{"original_string": "@SuppressWarnings(\"unused\")\npublic final class PointDouble_ extends Struct {\n  public void __init(int _i, ByteBuffer _bb) { __reset(_i, _bb); }\n  public PointDouble_ __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }\n\n  public double x() { return bb.getDouble(bb_pos + 0); }\n  public double y() { return bb.getDouble(bb_pos + 8); }\n\n  public static int createPointDouble_(FlatBufferBuilder builder, double x, double y) {\n    builder.prep(8, 16);\n    builder.putDouble(y);\n    builder.putDouble(x);\n    return builder.offset();\n  }\n\n  public static final class Vector extends BaseVector {\n    public Vector __assign(int _vector, int _element_size, ByteBuffer _bb) { __reset(_vector, _element_size, _bb); return this; }\n\n    public PointDouble_ get(int j) { return get(new PointDouble_(), j); }\n    public PointDouble_ get(PointDouble_ obj, int j) {  return obj.__assign(__element(j), bb); }\n  }\n}", "definition": "@SuppressWarnings(\"unused\")\npublic final class PointDouble_ extends Struct", "class_docstring": "", "name": "PointDouble_", "super_interfaces": [], "superclasses": "Struct", "attributes": {"modifiers": "@SuppressWarnings(\"unused\")\npublic final", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings(\"unused\")", "public", "final"], "comments": [], "fields": [], "classes": [{"original_string": "  public static final class Vector extends BaseVector {\n    public Vector __assign(int _vector, int _element_size, ByteBuffer _bb) { __reset(_vector, _element_size, _bb); return this; }\n\n    public PointDouble_ get(int j) { return get(new PointDouble_(), j); }\n    public PointDouble_ get(PointDouble_ obj, int j) {  return obj.__assign(__element(j), bb); }\n  }", "definition": "  public static final class Vector extends BaseVector", "class_docstring": "", "name": "Vector", "super_interfaces": [], "superclasses": "BaseVector", "attributes": {"modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    public Vector __assign(int _vector, int _element_size, ByteBuffer _bb) { __reset(_vector, _element_size, _bb); return this; }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Vector", "classes": []}, "name": "__assign", "params": [{"name": "_vector", "type": "int"}, {"name": "_element_size", "type": "int"}, {"name": "_bb", "type": "ByteBuffer"}], "body": "                                                                           { __reset(_vector, _element_size, _bb); return this; }", "signature": "public Vector __assign(int _vector, int _element_size, ByteBuffer _bb)"}, {"syntax_pass": true, "original_string": "    public PointDouble_ get(int j) { return get(new PointDouble_(), j); }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "PointDouble_", "classes": []}, "name": "get", "params": [{"name": "j", "type": "int"}], "body": "                                   { return get(new PointDouble_(), j); }", "signature": "public PointDouble_ get(int j)"}, {"syntax_pass": true, "original_string": "    public PointDouble_ get(PointDouble_ obj, int j) {  return obj.__assign(__element(j), bb); }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "PointDouble_", "classes": []}, "name": "get", "params": [{"name": "obj", "type": "PointDouble_"}, {"name": "j", "type": "int"}], "body": "                                                     {  return obj.__assign(__element(j), bb); }", "signature": "public PointDouble_ get(PointDouble_ obj, int j)"}]}]}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "  public void __init(int _i, ByteBuffer _bb) { __reset(_i, _bb); }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "__init", "params": [{"name": "_i", "type": "int"}, {"name": "_bb", "type": "ByteBuffer"}], "body": "                                             { __reset(_i, _bb); }", "signature": "public void __init(int _i, ByteBuffer _bb)"}, {"syntax_pass": true, "original_string": "  public PointDouble_ __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "PointDouble_", "classes": []}, "name": "__assign", "params": [{"name": "_i", "type": "int"}, {"name": "_bb", "type": "ByteBuffer"}], "body": "                                                       { __init(_i, _bb); return this; }", "signature": "public PointDouble_ __assign(int _i, ByteBuffer _bb)"}, {"syntax_pass": true, "original_string": "  public double x() { return bb.getDouble(bb_pos + 0); }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "double", "classes": []}, "name": "x", "params": [], "body": "                    { return bb.getDouble(bb_pos + 0); }", "signature": "public double x()"}, {"syntax_pass": true, "original_string": "  public double y() { return bb.getDouble(bb_pos + 8); }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "double", "classes": []}, "name": "y", "params": [], "body": "                    { return bb.getDouble(bb_pos + 8); }", "signature": "public double y()"}, {"syntax_pass": true, "original_string": "  public static int createPointDouble_(FlatBufferBuilder builder, double x, double y) {\n    builder.prep(8, 16);\n    builder.putDouble(y);\n    builder.putDouble(x);\n    return builder.offset();\n  }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "int", "classes": []}, "name": "createPointDouble_", "params": [{"name": "builder", "type": "FlatBufferBuilder"}, {"name": "x", "type": "double"}, {"name": "y", "type": "double"}], "body": "                                                                                      {\n    builder.prep(8, 16);\n    builder.putDouble(y);\n    builder.putDouble(x);\n    return builder.offset();\n  }", "signature": "public static int createPointDouble_(FlatBufferBuilder builder, double x, double y)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/com/github/davidmoten/rtree/fbs/generated/Tree_.java", "original_string": "// automatically generated by the FlatBuffers compiler, do not modify\n\npackage com.github.davidmoten.rtree.fbs.generated;\n\nimport java.nio.*;\nimport java.lang.*;\nimport java.util.*;\nimport com.google.flatbuffers.*;\n\n@SuppressWarnings(\"unused\")\npublic final class Tree_ extends Table {\n  public static void ValidateVersion() { Constants.FLATBUFFERS_2_0_8(); }\n  public static Tree_ getRootAsTree_(ByteBuffer _bb) { return getRootAsTree_(_bb, new Tree_()); }\n  public static Tree_ getRootAsTree_(ByteBuffer _bb, Tree_ obj) { _bb.order(ByteOrder.LITTLE_ENDIAN); return (obj.__assign(_bb.getInt(_bb.position()) + _bb.position(), _bb)); }\n  public void __init(int _i, ByteBuffer _bb) { __reset(_i, _bb); }\n  public Tree_ __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }\n\n  public com.github.davidmoten.rtree.fbs.generated.Context_ context() { return context(new com.github.davidmoten.rtree.fbs.generated.Context_()); }\n  public com.github.davidmoten.rtree.fbs.generated.Context_ context(com.github.davidmoten.rtree.fbs.generated.Context_ obj) { int o = __offset(4); return o != 0 ? obj.__assign(__indirect(o + bb_pos), bb) : null; }\n  public com.github.davidmoten.rtree.fbs.generated.Node_ root() { return root(new com.github.davidmoten.rtree.fbs.generated.Node_()); }\n  public com.github.davidmoten.rtree.fbs.generated.Node_ root(com.github.davidmoten.rtree.fbs.generated.Node_ obj) { int o = __offset(6); return o != 0 ? obj.__assign(__indirect(o + bb_pos), bb) : null; }\n  public long size() { int o = __offset(8); return o != 0 ? (long)bb.getInt(o + bb_pos) & 0xFFFFFFFFL : 0L; }\n\n  public static int createTree_(FlatBufferBuilder builder,\n      int contextOffset,\n      int rootOffset,\n      long size) {\n    builder.startTable(3);\n    Tree_.addSize(builder, size);\n    Tree_.addRoot(builder, rootOffset);\n    Tree_.addContext(builder, contextOffset);\n    return Tree_.endTree_(builder);\n  }\n\n  public static void startTree_(FlatBufferBuilder builder) { builder.startTable(3); }\n  public static void addContext(FlatBufferBuilder builder, int contextOffset) { builder.addOffset(0, contextOffset, 0); }\n  public static void addRoot(FlatBufferBuilder builder, int rootOffset) { builder.addOffset(1, rootOffset, 0); }\n  public static void addSize(FlatBufferBuilder builder, long size) { builder.addInt(2, (int)size, (int)0L); }\n  public static int endTree_(FlatBufferBuilder builder) {\n    int o = builder.endTable();\n    return o;\n  }\n  public static void finishTree_Buffer(FlatBufferBuilder builder, int offset) { builder.finish(offset); }\n  public static void finishSizePrefixedTree_Buffer(FlatBufferBuilder builder, int offset) { builder.finishSizePrefixed(offset); }\n\n  public static final class Vector extends BaseVector {\n    public Vector __assign(int _vector, int _element_size, ByteBuffer _bb) { __reset(_vector, _element_size, _bb); return this; }\n\n    public Tree_ get(int j) { return get(new Tree_(), j); }\n    public Tree_ get(Tree_ obj, int j) {  return obj.__assign(__indirect(__element(j), bb), bb); }\n  }\n}\n\n", "file_hash": "c0b061a4fd7f8cfd12fa4521e9aa9d1399cf4f680c690e5cf7cbef8887254de7", "file_docstring": " automatically generated by the FlatBuffers compiler, do not modify", "contexts": ["package com.github.davidmoten.rtree.fbs.generated;", "import java.nio.*;", "import java.lang.*;", "import java.util.*;", "import com.google.flatbuffers.*;"], "methods": [], "classes": [{"original_string": "@SuppressWarnings(\"unused\")\npublic final class Tree_ extends Table {\n  public static void ValidateVersion() { Constants.FLATBUFFERS_2_0_8(); }\n  public static Tree_ getRootAsTree_(ByteBuffer _bb) { return getRootAsTree_(_bb, new Tree_()); }\n  public static Tree_ getRootAsTree_(ByteBuffer _bb, Tree_ obj) { _bb.order(ByteOrder.LITTLE_ENDIAN); return (obj.__assign(_bb.getInt(_bb.position()) + _bb.position(), _bb)); }\n  public void __init(int _i, ByteBuffer _bb) { __reset(_i, _bb); }\n  public Tree_ __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }\n\n  public com.github.davidmoten.rtree.fbs.generated.Context_ context() { return context(new com.github.davidmoten.rtree.fbs.generated.Context_()); }\n  public com.github.davidmoten.rtree.fbs.generated.Context_ context(com.github.davidmoten.rtree.fbs.generated.Context_ obj) { int o = __offset(4); return o != 0 ? obj.__assign(__indirect(o + bb_pos), bb) : null; }\n  public com.github.davidmoten.rtree.fbs.generated.Node_ root() { return root(new com.github.davidmoten.rtree.fbs.generated.Node_()); }\n  public com.github.davidmoten.rtree.fbs.generated.Node_ root(com.github.davidmoten.rtree.fbs.generated.Node_ obj) { int o = __offset(6); return o != 0 ? obj.__assign(__indirect(o + bb_pos), bb) : null; }\n  public long size() { int o = __offset(8); return o != 0 ? (long)bb.getInt(o + bb_pos) & 0xFFFFFFFFL : 0L; }\n\n  public static int createTree_(FlatBufferBuilder builder,\n      int contextOffset,\n      int rootOffset,\n      long size) {\n    builder.startTable(3);\n    Tree_.addSize(builder, size);\n    Tree_.addRoot(builder, rootOffset);\n    Tree_.addContext(builder, contextOffset);\n    return Tree_.endTree_(builder);\n  }\n\n  public static void startTree_(FlatBufferBuilder builder) { builder.startTable(3); }\n  public static void addContext(FlatBufferBuilder builder, int contextOffset) { builder.addOffset(0, contextOffset, 0); }\n  public static void addRoot(FlatBufferBuilder builder, int rootOffset) { builder.addOffset(1, rootOffset, 0); }\n  public static void addSize(FlatBufferBuilder builder, long size) { builder.addInt(2, (int)size, (int)0L); }\n  public static int endTree_(FlatBufferBuilder builder) {\n    int o = builder.endTable();\n    return o;\n  }\n  public static void finishTree_Buffer(FlatBufferBuilder builder, int offset) { builder.finish(offset); }\n  public static void finishSizePrefixedTree_Buffer(FlatBufferBuilder builder, int offset) { builder.finishSizePrefixed(offset); }\n\n  public static final class Vector extends BaseVector {\n    public Vector __assign(int _vector, int _element_size, ByteBuffer _bb) { __reset(_vector, _element_size, _bb); return this; }\n\n    public Tree_ get(int j) { return get(new Tree_(), j); }\n    public Tree_ get(Tree_ obj, int j) {  return obj.__assign(__indirect(__element(j), bb), bb); }\n  }\n}", "definition": "@SuppressWarnings(\"unused\")\npublic final class Tree_ extends Table", "class_docstring": "", "name": "Tree_", "super_interfaces": [], "superclasses": "Table", "attributes": {"modifiers": "@SuppressWarnings(\"unused\")\npublic final", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings(\"unused\")", "public", "final"], "comments": [], "fields": [], "classes": [{"original_string": "  public static final class Vector extends BaseVector {\n    public Vector __assign(int _vector, int _element_size, ByteBuffer _bb) { __reset(_vector, _element_size, _bb); return this; }\n\n    public Tree_ get(int j) { return get(new Tree_(), j); }\n    public Tree_ get(Tree_ obj, int j) {  return obj.__assign(__indirect(__element(j), bb), bb); }\n  }", "definition": "  public static final class Vector extends BaseVector", "class_docstring": "", "name": "Vector", "super_interfaces": [], "superclasses": "BaseVector", "attributes": {"modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    public Vector __assign(int _vector, int _element_size, ByteBuffer _bb) { __reset(_vector, _element_size, _bb); return this; }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Vector", "classes": []}, "name": "__assign", "params": [{"name": "_vector", "type": "int"}, {"name": "_element_size", "type": "int"}, {"name": "_bb", "type": "ByteBuffer"}], "body": "                                                                           { __reset(_vector, _element_size, _bb); return this; }", "signature": "public Vector __assign(int _vector, int _element_size, ByteBuffer _bb)"}, {"syntax_pass": true, "original_string": "    public Tree_ get(int j) { return get(new Tree_(), j); }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Tree_", "classes": []}, "name": "get", "params": [{"name": "j", "type": "int"}], "body": "                            { return get(new Tree_(), j); }", "signature": "public Tree_ get(int j)"}, {"syntax_pass": true, "original_string": "    public Tree_ get(Tree_ obj, int j) {  return obj.__assign(__indirect(__element(j), bb), bb); }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Tree_", "classes": []}, "name": "get", "params": [{"name": "obj", "type": "Tree_"}, {"name": "j", "type": "int"}], "body": "                                       {  return obj.__assign(__indirect(__element(j), bb), bb); }", "signature": "public Tree_ get(Tree_ obj, int j)"}]}]}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "  public static void ValidateVersion() { Constants.FLATBUFFERS_2_0_8(); }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "void", "classes": []}, "name": "ValidateVersion", "params": [], "body": "                                       { Constants.FLATBUFFERS_2_0_8(); }", "signature": "public static void ValidateVersion()"}, {"syntax_pass": true, "original_string": "  public static Tree_ getRootAsTree_(ByteBuffer _bb) { return getRootAsTree_(_bb, new Tree_()); }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Tree_", "classes": []}, "name": "getRootAsTree_", "params": [{"name": "_bb", "type": "ByteBuffer"}], "body": "                                                     { return getRootAsTree_(_bb, new Tree_()); }", "signature": "public static Tree_ getRootAsTree_(ByteBuffer _bb)"}, {"syntax_pass": true, "original_string": "  public static Tree_ getRootAsTree_(ByteBuffer _bb, Tree_ obj) { _bb.order(ByteOrder.LITTLE_ENDIAN); return (obj.__assign(_bb.getInt(_bb.position()) + _bb.position(), _bb)); }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Tree_", "classes": []}, "name": "getRootAsTree_", "params": [{"name": "_bb", "type": "ByteBuffer"}, {"name": "obj", "type": "Tree_"}], "body": "                                                                { _bb.order(ByteOrder.LITTLE_ENDIAN); return (obj.__assign(_bb.getInt(_bb.position()) + _bb.position(), _bb)); }", "signature": "public static Tree_ getRootAsTree_(ByteBuffer _bb, Tree_ obj)"}, {"syntax_pass": true, "original_string": "  public void __init(int _i, ByteBuffer _bb) { __reset(_i, _bb); }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "__init", "params": [{"name": "_i", "type": "int"}, {"name": "_bb", "type": "ByteBuffer"}], "body": "                                             { __reset(_i, _bb); }", "signature": "public void __init(int _i, ByteBuffer _bb)"}, {"syntax_pass": true, "original_string": "  public Tree_ __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Tree_", "classes": []}, "name": "__assign", "params": [{"name": "_i", "type": "int"}, {"name": "_bb", "type": "ByteBuffer"}], "body": "                                                { __init(_i, _bb); return this; }", "signature": "public Tree_ __assign(int _i, ByteBuffer _bb)"}, {"syntax_pass": true, "original_string": "  public com.github.davidmoten.rtree.fbs.generated.Context_ context() { return context(new com.github.davidmoten.rtree.fbs.generated.Context_()); }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "com.github.davidmoten.rtree.fbs.generated.Context_", "classes": []}, "name": "context", "params": [], "body": "                                                                      { return context(new com.github.davidmoten.rtree.fbs.generated.Context_()); }", "signature": "public com.github.davidmoten.rtree.fbs.generated.Context_ context()"}, {"syntax_pass": true, "original_string": "  public com.github.davidmoten.rtree.fbs.generated.Context_ context(com.github.davidmoten.rtree.fbs.generated.Context_ obj) { int o = __offset(4); return o != 0 ? obj.__assign(__indirect(o + bb_pos), bb) : null; }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "com.github.davidmoten.rtree.fbs.generated.Context_", "classes": []}, "name": "context", "params": [{"name": "obj", "type": "com.github.davidmoten.rtree.fbs.generated.Context_"}], "body": "                                                                                                                            { int o = __offset(4); return o != 0 ? obj.__assign(__indirect(o + bb_pos), bb) : null; }", "signature": "public com.github.davidmoten.rtree.fbs.generated.Context_ context(com.github.davidmoten.rtree.fbs.generated.Context_ obj)"}, {"syntax_pass": true, "original_string": "  public com.github.davidmoten.rtree.fbs.generated.Node_ root() { return root(new com.github.davidmoten.rtree.fbs.generated.Node_()); }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "com.github.davidmoten.rtree.fbs.generated.Node_", "classes": []}, "name": "root", "params": [], "body": "                                                                { return root(new com.github.davidmoten.rtree.fbs.generated.Node_()); }", "signature": "public com.github.davidmoten.rtree.fbs.generated.Node_ root()"}, {"syntax_pass": true, "original_string": "  public com.github.davidmoten.rtree.fbs.generated.Node_ root(com.github.davidmoten.rtree.fbs.generated.Node_ obj) { int o = __offset(6); return o != 0 ? obj.__assign(__indirect(o + bb_pos), bb) : null; }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "com.github.davidmoten.rtree.fbs.generated.Node_", "classes": []}, "name": "root", "params": [{"name": "obj", "type": "com.github.davidmoten.rtree.fbs.generated.Node_"}], "body": "                                                                                                                   { int o = __offset(6); return o != 0 ? obj.__assign(__indirect(o + bb_pos), bb) : null; }", "signature": "public com.github.davidmoten.rtree.fbs.generated.Node_ root(com.github.davidmoten.rtree.fbs.generated.Node_ obj)"}, {"syntax_pass": true, "original_string": "  public long size() { int o = __offset(8); return o != 0 ? (long)bb.getInt(o + bb_pos) & 0xFFFFFFFFL : 0L; }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "long", "classes": []}, "name": "size", "params": [], "body": "                     { int o = __offset(8); return o != 0 ? (long)bb.getInt(o + bb_pos) & 0xFFFFFFFFL : 0L; }", "signature": "public long size()"}, {"syntax_pass": true, "original_string": "  public static int createTree_(FlatBufferBuilder builder,\n      int contextOffset,\n      int rootOffset,\n      long size) {\n    builder.startTable(3);\n    Tree_.addSize(builder, size);\n    Tree_.addRoot(builder, rootOffset);\n    Tree_.addContext(builder, contextOffset);\n    return Tree_.endTree_(builder);\n  }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "int", "classes": []}, "name": "createTree_", "params": [{"name": "builder", "type": "FlatBufferBuilder"}, {"name": "contextOffset", "type": "int"}, {"name": "rootOffset", "type": "int"}, {"name": "size", "type": "long"}], "body": "                 {\n    builder.startTable(3);\n    Tree_.addSize(builder, size);\n    Tree_.addRoot(builder, rootOffset);\n    Tree_.addContext(builder, contextOffset);\n    return Tree_.endTree_(builder);\n  }", "signature": "public static int createTree_(FlatBufferBuilder builder,\n      int contextOffset,\n      int rootOffset,\n      long size)"}, {"syntax_pass": true, "original_string": "  public static void startTree_(FlatBufferBuilder builder) { builder.startTable(3); }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "void", "classes": []}, "name": "startTree_", "params": [{"name": "builder", "type": "FlatBufferBuilder"}], "body": "                                                           { builder.startTable(3); }", "signature": "public static void startTree_(FlatBufferBuilder builder)"}, {"syntax_pass": true, "original_string": "  public static void addContext(FlatBufferBuilder builder, int contextOffset) { builder.addOffset(0, contextOffset, 0); }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "void", "classes": []}, "name": "addContext", "params": [{"name": "builder", "type": "FlatBufferBuilder"}, {"name": "contextOffset", "type": "int"}], "body": "                                                                              { builder.addOffset(0, contextOffset, 0); }", "signature": "public static void addContext(FlatBufferBuilder builder, int contextOffset)"}, {"syntax_pass": true, "original_string": "  public static void addRoot(FlatBufferBuilder builder, int rootOffset) { builder.addOffset(1, rootOffset, 0); }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "void", "classes": []}, "name": "addRoot", "params": [{"name": "builder", "type": "FlatBufferBuilder"}, {"name": "rootOffset", "type": "int"}], "body": "                                                                        { builder.addOffset(1, rootOffset, 0); }", "signature": "public static void addRoot(FlatBufferBuilder builder, int rootOffset)"}, {"syntax_pass": true, "original_string": "  public static void addSize(FlatBufferBuilder builder, long size) { builder.addInt(2, (int)size, (int)0L); }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "void", "classes": []}, "name": "addSize", "params": [{"name": "builder", "type": "FlatBufferBuilder"}, {"name": "size", "type": "long"}], "body": "                                                                   { builder.addInt(2, (int)size, (int)0L); }", "signature": "public static void addSize(FlatBufferBuilder builder, long size)"}, {"syntax_pass": true, "original_string": "  public static int endTree_(FlatBufferBuilder builder) {\n    int o = builder.endTable();\n    return o;\n  }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "int", "classes": []}, "name": "endTree_", "params": [{"name": "builder", "type": "FlatBufferBuilder"}], "body": "                                                        {\n    int o = builder.endTable();\n    return o;\n  }", "signature": "public static int endTree_(FlatBufferBuilder builder)"}, {"syntax_pass": true, "original_string": "  public static void finishTree_Buffer(FlatBufferBuilder builder, int offset) { builder.finish(offset); }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "void", "classes": []}, "name": "finishTree_Buffer", "params": [{"name": "builder", "type": "FlatBufferBuilder"}, {"name": "offset", "type": "int"}], "body": "                                                                              { builder.finish(offset); }", "signature": "public static void finishTree_Buffer(FlatBufferBuilder builder, int offset)"}, {"syntax_pass": true, "original_string": "  public static void finishSizePrefixedTree_Buffer(FlatBufferBuilder builder, int offset) { builder.finishSizePrefixed(offset); }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "void", "classes": []}, "name": "finishSizePrefixedTree_Buffer", "params": [{"name": "builder", "type": "FlatBufferBuilder"}, {"name": "offset", "type": "int"}], "body": "                                                                                          { builder.finishSizePrefixed(offset); }", "signature": "public static void finishSizePrefixedTree_Buffer(FlatBufferBuilder builder, int offset)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/com/github/davidmoten/rtree/fbs/generated/Geometry_.java", "original_string": "// automatically generated by the FlatBuffers compiler, do not modify\n\npackage com.github.davidmoten.rtree.fbs.generated;\n\nimport java.nio.*;\nimport java.lang.*;\nimport java.util.*;\nimport com.google.flatbuffers.*;\n\n@SuppressWarnings(\"unused\")\npublic final class Geometry_ extends Table {\n  public static void ValidateVersion() { Constants.FLATBUFFERS_2_0_8(); }\n  public static Geometry_ getRootAsGeometry_(ByteBuffer _bb) { return getRootAsGeometry_(_bb, new Geometry_()); }\n  public static Geometry_ getRootAsGeometry_(ByteBuffer _bb, Geometry_ obj) { _bb.order(ByteOrder.LITTLE_ENDIAN); return (obj.__assign(_bb.getInt(_bb.position()) + _bb.position(), _bb)); }\n  public void __init(int _i, ByteBuffer _bb) { __reset(_i, _bb); }\n  public Geometry_ __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }\n\n  public byte type() { int o = __offset(4); return o != 0 ? bb.get(o + bb_pos) : 0; }\n  public com.github.davidmoten.rtree.fbs.generated.BoxFloat_ boxFloat() { return boxFloat(new com.github.davidmoten.rtree.fbs.generated.BoxFloat_()); }\n  public com.github.davidmoten.rtree.fbs.generated.BoxFloat_ boxFloat(com.github.davidmoten.rtree.fbs.generated.BoxFloat_ obj) { int o = __offset(6); return o != 0 ? obj.__assign(o + bb_pos, bb) : null; }\n  public com.github.davidmoten.rtree.fbs.generated.PointFloat_ pointFloat() { return pointFloat(new com.github.davidmoten.rtree.fbs.generated.PointFloat_()); }\n  public com.github.davidmoten.rtree.fbs.generated.PointFloat_ pointFloat(com.github.davidmoten.rtree.fbs.generated.PointFloat_ obj) { int o = __offset(8); return o != 0 ? obj.__assign(o + bb_pos, bb) : null; }\n  public com.github.davidmoten.rtree.fbs.generated.CircleFloat_ circleFloat() { return circleFloat(new com.github.davidmoten.rtree.fbs.generated.CircleFloat_()); }\n  public com.github.davidmoten.rtree.fbs.generated.CircleFloat_ circleFloat(com.github.davidmoten.rtree.fbs.generated.CircleFloat_ obj) { int o = __offset(10); return o != 0 ? obj.__assign(o + bb_pos, bb) : null; }\n  public com.github.davidmoten.rtree.fbs.generated.BoxFloat_ lineFloat() { return lineFloat(new com.github.davidmoten.rtree.fbs.generated.BoxFloat_()); }\n  public com.github.davidmoten.rtree.fbs.generated.BoxFloat_ lineFloat(com.github.davidmoten.rtree.fbs.generated.BoxFloat_ obj) { int o = __offset(12); return o != 0 ? obj.__assign(o + bb_pos, bb) : null; }\n  public com.github.davidmoten.rtree.fbs.generated.BoxDouble_ boxDouble() { return boxDouble(new com.github.davidmoten.rtree.fbs.generated.BoxDouble_()); }\n  public com.github.davidmoten.rtree.fbs.generated.BoxDouble_ boxDouble(com.github.davidmoten.rtree.fbs.generated.BoxDouble_ obj) { int o = __offset(14); return o != 0 ? obj.__assign(o + bb_pos, bb) : null; }\n  public com.github.davidmoten.rtree.fbs.generated.PointDouble_ pointDouble() { return pointDouble(new com.github.davidmoten.rtree.fbs.generated.PointDouble_()); }\n  public com.github.davidmoten.rtree.fbs.generated.PointDouble_ pointDouble(com.github.davidmoten.rtree.fbs.generated.PointDouble_ obj) { int o = __offset(16); return o != 0 ? obj.__assign(o + bb_pos, bb) : null; }\n  public com.github.davidmoten.rtree.fbs.generated.CircleDouble_ circleDouble() { return circleDouble(new com.github.davidmoten.rtree.fbs.generated.CircleDouble_()); }\n  public com.github.davidmoten.rtree.fbs.generated.CircleDouble_ circleDouble(com.github.davidmoten.rtree.fbs.generated.CircleDouble_ obj) { int o = __offset(18); return o != 0 ? obj.__assign(o + bb_pos, bb) : null; }\n  public com.github.davidmoten.rtree.fbs.generated.BoxDouble_ lineDouble() { return lineDouble(new com.github.davidmoten.rtree.fbs.generated.BoxDouble_()); }\n  public com.github.davidmoten.rtree.fbs.generated.BoxDouble_ lineDouble(com.github.davidmoten.rtree.fbs.generated.BoxDouble_ obj) { int o = __offset(20); return o != 0 ? obj.__assign(o + bb_pos, bb) : null; }\n\n  public static void startGeometry_(FlatBufferBuilder builder) { builder.startTable(9); }\n  public static void addType(FlatBufferBuilder builder, byte type) { builder.addByte(0, type, 0); }\n  public static void addBoxFloat(FlatBufferBuilder builder, int boxFloatOffset) { builder.addStruct(1, boxFloatOffset, 0); }\n  public static void addPointFloat(FlatBufferBuilder builder, int pointFloatOffset) { builder.addStruct(2, pointFloatOffset, 0); }\n  public static void addCircleFloat(FlatBufferBuilder builder, int circleFloatOffset) { builder.addStruct(3, circleFloatOffset, 0); }\n  public static void addLineFloat(FlatBufferBuilder builder, int lineFloatOffset) { builder.addStruct(4, lineFloatOffset, 0); }\n  public static void addBoxDouble(FlatBufferBuilder builder, int boxDoubleOffset) { builder.addStruct(5, boxDoubleOffset, 0); }\n  public static void addPointDouble(FlatBufferBuilder builder, int pointDoubleOffset) { builder.addStruct(6, pointDoubleOffset, 0); }\n  public static void addCircleDouble(FlatBufferBuilder builder, int circleDoubleOffset) { builder.addStruct(7, circleDoubleOffset, 0); }\n  public static void addLineDouble(FlatBufferBuilder builder, int lineDoubleOffset) { builder.addStruct(8, lineDoubleOffset, 0); }\n  public static int endGeometry_(FlatBufferBuilder builder) {\n    int o = builder.endTable();\n    return o;\n  }\n\n  public static final class Vector extends BaseVector {\n    public Vector __assign(int _vector, int _element_size, ByteBuffer _bb) { __reset(_vector, _element_size, _bb); return this; }\n\n    public Geometry_ get(int j) { return get(new Geometry_(), j); }\n    public Geometry_ get(Geometry_ obj, int j) {  return obj.__assign(__indirect(__element(j), bb), bb); }\n  }\n}\n\n", "file_hash": "a1bc2f145af9809127ba969145708c458e1ace7d1e9fb42db9a7a1a0b4bd3653", "file_docstring": " automatically generated by the FlatBuffers compiler, do not modify", "contexts": ["package com.github.davidmoten.rtree.fbs.generated;", "import java.nio.*;", "import java.lang.*;", "import java.util.*;", "import com.google.flatbuffers.*;"], "methods": [], "classes": [{"original_string": "@SuppressWarnings(\"unused\")\npublic final class Geometry_ extends Table {\n  public static void ValidateVersion() { Constants.FLATBUFFERS_2_0_8(); }\n  public static Geometry_ getRootAsGeometry_(ByteBuffer _bb) { return getRootAsGeometry_(_bb, new Geometry_()); }\n  public static Geometry_ getRootAsGeometry_(ByteBuffer _bb, Geometry_ obj) { _bb.order(ByteOrder.LITTLE_ENDIAN); return (obj.__assign(_bb.getInt(_bb.position()) + _bb.position(), _bb)); }\n  public void __init(int _i, ByteBuffer _bb) { __reset(_i, _bb); }\n  public Geometry_ __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }\n\n  public byte type() { int o = __offset(4); return o != 0 ? bb.get(o + bb_pos) : 0; }\n  public com.github.davidmoten.rtree.fbs.generated.BoxFloat_ boxFloat() { return boxFloat(new com.github.davidmoten.rtree.fbs.generated.BoxFloat_()); }\n  public com.github.davidmoten.rtree.fbs.generated.BoxFloat_ boxFloat(com.github.davidmoten.rtree.fbs.generated.BoxFloat_ obj) { int o = __offset(6); return o != 0 ? obj.__assign(o + bb_pos, bb) : null; }\n  public com.github.davidmoten.rtree.fbs.generated.PointFloat_ pointFloat() { return pointFloat(new com.github.davidmoten.rtree.fbs.generated.PointFloat_()); }\n  public com.github.davidmoten.rtree.fbs.generated.PointFloat_ pointFloat(com.github.davidmoten.rtree.fbs.generated.PointFloat_ obj) { int o = __offset(8); return o != 0 ? obj.__assign(o + bb_pos, bb) : null; }\n  public com.github.davidmoten.rtree.fbs.generated.CircleFloat_ circleFloat() { return circleFloat(new com.github.davidmoten.rtree.fbs.generated.CircleFloat_()); }\n  public com.github.davidmoten.rtree.fbs.generated.CircleFloat_ circleFloat(com.github.davidmoten.rtree.fbs.generated.CircleFloat_ obj) { int o = __offset(10); return o != 0 ? obj.__assign(o + bb_pos, bb) : null; }\n  public com.github.davidmoten.rtree.fbs.generated.BoxFloat_ lineFloat() { return lineFloat(new com.github.davidmoten.rtree.fbs.generated.BoxFloat_()); }\n  public com.github.davidmoten.rtree.fbs.generated.BoxFloat_ lineFloat(com.github.davidmoten.rtree.fbs.generated.BoxFloat_ obj) { int o = __offset(12); return o != 0 ? obj.__assign(o + bb_pos, bb) : null; }\n  public com.github.davidmoten.rtree.fbs.generated.BoxDouble_ boxDouble() { return boxDouble(new com.github.davidmoten.rtree.fbs.generated.BoxDouble_()); }\n  public com.github.davidmoten.rtree.fbs.generated.BoxDouble_ boxDouble(com.github.davidmoten.rtree.fbs.generated.BoxDouble_ obj) { int o = __offset(14); return o != 0 ? obj.__assign(o + bb_pos, bb) : null; }\n  public com.github.davidmoten.rtree.fbs.generated.PointDouble_ pointDouble() { return pointDouble(new com.github.davidmoten.rtree.fbs.generated.PointDouble_()); }\n  public com.github.davidmoten.rtree.fbs.generated.PointDouble_ pointDouble(com.github.davidmoten.rtree.fbs.generated.PointDouble_ obj) { int o = __offset(16); return o != 0 ? obj.__assign(o + bb_pos, bb) : null; }\n  public com.github.davidmoten.rtree.fbs.generated.CircleDouble_ circleDouble() { return circleDouble(new com.github.davidmoten.rtree.fbs.generated.CircleDouble_()); }\n  public com.github.davidmoten.rtree.fbs.generated.CircleDouble_ circleDouble(com.github.davidmoten.rtree.fbs.generated.CircleDouble_ obj) { int o = __offset(18); return o != 0 ? obj.__assign(o + bb_pos, bb) : null; }\n  public com.github.davidmoten.rtree.fbs.generated.BoxDouble_ lineDouble() { return lineDouble(new com.github.davidmoten.rtree.fbs.generated.BoxDouble_()); }\n  public com.github.davidmoten.rtree.fbs.generated.BoxDouble_ lineDouble(com.github.davidmoten.rtree.fbs.generated.BoxDouble_ obj) { int o = __offset(20); return o != 0 ? obj.__assign(o + bb_pos, bb) : null; }\n\n  public static void startGeometry_(FlatBufferBuilder builder) { builder.startTable(9); }\n  public static void addType(FlatBufferBuilder builder, byte type) { builder.addByte(0, type, 0); }\n  public static void addBoxFloat(FlatBufferBuilder builder, int boxFloatOffset) { builder.addStruct(1, boxFloatOffset, 0); }\n  public static void addPointFloat(FlatBufferBuilder builder, int pointFloatOffset) { builder.addStruct(2, pointFloatOffset, 0); }\n  public static void addCircleFloat(FlatBufferBuilder builder, int circleFloatOffset) { builder.addStruct(3, circleFloatOffset, 0); }\n  public static void addLineFloat(FlatBufferBuilder builder, int lineFloatOffset) { builder.addStruct(4, lineFloatOffset, 0); }\n  public static void addBoxDouble(FlatBufferBuilder builder, int boxDoubleOffset) { builder.addStruct(5, boxDoubleOffset, 0); }\n  public static void addPointDouble(FlatBufferBuilder builder, int pointDoubleOffset) { builder.addStruct(6, pointDoubleOffset, 0); }\n  public static void addCircleDouble(FlatBufferBuilder builder, int circleDoubleOffset) { builder.addStruct(7, circleDoubleOffset, 0); }\n  public static void addLineDouble(FlatBufferBuilder builder, int lineDoubleOffset) { builder.addStruct(8, lineDoubleOffset, 0); }\n  public static int endGeometry_(FlatBufferBuilder builder) {\n    int o = builder.endTable();\n    return o;\n  }\n\n  public static final class Vector extends BaseVector {\n    public Vector __assign(int _vector, int _element_size, ByteBuffer _bb) { __reset(_vector, _element_size, _bb); return this; }\n\n    public Geometry_ get(int j) { return get(new Geometry_(), j); }\n    public Geometry_ get(Geometry_ obj, int j) {  return obj.__assign(__indirect(__element(j), bb), bb); }\n  }\n}", "definition": "@SuppressWarnings(\"unused\")\npublic final class Geometry_ extends Table", "class_docstring": "", "name": "Geometry_", "super_interfaces": [], "superclasses": "Table", "attributes": {"modifiers": "@SuppressWarnings(\"unused\")\npublic final", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings(\"unused\")", "public", "final"], "comments": [], "fields": [], "classes": [{"original_string": "  public static final class Vector extends BaseVector {\n    public Vector __assign(int _vector, int _element_size, ByteBuffer _bb) { __reset(_vector, _element_size, _bb); return this; }\n\n    public Geometry_ get(int j) { return get(new Geometry_(), j); }\n    public Geometry_ get(Geometry_ obj, int j) {  return obj.__assign(__indirect(__element(j), bb), bb); }\n  }", "definition": "  public static final class Vector extends BaseVector", "class_docstring": "", "name": "Vector", "super_interfaces": [], "superclasses": "BaseVector", "attributes": {"modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    public Vector __assign(int _vector, int _element_size, ByteBuffer _bb) { __reset(_vector, _element_size, _bb); return this; }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Vector", "classes": []}, "name": "__assign", "params": [{"name": "_vector", "type": "int"}, {"name": "_element_size", "type": "int"}, {"name": "_bb", "type": "ByteBuffer"}], "body": "                                                                           { __reset(_vector, _element_size, _bb); return this; }", "signature": "public Vector __assign(int _vector, int _element_size, ByteBuffer _bb)"}, {"syntax_pass": true, "original_string": "    public Geometry_ get(int j) { return get(new Geometry_(), j); }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Geometry_", "classes": []}, "name": "get", "params": [{"name": "j", "type": "int"}], "body": "                                { return get(new Geometry_(), j); }", "signature": "public Geometry_ get(int j)"}, {"syntax_pass": true, "original_string": "    public Geometry_ get(Geometry_ obj, int j) {  return obj.__assign(__indirect(__element(j), bb), bb); }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Geometry_", "classes": []}, "name": "get", "params": [{"name": "obj", "type": "Geometry_"}, {"name": "j", "type": "int"}], "body": "                                               {  return obj.__assign(__indirect(__element(j), bb), bb); }", "signature": "public Geometry_ get(Geometry_ obj, int j)"}]}]}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "  public static void ValidateVersion() { Constants.FLATBUFFERS_2_0_8(); }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "void", "classes": []}, "name": "ValidateVersion", "params": [], "body": "                                       { Constants.FLATBUFFERS_2_0_8(); }", "signature": "public static void ValidateVersion()"}, {"syntax_pass": true, "original_string": "  public static Geometry_ getRootAsGeometry_(ByteBuffer _bb) { return getRootAsGeometry_(_bb, new Geometry_()); }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Geometry_", "classes": []}, "name": "getRootAsGeometry_", "params": [{"name": "_bb", "type": "ByteBuffer"}], "body": "                                                             { return getRootAsGeometry_(_bb, new Geometry_()); }", "signature": "public static Geometry_ getRootAsGeometry_(ByteBuffer _bb)"}, {"syntax_pass": true, "original_string": "  public static Geometry_ getRootAsGeometry_(ByteBuffer _bb, Geometry_ obj) { _bb.order(ByteOrder.LITTLE_ENDIAN); return (obj.__assign(_bb.getInt(_bb.position()) + _bb.position(), _bb)); }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Geometry_", "classes": []}, "name": "getRootAsGeometry_", "params": [{"name": "_bb", "type": "ByteBuffer"}, {"name": "obj", "type": "Geometry_"}], "body": "                                                                            { _bb.order(ByteOrder.LITTLE_ENDIAN); return (obj.__assign(_bb.getInt(_bb.position()) + _bb.position(), _bb)); }", "signature": "public static Geometry_ getRootAsGeometry_(ByteBuffer _bb, Geometry_ obj)"}, {"syntax_pass": true, "original_string": "  public void __init(int _i, ByteBuffer _bb) { __reset(_i, _bb); }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "__init", "params": [{"name": "_i", "type": "int"}, {"name": "_bb", "type": "ByteBuffer"}], "body": "                                             { __reset(_i, _bb); }", "signature": "public void __init(int _i, ByteBuffer _bb)"}, {"syntax_pass": true, "original_string": "  public Geometry_ __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Geometry_", "classes": []}, "name": "__assign", "params": [{"name": "_i", "type": "int"}, {"name": "_bb", "type": "ByteBuffer"}], "body": "                                                    { __init(_i, _bb); return this; }", "signature": "public Geometry_ __assign(int _i, ByteBuffer _bb)"}, {"syntax_pass": true, "original_string": "  public byte type() { int o = __offset(4); return o != 0 ? bb.get(o + bb_pos) : 0; }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "byte", "classes": []}, "name": "type", "params": [], "body": "                     { int o = __offset(4); return o != 0 ? bb.get(o + bb_pos) : 0; }", "signature": "public byte type()"}, {"syntax_pass": true, "original_string": "  public com.github.davidmoten.rtree.fbs.generated.BoxFloat_ boxFloat() { return boxFloat(new com.github.davidmoten.rtree.fbs.generated.BoxFloat_()); }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "com.github.davidmoten.rtree.fbs.generated.BoxFloat_", "classes": []}, "name": "boxFloat", "params": [], "body": "                                                                        { return boxFloat(new com.github.davidmoten.rtree.fbs.generated.BoxFloat_()); }", "signature": "public com.github.davidmoten.rtree.fbs.generated.BoxFloat_ boxFloat()"}, {"syntax_pass": true, "original_string": "  public com.github.davidmoten.rtree.fbs.generated.BoxFloat_ boxFloat(com.github.davidmoten.rtree.fbs.generated.BoxFloat_ obj) { int o = __offset(6); return o != 0 ? obj.__assign(o + bb_pos, bb) : null; }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "com.github.davidmoten.rtree.fbs.generated.BoxFloat_", "classes": []}, "name": "boxFloat", "params": [{"name": "obj", "type": "com.github.davidmoten.rtree.fbs.generated.BoxFloat_"}], "body": "                                                                                                                               { int o = __offset(6); return o != 0 ? obj.__assign(o + bb_pos, bb) : null; }", "signature": "public com.github.davidmoten.rtree.fbs.generated.BoxFloat_ boxFloat(com.github.davidmoten.rtree.fbs.generated.BoxFloat_ obj)"}, {"syntax_pass": true, "original_string": "  public com.github.davidmoten.rtree.fbs.generated.PointFloat_ pointFloat() { return pointFloat(new com.github.davidmoten.rtree.fbs.generated.PointFloat_()); }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "com.github.davidmoten.rtree.fbs.generated.PointFloat_", "classes": []}, "name": "pointFloat", "params": [], "body": "                                                                            { return pointFloat(new com.github.davidmoten.rtree.fbs.generated.PointFloat_()); }", "signature": "public com.github.davidmoten.rtree.fbs.generated.PointFloat_ pointFloat()"}, {"syntax_pass": true, "original_string": "  public com.github.davidmoten.rtree.fbs.generated.PointFloat_ pointFloat(com.github.davidmoten.rtree.fbs.generated.PointFloat_ obj) { int o = __offset(8); return o != 0 ? obj.__assign(o + bb_pos, bb) : null; }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "com.github.davidmoten.rtree.fbs.generated.PointFloat_", "classes": []}, "name": "pointFloat", "params": [{"name": "obj", "type": "com.github.davidmoten.rtree.fbs.generated.PointFloat_"}], "body": "                                                                                                                                     { int o = __offset(8); return o != 0 ? obj.__assign(o + bb_pos, bb) : null; }", "signature": "public com.github.davidmoten.rtree.fbs.generated.PointFloat_ pointFloat(com.github.davidmoten.rtree.fbs.generated.PointFloat_ obj)"}, {"syntax_pass": true, "original_string": "  public com.github.davidmoten.rtree.fbs.generated.CircleFloat_ circleFloat() { return circleFloat(new com.github.davidmoten.rtree.fbs.generated.CircleFloat_()); }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "com.github.davidmoten.rtree.fbs.generated.CircleFloat_", "classes": []}, "name": "circleFloat", "params": [], "body": "                                                                              { return circleFloat(new com.github.davidmoten.rtree.fbs.generated.CircleFloat_()); }", "signature": "public com.github.davidmoten.rtree.fbs.generated.CircleFloat_ circleFloat()"}, {"syntax_pass": true, "original_string": "  public com.github.davidmoten.rtree.fbs.generated.CircleFloat_ circleFloat(com.github.davidmoten.rtree.fbs.generated.CircleFloat_ obj) { int o = __offset(10); return o != 0 ? obj.__assign(o + bb_pos, bb) : null; }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "com.github.davidmoten.rtree.fbs.generated.CircleFloat_", "classes": []}, "name": "circleFloat", "params": [{"name": "obj", "type": "com.github.davidmoten.rtree.fbs.generated.CircleFloat_"}], "body": "                                                                                                                                        { int o = __offset(10); return o != 0 ? obj.__assign(o + bb_pos, bb) : null; }", "signature": "public com.github.davidmoten.rtree.fbs.generated.CircleFloat_ circleFloat(com.github.davidmoten.rtree.fbs.generated.CircleFloat_ obj)"}, {"syntax_pass": true, "original_string": "  public com.github.davidmoten.rtree.fbs.generated.BoxFloat_ lineFloat() { return lineFloat(new com.github.davidmoten.rtree.fbs.generated.BoxFloat_()); }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "com.github.davidmoten.rtree.fbs.generated.BoxFloat_", "classes": []}, "name": "lineFloat", "params": [], "body": "                                                                         { return lineFloat(new com.github.davidmoten.rtree.fbs.generated.BoxFloat_()); }", "signature": "public com.github.davidmoten.rtree.fbs.generated.BoxFloat_ lineFloat()"}, {"syntax_pass": true, "original_string": "  public com.github.davidmoten.rtree.fbs.generated.BoxFloat_ lineFloat(com.github.davidmoten.rtree.fbs.generated.BoxFloat_ obj) { int o = __offset(12); return o != 0 ? obj.__assign(o + bb_pos, bb) : null; }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "com.github.davidmoten.rtree.fbs.generated.BoxFloat_", "classes": []}, "name": "lineFloat", "params": [{"name": "obj", "type": "com.github.davidmoten.rtree.fbs.generated.BoxFloat_"}], "body": "                                                                                                                                { int o = __offset(12); return o != 0 ? obj.__assign(o + bb_pos, bb) : null; }", "signature": "public com.github.davidmoten.rtree.fbs.generated.BoxFloat_ lineFloat(com.github.davidmoten.rtree.fbs.generated.BoxFloat_ obj)"}, {"syntax_pass": true, "original_string": "  public com.github.davidmoten.rtree.fbs.generated.BoxDouble_ boxDouble() { return boxDouble(new com.github.davidmoten.rtree.fbs.generated.BoxDouble_()); }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "com.github.davidmoten.rtree.fbs.generated.BoxDouble_", "classes": []}, "name": "boxDouble", "params": [], "body": "                                                                          { return boxDouble(new com.github.davidmoten.rtree.fbs.generated.BoxDouble_()); }", "signature": "public com.github.davidmoten.rtree.fbs.generated.BoxDouble_ boxDouble()"}, {"syntax_pass": true, "original_string": "  public com.github.davidmoten.rtree.fbs.generated.BoxDouble_ boxDouble(com.github.davidmoten.rtree.fbs.generated.BoxDouble_ obj) { int o = __offset(14); return o != 0 ? obj.__assign(o + bb_pos, bb) : null; }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "com.github.davidmoten.rtree.fbs.generated.BoxDouble_", "classes": []}, "name": "boxDouble", "params": [{"name": "obj", "type": "com.github.davidmoten.rtree.fbs.generated.BoxDouble_"}], "body": "                                                                                                                                  { int o = __offset(14); return o != 0 ? obj.__assign(o + bb_pos, bb) : null; }", "signature": "public com.github.davidmoten.rtree.fbs.generated.BoxDouble_ boxDouble(com.github.davidmoten.rtree.fbs.generated.BoxDouble_ obj)"}, {"syntax_pass": true, "original_string": "  public com.github.davidmoten.rtree.fbs.generated.PointDouble_ pointDouble() { return pointDouble(new com.github.davidmoten.rtree.fbs.generated.PointDouble_()); }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "com.github.davidmoten.rtree.fbs.generated.PointDouble_", "classes": []}, "name": "pointDouble", "params": [], "body": "                                                                              { return pointDouble(new com.github.davidmoten.rtree.fbs.generated.PointDouble_()); }", "signature": "public com.github.davidmoten.rtree.fbs.generated.PointDouble_ pointDouble()"}, {"syntax_pass": true, "original_string": "  public com.github.davidmoten.rtree.fbs.generated.PointDouble_ pointDouble(com.github.davidmoten.rtree.fbs.generated.PointDouble_ obj) { int o = __offset(16); return o != 0 ? obj.__assign(o + bb_pos, bb) : null; }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "com.github.davidmoten.rtree.fbs.generated.PointDouble_", "classes": []}, "name": "pointDouble", "params": [{"name": "obj", "type": "com.github.davidmoten.rtree.fbs.generated.PointDouble_"}], "body": "                                                                                                                                        { int o = __offset(16); return o != 0 ? obj.__assign(o + bb_pos, bb) : null; }", "signature": "public com.github.davidmoten.rtree.fbs.generated.PointDouble_ pointDouble(com.github.davidmoten.rtree.fbs.generated.PointDouble_ obj)"}, {"syntax_pass": true, "original_string": "  public com.github.davidmoten.rtree.fbs.generated.CircleDouble_ circleDouble() { return circleDouble(new com.github.davidmoten.rtree.fbs.generated.CircleDouble_()); }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "com.github.davidmoten.rtree.fbs.generated.CircleDouble_", "classes": []}, "name": "circleDouble", "params": [], "body": "                                                                                { return circleDouble(new com.github.davidmoten.rtree.fbs.generated.CircleDouble_()); }", "signature": "public com.github.davidmoten.rtree.fbs.generated.CircleDouble_ circleDouble()"}, {"syntax_pass": true, "original_string": "  public com.github.davidmoten.rtree.fbs.generated.CircleDouble_ circleDouble(com.github.davidmoten.rtree.fbs.generated.CircleDouble_ obj) { int o = __offset(18); return o != 0 ? obj.__assign(o + bb_pos, bb) : null; }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "com.github.davidmoten.rtree.fbs.generated.CircleDouble_", "classes": []}, "name": "circleDouble", "params": [{"name": "obj", "type": "com.github.davidmoten.rtree.fbs.generated.CircleDouble_"}], "body": "                                                                                                                                           { int o = __offset(18); return o != 0 ? obj.__assign(o + bb_pos, bb) : null; }", "signature": "public com.github.davidmoten.rtree.fbs.generated.CircleDouble_ circleDouble(com.github.davidmoten.rtree.fbs.generated.CircleDouble_ obj)"}, {"syntax_pass": true, "original_string": "  public com.github.davidmoten.rtree.fbs.generated.BoxDouble_ lineDouble() { return lineDouble(new com.github.davidmoten.rtree.fbs.generated.BoxDouble_()); }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "com.github.davidmoten.rtree.fbs.generated.BoxDouble_", "classes": []}, "name": "lineDouble", "params": [], "body": "                                                                           { return lineDouble(new com.github.davidmoten.rtree.fbs.generated.BoxDouble_()); }", "signature": "public com.github.davidmoten.rtree.fbs.generated.BoxDouble_ lineDouble()"}, {"syntax_pass": true, "original_string": "  public com.github.davidmoten.rtree.fbs.generated.BoxDouble_ lineDouble(com.github.davidmoten.rtree.fbs.generated.BoxDouble_ obj) { int o = __offset(20); return o != 0 ? obj.__assign(o + bb_pos, bb) : null; }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "com.github.davidmoten.rtree.fbs.generated.BoxDouble_", "classes": []}, "name": "lineDouble", "params": [{"name": "obj", "type": "com.github.davidmoten.rtree.fbs.generated.BoxDouble_"}], "body": "                                                                                                                                   { int o = __offset(20); return o != 0 ? obj.__assign(o + bb_pos, bb) : null; }", "signature": "public com.github.davidmoten.rtree.fbs.generated.BoxDouble_ lineDouble(com.github.davidmoten.rtree.fbs.generated.BoxDouble_ obj)"}, {"syntax_pass": true, "original_string": "  public static void startGeometry_(FlatBufferBuilder builder) { builder.startTable(9); }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "void", "classes": []}, "name": "startGeometry_", "params": [{"name": "builder", "type": "FlatBufferBuilder"}], "body": "                                                               { builder.startTable(9); }", "signature": "public static void startGeometry_(FlatBufferBuilder builder)"}, {"syntax_pass": true, "original_string": "  public static void addType(FlatBufferBuilder builder, byte type) { builder.addByte(0, type, 0); }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "void", "classes": []}, "name": "addType", "params": [{"name": "builder", "type": "FlatBufferBuilder"}, {"name": "type", "type": "byte"}], "body": "                                                                   { builder.addByte(0, type, 0); }", "signature": "public static void addType(FlatBufferBuilder builder, byte type)"}, {"syntax_pass": true, "original_string": "  public static void addBoxFloat(FlatBufferBuilder builder, int boxFloatOffset) { builder.addStruct(1, boxFloatOffset, 0); }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "void", "classes": []}, "name": "addBoxFloat", "params": [{"name": "builder", "type": "FlatBufferBuilder"}, {"name": "boxFloatOffset", "type": "int"}], "body": "                                                                                { builder.addStruct(1, boxFloatOffset, 0); }", "signature": "public static void addBoxFloat(FlatBufferBuilder builder, int boxFloatOffset)"}, {"syntax_pass": true, "original_string": "  public static void addPointFloat(FlatBufferBuilder builder, int pointFloatOffset) { builder.addStruct(2, pointFloatOffset, 0); }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "void", "classes": []}, "name": "addPointFloat", "params": [{"name": "builder", "type": "FlatBufferBuilder"}, {"name": "pointFloatOffset", "type": "int"}], "body": "                                                                                    { builder.addStruct(2, pointFloatOffset, 0); }", "signature": "public static void addPointFloat(FlatBufferBuilder builder, int pointFloatOffset)"}, {"syntax_pass": true, "original_string": "  public static void addCircleFloat(FlatBufferBuilder builder, int circleFloatOffset) { builder.addStruct(3, circleFloatOffset, 0); }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "void", "classes": []}, "name": "addCircleFloat", "params": [{"name": "builder", "type": "FlatBufferBuilder"}, {"name": "circleFloatOffset", "type": "int"}], "body": "                                                                                      { builder.addStruct(3, circleFloatOffset, 0); }", "signature": "public static void addCircleFloat(FlatBufferBuilder builder, int circleFloatOffset)"}, {"syntax_pass": true, "original_string": "  public static void addLineFloat(FlatBufferBuilder builder, int lineFloatOffset) { builder.addStruct(4, lineFloatOffset, 0); }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "void", "classes": []}, "name": "addLineFloat", "params": [{"name": "builder", "type": "FlatBufferBuilder"}, {"name": "lineFloatOffset", "type": "int"}], "body": "                                                                                  { builder.addStruct(4, lineFloatOffset, 0); }", "signature": "public static void addLineFloat(FlatBufferBuilder builder, int lineFloatOffset)"}, {"syntax_pass": true, "original_string": "  public static void addBoxDouble(FlatBufferBuilder builder, int boxDoubleOffset) { builder.addStruct(5, boxDoubleOffset, 0); }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "void", "classes": []}, "name": "addBoxDouble", "params": [{"name": "builder", "type": "FlatBufferBuilder"}, {"name": "boxDoubleOffset", "type": "int"}], "body": "                                                                                  { builder.addStruct(5, boxDoubleOffset, 0); }", "signature": "public static void addBoxDouble(FlatBufferBuilder builder, int boxDoubleOffset)"}, {"syntax_pass": true, "original_string": "  public static void addPointDouble(FlatBufferBuilder builder, int pointDoubleOffset) { builder.addStruct(6, pointDoubleOffset, 0); }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "void", "classes": []}, "name": "addPointDouble", "params": [{"name": "builder", "type": "FlatBufferBuilder"}, {"name": "pointDoubleOffset", "type": "int"}], "body": "                                                                                      { builder.addStruct(6, pointDoubleOffset, 0); }", "signature": "public static void addPointDouble(FlatBufferBuilder builder, int pointDoubleOffset)"}, {"syntax_pass": true, "original_string": "  public static void addCircleDouble(FlatBufferBuilder builder, int circleDoubleOffset) { builder.addStruct(7, circleDoubleOffset, 0); }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "void", "classes": []}, "name": "addCircleDouble", "params": [{"name": "builder", "type": "FlatBufferBuilder"}, {"name": "circleDoubleOffset", "type": "int"}], "body": "                                                                                        { builder.addStruct(7, circleDoubleOffset, 0); }", "signature": "public static void addCircleDouble(FlatBufferBuilder builder, int circleDoubleOffset)"}, {"syntax_pass": true, "original_string": "  public static void addLineDouble(FlatBufferBuilder builder, int lineDoubleOffset) { builder.addStruct(8, lineDoubleOffset, 0); }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "void", "classes": []}, "name": "addLineDouble", "params": [{"name": "builder", "type": "FlatBufferBuilder"}, {"name": "lineDoubleOffset", "type": "int"}], "body": "                                                                                    { builder.addStruct(8, lineDoubleOffset, 0); }", "signature": "public static void addLineDouble(FlatBufferBuilder builder, int lineDoubleOffset)"}, {"syntax_pass": true, "original_string": "  public static int endGeometry_(FlatBufferBuilder builder) {\n    int o = builder.endTable();\n    return o;\n  }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "int", "classes": []}, "name": "endGeometry_", "params": [{"name": "builder", "type": "FlatBufferBuilder"}], "body": "                                                            {\n    int o = builder.endTable();\n    return o;\n  }", "signature": "public static int endGeometry_(FlatBufferBuilder builder)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/com/github/davidmoten/rtree/fbs/generated/Bounds_.java", "original_string": "// automatically generated by the FlatBuffers compiler, do not modify\n\npackage com.github.davidmoten.rtree.fbs.generated;\n\nimport java.nio.*;\nimport java.lang.*;\nimport java.util.*;\nimport com.google.flatbuffers.*;\n\n@SuppressWarnings(\"unused\")\npublic final class Bounds_ extends Table {\n  public static void ValidateVersion() { Constants.FLATBUFFERS_2_0_8(); }\n  public static Bounds_ getRootAsBounds_(ByteBuffer _bb) { return getRootAsBounds_(_bb, new Bounds_()); }\n  public static Bounds_ getRootAsBounds_(ByteBuffer _bb, Bounds_ obj) { _bb.order(ByteOrder.LITTLE_ENDIAN); return (obj.__assign(_bb.getInt(_bb.position()) + _bb.position(), _bb)); }\n  public void __init(int _i, ByteBuffer _bb) { __reset(_i, _bb); }\n  public Bounds_ __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }\n\n  public byte type() { int o = __offset(4); return o != 0 ? bb.get(o + bb_pos) : 0; }\n  public com.github.davidmoten.rtree.fbs.generated.BoxFloat_ boxFloat() { return boxFloat(new com.github.davidmoten.rtree.fbs.generated.BoxFloat_()); }\n  public com.github.davidmoten.rtree.fbs.generated.BoxFloat_ boxFloat(com.github.davidmoten.rtree.fbs.generated.BoxFloat_ obj) { int o = __offset(6); return o != 0 ? obj.__assign(o + bb_pos, bb) : null; }\n  public com.github.davidmoten.rtree.fbs.generated.BoxDouble_ boxDouble() { return boxDouble(new com.github.davidmoten.rtree.fbs.generated.BoxDouble_()); }\n  public com.github.davidmoten.rtree.fbs.generated.BoxDouble_ boxDouble(com.github.davidmoten.rtree.fbs.generated.BoxDouble_ obj) { int o = __offset(8); return o != 0 ? obj.__assign(o + bb_pos, bb) : null; }\n\n  public static void startBounds_(FlatBufferBuilder builder) { builder.startTable(3); }\n  public static void addType(FlatBufferBuilder builder, byte type) { builder.addByte(0, type, 0); }\n  public static void addBoxFloat(FlatBufferBuilder builder, int boxFloatOffset) { builder.addStruct(1, boxFloatOffset, 0); }\n  public static void addBoxDouble(FlatBufferBuilder builder, int boxDoubleOffset) { builder.addStruct(2, boxDoubleOffset, 0); }\n  public static int endBounds_(FlatBufferBuilder builder) {\n    int o = builder.endTable();\n    return o;\n  }\n\n  public static final class Vector extends BaseVector {\n    public Vector __assign(int _vector, int _element_size, ByteBuffer _bb) { __reset(_vector, _element_size, _bb); return this; }\n\n    public Bounds_ get(int j) { return get(new Bounds_(), j); }\n    public Bounds_ get(Bounds_ obj, int j) {  return obj.__assign(__indirect(__element(j), bb), bb); }\n  }\n}\n\n", "file_hash": "5258c2da1d515f4fad0487ba4238632a5fa4354e1bd9da2d39a1a39474ec27f3", "file_docstring": " automatically generated by the FlatBuffers compiler, do not modify", "contexts": ["package com.github.davidmoten.rtree.fbs.generated;", "import java.nio.*;", "import java.lang.*;", "import java.util.*;", "import com.google.flatbuffers.*;"], "methods": [], "classes": [{"original_string": "@SuppressWarnings(\"unused\")\npublic final class Bounds_ extends Table {\n  public static void ValidateVersion() { Constants.FLATBUFFERS_2_0_8(); }\n  public static Bounds_ getRootAsBounds_(ByteBuffer _bb) { return getRootAsBounds_(_bb, new Bounds_()); }\n  public static Bounds_ getRootAsBounds_(ByteBuffer _bb, Bounds_ obj) { _bb.order(ByteOrder.LITTLE_ENDIAN); return (obj.__assign(_bb.getInt(_bb.position()) + _bb.position(), _bb)); }\n  public void __init(int _i, ByteBuffer _bb) { __reset(_i, _bb); }\n  public Bounds_ __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }\n\n  public byte type() { int o = __offset(4); return o != 0 ? bb.get(o + bb_pos) : 0; }\n  public com.github.davidmoten.rtree.fbs.generated.BoxFloat_ boxFloat() { return boxFloat(new com.github.davidmoten.rtree.fbs.generated.BoxFloat_()); }\n  public com.github.davidmoten.rtree.fbs.generated.BoxFloat_ boxFloat(com.github.davidmoten.rtree.fbs.generated.BoxFloat_ obj) { int o = __offset(6); return o != 0 ? obj.__assign(o + bb_pos, bb) : null; }\n  public com.github.davidmoten.rtree.fbs.generated.BoxDouble_ boxDouble() { return boxDouble(new com.github.davidmoten.rtree.fbs.generated.BoxDouble_()); }\n  public com.github.davidmoten.rtree.fbs.generated.BoxDouble_ boxDouble(com.github.davidmoten.rtree.fbs.generated.BoxDouble_ obj) { int o = __offset(8); return o != 0 ? obj.__assign(o + bb_pos, bb) : null; }\n\n  public static void startBounds_(FlatBufferBuilder builder) { builder.startTable(3); }\n  public static void addType(FlatBufferBuilder builder, byte type) { builder.addByte(0, type, 0); }\n  public static void addBoxFloat(FlatBufferBuilder builder, int boxFloatOffset) { builder.addStruct(1, boxFloatOffset, 0); }\n  public static void addBoxDouble(FlatBufferBuilder builder, int boxDoubleOffset) { builder.addStruct(2, boxDoubleOffset, 0); }\n  public static int endBounds_(FlatBufferBuilder builder) {\n    int o = builder.endTable();\n    return o;\n  }\n\n  public static final class Vector extends BaseVector {\n    public Vector __assign(int _vector, int _element_size, ByteBuffer _bb) { __reset(_vector, _element_size, _bb); return this; }\n\n    public Bounds_ get(int j) { return get(new Bounds_(), j); }\n    public Bounds_ get(Bounds_ obj, int j) {  return obj.__assign(__indirect(__element(j), bb), bb); }\n  }\n}", "definition": "@SuppressWarnings(\"unused\")\npublic final class Bounds_ extends Table", "class_docstring": "", "name": "Bounds_", "super_interfaces": [], "superclasses": "Table", "attributes": {"modifiers": "@SuppressWarnings(\"unused\")\npublic final", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings(\"unused\")", "public", "final"], "comments": [], "fields": [], "classes": [{"original_string": "  public static final class Vector extends BaseVector {\n    public Vector __assign(int _vector, int _element_size, ByteBuffer _bb) { __reset(_vector, _element_size, _bb); return this; }\n\n    public Bounds_ get(int j) { return get(new Bounds_(), j); }\n    public Bounds_ get(Bounds_ obj, int j) {  return obj.__assign(__indirect(__element(j), bb), bb); }\n  }", "definition": "  public static final class Vector extends BaseVector", "class_docstring": "", "name": "Vector", "super_interfaces": [], "superclasses": "BaseVector", "attributes": {"modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    public Vector __assign(int _vector, int _element_size, ByteBuffer _bb) { __reset(_vector, _element_size, _bb); return this; }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Vector", "classes": []}, "name": "__assign", "params": [{"name": "_vector", "type": "int"}, {"name": "_element_size", "type": "int"}, {"name": "_bb", "type": "ByteBuffer"}], "body": "                                                                           { __reset(_vector, _element_size, _bb); return this; }", "signature": "public Vector __assign(int _vector, int _element_size, ByteBuffer _bb)"}, {"syntax_pass": true, "original_string": "    public Bounds_ get(int j) { return get(new Bounds_(), j); }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Bounds_", "classes": []}, "name": "get", "params": [{"name": "j", "type": "int"}], "body": "                              { return get(new Bounds_(), j); }", "signature": "public Bounds_ get(int j)"}, {"syntax_pass": true, "original_string": "    public Bounds_ get(Bounds_ obj, int j) {  return obj.__assign(__indirect(__element(j), bb), bb); }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Bounds_", "classes": []}, "name": "get", "params": [{"name": "obj", "type": "Bounds_"}, {"name": "j", "type": "int"}], "body": "                                           {  return obj.__assign(__indirect(__element(j), bb), bb); }", "signature": "public Bounds_ get(Bounds_ obj, int j)"}]}]}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "  public static void ValidateVersion() { Constants.FLATBUFFERS_2_0_8(); }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "void", "classes": []}, "name": "ValidateVersion", "params": [], "body": "                                       { Constants.FLATBUFFERS_2_0_8(); }", "signature": "public static void ValidateVersion()"}, {"syntax_pass": true, "original_string": "  public static Bounds_ getRootAsBounds_(ByteBuffer _bb) { return getRootAsBounds_(_bb, new Bounds_()); }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Bounds_", "classes": []}, "name": "getRootAsBounds_", "params": [{"name": "_bb", "type": "ByteBuffer"}], "body": "                                                         { return getRootAsBounds_(_bb, new Bounds_()); }", "signature": "public static Bounds_ getRootAsBounds_(ByteBuffer _bb)"}, {"syntax_pass": true, "original_string": "  public static Bounds_ getRootAsBounds_(ByteBuffer _bb, Bounds_ obj) { _bb.order(ByteOrder.LITTLE_ENDIAN); return (obj.__assign(_bb.getInt(_bb.position()) + _bb.position(), _bb)); }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Bounds_", "classes": []}, "name": "getRootAsBounds_", "params": [{"name": "_bb", "type": "ByteBuffer"}, {"name": "obj", "type": "Bounds_"}], "body": "                                                                      { _bb.order(ByteOrder.LITTLE_ENDIAN); return (obj.__assign(_bb.getInt(_bb.position()) + _bb.position(), _bb)); }", "signature": "public static Bounds_ getRootAsBounds_(ByteBuffer _bb, Bounds_ obj)"}, {"syntax_pass": true, "original_string": "  public void __init(int _i, ByteBuffer _bb) { __reset(_i, _bb); }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "__init", "params": [{"name": "_i", "type": "int"}, {"name": "_bb", "type": "ByteBuffer"}], "body": "                                             { __reset(_i, _bb); }", "signature": "public void __init(int _i, ByteBuffer _bb)"}, {"syntax_pass": true, "original_string": "  public Bounds_ __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Bounds_", "classes": []}, "name": "__assign", "params": [{"name": "_i", "type": "int"}, {"name": "_bb", "type": "ByteBuffer"}], "body": "                                                  { __init(_i, _bb); return this; }", "signature": "public Bounds_ __assign(int _i, ByteBuffer _bb)"}, {"syntax_pass": true, "original_string": "  public byte type() { int o = __offset(4); return o != 0 ? bb.get(o + bb_pos) : 0; }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "byte", "classes": []}, "name": "type", "params": [], "body": "                     { int o = __offset(4); return o != 0 ? bb.get(o + bb_pos) : 0; }", "signature": "public byte type()"}, {"syntax_pass": true, "original_string": "  public com.github.davidmoten.rtree.fbs.generated.BoxFloat_ boxFloat() { return boxFloat(new com.github.davidmoten.rtree.fbs.generated.BoxFloat_()); }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "com.github.davidmoten.rtree.fbs.generated.BoxFloat_", "classes": []}, "name": "boxFloat", "params": [], "body": "                                                                        { return boxFloat(new com.github.davidmoten.rtree.fbs.generated.BoxFloat_()); }", "signature": "public com.github.davidmoten.rtree.fbs.generated.BoxFloat_ boxFloat()"}, {"syntax_pass": true, "original_string": "  public com.github.davidmoten.rtree.fbs.generated.BoxFloat_ boxFloat(com.github.davidmoten.rtree.fbs.generated.BoxFloat_ obj) { int o = __offset(6); return o != 0 ? obj.__assign(o + bb_pos, bb) : null; }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "com.github.davidmoten.rtree.fbs.generated.BoxFloat_", "classes": []}, "name": "boxFloat", "params": [{"name": "obj", "type": "com.github.davidmoten.rtree.fbs.generated.BoxFloat_"}], "body": "                                                                                                                               { int o = __offset(6); return o != 0 ? obj.__assign(o + bb_pos, bb) : null; }", "signature": "public com.github.davidmoten.rtree.fbs.generated.BoxFloat_ boxFloat(com.github.davidmoten.rtree.fbs.generated.BoxFloat_ obj)"}, {"syntax_pass": true, "original_string": "  public com.github.davidmoten.rtree.fbs.generated.BoxDouble_ boxDouble() { return boxDouble(new com.github.davidmoten.rtree.fbs.generated.BoxDouble_()); }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "com.github.davidmoten.rtree.fbs.generated.BoxDouble_", "classes": []}, "name": "boxDouble", "params": [], "body": "                                                                          { return boxDouble(new com.github.davidmoten.rtree.fbs.generated.BoxDouble_()); }", "signature": "public com.github.davidmoten.rtree.fbs.generated.BoxDouble_ boxDouble()"}, {"syntax_pass": true, "original_string": "  public com.github.davidmoten.rtree.fbs.generated.BoxDouble_ boxDouble(com.github.davidmoten.rtree.fbs.generated.BoxDouble_ obj) { int o = __offset(8); return o != 0 ? obj.__assign(o + bb_pos, bb) : null; }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "com.github.davidmoten.rtree.fbs.generated.BoxDouble_", "classes": []}, "name": "boxDouble", "params": [{"name": "obj", "type": "com.github.davidmoten.rtree.fbs.generated.BoxDouble_"}], "body": "                                                                                                                                  { int o = __offset(8); return o != 0 ? obj.__assign(o + bb_pos, bb) : null; }", "signature": "public com.github.davidmoten.rtree.fbs.generated.BoxDouble_ boxDouble(com.github.davidmoten.rtree.fbs.generated.BoxDouble_ obj)"}, {"syntax_pass": true, "original_string": "  public static void startBounds_(FlatBufferBuilder builder) { builder.startTable(3); }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "void", "classes": []}, "name": "startBounds_", "params": [{"name": "builder", "type": "FlatBufferBuilder"}], "body": "                                                             { builder.startTable(3); }", "signature": "public static void startBounds_(FlatBufferBuilder builder)"}, {"syntax_pass": true, "original_string": "  public static void addType(FlatBufferBuilder builder, byte type) { builder.addByte(0, type, 0); }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "void", "classes": []}, "name": "addType", "params": [{"name": "builder", "type": "FlatBufferBuilder"}, {"name": "type", "type": "byte"}], "body": "                                                                   { builder.addByte(0, type, 0); }", "signature": "public static void addType(FlatBufferBuilder builder, byte type)"}, {"syntax_pass": true, "original_string": "  public static void addBoxFloat(FlatBufferBuilder builder, int boxFloatOffset) { builder.addStruct(1, boxFloatOffset, 0); }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "void", "classes": []}, "name": "addBoxFloat", "params": [{"name": "builder", "type": "FlatBufferBuilder"}, {"name": "boxFloatOffset", "type": "int"}], "body": "                                                                                { builder.addStruct(1, boxFloatOffset, 0); }", "signature": "public static void addBoxFloat(FlatBufferBuilder builder, int boxFloatOffset)"}, {"syntax_pass": true, "original_string": "  public static void addBoxDouble(FlatBufferBuilder builder, int boxDoubleOffset) { builder.addStruct(2, boxDoubleOffset, 0); }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "void", "classes": []}, "name": "addBoxDouble", "params": [{"name": "builder", "type": "FlatBufferBuilder"}, {"name": "boxDoubleOffset", "type": "int"}], "body": "                                                                                  { builder.addStruct(2, boxDoubleOffset, 0); }", "signature": "public static void addBoxDouble(FlatBufferBuilder builder, int boxDoubleOffset)"}, {"syntax_pass": true, "original_string": "  public static int endBounds_(FlatBufferBuilder builder) {\n    int o = builder.endTable();\n    return o;\n  }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "int", "classes": []}, "name": "endBounds_", "params": [{"name": "builder", "type": "FlatBufferBuilder"}], "body": "                                                          {\n    int o = builder.endTable();\n    return o;\n  }", "signature": "public static int endBounds_(FlatBufferBuilder builder)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/com/github/davidmoten/rtree/fbs/generated/PointFloat_.java", "original_string": "// automatically generated by the FlatBuffers compiler, do not modify\n\npackage com.github.davidmoten.rtree.fbs.generated;\n\nimport java.nio.*;\nimport java.lang.*;\nimport java.util.*;\nimport com.google.flatbuffers.*;\n\n@SuppressWarnings(\"unused\")\npublic final class PointFloat_ extends Struct {\n  public void __init(int _i, ByteBuffer _bb) { __reset(_i, _bb); }\n  public PointFloat_ __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }\n\n  public float x() { return bb.getFloat(bb_pos + 0); }\n  public float y() { return bb.getFloat(bb_pos + 4); }\n\n  public static int createPointFloat_(FlatBufferBuilder builder, float x, float y) {\n    builder.prep(4, 8);\n    builder.putFloat(y);\n    builder.putFloat(x);\n    return builder.offset();\n  }\n\n  public static final class Vector extends BaseVector {\n    public Vector __assign(int _vector, int _element_size, ByteBuffer _bb) { __reset(_vector, _element_size, _bb); return this; }\n\n    public PointFloat_ get(int j) { return get(new PointFloat_(), j); }\n    public PointFloat_ get(PointFloat_ obj, int j) {  return obj.__assign(__element(j), bb); }\n  }\n}\n\n", "file_hash": "b8a6357a6a3258bff28b06b7349c8c459d221d0614a86ede349b8b31267b364b", "file_docstring": " automatically generated by the FlatBuffers compiler, do not modify", "contexts": ["package com.github.davidmoten.rtree.fbs.generated;", "import java.nio.*;", "import java.lang.*;", "import java.util.*;", "import com.google.flatbuffers.*;"], "methods": [], "classes": [{"original_string": "@SuppressWarnings(\"unused\")\npublic final class PointFloat_ extends Struct {\n  public void __init(int _i, ByteBuffer _bb) { __reset(_i, _bb); }\n  public PointFloat_ __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }\n\n  public float x() { return bb.getFloat(bb_pos + 0); }\n  public float y() { return bb.getFloat(bb_pos + 4); }\n\n  public static int createPointFloat_(FlatBufferBuilder builder, float x, float y) {\n    builder.prep(4, 8);\n    builder.putFloat(y);\n    builder.putFloat(x);\n    return builder.offset();\n  }\n\n  public static final class Vector extends BaseVector {\n    public Vector __assign(int _vector, int _element_size, ByteBuffer _bb) { __reset(_vector, _element_size, _bb); return this; }\n\n    public PointFloat_ get(int j) { return get(new PointFloat_(), j); }\n    public PointFloat_ get(PointFloat_ obj, int j) {  return obj.__assign(__element(j), bb); }\n  }\n}", "definition": "@SuppressWarnings(\"unused\")\npublic final class PointFloat_ extends Struct", "class_docstring": "", "name": "PointFloat_", "super_interfaces": [], "superclasses": "Struct", "attributes": {"modifiers": "@SuppressWarnings(\"unused\")\npublic final", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings(\"unused\")", "public", "final"], "comments": [], "fields": [], "classes": [{"original_string": "  public static final class Vector extends BaseVector {\n    public Vector __assign(int _vector, int _element_size, ByteBuffer _bb) { __reset(_vector, _element_size, _bb); return this; }\n\n    public PointFloat_ get(int j) { return get(new PointFloat_(), j); }\n    public PointFloat_ get(PointFloat_ obj, int j) {  return obj.__assign(__element(j), bb); }\n  }", "definition": "  public static final class Vector extends BaseVector", "class_docstring": "", "name": "Vector", "super_interfaces": [], "superclasses": "BaseVector", "attributes": {"modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    public Vector __assign(int _vector, int _element_size, ByteBuffer _bb) { __reset(_vector, _element_size, _bb); return this; }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Vector", "classes": []}, "name": "__assign", "params": [{"name": "_vector", "type": "int"}, {"name": "_element_size", "type": "int"}, {"name": "_bb", "type": "ByteBuffer"}], "body": "                                                                           { __reset(_vector, _element_size, _bb); return this; }", "signature": "public Vector __assign(int _vector, int _element_size, ByteBuffer _bb)"}, {"syntax_pass": true, "original_string": "    public PointFloat_ get(int j) { return get(new PointFloat_(), j); }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "PointFloat_", "classes": []}, "name": "get", "params": [{"name": "j", "type": "int"}], "body": "                                  { return get(new PointFloat_(), j); }", "signature": "public PointFloat_ get(int j)"}, {"syntax_pass": true, "original_string": "    public PointFloat_ get(PointFloat_ obj, int j) {  return obj.__assign(__element(j), bb); }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "PointFloat_", "classes": []}, "name": "get", "params": [{"name": "obj", "type": "PointFloat_"}, {"name": "j", "type": "int"}], "body": "                                                   {  return obj.__assign(__element(j), bb); }", "signature": "public PointFloat_ get(PointFloat_ obj, int j)"}]}]}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "  public void __init(int _i, ByteBuffer _bb) { __reset(_i, _bb); }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "__init", "params": [{"name": "_i", "type": "int"}, {"name": "_bb", "type": "ByteBuffer"}], "body": "                                             { __reset(_i, _bb); }", "signature": "public void __init(int _i, ByteBuffer _bb)"}, {"syntax_pass": true, "original_string": "  public PointFloat_ __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "PointFloat_", "classes": []}, "name": "__assign", "params": [{"name": "_i", "type": "int"}, {"name": "_bb", "type": "ByteBuffer"}], "body": "                                                      { __init(_i, _bb); return this; }", "signature": "public PointFloat_ __assign(int _i, ByteBuffer _bb)"}, {"syntax_pass": true, "original_string": "  public float x() { return bb.getFloat(bb_pos + 0); }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "float", "classes": []}, "name": "x", "params": [], "body": "                   { return bb.getFloat(bb_pos + 0); }", "signature": "public float x()"}, {"syntax_pass": true, "original_string": "  public float y() { return bb.getFloat(bb_pos + 4); }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "float", "classes": []}, "name": "y", "params": [], "body": "                   { return bb.getFloat(bb_pos + 4); }", "signature": "public float y()"}, {"syntax_pass": true, "original_string": "  public static int createPointFloat_(FlatBufferBuilder builder, float x, float y) {\n    builder.prep(4, 8);\n    builder.putFloat(y);\n    builder.putFloat(x);\n    return builder.offset();\n  }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "int", "classes": []}, "name": "createPointFloat_", "params": [{"name": "builder", "type": "FlatBufferBuilder"}, {"name": "x", "type": "float"}, {"name": "y", "type": "float"}], "body": "                                                                                   {\n    builder.prep(4, 8);\n    builder.putFloat(y);\n    builder.putFloat(x);\n    return builder.offset();\n  }", "signature": "public static int createPointFloat_(FlatBufferBuilder builder, float x, float y)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/com/github/davidmoten/rtree/fbs/generated/Entry_.java", "original_string": "// automatically generated by the FlatBuffers compiler, do not modify\n\npackage com.github.davidmoten.rtree.fbs.generated;\n\nimport java.nio.*;\nimport java.lang.*;\nimport java.util.*;\nimport com.google.flatbuffers.*;\n\n@SuppressWarnings(\"unused\")\npublic final class Entry_ extends Table {\n  public static void ValidateVersion() { Constants.FLATBUFFERS_2_0_8(); }\n  public static Entry_ getRootAsEntry_(ByteBuffer _bb) { return getRootAsEntry_(_bb, new Entry_()); }\n  public static Entry_ getRootAsEntry_(ByteBuffer _bb, Entry_ obj) { _bb.order(ByteOrder.LITTLE_ENDIAN); return (obj.__assign(_bb.getInt(_bb.position()) + _bb.position(), _bb)); }\n  public void __init(int _i, ByteBuffer _bb) { __reset(_i, _bb); }\n  public Entry_ __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }\n\n  public com.github.davidmoten.rtree.fbs.generated.Geometry_ geometry() { return geometry(new com.github.davidmoten.rtree.fbs.generated.Geometry_()); }\n  public com.github.davidmoten.rtree.fbs.generated.Geometry_ geometry(com.github.davidmoten.rtree.fbs.generated.Geometry_ obj) { int o = __offset(4); return o != 0 ? obj.__assign(__indirect(o + bb_pos), bb) : null; }\n  public byte object(int j) { int o = __offset(6); return o != 0 ? bb.get(__vector(o) + j * 1) : 0; }\n  public int objectLength() { int o = __offset(6); return o != 0 ? __vector_len(o) : 0; }\n  public ByteVector objectVector() { return objectVector(new ByteVector()); }\n  public ByteVector objectVector(ByteVector obj) { int o = __offset(6); return o != 0 ? obj.__assign(__vector(o), bb) : null; }\n  public ByteBuffer objectAsByteBuffer() { return __vector_as_bytebuffer(6, 1); }\n  public ByteBuffer objectInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 6, 1); }\n\n  public static int createEntry_(FlatBufferBuilder builder,\n      int geometryOffset,\n      int objectOffset) {\n    builder.startTable(2);\n    Entry_.addObject(builder, objectOffset);\n    Entry_.addGeometry(builder, geometryOffset);\n    return Entry_.endEntry_(builder);\n  }\n\n  public static void startEntry_(FlatBufferBuilder builder) { builder.startTable(2); }\n  public static void addGeometry(FlatBufferBuilder builder, int geometryOffset) { builder.addOffset(0, geometryOffset, 0); }\n  public static void addObject(FlatBufferBuilder builder, int objectOffset) { builder.addOffset(1, objectOffset, 0); }\n  public static int createObjectVector(FlatBufferBuilder builder, byte[] data) { return builder.createByteVector(data); }\n  public static int createObjectVector(FlatBufferBuilder builder, ByteBuffer data) { return builder.createByteVector(data); }\n  public static void startObjectVector(FlatBufferBuilder builder, int numElems) { builder.startVector(1, numElems, 1); }\n  public static int endEntry_(FlatBufferBuilder builder) {\n    int o = builder.endTable();\n    return o;\n  }\n\n  public static final class Vector extends BaseVector {\n    public Vector __assign(int _vector, int _element_size, ByteBuffer _bb) { __reset(_vector, _element_size, _bb); return this; }\n\n    public Entry_ get(int j) { return get(new Entry_(), j); }\n    public Entry_ get(Entry_ obj, int j) {  return obj.__assign(__indirect(__element(j), bb), bb); }\n  }\n}\n\n", "file_hash": "7505adfb4d483a611e1be95dc78c2e8a750f108e3f52189823bdd0176f1b97cd", "file_docstring": " automatically generated by the FlatBuffers compiler, do not modify", "contexts": ["package com.github.davidmoten.rtree.fbs.generated;", "import java.nio.*;", "import java.lang.*;", "import java.util.*;", "import com.google.flatbuffers.*;"], "methods": [], "classes": [{"original_string": "@SuppressWarnings(\"unused\")\npublic final class Entry_ extends Table {\n  public static void ValidateVersion() { Constants.FLATBUFFERS_2_0_8(); }\n  public static Entry_ getRootAsEntry_(ByteBuffer _bb) { return getRootAsEntry_(_bb, new Entry_()); }\n  public static Entry_ getRootAsEntry_(ByteBuffer _bb, Entry_ obj) { _bb.order(ByteOrder.LITTLE_ENDIAN); return (obj.__assign(_bb.getInt(_bb.position()) + _bb.position(), _bb)); }\n  public void __init(int _i, ByteBuffer _bb) { __reset(_i, _bb); }\n  public Entry_ __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }\n\n  public com.github.davidmoten.rtree.fbs.generated.Geometry_ geometry() { return geometry(new com.github.davidmoten.rtree.fbs.generated.Geometry_()); }\n  public com.github.davidmoten.rtree.fbs.generated.Geometry_ geometry(com.github.davidmoten.rtree.fbs.generated.Geometry_ obj) { int o = __offset(4); return o != 0 ? obj.__assign(__indirect(o + bb_pos), bb) : null; }\n  public byte object(int j) { int o = __offset(6); return o != 0 ? bb.get(__vector(o) + j * 1) : 0; }\n  public int objectLength() { int o = __offset(6); return o != 0 ? __vector_len(o) : 0; }\n  public ByteVector objectVector() { return objectVector(new ByteVector()); }\n  public ByteVector objectVector(ByteVector obj) { int o = __offset(6); return o != 0 ? obj.__assign(__vector(o), bb) : null; }\n  public ByteBuffer objectAsByteBuffer() { return __vector_as_bytebuffer(6, 1); }\n  public ByteBuffer objectInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 6, 1); }\n\n  public static int createEntry_(FlatBufferBuilder builder,\n      int geometryOffset,\n      int objectOffset) {\n    builder.startTable(2);\n    Entry_.addObject(builder, objectOffset);\n    Entry_.addGeometry(builder, geometryOffset);\n    return Entry_.endEntry_(builder);\n  }\n\n  public static void startEntry_(FlatBufferBuilder builder) { builder.startTable(2); }\n  public static void addGeometry(FlatBufferBuilder builder, int geometryOffset) { builder.addOffset(0, geometryOffset, 0); }\n  public static void addObject(FlatBufferBuilder builder, int objectOffset) { builder.addOffset(1, objectOffset, 0); }\n  public static int createObjectVector(FlatBufferBuilder builder, byte[] data) { return builder.createByteVector(data); }\n  public static int createObjectVector(FlatBufferBuilder builder, ByteBuffer data) { return builder.createByteVector(data); }\n  public static void startObjectVector(FlatBufferBuilder builder, int numElems) { builder.startVector(1, numElems, 1); }\n  public static int endEntry_(FlatBufferBuilder builder) {\n    int o = builder.endTable();\n    return o;\n  }\n\n  public static final class Vector extends BaseVector {\n    public Vector __assign(int _vector, int _element_size, ByteBuffer _bb) { __reset(_vector, _element_size, _bb); return this; }\n\n    public Entry_ get(int j) { return get(new Entry_(), j); }\n    public Entry_ get(Entry_ obj, int j) {  return obj.__assign(__indirect(__element(j), bb), bb); }\n  }\n}", "definition": "@SuppressWarnings(\"unused\")\npublic final class Entry_ extends Table", "class_docstring": "", "name": "Entry_", "super_interfaces": [], "superclasses": "Table", "attributes": {"modifiers": "@SuppressWarnings(\"unused\")\npublic final", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings(\"unused\")", "public", "final"], "comments": [], "fields": [], "classes": [{"original_string": "  public static final class Vector extends BaseVector {\n    public Vector __assign(int _vector, int _element_size, ByteBuffer _bb) { __reset(_vector, _element_size, _bb); return this; }\n\n    public Entry_ get(int j) { return get(new Entry_(), j); }\n    public Entry_ get(Entry_ obj, int j) {  return obj.__assign(__indirect(__element(j), bb), bb); }\n  }", "definition": "  public static final class Vector extends BaseVector", "class_docstring": "", "name": "Vector", "super_interfaces": [], "superclasses": "BaseVector", "attributes": {"modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    public Vector __assign(int _vector, int _element_size, ByteBuffer _bb) { __reset(_vector, _element_size, _bb); return this; }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Vector", "classes": []}, "name": "__assign", "params": [{"name": "_vector", "type": "int"}, {"name": "_element_size", "type": "int"}, {"name": "_bb", "type": "ByteBuffer"}], "body": "                                                                           { __reset(_vector, _element_size, _bb); return this; }", "signature": "public Vector __assign(int _vector, int _element_size, ByteBuffer _bb)"}, {"syntax_pass": true, "original_string": "    public Entry_ get(int j) { return get(new Entry_(), j); }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Entry_", "classes": []}, "name": "get", "params": [{"name": "j", "type": "int"}], "body": "                             { return get(new Entry_(), j); }", "signature": "public Entry_ get(int j)"}, {"syntax_pass": true, "original_string": "    public Entry_ get(Entry_ obj, int j) {  return obj.__assign(__indirect(__element(j), bb), bb); }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Entry_", "classes": []}, "name": "get", "params": [{"name": "obj", "type": "Entry_"}, {"name": "j", "type": "int"}], "body": "                                         {  return obj.__assign(__indirect(__element(j), bb), bb); }", "signature": "public Entry_ get(Entry_ obj, int j)"}]}]}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "  public static void ValidateVersion() { Constants.FLATBUFFERS_2_0_8(); }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "void", "classes": []}, "name": "ValidateVersion", "params": [], "body": "                                       { Constants.FLATBUFFERS_2_0_8(); }", "signature": "public static void ValidateVersion()"}, {"syntax_pass": true, "original_string": "  public static Entry_ getRootAsEntry_(ByteBuffer _bb) { return getRootAsEntry_(_bb, new Entry_()); }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Entry_", "classes": []}, "name": "getRootAsEntry_", "params": [{"name": "_bb", "type": "ByteBuffer"}], "body": "                                                       { return getRootAsEntry_(_bb, new Entry_()); }", "signature": "public static Entry_ getRootAsEntry_(ByteBuffer _bb)"}, {"syntax_pass": true, "original_string": "  public static Entry_ getRootAsEntry_(ByteBuffer _bb, Entry_ obj) { _bb.order(ByteOrder.LITTLE_ENDIAN); return (obj.__assign(_bb.getInt(_bb.position()) + _bb.position(), _bb)); }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Entry_", "classes": []}, "name": "getRootAsEntry_", "params": [{"name": "_bb", "type": "ByteBuffer"}, {"name": "obj", "type": "Entry_"}], "body": "                                                                   { _bb.order(ByteOrder.LITTLE_ENDIAN); return (obj.__assign(_bb.getInt(_bb.position()) + _bb.position(), _bb)); }", "signature": "public static Entry_ getRootAsEntry_(ByteBuffer _bb, Entry_ obj)"}, {"syntax_pass": true, "original_string": "  public void __init(int _i, ByteBuffer _bb) { __reset(_i, _bb); }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "__init", "params": [{"name": "_i", "type": "int"}, {"name": "_bb", "type": "ByteBuffer"}], "body": "                                             { __reset(_i, _bb); }", "signature": "public void __init(int _i, ByteBuffer _bb)"}, {"syntax_pass": true, "original_string": "  public Entry_ __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Entry_", "classes": []}, "name": "__assign", "params": [{"name": "_i", "type": "int"}, {"name": "_bb", "type": "ByteBuffer"}], "body": "                                                 { __init(_i, _bb); return this; }", "signature": "public Entry_ __assign(int _i, ByteBuffer _bb)"}, {"syntax_pass": true, "original_string": "  public com.github.davidmoten.rtree.fbs.generated.Geometry_ geometry() { return geometry(new com.github.davidmoten.rtree.fbs.generated.Geometry_()); }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "com.github.davidmoten.rtree.fbs.generated.Geometry_", "classes": []}, "name": "geometry", "params": [], "body": "                                                                        { return geometry(new com.github.davidmoten.rtree.fbs.generated.Geometry_()); }", "signature": "public com.github.davidmoten.rtree.fbs.generated.Geometry_ geometry()"}, {"syntax_pass": true, "original_string": "  public com.github.davidmoten.rtree.fbs.generated.Geometry_ geometry(com.github.davidmoten.rtree.fbs.generated.Geometry_ obj) { int o = __offset(4); return o != 0 ? obj.__assign(__indirect(o + bb_pos), bb) : null; }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "com.github.davidmoten.rtree.fbs.generated.Geometry_", "classes": []}, "name": "geometry", "params": [{"name": "obj", "type": "com.github.davidmoten.rtree.fbs.generated.Geometry_"}], "body": "                                                                                                                               { int o = __offset(4); return o != 0 ? obj.__assign(__indirect(o + bb_pos), bb) : null; }", "signature": "public com.github.davidmoten.rtree.fbs.generated.Geometry_ geometry(com.github.davidmoten.rtree.fbs.generated.Geometry_ obj)"}, {"syntax_pass": true, "original_string": "  public byte object(int j) { int o = __offset(6); return o != 0 ? bb.get(__vector(o) + j * 1) : 0; }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "byte", "classes": []}, "name": "object", "params": [{"name": "j", "type": "int"}], "body": "                            { int o = __offset(6); return o != 0 ? bb.get(__vector(o) + j * 1) : 0; }", "signature": "public byte object(int j)"}, {"syntax_pass": true, "original_string": "  public int objectLength() { int o = __offset(6); return o != 0 ? __vector_len(o) : 0; }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "objectLength", "params": [], "body": "                            { int o = __offset(6); return o != 0 ? __vector_len(o) : 0; }", "signature": "public int objectLength()"}, {"syntax_pass": true, "original_string": "  public ByteVector objectVector() { return objectVector(new ByteVector()); }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ByteVector", "classes": []}, "name": "objectVector", "params": [], "body": "                                   { return objectVector(new ByteVector()); }", "signature": "public ByteVector objectVector()"}, {"syntax_pass": true, "original_string": "  public ByteVector objectVector(ByteVector obj) { int o = __offset(6); return o != 0 ? obj.__assign(__vector(o), bb) : null; }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ByteVector", "classes": []}, "name": "objectVector", "params": [{"name": "obj", "type": "ByteVector"}], "body": "                                                 { int o = __offset(6); return o != 0 ? obj.__assign(__vector(o), bb) : null; }", "signature": "public ByteVector objectVector(ByteVector obj)"}, {"syntax_pass": true, "original_string": "  public ByteBuffer objectAsByteBuffer() { return __vector_as_bytebuffer(6, 1); }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ByteBuffer", "classes": []}, "name": "objectAsByteBuffer", "params": [], "body": "                                         { return __vector_as_bytebuffer(6, 1); }", "signature": "public ByteBuffer objectAsByteBuffer()"}, {"syntax_pass": true, "original_string": "  public ByteBuffer objectInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 6, 1); }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ByteBuffer", "classes": []}, "name": "objectInByteBuffer", "params": [{"name": "_bb", "type": "ByteBuffer"}], "body": "                                                       { return __vector_in_bytebuffer(_bb, 6, 1); }", "signature": "public ByteBuffer objectInByteBuffer(ByteBuffer _bb)"}, {"syntax_pass": true, "original_string": "  public static int createEntry_(FlatBufferBuilder builder,\n      int geometryOffset,\n      int objectOffset) {\n    builder.startTable(2);\n    Entry_.addObject(builder, objectOffset);\n    Entry_.addGeometry(builder, geometryOffset);\n    return Entry_.endEntry_(builder);\n  }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "int", "classes": []}, "name": "createEntry_", "params": [{"name": "builder", "type": "FlatBufferBuilder"}, {"name": "geometryOffset", "type": "int"}, {"name": "objectOffset", "type": "int"}], "body": "                        {\n    builder.startTable(2);\n    Entry_.addObject(builder, objectOffset);\n    Entry_.addGeometry(builder, geometryOffset);\n    return Entry_.endEntry_(builder);\n  }", "signature": "public static int createEntry_(FlatBufferBuilder builder,\n      int geometryOffset,\n      int objectOffset)"}, {"syntax_pass": true, "original_string": "  public static void startEntry_(FlatBufferBuilder builder) { builder.startTable(2); }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "void", "classes": []}, "name": "startEntry_", "params": [{"name": "builder", "type": "FlatBufferBuilder"}], "body": "                                                            { builder.startTable(2); }", "signature": "public static void startEntry_(FlatBufferBuilder builder)"}, {"syntax_pass": true, "original_string": "  public static void addGeometry(FlatBufferBuilder builder, int geometryOffset) { builder.addOffset(0, geometryOffset, 0); }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "void", "classes": []}, "name": "addGeometry", "params": [{"name": "builder", "type": "FlatBufferBuilder"}, {"name": "geometryOffset", "type": "int"}], "body": "                                                                                { builder.addOffset(0, geometryOffset, 0); }", "signature": "public static void addGeometry(FlatBufferBuilder builder, int geometryOffset)"}, {"syntax_pass": true, "original_string": "  public static void addObject(FlatBufferBuilder builder, int objectOffset) { builder.addOffset(1, objectOffset, 0); }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "void", "classes": []}, "name": "addObject", "params": [{"name": "builder", "type": "FlatBufferBuilder"}, {"name": "objectOffset", "type": "int"}], "body": "                                                                            { builder.addOffset(1, objectOffset, 0); }", "signature": "public static void addObject(FlatBufferBuilder builder, int objectOffset)"}, {"syntax_pass": true, "original_string": "  public static int createObjectVector(FlatBufferBuilder builder, byte[] data) { return builder.createByteVector(data); }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "int", "classes": []}, "name": "createObjectVector", "params": [{"name": "builder", "type": "FlatBufferBuilder"}, {"name": "data", "type": "byte[]"}], "body": "                                                                               { return builder.createByteVector(data); }", "signature": "public static int createObjectVector(FlatBufferBuilder builder, byte[] data)"}, {"syntax_pass": true, "original_string": "  public static int createObjectVector(FlatBufferBuilder builder, ByteBuffer data) { return builder.createByteVector(data); }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "int", "classes": []}, "name": "createObjectVector", "params": [{"name": "builder", "type": "FlatBufferBuilder"}, {"name": "data", "type": "ByteBuffer"}], "body": "                                                                                   { return builder.createByteVector(data); }", "signature": "public static int createObjectVector(FlatBufferBuilder builder, ByteBuffer data)"}, {"syntax_pass": true, "original_string": "  public static void startObjectVector(FlatBufferBuilder builder, int numElems) { builder.startVector(1, numElems, 1); }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "void", "classes": []}, "name": "startObjectVector", "params": [{"name": "builder", "type": "FlatBufferBuilder"}, {"name": "numElems", "type": "int"}], "body": "                                                                                { builder.startVector(1, numElems, 1); }", "signature": "public static void startObjectVector(FlatBufferBuilder builder, int numElems)"}, {"syntax_pass": true, "original_string": "  public static int endEntry_(FlatBufferBuilder builder) {\n    int o = builder.endTable();\n    return o;\n  }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "int", "classes": []}, "name": "endEntry_", "params": [{"name": "builder", "type": "FlatBufferBuilder"}], "body": "                                                         {\n    int o = builder.endTable();\n    return o;\n  }", "signature": "public static int endEntry_(FlatBufferBuilder builder)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/com/github/davidmoten/rtree/fbs/generated/LineFloat_.java", "original_string": "// automatically generated by the FlatBuffers compiler, do not modify\n\npackage com.github.davidmoten.rtree.fbs.generated;\n\nimport java.nio.*;\nimport java.lang.*;\nimport java.util.*;\nimport com.google.flatbuffers.*;\n\n@SuppressWarnings(\"unused\")\npublic final class LineFloat_ extends Struct {\n  public void __init(int _i, ByteBuffer _bb) { __reset(_i, _bb); }\n  public LineFloat_ __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }\n\n  public float minX() { return bb.getFloat(bb_pos + 0); }\n  public float minY() { return bb.getFloat(bb_pos + 4); }\n  public float maxX() { return bb.getFloat(bb_pos + 8); }\n  public float maxY() { return bb.getFloat(bb_pos + 12); }\n\n  public static int createLineFloat_(FlatBufferBuilder builder, float minX, float minY, float maxX, float maxY) {\n    builder.prep(4, 16);\n    builder.putFloat(maxY);\n    builder.putFloat(maxX);\n    builder.putFloat(minY);\n    builder.putFloat(minX);\n    return builder.offset();\n  }\n\n  public static final class Vector extends BaseVector {\n    public Vector __assign(int _vector, int _element_size, ByteBuffer _bb) { __reset(_vector, _element_size, _bb); return this; }\n\n    public LineFloat_ get(int j) { return get(new LineFloat_(), j); }\n    public LineFloat_ get(LineFloat_ obj, int j) {  return obj.__assign(__element(j), bb); }\n  }\n}\n\n", "file_hash": "22c599bdf520665f7a9571273a19ad76f30cf04d68be9309c5d091b2d11ad6c1", "file_docstring": " automatically generated by the FlatBuffers compiler, do not modify", "contexts": ["package com.github.davidmoten.rtree.fbs.generated;", "import java.nio.*;", "import java.lang.*;", "import java.util.*;", "import com.google.flatbuffers.*;"], "methods": [], "classes": [{"original_string": "@SuppressWarnings(\"unused\")\npublic final class LineFloat_ extends Struct {\n  public void __init(int _i, ByteBuffer _bb) { __reset(_i, _bb); }\n  public LineFloat_ __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }\n\n  public float minX() { return bb.getFloat(bb_pos + 0); }\n  public float minY() { return bb.getFloat(bb_pos + 4); }\n  public float maxX() { return bb.getFloat(bb_pos + 8); }\n  public float maxY() { return bb.getFloat(bb_pos + 12); }\n\n  public static int createLineFloat_(FlatBufferBuilder builder, float minX, float minY, float maxX, float maxY) {\n    builder.prep(4, 16);\n    builder.putFloat(maxY);\n    builder.putFloat(maxX);\n    builder.putFloat(minY);\n    builder.putFloat(minX);\n    return builder.offset();\n  }\n\n  public static final class Vector extends BaseVector {\n    public Vector __assign(int _vector, int _element_size, ByteBuffer _bb) { __reset(_vector, _element_size, _bb); return this; }\n\n    public LineFloat_ get(int j) { return get(new LineFloat_(), j); }\n    public LineFloat_ get(LineFloat_ obj, int j) {  return obj.__assign(__element(j), bb); }\n  }\n}", "definition": "@SuppressWarnings(\"unused\")\npublic final class LineFloat_ extends Struct", "class_docstring": "", "name": "LineFloat_", "super_interfaces": [], "superclasses": "Struct", "attributes": {"modifiers": "@SuppressWarnings(\"unused\")\npublic final", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings(\"unused\")", "public", "final"], "comments": [], "fields": [], "classes": [{"original_string": "  public static final class Vector extends BaseVector {\n    public Vector __assign(int _vector, int _element_size, ByteBuffer _bb) { __reset(_vector, _element_size, _bb); return this; }\n\n    public LineFloat_ get(int j) { return get(new LineFloat_(), j); }\n    public LineFloat_ get(LineFloat_ obj, int j) {  return obj.__assign(__element(j), bb); }\n  }", "definition": "  public static final class Vector extends BaseVector", "class_docstring": "", "name": "Vector", "super_interfaces": [], "superclasses": "BaseVector", "attributes": {"modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    public Vector __assign(int _vector, int _element_size, ByteBuffer _bb) { __reset(_vector, _element_size, _bb); return this; }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Vector", "classes": []}, "name": "__assign", "params": [{"name": "_vector", "type": "int"}, {"name": "_element_size", "type": "int"}, {"name": "_bb", "type": "ByteBuffer"}], "body": "                                                                           { __reset(_vector, _element_size, _bb); return this; }", "signature": "public Vector __assign(int _vector, int _element_size, ByteBuffer _bb)"}, {"syntax_pass": true, "original_string": "    public LineFloat_ get(int j) { return get(new LineFloat_(), j); }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "LineFloat_", "classes": []}, "name": "get", "params": [{"name": "j", "type": "int"}], "body": "                                 { return get(new LineFloat_(), j); }", "signature": "public LineFloat_ get(int j)"}, {"syntax_pass": true, "original_string": "    public LineFloat_ get(LineFloat_ obj, int j) {  return obj.__assign(__element(j), bb); }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "LineFloat_", "classes": []}, "name": "get", "params": [{"name": "obj", "type": "LineFloat_"}, {"name": "j", "type": "int"}], "body": "                                                 {  return obj.__assign(__element(j), bb); }", "signature": "public LineFloat_ get(LineFloat_ obj, int j)"}]}]}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "  public void __init(int _i, ByteBuffer _bb) { __reset(_i, _bb); }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "__init", "params": [{"name": "_i", "type": "int"}, {"name": "_bb", "type": "ByteBuffer"}], "body": "                                             { __reset(_i, _bb); }", "signature": "public void __init(int _i, ByteBuffer _bb)"}, {"syntax_pass": true, "original_string": "  public LineFloat_ __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "LineFloat_", "classes": []}, "name": "__assign", "params": [{"name": "_i", "type": "int"}, {"name": "_bb", "type": "ByteBuffer"}], "body": "                                                     { __init(_i, _bb); return this; }", "signature": "public LineFloat_ __assign(int _i, ByteBuffer _bb)"}, {"syntax_pass": true, "original_string": "  public float minX() { return bb.getFloat(bb_pos + 0); }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "float", "classes": []}, "name": "minX", "params": [], "body": "                      { return bb.getFloat(bb_pos + 0); }", "signature": "public float minX()"}, {"syntax_pass": true, "original_string": "  public float minY() { return bb.getFloat(bb_pos + 4); }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "float", "classes": []}, "name": "minY", "params": [], "body": "                      { return bb.getFloat(bb_pos + 4); }", "signature": "public float minY()"}, {"syntax_pass": true, "original_string": "  public float maxX() { return bb.getFloat(bb_pos + 8); }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "float", "classes": []}, "name": "maxX", "params": [], "body": "                      { return bb.getFloat(bb_pos + 8); }", "signature": "public float maxX()"}, {"syntax_pass": true, "original_string": "  public float maxY() { return bb.getFloat(bb_pos + 12); }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "float", "classes": []}, "name": "maxY", "params": [], "body": "                      { return bb.getFloat(bb_pos + 12); }", "signature": "public float maxY()"}, {"syntax_pass": true, "original_string": "  public static int createLineFloat_(FlatBufferBuilder builder, float minX, float minY, float maxX, float maxY) {\n    builder.prep(4, 16);\n    builder.putFloat(maxY);\n    builder.putFloat(maxX);\n    builder.putFloat(minY);\n    builder.putFloat(minX);\n    return builder.offset();\n  }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "int", "classes": []}, "name": "createLineFloat_", "params": [{"name": "builder", "type": "FlatBufferBuilder"}, {"name": "minX", "type": "float"}, {"name": "minY", "type": "float"}, {"name": "maxX", "type": "float"}, {"name": "maxY", "type": "float"}], "body": "                                                                                                                {\n    builder.prep(4, 16);\n    builder.putFloat(maxY);\n    builder.putFloat(maxX);\n    builder.putFloat(minY);\n    builder.putFloat(minX);\n    return builder.offset();\n  }", "signature": "public static int createLineFloat_(FlatBufferBuilder builder, float minX, float minY, float maxX, float maxY)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/com/github/davidmoten/rtree/fbs/generated/CircleDouble_.java", "original_string": "// automatically generated by the FlatBuffers compiler, do not modify\n\npackage com.github.davidmoten.rtree.fbs.generated;\n\nimport java.nio.*;\nimport java.lang.*;\nimport java.util.*;\nimport com.google.flatbuffers.*;\n\n@SuppressWarnings(\"unused\")\npublic final class CircleDouble_ extends Struct {\n  public void __init(int _i, ByteBuffer _bb) { __reset(_i, _bb); }\n  public CircleDouble_ __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }\n\n  public double x() { return bb.getDouble(bb_pos + 0); }\n  public double y() { return bb.getDouble(bb_pos + 8); }\n  public double radius() { return bb.getDouble(bb_pos + 16); }\n\n  public static int createCircleDouble_(FlatBufferBuilder builder, double x, double y, double radius) {\n    builder.prep(8, 24);\n    builder.putDouble(radius);\n    builder.putDouble(y);\n    builder.putDouble(x);\n    return builder.offset();\n  }\n\n  public static final class Vector extends BaseVector {\n    public Vector __assign(int _vector, int _element_size, ByteBuffer _bb) { __reset(_vector, _element_size, _bb); return this; }\n\n    public CircleDouble_ get(int j) { return get(new CircleDouble_(), j); }\n    public CircleDouble_ get(CircleDouble_ obj, int j) {  return obj.__assign(__element(j), bb); }\n  }\n}\n\n", "file_hash": "1366dbe55cbaf7f22516dc33f216295ffe2bdf03d0fe4e199d05b2c473fc5d8c", "file_docstring": " automatically generated by the FlatBuffers compiler, do not modify", "contexts": ["package com.github.davidmoten.rtree.fbs.generated;", "import java.nio.*;", "import java.lang.*;", "import java.util.*;", "import com.google.flatbuffers.*;"], "methods": [], "classes": [{"original_string": "@SuppressWarnings(\"unused\")\npublic final class CircleDouble_ extends Struct {\n  public void __init(int _i, ByteBuffer _bb) { __reset(_i, _bb); }\n  public CircleDouble_ __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }\n\n  public double x() { return bb.getDouble(bb_pos + 0); }\n  public double y() { return bb.getDouble(bb_pos + 8); }\n  public double radius() { return bb.getDouble(bb_pos + 16); }\n\n  public static int createCircleDouble_(FlatBufferBuilder builder, double x, double y, double radius) {\n    builder.prep(8, 24);\n    builder.putDouble(radius);\n    builder.putDouble(y);\n    builder.putDouble(x);\n    return builder.offset();\n  }\n\n  public static final class Vector extends BaseVector {\n    public Vector __assign(int _vector, int _element_size, ByteBuffer _bb) { __reset(_vector, _element_size, _bb); return this; }\n\n    public CircleDouble_ get(int j) { return get(new CircleDouble_(), j); }\n    public CircleDouble_ get(CircleDouble_ obj, int j) {  return obj.__assign(__element(j), bb); }\n  }\n}", "definition": "@SuppressWarnings(\"unused\")\npublic final class CircleDouble_ extends Struct", "class_docstring": "", "name": "CircleDouble_", "super_interfaces": [], "superclasses": "Struct", "attributes": {"modifiers": "@SuppressWarnings(\"unused\")\npublic final", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings(\"unused\")", "public", "final"], "comments": [], "fields": [], "classes": [{"original_string": "  public static final class Vector extends BaseVector {\n    public Vector __assign(int _vector, int _element_size, ByteBuffer _bb) { __reset(_vector, _element_size, _bb); return this; }\n\n    public CircleDouble_ get(int j) { return get(new CircleDouble_(), j); }\n    public CircleDouble_ get(CircleDouble_ obj, int j) {  return obj.__assign(__element(j), bb); }\n  }", "definition": "  public static final class Vector extends BaseVector", "class_docstring": "", "name": "Vector", "super_interfaces": [], "superclasses": "BaseVector", "attributes": {"modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    public Vector __assign(int _vector, int _element_size, ByteBuffer _bb) { __reset(_vector, _element_size, _bb); return this; }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Vector", "classes": []}, "name": "__assign", "params": [{"name": "_vector", "type": "int"}, {"name": "_element_size", "type": "int"}, {"name": "_bb", "type": "ByteBuffer"}], "body": "                                                                           { __reset(_vector, _element_size, _bb); return this; }", "signature": "public Vector __assign(int _vector, int _element_size, ByteBuffer _bb)"}, {"syntax_pass": true, "original_string": "    public CircleDouble_ get(int j) { return get(new CircleDouble_(), j); }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "CircleDouble_", "classes": []}, "name": "get", "params": [{"name": "j", "type": "int"}], "body": "                                    { return get(new CircleDouble_(), j); }", "signature": "public CircleDouble_ get(int j)"}, {"syntax_pass": true, "original_string": "    public CircleDouble_ get(CircleDouble_ obj, int j) {  return obj.__assign(__element(j), bb); }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "CircleDouble_", "classes": []}, "name": "get", "params": [{"name": "obj", "type": "CircleDouble_"}, {"name": "j", "type": "int"}], "body": "                                                       {  return obj.__assign(__element(j), bb); }", "signature": "public CircleDouble_ get(CircleDouble_ obj, int j)"}]}]}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "  public void __init(int _i, ByteBuffer _bb) { __reset(_i, _bb); }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "__init", "params": [{"name": "_i", "type": "int"}, {"name": "_bb", "type": "ByteBuffer"}], "body": "                                             { __reset(_i, _bb); }", "signature": "public void __init(int _i, ByteBuffer _bb)"}, {"syntax_pass": true, "original_string": "  public CircleDouble_ __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "CircleDouble_", "classes": []}, "name": "__assign", "params": [{"name": "_i", "type": "int"}, {"name": "_bb", "type": "ByteBuffer"}], "body": "                                                        { __init(_i, _bb); return this; }", "signature": "public CircleDouble_ __assign(int _i, ByteBuffer _bb)"}, {"syntax_pass": true, "original_string": "  public double x() { return bb.getDouble(bb_pos + 0); }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "double", "classes": []}, "name": "x", "params": [], "body": "                    { return bb.getDouble(bb_pos + 0); }", "signature": "public double x()"}, {"syntax_pass": true, "original_string": "  public double y() { return bb.getDouble(bb_pos + 8); }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "double", "classes": []}, "name": "y", "params": [], "body": "                    { return bb.getDouble(bb_pos + 8); }", "signature": "public double y()"}, {"syntax_pass": true, "original_string": "  public double radius() { return bb.getDouble(bb_pos + 16); }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "double", "classes": []}, "name": "radius", "params": [], "body": "                         { return bb.getDouble(bb_pos + 16); }", "signature": "public double radius()"}, {"syntax_pass": true, "original_string": "  public static int createCircleDouble_(FlatBufferBuilder builder, double x, double y, double radius) {\n    builder.prep(8, 24);\n    builder.putDouble(radius);\n    builder.putDouble(y);\n    builder.putDouble(x);\n    return builder.offset();\n  }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "int", "classes": []}, "name": "createCircleDouble_", "params": [{"name": "builder", "type": "FlatBufferBuilder"}, {"name": "x", "type": "double"}, {"name": "y", "type": "double"}, {"name": "radius", "type": "double"}], "body": "                                                                                                      {\n    builder.prep(8, 24);\n    builder.putDouble(radius);\n    builder.putDouble(y);\n    builder.putDouble(x);\n    return builder.offset();\n  }", "signature": "public static int createCircleDouble_(FlatBufferBuilder builder, double x, double y, double radius)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/com/github/davidmoten/rtree/fbs/generated/BoundsType_.java", "original_string": "// automatically generated by the FlatBuffers compiler, do not modify\n\npackage com.github.davidmoten.rtree.fbs.generated;\n\npublic final class BoundsType_ {\n  private BoundsType_() { }\n  public static final byte BoundsFloat = 0;\n  public static final byte BoundsDouble = 1;\n\n  public static final String[] names = { \"BoundsFloat\", \"BoundsDouble\", };\n\n  public static String name(int e) { return names[e]; }\n}\n\n", "file_hash": "79a1ee633369fc8d2f44648ebe31723cad1b968be12e7d83ac99947c8e9d48c3", "file_docstring": " automatically generated by the FlatBuffers compiler, do not modify", "contexts": ["package com.github.davidmoten.rtree.fbs.generated;"], "methods": [], "classes": [{"original_string": "public final class BoundsType_ {\n  private BoundsType_() { }\n  public static final byte BoundsFloat = 0;\n  public static final byte BoundsDouble = 1;\n\n  public static final String[] names = { \"BoundsFloat\", \"BoundsDouble\", };\n\n  public static String name(int e) { return names[e]; }\n}", "definition": "public final class BoundsType_", "class_docstring": "", "name": "BoundsType_", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "fields": [{"attribute_expression": "public static final byte BoundsFloat = 0;", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "byte", "name": "BoundsFloat = 0", "syntax_pass": true}, {"attribute_expression": "public static final byte BoundsDouble = 1;", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "byte", "name": "BoundsDouble = 1", "syntax_pass": true}, {"attribute_expression": "public static final String[] names = { \"BoundsFloat\", \"BoundsDouble\", };", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "String[]", "name": "names = { \"BoundsFloat\", \"BoundsDouble\", }", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "  private BoundsType_() { }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "", "classes": []}, "name": "BoundsType_", "params": [], "body": "                        { }", "signature": "private BoundsType_()"}, {"syntax_pass": true, "original_string": "  public static String name(int e) { return names[e]; }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "String", "classes": []}, "name": "name", "params": [{"name": "e", "type": "int"}], "body": "                                   { return names[e]; }", "signature": "public static String name(int e)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/com/github/davidmoten/rtree/fbs/generated/Context_.java", "original_string": "// automatically generated by the FlatBuffers compiler, do not modify\n\npackage com.github.davidmoten.rtree.fbs.generated;\n\nimport java.nio.*;\nimport java.lang.*;\nimport java.util.*;\nimport com.google.flatbuffers.*;\n\n@SuppressWarnings(\"unused\")\npublic final class Context_ extends Table {\n  public static void ValidateVersion() { Constants.FLATBUFFERS_2_0_8(); }\n  public static Context_ getRootAsContext_(ByteBuffer _bb) { return getRootAsContext_(_bb, new Context_()); }\n  public static Context_ getRootAsContext_(ByteBuffer _bb, Context_ obj) { _bb.order(ByteOrder.LITTLE_ENDIAN); return (obj.__assign(_bb.getInt(_bb.position()) + _bb.position(), _bb)); }\n  public void __init(int _i, ByteBuffer _bb) { __reset(_i, _bb); }\n  public Context_ __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }\n\n  public com.github.davidmoten.rtree.fbs.generated.Bounds_ bounds() { return bounds(new com.github.davidmoten.rtree.fbs.generated.Bounds_()); }\n  public com.github.davidmoten.rtree.fbs.generated.Bounds_ bounds(com.github.davidmoten.rtree.fbs.generated.Bounds_ obj) { int o = __offset(4); return o != 0 ? obj.__assign(__indirect(o + bb_pos), bb) : null; }\n  public int minChildren() { int o = __offset(6); return o != 0 ? bb.getInt(o + bb_pos) : 0; }\n  public int maxChildren() { int o = __offset(8); return o != 0 ? bb.getInt(o + bb_pos) : 0; }\n\n  public static int createContext_(FlatBufferBuilder builder,\n      int boundsOffset,\n      int minChildren,\n      int maxChildren) {\n    builder.startTable(3);\n    Context_.addMaxChildren(builder, maxChildren);\n    Context_.addMinChildren(builder, minChildren);\n    Context_.addBounds(builder, boundsOffset);\n    return Context_.endContext_(builder);\n  }\n\n  public static void startContext_(FlatBufferBuilder builder) { builder.startTable(3); }\n  public static void addBounds(FlatBufferBuilder builder, int boundsOffset) { builder.addOffset(0, boundsOffset, 0); }\n  public static void addMinChildren(FlatBufferBuilder builder, int minChildren) { builder.addInt(1, minChildren, 0); }\n  public static void addMaxChildren(FlatBufferBuilder builder, int maxChildren) { builder.addInt(2, maxChildren, 0); }\n  public static int endContext_(FlatBufferBuilder builder) {\n    int o = builder.endTable();\n    return o;\n  }\n\n  public static final class Vector extends BaseVector {\n    public Vector __assign(int _vector, int _element_size, ByteBuffer _bb) { __reset(_vector, _element_size, _bb); return this; }\n\n    public Context_ get(int j) { return get(new Context_(), j); }\n    public Context_ get(Context_ obj, int j) {  return obj.__assign(__indirect(__element(j), bb), bb); }\n  }\n}\n\n", "file_hash": "f323eab2bc4c98493360678418f5c035a38ab2c9923976b7e2668a64a088ab06", "file_docstring": " automatically generated by the FlatBuffers compiler, do not modify", "contexts": ["package com.github.davidmoten.rtree.fbs.generated;", "import java.nio.*;", "import java.lang.*;", "import java.util.*;", "import com.google.flatbuffers.*;"], "methods": [], "classes": [{"original_string": "@SuppressWarnings(\"unused\")\npublic final class Context_ extends Table {\n  public static void ValidateVersion() { Constants.FLATBUFFERS_2_0_8(); }\n  public static Context_ getRootAsContext_(ByteBuffer _bb) { return getRootAsContext_(_bb, new Context_()); }\n  public static Context_ getRootAsContext_(ByteBuffer _bb, Context_ obj) { _bb.order(ByteOrder.LITTLE_ENDIAN); return (obj.__assign(_bb.getInt(_bb.position()) + _bb.position(), _bb)); }\n  public void __init(int _i, ByteBuffer _bb) { __reset(_i, _bb); }\n  public Context_ __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }\n\n  public com.github.davidmoten.rtree.fbs.generated.Bounds_ bounds() { return bounds(new com.github.davidmoten.rtree.fbs.generated.Bounds_()); }\n  public com.github.davidmoten.rtree.fbs.generated.Bounds_ bounds(com.github.davidmoten.rtree.fbs.generated.Bounds_ obj) { int o = __offset(4); return o != 0 ? obj.__assign(__indirect(o + bb_pos), bb) : null; }\n  public int minChildren() { int o = __offset(6); return o != 0 ? bb.getInt(o + bb_pos) : 0; }\n  public int maxChildren() { int o = __offset(8); return o != 0 ? bb.getInt(o + bb_pos) : 0; }\n\n  public static int createContext_(FlatBufferBuilder builder,\n      int boundsOffset,\n      int minChildren,\n      int maxChildren) {\n    builder.startTable(3);\n    Context_.addMaxChildren(builder, maxChildren);\n    Context_.addMinChildren(builder, minChildren);\n    Context_.addBounds(builder, boundsOffset);\n    return Context_.endContext_(builder);\n  }\n\n  public static void startContext_(FlatBufferBuilder builder) { builder.startTable(3); }\n  public static void addBounds(FlatBufferBuilder builder, int boundsOffset) { builder.addOffset(0, boundsOffset, 0); }\n  public static void addMinChildren(FlatBufferBuilder builder, int minChildren) { builder.addInt(1, minChildren, 0); }\n  public static void addMaxChildren(FlatBufferBuilder builder, int maxChildren) { builder.addInt(2, maxChildren, 0); }\n  public static int endContext_(FlatBufferBuilder builder) {\n    int o = builder.endTable();\n    return o;\n  }\n\n  public static final class Vector extends BaseVector {\n    public Vector __assign(int _vector, int _element_size, ByteBuffer _bb) { __reset(_vector, _element_size, _bb); return this; }\n\n    public Context_ get(int j) { return get(new Context_(), j); }\n    public Context_ get(Context_ obj, int j) {  return obj.__assign(__indirect(__element(j), bb), bb); }\n  }\n}", "definition": "@SuppressWarnings(\"unused\")\npublic final class Context_ extends Table", "class_docstring": "", "name": "Context_", "super_interfaces": [], "superclasses": "Table", "attributes": {"modifiers": "@SuppressWarnings(\"unused\")\npublic final", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings(\"unused\")", "public", "final"], "comments": [], "fields": [], "classes": [{"original_string": "  public static final class Vector extends BaseVector {\n    public Vector __assign(int _vector, int _element_size, ByteBuffer _bb) { __reset(_vector, _element_size, _bb); return this; }\n\n    public Context_ get(int j) { return get(new Context_(), j); }\n    public Context_ get(Context_ obj, int j) {  return obj.__assign(__indirect(__element(j), bb), bb); }\n  }", "definition": "  public static final class Vector extends BaseVector", "class_docstring": "", "name": "Vector", "super_interfaces": [], "superclasses": "BaseVector", "attributes": {"modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    public Vector __assign(int _vector, int _element_size, ByteBuffer _bb) { __reset(_vector, _element_size, _bb); return this; }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Vector", "classes": []}, "name": "__assign", "params": [{"name": "_vector", "type": "int"}, {"name": "_element_size", "type": "int"}, {"name": "_bb", "type": "ByteBuffer"}], "body": "                                                                           { __reset(_vector, _element_size, _bb); return this; }", "signature": "public Vector __assign(int _vector, int _element_size, ByteBuffer _bb)"}, {"syntax_pass": true, "original_string": "    public Context_ get(int j) { return get(new Context_(), j); }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Context_", "classes": []}, "name": "get", "params": [{"name": "j", "type": "int"}], "body": "                               { return get(new Context_(), j); }", "signature": "public Context_ get(int j)"}, {"syntax_pass": true, "original_string": "    public Context_ get(Context_ obj, int j) {  return obj.__assign(__indirect(__element(j), bb), bb); }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Context_", "classes": []}, "name": "get", "params": [{"name": "obj", "type": "Context_"}, {"name": "j", "type": "int"}], "body": "                                             {  return obj.__assign(__indirect(__element(j), bb), bb); }", "signature": "public Context_ get(Context_ obj, int j)"}]}]}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "  public static void ValidateVersion() { Constants.FLATBUFFERS_2_0_8(); }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "void", "classes": []}, "name": "ValidateVersion", "params": [], "body": "                                       { Constants.FLATBUFFERS_2_0_8(); }", "signature": "public static void ValidateVersion()"}, {"syntax_pass": true, "original_string": "  public static Context_ getRootAsContext_(ByteBuffer _bb) { return getRootAsContext_(_bb, new Context_()); }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Context_", "classes": []}, "name": "getRootAsContext_", "params": [{"name": "_bb", "type": "ByteBuffer"}], "body": "                                                           { return getRootAsContext_(_bb, new Context_()); }", "signature": "public static Context_ getRootAsContext_(ByteBuffer _bb)"}, {"syntax_pass": true, "original_string": "  public static Context_ getRootAsContext_(ByteBuffer _bb, Context_ obj) { _bb.order(ByteOrder.LITTLE_ENDIAN); return (obj.__assign(_bb.getInt(_bb.position()) + _bb.position(), _bb)); }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Context_", "classes": []}, "name": "getRootAsContext_", "params": [{"name": "_bb", "type": "ByteBuffer"}, {"name": "obj", "type": "Context_"}], "body": "                                                                         { _bb.order(ByteOrder.LITTLE_ENDIAN); return (obj.__assign(_bb.getInt(_bb.position()) + _bb.position(), _bb)); }", "signature": "public static Context_ getRootAsContext_(ByteBuffer _bb, Context_ obj)"}, {"syntax_pass": true, "original_string": "  public void __init(int _i, ByteBuffer _bb) { __reset(_i, _bb); }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "__init", "params": [{"name": "_i", "type": "int"}, {"name": "_bb", "type": "ByteBuffer"}], "body": "                                             { __reset(_i, _bb); }", "signature": "public void __init(int _i, ByteBuffer _bb)"}, {"syntax_pass": true, "original_string": "  public Context_ __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Context_", "classes": []}, "name": "__assign", "params": [{"name": "_i", "type": "int"}, {"name": "_bb", "type": "ByteBuffer"}], "body": "                                                   { __init(_i, _bb); return this; }", "signature": "public Context_ __assign(int _i, ByteBuffer _bb)"}, {"syntax_pass": true, "original_string": "  public com.github.davidmoten.rtree.fbs.generated.Bounds_ bounds() { return bounds(new com.github.davidmoten.rtree.fbs.generated.Bounds_()); }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "com.github.davidmoten.rtree.fbs.generated.Bounds_", "classes": []}, "name": "bounds", "params": [], "body": "                                                                    { return bounds(new com.github.davidmoten.rtree.fbs.generated.Bounds_()); }", "signature": "public com.github.davidmoten.rtree.fbs.generated.Bounds_ bounds()"}, {"syntax_pass": true, "original_string": "  public com.github.davidmoten.rtree.fbs.generated.Bounds_ bounds(com.github.davidmoten.rtree.fbs.generated.Bounds_ obj) { int o = __offset(4); return o != 0 ? obj.__assign(__indirect(o + bb_pos), bb) : null; }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "com.github.davidmoten.rtree.fbs.generated.Bounds_", "classes": []}, "name": "bounds", "params": [{"name": "obj", "type": "com.github.davidmoten.rtree.fbs.generated.Bounds_"}], "body": "                                                                                                                         { int o = __offset(4); return o != 0 ? obj.__assign(__indirect(o + bb_pos), bb) : null; }", "signature": "public com.github.davidmoten.rtree.fbs.generated.Bounds_ bounds(com.github.davidmoten.rtree.fbs.generated.Bounds_ obj)"}, {"syntax_pass": true, "original_string": "  public int minChildren() { int o = __offset(6); return o != 0 ? bb.getInt(o + bb_pos) : 0; }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "minChildren", "params": [], "body": "                           { int o = __offset(6); return o != 0 ? bb.getInt(o + bb_pos) : 0; }", "signature": "public int minChildren()"}, {"syntax_pass": true, "original_string": "  public int maxChildren() { int o = __offset(8); return o != 0 ? bb.getInt(o + bb_pos) : 0; }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "maxChildren", "params": [], "body": "                           { int o = __offset(8); return o != 0 ? bb.getInt(o + bb_pos) : 0; }", "signature": "public int maxChildren()"}, {"syntax_pass": true, "original_string": "  public static int createContext_(FlatBufferBuilder builder,\n      int boundsOffset,\n      int minChildren,\n      int maxChildren) {\n    builder.startTable(3);\n    Context_.addMaxChildren(builder, maxChildren);\n    Context_.addMinChildren(builder, minChildren);\n    Context_.addBounds(builder, boundsOffset);\n    return Context_.endContext_(builder);\n  }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "int", "classes": []}, "name": "createContext_", "params": [{"name": "builder", "type": "FlatBufferBuilder"}, {"name": "boundsOffset", "type": "int"}, {"name": "minChildren", "type": "int"}, {"name": "maxChildren", "type": "int"}], "body": "                       {\n    builder.startTable(3);\n    Context_.addMaxChildren(builder, maxChildren);\n    Context_.addMinChildren(builder, minChildren);\n    Context_.addBounds(builder, boundsOffset);\n    return Context_.endContext_(builder);\n  }", "signature": "public static int createContext_(FlatBufferBuilder builder,\n      int boundsOffset,\n      int minChildren,\n      int maxChildren)"}, {"syntax_pass": true, "original_string": "  public static void startContext_(FlatBufferBuilder builder) { builder.startTable(3); }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "void", "classes": []}, "name": "startContext_", "params": [{"name": "builder", "type": "FlatBufferBuilder"}], "body": "                                                              { builder.startTable(3); }", "signature": "public static void startContext_(FlatBufferBuilder builder)"}, {"syntax_pass": true, "original_string": "  public static void addBounds(FlatBufferBuilder builder, int boundsOffset) { builder.addOffset(0, boundsOffset, 0); }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "void", "classes": []}, "name": "addBounds", "params": [{"name": "builder", "type": "FlatBufferBuilder"}, {"name": "boundsOffset", "type": "int"}], "body": "                                                                            { builder.addOffset(0, boundsOffset, 0); }", "signature": "public static void addBounds(FlatBufferBuilder builder, int boundsOffset)"}, {"syntax_pass": true, "original_string": "  public static void addMinChildren(FlatBufferBuilder builder, int minChildren) { builder.addInt(1, minChildren, 0); }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "void", "classes": []}, "name": "addMinChildren", "params": [{"name": "builder", "type": "FlatBufferBuilder"}, {"name": "minChildren", "type": "int"}], "body": "                                                                                { builder.addInt(1, minChildren, 0); }", "signature": "public static void addMinChildren(FlatBufferBuilder builder, int minChildren)"}, {"syntax_pass": true, "original_string": "  public static void addMaxChildren(FlatBufferBuilder builder, int maxChildren) { builder.addInt(2, maxChildren, 0); }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "void", "classes": []}, "name": "addMaxChildren", "params": [{"name": "builder", "type": "FlatBufferBuilder"}, {"name": "maxChildren", "type": "int"}], "body": "                                                                                { builder.addInt(2, maxChildren, 0); }", "signature": "public static void addMaxChildren(FlatBufferBuilder builder, int maxChildren)"}, {"syntax_pass": true, "original_string": "  public static int endContext_(FlatBufferBuilder builder) {\n    int o = builder.endTable();\n    return o;\n  }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "int", "classes": []}, "name": "endContext_", "params": [{"name": "builder", "type": "FlatBufferBuilder"}], "body": "                                                           {\n    int o = builder.endTable();\n    return o;\n  }", "signature": "public static int endContext_(FlatBufferBuilder builder)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/com/github/davidmoten/rtree/fbs/generated/GeometryType_.java", "original_string": "// automatically generated by the FlatBuffers compiler, do not modify\n\npackage com.github.davidmoten.rtree.fbs.generated;\n\npublic final class GeometryType_ {\n  private GeometryType_() { }\n  public static final byte PointFloat = 0;\n  public static final byte BoxFloat = 1;\n  public static final byte CircleFloat = 2;\n  public static final byte LineFloat = 3;\n  public static final byte PointDouble = 4;\n  public static final byte BoxDouble = 5;\n  public static final byte CircleDouble = 6;\n  public static final byte LineDouble = 7;\n\n  public static final String[] names = { \"PointFloat\", \"BoxFloat\", \"CircleFloat\", \"LineFloat\", \"PointDouble\", \"BoxDouble\", \"CircleDouble\", \"LineDouble\", };\n\n  public static String name(int e) { return names[e]; }\n}\n\n", "file_hash": "f730e2cd69fec20462c2f581613310250cee66b0dd604c40c914d4cb90f5c10b", "file_docstring": " automatically generated by the FlatBuffers compiler, do not modify", "contexts": ["package com.github.davidmoten.rtree.fbs.generated;"], "methods": [], "classes": [{"original_string": "public final class GeometryType_ {\n  private GeometryType_() { }\n  public static final byte PointFloat = 0;\n  public static final byte BoxFloat = 1;\n  public static final byte CircleFloat = 2;\n  public static final byte LineFloat = 3;\n  public static final byte PointDouble = 4;\n  public static final byte BoxDouble = 5;\n  public static final byte CircleDouble = 6;\n  public static final byte LineDouble = 7;\n\n  public static final String[] names = { \"PointFloat\", \"BoxFloat\", \"CircleFloat\", \"LineFloat\", \"PointDouble\", \"BoxDouble\", \"CircleDouble\", \"LineDouble\", };\n\n  public static String name(int e) { return names[e]; }\n}", "definition": "public final class GeometryType_", "class_docstring": "", "name": "GeometryType_", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "fields": [{"attribute_expression": "public static final byte PointFloat = 0;", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "byte", "name": "PointFloat = 0", "syntax_pass": true}, {"attribute_expression": "public static final byte BoxFloat = 1;", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "byte", "name": "BoxFloat = 1", "syntax_pass": true}, {"attribute_expression": "public static final byte CircleFloat = 2;", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "byte", "name": "CircleFloat = 2", "syntax_pass": true}, {"attribute_expression": "public static final byte LineFloat = 3;", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "byte", "name": "LineFloat = 3", "syntax_pass": true}, {"attribute_expression": "public static final byte PointDouble = 4;", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "byte", "name": "PointDouble = 4", "syntax_pass": true}, {"attribute_expression": "public static final byte BoxDouble = 5;", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "byte", "name": "BoxDouble = 5", "syntax_pass": true}, {"attribute_expression": "public static final byte CircleDouble = 6;", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "byte", "name": "CircleDouble = 6", "syntax_pass": true}, {"attribute_expression": "public static final byte LineDouble = 7;", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "byte", "name": "LineDouble = 7", "syntax_pass": true}, {"attribute_expression": "public static final String[] names = { \"PointFloat\", \"BoxFloat\", \"CircleFloat\", \"LineFloat\", \"PointDouble\", \"BoxDouble\", \"CircleDouble\", \"LineDouble\", };", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "String[]", "name": "names = { \"PointFloat\", \"BoxFloat\", \"CircleFloat\", \"LineFloat\", \"PointDouble\", \"BoxDouble\", \"CircleDouble\", \"LineDouble\", }", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "  private GeometryType_() { }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "", "classes": []}, "name": "GeometryType_", "params": [], "body": "                          { }", "signature": "private GeometryType_()"}, {"syntax_pass": true, "original_string": "  public static String name(int e) { return names[e]; }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "String", "classes": []}, "name": "name", "params": [{"name": "e", "type": "int"}], "body": "                                   { return names[e]; }", "signature": "public static String name(int e)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/com/github/davidmoten/rtree/fbs/generated/CircleFloat_.java", "original_string": "// automatically generated by the FlatBuffers compiler, do not modify\n\npackage com.github.davidmoten.rtree.fbs.generated;\n\nimport java.nio.*;\nimport java.lang.*;\nimport java.util.*;\nimport com.google.flatbuffers.*;\n\n@SuppressWarnings(\"unused\")\npublic final class CircleFloat_ extends Struct {\n  public void __init(int _i, ByteBuffer _bb) { __reset(_i, _bb); }\n  public CircleFloat_ __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }\n\n  public float x() { return bb.getFloat(bb_pos + 0); }\n  public float y() { return bb.getFloat(bb_pos + 4); }\n  public float radius() { return bb.getFloat(bb_pos + 8); }\n\n  public static int createCircleFloat_(FlatBufferBuilder builder, float x, float y, float radius) {\n    builder.prep(4, 12);\n    builder.putFloat(radius);\n    builder.putFloat(y);\n    builder.putFloat(x);\n    return builder.offset();\n  }\n\n  public static final class Vector extends BaseVector {\n    public Vector __assign(int _vector, int _element_size, ByteBuffer _bb) { __reset(_vector, _element_size, _bb); return this; }\n\n    public CircleFloat_ get(int j) { return get(new CircleFloat_(), j); }\n    public CircleFloat_ get(CircleFloat_ obj, int j) {  return obj.__assign(__element(j), bb); }\n  }\n}\n\n", "file_hash": "4c4da49ba0b5a3b7b89e895f51f3c34ef6bda064d1723e2732ff11522a41ea07", "file_docstring": " automatically generated by the FlatBuffers compiler, do not modify", "contexts": ["package com.github.davidmoten.rtree.fbs.generated;", "import java.nio.*;", "import java.lang.*;", "import java.util.*;", "import com.google.flatbuffers.*;"], "methods": [], "classes": [{"original_string": "@SuppressWarnings(\"unused\")\npublic final class CircleFloat_ extends Struct {\n  public void __init(int _i, ByteBuffer _bb) { __reset(_i, _bb); }\n  public CircleFloat_ __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }\n\n  public float x() { return bb.getFloat(bb_pos + 0); }\n  public float y() { return bb.getFloat(bb_pos + 4); }\n  public float radius() { return bb.getFloat(bb_pos + 8); }\n\n  public static int createCircleFloat_(FlatBufferBuilder builder, float x, float y, float radius) {\n    builder.prep(4, 12);\n    builder.putFloat(radius);\n    builder.putFloat(y);\n    builder.putFloat(x);\n    return builder.offset();\n  }\n\n  public static final class Vector extends BaseVector {\n    public Vector __assign(int _vector, int _element_size, ByteBuffer _bb) { __reset(_vector, _element_size, _bb); return this; }\n\n    public CircleFloat_ get(int j) { return get(new CircleFloat_(), j); }\n    public CircleFloat_ get(CircleFloat_ obj, int j) {  return obj.__assign(__element(j), bb); }\n  }\n}", "definition": "@SuppressWarnings(\"unused\")\npublic final class CircleFloat_ extends Struct", "class_docstring": "", "name": "CircleFloat_", "super_interfaces": [], "superclasses": "Struct", "attributes": {"modifiers": "@SuppressWarnings(\"unused\")\npublic final", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings(\"unused\")", "public", "final"], "comments": [], "fields": [], "classes": [{"original_string": "  public static final class Vector extends BaseVector {\n    public Vector __assign(int _vector, int _element_size, ByteBuffer _bb) { __reset(_vector, _element_size, _bb); return this; }\n\n    public CircleFloat_ get(int j) { return get(new CircleFloat_(), j); }\n    public CircleFloat_ get(CircleFloat_ obj, int j) {  return obj.__assign(__element(j), bb); }\n  }", "definition": "  public static final class Vector extends BaseVector", "class_docstring": "", "name": "Vector", "super_interfaces": [], "superclasses": "BaseVector", "attributes": {"modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    public Vector __assign(int _vector, int _element_size, ByteBuffer _bb) { __reset(_vector, _element_size, _bb); return this; }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Vector", "classes": []}, "name": "__assign", "params": [{"name": "_vector", "type": "int"}, {"name": "_element_size", "type": "int"}, {"name": "_bb", "type": "ByteBuffer"}], "body": "                                                                           { __reset(_vector, _element_size, _bb); return this; }", "signature": "public Vector __assign(int _vector, int _element_size, ByteBuffer _bb)"}, {"syntax_pass": true, "original_string": "    public CircleFloat_ get(int j) { return get(new CircleFloat_(), j); }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "CircleFloat_", "classes": []}, "name": "get", "params": [{"name": "j", "type": "int"}], "body": "                                   { return get(new CircleFloat_(), j); }", "signature": "public CircleFloat_ get(int j)"}, {"syntax_pass": true, "original_string": "    public CircleFloat_ get(CircleFloat_ obj, int j) {  return obj.__assign(__element(j), bb); }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "CircleFloat_", "classes": []}, "name": "get", "params": [{"name": "obj", "type": "CircleFloat_"}, {"name": "j", "type": "int"}], "body": "                                                     {  return obj.__assign(__element(j), bb); }", "signature": "public CircleFloat_ get(CircleFloat_ obj, int j)"}]}]}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "  public void __init(int _i, ByteBuffer _bb) { __reset(_i, _bb); }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "__init", "params": [{"name": "_i", "type": "int"}, {"name": "_bb", "type": "ByteBuffer"}], "body": "                                             { __reset(_i, _bb); }", "signature": "public void __init(int _i, ByteBuffer _bb)"}, {"syntax_pass": true, "original_string": "  public CircleFloat_ __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "CircleFloat_", "classes": []}, "name": "__assign", "params": [{"name": "_i", "type": "int"}, {"name": "_bb", "type": "ByteBuffer"}], "body": "                                                       { __init(_i, _bb); return this; }", "signature": "public CircleFloat_ __assign(int _i, ByteBuffer _bb)"}, {"syntax_pass": true, "original_string": "  public float x() { return bb.getFloat(bb_pos + 0); }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "float", "classes": []}, "name": "x", "params": [], "body": "                   { return bb.getFloat(bb_pos + 0); }", "signature": "public float x()"}, {"syntax_pass": true, "original_string": "  public float y() { return bb.getFloat(bb_pos + 4); }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "float", "classes": []}, "name": "y", "params": [], "body": "                   { return bb.getFloat(bb_pos + 4); }", "signature": "public float y()"}, {"syntax_pass": true, "original_string": "  public float radius() { return bb.getFloat(bb_pos + 8); }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "float", "classes": []}, "name": "radius", "params": [], "body": "                        { return bb.getFloat(bb_pos + 8); }", "signature": "public float radius()"}, {"syntax_pass": true, "original_string": "  public static int createCircleFloat_(FlatBufferBuilder builder, float x, float y, float radius) {\n    builder.prep(4, 12);\n    builder.putFloat(radius);\n    builder.putFloat(y);\n    builder.putFloat(x);\n    return builder.offset();\n  }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "int", "classes": []}, "name": "createCircleFloat_", "params": [{"name": "builder", "type": "FlatBufferBuilder"}, {"name": "x", "type": "float"}, {"name": "y", "type": "float"}, {"name": "radius", "type": "float"}], "body": "                                                                                                  {\n    builder.prep(4, 12);\n    builder.putFloat(radius);\n    builder.putFloat(y);\n    builder.putFloat(x);\n    return builder.offset();\n  }", "signature": "public static int createCircleFloat_(FlatBufferBuilder builder, float x, float y, float radius)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/com/github/davidmoten/rtree/fbs/generated/Node_.java", "original_string": "// automatically generated by the FlatBuffers compiler, do not modify\n\npackage com.github.davidmoten.rtree.fbs.generated;\n\nimport java.nio.*;\nimport java.lang.*;\nimport java.util.*;\nimport com.google.flatbuffers.*;\n\n@SuppressWarnings(\"unused\")\npublic final class Node_ extends Table {\n  public static void ValidateVersion() { Constants.FLATBUFFERS_2_0_8(); }\n  public static Node_ getRootAsNode_(ByteBuffer _bb) { return getRootAsNode_(_bb, new Node_()); }\n  public static Node_ getRootAsNode_(ByteBuffer _bb, Node_ obj) { _bb.order(ByteOrder.LITTLE_ENDIAN); return (obj.__assign(_bb.getInt(_bb.position()) + _bb.position(), _bb)); }\n  public void __init(int _i, ByteBuffer _bb) { __reset(_i, _bb); }\n  public Node_ __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }\n\n  public com.github.davidmoten.rtree.fbs.generated.Bounds_ mbb() { return mbb(new com.github.davidmoten.rtree.fbs.generated.Bounds_()); }\n  public com.github.davidmoten.rtree.fbs.generated.Bounds_ mbb(com.github.davidmoten.rtree.fbs.generated.Bounds_ obj) { int o = __offset(4); return o != 0 ? obj.__assign(__indirect(o + bb_pos), bb) : null; }\n  public com.github.davidmoten.rtree.fbs.generated.Node_ children(int j) { return children(new com.github.davidmoten.rtree.fbs.generated.Node_(), j); }\n  public com.github.davidmoten.rtree.fbs.generated.Node_ children(com.github.davidmoten.rtree.fbs.generated.Node_ obj, int j) { int o = __offset(6); return o != 0 ? obj.__assign(__indirect(__vector(o) + j * 4), bb) : null; }\n  public int childrenLength() { int o = __offset(6); return o != 0 ? __vector_len(o) : 0; }\n  public com.github.davidmoten.rtree.fbs.generated.Node_.Vector childrenVector() { return childrenVector(new com.github.davidmoten.rtree.fbs.generated.Node_.Vector()); }\n  public com.github.davidmoten.rtree.fbs.generated.Node_.Vector childrenVector(com.github.davidmoten.rtree.fbs.generated.Node_.Vector obj) { int o = __offset(6); return o != 0 ? obj.__assign(__vector(o), 4, bb) : null; }\n  public com.github.davidmoten.rtree.fbs.generated.Entry_ entries(int j) { return entries(new com.github.davidmoten.rtree.fbs.generated.Entry_(), j); }\n  public com.github.davidmoten.rtree.fbs.generated.Entry_ entries(com.github.davidmoten.rtree.fbs.generated.Entry_ obj, int j) { int o = __offset(8); return o != 0 ? obj.__assign(__indirect(__vector(o) + j * 4), bb) : null; }\n  public int entriesLength() { int o = __offset(8); return o != 0 ? __vector_len(o) : 0; }\n  public com.github.davidmoten.rtree.fbs.generated.Entry_.Vector entriesVector() { return entriesVector(new com.github.davidmoten.rtree.fbs.generated.Entry_.Vector()); }\n  public com.github.davidmoten.rtree.fbs.generated.Entry_.Vector entriesVector(com.github.davidmoten.rtree.fbs.generated.Entry_.Vector obj) { int o = __offset(8); return o != 0 ? obj.__assign(__vector(o), 4, bb) : null; }\n\n  public static int createNode_(FlatBufferBuilder builder,\n      int mbbOffset,\n      int childrenOffset,\n      int entriesOffset) {\n    builder.startTable(3);\n    Node_.addEntries(builder, entriesOffset);\n    Node_.addChildren(builder, childrenOffset);\n    Node_.addMbb(builder, mbbOffset);\n    return Node_.endNode_(builder);\n  }\n\n  public static void startNode_(FlatBufferBuilder builder) { builder.startTable(3); }\n  public static void addMbb(FlatBufferBuilder builder, int mbbOffset) { builder.addOffset(0, mbbOffset, 0); }\n  public static void addChildren(FlatBufferBuilder builder, int childrenOffset) { builder.addOffset(1, childrenOffset, 0); }\n  public static int createChildrenVector(FlatBufferBuilder builder, int[] data) { builder.startVector(4, data.length, 4); for (int i = data.length - 1; i >= 0; i--) builder.addOffset(data[i]); return builder.endVector(); }\n  public static void startChildrenVector(FlatBufferBuilder builder, int numElems) { builder.startVector(4, numElems, 4); }\n  public static void addEntries(FlatBufferBuilder builder, int entriesOffset) { builder.addOffset(2, entriesOffset, 0); }\n  public static int createEntriesVector(FlatBufferBuilder builder, int[] data) { builder.startVector(4, data.length, 4); for (int i = data.length - 1; i >= 0; i--) builder.addOffset(data[i]); return builder.endVector(); }\n  public static void startEntriesVector(FlatBufferBuilder builder, int numElems) { builder.startVector(4, numElems, 4); }\n  public static int endNode_(FlatBufferBuilder builder) {\n    int o = builder.endTable();\n    return o;\n  }\n\n  public static final class Vector extends BaseVector {\n    public Vector __assign(int _vector, int _element_size, ByteBuffer _bb) { __reset(_vector, _element_size, _bb); return this; }\n\n    public Node_ get(int j) { return get(new Node_(), j); }\n    public Node_ get(Node_ obj, int j) {  return obj.__assign(__indirect(__element(j), bb), bb); }\n  }\n}\n\n", "file_hash": "d45f3b5e63e1f762655764d72828bf0d96aa8e7bcb84e50ca1bb4bd8bff3a56c", "file_docstring": " automatically generated by the FlatBuffers compiler, do not modify", "contexts": ["package com.github.davidmoten.rtree.fbs.generated;", "import java.nio.*;", "import java.lang.*;", "import java.util.*;", "import com.google.flatbuffers.*;"], "methods": [], "classes": [{"original_string": "@SuppressWarnings(\"unused\")\npublic final class Node_ extends Table {\n  public static void ValidateVersion() { Constants.FLATBUFFERS_2_0_8(); }\n  public static Node_ getRootAsNode_(ByteBuffer _bb) { return getRootAsNode_(_bb, new Node_()); }\n  public static Node_ getRootAsNode_(ByteBuffer _bb, Node_ obj) { _bb.order(ByteOrder.LITTLE_ENDIAN); return (obj.__assign(_bb.getInt(_bb.position()) + _bb.position(), _bb)); }\n  public void __init(int _i, ByteBuffer _bb) { __reset(_i, _bb); }\n  public Node_ __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }\n\n  public com.github.davidmoten.rtree.fbs.generated.Bounds_ mbb() { return mbb(new com.github.davidmoten.rtree.fbs.generated.Bounds_()); }\n  public com.github.davidmoten.rtree.fbs.generated.Bounds_ mbb(com.github.davidmoten.rtree.fbs.generated.Bounds_ obj) { int o = __offset(4); return o != 0 ? obj.__assign(__indirect(o + bb_pos), bb) : null; }\n  public com.github.davidmoten.rtree.fbs.generated.Node_ children(int j) { return children(new com.github.davidmoten.rtree.fbs.generated.Node_(), j); }\n  public com.github.davidmoten.rtree.fbs.generated.Node_ children(com.github.davidmoten.rtree.fbs.generated.Node_ obj, int j) { int o = __offset(6); return o != 0 ? obj.__assign(__indirect(__vector(o) + j * 4), bb) : null; }\n  public int childrenLength() { int o = __offset(6); return o != 0 ? __vector_len(o) : 0; }\n  public com.github.davidmoten.rtree.fbs.generated.Node_.Vector childrenVector() { return childrenVector(new com.github.davidmoten.rtree.fbs.generated.Node_.Vector()); }\n  public com.github.davidmoten.rtree.fbs.generated.Node_.Vector childrenVector(com.github.davidmoten.rtree.fbs.generated.Node_.Vector obj) { int o = __offset(6); return o != 0 ? obj.__assign(__vector(o), 4, bb) : null; }\n  public com.github.davidmoten.rtree.fbs.generated.Entry_ entries(int j) { return entries(new com.github.davidmoten.rtree.fbs.generated.Entry_(), j); }\n  public com.github.davidmoten.rtree.fbs.generated.Entry_ entries(com.github.davidmoten.rtree.fbs.generated.Entry_ obj, int j) { int o = __offset(8); return o != 0 ? obj.__assign(__indirect(__vector(o) + j * 4), bb) : null; }\n  public int entriesLength() { int o = __offset(8); return o != 0 ? __vector_len(o) : 0; }\n  public com.github.davidmoten.rtree.fbs.generated.Entry_.Vector entriesVector() { return entriesVector(new com.github.davidmoten.rtree.fbs.generated.Entry_.Vector()); }\n  public com.github.davidmoten.rtree.fbs.generated.Entry_.Vector entriesVector(com.github.davidmoten.rtree.fbs.generated.Entry_.Vector obj) { int o = __offset(8); return o != 0 ? obj.__assign(__vector(o), 4, bb) : null; }\n\n  public static int createNode_(FlatBufferBuilder builder,\n      int mbbOffset,\n      int childrenOffset,\n      int entriesOffset) {\n    builder.startTable(3);\n    Node_.addEntries(builder, entriesOffset);\n    Node_.addChildren(builder, childrenOffset);\n    Node_.addMbb(builder, mbbOffset);\n    return Node_.endNode_(builder);\n  }\n\n  public static void startNode_(FlatBufferBuilder builder) { builder.startTable(3); }\n  public static void addMbb(FlatBufferBuilder builder, int mbbOffset) { builder.addOffset(0, mbbOffset, 0); }\n  public static void addChildren(FlatBufferBuilder builder, int childrenOffset) { builder.addOffset(1, childrenOffset, 0); }\n  public static int createChildrenVector(FlatBufferBuilder builder, int[] data) { builder.startVector(4, data.length, 4); for (int i = data.length - 1; i >= 0; i--) builder.addOffset(data[i]); return builder.endVector(); }\n  public static void startChildrenVector(FlatBufferBuilder builder, int numElems) { builder.startVector(4, numElems, 4); }\n  public static void addEntries(FlatBufferBuilder builder, int entriesOffset) { builder.addOffset(2, entriesOffset, 0); }\n  public static int createEntriesVector(FlatBufferBuilder builder, int[] data) { builder.startVector(4, data.length, 4); for (int i = data.length - 1; i >= 0; i--) builder.addOffset(data[i]); return builder.endVector(); }\n  public static void startEntriesVector(FlatBufferBuilder builder, int numElems) { builder.startVector(4, numElems, 4); }\n  public static int endNode_(FlatBufferBuilder builder) {\n    int o = builder.endTable();\n    return o;\n  }\n\n  public static final class Vector extends BaseVector {\n    public Vector __assign(int _vector, int _element_size, ByteBuffer _bb) { __reset(_vector, _element_size, _bb); return this; }\n\n    public Node_ get(int j) { return get(new Node_(), j); }\n    public Node_ get(Node_ obj, int j) {  return obj.__assign(__indirect(__element(j), bb), bb); }\n  }\n}", "definition": "@SuppressWarnings(\"unused\")\npublic final class Node_ extends Table", "class_docstring": "", "name": "Node_", "super_interfaces": [], "superclasses": "Table", "attributes": {"modifiers": "@SuppressWarnings(\"unused\")\npublic final", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings(\"unused\")", "public", "final"], "comments": [], "fields": [], "classes": [{"original_string": "  public static final class Vector extends BaseVector {\n    public Vector __assign(int _vector, int _element_size, ByteBuffer _bb) { __reset(_vector, _element_size, _bb); return this; }\n\n    public Node_ get(int j) { return get(new Node_(), j); }\n    public Node_ get(Node_ obj, int j) {  return obj.__assign(__indirect(__element(j), bb), bb); }\n  }", "definition": "  public static final class Vector extends BaseVector", "class_docstring": "", "name": "Vector", "super_interfaces": [], "superclasses": "BaseVector", "attributes": {"modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    public Vector __assign(int _vector, int _element_size, ByteBuffer _bb) { __reset(_vector, _element_size, _bb); return this; }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Vector", "classes": []}, "name": "__assign", "params": [{"name": "_vector", "type": "int"}, {"name": "_element_size", "type": "int"}, {"name": "_bb", "type": "ByteBuffer"}], "body": "                                                                           { __reset(_vector, _element_size, _bb); return this; }", "signature": "public Vector __assign(int _vector, int _element_size, ByteBuffer _bb)"}, {"syntax_pass": true, "original_string": "    public Node_ get(int j) { return get(new Node_(), j); }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Node_", "classes": []}, "name": "get", "params": [{"name": "j", "type": "int"}], "body": "                            { return get(new Node_(), j); }", "signature": "public Node_ get(int j)"}, {"syntax_pass": true, "original_string": "    public Node_ get(Node_ obj, int j) {  return obj.__assign(__indirect(__element(j), bb), bb); }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Node_", "classes": []}, "name": "get", "params": [{"name": "obj", "type": "Node_"}, {"name": "j", "type": "int"}], "body": "                                       {  return obj.__assign(__indirect(__element(j), bb), bb); }", "signature": "public Node_ get(Node_ obj, int j)"}]}]}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "  public static void ValidateVersion() { Constants.FLATBUFFERS_2_0_8(); }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "void", "classes": []}, "name": "ValidateVersion", "params": [], "body": "                                       { Constants.FLATBUFFERS_2_0_8(); }", "signature": "public static void ValidateVersion()"}, {"syntax_pass": true, "original_string": "  public static Node_ getRootAsNode_(ByteBuffer _bb) { return getRootAsNode_(_bb, new Node_()); }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Node_", "classes": []}, "name": "getRootAsNode_", "params": [{"name": "_bb", "type": "ByteBuffer"}], "body": "                                                     { return getRootAsNode_(_bb, new Node_()); }", "signature": "public static Node_ getRootAsNode_(ByteBuffer _bb)"}, {"syntax_pass": true, "original_string": "  public static Node_ getRootAsNode_(ByteBuffer _bb, Node_ obj) { _bb.order(ByteOrder.LITTLE_ENDIAN); return (obj.__assign(_bb.getInt(_bb.position()) + _bb.position(), _bb)); }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Node_", "classes": []}, "name": "getRootAsNode_", "params": [{"name": "_bb", "type": "ByteBuffer"}, {"name": "obj", "type": "Node_"}], "body": "                                                                { _bb.order(ByteOrder.LITTLE_ENDIAN); return (obj.__assign(_bb.getInt(_bb.position()) + _bb.position(), _bb)); }", "signature": "public static Node_ getRootAsNode_(ByteBuffer _bb, Node_ obj)"}, {"syntax_pass": true, "original_string": "  public void __init(int _i, ByteBuffer _bb) { __reset(_i, _bb); }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "__init", "params": [{"name": "_i", "type": "int"}, {"name": "_bb", "type": "ByteBuffer"}], "body": "                                             { __reset(_i, _bb); }", "signature": "public void __init(int _i, ByteBuffer _bb)"}, {"syntax_pass": true, "original_string": "  public Node_ __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Node_", "classes": []}, "name": "__assign", "params": [{"name": "_i", "type": "int"}, {"name": "_bb", "type": "ByteBuffer"}], "body": "                                                { __init(_i, _bb); return this; }", "signature": "public Node_ __assign(int _i, ByteBuffer _bb)"}, {"syntax_pass": true, "original_string": "  public com.github.davidmoten.rtree.fbs.generated.Bounds_ mbb() { return mbb(new com.github.davidmoten.rtree.fbs.generated.Bounds_()); }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "com.github.davidmoten.rtree.fbs.generated.Bounds_", "classes": []}, "name": "mbb", "params": [], "body": "                                                                 { return mbb(new com.github.davidmoten.rtree.fbs.generated.Bounds_()); }", "signature": "public com.github.davidmoten.rtree.fbs.generated.Bounds_ mbb()"}, {"syntax_pass": true, "original_string": "  public com.github.davidmoten.rtree.fbs.generated.Bounds_ mbb(com.github.davidmoten.rtree.fbs.generated.Bounds_ obj) { int o = __offset(4); return o != 0 ? obj.__assign(__indirect(o + bb_pos), bb) : null; }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "com.github.davidmoten.rtree.fbs.generated.Bounds_", "classes": []}, "name": "mbb", "params": [{"name": "obj", "type": "com.github.davidmoten.rtree.fbs.generated.Bounds_"}], "body": "                                                                                                                      { int o = __offset(4); return o != 0 ? obj.__assign(__indirect(o + bb_pos), bb) : null; }", "signature": "public com.github.davidmoten.rtree.fbs.generated.Bounds_ mbb(com.github.davidmoten.rtree.fbs.generated.Bounds_ obj)"}, {"syntax_pass": true, "original_string": "  public com.github.davidmoten.rtree.fbs.generated.Node_ children(int j) { return children(new com.github.davidmoten.rtree.fbs.generated.Node_(), j); }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "com.github.davidmoten.rtree.fbs.generated.Node_", "classes": []}, "name": "children", "params": [{"name": "j", "type": "int"}], "body": "                                                                         { return children(new com.github.davidmoten.rtree.fbs.generated.Node_(), j); }", "signature": "public com.github.davidmoten.rtree.fbs.generated.Node_ children(int j)"}, {"syntax_pass": true, "original_string": "  public com.github.davidmoten.rtree.fbs.generated.Node_ children(com.github.davidmoten.rtree.fbs.generated.Node_ obj, int j) { int o = __offset(6); return o != 0 ? obj.__assign(__indirect(__vector(o) + j * 4), bb) : null; }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "com.github.davidmoten.rtree.fbs.generated.Node_", "classes": []}, "name": "children", "params": [{"name": "obj", "type": "com.github.davidmoten.rtree.fbs.generated.Node_"}, {"name": "j", "type": "int"}], "body": "                                                                                                                              { int o = __offset(6); return o != 0 ? obj.__assign(__indirect(__vector(o) + j * 4), bb) : null; }", "signature": "public com.github.davidmoten.rtree.fbs.generated.Node_ children(com.github.davidmoten.rtree.fbs.generated.Node_ obj, int j)"}, {"syntax_pass": true, "original_string": "  public int childrenLength() { int o = __offset(6); return o != 0 ? __vector_len(o) : 0; }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "childrenLength", "params": [], "body": "                              { int o = __offset(6); return o != 0 ? __vector_len(o) : 0; }", "signature": "public int childrenLength()"}, {"syntax_pass": true, "original_string": "  public com.github.davidmoten.rtree.fbs.generated.Node_.Vector childrenVector() { return childrenVector(new com.github.davidmoten.rtree.fbs.generated.Node_.Vector()); }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "com.github.davidmoten.rtree.fbs.generated.Node_.Vector", "classes": []}, "name": "childrenVector", "params": [], "body": "                                                                                 { return childrenVector(new com.github.davidmoten.rtree.fbs.generated.Node_.Vector()); }", "signature": "public com.github.davidmoten.rtree.fbs.generated.Node_.Vector childrenVector()"}, {"syntax_pass": true, "original_string": "  public com.github.davidmoten.rtree.fbs.generated.Node_.Vector childrenVector(com.github.davidmoten.rtree.fbs.generated.Node_.Vector obj) { int o = __offset(6); return o != 0 ? obj.__assign(__vector(o), 4, bb) : null; }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "com.github.davidmoten.rtree.fbs.generated.Node_.Vector", "classes": []}, "name": "childrenVector", "params": [{"name": "obj", "type": "com.github.davidmoten.rtree.fbs.generated.Node_.Vector"}], "body": "                                                                                                                                           { int o = __offset(6); return o != 0 ? obj.__assign(__vector(o), 4, bb) : null; }", "signature": "public com.github.davidmoten.rtree.fbs.generated.Node_.Vector childrenVector(com.github.davidmoten.rtree.fbs.generated.Node_.Vector obj)"}, {"syntax_pass": true, "original_string": "  public com.github.davidmoten.rtree.fbs.generated.Entry_ entries(int j) { return entries(new com.github.davidmoten.rtree.fbs.generated.Entry_(), j); }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "com.github.davidmoten.rtree.fbs.generated.Entry_", "classes": []}, "name": "entries", "params": [{"name": "j", "type": "int"}], "body": "                                                                         { return entries(new com.github.davidmoten.rtree.fbs.generated.Entry_(), j); }", "signature": "public com.github.davidmoten.rtree.fbs.generated.Entry_ entries(int j)"}, {"syntax_pass": true, "original_string": "  public com.github.davidmoten.rtree.fbs.generated.Entry_ entries(com.github.davidmoten.rtree.fbs.generated.Entry_ obj, int j) { int o = __offset(8); return o != 0 ? obj.__assign(__indirect(__vector(o) + j * 4), bb) : null; }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "com.github.davidmoten.rtree.fbs.generated.Entry_", "classes": []}, "name": "entries", "params": [{"name": "obj", "type": "com.github.davidmoten.rtree.fbs.generated.Entry_"}, {"name": "j", "type": "int"}], "body": "                                                                                                                               { int o = __offset(8); return o != 0 ? obj.__assign(__indirect(__vector(o) + j * 4), bb) : null; }", "signature": "public com.github.davidmoten.rtree.fbs.generated.Entry_ entries(com.github.davidmoten.rtree.fbs.generated.Entry_ obj, int j)"}, {"syntax_pass": true, "original_string": "  public int entriesLength() { int o = __offset(8); return o != 0 ? __vector_len(o) : 0; }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "entriesLength", "params": [], "body": "                             { int o = __offset(8); return o != 0 ? __vector_len(o) : 0; }", "signature": "public int entriesLength()"}, {"syntax_pass": true, "original_string": "  public com.github.davidmoten.rtree.fbs.generated.Entry_.Vector entriesVector() { return entriesVector(new com.github.davidmoten.rtree.fbs.generated.Entry_.Vector()); }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "com.github.davidmoten.rtree.fbs.generated.Entry_.Vector", "classes": []}, "name": "entriesVector", "params": [], "body": "                                                                                 { return entriesVector(new com.github.davidmoten.rtree.fbs.generated.Entry_.Vector()); }", "signature": "public com.github.davidmoten.rtree.fbs.generated.Entry_.Vector entriesVector()"}, {"syntax_pass": true, "original_string": "  public com.github.davidmoten.rtree.fbs.generated.Entry_.Vector entriesVector(com.github.davidmoten.rtree.fbs.generated.Entry_.Vector obj) { int o = __offset(8); return o != 0 ? obj.__assign(__vector(o), 4, bb) : null; }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "com.github.davidmoten.rtree.fbs.generated.Entry_.Vector", "classes": []}, "name": "entriesVector", "params": [{"name": "obj", "type": "com.github.davidmoten.rtree.fbs.generated.Entry_.Vector"}], "body": "                                                                                                                                            { int o = __offset(8); return o != 0 ? obj.__assign(__vector(o), 4, bb) : null; }", "signature": "public com.github.davidmoten.rtree.fbs.generated.Entry_.Vector entriesVector(com.github.davidmoten.rtree.fbs.generated.Entry_.Vector obj)"}, {"syntax_pass": true, "original_string": "  public static int createNode_(FlatBufferBuilder builder,\n      int mbbOffset,\n      int childrenOffset,\n      int entriesOffset) {\n    builder.startTable(3);\n    Node_.addEntries(builder, entriesOffset);\n    Node_.addChildren(builder, childrenOffset);\n    Node_.addMbb(builder, mbbOffset);\n    return Node_.endNode_(builder);\n  }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "int", "classes": []}, "name": "createNode_", "params": [{"name": "builder", "type": "FlatBufferBuilder"}, {"name": "mbbOffset", "type": "int"}, {"name": "childrenOffset", "type": "int"}, {"name": "entriesOffset", "type": "int"}], "body": "                         {\n    builder.startTable(3);\n    Node_.addEntries(builder, entriesOffset);\n    Node_.addChildren(builder, childrenOffset);\n    Node_.addMbb(builder, mbbOffset);\n    return Node_.endNode_(builder);\n  }", "signature": "public static int createNode_(FlatBufferBuilder builder,\n      int mbbOffset,\n      int childrenOffset,\n      int entriesOffset)"}, {"syntax_pass": true, "original_string": "  public static void startNode_(FlatBufferBuilder builder) { builder.startTable(3); }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "void", "classes": []}, "name": "startNode_", "params": [{"name": "builder", "type": "FlatBufferBuilder"}], "body": "                                                           { builder.startTable(3); }", "signature": "public static void startNode_(FlatBufferBuilder builder)"}, {"syntax_pass": true, "original_string": "  public static void addMbb(FlatBufferBuilder builder, int mbbOffset) { builder.addOffset(0, mbbOffset, 0); }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "void", "classes": []}, "name": "addMbb", "params": [{"name": "builder", "type": "FlatBufferBuilder"}, {"name": "mbbOffset", "type": "int"}], "body": "                                                                      { builder.addOffset(0, mbbOffset, 0); }", "signature": "public static void addMbb(FlatBufferBuilder builder, int mbbOffset)"}, {"syntax_pass": true, "original_string": "  public static void addChildren(FlatBufferBuilder builder, int childrenOffset) { builder.addOffset(1, childrenOffset, 0); }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "void", "classes": []}, "name": "addChildren", "params": [{"name": "builder", "type": "FlatBufferBuilder"}, {"name": "childrenOffset", "type": "int"}], "body": "                                                                                { builder.addOffset(1, childrenOffset, 0); }", "signature": "public static void addChildren(FlatBufferBuilder builder, int childrenOffset)"}, {"syntax_pass": true, "original_string": "  public static int createChildrenVector(FlatBufferBuilder builder, int[] data) { builder.startVector(4, data.length, 4); for (int i = data.length - 1; i >= 0; i--) builder.addOffset(data[i]); return builder.endVector(); }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "int", "classes": []}, "name": "createChildrenVector", "params": [{"name": "builder", "type": "FlatBufferBuilder"}, {"name": "data", "type": "int[]"}], "body": "                                                                                { builder.startVector(4, data.length, 4); for (int i = data.length - 1; i >= 0; i--) builder.addOffset(data[i]); return builder.endVector(); }", "signature": "public static int createChildrenVector(FlatBufferBuilder builder, int[] data)"}, {"syntax_pass": true, "original_string": "  public static void startChildrenVector(FlatBufferBuilder builder, int numElems) { builder.startVector(4, numElems, 4); }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "void", "classes": []}, "name": "startChildrenVector", "params": [{"name": "builder", "type": "FlatBufferBuilder"}, {"name": "numElems", "type": "int"}], "body": "                                                                                  { builder.startVector(4, numElems, 4); }", "signature": "public static void startChildrenVector(FlatBufferBuilder builder, int numElems)"}, {"syntax_pass": true, "original_string": "  public static void addEntries(FlatBufferBuilder builder, int entriesOffset) { builder.addOffset(2, entriesOffset, 0); }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "void", "classes": []}, "name": "addEntries", "params": [{"name": "builder", "type": "FlatBufferBuilder"}, {"name": "entriesOffset", "type": "int"}], "body": "                                                                              { builder.addOffset(2, entriesOffset, 0); }", "signature": "public static void addEntries(FlatBufferBuilder builder, int entriesOffset)"}, {"syntax_pass": true, "original_string": "  public static int createEntriesVector(FlatBufferBuilder builder, int[] data) { builder.startVector(4, data.length, 4); for (int i = data.length - 1; i >= 0; i--) builder.addOffset(data[i]); return builder.endVector(); }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "int", "classes": []}, "name": "createEntriesVector", "params": [{"name": "builder", "type": "FlatBufferBuilder"}, {"name": "data", "type": "int[]"}], "body": "                                                                               { builder.startVector(4, data.length, 4); for (int i = data.length - 1; i >= 0; i--) builder.addOffset(data[i]); return builder.endVector(); }", "signature": "public static int createEntriesVector(FlatBufferBuilder builder, int[] data)"}, {"syntax_pass": true, "original_string": "  public static void startEntriesVector(FlatBufferBuilder builder, int numElems) { builder.startVector(4, numElems, 4); }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "void", "classes": []}, "name": "startEntriesVector", "params": [{"name": "builder", "type": "FlatBufferBuilder"}, {"name": "numElems", "type": "int"}], "body": "                                                                                 { builder.startVector(4, numElems, 4); }", "signature": "public static void startEntriesVector(FlatBufferBuilder builder, int numElems)"}, {"syntax_pass": true, "original_string": "  public static int endNode_(FlatBufferBuilder builder) {\n    int o = builder.endTable();\n    return o;\n  }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "int", "classes": []}, "name": "endNode_", "params": [{"name": "builder", "type": "FlatBufferBuilder"}], "body": "                                                        {\n    int o = builder.endTable();\n    return o;\n  }", "signature": "public static int endNode_(FlatBufferBuilder builder)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/com/github/davidmoten/rtree/fbs/generated/LineDouble_.java", "original_string": "// automatically generated by the FlatBuffers compiler, do not modify\n\npackage com.github.davidmoten.rtree.fbs.generated;\n\nimport java.nio.*;\nimport java.lang.*;\nimport java.util.*;\nimport com.google.flatbuffers.*;\n\n@SuppressWarnings(\"unused\")\npublic final class LineDouble_ extends Struct {\n  public void __init(int _i, ByteBuffer _bb) { __reset(_i, _bb); }\n  public LineDouble_ __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }\n\n  public double minX() { return bb.getDouble(bb_pos + 0); }\n  public double minY() { return bb.getDouble(bb_pos + 8); }\n  public double maxX() { return bb.getDouble(bb_pos + 16); }\n  public double maxY() { return bb.getDouble(bb_pos + 24); }\n\n  public static int createLineDouble_(FlatBufferBuilder builder, double minX, double minY, double maxX, double maxY) {\n    builder.prep(8, 32);\n    builder.putDouble(maxY);\n    builder.putDouble(maxX);\n    builder.putDouble(minY);\n    builder.putDouble(minX);\n    return builder.offset();\n  }\n\n  public static final class Vector extends BaseVector {\n    public Vector __assign(int _vector, int _element_size, ByteBuffer _bb) { __reset(_vector, _element_size, _bb); return this; }\n\n    public LineDouble_ get(int j) { return get(new LineDouble_(), j); }\n    public LineDouble_ get(LineDouble_ obj, int j) {  return obj.__assign(__element(j), bb); }\n  }\n}\n\n", "file_hash": "ce5c195b7bc6c284e78056221f8262f9b3ad075276bdf43af2364acc47532d3f", "file_docstring": " automatically generated by the FlatBuffers compiler, do not modify", "contexts": ["package com.github.davidmoten.rtree.fbs.generated;", "import java.nio.*;", "import java.lang.*;", "import java.util.*;", "import com.google.flatbuffers.*;"], "methods": [], "classes": [{"original_string": "@SuppressWarnings(\"unused\")\npublic final class LineDouble_ extends Struct {\n  public void __init(int _i, ByteBuffer _bb) { __reset(_i, _bb); }\n  public LineDouble_ __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }\n\n  public double minX() { return bb.getDouble(bb_pos + 0); }\n  public double minY() { return bb.getDouble(bb_pos + 8); }\n  public double maxX() { return bb.getDouble(bb_pos + 16); }\n  public double maxY() { return bb.getDouble(bb_pos + 24); }\n\n  public static int createLineDouble_(FlatBufferBuilder builder, double minX, double minY, double maxX, double maxY) {\n    builder.prep(8, 32);\n    builder.putDouble(maxY);\n    builder.putDouble(maxX);\n    builder.putDouble(minY);\n    builder.putDouble(minX);\n    return builder.offset();\n  }\n\n  public static final class Vector extends BaseVector {\n    public Vector __assign(int _vector, int _element_size, ByteBuffer _bb) { __reset(_vector, _element_size, _bb); return this; }\n\n    public LineDouble_ get(int j) { return get(new LineDouble_(), j); }\n    public LineDouble_ get(LineDouble_ obj, int j) {  return obj.__assign(__element(j), bb); }\n  }\n}", "definition": "@SuppressWarnings(\"unused\")\npublic final class LineDouble_ extends Struct", "class_docstring": "", "name": "LineDouble_", "super_interfaces": [], "superclasses": "Struct", "attributes": {"modifiers": "@SuppressWarnings(\"unused\")\npublic final", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings(\"unused\")", "public", "final"], "comments": [], "fields": [], "classes": [{"original_string": "  public static final class Vector extends BaseVector {\n    public Vector __assign(int _vector, int _element_size, ByteBuffer _bb) { __reset(_vector, _element_size, _bb); return this; }\n\n    public LineDouble_ get(int j) { return get(new LineDouble_(), j); }\n    public LineDouble_ get(LineDouble_ obj, int j) {  return obj.__assign(__element(j), bb); }\n  }", "definition": "  public static final class Vector extends BaseVector", "class_docstring": "", "name": "Vector", "super_interfaces": [], "superclasses": "BaseVector", "attributes": {"modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    public Vector __assign(int _vector, int _element_size, ByteBuffer _bb) { __reset(_vector, _element_size, _bb); return this; }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Vector", "classes": []}, "name": "__assign", "params": [{"name": "_vector", "type": "int"}, {"name": "_element_size", "type": "int"}, {"name": "_bb", "type": "ByteBuffer"}], "body": "                                                                           { __reset(_vector, _element_size, _bb); return this; }", "signature": "public Vector __assign(int _vector, int _element_size, ByteBuffer _bb)"}, {"syntax_pass": true, "original_string": "    public LineDouble_ get(int j) { return get(new LineDouble_(), j); }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "LineDouble_", "classes": []}, "name": "get", "params": [{"name": "j", "type": "int"}], "body": "                                  { return get(new LineDouble_(), j); }", "signature": "public LineDouble_ get(int j)"}, {"syntax_pass": true, "original_string": "    public LineDouble_ get(LineDouble_ obj, int j) {  return obj.__assign(__element(j), bb); }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "LineDouble_", "classes": []}, "name": "get", "params": [{"name": "obj", "type": "LineDouble_"}, {"name": "j", "type": "int"}], "body": "                                                   {  return obj.__assign(__element(j), bb); }", "signature": "public LineDouble_ get(LineDouble_ obj, int j)"}]}]}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "  public void __init(int _i, ByteBuffer _bb) { __reset(_i, _bb); }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "__init", "params": [{"name": "_i", "type": "int"}, {"name": "_bb", "type": "ByteBuffer"}], "body": "                                             { __reset(_i, _bb); }", "signature": "public void __init(int _i, ByteBuffer _bb)"}, {"syntax_pass": true, "original_string": "  public LineDouble_ __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "LineDouble_", "classes": []}, "name": "__assign", "params": [{"name": "_i", "type": "int"}, {"name": "_bb", "type": "ByteBuffer"}], "body": "                                                      { __init(_i, _bb); return this; }", "signature": "public LineDouble_ __assign(int _i, ByteBuffer _bb)"}, {"syntax_pass": true, "original_string": "  public double minX() { return bb.getDouble(bb_pos + 0); }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "double", "classes": []}, "name": "minX", "params": [], "body": "                       { return bb.getDouble(bb_pos + 0); }", "signature": "public double minX()"}, {"syntax_pass": true, "original_string": "  public double minY() { return bb.getDouble(bb_pos + 8); }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "double", "classes": []}, "name": "minY", "params": [], "body": "                       { return bb.getDouble(bb_pos + 8); }", "signature": "public double minY()"}, {"syntax_pass": true, "original_string": "  public double maxX() { return bb.getDouble(bb_pos + 16); }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "double", "classes": []}, "name": "maxX", "params": [], "body": "                       { return bb.getDouble(bb_pos + 16); }", "signature": "public double maxX()"}, {"syntax_pass": true, "original_string": "  public double maxY() { return bb.getDouble(bb_pos + 24); }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "double", "classes": []}, "name": "maxY", "params": [], "body": "                       { return bb.getDouble(bb_pos + 24); }", "signature": "public double maxY()"}, {"syntax_pass": true, "original_string": "  public static int createLineDouble_(FlatBufferBuilder builder, double minX, double minY, double maxX, double maxY) {\n    builder.prep(8, 32);\n    builder.putDouble(maxY);\n    builder.putDouble(maxX);\n    builder.putDouble(minY);\n    builder.putDouble(minX);\n    return builder.offset();\n  }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "int", "classes": []}, "name": "createLineDouble_", "params": [{"name": "builder", "type": "FlatBufferBuilder"}, {"name": "minX", "type": "double"}, {"name": "minY", "type": "double"}, {"name": "maxX", "type": "double"}, {"name": "maxY", "type": "double"}], "body": "                                                                                                                     {\n    builder.prep(8, 32);\n    builder.putDouble(maxY);\n    builder.putDouble(maxX);\n    builder.putDouble(minY);\n    builder.putDouble(minX);\n    return builder.offset();\n  }", "signature": "public static int createLineDouble_(FlatBufferBuilder builder, double minX, double minY, double maxX, double maxY)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/com/github/davidmoten/rtree/fbs/generated/BoxDouble_.java", "original_string": "// automatically generated by the FlatBuffers compiler, do not modify\n\npackage com.github.davidmoten.rtree.fbs.generated;\n\nimport java.nio.*;\nimport java.lang.*;\nimport java.util.*;\nimport com.google.flatbuffers.*;\n\n@SuppressWarnings(\"unused\")\npublic final class BoxDouble_ extends Struct {\n  public void __init(int _i, ByteBuffer _bb) { __reset(_i, _bb); }\n  public BoxDouble_ __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }\n\n  public double minX() { return bb.getDouble(bb_pos + 0); }\n  public double minY() { return bb.getDouble(bb_pos + 8); }\n  public double maxX() { return bb.getDouble(bb_pos + 16); }\n  public double maxY() { return bb.getDouble(bb_pos + 24); }\n\n  public static int createBoxDouble_(FlatBufferBuilder builder, double minX, double minY, double maxX, double maxY) {\n    builder.prep(8, 32);\n    builder.putDouble(maxY);\n    builder.putDouble(maxX);\n    builder.putDouble(minY);\n    builder.putDouble(minX);\n    return builder.offset();\n  }\n\n  public static final class Vector extends BaseVector {\n    public Vector __assign(int _vector, int _element_size, ByteBuffer _bb) { __reset(_vector, _element_size, _bb); return this; }\n\n    public BoxDouble_ get(int j) { return get(new BoxDouble_(), j); }\n    public BoxDouble_ get(BoxDouble_ obj, int j) {  return obj.__assign(__element(j), bb); }\n  }\n}\n\n", "file_hash": "fd8837e17682adb2b370b32f34c9d69fa7ea8eb39e8e52c1ee506105c8f02320", "file_docstring": " automatically generated by the FlatBuffers compiler, do not modify", "contexts": ["package com.github.davidmoten.rtree.fbs.generated;", "import java.nio.*;", "import java.lang.*;", "import java.util.*;", "import com.google.flatbuffers.*;"], "methods": [], "classes": [{"original_string": "@SuppressWarnings(\"unused\")\npublic final class BoxDouble_ extends Struct {\n  public void __init(int _i, ByteBuffer _bb) { __reset(_i, _bb); }\n  public BoxDouble_ __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }\n\n  public double minX() { return bb.getDouble(bb_pos + 0); }\n  public double minY() { return bb.getDouble(bb_pos + 8); }\n  public double maxX() { return bb.getDouble(bb_pos + 16); }\n  public double maxY() { return bb.getDouble(bb_pos + 24); }\n\n  public static int createBoxDouble_(FlatBufferBuilder builder, double minX, double minY, double maxX, double maxY) {\n    builder.prep(8, 32);\n    builder.putDouble(maxY);\n    builder.putDouble(maxX);\n    builder.putDouble(minY);\n    builder.putDouble(minX);\n    return builder.offset();\n  }\n\n  public static final class Vector extends BaseVector {\n    public Vector __assign(int _vector, int _element_size, ByteBuffer _bb) { __reset(_vector, _element_size, _bb); return this; }\n\n    public BoxDouble_ get(int j) { return get(new BoxDouble_(), j); }\n    public BoxDouble_ get(BoxDouble_ obj, int j) {  return obj.__assign(__element(j), bb); }\n  }\n}", "definition": "@SuppressWarnings(\"unused\")\npublic final class BoxDouble_ extends Struct", "class_docstring": "", "name": "BoxDouble_", "super_interfaces": [], "superclasses": "Struct", "attributes": {"modifiers": "@SuppressWarnings(\"unused\")\npublic final", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings(\"unused\")", "public", "final"], "comments": [], "fields": [], "classes": [{"original_string": "  public static final class Vector extends BaseVector {\n    public Vector __assign(int _vector, int _element_size, ByteBuffer _bb) { __reset(_vector, _element_size, _bb); return this; }\n\n    public BoxDouble_ get(int j) { return get(new BoxDouble_(), j); }\n    public BoxDouble_ get(BoxDouble_ obj, int j) {  return obj.__assign(__element(j), bb); }\n  }", "definition": "  public static final class Vector extends BaseVector", "class_docstring": "", "name": "Vector", "super_interfaces": [], "superclasses": "BaseVector", "attributes": {"modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    public Vector __assign(int _vector, int _element_size, ByteBuffer _bb) { __reset(_vector, _element_size, _bb); return this; }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Vector", "classes": []}, "name": "__assign", "params": [{"name": "_vector", "type": "int"}, {"name": "_element_size", "type": "int"}, {"name": "_bb", "type": "ByteBuffer"}], "body": "                                                                           { __reset(_vector, _element_size, _bb); return this; }", "signature": "public Vector __assign(int _vector, int _element_size, ByteBuffer _bb)"}, {"syntax_pass": true, "original_string": "    public BoxDouble_ get(int j) { return get(new BoxDouble_(), j); }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "BoxDouble_", "classes": []}, "name": "get", "params": [{"name": "j", "type": "int"}], "body": "                                 { return get(new BoxDouble_(), j); }", "signature": "public BoxDouble_ get(int j)"}, {"syntax_pass": true, "original_string": "    public BoxDouble_ get(BoxDouble_ obj, int j) {  return obj.__assign(__element(j), bb); }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "BoxDouble_", "classes": []}, "name": "get", "params": [{"name": "obj", "type": "BoxDouble_"}, {"name": "j", "type": "int"}], "body": "                                                 {  return obj.__assign(__element(j), bb); }", "signature": "public BoxDouble_ get(BoxDouble_ obj, int j)"}]}]}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "  public void __init(int _i, ByteBuffer _bb) { __reset(_i, _bb); }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "__init", "params": [{"name": "_i", "type": "int"}, {"name": "_bb", "type": "ByteBuffer"}], "body": "                                             { __reset(_i, _bb); }", "signature": "public void __init(int _i, ByteBuffer _bb)"}, {"syntax_pass": true, "original_string": "  public BoxDouble_ __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "BoxDouble_", "classes": []}, "name": "__assign", "params": [{"name": "_i", "type": "int"}, {"name": "_bb", "type": "ByteBuffer"}], "body": "                                                     { __init(_i, _bb); return this; }", "signature": "public BoxDouble_ __assign(int _i, ByteBuffer _bb)"}, {"syntax_pass": true, "original_string": "  public double minX() { return bb.getDouble(bb_pos + 0); }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "double", "classes": []}, "name": "minX", "params": [], "body": "                       { return bb.getDouble(bb_pos + 0); }", "signature": "public double minX()"}, {"syntax_pass": true, "original_string": "  public double minY() { return bb.getDouble(bb_pos + 8); }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "double", "classes": []}, "name": "minY", "params": [], "body": "                       { return bb.getDouble(bb_pos + 8); }", "signature": "public double minY()"}, {"syntax_pass": true, "original_string": "  public double maxX() { return bb.getDouble(bb_pos + 16); }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "double", "classes": []}, "name": "maxX", "params": [], "body": "                       { return bb.getDouble(bb_pos + 16); }", "signature": "public double maxX()"}, {"syntax_pass": true, "original_string": "  public double maxY() { return bb.getDouble(bb_pos + 24); }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "double", "classes": []}, "name": "maxY", "params": [], "body": "                       { return bb.getDouble(bb_pos + 24); }", "signature": "public double maxY()"}, {"syntax_pass": true, "original_string": "  public static int createBoxDouble_(FlatBufferBuilder builder, double minX, double minY, double maxX, double maxY) {\n    builder.prep(8, 32);\n    builder.putDouble(maxY);\n    builder.putDouble(maxX);\n    builder.putDouble(minY);\n    builder.putDouble(minX);\n    return builder.offset();\n  }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "int", "classes": []}, "name": "createBoxDouble_", "params": [{"name": "builder", "type": "FlatBufferBuilder"}, {"name": "minX", "type": "double"}, {"name": "minY", "type": "double"}, {"name": "maxX", "type": "double"}, {"name": "maxY", "type": "double"}], "body": "                                                                                                                    {\n    builder.prep(8, 32);\n    builder.putDouble(maxY);\n    builder.putDouble(maxX);\n    builder.putDouble(minY);\n    builder.putDouble(minX);\n    return builder.offset();\n  }", "signature": "public static int createBoxDouble_(FlatBufferBuilder builder, double minX, double minY, double maxX, double maxY)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/com/github/davidmoten/rtree/kryo/SerializerKryo.java", "original_string": "package com.github.davidmoten.rtree.kryo;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.util.Optional;\n\nimport com.esotericsoftware.kryo.Kryo;\nimport com.esotericsoftware.kryo.io.Input;\nimport com.esotericsoftware.kryo.io.Output;\nimport com.github.davidmoten.rtree.Context;\nimport com.github.davidmoten.rtree.Entry;\nimport com.github.davidmoten.rtree.InternalStructure;\nimport com.github.davidmoten.rtree.Leaf;\nimport com.github.davidmoten.rtree.Node;\nimport com.github.davidmoten.rtree.NonLeaf;\nimport com.github.davidmoten.rtree.RTree;\nimport com.github.davidmoten.rtree.SelectorRStar;\nimport com.github.davidmoten.rtree.Serializer;\nimport com.github.davidmoten.rtree.SerializerHelper;\nimport com.github.davidmoten.rtree.SplitterRStar;\nimport com.github.davidmoten.rtree.geometry.Geometry;\nimport com.github.davidmoten.rtree.geometry.Rectangle;\nimport com.github.davidmoten.rtree.internal.FactoryDefault;\n\nimport rx.functions.Func0;\nimport rx.functions.Func1;\n\npublic class SerializerKryo<T, S extends Geometry> implements Serializer<T, S> {\n\n    private final Func1<? super T, byte[]> serializer;\n    private final Func1<byte[], ? extends T> deserializer;\n    private final Func0<Kryo> kryoFactory;\n\n    public SerializerKryo(Func1<? super T, byte[]> serializer,\n            Func1<byte[], ? extends T> deserializer, Func0<Kryo> kryoFactory) {\n        this.serializer = serializer;\n        this.deserializer = deserializer;\n        this.kryoFactory = kryoFactory;\n    }\n\n    @Override\n    public void write(RTree<T, S> tree, OutputStream os) throws IOException {\n        Output output = new Output(os);\n        Kryo kryo = kryoFactory.call();\n        write(kryo, output, tree);\n    }\n\n    private void write(Kryo kryo, Output output, RTree<T, S> tree) {\n        writeContext(tree.context(), output);\n        output.writeBoolean(tree.root().isPresent());\n        output.writeInt(tree.size());\n        if (tree.root().isPresent()) {\n            writeNode(tree.root().get(), output);\n        }\n    }\n\n    private void writeNode(Node<T, S> node, Output output) {\n        boolean isLeaf = node instanceof Leaf;\n        output.writeBoolean(isLeaf);\n        if (isLeaf) {\n            Leaf<T, S> leaf = (Leaf<T, S>) node;\n            writeBounds(output, leaf.geometry().mbr());\n            output.writeInt(leaf.count());\n            for (Entry<T, S> entry : leaf.entries()) {\n                S g = entry.geometry();\n                writeValue(output, entry.value());\n                writeGeometry(output, g);\n            }\n        } else {\n            NonLeaf<T, S> nonLeaf = (NonLeaf<T, S>) node;\n            writeBounds(output, nonLeaf.geometry().mbr());\n            output.writeInt(nonLeaf.count());\n            for (Node<T, S> nd : nonLeaf.children()) {\n                writeNode(nd, output);\n            }\n        }\n    }\n\n    private void writeValue(Output output, T t) {\n        byte[] bytes = serializer.call(t);\n        output.write(bytes.length);\n        output.write(bytes);\n    }\n\n    private void writeRectangle(Output output, S g) {\n        Rectangle r = (Rectangle) g;\n        output.write(0);\n        writeBounds(output, r);\n    }\n\n    private void writeGeometry(Output output, S g) {\n        if (g instanceof Rectangle) {\n            writeRectangle(output, g);\n        } else {\n            throw new RuntimeException(\"unexpected\");\n        }\n    }\n\n    private void writeBounds(Output output, Rectangle mbr) {\n        output.writeBoolean(mbr.isDoublePrecision());\n        if (mbr.isDoublePrecision()) {\n            output.writeDouble(mbr.x1());\n            output.writeDouble(mbr.y1());\n            output.writeDouble(mbr.y1());\n            output.writeDouble(mbr.y2());\n        } else {\n            output.writeFloat((float) mbr.x1());\n            output.writeFloat((float) mbr.y1());\n            output.writeFloat((float) mbr.y1());\n            output.writeFloat((float) mbr.y2());\n        }\n    }\n\n    private void writeContext(Context<T, S> context, Output output) {\n        output.writeInt(context.minChildren());\n        output.writeInt(context.maxChildren());\n    }\n\n    @Override\n    public RTree<T, S> read(InputStream is, long sizeBytes, InternalStructure structure)\n            throws IOException {\n        Input input = new Input(is);\n        return read(input);\n    }\n\n    private static <T, S extends Geometry> RTree<T, S> read(Input input) {\n        Context<T, S> context = readContext(input);\n        boolean hasRoot = input.readBoolean();\n        int size = input.readInt();\n        Optional<Node<T, S>> root;\n        if (hasRoot) {\n            root = Optional.of(SerializerKryo.readNode(input));\n        } else {\n            root = Optional.empty();\n        }\n        return SerializerHelper.create(root, size, context);\n    }\n\n    private static <T, S extends Geometry> Node<T, S> readNode(Input input) {\n        // TODO\n        return null;\n    }\n\n    private static <T, S extends Geometry> Context<T, S> readContext(Input input) {\n        return new Context<T, S>(2, 4, new SelectorRStar(), new SplitterRStar(),\n                FactoryDefault.<T, S>instance());\n    }\n\n    public static <T, S extends Geometry> Serializer<T, S> create(\n            Func1<? super T, byte[]> serializer, Func1<byte[], ? extends T> deserializer,\n            Func0<Kryo> kryoFactory) {\n        return new SerializerKryo<T, S>(serializer, deserializer, kryoFactory);\n    }\n\n}\n", "file_hash": "2f678041f79a97071de7d2101daebcd121d29a3c2e5bc76808e518ba6aa50ec4", "file_docstring": "", "contexts": ["package com.github.davidmoten.rtree.kryo;", "import java.io.IOException;", "import java.io.InputStream;", "import java.io.OutputStream;", "import java.util.Optional;", "import com.esotericsoftware.kryo.Kryo;", "import com.esotericsoftware.kryo.io.Input;", "import com.esotericsoftware.kryo.io.Output;", "import com.github.davidmoten.rtree.Context;", "import com.github.davidmoten.rtree.Entry;", "import com.github.davidmoten.rtree.InternalStructure;", "import com.github.davidmoten.rtree.Leaf;", "import com.github.davidmoten.rtree.Node;", "import com.github.davidmoten.rtree.NonLeaf;", "import com.github.davidmoten.rtree.RTree;", "import com.github.davidmoten.rtree.SelectorRStar;", "import com.github.davidmoten.rtree.Serializer;", "import com.github.davidmoten.rtree.SerializerHelper;", "import com.github.davidmoten.rtree.SplitterRStar;", "import com.github.davidmoten.rtree.geometry.Geometry;", "import com.github.davidmoten.rtree.geometry.Rectangle;", "import com.github.davidmoten.rtree.internal.FactoryDefault;", "import rx.functions.Func0;", "import rx.functions.Func1;"], "methods": [], "classes": [{"original_string": "public class SerializerKryo<T, S extends Geometry> implements Serializer<T, S> {\n\n    private final Func1<? super T, byte[]> serializer;\n    private final Func1<byte[], ? extends T> deserializer;\n    private final Func0<Kryo> kryoFactory;\n\n    public SerializerKryo(Func1<? super T, byte[]> serializer,\n            Func1<byte[], ? extends T> deserializer, Func0<Kryo> kryoFactory) {\n        this.serializer = serializer;\n        this.deserializer = deserializer;\n        this.kryoFactory = kryoFactory;\n    }\n\n    @Override\n    public void write(RTree<T, S> tree, OutputStream os) throws IOException {\n        Output output = new Output(os);\n        Kryo kryo = kryoFactory.call();\n        write(kryo, output, tree);\n    }\n\n    private void write(Kryo kryo, Output output, RTree<T, S> tree) {\n        writeContext(tree.context(), output);\n        output.writeBoolean(tree.root().isPresent());\n        output.writeInt(tree.size());\n        if (tree.root().isPresent()) {\n            writeNode(tree.root().get(), output);\n        }\n    }\n\n    private void writeNode(Node<T, S> node, Output output) {\n        boolean isLeaf = node instanceof Leaf;\n        output.writeBoolean(isLeaf);\n        if (isLeaf) {\n            Leaf<T, S> leaf = (Leaf<T, S>) node;\n            writeBounds(output, leaf.geometry().mbr());\n            output.writeInt(leaf.count());\n            for (Entry<T, S> entry : leaf.entries()) {\n                S g = entry.geometry();\n                writeValue(output, entry.value());\n                writeGeometry(output, g);\n            }\n        } else {\n            NonLeaf<T, S> nonLeaf = (NonLeaf<T, S>) node;\n            writeBounds(output, nonLeaf.geometry().mbr());\n            output.writeInt(nonLeaf.count());\n            for (Node<T, S> nd : nonLeaf.children()) {\n                writeNode(nd, output);\n            }\n        }\n    }\n\n    private void writeValue(Output output, T t) {\n        byte[] bytes = serializer.call(t);\n        output.write(bytes.length);\n        output.write(bytes);\n    }\n\n    private void writeRectangle(Output output, S g) {\n        Rectangle r = (Rectangle) g;\n        output.write(0);\n        writeBounds(output, r);\n    }\n\n    private void writeGeometry(Output output, S g) {\n        if (g instanceof Rectangle) {\n            writeRectangle(output, g);\n        } else {\n            throw new RuntimeException(\"unexpected\");\n        }\n    }\n\n    private void writeBounds(Output output, Rectangle mbr) {\n        output.writeBoolean(mbr.isDoublePrecision());\n        if (mbr.isDoublePrecision()) {\n            output.writeDouble(mbr.x1());\n            output.writeDouble(mbr.y1());\n            output.writeDouble(mbr.y1());\n            output.writeDouble(mbr.y2());\n        } else {\n            output.writeFloat((float) mbr.x1());\n            output.writeFloat((float) mbr.y1());\n            output.writeFloat((float) mbr.y1());\n            output.writeFloat((float) mbr.y2());\n        }\n    }\n\n    private void writeContext(Context<T, S> context, Output output) {\n        output.writeInt(context.minChildren());\n        output.writeInt(context.maxChildren());\n    }\n\n    @Override\n    public RTree<T, S> read(InputStream is, long sizeBytes, InternalStructure structure)\n            throws IOException {\n        Input input = new Input(is);\n        return read(input);\n    }\n\n    private static <T, S extends Geometry> RTree<T, S> read(Input input) {\n        Context<T, S> context = readContext(input);\n        boolean hasRoot = input.readBoolean();\n        int size = input.readInt();\n        Optional<Node<T, S>> root;\n        if (hasRoot) {\n            root = Optional.of(SerializerKryo.readNode(input));\n        } else {\n            root = Optional.empty();\n        }\n        return SerializerHelper.create(root, size, context);\n    }\n\n    private static <T, S extends Geometry> Node<T, S> readNode(Input input) {\n        // TODO\n        return null;\n    }\n\n    private static <T, S extends Geometry> Context<T, S> readContext(Input input) {\n        return new Context<T, S>(2, 4, new SelectorRStar(), new SplitterRStar(),\n                FactoryDefault.<T, S>instance());\n    }\n\n    public static <T, S extends Geometry> Serializer<T, S> create(\n            Func1<? super T, byte[]> serializer, Func1<byte[], ? extends T> deserializer,\n            Func0<Kryo> kryoFactory) {\n        return new SerializerKryo<T, S>(serializer, deserializer, kryoFactory);\n    }\n\n}", "definition": "public class SerializerKryo<T, S extends Geometry> implements Serializer<T, S>", "class_docstring": "", "name": "SerializerKryo", "super_interfaces": ["Serializer<T, S>"], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private final Func1<? super T, byte[]> serializer;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Func1<? super T, byte[]>", "name": "serializer", "syntax_pass": true}, {"attribute_expression": "private final Func1<byte[], ? extends T> deserializer;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Func1<byte[], ? extends T>", "name": "deserializer", "syntax_pass": true}, {"attribute_expression": "private final Func0<Kryo> kryoFactory;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Func0<Kryo>", "name": "kryoFactory", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    public SerializerKryo(Func1<? super T, byte[]> serializer,\n            Func1<byte[], ? extends T> deserializer, Func0<Kryo> kryoFactory) {\n        this.serializer = serializer;\n        this.deserializer = deserializer;\n        this.kryoFactory = kryoFactory;\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "SerializerKryo", "params": [{"name": "serializer", "type": "Func1<? super T, byte[]>"}, {"name": "deserializer", "type": "Func1<byte[], ? extends T>"}, {"name": "kryoFactory", "type": "Func0<Kryo>"}], "body": "                                                                              {\n        this.serializer = serializer;\n        this.deserializer = deserializer;\n        this.kryoFactory = kryoFactory;\n    }", "signature": "public SerializerKryo(Func1<? super T, byte[]> serializer,\n            Func1<byte[], ? extends T> deserializer, Func0<Kryo> kryoFactory)"}, {"syntax_pass": true, "original_string": "    @Override\n    public void write(RTree<T, S> tree, OutputStream os) throws IOException {\n        Output output = new Output(os);\n        Kryo kryo = kryoFactory.call();\n        write(kryo, output, tree);\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "write", "params": [{"name": "tree", "type": "RTree<T, S>"}, {"name": "os", "type": "OutputStream"}], "body": "                                                                            {\n        Output output = new Output(os);\n        Kryo kryo = kryoFactory.call();\n        write(kryo, output, tree);\n    }", "signature": "@Override\n    public void write(RTree<T, S> tree, OutputStream os)"}, {"syntax_pass": true, "original_string": "    private void write(Kryo kryo, Output output, RTree<T, S> tree) {\n        writeContext(tree.context(), output);\n        output.writeBoolean(tree.root().isPresent());\n        output.writeInt(tree.size());\n        if (tree.root().isPresent()) {\n            writeNode(tree.root().get(), output);\n        }\n    }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "name": "write", "params": [{"name": "kryo", "type": "Kryo"}, {"name": "output", "type": "Output"}, {"name": "tree", "type": "RTree<T, S>"}], "body": "                                                                   {\n        writeContext(tree.context(), output);\n        output.writeBoolean(tree.root().isPresent());\n        output.writeInt(tree.size());\n        if (tree.root().isPresent()) {\n            writeNode(tree.root().get(), output);\n        }\n    }", "signature": "private void write(Kryo kryo, Output output, RTree<T, S> tree)"}, {"syntax_pass": true, "original_string": "    private void writeNode(Node<T, S> node, Output output) {\n        boolean isLeaf = node instanceof Leaf;\n        output.writeBoolean(isLeaf);\n        if (isLeaf) {\n            Leaf<T, S> leaf = (Leaf<T, S>) node;\n            writeBounds(output, leaf.geometry().mbr());\n            output.writeInt(leaf.count());\n            for (Entry<T, S> entry : leaf.entries()) {\n                S g = entry.geometry();\n                writeValue(output, entry.value());\n                writeGeometry(output, g);\n            }\n        } else {\n            NonLeaf<T, S> nonLeaf = (NonLeaf<T, S>) node;\n            writeBounds(output, nonLeaf.geometry().mbr());\n            output.writeInt(nonLeaf.count());\n            for (Node<T, S> nd : nonLeaf.children()) {\n                writeNode(nd, output);\n            }\n        }\n    }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "name": "writeNode", "params": [{"name": "node", "type": "Node<T, S>"}, {"name": "output", "type": "Output"}], "body": "                                                           {\n        boolean isLeaf = node instanceof Leaf;\n        output.writeBoolean(isLeaf);\n        if (isLeaf) {\n            Leaf<T, S> leaf = (Leaf<T, S>) node;\n            writeBounds(output, leaf.geometry().mbr());\n            output.writeInt(leaf.count());\n            for (Entry<T, S> entry : leaf.entries()) {\n                S g = entry.geometry();\n                writeValue(output, entry.value());\n                writeGeometry(output, g);\n            }\n        } else {\n            NonLeaf<T, S> nonLeaf = (NonLeaf<T, S>) node;\n            writeBounds(output, nonLeaf.geometry().mbr());\n            output.writeInt(nonLeaf.count());\n            for (Node<T, S> nd : nonLeaf.children()) {\n                writeNode(nd, output);\n            }\n        }\n    }", "signature": "private void writeNode(Node<T, S> node, Output output)"}, {"syntax_pass": true, "original_string": "    private void writeValue(Output output, T t) {\n        byte[] bytes = serializer.call(t);\n        output.write(bytes.length);\n        output.write(bytes);\n    }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "name": "writeValue", "params": [{"name": "output", "type": "Output"}, {"name": "t", "type": "T"}], "body": "                                                {\n        byte[] bytes = serializer.call(t);\n        output.write(bytes.length);\n        output.write(bytes);\n    }", "signature": "private void writeValue(Output output, T t)"}, {"syntax_pass": true, "original_string": "    private void writeRectangle(Output output, S g) {\n        Rectangle r = (Rectangle) g;\n        output.write(0);\n        writeBounds(output, r);\n    }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "name": "writeRectangle", "params": [{"name": "output", "type": "Output"}, {"name": "g", "type": "S"}], "body": "                                                    {\n        Rectangle r = (Rectangle) g;\n        output.write(0);\n        writeBounds(output, r);\n    }", "signature": "private void writeRectangle(Output output, S g)"}, {"syntax_pass": true, "original_string": "    private void writeGeometry(Output output, S g) {\n        if (g instanceof Rectangle) {\n            writeRectangle(output, g);\n        } else {\n            throw new RuntimeException(\"unexpected\");\n        }\n    }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "name": "writeGeometry", "params": [{"name": "output", "type": "Output"}, {"name": "g", "type": "S"}], "body": "                                                   {\n        if (g instanceof Rectangle) {\n            writeRectangle(output, g);\n        } else {\n            throw new RuntimeException(\"unexpected\");\n        }\n    }", "signature": "private void writeGeometry(Output output, S g)"}, {"syntax_pass": true, "original_string": "    private void writeBounds(Output output, Rectangle mbr) {\n        output.writeBoolean(mbr.isDoublePrecision());\n        if (mbr.isDoublePrecision()) {\n            output.writeDouble(mbr.x1());\n            output.writeDouble(mbr.y1());\n            output.writeDouble(mbr.y1());\n            output.writeDouble(mbr.y2());\n        } else {\n            output.writeFloat((float) mbr.x1());\n            output.writeFloat((float) mbr.y1());\n            output.writeFloat((float) mbr.y1());\n            output.writeFloat((float) mbr.y2());\n        }\n    }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "name": "writeBounds", "params": [{"name": "output", "type": "Output"}, {"name": "mbr", "type": "Rectangle"}], "body": "                                                           {\n        output.writeBoolean(mbr.isDoublePrecision());\n        if (mbr.isDoublePrecision()) {\n            output.writeDouble(mbr.x1());\n            output.writeDouble(mbr.y1());\n            output.writeDouble(mbr.y1());\n            output.writeDouble(mbr.y2());\n        } else {\n            output.writeFloat((float) mbr.x1());\n            output.writeFloat((float) mbr.y1());\n            output.writeFloat((float) mbr.y1());\n            output.writeFloat((float) mbr.y2());\n        }\n    }", "signature": "private void writeBounds(Output output, Rectangle mbr)"}, {"syntax_pass": true, "original_string": "    private void writeContext(Context<T, S> context, Output output) {\n        output.writeInt(context.minChildren());\n        output.writeInt(context.maxChildren());\n    }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "name": "writeContext", "params": [{"name": "context", "type": "Context<T, S>"}, {"name": "output", "type": "Output"}], "body": "                                                                    {\n        output.writeInt(context.minChildren());\n        output.writeInt(context.maxChildren());\n    }", "signature": "private void writeContext(Context<T, S> context, Output output)"}, {"syntax_pass": true, "original_string": "    @Override\n    public RTree<T, S> read(InputStream is, long sizeBytes, InternalStructure structure)\n            throws IOException {\n        Input input = new Input(is);\n        return read(input);\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "RTree<T, S>", "classes": []}, "name": "read", "params": [{"name": "is", "type": "InputStream"}, {"name": "sizeBytes", "type": "long"}, {"name": "structure", "type": "InternalStructure"}], "body": "                               {\n        Input input = new Input(is);\n        return read(input);\n    }", "signature": "@Override\n    public RTree<T, S> read(InputStream is, long sizeBytes, InternalStructure structure)"}, {"syntax_pass": true, "original_string": "    private static <T, S extends Geometry> RTree<T, S> read(Input input) {\n        Context<T, S> context = readContext(input);\n        boolean hasRoot = input.readBoolean();\n        int size = input.readInt();\n        Optional<Node<T, S>> root;\n        if (hasRoot) {\n            root = Optional.of(SerializerKryo.readNode(input));\n        } else {\n            root = Optional.empty();\n        }\n        return SerializerHelper.create(root, size, context);\n    }", "docstring": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "RTree<T, S>", "classes": []}, "name": "read", "params": [{"name": "input", "type": "Input"}], "body": "                                                                         {\n        Context<T, S> context = readContext(input);\n        boolean hasRoot = input.readBoolean();\n        int size = input.readInt();\n        Optional<Node<T, S>> root;\n        if (hasRoot) {\n            root = Optional.of(SerializerKryo.readNode(input));\n        } else {\n            root = Optional.empty();\n        }\n        return SerializerHelper.create(root, size, context);\n    }", "signature": "private static <T, S extends Geometry> RTree<T, S> read(Input input)"}, {"syntax_pass": true, "original_string": "    private static <T, S extends Geometry> Node<T, S> readNode(Input input) {\n        // TODO\n        return null;\n    }", "docstring": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "Node<T, S>", "classes": []}, "name": "readNode", "params": [{"name": "input", "type": "Input"}], "body": "                                                                            {\n        // TODO\n        return null;\n    }", "signature": "private static <T, S extends Geometry> Node<T, S> readNode(Input input)"}, {"syntax_pass": true, "original_string": "    private static <T, S extends Geometry> Context<T, S> readContext(Input input) {\n        return new Context<T, S>(2, 4, new SelectorRStar(), new SplitterRStar(),\n                FactoryDefault.<T, S>instance());\n    }", "docstring": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "Context<T, S>", "classes": []}, "name": "readContext", "params": [{"name": "input", "type": "Input"}], "body": "                                                                                  {\n        return new Context<T, S>(2, 4, new SelectorRStar(), new SplitterRStar(),\n                FactoryDefault.<T, S>instance());\n    }", "signature": "private static <T, S extends Geometry> Context<T, S> readContext(Input input)"}, {"syntax_pass": true, "original_string": "    public static <T, S extends Geometry> Serializer<T, S> create(\n            Func1<? super T, byte[]> serializer, Func1<byte[], ? extends T> deserializer,\n            Func0<Kryo> kryoFactory) {\n        return new SerializerKryo<T, S>(serializer, deserializer, kryoFactory);\n    }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Serializer<T, S>", "classes": []}, "name": "create", "params": [{"name": "serializer", "type": "Func1<? super T, byte[]>"}, {"name": "deserializer", "type": "Func1<byte[], ? extends T>"}, {"name": "kryoFactory", "type": "Func0<Kryo>"}], "body": "                                     {\n        return new SerializerKryo<T, S>(serializer, deserializer, kryoFactory);\n    }", "signature": "public static <T, S extends Geometry> Serializer<T, S> create(\n            Func1<? super T, byte[]> serializer, Func1<byte[], ? extends T> deserializer,\n            Func0<Kryo> kryoFactory)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/com/github/davidmoten/rtree/geometry/Geometry.java", "original_string": "package com.github.davidmoten.rtree.geometry;\n\n/**\n * A geometrical region that represents an Entry spatially. It is recommended\n * that implementations of this interface implement equals() and hashCode()\n * appropriately that entry equality checks work as expected.\n */\npublic interface Geometry {\n\n    /**\n     * <p>\n     * Returns the distance to the given {@link Rectangle}. For a {@link Rectangle}\n     * this might be Euclidean distance but for an EPSG4326 lat-long Rectangle might\n     * be great-circle distance. The distance function should satisfy the following\n     * properties:\n     * </p>\n     * \n     * <p>\n     * <code>distance(r) &gt;= 0</code>\n     * </p>\n     * \n     * <p>\n     * <code>if r1 contains r2 then distance(r1)&lt;=distance(r2)</code>\n     * </p>\n     * \n     * \n     * @param r\n     *            rectangle to measure distance to\n     * @return distance to the rectangle r from the geometry\n     */\n    double distance(Rectangle r);\n\n    /**\n     * Returns the minimum bounding rectangle of this geometry.\n     * \n     * @return minimum bounding rectangle\n     */\n    Rectangle mbr();\n\n    boolean intersects(Rectangle r);\n\n    boolean isDoublePrecision();\n}\n", "file_hash": "bd791b0e50d62c244845530194e1b7cabb6493d95cc0042834f9b8518b7cc03b", "file_docstring": "\nA geometrical region that represents an Entry spatially. It is recommended\nthat implementations of this interface implement equals() and hashCode()\nappropriately that entry equality checks work as expected.\n", "contexts": ["package com.github.davidmoten.rtree.geometry;"], "methods": [], "classes": [], "interfaces": [{"original_string": "public interface Geometry {\n\n    /**\n     * <p>\n     * Returns the distance to the given {@link Rectangle}. For a {@link Rectangle}\n     * this might be Euclidean distance but for an EPSG4326 lat-long Rectangle might\n     * be great-circle distance. The distance function should satisfy the following\n     * properties:\n     * </p>\n     * \n     * <p>\n     * <code>distance(r) &gt;= 0</code>\n     * </p>\n     * \n     * <p>\n     * <code>if r1 contains r2 then distance(r1)&lt;=distance(r2)</code>\n     * </p>\n     * \n     * \n     * @param r\n     *            rectangle to measure distance to\n     * @return distance to the rectangle r from the geometry\n     */\n    double distance(Rectangle r);\n\n    /**\n     * Returns the minimum bounding rectangle of this geometry.\n     * \n     * @return minimum bounding rectangle\n     */\n    Rectangle mbr();\n\n    boolean intersects(Rectangle r);\n\n    boolean isDoublePrecision();\n}", "definition": "public interface Geometry", "interface_docstring": "\nA geometrical region that represents an Entry spatially. It is recommended\nthat implementations of this interface implement equals() and hashCode()\nappropriately that entry equality checks work as expected.\n", "name": "Geometry", "extends_interfaces": [], "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    double distance(Rectangle r);", "docstring": "\n<p>\nReturns the distance to the given {@link Rectangle}. For a {@link Rectangle}\nthis might be Euclidean distance but for an EPSG4326 lat-long Rectangle might\nbe great-circle distance. The distance function should satisfy the following\nproperties:\n</p>\n\n<p>\n<code>distance(r) &gt;= 0</code>\n</p>\n\n<p>\n<code>if r1 contains r2 then distance(r1)&lt;=distance(r2)</code>\n</p>\n\n\n@param r\n           rectangle to measure distance to\n@return distance to the rectangle r from the geometry\n", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "double", "classes": []}, "name": "distance", "params": [{"name": "r", "type": "Rectangle"}], "body": "", "signature": "double distance(Rectangle r)"}, {"syntax_pass": true, "original_string": "    Rectangle mbr();", "docstring": "\nReturns the minimum bounding rectangle of this geometry.\n\n@return minimum bounding rectangle\n", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "Rectangle", "classes": []}, "name": "mbr", "params": [], "body": "", "signature": "Rectangle mbr()"}, {"syntax_pass": true, "original_string": "    boolean intersects(Rectangle r);", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "boolean", "classes": []}, "name": "intersects", "params": [{"name": "r", "type": "Rectangle"}], "body": "", "signature": "boolean intersects(Rectangle r)"}, {"syntax_pass": true, "original_string": "    boolean isDoublePrecision();", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "boolean", "classes": []}, "name": "isDoublePrecision", "params": [], "body": "", "signature": "boolean isDoublePrecision()"}]}], "records": []}, {"relative_path": "src/main/java/com/github/davidmoten/rtree/geometry/Group.java", "original_string": "package com.github.davidmoten.rtree.geometry;\n\nimport java.util.List;\n\nimport com.github.davidmoten.rtree.internal.Util;\n\npublic class Group<T extends HasGeometry> implements HasGeometry {\n\n    private final List<T> list;\n    private final Rectangle mbr;\n\n    public Group(List<T> list) {\n        this.list = list;\n        this.mbr = Util.mbr(list);\n    }\n\n    public List<T> list() {\n        return list;\n    }\n\n    @Override\n    public Geometry geometry() {\n        return mbr;\n    }\n\n}\n", "file_hash": "3bf2d392f40eefeddbd5a8e9c51e108774b1bb060d7e75080af348fe2c3be043", "file_docstring": "", "contexts": ["package com.github.davidmoten.rtree.geometry;", "import java.util.List;", "import com.github.davidmoten.rtree.internal.Util;"], "methods": [], "classes": [{"original_string": "public class Group<T extends HasGeometry> implements HasGeometry {\n\n    private final List<T> list;\n    private final Rectangle mbr;\n\n    public Group(List<T> list) {\n        this.list = list;\n        this.mbr = Util.mbr(list);\n    }\n\n    public List<T> list() {\n        return list;\n    }\n\n    @Override\n    public Geometry geometry() {\n        return mbr;\n    }\n\n}", "definition": "public class Group<T extends HasGeometry> implements HasGeometry", "class_docstring": "", "name": "Group", "super_interfaces": ["HasGeometry"], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private final List<T> list;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "List<T>", "name": "list", "syntax_pass": true}, {"attribute_expression": "private final Rectangle mbr;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Rectangle", "name": "mbr", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    public Group(List<T> list) {\n        this.list = list;\n        this.mbr = Util.mbr(list);\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "Group", "params": [{"name": "list", "type": "List<T>"}], "body": "                               {\n        this.list = list;\n        this.mbr = Util.mbr(list);\n    }", "signature": "public Group(List<T> list)"}, {"syntax_pass": true, "original_string": "    public List<T> list() {\n        return list;\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "List<T>", "classes": []}, "name": "list", "params": [], "body": "                          {\n        return list;\n    }", "signature": "public List<T> list()"}, {"syntax_pass": true, "original_string": "    @Override\n    public Geometry geometry() {\n        return mbr;\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Geometry", "classes": []}, "name": "geometry", "params": [], "body": "                               {\n        return mbr;\n    }", "signature": "@Override\n    public Geometry geometry()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/com/github/davidmoten/rtree/geometry/Geometries.java", "original_string": "package com.github.davidmoten.rtree.geometry;\n\nimport com.github.davidmoten.guavamini.annotations.VisibleForTesting;\nimport com.github.davidmoten.rtree.geometry.internal.CircleDouble;\nimport com.github.davidmoten.rtree.geometry.internal.CircleFloat;\nimport com.github.davidmoten.rtree.geometry.internal.LineDouble;\nimport com.github.davidmoten.rtree.geometry.internal.LineFloat;\nimport com.github.davidmoten.rtree.geometry.internal.PointDouble;\nimport com.github.davidmoten.rtree.geometry.internal.PointFloat;\nimport com.github.davidmoten.rtree.geometry.internal.RectangleDouble;\nimport com.github.davidmoten.rtree.geometry.internal.RectangleFloat;\n\npublic final class Geometries {\n\n    private Geometries() {\n        // prevent instantiation\n    }\n\n    public static Point point(double x, double y) {\n        return PointDouble.create(x, y);\n    }\n\n    public static Point point(float x, float y) {\n        return PointFloat.create(x, y);\n    }\n\n    public static Point pointGeographic(double lon, double lat) {\n        return point(normalizeLongitudeDouble(lon), lat);\n    }\n\n    public static Point pointGeographic(float lon, float lat) {\n        return point(normalizeLongitude(lon), lat);\n    }\n\n    public static Rectangle rectangle(double x1, double y1, double x2, double y2) {\n        return rectangleDouble(x1, y1, x2, y2);\n    }\n\n    public static Rectangle rectangle(float x1, float y1, float x2, float y2) {\n        return RectangleFloat.create(x1, y1, x2, y2);\n    }\n\n    public static Rectangle rectangleGeographic(double lon1, double lat1, double lon2,\n            double lat2) {\n        return rectangleGeographic((float) lon1, (float) lat1, (float) lon2, (float) lat2);\n    }\n\n    public static Rectangle rectangleGeographic(float lon1, float lat1, float lon2, float lat2) {\n        float x1 = normalizeLongitude(lon1);\n        float x2 = normalizeLongitude(lon2);\n        if (x2 < x1) {\n            x2 += 360;\n        }\n        return rectangle(x1, lat1, x2, lat2);\n    }\n\n    private static Rectangle rectangleDouble(double x1, double y1, double x2, double y2) {\n        return  RectangleDouble.create(x1, y1, x2, y2);\n    }\n\n    public static Circle circle(double x, double y, double radius) {\n        return CircleDouble.create(x, y, radius);\n    }\n\n    public static Circle circle(float x, float y, float radius) {\n        return CircleFloat.create(x, y, radius);\n    }\n\n    public static Line line(double x1, double y1, double x2, double y2) {\n        return LineDouble.create(x1, y1, x2, y2);\n    }\n\n    public static Line line(float x1, float y1, float x2, float y2) {\n        return LineFloat.create(x1, y1, x2, y2);\n    }\n\n    @VisibleForTesting\n    static double normalizeLongitude(double d) {\n        return normalizeLongitude((float) d);\n    }\n\n    private static float normalizeLongitude(float d) {\n        if (d == -180.0f)\n            return -180.0f;\n        else {\n            float sign = Math.signum(d);\n            float x = Math.abs(d) / 360;\n            float x2 = (x - (float) Math.floor(x)) * 360;\n            if (x2 >= 180)\n                x2 -= 360;\n            return x2 * sign;\n        }\n    }\n\n    private static double normalizeLongitudeDouble(double d) {\n        if (d == -180.0f)\n            return -180.0d;\n        else {\n            double sign = Math.signum(d);\n            double x = Math.abs(d) / 360;\n            double x2 = (x - (float) Math.floor(x)) * 360;\n            if (x2 >= 180)\n                x2 -= 360;\n            return x2 * sign;\n        }\n    }\n\n}\n", "file_hash": "d037fa2e7f18345bd610fd5a8e8a98a3f4f3ed67ec22617dee366832e5c8a890", "file_docstring": "", "contexts": ["package com.github.davidmoten.rtree.geometry;", "import com.github.davidmoten.guavamini.annotations.VisibleForTesting;", "import com.github.davidmoten.rtree.geometry.internal.CircleDouble;", "import com.github.davidmoten.rtree.geometry.internal.CircleFloat;", "import com.github.davidmoten.rtree.geometry.internal.LineDouble;", "import com.github.davidmoten.rtree.geometry.internal.LineFloat;", "import com.github.davidmoten.rtree.geometry.internal.PointDouble;", "import com.github.davidmoten.rtree.geometry.internal.PointFloat;", "import com.github.davidmoten.rtree.geometry.internal.RectangleDouble;", "import com.github.davidmoten.rtree.geometry.internal.RectangleFloat;"], "methods": [], "classes": [{"original_string": "public final class Geometries {\n\n    private Geometries() {\n        // prevent instantiation\n    }\n\n    public static Point point(double x, double y) {\n        return PointDouble.create(x, y);\n    }\n\n    public static Point point(float x, float y) {\n        return PointFloat.create(x, y);\n    }\n\n    public static Point pointGeographic(double lon, double lat) {\n        return point(normalizeLongitudeDouble(lon), lat);\n    }\n\n    public static Point pointGeographic(float lon, float lat) {\n        return point(normalizeLongitude(lon), lat);\n    }\n\n    public static Rectangle rectangle(double x1, double y1, double x2, double y2) {\n        return rectangleDouble(x1, y1, x2, y2);\n    }\n\n    public static Rectangle rectangle(float x1, float y1, float x2, float y2) {\n        return RectangleFloat.create(x1, y1, x2, y2);\n    }\n\n    public static Rectangle rectangleGeographic(double lon1, double lat1, double lon2,\n            double lat2) {\n        return rectangleGeographic((float) lon1, (float) lat1, (float) lon2, (float) lat2);\n    }\n\n    public static Rectangle rectangleGeographic(float lon1, float lat1, float lon2, float lat2) {\n        float x1 = normalizeLongitude(lon1);\n        float x2 = normalizeLongitude(lon2);\n        if (x2 < x1) {\n            x2 += 360;\n        }\n        return rectangle(x1, lat1, x2, lat2);\n    }\n\n    private static Rectangle rectangleDouble(double x1, double y1, double x2, double y2) {\n        return  RectangleDouble.create(x1, y1, x2, y2);\n    }\n\n    public static Circle circle(double x, double y, double radius) {\n        return CircleDouble.create(x, y, radius);\n    }\n\n    public static Circle circle(float x, float y, float radius) {\n        return CircleFloat.create(x, y, radius);\n    }\n\n    public static Line line(double x1, double y1, double x2, double y2) {\n        return LineDouble.create(x1, y1, x2, y2);\n    }\n\n    public static Line line(float x1, float y1, float x2, float y2) {\n        return LineFloat.create(x1, y1, x2, y2);\n    }\n\n    @VisibleForTesting\n    static double normalizeLongitude(double d) {\n        return normalizeLongitude((float) d);\n    }\n\n    private static float normalizeLongitude(float d) {\n        if (d == -180.0f)\n            return -180.0f;\n        else {\n            float sign = Math.signum(d);\n            float x = Math.abs(d) / 360;\n            float x2 = (x - (float) Math.floor(x)) * 360;\n            if (x2 >= 180)\n                x2 -= 360;\n            return x2 * sign;\n        }\n    }\n\n    private static double normalizeLongitudeDouble(double d) {\n        if (d == -180.0f)\n            return -180.0d;\n        else {\n            double sign = Math.signum(d);\n            double x = Math.abs(d) / 360;\n            double x2 = (x - (float) Math.floor(x)) * 360;\n            if (x2 >= 180)\n                x2 -= 360;\n            return x2 * sign;\n        }\n    }\n\n}", "definition": "public final class Geometries", "class_docstring": "", "name": "Geometries", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    private Geometries() {\n        // prevent instantiation\n    }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "", "classes": []}, "name": "Geometries", "params": [], "body": "                         {\n        // prevent instantiation\n    }", "signature": "private Geometries()"}, {"syntax_pass": true, "original_string": "    public static Point point(double x, double y) {\n        return PointDouble.create(x, y);\n    }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Point", "classes": []}, "name": "point", "params": [{"name": "x", "type": "double"}, {"name": "y", "type": "double"}], "body": "                                                  {\n        return PointDouble.create(x, y);\n    }", "signature": "public static Point point(double x, double y)"}, {"syntax_pass": true, "original_string": "    public static Point point(float x, float y) {\n        return PointFloat.create(x, y);\n    }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Point", "classes": []}, "name": "point", "params": [{"name": "x", "type": "float"}, {"name": "y", "type": "float"}], "body": "                                                {\n        return PointFloat.create(x, y);\n    }", "signature": "public static Point point(float x, float y)"}, {"syntax_pass": true, "original_string": "    public static Point pointGeographic(double lon, double lat) {\n        return point(normalizeLongitudeDouble(lon), lat);\n    }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Point", "classes": []}, "name": "pointGeographic", "params": [{"name": "lon", "type": "double"}, {"name": "lat", "type": "double"}], "body": "                                                                {\n        return point(normalizeLongitudeDouble(lon), lat);\n    }", "signature": "public static Point pointGeographic(double lon, double lat)"}, {"syntax_pass": true, "original_string": "    public static Point pointGeographic(float lon, float lat) {\n        return point(normalizeLongitude(lon), lat);\n    }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Point", "classes": []}, "name": "pointGeographic", "params": [{"name": "lon", "type": "float"}, {"name": "lat", "type": "float"}], "body": "                                                              {\n        return point(normalizeLongitude(lon), lat);\n    }", "signature": "public static Point pointGeographic(float lon, float lat)"}, {"syntax_pass": true, "original_string": "    public static Rectangle rectangle(double x1, double y1, double x2, double y2) {\n        return rectangleDouble(x1, y1, x2, y2);\n    }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Rectangle", "classes": []}, "name": "rectangle", "params": [{"name": "x1", "type": "double"}, {"name": "y1", "type": "double"}, {"name": "x2", "type": "double"}, {"name": "y2", "type": "double"}], "body": "                                                                                  {\n        return rectangleDouble(x1, y1, x2, y2);\n    }", "signature": "public static Rectangle rectangle(double x1, double y1, double x2, double y2)"}, {"syntax_pass": true, "original_string": "    public static Rectangle rectangle(float x1, float y1, float x2, float y2) {\n        return RectangleFloat.create(x1, y1, x2, y2);\n    }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Rectangle", "classes": []}, "name": "rectangle", "params": [{"name": "x1", "type": "float"}, {"name": "y1", "type": "float"}, {"name": "x2", "type": "float"}, {"name": "y2", "type": "float"}], "body": "                                                                              {\n        return RectangleFloat.create(x1, y1, x2, y2);\n    }", "signature": "public static Rectangle rectangle(float x1, float y1, float x2, float y2)"}, {"syntax_pass": true, "original_string": "    public static Rectangle rectangleGeographic(double lon1, double lat1, double lon2,\n            double lat2) {\n        return rectangleGeographic((float) lon1, (float) lat1, (float) lon2, (float) lat2);\n    }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Rectangle", "classes": []}, "name": "rectangleGeographic", "params": [{"name": "lon1", "type": "double"}, {"name": "lat1", "type": "double"}, {"name": "lon2", "type": "double"}, {"name": "lat2", "type": "double"}], "body": "                         {\n        return rectangleGeographic((float) lon1, (float) lat1, (float) lon2, (float) lat2);\n    }", "signature": "public static Rectangle rectangleGeographic(double lon1, double lat1, double lon2,\n            double lat2)"}, {"syntax_pass": true, "original_string": "    public static Rectangle rectangleGeographic(float lon1, float lat1, float lon2, float lat2) {\n        float x1 = normalizeLongitude(lon1);\n        float x2 = normalizeLongitude(lon2);\n        if (x2 < x1) {\n            x2 += 360;\n        }\n        return rectangle(x1, lat1, x2, lat2);\n    }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Rectangle", "classes": []}, "name": "rectangleGeographic", "params": [{"name": "lon1", "type": "float"}, {"name": "lat1", "type": "float"}, {"name": "lon2", "type": "float"}, {"name": "lat2", "type": "float"}], "body": "                                                                                                {\n        float x1 = normalizeLongitude(lon1);\n        float x2 = normalizeLongitude(lon2);\n        if (x2 < x1) {\n            x2 += 360;\n        }\n        return rectangle(x1, lat1, x2, lat2);\n    }", "signature": "public static Rectangle rectangleGeographic(float lon1, float lat1, float lon2, float lat2)"}, {"syntax_pass": true, "original_string": "    private static Rectangle rectangleDouble(double x1, double y1, double x2, double y2) {\n        return  RectangleDouble.create(x1, y1, x2, y2);\n    }", "docstring": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "Rectangle", "classes": []}, "name": "rectangleDouble", "params": [{"name": "x1", "type": "double"}, {"name": "y1", "type": "double"}, {"name": "x2", "type": "double"}, {"name": "y2", "type": "double"}], "body": "                                                                                         {\n        return  RectangleDouble.create(x1, y1, x2, y2);\n    }", "signature": "private static Rectangle rectangleDouble(double x1, double y1, double x2, double y2)"}, {"syntax_pass": true, "original_string": "    public static Circle circle(double x, double y, double radius) {\n        return CircleDouble.create(x, y, radius);\n    }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Circle", "classes": []}, "name": "circle", "params": [{"name": "x", "type": "double"}, {"name": "y", "type": "double"}, {"name": "radius", "type": "double"}], "body": "                                                                   {\n        return CircleDouble.create(x, y, radius);\n    }", "signature": "public static Circle circle(double x, double y, double radius)"}, {"syntax_pass": true, "original_string": "    public static Circle circle(float x, float y, float radius) {\n        return CircleFloat.create(x, y, radius);\n    }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Circle", "classes": []}, "name": "circle", "params": [{"name": "x", "type": "float"}, {"name": "y", "type": "float"}, {"name": "radius", "type": "float"}], "body": "                                                                {\n        return CircleFloat.create(x, y, radius);\n    }", "signature": "public static Circle circle(float x, float y, float radius)"}, {"syntax_pass": true, "original_string": "    public static Line line(double x1, double y1, double x2, double y2) {\n        return LineDouble.create(x1, y1, x2, y2);\n    }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Line", "classes": []}, "name": "line", "params": [{"name": "x1", "type": "double"}, {"name": "y1", "type": "double"}, {"name": "x2", "type": "double"}, {"name": "y2", "type": "double"}], "body": "                                                                        {\n        return LineDouble.create(x1, y1, x2, y2);\n    }", "signature": "public static Line line(double x1, double y1, double x2, double y2)"}, {"syntax_pass": true, "original_string": "    public static Line line(float x1, float y1, float x2, float y2) {\n        return LineFloat.create(x1, y1, x2, y2);\n    }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Line", "classes": []}, "name": "line", "params": [{"name": "x1", "type": "float"}, {"name": "y1", "type": "float"}, {"name": "x2", "type": "float"}, {"name": "y2", "type": "float"}], "body": "                                                                    {\n        return LineFloat.create(x1, y1, x2, y2);\n    }", "signature": "public static Line line(float x1, float y1, float x2, float y2)"}, {"syntax_pass": true, "original_string": "    @VisibleForTesting\n    static double normalizeLongitude(double d) {\n        return normalizeLongitude((float) d);\n    }", "docstring": "", "attributes": {"modifiers": "@VisibleForTesting\n    static", "marker_annotations": ["@VisibleForTesting"], "non_marker_annotations": ["static"], "comments": [], "return_type": "double", "classes": []}, "name": "normalizeLongitude", "params": [{"name": "d", "type": "double"}], "body": "                                               {\n        return normalizeLongitude((float) d);\n    }", "signature": "@VisibleForTesting\n    static double normalizeLongitude(double d)"}, {"syntax_pass": true, "original_string": "    private static float normalizeLongitude(float d) {\n        if (d == -180.0f)\n            return -180.0f;\n        else {\n            float sign = Math.signum(d);\n            float x = Math.abs(d) / 360;\n            float x2 = (x - (float) Math.floor(x)) * 360;\n            if (x2 >= 180)\n                x2 -= 360;\n            return x2 * sign;\n        }\n    }", "docstring": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "float", "classes": []}, "name": "normalizeLongitude", "params": [{"name": "d", "type": "float"}], "body": "                                                     {\n        if (d == -180.0f)\n            return -180.0f;\n        else {\n            float sign = Math.signum(d);\n            float x = Math.abs(d) / 360;\n            float x2 = (x - (float) Math.floor(x)) * 360;\n            if (x2 >= 180)\n                x2 -= 360;\n            return x2 * sign;\n        }\n    }", "signature": "private static float normalizeLongitude(float d)"}, {"syntax_pass": true, "original_string": "    private static double normalizeLongitudeDouble(double d) {\n        if (d == -180.0f)\n            return -180.0d;\n        else {\n            double sign = Math.signum(d);\n            double x = Math.abs(d) / 360;\n            double x2 = (x - (float) Math.floor(x)) * 360;\n            if (x2 >= 180)\n                x2 -= 360;\n            return x2 * sign;\n        }\n    }", "docstring": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "double", "classes": []}, "name": "normalizeLongitudeDouble", "params": [{"name": "d", "type": "double"}], "body": "                                                             {\n        if (d == -180.0f)\n            return -180.0d;\n        else {\n            double sign = Math.signum(d);\n            double x = Math.abs(d) / 360;\n            double x2 = (x - (float) Math.floor(x)) * 360;\n            if (x2 >= 180)\n                x2 -= 360;\n            return x2 * sign;\n        }\n    }", "signature": "private static double normalizeLongitudeDouble(double d)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/com/github/davidmoten/rtree/geometry/ListPair.java", "original_string": "package com.github.davidmoten.rtree.geometry;\n\nimport java.util.List;\n\n/**\n *\n * Not thread safe.\n *\n * @param <T>\n *            list type\n */\npublic final class ListPair<T extends HasGeometry> {\n    private final Group<T> group1;\n    private final Group<T> group2;\n    // these non-final variable mean that this class is not thread-safe\n    // because access to them is not synchronized\n    private double areaSum = -1;\n    private final double marginSum;\n\n    public ListPair(List<T> list1, List<T> list2) {\n        this.group1 = new Group<T>(list1);\n        this.group2 = new Group<T>(list2);\n        this.marginSum = group1.geometry().mbr().perimeter() + group2.geometry().mbr().perimeter();\n    }\n\n    public Group<T> group1() {\n        return group1;\n    }\n\n    public Group<T> group2() {\n        return group2;\n    }\n\n    public double areaSum() {\n        if (areaSum == -1)\n            areaSum = group1.geometry().mbr().area() + group2.geometry().mbr().area();\n        return areaSum;\n    }\n\n    public double marginSum() {\n        return marginSum;\n    }\n\n}\n", "file_hash": "003d7cf5b2f5010d1c38d34a39fe6f6fb06a3ad086405b350314fbf89b7ecb56", "file_docstring": "", "contexts": ["package com.github.davidmoten.rtree.geometry;", "import java.util.List;"], "methods": [], "classes": [{"original_string": "public final class ListPair<T extends HasGeometry> {\n    private final Group<T> group1;\n    private final Group<T> group2;\n    // these non-final variable mean that this class is not thread-safe\n    // because access to them is not synchronized\n    private double areaSum = -1;\n    private final double marginSum;\n\n    public ListPair(List<T> list1, List<T> list2) {\n        this.group1 = new Group<T>(list1);\n        this.group2 = new Group<T>(list2);\n        this.marginSum = group1.geometry().mbr().perimeter() + group2.geometry().mbr().perimeter();\n    }\n\n    public Group<T> group1() {\n        return group1;\n    }\n\n    public Group<T> group2() {\n        return group2;\n    }\n\n    public double areaSum() {\n        if (areaSum == -1)\n            areaSum = group1.geometry().mbr().area() + group2.geometry().mbr().area();\n        return areaSum;\n    }\n\n    public double marginSum() {\n        return marginSum;\n    }\n\n}", "definition": "public final class ListPair<T extends HasGeometry>", "class_docstring": "\n\nNot thread safe.\n\n@param <T>\n           list type\n", "name": "ListPair", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "fields": [{"attribute_expression": "private final Group<T> group1;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Group<T>", "name": "group1", "syntax_pass": true}, {"attribute_expression": "private final Group<T> group2;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Group<T>", "name": "group2", "syntax_pass": true}, {"attribute_expression": "private double areaSum = -1;", "docstring": " because access to them is not synchronized", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "double", "name": "areaSum = -1", "syntax_pass": true}, {"attribute_expression": "private final double marginSum;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "double", "name": "marginSum", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    public ListPair(List<T> list1, List<T> list2) {\n        this.group1 = new Group<T>(list1);\n        this.group2 = new Group<T>(list2);\n        this.marginSum = group1.geometry().mbr().perimeter() + group2.geometry().mbr().perimeter();\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "ListPair", "params": [{"name": "list1", "type": "List<T>"}, {"name": "list2", "type": "List<T>"}], "body": "                                                  {\n        this.group1 = new Group<T>(list1);\n        this.group2 = new Group<T>(list2);\n        this.marginSum = group1.geometry().mbr().perimeter() + group2.geometry().mbr().perimeter();\n    }", "signature": "public ListPair(List<T> list1, List<T> list2)"}, {"syntax_pass": true, "original_string": "    public Group<T> group1() {\n        return group1;\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Group<T>", "classes": []}, "name": "group1", "params": [], "body": "                             {\n        return group1;\n    }", "signature": "public Group<T> group1()"}, {"syntax_pass": true, "original_string": "    public Group<T> group2() {\n        return group2;\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Group<T>", "classes": []}, "name": "group2", "params": [], "body": "                             {\n        return group2;\n    }", "signature": "public Group<T> group2()"}, {"syntax_pass": true, "original_string": "    public double areaSum() {\n        if (areaSum == -1)\n            areaSum = group1.geometry().mbr().area() + group2.geometry().mbr().area();\n        return areaSum;\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "double", "classes": []}, "name": "areaSum", "params": [], "body": "                            {\n        if (areaSum == -1)\n            areaSum = group1.geometry().mbr().area() + group2.geometry().mbr().area();\n        return areaSum;\n    }", "signature": "public double areaSum()"}, {"syntax_pass": true, "original_string": "    public double marginSum() {\n        return marginSum;\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "double", "classes": []}, "name": "marginSum", "params": [], "body": "                              {\n        return marginSum;\n    }", "signature": "public double marginSum()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/com/github/davidmoten/rtree/geometry/HasGeometry.java", "original_string": "package com.github.davidmoten.rtree.geometry;\n\npublic interface HasGeometry {\n\n    Geometry geometry();\n}\n", "file_hash": "1e2c1e8c7a2b91aa4582c0fb592b0d9ed7f1dfc776f0fbf8dd76e7ee51947ebc", "file_docstring": "", "contexts": ["package com.github.davidmoten.rtree.geometry;"], "methods": [], "classes": [], "interfaces": [{"original_string": "public interface HasGeometry {\n\n    Geometry geometry();\n}", "definition": "public interface HasGeometry", "interface_docstring": "", "name": "HasGeometry", "extends_interfaces": [], "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    Geometry geometry();", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "Geometry", "classes": []}, "name": "geometry", "params": [], "body": "", "signature": "Geometry geometry()"}]}], "records": []}, {"relative_path": "src/main/java/com/github/davidmoten/rtree/geometry/Point.java", "original_string": "package com.github.davidmoten.rtree.geometry;\n\npublic interface Point extends Rectangle {\n\n    double x();\n\n    double y();\n\n}\n", "file_hash": "aeb17aec030761690f27ffad730befd8655a06677196a26dbc79b4b46b5658ed", "file_docstring": "", "contexts": ["package com.github.davidmoten.rtree.geometry;"], "methods": [], "classes": [], "interfaces": [{"original_string": "public interface Point extends Rectangle {\n\n    double x();\n\n    double y();\n\n}", "definition": "public interface Point extends Rectangle", "interface_docstring": "", "name": "Point", "extends_interfaces": ["Rectangle"], "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    double x();", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "double", "classes": []}, "name": "x", "params": [], "body": "", "signature": "double x()"}, {"syntax_pass": true, "original_string": "    double y();", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "double", "classes": []}, "name": "y", "params": [], "body": "", "signature": "double y()"}]}], "records": []}, {"relative_path": "src/main/java/com/github/davidmoten/rtree/geometry/Rectangle.java", "original_string": "package com.github.davidmoten.rtree.geometry;\n\npublic interface Rectangle extends Geometry, HasGeometry {\n\n    double x1();\n\n    double y1();\n\n    double x2();\n\n    double y2();\n\n    double area();\n\n    double intersectionArea(Rectangle r);\n\n    double perimeter();\n\n    Rectangle add(Rectangle r);\n\n    boolean contains(double x, double y);\n    \n    boolean isDoublePrecision();\n\n}", "file_hash": "b82d4ed6916e3dab804352d95ca73e3e6bf8a39b3fdf7a4d46618de85a767dd0", "file_docstring": "", "contexts": ["package com.github.davidmoten.rtree.geometry;"], "methods": [], "classes": [], "interfaces": [{"original_string": "public interface Rectangle extends Geometry, HasGeometry {\n\n    double x1();\n\n    double y1();\n\n    double x2();\n\n    double y2();\n\n    double area();\n\n    double intersectionArea(Rectangle r);\n\n    double perimeter();\n\n    Rectangle add(Rectangle r);\n\n    boolean contains(double x, double y);\n    \n    boolean isDoublePrecision();\n\n}", "definition": "public interface Rectangle extends Geometry, HasGeometry", "interface_docstring": "", "name": "Rectangle", "extends_interfaces": ["Geometry", "HasGeometry"], "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    double x1();", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "double", "classes": []}, "name": "x1", "params": [], "body": "", "signature": "double x1()"}, {"syntax_pass": true, "original_string": "    double y1();", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "double", "classes": []}, "name": "y1", "params": [], "body": "", "signature": "double y1()"}, {"syntax_pass": true, "original_string": "    double x2();", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "double", "classes": []}, "name": "x2", "params": [], "body": "", "signature": "double x2()"}, {"syntax_pass": true, "original_string": "    double y2();", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "double", "classes": []}, "name": "y2", "params": [], "body": "", "signature": "double y2()"}, {"syntax_pass": true, "original_string": "    double area();", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "double", "classes": []}, "name": "area", "params": [], "body": "", "signature": "double area()"}, {"syntax_pass": true, "original_string": "    double intersectionArea(Rectangle r);", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "double", "classes": []}, "name": "intersectionArea", "params": [{"name": "r", "type": "Rectangle"}], "body": "", "signature": "double intersectionArea(Rectangle r)"}, {"syntax_pass": true, "original_string": "    double perimeter();", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "double", "classes": []}, "name": "perimeter", "params": [], "body": "", "signature": "double perimeter()"}, {"syntax_pass": true, "original_string": "    Rectangle add(Rectangle r);", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "Rectangle", "classes": []}, "name": "add", "params": [{"name": "r", "type": "Rectangle"}], "body": "", "signature": "Rectangle add(Rectangle r)"}, {"syntax_pass": true, "original_string": "    boolean contains(double x, double y);", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "boolean", "classes": []}, "name": "contains", "params": [{"name": "x", "type": "double"}, {"name": "y", "type": "double"}], "body": "", "signature": "boolean contains(double x, double y)"}, {"syntax_pass": true, "original_string": "    boolean isDoublePrecision();", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "boolean", "classes": []}, "name": "isDoublePrecision", "params": [], "body": "", "signature": "boolean isDoublePrecision()"}]}], "records": []}, {"relative_path": "src/main/java/com/github/davidmoten/rtree/geometry/Circle.java", "original_string": "package com.github.davidmoten.rtree.geometry;\n\npublic interface Circle extends Geometry {\n\n    double x();\n\n    double y();\n\n    double radius();\n\n    boolean intersects(Circle c);\n\n    boolean intersects(Point point);\n\n    boolean intersects(Line line);\n\n}", "file_hash": "bd5312a0406e343f513cc5660ae9661f90a02746b51a5ac657b3708e04e60f2b", "file_docstring": "", "contexts": ["package com.github.davidmoten.rtree.geometry;"], "methods": [], "classes": [], "interfaces": [{"original_string": "public interface Circle extends Geometry {\n\n    double x();\n\n    double y();\n\n    double radius();\n\n    boolean intersects(Circle c);\n\n    boolean intersects(Point point);\n\n    boolean intersects(Line line);\n\n}", "definition": "public interface Circle extends Geometry", "interface_docstring": "", "name": "Circle", "extends_interfaces": ["Geometry"], "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    double x();", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "double", "classes": []}, "name": "x", "params": [], "body": "", "signature": "double x()"}, {"syntax_pass": true, "original_string": "    double y();", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "double", "classes": []}, "name": "y", "params": [], "body": "", "signature": "double y()"}, {"syntax_pass": true, "original_string": "    double radius();", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "double", "classes": []}, "name": "radius", "params": [], "body": "", "signature": "double radius()"}, {"syntax_pass": true, "original_string": "    boolean intersects(Circle c);", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "boolean", "classes": []}, "name": "intersects", "params": [{"name": "c", "type": "Circle"}], "body": "", "signature": "boolean intersects(Circle c)"}, {"syntax_pass": true, "original_string": "    boolean intersects(Point point);", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "boolean", "classes": []}, "name": "intersects", "params": [{"name": "point", "type": "Point"}], "body": "", "signature": "boolean intersects(Point point)"}, {"syntax_pass": true, "original_string": "    boolean intersects(Line line);", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "boolean", "classes": []}, "name": "intersects", "params": [{"name": "line", "type": "Line"}], "body": "", "signature": "boolean intersects(Line line)"}]}], "records": []}, {"relative_path": "src/main/java/com/github/davidmoten/rtree/geometry/Intersects.java", "original_string": "package com.github.davidmoten.rtree.geometry;\n\nimport rx.functions.Func2;\n\npublic final class Intersects {\n\n    private Intersects() {\n        // prevent instantiation\n    }\n\n    public static final Func2<Rectangle, Circle, Boolean> rectangleIntersectsCircle = new Func2<Rectangle, Circle, Boolean>() {\n        @Override\n        public Boolean call(Rectangle rectangle, Circle circle) {\n            return circleIntersectsRectangle.call(circle, rectangle);\n        }\n    };\n\n    public static final Func2<Circle, Rectangle, Boolean> circleIntersectsRectangle = new Func2<Circle, Rectangle, Boolean>() {\n        @Override\n        public Boolean call(Circle circle, Rectangle rectangle) {\n            return circle.intersects(rectangle);\n        }\n    };\n\n    public static final Func2<Point, Circle, Boolean> pointIntersectsCircle = new Func2<Point, Circle, Boolean>() {\n        @Override\n        public Boolean call(Point point, Circle circle) {\n            return circleIntersectsPoint.call(circle, point);\n        }\n    };\n\n    public static final Func2<Circle, Point, Boolean> circleIntersectsPoint = new Func2<Circle, Point, Boolean>() {\n        @Override\n        public Boolean call(Circle circle, Point point) {\n            return circle.intersects(point);\n        }\n    };\n\n    public static final Func2<Circle, Circle, Boolean> circleIntersectsCircle = new Func2<Circle, Circle, Boolean>() {\n        @Override\n        public Boolean call(Circle a, Circle b) {\n            return a.intersects(b);\n        }\n    };\n\n    public static final Func2<Line, Line, Boolean> lineIntersectsLine = new Func2<Line, Line, Boolean>() {\n        @Override\n        public Boolean call(Line a, Line b) {\n            return a.intersects(b);\n        }\n    };\n\n    public static final Func2<Line, Rectangle, Boolean> lineIntersectsRectangle = new Func2<Line, Rectangle, Boolean>() {\n        @Override\n        public Boolean call(Line a, Rectangle r) {\n            return rectangleIntersectsLine.call(r, a);\n        }\n    };\n\n    public static final Func2<Rectangle, Line, Boolean> rectangleIntersectsLine = new Func2<Rectangle, Line, Boolean>() {\n        @Override\n        public Boolean call(Rectangle r, Line a) {\n            return a.intersects(r);\n        }\n    };\n\n    public static final Func2<Line, Circle, Boolean> lineIntersectsCircle = new Func2<Line, Circle, Boolean>() {\n        @Override\n        public Boolean call(Line a, Circle c) {\n            return circleIntersectsLine.call(c, a);\n        }\n    };\n\n    public static final Func2<Circle, Line, Boolean> circleIntersectsLine = new Func2<Circle, Line, Boolean>() {\n        @Override\n        public Boolean call(Circle c, Line a) {\n            return a.intersects(c);\n        }\n    };\n\n    public static final Func2<Line, Point, Boolean> lineIntersectsPoint = new Func2<Line, Point, Boolean>() {\n\n        @Override\n        public Boolean call(Line line, Point point) {\n            return pointIntersectsLine.call(point, line);\n        }\n    };\n\n    public static final Func2<Point, Line, Boolean> pointIntersectsLine = new Func2<Point, Line, Boolean>() {\n\n        @Override\n        public Boolean call(Point point, Line line) {\n            return line.intersects(point);\n        }\n    };\n\n    public static final Func2<Geometry, Line, Boolean> geometryIntersectsLine = new Func2<Geometry, Line, Boolean>() {\n\n        @Override\n        public Boolean call(Geometry geometry, Line line) {\n            if (geometry instanceof Line)\n                return line.intersects((Line) geometry);\n            else if (geometry instanceof Circle)\n                return line.intersects((Circle) geometry);\n            else if (geometry instanceof Point)\n                return line.intersects((Point) geometry);\n            else if (geometry instanceof Rectangle)\n                return line.intersects((Rectangle) geometry);\n            else\n                throw new RuntimeException(\"unrecognized geometry: \" + geometry);\n        }\n    };\n\n    public static final Func2<Geometry, Circle, Boolean> geometryIntersectsCircle = new Func2<Geometry, Circle, Boolean>() {\n\n        @Override\n        public Boolean call(Geometry geometry, Circle circle) {\n            if (geometry instanceof Line)\n                return circle.intersects((Line) geometry);\n            else if (geometry instanceof Circle)\n                return circle.intersects((Circle) geometry);\n            else if (geometry instanceof Point)\n                return circle.intersects((Point) geometry);\n            else if (geometry instanceof Rectangle)\n                return circle.intersects((Rectangle) geometry);\n            else\n                throw new RuntimeException(\"unrecognized geometry: \" + geometry);\n        }\n    };\n\n    public static final Func2<Circle, Geometry, Boolean> circleIntersectsGeometry = new Func2<Circle, Geometry, Boolean>() {\n\n        @Override\n        public Boolean call(Circle circle, Geometry geometry) {\n            return geometryIntersectsCircle.call(geometry, circle);\n        }\n    };\n\n    public static final Func2<Geometry, Rectangle, Boolean> geometryIntersectsRectangle = new Func2<Geometry, Rectangle, Boolean>() {\n\n        @Override\n        public Boolean call(Geometry geometry, Rectangle r) {\n            if (geometry instanceof Line)\n                return geometry.intersects(r);\n            else if (geometry instanceof Circle)\n                return geometry.intersects(r);\n            else if (geometry instanceof Point)\n                return geometry.intersects(r);\n            else if (geometry instanceof Rectangle)\n                return r.intersects((Rectangle) geometry);\n            else\n                throw new RuntimeException(\"unrecognized geometry: \" + geometry);\n        }\n    };\n\n    public static final Func2<Rectangle, Geometry, Boolean> rectangleIntersectsGeometry = new Func2<Rectangle, Geometry, Boolean>() {\n\n        @Override\n        public Boolean call(Rectangle r, Geometry geometry) {\n            return geometryIntersectsRectangle.call(geometry, r);\n        }\n    };\n\n    public static final Func2<Geometry, Point, Boolean> geometryIntersectsPoint = new Func2<Geometry, Point, Boolean>() {\n\n        @Override\n        public Boolean call(Geometry geometry, Point point) {\n            return geometryIntersectsRectangle.call(geometry, point.mbr());\n        }\n    };\n\n    public static final Func2<Point, Geometry, Boolean> pointIntersectsGeometry = new Func2<Point, Geometry, Boolean>() {\n\n        @Override\n        public Boolean call(Point point, Geometry geometry) {\n            return geometryIntersectsPoint.call(geometry, point);\n        }\n    };\n\n}\n", "file_hash": "1bcb60a65f0b8e4211498530a7ef50fedcbf4e8c0869edf649fc7119935e462f", "file_docstring": "", "contexts": ["package com.github.davidmoten.rtree.geometry;", "import rx.functions.Func2;"], "methods": [], "classes": [{"original_string": "public final class Intersects {\n\n    private Intersects() {\n        // prevent instantiation\n    }\n\n    public static final Func2<Rectangle, Circle, Boolean> rectangleIntersectsCircle = new Func2<Rectangle, Circle, Boolean>() {\n        @Override\n        public Boolean call(Rectangle rectangle, Circle circle) {\n            return circleIntersectsRectangle.call(circle, rectangle);\n        }\n    };\n\n    public static final Func2<Circle, Rectangle, Boolean> circleIntersectsRectangle = new Func2<Circle, Rectangle, Boolean>() {\n        @Override\n        public Boolean call(Circle circle, Rectangle rectangle) {\n            return circle.intersects(rectangle);\n        }\n    };\n\n    public static final Func2<Point, Circle, Boolean> pointIntersectsCircle = new Func2<Point, Circle, Boolean>() {\n        @Override\n        public Boolean call(Point point, Circle circle) {\n            return circleIntersectsPoint.call(circle, point);\n        }\n    };\n\n    public static final Func2<Circle, Point, Boolean> circleIntersectsPoint = new Func2<Circle, Point, Boolean>() {\n        @Override\n        public Boolean call(Circle circle, Point point) {\n            return circle.intersects(point);\n        }\n    };\n\n    public static final Func2<Circle, Circle, Boolean> circleIntersectsCircle = new Func2<Circle, Circle, Boolean>() {\n        @Override\n        public Boolean call(Circle a, Circle b) {\n            return a.intersects(b);\n        }\n    };\n\n    public static final Func2<Line, Line, Boolean> lineIntersectsLine = new Func2<Line, Line, Boolean>() {\n        @Override\n        public Boolean call(Line a, Line b) {\n            return a.intersects(b);\n        }\n    };\n\n    public static final Func2<Line, Rectangle, Boolean> lineIntersectsRectangle = new Func2<Line, Rectangle, Boolean>() {\n        @Override\n        public Boolean call(Line a, Rectangle r) {\n            return rectangleIntersectsLine.call(r, a);\n        }\n    };\n\n    public static final Func2<Rectangle, Line, Boolean> rectangleIntersectsLine = new Func2<Rectangle, Line, Boolean>() {\n        @Override\n        public Boolean call(Rectangle r, Line a) {\n            return a.intersects(r);\n        }\n    };\n\n    public static final Func2<Line, Circle, Boolean> lineIntersectsCircle = new Func2<Line, Circle, Boolean>() {\n        @Override\n        public Boolean call(Line a, Circle c) {\n            return circleIntersectsLine.call(c, a);\n        }\n    };\n\n    public static final Func2<Circle, Line, Boolean> circleIntersectsLine = new Func2<Circle, Line, Boolean>() {\n        @Override\n        public Boolean call(Circle c, Line a) {\n            return a.intersects(c);\n        }\n    };\n\n    public static final Func2<Line, Point, Boolean> lineIntersectsPoint = new Func2<Line, Point, Boolean>() {\n\n        @Override\n        public Boolean call(Line line, Point point) {\n            return pointIntersectsLine.call(point, line);\n        }\n    };\n\n    public static final Func2<Point, Line, Boolean> pointIntersectsLine = new Func2<Point, Line, Boolean>() {\n\n        @Override\n        public Boolean call(Point point, Line line) {\n            return line.intersects(point);\n        }\n    };\n\n    public static final Func2<Geometry, Line, Boolean> geometryIntersectsLine = new Func2<Geometry, Line, Boolean>() {\n\n        @Override\n        public Boolean call(Geometry geometry, Line line) {\n            if (geometry instanceof Line)\n                return line.intersects((Line) geometry);\n            else if (geometry instanceof Circle)\n                return line.intersects((Circle) geometry);\n            else if (geometry instanceof Point)\n                return line.intersects((Point) geometry);\n            else if (geometry instanceof Rectangle)\n                return line.intersects((Rectangle) geometry);\n            else\n                throw new RuntimeException(\"unrecognized geometry: \" + geometry);\n        }\n    };\n\n    public static final Func2<Geometry, Circle, Boolean> geometryIntersectsCircle = new Func2<Geometry, Circle, Boolean>() {\n\n        @Override\n        public Boolean call(Geometry geometry, Circle circle) {\n            if (geometry instanceof Line)\n                return circle.intersects((Line) geometry);\n            else if (geometry instanceof Circle)\n                return circle.intersects((Circle) geometry);\n            else if (geometry instanceof Point)\n                return circle.intersects((Point) geometry);\n            else if (geometry instanceof Rectangle)\n                return circle.intersects((Rectangle) geometry);\n            else\n                throw new RuntimeException(\"unrecognized geometry: \" + geometry);\n        }\n    };\n\n    public static final Func2<Circle, Geometry, Boolean> circleIntersectsGeometry = new Func2<Circle, Geometry, Boolean>() {\n\n        @Override\n        public Boolean call(Circle circle, Geometry geometry) {\n            return geometryIntersectsCircle.call(geometry, circle);\n        }\n    };\n\n    public static final Func2<Geometry, Rectangle, Boolean> geometryIntersectsRectangle = new Func2<Geometry, Rectangle, Boolean>() {\n\n        @Override\n        public Boolean call(Geometry geometry, Rectangle r) {\n            if (geometry instanceof Line)\n                return geometry.intersects(r);\n            else if (geometry instanceof Circle)\n                return geometry.intersects(r);\n            else if (geometry instanceof Point)\n                return geometry.intersects(r);\n            else if (geometry instanceof Rectangle)\n                return r.intersects((Rectangle) geometry);\n            else\n                throw new RuntimeException(\"unrecognized geometry: \" + geometry);\n        }\n    };\n\n    public static final Func2<Rectangle, Geometry, Boolean> rectangleIntersectsGeometry = new Func2<Rectangle, Geometry, Boolean>() {\n\n        @Override\n        public Boolean call(Rectangle r, Geometry geometry) {\n            return geometryIntersectsRectangle.call(geometry, r);\n        }\n    };\n\n    public static final Func2<Geometry, Point, Boolean> geometryIntersectsPoint = new Func2<Geometry, Point, Boolean>() {\n\n        @Override\n        public Boolean call(Geometry geometry, Point point) {\n            return geometryIntersectsRectangle.call(geometry, point.mbr());\n        }\n    };\n\n    public static final Func2<Point, Geometry, Boolean> pointIntersectsGeometry = new Func2<Point, Geometry, Boolean>() {\n\n        @Override\n        public Boolean call(Point point, Geometry geometry) {\n            return geometryIntersectsPoint.call(geometry, point);\n        }\n    };\n\n}", "definition": "public final class Intersects", "class_docstring": "", "name": "Intersects", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "fields": [{"attribute_expression": "public static final Func2<Rectangle, Circle, Boolean> rectangleIntersectsCircle = new Func2<Rectangle, Circle, Boolean>() {\n        @Override\n        public Boolean call(Rectangle rectangle, Circle circle) {\n            return circleIntersectsRectangle.call(circle, rectangle);\n        }\n    };", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "Func2<Rectangle, Circle, Boolean>", "name": "rectangleIntersectsCircle = new Func2<Rectangle, Circle, Boolean>() {\n        @Override\n        public Boolean call(Rectangle rectangle, Circle circle) {\n            return circleIntersectsRectangle.call(circle, rectangle);\n        }\n    }", "syntax_pass": true}, {"attribute_expression": "public static final Func2<Circle, Rectangle, Boolean> circleIntersectsRectangle = new Func2<Circle, Rectangle, Boolean>() {\n        @Override\n        public Boolean call(Circle circle, Rectangle rectangle) {\n            return circle.intersects(rectangle);\n        }\n    };", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "Func2<Circle, Rectangle, Boolean>", "name": "circleIntersectsRectangle = new Func2<Circle, Rectangle, Boolean>() {\n        @Override\n        public Boolean call(Circle circle, Rectangle rectangle) {\n            return circle.intersects(rectangle);\n        }\n    }", "syntax_pass": true}, {"attribute_expression": "public static final Func2<Point, Circle, Boolean> pointIntersectsCircle = new Func2<Point, Circle, Boolean>() {\n        @Override\n        public Boolean call(Point point, Circle circle) {\n            return circleIntersectsPoint.call(circle, point);\n        }\n    };", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "Func2<Point, Circle, Boolean>", "name": "pointIntersectsCircle = new Func2<Point, Circle, Boolean>() {\n        @Override\n        public Boolean call(Point point, Circle circle) {\n            return circleIntersectsPoint.call(circle, point);\n        }\n    }", "syntax_pass": true}, {"attribute_expression": "public static final Func2<Circle, Point, Boolean> circleIntersectsPoint = new Func2<Circle, Point, Boolean>() {\n        @Override\n        public Boolean call(Circle circle, Point point) {\n            return circle.intersects(point);\n        }\n    };", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "Func2<Circle, Point, Boolean>", "name": "circleIntersectsPoint = new Func2<Circle, Point, Boolean>() {\n        @Override\n        public Boolean call(Circle circle, Point point) {\n            return circle.intersects(point);\n        }\n    }", "syntax_pass": true}, {"attribute_expression": "public static final Func2<Circle, Circle, Boolean> circleIntersectsCircle = new Func2<Circle, Circle, Boolean>() {\n        @Override\n        public Boolean call(Circle a, Circle b) {\n            return a.intersects(b);\n        }\n    };", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "Func2<Circle, Circle, Boolean>", "name": "circleIntersectsCircle = new Func2<Circle, Circle, Boolean>() {\n        @Override\n        public Boolean call(Circle a, Circle b) {\n            return a.intersects(b);\n        }\n    }", "syntax_pass": true}, {"attribute_expression": "public static final Func2<Line, Line, Boolean> lineIntersectsLine = new Func2<Line, Line, Boolean>() {\n        @Override\n        public Boolean call(Line a, Line b) {\n            return a.intersects(b);\n        }\n    };", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "Func2<Line, Line, Boolean>", "name": "lineIntersectsLine = new Func2<Line, Line, Boolean>() {\n        @Override\n        public Boolean call(Line a, Line b) {\n            return a.intersects(b);\n        }\n    }", "syntax_pass": true}, {"attribute_expression": "public static final Func2<Line, Rectangle, Boolean> lineIntersectsRectangle = new Func2<Line, Rectangle, Boolean>() {\n        @Override\n        public Boolean call(Line a, Rectangle r) {\n            return rectangleIntersectsLine.call(r, a);\n        }\n    };", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "Func2<Line, Rectangle, Boolean>", "name": "lineIntersectsRectangle = new Func2<Line, Rectangle, Boolean>() {\n        @Override\n        public Boolean call(Line a, Rectangle r) {\n            return rectangleIntersectsLine.call(r, a);\n        }\n    }", "syntax_pass": true}, {"attribute_expression": "public static final Func2<Rectangle, Line, Boolean> rectangleIntersectsLine = new Func2<Rectangle, Line, Boolean>() {\n        @Override\n        public Boolean call(Rectangle r, Line a) {\n            return a.intersects(r);\n        }\n    };", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "Func2<Rectangle, Line, Boolean>", "name": "rectangleIntersectsLine = new Func2<Rectangle, Line, Boolean>() {\n        @Override\n        public Boolean call(Rectangle r, Line a) {\n            return a.intersects(r);\n        }\n    }", "syntax_pass": true}, {"attribute_expression": "public static final Func2<Line, Circle, Boolean> lineIntersectsCircle = new Func2<Line, Circle, Boolean>() {\n        @Override\n        public Boolean call(Line a, Circle c) {\n            return circleIntersectsLine.call(c, a);\n        }\n    };", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "Func2<Line, Circle, Boolean>", "name": "lineIntersectsCircle = new Func2<Line, Circle, Boolean>() {\n        @Override\n        public Boolean call(Line a, Circle c) {\n            return circleIntersectsLine.call(c, a);\n        }\n    }", "syntax_pass": true}, {"attribute_expression": "public static final Func2<Circle, Line, Boolean> circleIntersectsLine = new Func2<Circle, Line, Boolean>() {\n        @Override\n        public Boolean call(Circle c, Line a) {\n            return a.intersects(c);\n        }\n    };", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "Func2<Circle, Line, Boolean>", "name": "circleIntersectsLine = new Func2<Circle, Line, Boolean>() {\n        @Override\n        public Boolean call(Circle c, Line a) {\n            return a.intersects(c);\n        }\n    }", "syntax_pass": true}, {"attribute_expression": "public static final Func2<Line, Point, Boolean> lineIntersectsPoint = new Func2<Line, Point, Boolean>() {\n\n        @Override\n        public Boolean call(Line line, Point point) {\n            return pointIntersectsLine.call(point, line);\n        }\n    };", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "Func2<Line, Point, Boolean>", "name": "lineIntersectsPoint = new Func2<Line, Point, Boolean>() {\n\n        @Override\n        public Boolean call(Line line, Point point) {\n            return pointIntersectsLine.call(point, line);\n        }\n    }", "syntax_pass": true}, {"attribute_expression": "public static final Func2<Point, Line, Boolean> pointIntersectsLine = new Func2<Point, Line, Boolean>() {\n\n        @Override\n        public Boolean call(Point point, Line line) {\n            return line.intersects(point);\n        }\n    };", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "Func2<Point, Line, Boolean>", "name": "pointIntersectsLine = new Func2<Point, Line, Boolean>() {\n\n        @Override\n        public Boolean call(Point point, Line line) {\n            return line.intersects(point);\n        }\n    }", "syntax_pass": true}, {"attribute_expression": "public static final Func2<Geometry, Line, Boolean> geometryIntersectsLine = new Func2<Geometry, Line, Boolean>() {\n\n        @Override\n        public Boolean call(Geometry geometry, Line line) {\n            if (geometry instanceof Line)\n                return line.intersects((Line) geometry);\n            else if (geometry instanceof Circle)\n                return line.intersects((Circle) geometry);\n            else if (geometry instanceof Point)\n                return line.intersects((Point) geometry);\n            else if (geometry instanceof Rectangle)\n                return line.intersects((Rectangle) geometry);\n            else\n                throw new RuntimeException(\"unrecognized geometry: \" + geometry);\n        }\n    };", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "Func2<Geometry, Line, Boolean>", "name": "geometryIntersectsLine = new Func2<Geometry, Line, Boolean>() {\n\n        @Override\n        public Boolean call(Geometry geometry, Line line) {\n            if (geometry instanceof Line)\n                return line.intersects((Line) geometry);\n            else if (geometry instanceof Circle)\n                return line.intersects((Circle) geometry);\n            else if (geometry instanceof Point)\n                return line.intersects((Point) geometry);\n            else if (geometry instanceof Rectangle)\n                return line.intersects((Rectangle) geometry);\n            else\n                throw new RuntimeException(\"unrecognized geometry: \" + geometry);\n        }\n    }", "syntax_pass": true}, {"attribute_expression": "public static final Func2<Geometry, Circle, Boolean> geometryIntersectsCircle = new Func2<Geometry, Circle, Boolean>() {\n\n        @Override\n        public Boolean call(Geometry geometry, Circle circle) {\n            if (geometry instanceof Line)\n                return circle.intersects((Line) geometry);\n            else if (geometry instanceof Circle)\n                return circle.intersects((Circle) geometry);\n            else if (geometry instanceof Point)\n                return circle.intersects((Point) geometry);\n            else if (geometry instanceof Rectangle)\n                return circle.intersects((Rectangle) geometry);\n            else\n                throw new RuntimeException(\"unrecognized geometry: \" + geometry);\n        }\n    };", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "Func2<Geometry, Circle, Boolean>", "name": "geometryIntersectsCircle = new Func2<Geometry, Circle, Boolean>() {\n\n        @Override\n        public Boolean call(Geometry geometry, Circle circle) {\n            if (geometry instanceof Line)\n                return circle.intersects((Line) geometry);\n            else if (geometry instanceof Circle)\n                return circle.intersects((Circle) geometry);\n            else if (geometry instanceof Point)\n                return circle.intersects((Point) geometry);\n            else if (geometry instanceof Rectangle)\n                return circle.intersects((Rectangle) geometry);\n            else\n                throw new RuntimeException(\"unrecognized geometry: \" + geometry);\n        }\n    }", "syntax_pass": true}, {"attribute_expression": "public static final Func2<Circle, Geometry, Boolean> circleIntersectsGeometry = new Func2<Circle, Geometry, Boolean>() {\n\n        @Override\n        public Boolean call(Circle circle, Geometry geometry) {\n            return geometryIntersectsCircle.call(geometry, circle);\n        }\n    };", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "Func2<Circle, Geometry, Boolean>", "name": "circleIntersectsGeometry = new Func2<Circle, Geometry, Boolean>() {\n\n        @Override\n        public Boolean call(Circle circle, Geometry geometry) {\n            return geometryIntersectsCircle.call(geometry, circle);\n        }\n    }", "syntax_pass": true}, {"attribute_expression": "public static final Func2<Geometry, Rectangle, Boolean> geometryIntersectsRectangle = new Func2<Geometry, Rectangle, Boolean>() {\n\n        @Override\n        public Boolean call(Geometry geometry, Rectangle r) {\n            if (geometry instanceof Line)\n                return geometry.intersects(r);\n            else if (geometry instanceof Circle)\n                return geometry.intersects(r);\n            else if (geometry instanceof Point)\n                return geometry.intersects(r);\n            else if (geometry instanceof Rectangle)\n                return r.intersects((Rectangle) geometry);\n            else\n                throw new RuntimeException(\"unrecognized geometry: \" + geometry);\n        }\n    };", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "Func2<Geometry, Rectangle, Boolean>", "name": "geometryIntersectsRectangle = new Func2<Geometry, Rectangle, Boolean>() {\n\n        @Override\n        public Boolean call(Geometry geometry, Rectangle r) {\n            if (geometry instanceof Line)\n                return geometry.intersects(r);\n            else if (geometry instanceof Circle)\n                return geometry.intersects(r);\n            else if (geometry instanceof Point)\n                return geometry.intersects(r);\n            else if (geometry instanceof Rectangle)\n                return r.intersects((Rectangle) geometry);\n            else\n                throw new RuntimeException(\"unrecognized geometry: \" + geometry);\n        }\n    }", "syntax_pass": true}, {"attribute_expression": "public static final Func2<Rectangle, Geometry, Boolean> rectangleIntersectsGeometry = new Func2<Rectangle, Geometry, Boolean>() {\n\n        @Override\n        public Boolean call(Rectangle r, Geometry geometry) {\n            return geometryIntersectsRectangle.call(geometry, r);\n        }\n    };", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "Func2<Rectangle, Geometry, Boolean>", "name": "rectangleIntersectsGeometry = new Func2<Rectangle, Geometry, Boolean>() {\n\n        @Override\n        public Boolean call(Rectangle r, Geometry geometry) {\n            return geometryIntersectsRectangle.call(geometry, r);\n        }\n    }", "syntax_pass": true}, {"attribute_expression": "public static final Func2<Geometry, Point, Boolean> geometryIntersectsPoint = new Func2<Geometry, Point, Boolean>() {\n\n        @Override\n        public Boolean call(Geometry geometry, Point point) {\n            return geometryIntersectsRectangle.call(geometry, point.mbr());\n        }\n    };", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "Func2<Geometry, Point, Boolean>", "name": "geometryIntersectsPoint = new Func2<Geometry, Point, Boolean>() {\n\n        @Override\n        public Boolean call(Geometry geometry, Point point) {\n            return geometryIntersectsRectangle.call(geometry, point.mbr());\n        }\n    }", "syntax_pass": true}, {"attribute_expression": "public static final Func2<Point, Geometry, Boolean> pointIntersectsGeometry = new Func2<Point, Geometry, Boolean>() {\n\n        @Override\n        public Boolean call(Point point, Geometry geometry) {\n            return geometryIntersectsPoint.call(geometry, point);\n        }\n    };", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "Func2<Point, Geometry, Boolean>", "name": "pointIntersectsGeometry = new Func2<Point, Geometry, Boolean>() {\n\n        @Override\n        public Boolean call(Point point, Geometry geometry) {\n            return geometryIntersectsPoint.call(geometry, point);\n        }\n    }", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    private Intersects() {\n        // prevent instantiation\n    }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "", "classes": []}, "name": "Intersects", "params": [], "body": "                         {\n        // prevent instantiation\n    }", "signature": "private Intersects()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/com/github/davidmoten/rtree/geometry/Line.java", "original_string": "package com.github.davidmoten.rtree.geometry;\n\npublic interface Line extends Geometry {\n\n    double x1();\n\n    double y1();\n\n    double x2();\n\n    double y2();\n\n    boolean intersects(Line b);\n\n    boolean intersects(Point point);\n\n    boolean intersects(Circle circle);\n\n}", "file_hash": "e8a2bc229f3775a0e5b038418665362b66bcb6841d019efaec4cfbe2bc14bf40", "file_docstring": "", "contexts": ["package com.github.davidmoten.rtree.geometry;"], "methods": [], "classes": [], "interfaces": [{"original_string": "public interface Line extends Geometry {\n\n    double x1();\n\n    double y1();\n\n    double x2();\n\n    double y2();\n\n    boolean intersects(Line b);\n\n    boolean intersects(Point point);\n\n    boolean intersects(Circle circle);\n\n}", "definition": "public interface Line extends Geometry", "interface_docstring": "", "name": "Line", "extends_interfaces": ["Geometry"], "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    double x1();", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "double", "classes": []}, "name": "x1", "params": [], "body": "", "signature": "double x1()"}, {"syntax_pass": true, "original_string": "    double y1();", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "double", "classes": []}, "name": "y1", "params": [], "body": "", "signature": "double y1()"}, {"syntax_pass": true, "original_string": "    double x2();", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "double", "classes": []}, "name": "x2", "params": [], "body": "", "signature": "double x2()"}, {"syntax_pass": true, "original_string": "    double y2();", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "double", "classes": []}, "name": "y2", "params": [], "body": "", "signature": "double y2()"}, {"syntax_pass": true, "original_string": "    boolean intersects(Line b);", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "boolean", "classes": []}, "name": "intersects", "params": [{"name": "b", "type": "Line"}], "body": "", "signature": "boolean intersects(Line b)"}, {"syntax_pass": true, "original_string": "    boolean intersects(Point point);", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "boolean", "classes": []}, "name": "intersects", "params": [{"name": "point", "type": "Point"}], "body": "", "signature": "boolean intersects(Point point)"}, {"syntax_pass": true, "original_string": "    boolean intersects(Circle circle);", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "boolean", "classes": []}, "name": "intersects", "params": [{"name": "circle", "type": "Circle"}], "body": "", "signature": "boolean intersects(Circle circle)"}]}], "records": []}, {"relative_path": "src/main/java/com/github/davidmoten/rtree/geometry/internal/LineFloat.java", "original_string": "package com.github.davidmoten.rtree.geometry.internal;\n\nimport com.github.davidmoten.rtree.geometry.Circle;\nimport com.github.davidmoten.rtree.geometry.Geometries;\nimport com.github.davidmoten.rtree.geometry.Line;\nimport com.github.davidmoten.rtree.geometry.Point;\nimport com.github.davidmoten.rtree.geometry.Rectangle;\nimport com.github.davidmoten.rtree.internal.Line2D;\nimport com.github.davidmoten.rtree.internal.RectangleUtil;\nimport com.github.davidmoten.rtree.internal.util.ObjectsHelper;\n\nimport java.util.Objects;\nimport java.util.Optional;\n\n/**\n * A line segment.\n */\npublic final class LineFloat implements Line {\n\n    private final double x1;\n    private final double y1;\n    private final double x2;\n    private final double y2;\n\n    private LineFloat(double x1, double y1, double x2, double y2) {\n        this.x1 = x1;\n        this.y1 = y1;\n        this.x2 = x2;\n        this.y2 = y2;\n    }\n\n    public static LineFloat create(double x1, double y1, double x2, double y2) {\n        return new LineFloat(x1, y1, x2, y2);\n    }\n\n    @Override\n    public double distance(Rectangle r) {\n        if (r.contains(x1, y1) || r.contains(x2, y2)) {\n            return 0;\n        } else {\n            double d1 = distance(r.x1(), r.y1(), r.x1(), r.y2());\n            if (d1 == 0)\n                return 0;\n            double d2 = distance(r.x1(), r.y2(), r.x2(), r.y2());\n            if (d2 == 0)\n                return 0;\n            double d3 = distance(r.x2(), r.y2(), r.x2(), r.y1());\n            double d4 = distance(r.x2(), r.y1(), r.x1(), r.y1());\n            return Math.min(d1, Math.min(d2, Math.min(d3, d4)));\n        }\n    }\n\n    private double distance(double x1, double y1, double x2, double y2) {\n        Line2D line = new Line2D(x1, y1, x2, y2);\n        double d1 = line.ptSegDist(this.x1, this.y1);\n        double d2 = line.ptSegDist(this.x2, this.y2);\n        Line2D line2 = new Line2D(this.x1, this.y1, this.x2, this.y2);\n        double d3 = line2.ptSegDist(x1, y1);\n        if (d3 == 0)\n            return 0;\n        double d4 = line2.ptSegDist(x2, y2);\n        if (d4 == 0)\n            return 0;\n        else\n            return Math.min(d1, Math.min(d2, Math.min(d3, d4)));\n\n    }\n\n    @Override\n    public Rectangle mbr() {\n        return Geometries.rectangle(Math.min(x1, x2), Math.min(y1, y2), Math.max(x1, x2),\n                Math.max(y1, y2));\n    }\n\n    @Override\n    public boolean intersects(Rectangle r) {\n        return RectangleUtil.rectangleIntersectsLine(r.x1(), r.y1(), r.x2() - r.x1(),\n                r.y2() - r.y1(), x1, y1, x2, y2);\n    }\n\n    @Override\n    public double x1() {\n        return x1;\n    }\n\n    @Override\n    public double y1() {\n        return y1;\n    }\n\n    @Override\n    public double x2() {\n        return x2;\n    }\n\n    @Override\n    public double y2() {\n        return y2;\n    }\n\n    @Override\n    public boolean intersects(Line b) {\n        Line2D line1 = new Line2D(x1, y1, x2, y2);\n        Line2D line2 = new Line2D(b.x1(), b.y1(), b.x2(), b.y2());\n        return line2.intersectsLine(line1);\n    }\n\n    @Override\n    public boolean intersects(Point point) {\n        return intersects(point.mbr());\n    }\n\n    @Override\n    public boolean intersects(Circle circle) {\n        return GeometryUtil.lineIntersects(x1, y1, x2, y2, circle);\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(x1, y1, x2, y2);\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        Optional<LineFloat> other = ObjectsHelper.asClass(obj, LineFloat.class);\n        if (other.isPresent()) {\n            return Objects.equals(x1, other.get().x1) && Objects.equals(x2, other.get().x2)\n                    && Objects.equals(y1, other.get().y1) && Objects.equals(y2, other.get().y2);\n        } else\n            return false;\n    }\n\n    @Override\n    public boolean isDoublePrecision() {\n        return false;\n    }\n\n}\n", "file_hash": "8a8451c9f0b1b4c479b38af73fd438bb3ebdc165d0329cd54072f51671ea63c5", "file_docstring": "", "contexts": ["package com.github.davidmoten.rtree.geometry.internal;", "import com.github.davidmoten.rtree.geometry.Circle;", "import com.github.davidmoten.rtree.geometry.Geometries;", "import com.github.davidmoten.rtree.geometry.Line;", "import com.github.davidmoten.rtree.geometry.Point;", "import com.github.davidmoten.rtree.geometry.Rectangle;", "import com.github.davidmoten.rtree.internal.Line2D;", "import com.github.davidmoten.rtree.internal.RectangleUtil;", "import com.github.davidmoten.rtree.internal.util.ObjectsHelper;", "import java.util.Objects;", "import java.util.Optional;"], "methods": [], "classes": [{"original_string": "public final class LineFloat implements Line {\n\n    private final double x1;\n    private final double y1;\n    private final double x2;\n    private final double y2;\n\n    private LineFloat(double x1, double y1, double x2, double y2) {\n        this.x1 = x1;\n        this.y1 = y1;\n        this.x2 = x2;\n        this.y2 = y2;\n    }\n\n    public static LineFloat create(double x1, double y1, double x2, double y2) {\n        return new LineFloat(x1, y1, x2, y2);\n    }\n\n    @Override\n    public double distance(Rectangle r) {\n        if (r.contains(x1, y1) || r.contains(x2, y2)) {\n            return 0;\n        } else {\n            double d1 = distance(r.x1(), r.y1(), r.x1(), r.y2());\n            if (d1 == 0)\n                return 0;\n            double d2 = distance(r.x1(), r.y2(), r.x2(), r.y2());\n            if (d2 == 0)\n                return 0;\n            double d3 = distance(r.x2(), r.y2(), r.x2(), r.y1());\n            double d4 = distance(r.x2(), r.y1(), r.x1(), r.y1());\n            return Math.min(d1, Math.min(d2, Math.min(d3, d4)));\n        }\n    }\n\n    private double distance(double x1, double y1, double x2, double y2) {\n        Line2D line = new Line2D(x1, y1, x2, y2);\n        double d1 = line.ptSegDist(this.x1, this.y1);\n        double d2 = line.ptSegDist(this.x2, this.y2);\n        Line2D line2 = new Line2D(this.x1, this.y1, this.x2, this.y2);\n        double d3 = line2.ptSegDist(x1, y1);\n        if (d3 == 0)\n            return 0;\n        double d4 = line2.ptSegDist(x2, y2);\n        if (d4 == 0)\n            return 0;\n        else\n            return Math.min(d1, Math.min(d2, Math.min(d3, d4)));\n\n    }\n\n    @Override\n    public Rectangle mbr() {\n        return Geometries.rectangle(Math.min(x1, x2), Math.min(y1, y2), Math.max(x1, x2),\n                Math.max(y1, y2));\n    }\n\n    @Override\n    public boolean intersects(Rectangle r) {\n        return RectangleUtil.rectangleIntersectsLine(r.x1(), r.y1(), r.x2() - r.x1(),\n                r.y2() - r.y1(), x1, y1, x2, y2);\n    }\n\n    @Override\n    public double x1() {\n        return x1;\n    }\n\n    @Override\n    public double y1() {\n        return y1;\n    }\n\n    @Override\n    public double x2() {\n        return x2;\n    }\n\n    @Override\n    public double y2() {\n        return y2;\n    }\n\n    @Override\n    public boolean intersects(Line b) {\n        Line2D line1 = new Line2D(x1, y1, x2, y2);\n        Line2D line2 = new Line2D(b.x1(), b.y1(), b.x2(), b.y2());\n        return line2.intersectsLine(line1);\n    }\n\n    @Override\n    public boolean intersects(Point point) {\n        return intersects(point.mbr());\n    }\n\n    @Override\n    public boolean intersects(Circle circle) {\n        return GeometryUtil.lineIntersects(x1, y1, x2, y2, circle);\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(x1, y1, x2, y2);\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        Optional<LineFloat> other = ObjectsHelper.asClass(obj, LineFloat.class);\n        if (other.isPresent()) {\n            return Objects.equals(x1, other.get().x1) && Objects.equals(x2, other.get().x2)\n                    && Objects.equals(y1, other.get().y1) && Objects.equals(y2, other.get().y2);\n        } else\n            return false;\n    }\n\n    @Override\n    public boolean isDoublePrecision() {\n        return false;\n    }\n\n}", "definition": "public final class LineFloat implements Line", "class_docstring": "\nA line segment.\n", "name": "LineFloat", "super_interfaces": ["Line"], "superclasses": "", "attributes": {"modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "fields": [{"attribute_expression": "private final double x1;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "double", "name": "x1", "syntax_pass": true}, {"attribute_expression": "private final double y1;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "double", "name": "y1", "syntax_pass": true}, {"attribute_expression": "private final double x2;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "double", "name": "x2", "syntax_pass": true}, {"attribute_expression": "private final double y2;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "double", "name": "y2", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    private LineFloat(double x1, double y1, double x2, double y2) {\n        this.x1 = x1;\n        this.y1 = y1;\n        this.x2 = x2;\n        this.y2 = y2;\n    }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "", "classes": []}, "name": "LineFloat", "params": [{"name": "x1", "type": "double"}, {"name": "y1", "type": "double"}, {"name": "x2", "type": "double"}, {"name": "y2", "type": "double"}], "body": "                                                                  {\n        this.x1 = x1;\n        this.y1 = y1;\n        this.x2 = x2;\n        this.y2 = y2;\n    }", "signature": "private LineFloat(double x1, double y1, double x2, double y2)"}, {"syntax_pass": true, "original_string": "    public static LineFloat create(double x1, double y1, double x2, double y2) {\n        return new LineFloat(x1, y1, x2, y2);\n    }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "LineFloat", "classes": []}, "name": "create", "params": [{"name": "x1", "type": "double"}, {"name": "y1", "type": "double"}, {"name": "x2", "type": "double"}, {"name": "y2", "type": "double"}], "body": "                                                                               {\n        return new LineFloat(x1, y1, x2, y2);\n    }", "signature": "public static LineFloat create(double x1, double y1, double x2, double y2)"}, {"syntax_pass": true, "original_string": "    @Override\n    public double distance(Rectangle r) {\n        if (r.contains(x1, y1) || r.contains(x2, y2)) {\n            return 0;\n        } else {\n            double d1 = distance(r.x1(), r.y1(), r.x1(), r.y2());\n            if (d1 == 0)\n                return 0;\n            double d2 = distance(r.x1(), r.y2(), r.x2(), r.y2());\n            if (d2 == 0)\n                return 0;\n            double d3 = distance(r.x2(), r.y2(), r.x2(), r.y1());\n            double d4 = distance(r.x2(), r.y1(), r.x1(), r.y1());\n            return Math.min(d1, Math.min(d2, Math.min(d3, d4)));\n        }\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "double", "classes": []}, "name": "distance", "params": [{"name": "r", "type": "Rectangle"}], "body": "                                        {\n        if (r.contains(x1, y1) || r.contains(x2, y2)) {\n            return 0;\n        } else {\n            double d1 = distance(r.x1(), r.y1(), r.x1(), r.y2());\n            if (d1 == 0)\n                return 0;\n            double d2 = distance(r.x1(), r.y2(), r.x2(), r.y2());\n            if (d2 == 0)\n                return 0;\n            double d3 = distance(r.x2(), r.y2(), r.x2(), r.y1());\n            double d4 = distance(r.x2(), r.y1(), r.x1(), r.y1());\n            return Math.min(d1, Math.min(d2, Math.min(d3, d4)));\n        }\n    }", "signature": "@Override\n    public double distance(Rectangle r)"}, {"syntax_pass": true, "original_string": "    private double distance(double x1, double y1, double x2, double y2) {\n        Line2D line = new Line2D(x1, y1, x2, y2);\n        double d1 = line.ptSegDist(this.x1, this.y1);\n        double d2 = line.ptSegDist(this.x2, this.y2);\n        Line2D line2 = new Line2D(this.x1, this.y1, this.x2, this.y2);\n        double d3 = line2.ptSegDist(x1, y1);\n        if (d3 == 0)\n            return 0;\n        double d4 = line2.ptSegDist(x2, y2);\n        if (d4 == 0)\n            return 0;\n        else\n            return Math.min(d1, Math.min(d2, Math.min(d3, d4)));\n\n    }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "double", "classes": []}, "name": "distance", "params": [{"name": "x1", "type": "double"}, {"name": "y1", "type": "double"}, {"name": "x2", "type": "double"}, {"name": "y2", "type": "double"}], "body": "                                                                        {\n        Line2D line = new Line2D(x1, y1, x2, y2);\n        double d1 = line.ptSegDist(this.x1, this.y1);\n        double d2 = line.ptSegDist(this.x2, this.y2);\n        Line2D line2 = new Line2D(this.x1, this.y1, this.x2, this.y2);\n        double d3 = line2.ptSegDist(x1, y1);\n        if (d3 == 0)\n            return 0;\n        double d4 = line2.ptSegDist(x2, y2);\n        if (d4 == 0)\n            return 0;\n        else\n            return Math.min(d1, Math.min(d2, Math.min(d3, d4)));\n\n    }", "signature": "private double distance(double x1, double y1, double x2, double y2)"}, {"syntax_pass": true, "original_string": "    @Override\n    public Rectangle mbr() {\n        return Geometries.rectangle(Math.min(x1, x2), Math.min(y1, y2), Math.max(x1, x2),\n                Math.max(y1, y2));\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Rectangle", "classes": []}, "name": "mbr", "params": [], "body": "                           {\n        return Geometries.rectangle(Math.min(x1, x2), Math.min(y1, y2), Math.max(x1, x2),\n                Math.max(y1, y2));\n    }", "signature": "@Override\n    public Rectangle mbr()"}, {"syntax_pass": true, "original_string": "    @Override\n    public boolean intersects(Rectangle r) {\n        return RectangleUtil.rectangleIntersectsLine(r.x1(), r.y1(), r.x2() - r.x1(),\n                r.y2() - r.y1(), x1, y1, x2, y2);\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "intersects", "params": [{"name": "r", "type": "Rectangle"}], "body": "                                           {\n        return RectangleUtil.rectangleIntersectsLine(r.x1(), r.y1(), r.x2() - r.x1(),\n                r.y2() - r.y1(), x1, y1, x2, y2);\n    }", "signature": "@Override\n    public boolean intersects(Rectangle r)"}, {"syntax_pass": true, "original_string": "    @Override\n    public double x1() {\n        return x1;\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "double", "classes": []}, "name": "x1", "params": [], "body": "                       {\n        return x1;\n    }", "signature": "@Override\n    public double x1()"}, {"syntax_pass": true, "original_string": "    @Override\n    public double y1() {\n        return y1;\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "double", "classes": []}, "name": "y1", "params": [], "body": "                       {\n        return y1;\n    }", "signature": "@Override\n    public double y1()"}, {"syntax_pass": true, "original_string": "    @Override\n    public double x2() {\n        return x2;\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "double", "classes": []}, "name": "x2", "params": [], "body": "                       {\n        return x2;\n    }", "signature": "@Override\n    public double x2()"}, {"syntax_pass": true, "original_string": "    @Override\n    public double y2() {\n        return y2;\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "double", "classes": []}, "name": "y2", "params": [], "body": "                       {\n        return y2;\n    }", "signature": "@Override\n    public double y2()"}, {"syntax_pass": true, "original_string": "    @Override\n    public boolean intersects(Line b) {\n        Line2D line1 = new Line2D(x1, y1, x2, y2);\n        Line2D line2 = new Line2D(b.x1(), b.y1(), b.x2(), b.y2());\n        return line2.intersectsLine(line1);\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "intersects", "params": [{"name": "b", "type": "Line"}], "body": "                                      {\n        Line2D line1 = new Line2D(x1, y1, x2, y2);\n        Line2D line2 = new Line2D(b.x1(), b.y1(), b.x2(), b.y2());\n        return line2.intersectsLine(line1);\n    }", "signature": "@Override\n    public boolean intersects(Line b)"}, {"syntax_pass": true, "original_string": "    @Override\n    public boolean intersects(Point point) {\n        return intersects(point.mbr());\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "intersects", "params": [{"name": "point", "type": "Point"}], "body": "                                           {\n        return intersects(point.mbr());\n    }", "signature": "@Override\n    public boolean intersects(Point point)"}, {"syntax_pass": true, "original_string": "    @Override\n    public boolean intersects(Circle circle) {\n        return GeometryUtil.lineIntersects(x1, y1, x2, y2, circle);\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "intersects", "params": [{"name": "circle", "type": "Circle"}], "body": "                                             {\n        return GeometryUtil.lineIntersects(x1, y1, x2, y2, circle);\n    }", "signature": "@Override\n    public boolean intersects(Circle circle)"}, {"syntax_pass": true, "original_string": "    @Override\n    public int hashCode() {\n        return Objects.hash(x1, y1, x2, y2);\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "hashCode", "params": [], "body": "                          {\n        return Objects.hash(x1, y1, x2, y2);\n    }", "signature": "@Override\n    public int hashCode()"}, {"syntax_pass": true, "original_string": "    @Override\n    public boolean equals(Object obj) {\n        Optional<LineFloat> other = ObjectsHelper.asClass(obj, LineFloat.class);\n        if (other.isPresent()) {\n            return Objects.equals(x1, other.get().x1) && Objects.equals(x2, other.get().x2)\n                    && Objects.equals(y1, other.get().y1) && Objects.equals(y2, other.get().y2);\n        } else\n            return false;\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "equals", "params": [{"name": "obj", "type": "Object"}], "body": "                                      {\n        Optional<LineFloat> other = ObjectsHelper.asClass(obj, LineFloat.class);\n        if (other.isPresent()) {\n            return Objects.equals(x1, other.get().x1) && Objects.equals(x2, other.get().x2)\n                    && Objects.equals(y1, other.get().y1) && Objects.equals(y2, other.get().y2);\n        } else\n            return false;\n    }", "signature": "@Override\n    public boolean equals(Object obj)"}, {"syntax_pass": true, "original_string": "    @Override\n    public boolean isDoublePrecision() {\n        return false;\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isDoublePrecision", "params": [], "body": "                                       {\n        return false;\n    }", "signature": "@Override\n    public boolean isDoublePrecision()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/com/github/davidmoten/rtree/geometry/internal/PointFloat.java", "original_string": "package com.github.davidmoten.rtree.geometry.internal;\n\nimport com.github.davidmoten.rtree.geometry.Geometry;\nimport com.github.davidmoten.rtree.geometry.Point;\nimport com.github.davidmoten.rtree.geometry.Rectangle;\n\npublic final class PointFloat implements Point {\n\n    private final float x;\n    private final float y;\n\n    private PointFloat(float x, float y) {\n        this.x = x;\n        this.y = y;\n    }\n\n    public static PointFloat create(float x, float y) {\n        return new PointFloat(x, y);\n    }\n\n    @Override\n    public Rectangle mbr() {\n        return this;\n    }\n\n    @Override\n    public double distance(Rectangle r) {\n        return GeometryUtil.distance(x, y, r);\n    }\n\n    @Override\n    public boolean intersects(Rectangle r) {\n        return r.x1() <= x && x <= r.x2() && r.y1() <= y && y <= r.y2();\n    }\n\n    @Override\n    public double x() {\n        return x;\n    }\n\n    @Override\n    public double y() {\n        return y;\n    }\n\n    @Override\n    public int hashCode() {\n        final int prime = 31;\n        int result = 1;\n        result = prime * result + Float.floatToIntBits(x);\n        result = prime * result + Float.floatToIntBits(y);\n        return result;\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        if (this == obj)\n            return true;\n        if (obj == null)\n            return false;\n        if (getClass() != obj.getClass())\n            return false;\n        PointFloat other = (PointFloat) obj;\n        if (Float.floatToIntBits(x) != Float.floatToIntBits(other.x))\n            return false;\n        if (Float.floatToIntBits(y) != Float.floatToIntBits(other.y))\n            return false;\n        return true;\n    }\n\n    @Override\n    public String toString() {\n        return \"Point [x=\" + x() + \", y=\" + y() + \"]\";\n    }\n\n    @Override\n    public Geometry geometry() {\n        return this;\n    }\n\n    @Override\n    public double x1() {\n        return x;\n    }\n\n    @Override\n    public double y1() {\n        return y;\n    }\n\n    @Override\n    public double x2() {\n        return x;\n    }\n\n    @Override\n    public double y2() {\n        return y;\n    }\n\n    @Override\n    public double area() {\n        return 0;\n    }\n\n    @Override\n    public Rectangle add(Rectangle r) {\n        if (r.isDoublePrecision()) {\n            return RectangleDouble.create(Math.min(x, r.x1()), Math.min(y, r.y1()),\n                    Math.max(x, r.x2()), Math.max(y, r.y2()));\n        } else if (r instanceof RectangleFloat) {\n            RectangleFloat rf = (RectangleFloat) r;\n            return RectangleFloat.create(Math.min(x, rf.x1), Math.min(y, rf.y1), Math.max(x, rf.x2),\n                    Math.max(y, rf.y2));\n        } else if (r instanceof PointFloat) {\n            PointFloat p = (PointFloat) r;\n            return RectangleFloat.create(Math.min(x, p.x), Math.min(y, p.y), Math.max(x, p.x),\n                    Math.max(y, p.y));\n        } else {\n            PointDouble p = (PointDouble) r;\n            return RectangleDouble.create(Math.min(x, p.x()), Math.min(y, p.y()),\n                    Math.max(x, p.x()), Math.max(y, p.y()));\n        }\n    }\n\n    @Override\n    public boolean contains(double x, double y) {\n        return this.x == x && this.y == y;\n    }\n\n    @Override\n    public double intersectionArea(Rectangle r) {\n        return 0;\n    }\n\n    @Override\n    public double perimeter() {\n        return 0;\n    }\n\n    @Override\n    public boolean isDoublePrecision() {\n        return false;\n    }\n\n    public float xFloat() {\n        return x;\n    }\n\n    public float yFloat() {\n        return y;\n    }\n\n}", "file_hash": "c59ae592f2d79dbc79b6bb8181af9e7ef5885fb4ec861600ba478e10309164e5", "file_docstring": "", "contexts": ["package com.github.davidmoten.rtree.geometry.internal;", "import com.github.davidmoten.rtree.geometry.Geometry;", "import com.github.davidmoten.rtree.geometry.Point;", "import com.github.davidmoten.rtree.geometry.Rectangle;"], "methods": [], "classes": [{"original_string": "public final class PointFloat implements Point {\n\n    private final float x;\n    private final float y;\n\n    private PointFloat(float x, float y) {\n        this.x = x;\n        this.y = y;\n    }\n\n    public static PointFloat create(float x, float y) {\n        return new PointFloat(x, y);\n    }\n\n    @Override\n    public Rectangle mbr() {\n        return this;\n    }\n\n    @Override\n    public double distance(Rectangle r) {\n        return GeometryUtil.distance(x, y, r);\n    }\n\n    @Override\n    public boolean intersects(Rectangle r) {\n        return r.x1() <= x && x <= r.x2() && r.y1() <= y && y <= r.y2();\n    }\n\n    @Override\n    public double x() {\n        return x;\n    }\n\n    @Override\n    public double y() {\n        return y;\n    }\n\n    @Override\n    public int hashCode() {\n        final int prime = 31;\n        int result = 1;\n        result = prime * result + Float.floatToIntBits(x);\n        result = prime * result + Float.floatToIntBits(y);\n        return result;\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        if (this == obj)\n            return true;\n        if (obj == null)\n            return false;\n        if (getClass() != obj.getClass())\n            return false;\n        PointFloat other = (PointFloat) obj;\n        if (Float.floatToIntBits(x) != Float.floatToIntBits(other.x))\n            return false;\n        if (Float.floatToIntBits(y) != Float.floatToIntBits(other.y))\n            return false;\n        return true;\n    }\n\n    @Override\n    public String toString() {\n        return \"Point [x=\" + x() + \", y=\" + y() + \"]\";\n    }\n\n    @Override\n    public Geometry geometry() {\n        return this;\n    }\n\n    @Override\n    public double x1() {\n        return x;\n    }\n\n    @Override\n    public double y1() {\n        return y;\n    }\n\n    @Override\n    public double x2() {\n        return x;\n    }\n\n    @Override\n    public double y2() {\n        return y;\n    }\n\n    @Override\n    public double area() {\n        return 0;\n    }\n\n    @Override\n    public Rectangle add(Rectangle r) {\n        if (r.isDoublePrecision()) {\n            return RectangleDouble.create(Math.min(x, r.x1()), Math.min(y, r.y1()),\n                    Math.max(x, r.x2()), Math.max(y, r.y2()));\n        } else if (r instanceof RectangleFloat) {\n            RectangleFloat rf = (RectangleFloat) r;\n            return RectangleFloat.create(Math.min(x, rf.x1), Math.min(y, rf.y1), Math.max(x, rf.x2),\n                    Math.max(y, rf.y2));\n        } else if (r instanceof PointFloat) {\n            PointFloat p = (PointFloat) r;\n            return RectangleFloat.create(Math.min(x, p.x), Math.min(y, p.y), Math.max(x, p.x),\n                    Math.max(y, p.y));\n        } else {\n            PointDouble p = (PointDouble) r;\n            return RectangleDouble.create(Math.min(x, p.x()), Math.min(y, p.y()),\n                    Math.max(x, p.x()), Math.max(y, p.y()));\n        }\n    }\n\n    @Override\n    public boolean contains(double x, double y) {\n        return this.x == x && this.y == y;\n    }\n\n    @Override\n    public double intersectionArea(Rectangle r) {\n        return 0;\n    }\n\n    @Override\n    public double perimeter() {\n        return 0;\n    }\n\n    @Override\n    public boolean isDoublePrecision() {\n        return false;\n    }\n\n    public float xFloat() {\n        return x;\n    }\n\n    public float yFloat() {\n        return y;\n    }\n\n}", "definition": "public final class PointFloat implements Point", "class_docstring": "", "name": "PointFloat", "super_interfaces": ["Point"], "superclasses": "", "attributes": {"modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "fields": [{"attribute_expression": "private final float x;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "float", "name": "x", "syntax_pass": true}, {"attribute_expression": "private final float y;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "float", "name": "y", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    private PointFloat(float x, float y) {\n        this.x = x;\n        this.y = y;\n    }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "", "classes": []}, "name": "PointFloat", "params": [{"name": "x", "type": "float"}, {"name": "y", "type": "float"}], "body": "                                         {\n        this.x = x;\n        this.y = y;\n    }", "signature": "private PointFloat(float x, float y)"}, {"syntax_pass": true, "original_string": "    public static PointFloat create(float x, float y) {\n        return new PointFloat(x, y);\n    }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "PointFloat", "classes": []}, "name": "create", "params": [{"name": "x", "type": "float"}, {"name": "y", "type": "float"}], "body": "                                                      {\n        return new PointFloat(x, y);\n    }", "signature": "public static PointFloat create(float x, float y)"}, {"syntax_pass": true, "original_string": "    @Override\n    public Rectangle mbr() {\n        return this;\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Rectangle", "classes": []}, "name": "mbr", "params": [], "body": "                           {\n        return this;\n    }", "signature": "@Override\n    public Rectangle mbr()"}, {"syntax_pass": true, "original_string": "    @Override\n    public double distance(Rectangle r) {\n        return GeometryUtil.distance(x, y, r);\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "double", "classes": []}, "name": "distance", "params": [{"name": "r", "type": "Rectangle"}], "body": "                                        {\n        return GeometryUtil.distance(x, y, r);\n    }", "signature": "@Override\n    public double distance(Rectangle r)"}, {"syntax_pass": true, "original_string": "    @Override\n    public boolean intersects(Rectangle r) {\n        return r.x1() <= x && x <= r.x2() && r.y1() <= y && y <= r.y2();\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "intersects", "params": [{"name": "r", "type": "Rectangle"}], "body": "                                           {\n        return r.x1() <= x && x <= r.x2() && r.y1() <= y && y <= r.y2();\n    }", "signature": "@Override\n    public boolean intersects(Rectangle r)"}, {"syntax_pass": true, "original_string": "    @Override\n    public double x() {\n        return x;\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "double", "classes": []}, "name": "x", "params": [], "body": "                      {\n        return x;\n    }", "signature": "@Override\n    public double x()"}, {"syntax_pass": true, "original_string": "    @Override\n    public double y() {\n        return y;\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "double", "classes": []}, "name": "y", "params": [], "body": "                      {\n        return y;\n    }", "signature": "@Override\n    public double y()"}, {"syntax_pass": true, "original_string": "    @Override\n    public int hashCode() {\n        final int prime = 31;\n        int result = 1;\n        result = prime * result + Float.floatToIntBits(x);\n        result = prime * result + Float.floatToIntBits(y);\n        return result;\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "hashCode", "params": [], "body": "                          {\n        final int prime = 31;\n        int result = 1;\n        result = prime * result + Float.floatToIntBits(x);\n        result = prime * result + Float.floatToIntBits(y);\n        return result;\n    }", "signature": "@Override\n    public int hashCode()"}, {"syntax_pass": true, "original_string": "    @Override\n    public boolean equals(Object obj) {\n        if (this == obj)\n            return true;\n        if (obj == null)\n            return false;\n        if (getClass() != obj.getClass())\n            return false;\n        PointFloat other = (PointFloat) obj;\n        if (Float.floatToIntBits(x) != Float.floatToIntBits(other.x))\n            return false;\n        if (Float.floatToIntBits(y) != Float.floatToIntBits(other.y))\n            return false;\n        return true;\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "equals", "params": [{"name": "obj", "type": "Object"}], "body": "                                      {\n        if (this == obj)\n            return true;\n        if (obj == null)\n            return false;\n        if (getClass() != obj.getClass())\n            return false;\n        PointFloat other = (PointFloat) obj;\n        if (Float.floatToIntBits(x) != Float.floatToIntBits(other.x))\n            return false;\n        if (Float.floatToIntBits(y) != Float.floatToIntBits(other.y))\n            return false;\n        return true;\n    }", "signature": "@Override\n    public boolean equals(Object obj)"}, {"syntax_pass": true, "original_string": "    @Override\n    public String toString() {\n        return \"Point [x=\" + x() + \", y=\" + y() + \"]\";\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "toString", "params": [], "body": "                             {\n        return \"Point [x=\" + x() + \", y=\" + y() + \"]\";\n    }", "signature": "@Override\n    public String toString()"}, {"syntax_pass": true, "original_string": "    @Override\n    public Geometry geometry() {\n        return this;\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Geometry", "classes": []}, "name": "geometry", "params": [], "body": "                               {\n        return this;\n    }", "signature": "@Override\n    public Geometry geometry()"}, {"syntax_pass": true, "original_string": "    @Override\n    public double x1() {\n        return x;\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "double", "classes": []}, "name": "x1", "params": [], "body": "                       {\n        return x;\n    }", "signature": "@Override\n    public double x1()"}, {"syntax_pass": true, "original_string": "    @Override\n    public double y1() {\n        return y;\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "double", "classes": []}, "name": "y1", "params": [], "body": "                       {\n        return y;\n    }", "signature": "@Override\n    public double y1()"}, {"syntax_pass": true, "original_string": "    @Override\n    public double x2() {\n        return x;\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "double", "classes": []}, "name": "x2", "params": [], "body": "                       {\n        return x;\n    }", "signature": "@Override\n    public double x2()"}, {"syntax_pass": true, "original_string": "    @Override\n    public double y2() {\n        return y;\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "double", "classes": []}, "name": "y2", "params": [], "body": "                       {\n        return y;\n    }", "signature": "@Override\n    public double y2()"}, {"syntax_pass": true, "original_string": "    @Override\n    public double area() {\n        return 0;\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "double", "classes": []}, "name": "area", "params": [], "body": "                         {\n        return 0;\n    }", "signature": "@Override\n    public double area()"}, {"syntax_pass": true, "original_string": "    @Override\n    public Rectangle add(Rectangle r) {\n        if (r.isDoublePrecision()) {\n            return RectangleDouble.create(Math.min(x, r.x1()), Math.min(y, r.y1()),\n                    Math.max(x, r.x2()), Math.max(y, r.y2()));\n        } else if (r instanceof RectangleFloat) {\n            RectangleFloat rf = (RectangleFloat) r;\n            return RectangleFloat.create(Math.min(x, rf.x1), Math.min(y, rf.y1), Math.max(x, rf.x2),\n                    Math.max(y, rf.y2));\n        } else if (r instanceof PointFloat) {\n            PointFloat p = (PointFloat) r;\n            return RectangleFloat.create(Math.min(x, p.x), Math.min(y, p.y), Math.max(x, p.x),\n                    Math.max(y, p.y));\n        } else {\n            PointDouble p = (PointDouble) r;\n            return RectangleDouble.create(Math.min(x, p.x()), Math.min(y, p.y()),\n                    Math.max(x, p.x()), Math.max(y, p.y()));\n        }\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Rectangle", "classes": []}, "name": "add", "params": [{"name": "r", "type": "Rectangle"}], "body": "                                      {\n        if (r.isDoublePrecision()) {\n            return RectangleDouble.create(Math.min(x, r.x1()), Math.min(y, r.y1()),\n                    Math.max(x, r.x2()), Math.max(y, r.y2()));\n        } else if (r instanceof RectangleFloat) {\n            RectangleFloat rf = (RectangleFloat) r;\n            return RectangleFloat.create(Math.min(x, rf.x1), Math.min(y, rf.y1), Math.max(x, rf.x2),\n                    Math.max(y, rf.y2));\n        } else if (r instanceof PointFloat) {\n            PointFloat p = (PointFloat) r;\n            return RectangleFloat.create(Math.min(x, p.x), Math.min(y, p.y), Math.max(x, p.x),\n                    Math.max(y, p.y));\n        } else {\n            PointDouble p = (PointDouble) r;\n            return RectangleDouble.create(Math.min(x, p.x()), Math.min(y, p.y()),\n                    Math.max(x, p.x()), Math.max(y, p.y()));\n        }\n    }", "signature": "@Override\n    public Rectangle add(Rectangle r)"}, {"syntax_pass": true, "original_string": "    @Override\n    public boolean contains(double x, double y) {\n        return this.x == x && this.y == y;\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "contains", "params": [{"name": "x", "type": "double"}, {"name": "y", "type": "double"}], "body": "                                                {\n        return this.x == x && this.y == y;\n    }", "signature": "@Override\n    public boolean contains(double x, double y)"}, {"syntax_pass": true, "original_string": "    @Override\n    public double intersectionArea(Rectangle r) {\n        return 0;\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "double", "classes": []}, "name": "intersectionArea", "params": [{"name": "r", "type": "Rectangle"}], "body": "                                                {\n        return 0;\n    }", "signature": "@Override\n    public double intersectionArea(Rectangle r)"}, {"syntax_pass": true, "original_string": "    @Override\n    public double perimeter() {\n        return 0;\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "double", "classes": []}, "name": "perimeter", "params": [], "body": "                              {\n        return 0;\n    }", "signature": "@Override\n    public double perimeter()"}, {"syntax_pass": true, "original_string": "    @Override\n    public boolean isDoublePrecision() {\n        return false;\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isDoublePrecision", "params": [], "body": "                                       {\n        return false;\n    }", "signature": "@Override\n    public boolean isDoublePrecision()"}, {"syntax_pass": true, "original_string": "    public float xFloat() {\n        return x;\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "float", "classes": []}, "name": "xFloat", "params": [], "body": "                          {\n        return x;\n    }", "signature": "public float xFloat()"}, {"syntax_pass": true, "original_string": "    public float yFloat() {\n        return y;\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "float", "classes": []}, "name": "yFloat", "params": [], "body": "                          {\n        return y;\n    }", "signature": "public float yFloat()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/com/github/davidmoten/rtree/geometry/internal/RectangleDouble.java", "original_string": "package com.github.davidmoten.rtree.geometry.internal;\n\nimport com.github.davidmoten.guavamini.Preconditions;\nimport com.github.davidmoten.rtree.geometry.Geometry;\nimport com.github.davidmoten.rtree.geometry.Rectangle;\nimport com.github.davidmoten.rtree.internal.util.ObjectsHelper;\n\nimport java.util.Objects;\nimport java.util.Optional;\n\npublic final class RectangleDouble implements Rectangle {\n    private final double x1, y1, x2, y2;\n\n    private RectangleDouble(double x1, double y1, double x2, double y2) {\n        Preconditions.checkArgument(x2 >= x1);\n        Preconditions.checkArgument(y2 >= y1);\n        this.x1 = x1;\n        this.y1 = y1;\n        this.x2 = x2;\n        this.y2 = y2;\n    }\n\n    public static RectangleDouble create(double x1, double y1, double x2, double y2) {\n        return new RectangleDouble((double) x1, (double) y1, (double) x2, (double) y2);\n    }\n\n    @Override\n    public double x1() {\n        return x1;\n    }\n\n    @Override\n    public double y1() {\n        return y1;\n    }\n\n    @Override\n    public double x2() {\n        return x2;\n    }\n\n    @Override\n    public double y2() {\n        return  y2;\n    }\n\n    @Override\n    public Rectangle add(Rectangle r) {\n        return new RectangleDouble(min(x1, r.x1()), min(y1, r.y1()), max(x2, r.x2()),\n                max(y2, r.y2()));\n    }\n\n    @Override\n    public boolean contains(double x, double y) {\n        return x >= x1 && x <= x2 && y >= y1 && y <= y2;\n    }\n\n    @Override\n    public boolean intersects(Rectangle r) {\n        if (r instanceof RectangleDouble) {\n            RectangleDouble rd = (RectangleDouble) r;\n            return intersects(rd);\n        } else {\n            return GeometryUtil.intersects(x1, y1, x2, y2, r.x1(), r.y1(), r.x2(), r.y2());\n        }\n    }\n\n    private boolean intersects(RectangleDouble rd) {\n        return GeometryUtil.intersects(x1, y1, x2, y2, rd.x1, rd.y1, rd.x2, rd.y2);\n    }\n\n    @Override\n    public double distance(Rectangle r) {\n        return GeometryUtil.distance(x1, y1, x2, y2, r.x1(), r.y1(), r.x2(), r.y2());\n    }\n\n    @Override\n    public Rectangle mbr() {\n        return this;\n    }\n\n    @Override\n    public String toString() {\n        return \"Rectangle [x1=\" + x1 + \", y1=\" + y1 + \", x2=\" + x2 + \", y2=\" + y2 + \"]\";\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(x1, y1, x2, y2);\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        Optional<RectangleDouble> other = ObjectsHelper.asClass(obj, RectangleDouble.class);\n        if (other.isPresent()) {\n            return Objects.equals(x1, other.get().x1) && Objects.equals(x2, other.get().x2)\n                    && Objects.equals(y1, other.get().y1) && Objects.equals(y2, other.get().y2);\n        } else\n            return false;\n    }\n\n    @Override\n    public double intersectionArea(Rectangle r) {\n        if (!intersects(r))\n            return 0;\n        else {\n            return create(max(x1, r.x1()), max(y1, r.y1()), min(x2, r.x2()), min(y2, r.y2()))\n                    .area();\n        }\n    }\n\n    @Override\n    public Geometry geometry() {\n        return this;\n    }\n\n    private static double max(double a, double b) {\n        if (a < b)\n            return b;\n        else\n            return a;\n    }\n\n    private static double min(double a, double b) {\n        if (a < b)\n            return a;\n        else\n            return b;\n    }\n\n    @Override\n    public double perimeter() {\n        return 2 * (x2 - x1) + 2 * (y2 - y1);\n    }\n\n    @Override\n    public double area() {\n        return (x2 - x1) * (y2 - y1);\n    }\n\n    @Override\n    public boolean isDoublePrecision() {\n        return true;\n    }\n\n}", "file_hash": "903ff45e172643f724249044d12b1c43a03baa5cb5c7d46ebad9ee6aa32fbe0d", "file_docstring": "", "contexts": ["package com.github.davidmoten.rtree.geometry.internal;", "import com.github.davidmoten.guavamini.Preconditions;", "import com.github.davidmoten.rtree.geometry.Geometry;", "import com.github.davidmoten.rtree.geometry.Rectangle;", "import com.github.davidmoten.rtree.internal.util.ObjectsHelper;", "import java.util.Objects;", "import java.util.Optional;"], "methods": [], "classes": [{"original_string": "public final class RectangleDouble implements Rectangle {\n    private final double x1, y1, x2, y2;\n\n    private RectangleDouble(double x1, double y1, double x2, double y2) {\n        Preconditions.checkArgument(x2 >= x1);\n        Preconditions.checkArgument(y2 >= y1);\n        this.x1 = x1;\n        this.y1 = y1;\n        this.x2 = x2;\n        this.y2 = y2;\n    }\n\n    public static RectangleDouble create(double x1, double y1, double x2, double y2) {\n        return new RectangleDouble((double) x1, (double) y1, (double) x2, (double) y2);\n    }\n\n    @Override\n    public double x1() {\n        return x1;\n    }\n\n    @Override\n    public double y1() {\n        return y1;\n    }\n\n    @Override\n    public double x2() {\n        return x2;\n    }\n\n    @Override\n    public double y2() {\n        return  y2;\n    }\n\n    @Override\n    public Rectangle add(Rectangle r) {\n        return new RectangleDouble(min(x1, r.x1()), min(y1, r.y1()), max(x2, r.x2()),\n                max(y2, r.y2()));\n    }\n\n    @Override\n    public boolean contains(double x, double y) {\n        return x >= x1 && x <= x2 && y >= y1 && y <= y2;\n    }\n\n    @Override\n    public boolean intersects(Rectangle r) {\n        if (r instanceof RectangleDouble) {\n            RectangleDouble rd = (RectangleDouble) r;\n            return intersects(rd);\n        } else {\n            return GeometryUtil.intersects(x1, y1, x2, y2, r.x1(), r.y1(), r.x2(), r.y2());\n        }\n    }\n\n    private boolean intersects(RectangleDouble rd) {\n        return GeometryUtil.intersects(x1, y1, x2, y2, rd.x1, rd.y1, rd.x2, rd.y2);\n    }\n\n    @Override\n    public double distance(Rectangle r) {\n        return GeometryUtil.distance(x1, y1, x2, y2, r.x1(), r.y1(), r.x2(), r.y2());\n    }\n\n    @Override\n    public Rectangle mbr() {\n        return this;\n    }\n\n    @Override\n    public String toString() {\n        return \"Rectangle [x1=\" + x1 + \", y1=\" + y1 + \", x2=\" + x2 + \", y2=\" + y2 + \"]\";\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(x1, y1, x2, y2);\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        Optional<RectangleDouble> other = ObjectsHelper.asClass(obj, RectangleDouble.class);\n        if (other.isPresent()) {\n            return Objects.equals(x1, other.get().x1) && Objects.equals(x2, other.get().x2)\n                    && Objects.equals(y1, other.get().y1) && Objects.equals(y2, other.get().y2);\n        } else\n            return false;\n    }\n\n    @Override\n    public double intersectionArea(Rectangle r) {\n        if (!intersects(r))\n            return 0;\n        else {\n            return create(max(x1, r.x1()), max(y1, r.y1()), min(x2, r.x2()), min(y2, r.y2()))\n                    .area();\n        }\n    }\n\n    @Override\n    public Geometry geometry() {\n        return this;\n    }\n\n    private static double max(double a, double b) {\n        if (a < b)\n            return b;\n        else\n            return a;\n    }\n\n    private static double min(double a, double b) {\n        if (a < b)\n            return a;\n        else\n            return b;\n    }\n\n    @Override\n    public double perimeter() {\n        return 2 * (x2 - x1) + 2 * (y2 - y1);\n    }\n\n    @Override\n    public double area() {\n        return (x2 - x1) * (y2 - y1);\n    }\n\n    @Override\n    public boolean isDoublePrecision() {\n        return true;\n    }\n\n}", "definition": "public final class RectangleDouble implements Rectangle", "class_docstring": "", "name": "RectangleDouble", "super_interfaces": ["Rectangle"], "superclasses": "", "attributes": {"modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "fields": [{"attribute_expression": "private final double x1, y1, x2, y2;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "double", "name": "x1", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    private RectangleDouble(double x1, double y1, double x2, double y2) {\n        Preconditions.checkArgument(x2 >= x1);\n        Preconditions.checkArgument(y2 >= y1);\n        this.x1 = x1;\n        this.y1 = y1;\n        this.x2 = x2;\n        this.y2 = y2;\n    }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "", "classes": []}, "name": "RectangleDouble", "params": [{"name": "x1", "type": "double"}, {"name": "y1", "type": "double"}, {"name": "x2", "type": "double"}, {"name": "y2", "type": "double"}], "body": "                                                                        {\n        Preconditions.checkArgument(x2 >= x1);\n        Preconditions.checkArgument(y2 >= y1);\n        this.x1 = x1;\n        this.y1 = y1;\n        this.x2 = x2;\n        this.y2 = y2;\n    }", "signature": "private RectangleDouble(double x1, double y1, double x2, double y2)"}, {"syntax_pass": true, "original_string": "    public static RectangleDouble create(double x1, double y1, double x2, double y2) {\n        return new RectangleDouble((double) x1, (double) y1, (double) x2, (double) y2);\n    }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "RectangleDouble", "classes": []}, "name": "create", "params": [{"name": "x1", "type": "double"}, {"name": "y1", "type": "double"}, {"name": "x2", "type": "double"}, {"name": "y2", "type": "double"}], "body": "                                                                                     {\n        return new RectangleDouble((double) x1, (double) y1, (double) x2, (double) y2);\n    }", "signature": "public static RectangleDouble create(double x1, double y1, double x2, double y2)"}, {"syntax_pass": true, "original_string": "    @Override\n    public double x1() {\n        return x1;\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "double", "classes": []}, "name": "x1", "params": [], "body": "                       {\n        return x1;\n    }", "signature": "@Override\n    public double x1()"}, {"syntax_pass": true, "original_string": "    @Override\n    public double y1() {\n        return y1;\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "double", "classes": []}, "name": "y1", "params": [], "body": "                       {\n        return y1;\n    }", "signature": "@Override\n    public double y1()"}, {"syntax_pass": true, "original_string": "    @Override\n    public double x2() {\n        return x2;\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "double", "classes": []}, "name": "x2", "params": [], "body": "                       {\n        return x2;\n    }", "signature": "@Override\n    public double x2()"}, {"syntax_pass": true, "original_string": "    @Override\n    public double y2() {\n        return  y2;\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "double", "classes": []}, "name": "y2", "params": [], "body": "                       {\n        return  y2;\n    }", "signature": "@Override\n    public double y2()"}, {"syntax_pass": true, "original_string": "    @Override\n    public Rectangle add(Rectangle r) {\n        return new RectangleDouble(min(x1, r.x1()), min(y1, r.y1()), max(x2, r.x2()),\n                max(y2, r.y2()));\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Rectangle", "classes": []}, "name": "add", "params": [{"name": "r", "type": "Rectangle"}], "body": "                                      {\n        return new RectangleDouble(min(x1, r.x1()), min(y1, r.y1()), max(x2, r.x2()),\n                max(y2, r.y2()));\n    }", "signature": "@Override\n    public Rectangle add(Rectangle r)"}, {"syntax_pass": true, "original_string": "    @Override\n    public boolean contains(double x, double y) {\n        return x >= x1 && x <= x2 && y >= y1 && y <= y2;\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "contains", "params": [{"name": "x", "type": "double"}, {"name": "y", "type": "double"}], "body": "                                                {\n        return x >= x1 && x <= x2 && y >= y1 && y <= y2;\n    }", "signature": "@Override\n    public boolean contains(double x, double y)"}, {"syntax_pass": true, "original_string": "    @Override\n    public boolean intersects(Rectangle r) {\n        if (r instanceof RectangleDouble) {\n            RectangleDouble rd = (RectangleDouble) r;\n            return intersects(rd);\n        } else {\n            return GeometryUtil.intersects(x1, y1, x2, y2, r.x1(), r.y1(), r.x2(), r.y2());\n        }\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "intersects", "params": [{"name": "r", "type": "Rectangle"}], "body": "                                           {\n        if (r instanceof RectangleDouble) {\n            RectangleDouble rd = (RectangleDouble) r;\n            return intersects(rd);\n        } else {\n            return GeometryUtil.intersects(x1, y1, x2, y2, r.x1(), r.y1(), r.x2(), r.y2());\n        }\n    }", "signature": "@Override\n    public boolean intersects(Rectangle r)"}, {"syntax_pass": true, "original_string": "    private boolean intersects(RectangleDouble rd) {\n        return GeometryUtil.intersects(x1, y1, x2, y2, rd.x1, rd.y1, rd.x2, rd.y2);\n    }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "boolean", "classes": []}, "name": "intersects", "params": [{"name": "rd", "type": "RectangleDouble"}], "body": "                                                   {\n        return GeometryUtil.intersects(x1, y1, x2, y2, rd.x1, rd.y1, rd.x2, rd.y2);\n    }", "signature": "private boolean intersects(RectangleDouble rd)"}, {"syntax_pass": true, "original_string": "    @Override\n    public double distance(Rectangle r) {\n        return GeometryUtil.distance(x1, y1, x2, y2, r.x1(), r.y1(), r.x2(), r.y2());\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "double", "classes": []}, "name": "distance", "params": [{"name": "r", "type": "Rectangle"}], "body": "                                        {\n        return GeometryUtil.distance(x1, y1, x2, y2, r.x1(), r.y1(), r.x2(), r.y2());\n    }", "signature": "@Override\n    public double distance(Rectangle r)"}, {"syntax_pass": true, "original_string": "    @Override\n    public Rectangle mbr() {\n        return this;\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Rectangle", "classes": []}, "name": "mbr", "params": [], "body": "                           {\n        return this;\n    }", "signature": "@Override\n    public Rectangle mbr()"}, {"syntax_pass": true, "original_string": "    @Override\n    public String toString() {\n        return \"Rectangle [x1=\" + x1 + \", y1=\" + y1 + \", x2=\" + x2 + \", y2=\" + y2 + \"]\";\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "toString", "params": [], "body": "                             {\n        return \"Rectangle [x1=\" + x1 + \", y1=\" + y1 + \", x2=\" + x2 + \", y2=\" + y2 + \"]\";\n    }", "signature": "@Override\n    public String toString()"}, {"syntax_pass": true, "original_string": "    @Override\n    public int hashCode() {\n        return Objects.hash(x1, y1, x2, y2);\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "hashCode", "params": [], "body": "                          {\n        return Objects.hash(x1, y1, x2, y2);\n    }", "signature": "@Override\n    public int hashCode()"}, {"syntax_pass": true, "original_string": "    @Override\n    public boolean equals(Object obj) {\n        Optional<RectangleDouble> other = ObjectsHelper.asClass(obj, RectangleDouble.class);\n        if (other.isPresent()) {\n            return Objects.equals(x1, other.get().x1) && Objects.equals(x2, other.get().x2)\n                    && Objects.equals(y1, other.get().y1) && Objects.equals(y2, other.get().y2);\n        } else\n            return false;\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "equals", "params": [{"name": "obj", "type": "Object"}], "body": "                                      {\n        Optional<RectangleDouble> other = ObjectsHelper.asClass(obj, RectangleDouble.class);\n        if (other.isPresent()) {\n            return Objects.equals(x1, other.get().x1) && Objects.equals(x2, other.get().x2)\n                    && Objects.equals(y1, other.get().y1) && Objects.equals(y2, other.get().y2);\n        } else\n            return false;\n    }", "signature": "@Override\n    public boolean equals(Object obj)"}, {"syntax_pass": true, "original_string": "    @Override\n    public double intersectionArea(Rectangle r) {\n        if (!intersects(r))\n            return 0;\n        else {\n            return create(max(x1, r.x1()), max(y1, r.y1()), min(x2, r.x2()), min(y2, r.y2()))\n                    .area();\n        }\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "double", "classes": []}, "name": "intersectionArea", "params": [{"name": "r", "type": "Rectangle"}], "body": "                                                {\n        if (!intersects(r))\n            return 0;\n        else {\n            return create(max(x1, r.x1()), max(y1, r.y1()), min(x2, r.x2()), min(y2, r.y2()))\n                    .area();\n        }\n    }", "signature": "@Override\n    public double intersectionArea(Rectangle r)"}, {"syntax_pass": true, "original_string": "    @Override\n    public Geometry geometry() {\n        return this;\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Geometry", "classes": []}, "name": "geometry", "params": [], "body": "                               {\n        return this;\n    }", "signature": "@Override\n    public Geometry geometry()"}, {"syntax_pass": true, "original_string": "    private static double max(double a, double b) {\n        if (a < b)\n            return b;\n        else\n            return a;\n    }", "docstring": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "double", "classes": []}, "name": "max", "params": [{"name": "a", "type": "double"}, {"name": "b", "type": "double"}], "body": "                                                  {\n        if (a < b)\n            return b;\n        else\n            return a;\n    }", "signature": "private static double max(double a, double b)"}, {"syntax_pass": true, "original_string": "    private static double min(double a, double b) {\n        if (a < b)\n            return a;\n        else\n            return b;\n    }", "docstring": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "double", "classes": []}, "name": "min", "params": [{"name": "a", "type": "double"}, {"name": "b", "type": "double"}], "body": "                                                  {\n        if (a < b)\n            return a;\n        else\n            return b;\n    }", "signature": "private static double min(double a, double b)"}, {"syntax_pass": true, "original_string": "    @Override\n    public double perimeter() {\n        return 2 * (x2 - x1) + 2 * (y2 - y1);\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "double", "classes": []}, "name": "perimeter", "params": [], "body": "                              {\n        return 2 * (x2 - x1) + 2 * (y2 - y1);\n    }", "signature": "@Override\n    public double perimeter()"}, {"syntax_pass": true, "original_string": "    @Override\n    public double area() {\n        return (x2 - x1) * (y2 - y1);\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "double", "classes": []}, "name": "area", "params": [], "body": "                         {\n        return (x2 - x1) * (y2 - y1);\n    }", "signature": "@Override\n    public double area()"}, {"syntax_pass": true, "original_string": "    @Override\n    public boolean isDoublePrecision() {\n        return true;\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isDoublePrecision", "params": [], "body": "                                       {\n        return true;\n    }", "signature": "@Override\n    public boolean isDoublePrecision()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/com/github/davidmoten/rtree/geometry/internal/Vector.java", "original_string": "package com.github.davidmoten.rtree.geometry.internal;\n\nfinal class Vector {\n\n    final double x;\n    final double y;\n\n    static Vector create(double x, double y) {\n        return new Vector(x, y);\n    }\n\n    Vector(double x, double y) {\n        this.x = x;\n        this.y = y;\n    }\n\n    double dot(Vector v) {\n        return x * v.x + y * v.y;\n    }\n\n    Vector times(double value) {\n        return create(value * x, value * y);\n    }\n\n    Vector minus(Vector v) {\n        return create(x - v.x, y - v.y);\n    }\n\n    double modulus() {\n        return Math.sqrt(modulusSquared());\n    }\n\n    double modulusSquared() {\n        return x * x + y * y;\n    }\n\n}\n", "file_hash": "64ad1607a233682d2c254d893097187134dfd26c218bdd8e49dd2a1e1319a539", "file_docstring": "", "contexts": ["package com.github.davidmoten.rtree.geometry.internal;"], "methods": [], "classes": [{"original_string": "final class Vector {\n\n    final double x;\n    final double y;\n\n    static Vector create(double x, double y) {\n        return new Vector(x, y);\n    }\n\n    Vector(double x, double y) {\n        this.x = x;\n        this.y = y;\n    }\n\n    double dot(Vector v) {\n        return x * v.x + y * v.y;\n    }\n\n    Vector times(double value) {\n        return create(value * x, value * y);\n    }\n\n    Vector minus(Vector v) {\n        return create(x - v.x, y - v.y);\n    }\n\n    double modulus() {\n        return Math.sqrt(modulusSquared());\n    }\n\n    double modulusSquared() {\n        return x * x + y * y;\n    }\n\n}", "definition": "final class Vector", "class_docstring": "", "name": "Vector", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "fields": [{"attribute_expression": "final double x;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "double", "name": "x", "syntax_pass": true}, {"attribute_expression": "final double y;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "double", "name": "y", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    static Vector create(double x, double y) {\n        return new Vector(x, y);\n    }", "docstring": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "Vector", "classes": []}, "name": "create", "params": [{"name": "x", "type": "double"}, {"name": "y", "type": "double"}], "body": "                                             {\n        return new Vector(x, y);\n    }", "signature": "static Vector create(double x, double y)"}, {"syntax_pass": true, "original_string": "    Vector(double x, double y) {\n        this.x = x;\n        this.y = y;\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "Vector", "params": [{"name": "x", "type": "double"}, {"name": "y", "type": "double"}], "body": "                               {\n        this.x = x;\n        this.y = y;\n    }", "signature": "Vector(double x, double y)"}, {"syntax_pass": true, "original_string": "    double dot(Vector v) {\n        return x * v.x + y * v.y;\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "double", "classes": []}, "name": "dot", "params": [{"name": "v", "type": "Vector"}], "body": "                         {\n        return x * v.x + y * v.y;\n    }", "signature": "double dot(Vector v)"}, {"syntax_pass": true, "original_string": "    Vector times(double value) {\n        return create(value * x, value * y);\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "Vector", "classes": []}, "name": "times", "params": [{"name": "value", "type": "double"}], "body": "                               {\n        return create(value * x, value * y);\n    }", "signature": "Vector times(double value)"}, {"syntax_pass": true, "original_string": "    Vector minus(Vector v) {\n        return create(x - v.x, y - v.y);\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "Vector", "classes": []}, "name": "minus", "params": [{"name": "v", "type": "Vector"}], "body": "                           {\n        return create(x - v.x, y - v.y);\n    }", "signature": "Vector minus(Vector v)"}, {"syntax_pass": true, "original_string": "    double modulus() {\n        return Math.sqrt(modulusSquared());\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "double", "classes": []}, "name": "modulus", "params": [], "body": "                     {\n        return Math.sqrt(modulusSquared());\n    }", "signature": "double modulus()"}, {"syntax_pass": true, "original_string": "    double modulusSquared() {\n        return x * x + y * y;\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "double", "classes": []}, "name": "modulusSquared", "params": [], "body": "                            {\n        return x * x + y * y;\n    }", "signature": "double modulusSquared()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/com/github/davidmoten/rtree/geometry/internal/GeometryUtil.java", "original_string": "package com.github.davidmoten.rtree.geometry.internal;\n\nimport com.github.davidmoten.rtree.geometry.Circle;\nimport com.github.davidmoten.rtree.geometry.Rectangle;\n\npublic final class GeometryUtil {\n\n    private GeometryUtil() {\n        // prevent instantiation\n    }\n\n    public static double distanceSquared(double x1, double y1, double x2, double y2) {\n        double dx = x2 - x1;\n        double dy = y2 - y1;\n        return dx * dx + dy * dy;\n    }\n\n    public static double max(double a, double b) {\n        if (a < b)\n            return b;\n        else\n            return a;\n    }\n\n    public static float max(float a, float b) {\n        if (a < b)\n            return b;\n        else\n            return a;\n    }\n\n    public static double min(double a, double b) {\n        if (a < b)\n            return a;\n        else\n            return b;\n    }\n\n    public static float min(float a, float b) {\n        if (a < b)\n            return a;\n        else\n            return b;\n    }\n\n    public static double distance(double x, double y, Rectangle r) {\n        return distance(x, y, r.x1(), r.y1(), r.x2(), r.y2());\n    }\n\n    public static double distance(double x, double y, double a1, double b1, double a2, double b2) {\n        return distance(x, y, x, y, a1, b1, a2, b2);\n    }\n\n    public static double distance(double x1, double y1, double x2, double y2, double a1, double b1,\n            double a2, double b2) {\n        if (intersects(x1, y1, x2, y2, a1, b1, a2, b2)) {\n            return 0;\n        }\n        boolean xyMostLeft = x1 < a1;\n        double mostLeftX1 = xyMostLeft ? x1 : a1;\n        double mostRightX1 = xyMostLeft ? a1 : x1;\n        double mostLeftX2 = xyMostLeft ? x2 : a2;\n        double xDifference = max(0, mostLeftX1 == mostRightX1 ? 0 : mostRightX1 - mostLeftX2);\n\n        boolean xyMostDown = y1 < b1;\n        double mostDownY1 = xyMostDown ? y1 : b1;\n        double mostUpY1 = xyMostDown ? b1 : y1;\n        double mostDownY2 = xyMostDown ? y2 : b2;\n\n        double yDifference = max(0, mostDownY1 == mostUpY1 ? 0 : mostUpY1 - mostDownY2);\n\n        return Math.sqrt(xDifference * xDifference + yDifference * yDifference);\n    }\n\n    public static boolean intersects(double x1, double y1, double x2, double y2, double a1,\n            double b1, double a2, double b2) {\n        return x1 <= a2 && a1 <= x2 && y1 <= b2 && b1 <= y2;\n    }\n    \n    public static boolean lineIntersects(double x1, double y1, double x2, double y2, Circle circle) {\n\n        // using Vector Projection\n        // https://en.wikipedia.org/wiki/Vector_projection\n        Vector c = Vector.create(circle.x(), circle.y());\n        Vector a = Vector.create(x1, y1);\n        Vector cMinusA = c.minus(a);\n        double radiusSquared = circle.radius() * circle.radius();\n        if (x1 == x2 && y1 == y2) {\n            return cMinusA.modulusSquared() <= radiusSquared;\n        } else {\n            Vector b = Vector.create(x2, y2);\n            Vector bMinusA = b.minus(a);\n            double bMinusAModulus = bMinusA.modulus();\n            double lambda = cMinusA.dot(bMinusA) / bMinusAModulus;\n            // if projection is on the segment\n            if (lambda >= 0 && lambda <= bMinusAModulus) {\n                Vector dMinusA = bMinusA.times(lambda / bMinusAModulus);\n                // calculate distance to line from c using pythagoras' theorem\n                return cMinusA.modulusSquared() - dMinusA.modulusSquared() <= radiusSquared;\n            } else {\n                // return true if and only if an endpoint is within radius of\n                // centre\n                return cMinusA.modulusSquared() <= radiusSquared\n                        || c.minus(b).modulusSquared() <= radiusSquared;\n            }\n        }\n\n    }\n\n\n}\n", "file_hash": "da2fe062b1d51295c0e4c6f06f3add2a7666f8646f264c02507c46660f0b7f2a", "file_docstring": "", "contexts": ["package com.github.davidmoten.rtree.geometry.internal;", "import com.github.davidmoten.rtree.geometry.Circle;", "import com.github.davidmoten.rtree.geometry.Rectangle;"], "methods": [], "classes": [{"original_string": "public final class GeometryUtil {\n\n    private GeometryUtil() {\n        // prevent instantiation\n    }\n\n    public static double distanceSquared(double x1, double y1, double x2, double y2) {\n        double dx = x2 - x1;\n        double dy = y2 - y1;\n        return dx * dx + dy * dy;\n    }\n\n    public static double max(double a, double b) {\n        if (a < b)\n            return b;\n        else\n            return a;\n    }\n\n    public static float max(float a, float b) {\n        if (a < b)\n            return b;\n        else\n            return a;\n    }\n\n    public static double min(double a, double b) {\n        if (a < b)\n            return a;\n        else\n            return b;\n    }\n\n    public static float min(float a, float b) {\n        if (a < b)\n            return a;\n        else\n            return b;\n    }\n\n    public static double distance(double x, double y, Rectangle r) {\n        return distance(x, y, r.x1(), r.y1(), r.x2(), r.y2());\n    }\n\n    public static double distance(double x, double y, double a1, double b1, double a2, double b2) {\n        return distance(x, y, x, y, a1, b1, a2, b2);\n    }\n\n    public static double distance(double x1, double y1, double x2, double y2, double a1, double b1,\n            double a2, double b2) {\n        if (intersects(x1, y1, x2, y2, a1, b1, a2, b2)) {\n            return 0;\n        }\n        boolean xyMostLeft = x1 < a1;\n        double mostLeftX1 = xyMostLeft ? x1 : a1;\n        double mostRightX1 = xyMostLeft ? a1 : x1;\n        double mostLeftX2 = xyMostLeft ? x2 : a2;\n        double xDifference = max(0, mostLeftX1 == mostRightX1 ? 0 : mostRightX1 - mostLeftX2);\n\n        boolean xyMostDown = y1 < b1;\n        double mostDownY1 = xyMostDown ? y1 : b1;\n        double mostUpY1 = xyMostDown ? b1 : y1;\n        double mostDownY2 = xyMostDown ? y2 : b2;\n\n        double yDifference = max(0, mostDownY1 == mostUpY1 ? 0 : mostUpY1 - mostDownY2);\n\n        return Math.sqrt(xDifference * xDifference + yDifference * yDifference);\n    }\n\n    public static boolean intersects(double x1, double y1, double x2, double y2, double a1,\n            double b1, double a2, double b2) {\n        return x1 <= a2 && a1 <= x2 && y1 <= b2 && b1 <= y2;\n    }\n    \n    public static boolean lineIntersects(double x1, double y1, double x2, double y2, Circle circle) {\n\n        // using Vector Projection\n        // https://en.wikipedia.org/wiki/Vector_projection\n        Vector c = Vector.create(circle.x(), circle.y());\n        Vector a = Vector.create(x1, y1);\n        Vector cMinusA = c.minus(a);\n        double radiusSquared = circle.radius() * circle.radius();\n        if (x1 == x2 && y1 == y2) {\n            return cMinusA.modulusSquared() <= radiusSquared;\n        } else {\n            Vector b = Vector.create(x2, y2);\n            Vector bMinusA = b.minus(a);\n            double bMinusAModulus = bMinusA.modulus();\n            double lambda = cMinusA.dot(bMinusA) / bMinusAModulus;\n            // if projection is on the segment\n            if (lambda >= 0 && lambda <= bMinusAModulus) {\n                Vector dMinusA = bMinusA.times(lambda / bMinusAModulus);\n                // calculate distance to line from c using pythagoras' theorem\n                return cMinusA.modulusSquared() - dMinusA.modulusSquared() <= radiusSquared;\n            } else {\n                // return true if and only if an endpoint is within radius of\n                // centre\n                return cMinusA.modulusSquared() <= radiusSquared\n                        || c.minus(b).modulusSquared() <= radiusSquared;\n            }\n        }\n\n    }\n\n\n}", "definition": "public final class GeometryUtil", "class_docstring": "", "name": "GeometryUtil", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    private GeometryUtil() {\n        // prevent instantiation\n    }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "", "classes": []}, "name": "GeometryUtil", "params": [], "body": "                           {\n        // prevent instantiation\n    }", "signature": "private GeometryUtil()"}, {"syntax_pass": true, "original_string": "    public static double distanceSquared(double x1, double y1, double x2, double y2) {\n        double dx = x2 - x1;\n        double dy = y2 - y1;\n        return dx * dx + dy * dy;\n    }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "double", "classes": []}, "name": "distanceSquared", "params": [{"name": "x1", "type": "double"}, {"name": "y1", "type": "double"}, {"name": "x2", "type": "double"}, {"name": "y2", "type": "double"}], "body": "                                                                                     {\n        double dx = x2 - x1;\n        double dy = y2 - y1;\n        return dx * dx + dy * dy;\n    }", "signature": "public static double distanceSquared(double x1, double y1, double x2, double y2)"}, {"syntax_pass": true, "original_string": "    public static double max(double a, double b) {\n        if (a < b)\n            return b;\n        else\n            return a;\n    }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "double", "classes": []}, "name": "max", "params": [{"name": "a", "type": "double"}, {"name": "b", "type": "double"}], "body": "                                                 {\n        if (a < b)\n            return b;\n        else\n            return a;\n    }", "signature": "public static double max(double a, double b)"}, {"syntax_pass": true, "original_string": "    public static float max(float a, float b) {\n        if (a < b)\n            return b;\n        else\n            return a;\n    }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "float", "classes": []}, "name": "max", "params": [{"name": "a", "type": "float"}, {"name": "b", "type": "float"}], "body": "                                              {\n        if (a < b)\n            return b;\n        else\n            return a;\n    }", "signature": "public static float max(float a, float b)"}, {"syntax_pass": true, "original_string": "    public static double min(double a, double b) {\n        if (a < b)\n            return a;\n        else\n            return b;\n    }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "double", "classes": []}, "name": "min", "params": [{"name": "a", "type": "double"}, {"name": "b", "type": "double"}], "body": "                                                 {\n        if (a < b)\n            return a;\n        else\n            return b;\n    }", "signature": "public static double min(double a, double b)"}, {"syntax_pass": true, "original_string": "    public static float min(float a, float b) {\n        if (a < b)\n            return a;\n        else\n            return b;\n    }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "float", "classes": []}, "name": "min", "params": [{"name": "a", "type": "float"}, {"name": "b", "type": "float"}], "body": "                                              {\n        if (a < b)\n            return a;\n        else\n            return b;\n    }", "signature": "public static float min(float a, float b)"}, {"syntax_pass": true, "original_string": "    public static double distance(double x, double y, Rectangle r) {\n        return distance(x, y, r.x1(), r.y1(), r.x2(), r.y2());\n    }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "double", "classes": []}, "name": "distance", "params": [{"name": "x", "type": "double"}, {"name": "y", "type": "double"}, {"name": "r", "type": "Rectangle"}], "body": "                                                                   {\n        return distance(x, y, r.x1(), r.y1(), r.x2(), r.y2());\n    }", "signature": "public static double distance(double x, double y, Rectangle r)"}, {"syntax_pass": true, "original_string": "    public static double distance(double x, double y, double a1, double b1, double a2, double b2) {\n        return distance(x, y, x, y, a1, b1, a2, b2);\n    }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "double", "classes": []}, "name": "distance", "params": [{"name": "x", "type": "double"}, {"name": "y", "type": "double"}, {"name": "a1", "type": "double"}, {"name": "b1", "type": "double"}, {"name": "a2", "type": "double"}, {"name": "b2", "type": "double"}], "body": "                                                                                                  {\n        return distance(x, y, x, y, a1, b1, a2, b2);\n    }", "signature": "public static double distance(double x, double y, double a1, double b1, double a2, double b2)"}, {"syntax_pass": true, "original_string": "    public static double distance(double x1, double y1, double x2, double y2, double a1, double b1,\n            double a2, double b2) {\n        if (intersects(x1, y1, x2, y2, a1, b1, a2, b2)) {\n            return 0;\n        }\n        boolean xyMostLeft = x1 < a1;\n        double mostLeftX1 = xyMostLeft ? x1 : a1;\n        double mostRightX1 = xyMostLeft ? a1 : x1;\n        double mostLeftX2 = xyMostLeft ? x2 : a2;\n        double xDifference = max(0, mostLeftX1 == mostRightX1 ? 0 : mostRightX1 - mostLeftX2);\n\n        boolean xyMostDown = y1 < b1;\n        double mostDownY1 = xyMostDown ? y1 : b1;\n        double mostUpY1 = xyMostDown ? b1 : y1;\n        double mostDownY2 = xyMostDown ? y2 : b2;\n\n        double yDifference = max(0, mostDownY1 == mostUpY1 ? 0 : mostUpY1 - mostDownY2);\n\n        return Math.sqrt(xDifference * xDifference + yDifference * yDifference);\n    }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "double", "classes": []}, "name": "distance", "params": [{"name": "x1", "type": "double"}, {"name": "y1", "type": "double"}, {"name": "x2", "type": "double"}, {"name": "y2", "type": "double"}, {"name": "a1", "type": "double"}, {"name": "b1", "type": "double"}, {"name": "a2", "type": "double"}, {"name": "b2", "type": "double"}], "body": "                                  {\n        if (intersects(x1, y1, x2, y2, a1, b1, a2, b2)) {\n            return 0;\n        }\n        boolean xyMostLeft = x1 < a1;\n        double mostLeftX1 = xyMostLeft ? x1 : a1;\n        double mostRightX1 = xyMostLeft ? a1 : x1;\n        double mostLeftX2 = xyMostLeft ? x2 : a2;\n        double xDifference = max(0, mostLeftX1 == mostRightX1 ? 0 : mostRightX1 - mostLeftX2);\n\n        boolean xyMostDown = y1 < b1;\n        double mostDownY1 = xyMostDown ? y1 : b1;\n        double mostUpY1 = xyMostDown ? b1 : y1;\n        double mostDownY2 = xyMostDown ? y2 : b2;\n\n        double yDifference = max(0, mostDownY1 == mostUpY1 ? 0 : mostUpY1 - mostDownY2);\n\n        return Math.sqrt(xDifference * xDifference + yDifference * yDifference);\n    }", "signature": "public static double distance(double x1, double y1, double x2, double y2, double a1, double b1,\n            double a2, double b2)"}, {"syntax_pass": true, "original_string": "    public static boolean intersects(double x1, double y1, double x2, double y2, double a1,\n            double b1, double a2, double b2) {\n        return x1 <= a2 && a1 <= x2 && y1 <= b2 && b1 <= y2;\n    }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "boolean", "classes": []}, "name": "intersects", "params": [{"name": "x1", "type": "double"}, {"name": "y1", "type": "double"}, {"name": "x2", "type": "double"}, {"name": "y2", "type": "double"}, {"name": "a1", "type": "double"}, {"name": "b1", "type": "double"}, {"name": "a2", "type": "double"}, {"name": "b2", "type": "double"}], "body": "                                             {\n        return x1 <= a2 && a1 <= x2 && y1 <= b2 && b1 <= y2;\n    }", "signature": "public static boolean intersects(double x1, double y1, double x2, double y2, double a1,\n            double b1, double a2, double b2)"}, {"syntax_pass": true, "original_string": "    public static boolean lineIntersects(double x1, double y1, double x2, double y2, Circle circle) {\n\n        // using Vector Projection\n        // https://en.wikipedia.org/wiki/Vector_projection\n        Vector c = Vector.create(circle.x(), circle.y());\n        Vector a = Vector.create(x1, y1);\n        Vector cMinusA = c.minus(a);\n        double radiusSquared = circle.radius() * circle.radius();\n        if (x1 == x2 && y1 == y2) {\n            return cMinusA.modulusSquared() <= radiusSquared;\n        } else {\n            Vector b = Vector.create(x2, y2);\n            Vector bMinusA = b.minus(a);\n            double bMinusAModulus = bMinusA.modulus();\n            double lambda = cMinusA.dot(bMinusA) / bMinusAModulus;\n            // if projection is on the segment\n            if (lambda >= 0 && lambda <= bMinusAModulus) {\n                Vector dMinusA = bMinusA.times(lambda / bMinusAModulus);\n                // calculate distance to line from c using pythagoras' theorem\n                return cMinusA.modulusSquared() - dMinusA.modulusSquared() <= radiusSquared;\n            } else {\n                // return true if and only if an endpoint is within radius of\n                // centre\n                return cMinusA.modulusSquared() <= radiusSquared\n                        || c.minus(b).modulusSquared() <= radiusSquared;\n            }\n        }\n\n    }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "boolean", "classes": []}, "name": "lineIntersects", "params": [{"name": "x1", "type": "double"}, {"name": "y1", "type": "double"}, {"name": "x2", "type": "double"}, {"name": "y2", "type": "double"}, {"name": "circle", "type": "Circle"}], "body": "                                                                                                    {\n\n        // using Vector Projection\n        // https://en.wikipedia.org/wiki/Vector_projection\n        Vector c = Vector.create(circle.x(), circle.y());\n        Vector a = Vector.create(x1, y1);\n        Vector cMinusA = c.minus(a);\n        double radiusSquared = circle.radius() * circle.radius();\n        if (x1 == x2 && y1 == y2) {\n            return cMinusA.modulusSquared() <= radiusSquared;\n        } else {\n            Vector b = Vector.create(x2, y2);\n            Vector bMinusA = b.minus(a);\n            double bMinusAModulus = bMinusA.modulus();\n            double lambda = cMinusA.dot(bMinusA) / bMinusAModulus;\n            // if projection is on the segment\n            if (lambda >= 0 && lambda <= bMinusAModulus) {\n                Vector dMinusA = bMinusA.times(lambda / bMinusAModulus);\n                // calculate distance to line from c using pythagoras' theorem\n                return cMinusA.modulusSquared() - dMinusA.modulusSquared() <= radiusSquared;\n            } else {\n                // return true if and only if an endpoint is within radius of\n                // centre\n                return cMinusA.modulusSquared() <= radiusSquared\n                        || c.minus(b).modulusSquared() <= radiusSquared;\n            }\n        }\n\n    }", "signature": "public static boolean lineIntersects(double x1, double y1, double x2, double y2, Circle circle)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/com/github/davidmoten/rtree/geometry/internal/CircleFloat.java", "original_string": "package com.github.davidmoten.rtree.geometry.internal;\n\nimport com.github.davidmoten.rtree.geometry.Circle;\nimport com.github.davidmoten.rtree.geometry.Line;\nimport com.github.davidmoten.rtree.geometry.Point;\nimport com.github.davidmoten.rtree.geometry.Rectangle;\nimport com.github.davidmoten.rtree.internal.util.ObjectsHelper;\n\nimport java.util.Objects;\nimport java.util.Optional;\n\npublic final class CircleFloat implements Circle {\n\n    private final float x, y, radius;\n    private final Rectangle mbr;\n\n    private CircleFloat(float x, float y, float radius) {\n        this.x = x;\n        this.y = y;\n        this.radius = radius;\n        this.mbr = RectangleFloat.create(x - radius, y - radius, x + radius, y + radius);\n    }\n\n    public static CircleFloat create(float x, float y, float radius) {\n        return new CircleFloat(x, y, radius);\n    }\n\n    @Override\n    public double x() {\n        return x;\n    }\n\n    @Override\n    public double y() {\n        return y;\n    }\n\n    @Override\n    public double radius() {\n        return radius;\n    }\n\n    @Override\n    public Rectangle mbr() {\n        return mbr;\n    }\n\n    @Override\n    public double distance(Rectangle r) {\n        return Math.max(0, GeometryUtil.distance(x, y, r) - radius);\n    }\n\n    @Override\n    public boolean intersects(Rectangle r) {\n        return distance(r) == 0;\n    }\n\n    @Override\n    public boolean intersects(Circle c) {\n        double total = radius + c.radius();\n        return GeometryUtil.distanceSquared(x, y, c.x(), c.y()) <= total * total;\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(x, y, radius);\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        Optional<CircleFloat> other = ObjectsHelper.asClass(obj, CircleFloat.class);\n        if (other.isPresent()) {\n            return Objects.equals(x, other.get().x) && Objects.equals(y, other.get().y)\n                    && Objects.equals(radius, other.get().radius);\n        } else\n            return false;\n    }\n\n    @Override\n    public boolean intersects(Point point) {\n        return Math.sqrt(sqr(x - point.x()) + sqr(y - point.y())) <= radius;\n    }\n\n    private double sqr(double x) {\n        return x * x;\n    }\n\n    @Override\n    public boolean intersects(Line line) {\n        return line.intersects(this);\n    }\n\n    @Override\n    public boolean isDoublePrecision() {\n        return false;\n    }\n}\n", "file_hash": "18ade635fd08fa5857e1a2eb6f8da787de4df0b7a6237031acf813fdee6b87b3", "file_docstring": "", "contexts": ["package com.github.davidmoten.rtree.geometry.internal;", "import com.github.davidmoten.rtree.geometry.Circle;", "import com.github.davidmoten.rtree.geometry.Line;", "import com.github.davidmoten.rtree.geometry.Point;", "import com.github.davidmoten.rtree.geometry.Rectangle;", "import com.github.davidmoten.rtree.internal.util.ObjectsHelper;", "import java.util.Objects;", "import java.util.Optional;"], "methods": [], "classes": [{"original_string": "public final class CircleFloat implements Circle {\n\n    private final float x, y, radius;\n    private final Rectangle mbr;\n\n    private CircleFloat(float x, float y, float radius) {\n        this.x = x;\n        this.y = y;\n        this.radius = radius;\n        this.mbr = RectangleFloat.create(x - radius, y - radius, x + radius, y + radius);\n    }\n\n    public static CircleFloat create(float x, float y, float radius) {\n        return new CircleFloat(x, y, radius);\n    }\n\n    @Override\n    public double x() {\n        return x;\n    }\n\n    @Override\n    public double y() {\n        return y;\n    }\n\n    @Override\n    public double radius() {\n        return radius;\n    }\n\n    @Override\n    public Rectangle mbr() {\n        return mbr;\n    }\n\n    @Override\n    public double distance(Rectangle r) {\n        return Math.max(0, GeometryUtil.distance(x, y, r) - radius);\n    }\n\n    @Override\n    public boolean intersects(Rectangle r) {\n        return distance(r) == 0;\n    }\n\n    @Override\n    public boolean intersects(Circle c) {\n        double total = radius + c.radius();\n        return GeometryUtil.distanceSquared(x, y, c.x(), c.y()) <= total * total;\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(x, y, radius);\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        Optional<CircleFloat> other = ObjectsHelper.asClass(obj, CircleFloat.class);\n        if (other.isPresent()) {\n            return Objects.equals(x, other.get().x) && Objects.equals(y, other.get().y)\n                    && Objects.equals(radius, other.get().radius);\n        } else\n            return false;\n    }\n\n    @Override\n    public boolean intersects(Point point) {\n        return Math.sqrt(sqr(x - point.x()) + sqr(y - point.y())) <= radius;\n    }\n\n    private double sqr(double x) {\n        return x * x;\n    }\n\n    @Override\n    public boolean intersects(Line line) {\n        return line.intersects(this);\n    }\n\n    @Override\n    public boolean isDoublePrecision() {\n        return false;\n    }\n}", "definition": "public final class CircleFloat implements Circle", "class_docstring": "", "name": "CircleFloat", "super_interfaces": ["Circle"], "superclasses": "", "attributes": {"modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "fields": [{"attribute_expression": "private final float x, y, radius;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "float", "name": "x", "syntax_pass": true}, {"attribute_expression": "private final Rectangle mbr;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Rectangle", "name": "mbr", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    private CircleFloat(float x, float y, float radius) {\n        this.x = x;\n        this.y = y;\n        this.radius = radius;\n        this.mbr = RectangleFloat.create(x - radius, y - radius, x + radius, y + radius);\n    }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "", "classes": []}, "name": "CircleFloat", "params": [{"name": "x", "type": "float"}, {"name": "y", "type": "float"}, {"name": "radius", "type": "float"}], "body": "                                                        {\n        this.x = x;\n        this.y = y;\n        this.radius = radius;\n        this.mbr = RectangleFloat.create(x - radius, y - radius, x + radius, y + radius);\n    }", "signature": "private CircleFloat(float x, float y, float radius)"}, {"syntax_pass": true, "original_string": "    public static CircleFloat create(float x, float y, float radius) {\n        return new CircleFloat(x, y, radius);\n    }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "CircleFloat", "classes": []}, "name": "create", "params": [{"name": "x", "type": "float"}, {"name": "y", "type": "float"}, {"name": "radius", "type": "float"}], "body": "                                                                     {\n        return new CircleFloat(x, y, radius);\n    }", "signature": "public static CircleFloat create(float x, float y, float radius)"}, {"syntax_pass": true, "original_string": "    @Override\n    public double x() {\n        return x;\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "double", "classes": []}, "name": "x", "params": [], "body": "                      {\n        return x;\n    }", "signature": "@Override\n    public double x()"}, {"syntax_pass": true, "original_string": "    @Override\n    public double y() {\n        return y;\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "double", "classes": []}, "name": "y", "params": [], "body": "                      {\n        return y;\n    }", "signature": "@Override\n    public double y()"}, {"syntax_pass": true, "original_string": "    @Override\n    public double radius() {\n        return radius;\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "double", "classes": []}, "name": "radius", "params": [], "body": "                           {\n        return radius;\n    }", "signature": "@Override\n    public double radius()"}, {"syntax_pass": true, "original_string": "    @Override\n    public Rectangle mbr() {\n        return mbr;\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Rectangle", "classes": []}, "name": "mbr", "params": [], "body": "                           {\n        return mbr;\n    }", "signature": "@Override\n    public Rectangle mbr()"}, {"syntax_pass": true, "original_string": "    @Override\n    public double distance(Rectangle r) {\n        return Math.max(0, GeometryUtil.distance(x, y, r) - radius);\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "double", "classes": []}, "name": "distance", "params": [{"name": "r", "type": "Rectangle"}], "body": "                                        {\n        return Math.max(0, GeometryUtil.distance(x, y, r) - radius);\n    }", "signature": "@Override\n    public double distance(Rectangle r)"}, {"syntax_pass": true, "original_string": "    @Override\n    public boolean intersects(Rectangle r) {\n        return distance(r) == 0;\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "intersects", "params": [{"name": "r", "type": "Rectangle"}], "body": "                                           {\n        return distance(r) == 0;\n    }", "signature": "@Override\n    public boolean intersects(Rectangle r)"}, {"syntax_pass": true, "original_string": "    @Override\n    public boolean intersects(Circle c) {\n        double total = radius + c.radius();\n        return GeometryUtil.distanceSquared(x, y, c.x(), c.y()) <= total * total;\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "intersects", "params": [{"name": "c", "type": "Circle"}], "body": "                                        {\n        double total = radius + c.radius();\n        return GeometryUtil.distanceSquared(x, y, c.x(), c.y()) <= total * total;\n    }", "signature": "@Override\n    public boolean intersects(Circle c)"}, {"syntax_pass": true, "original_string": "    @Override\n    public int hashCode() {\n        return Objects.hash(x, y, radius);\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "hashCode", "params": [], "body": "                          {\n        return Objects.hash(x, y, radius);\n    }", "signature": "@Override\n    public int hashCode()"}, {"syntax_pass": true, "original_string": "    @Override\n    public boolean equals(Object obj) {\n        Optional<CircleFloat> other = ObjectsHelper.asClass(obj, CircleFloat.class);\n        if (other.isPresent()) {\n            return Objects.equals(x, other.get().x) && Objects.equals(y, other.get().y)\n                    && Objects.equals(radius, other.get().radius);\n        } else\n            return false;\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "equals", "params": [{"name": "obj", "type": "Object"}], "body": "                                      {\n        Optional<CircleFloat> other = ObjectsHelper.asClass(obj, CircleFloat.class);\n        if (other.isPresent()) {\n            return Objects.equals(x, other.get().x) && Objects.equals(y, other.get().y)\n                    && Objects.equals(radius, other.get().radius);\n        } else\n            return false;\n    }", "signature": "@Override\n    public boolean equals(Object obj)"}, {"syntax_pass": true, "original_string": "    @Override\n    public boolean intersects(Point point) {\n        return Math.sqrt(sqr(x - point.x()) + sqr(y - point.y())) <= radius;\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "intersects", "params": [{"name": "point", "type": "Point"}], "body": "                                           {\n        return Math.sqrt(sqr(x - point.x()) + sqr(y - point.y())) <= radius;\n    }", "signature": "@Override\n    public boolean intersects(Point point)"}, {"syntax_pass": true, "original_string": "    private double sqr(double x) {\n        return x * x;\n    }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "double", "classes": []}, "name": "sqr", "params": [{"name": "x", "type": "double"}], "body": "                                 {\n        return x * x;\n    }", "signature": "private double sqr(double x)"}, {"syntax_pass": true, "original_string": "    @Override\n    public boolean intersects(Line line) {\n        return line.intersects(this);\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "intersects", "params": [{"name": "line", "type": "Line"}], "body": "                                         {\n        return line.intersects(this);\n    }", "signature": "@Override\n    public boolean intersects(Line line)"}, {"syntax_pass": true, "original_string": "    @Override\n    public boolean isDoublePrecision() {\n        return false;\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isDoublePrecision", "params": [], "body": "                                       {\n        return false;\n    }", "signature": "@Override\n    public boolean isDoublePrecision()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/com/github/davidmoten/rtree/geometry/internal/RectangleFloat.java", "original_string": "package com.github.davidmoten.rtree.geometry.internal;\n\nimport static com.github.davidmoten.rtree.geometry.internal.GeometryUtil.max;\nimport static com.github.davidmoten.rtree.geometry.internal.GeometryUtil.min;\n\nimport com.github.davidmoten.guavamini.Preconditions;\nimport com.github.davidmoten.rtree.geometry.Geometry;\nimport com.github.davidmoten.rtree.geometry.Rectangle;\nimport com.github.davidmoten.rtree.internal.util.ObjectsHelper;\n\nimport java.util.Objects;\nimport java.util.Optional;\n\npublic final class RectangleFloat implements Rectangle {\n    public final float x1, y1, x2, y2;\n\n    private RectangleFloat(float x1, float y1, float x2, float y2) {\n        Preconditions.checkArgument(x2 >= x1);\n        Preconditions.checkArgument(y2 >= y1);\n        this.x1 = x1;\n        this.y1 = y1;\n        this.x2 = x2;\n        this.y2 = y2;\n    }\n\n    public static Rectangle create(float x1, float y1, float x2, float y2) {\n        return new RectangleFloat(x1, y1, x2, y2);\n    }\n\n    @Override\n    public double x1() {\n        return x1;\n    }\n\n    @Override\n    public double y1() {\n        return y1;\n    }\n\n    @Override\n    public double x2() {\n        return x2;\n    }\n\n    @Override\n    public double y2() {\n        return y2;\n    }\n\n    @Override\n    public double area() {\n        return (x2 - x1) * (y2 - y1);\n    }\n\n    @Override\n    public Rectangle add(Rectangle r) {\n        if (r.isDoublePrecision()) {\n            return RectangleDouble.create(min(x1, r.x1()), min(y1, r.y1()), max(x2, r.x2()),\n                    max(y2, r.y2()));\n        } else if (r instanceof RectangleFloat) {\n            RectangleFloat rf = (RectangleFloat) r;\n            return RectangleFloat.create(min(x1, rf.x1), min(y1, rf.y1), max(x2, rf.x2),\n                    max(y2, rf.y2));\n        } else {\n            PointFloat rf = (PointFloat) r;\n            return RectangleFloat.create(min(x1, rf.xFloat()), min(y1, rf.yFloat()),\n                    max(x2, rf.xFloat()), max(y2, rf.yFloat()));\n        }\n    }\n\n    @Override\n    public boolean contains(double x, double y) {\n        return x >= x1 && x <= x2 && y >= y1 && y <= y2;\n    }\n\n    @Override\n    public boolean intersects(Rectangle r) {\n        return GeometryUtil.intersects(x1, y1, x2, y2, r.x1(), r.y1(), r.x2(), r.y2());\n    }\n\n    @Override\n    public double distance(Rectangle r) {\n        return GeometryUtil.distance(x1, y1, x2, y2, r.x1(), r.y1(), r.x2(), r.y2());\n    }\n\n    @Override\n    public Rectangle mbr() {\n        return this;\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(x1, y1, x2, y2);\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        Optional<RectangleFloat> other = ObjectsHelper.asClass(obj, RectangleFloat.class);\n        if (other.isPresent()) {\n            return Objects.equals(x1, other.get().x1) && Objects.equals(x2, other.get().x2)\n                    && Objects.equals(y1, other.get().y1) && Objects.equals(y2, other.get().y2);\n        } else\n            return false;\n    }\n\n    @Override\n    public double intersectionArea(Rectangle r) {\n        if (!intersects(r))\n            return 0;\n        else\n            return RectangleDouble\n                    .create(max(x1, r.x1()), max(y1, r.y1()), min(x2, r.x2()), min(y2, r.y2()))\n                    .area();\n    }\n\n    @Override\n    public double perimeter() {\n        return 2 * (x2 - x1) + 2 * (y2 - y1);\n    }\n\n    @Override\n    public Geometry geometry() {\n        return this;\n    }\n\n    @Override\n    public boolean isDoublePrecision() {\n        return false;\n    }\n\n    @Override\n    public String toString() {\n        return \"Rectangle [x1=\" + x1 + \", y1=\" + y1 + \", x2=\" + x2 + \", y2=\" + y2 + \"]\";\n    }\n\n}", "file_hash": "23690385084cd07988db46c0736cabb2273d287c1e8e1a52cebe44c0129d27a9", "file_docstring": "", "contexts": ["package com.github.davidmoten.rtree.geometry.internal;", "import static com.github.davidmoten.rtree.geometry.internal.GeometryUtil.max;", "import static com.github.davidmoten.rtree.geometry.internal.GeometryUtil.min;", "import com.github.davidmoten.guavamini.Preconditions;", "import com.github.davidmoten.rtree.geometry.Geometry;", "import com.github.davidmoten.rtree.geometry.Rectangle;", "import com.github.davidmoten.rtree.internal.util.ObjectsHelper;", "import java.util.Objects;", "import java.util.Optional;"], "methods": [], "classes": [{"original_string": "public final class RectangleFloat implements Rectangle {\n    public final float x1, y1, x2, y2;\n\n    private RectangleFloat(float x1, float y1, float x2, float y2) {\n        Preconditions.checkArgument(x2 >= x1);\n        Preconditions.checkArgument(y2 >= y1);\n        this.x1 = x1;\n        this.y1 = y1;\n        this.x2 = x2;\n        this.y2 = y2;\n    }\n\n    public static Rectangle create(float x1, float y1, float x2, float y2) {\n        return new RectangleFloat(x1, y1, x2, y2);\n    }\n\n    @Override\n    public double x1() {\n        return x1;\n    }\n\n    @Override\n    public double y1() {\n        return y1;\n    }\n\n    @Override\n    public double x2() {\n        return x2;\n    }\n\n    @Override\n    public double y2() {\n        return y2;\n    }\n\n    @Override\n    public double area() {\n        return (x2 - x1) * (y2 - y1);\n    }\n\n    @Override\n    public Rectangle add(Rectangle r) {\n        if (r.isDoublePrecision()) {\n            return RectangleDouble.create(min(x1, r.x1()), min(y1, r.y1()), max(x2, r.x2()),\n                    max(y2, r.y2()));\n        } else if (r instanceof RectangleFloat) {\n            RectangleFloat rf = (RectangleFloat) r;\n            return RectangleFloat.create(min(x1, rf.x1), min(y1, rf.y1), max(x2, rf.x2),\n                    max(y2, rf.y2));\n        } else {\n            PointFloat rf = (PointFloat) r;\n            return RectangleFloat.create(min(x1, rf.xFloat()), min(y1, rf.yFloat()),\n                    max(x2, rf.xFloat()), max(y2, rf.yFloat()));\n        }\n    }\n\n    @Override\n    public boolean contains(double x, double y) {\n        return x >= x1 && x <= x2 && y >= y1 && y <= y2;\n    }\n\n    @Override\n    public boolean intersects(Rectangle r) {\n        return GeometryUtil.intersects(x1, y1, x2, y2, r.x1(), r.y1(), r.x2(), r.y2());\n    }\n\n    @Override\n    public double distance(Rectangle r) {\n        return GeometryUtil.distance(x1, y1, x2, y2, r.x1(), r.y1(), r.x2(), r.y2());\n    }\n\n    @Override\n    public Rectangle mbr() {\n        return this;\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(x1, y1, x2, y2);\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        Optional<RectangleFloat> other = ObjectsHelper.asClass(obj, RectangleFloat.class);\n        if (other.isPresent()) {\n            return Objects.equals(x1, other.get().x1) && Objects.equals(x2, other.get().x2)\n                    && Objects.equals(y1, other.get().y1) && Objects.equals(y2, other.get().y2);\n        } else\n            return false;\n    }\n\n    @Override\n    public double intersectionArea(Rectangle r) {\n        if (!intersects(r))\n            return 0;\n        else\n            return RectangleDouble\n                    .create(max(x1, r.x1()), max(y1, r.y1()), min(x2, r.x2()), min(y2, r.y2()))\n                    .area();\n    }\n\n    @Override\n    public double perimeter() {\n        return 2 * (x2 - x1) + 2 * (y2 - y1);\n    }\n\n    @Override\n    public Geometry geometry() {\n        return this;\n    }\n\n    @Override\n    public boolean isDoublePrecision() {\n        return false;\n    }\n\n    @Override\n    public String toString() {\n        return \"Rectangle [x1=\" + x1 + \", y1=\" + y1 + \", x2=\" + x2 + \", y2=\" + y2 + \"]\";\n    }\n\n}", "definition": "public final class RectangleFloat implements Rectangle", "class_docstring": "", "name": "RectangleFloat", "super_interfaces": ["Rectangle"], "superclasses": "", "attributes": {"modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "fields": [{"attribute_expression": "public final float x1, y1, x2, y2;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "float", "name": "x1", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    private RectangleFloat(float x1, float y1, float x2, float y2) {\n        Preconditions.checkArgument(x2 >= x1);\n        Preconditions.checkArgument(y2 >= y1);\n        this.x1 = x1;\n        this.y1 = y1;\n        this.x2 = x2;\n        this.y2 = y2;\n    }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "", "classes": []}, "name": "RectangleFloat", "params": [{"name": "x1", "type": "float"}, {"name": "y1", "type": "float"}, {"name": "x2", "type": "float"}, {"name": "y2", "type": "float"}], "body": "                                                                   {\n        Preconditions.checkArgument(x2 >= x1);\n        Preconditions.checkArgument(y2 >= y1);\n        this.x1 = x1;\n        this.y1 = y1;\n        this.x2 = x2;\n        this.y2 = y2;\n    }", "signature": "private RectangleFloat(float x1, float y1, float x2, float y2)"}, {"syntax_pass": true, "original_string": "    public static Rectangle create(float x1, float y1, float x2, float y2) {\n        return new RectangleFloat(x1, y1, x2, y2);\n    }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Rectangle", "classes": []}, "name": "create", "params": [{"name": "x1", "type": "float"}, {"name": "y1", "type": "float"}, {"name": "x2", "type": "float"}, {"name": "y2", "type": "float"}], "body": "                                                                           {\n        return new RectangleFloat(x1, y1, x2, y2);\n    }", "signature": "public static Rectangle create(float x1, float y1, float x2, float y2)"}, {"syntax_pass": true, "original_string": "    @Override\n    public double x1() {\n        return x1;\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "double", "classes": []}, "name": "x1", "params": [], "body": "                       {\n        return x1;\n    }", "signature": "@Override\n    public double x1()"}, {"syntax_pass": true, "original_string": "    @Override\n    public double y1() {\n        return y1;\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "double", "classes": []}, "name": "y1", "params": [], "body": "                       {\n        return y1;\n    }", "signature": "@Override\n    public double y1()"}, {"syntax_pass": true, "original_string": "    @Override\n    public double x2() {\n        return x2;\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "double", "classes": []}, "name": "x2", "params": [], "body": "                       {\n        return x2;\n    }", "signature": "@Override\n    public double x2()"}, {"syntax_pass": true, "original_string": "    @Override\n    public double y2() {\n        return y2;\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "double", "classes": []}, "name": "y2", "params": [], "body": "                       {\n        return y2;\n    }", "signature": "@Override\n    public double y2()"}, {"syntax_pass": true, "original_string": "    @Override\n    public double area() {\n        return (x2 - x1) * (y2 - y1);\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "double", "classes": []}, "name": "area", "params": [], "body": "                         {\n        return (x2 - x1) * (y2 - y1);\n    }", "signature": "@Override\n    public double area()"}, {"syntax_pass": true, "original_string": "    @Override\n    public Rectangle add(Rectangle r) {\n        if (r.isDoublePrecision()) {\n            return RectangleDouble.create(min(x1, r.x1()), min(y1, r.y1()), max(x2, r.x2()),\n                    max(y2, r.y2()));\n        } else if (r instanceof RectangleFloat) {\n            RectangleFloat rf = (RectangleFloat) r;\n            return RectangleFloat.create(min(x1, rf.x1), min(y1, rf.y1), max(x2, rf.x2),\n                    max(y2, rf.y2));\n        } else {\n            PointFloat rf = (PointFloat) r;\n            return RectangleFloat.create(min(x1, rf.xFloat()), min(y1, rf.yFloat()),\n                    max(x2, rf.xFloat()), max(y2, rf.yFloat()));\n        }\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Rectangle", "classes": []}, "name": "add", "params": [{"name": "r", "type": "Rectangle"}], "body": "                                      {\n        if (r.isDoublePrecision()) {\n            return RectangleDouble.create(min(x1, r.x1()), min(y1, r.y1()), max(x2, r.x2()),\n                    max(y2, r.y2()));\n        } else if (r instanceof RectangleFloat) {\n            RectangleFloat rf = (RectangleFloat) r;\n            return RectangleFloat.create(min(x1, rf.x1), min(y1, rf.y1), max(x2, rf.x2),\n                    max(y2, rf.y2));\n        } else {\n            PointFloat rf = (PointFloat) r;\n            return RectangleFloat.create(min(x1, rf.xFloat()), min(y1, rf.yFloat()),\n                    max(x2, rf.xFloat()), max(y2, rf.yFloat()));\n        }\n    }", "signature": "@Override\n    public Rectangle add(Rectangle r)"}, {"syntax_pass": true, "original_string": "    @Override\n    public boolean contains(double x, double y) {\n        return x >= x1 && x <= x2 && y >= y1 && y <= y2;\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "contains", "params": [{"name": "x", "type": "double"}, {"name": "y", "type": "double"}], "body": "                                                {\n        return x >= x1 && x <= x2 && y >= y1 && y <= y2;\n    }", "signature": "@Override\n    public boolean contains(double x, double y)"}, {"syntax_pass": true, "original_string": "    @Override\n    public boolean intersects(Rectangle r) {\n        return GeometryUtil.intersects(x1, y1, x2, y2, r.x1(), r.y1(), r.x2(), r.y2());\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "intersects", "params": [{"name": "r", "type": "Rectangle"}], "body": "                                           {\n        return GeometryUtil.intersects(x1, y1, x2, y2, r.x1(), r.y1(), r.x2(), r.y2());\n    }", "signature": "@Override\n    public boolean intersects(Rectangle r)"}, {"syntax_pass": true, "original_string": "    @Override\n    public double distance(Rectangle r) {\n        return GeometryUtil.distance(x1, y1, x2, y2, r.x1(), r.y1(), r.x2(), r.y2());\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "double", "classes": []}, "name": "distance", "params": [{"name": "r", "type": "Rectangle"}], "body": "                                        {\n        return GeometryUtil.distance(x1, y1, x2, y2, r.x1(), r.y1(), r.x2(), r.y2());\n    }", "signature": "@Override\n    public double distance(Rectangle r)"}, {"syntax_pass": true, "original_string": "    @Override\n    public Rectangle mbr() {\n        return this;\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Rectangle", "classes": []}, "name": "mbr", "params": [], "body": "                           {\n        return this;\n    }", "signature": "@Override\n    public Rectangle mbr()"}, {"syntax_pass": true, "original_string": "    @Override\n    public int hashCode() {\n        return Objects.hash(x1, y1, x2, y2);\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "hashCode", "params": [], "body": "                          {\n        return Objects.hash(x1, y1, x2, y2);\n    }", "signature": "@Override\n    public int hashCode()"}, {"syntax_pass": true, "original_string": "    @Override\n    public boolean equals(Object obj) {\n        Optional<RectangleFloat> other = ObjectsHelper.asClass(obj, RectangleFloat.class);\n        if (other.isPresent()) {\n            return Objects.equals(x1, other.get().x1) && Objects.equals(x2, other.get().x2)\n                    && Objects.equals(y1, other.get().y1) && Objects.equals(y2, other.get().y2);\n        } else\n            return false;\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "equals", "params": [{"name": "obj", "type": "Object"}], "body": "                                      {\n        Optional<RectangleFloat> other = ObjectsHelper.asClass(obj, RectangleFloat.class);\n        if (other.isPresent()) {\n            return Objects.equals(x1, other.get().x1) && Objects.equals(x2, other.get().x2)\n                    && Objects.equals(y1, other.get().y1) && Objects.equals(y2, other.get().y2);\n        } else\n            return false;\n    }", "signature": "@Override\n    public boolean equals(Object obj)"}, {"syntax_pass": true, "original_string": "    @Override\n    public double intersectionArea(Rectangle r) {\n        if (!intersects(r))\n            return 0;\n        else\n            return RectangleDouble\n                    .create(max(x1, r.x1()), max(y1, r.y1()), min(x2, r.x2()), min(y2, r.y2()))\n                    .area();\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "double", "classes": []}, "name": "intersectionArea", "params": [{"name": "r", "type": "Rectangle"}], "body": "                                                {\n        if (!intersects(r))\n            return 0;\n        else\n            return RectangleDouble\n                    .create(max(x1, r.x1()), max(y1, r.y1()), min(x2, r.x2()), min(y2, r.y2()))\n                    .area();\n    }", "signature": "@Override\n    public double intersectionArea(Rectangle r)"}, {"syntax_pass": true, "original_string": "    @Override\n    public double perimeter() {\n        return 2 * (x2 - x1) + 2 * (y2 - y1);\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "double", "classes": []}, "name": "perimeter", "params": [], "body": "                              {\n        return 2 * (x2 - x1) + 2 * (y2 - y1);\n    }", "signature": "@Override\n    public double perimeter()"}, {"syntax_pass": true, "original_string": "    @Override\n    public Geometry geometry() {\n        return this;\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Geometry", "classes": []}, "name": "geometry", "params": [], "body": "                               {\n        return this;\n    }", "signature": "@Override\n    public Geometry geometry()"}, {"syntax_pass": true, "original_string": "    @Override\n    public boolean isDoublePrecision() {\n        return false;\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isDoublePrecision", "params": [], "body": "                                       {\n        return false;\n    }", "signature": "@Override\n    public boolean isDoublePrecision()"}, {"syntax_pass": true, "original_string": "    @Override\n    public String toString() {\n        return \"Rectangle [x1=\" + x1 + \", y1=\" + y1 + \", x2=\" + x2 + \", y2=\" + y2 + \"]\";\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "toString", "params": [], "body": "                             {\n        return \"Rectangle [x1=\" + x1 + \", y1=\" + y1 + \", x2=\" + x2 + \", y2=\" + y2 + \"]\";\n    }", "signature": "@Override\n    public String toString()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/com/github/davidmoten/rtree/geometry/internal/CircleDouble.java", "original_string": "package com.github.davidmoten.rtree.geometry.internal;\n\nimport com.github.davidmoten.rtree.geometry.Circle;\nimport com.github.davidmoten.rtree.geometry.Line;\nimport com.github.davidmoten.rtree.geometry.Point;\nimport com.github.davidmoten.rtree.geometry.Rectangle;\nimport com.github.davidmoten.rtree.internal.util.ObjectsHelper;\n\nimport java.util.Objects;\nimport java.util.Optional;\n\npublic final class CircleDouble implements Circle {\n\n    private final double x, y, radius;\n    private final Rectangle mbr;\n\n    private CircleDouble(double x, double y, double radius) {\n        this.x = x;\n        this.y = y;\n        this.radius = radius;\n        this.mbr = RectangleDouble.create(x - radius, y - radius, x + radius, y + radius);\n    }\n\n    public static CircleDouble create(double x, double y, double radius) {\n        return new CircleDouble(x, y, radius);\n    }\n\n    @Override\n    public double x() {\n        return x;\n    }\n\n    @Override\n    public double y() {\n        return y;\n    }\n\n    @Override\n    public double radius() {\n        return radius;\n    }\n\n    @Override\n    public Rectangle mbr() {\n        return mbr;\n    }\n\n    @Override\n    public double distance(Rectangle r) {\n        return Math.max(0, GeometryUtil.distance(x, y, r) - radius);\n    }\n\n    @Override\n    public boolean intersects(Rectangle r) {\n        return distance(r) == 0;\n    }\n\n    @Override\n    public boolean intersects(Circle c) {\n        double total = radius + c.radius();\n        return GeometryUtil.distanceSquared(x, y, c.x(), c.y()) <= total * total;\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(x, y, radius);\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        Optional<CircleDouble> other = ObjectsHelper.asClass(obj, CircleDouble.class);\n        if (other.isPresent()) {\n            return Objects.equals(x, other.get().x) && Objects.equals(y, other.get().y)\n                    && Objects.equals(radius, other.get().radius);\n        } else\n            return false;\n    }\n\n    @Override\n    public boolean intersects(Point point) {\n        return Math.sqrt(sqr(x - point.x()) + sqr(y - point.y())) <= radius;\n    }\n\n    private double sqr(double x) {\n        return x * x;\n    }\n\n    @Override\n    public boolean intersects(Line line) {\n        return line.intersects(this);\n    }\n\n    @Override\n    public boolean isDoublePrecision() {\n        return true;\n    }\n}\n", "file_hash": "07dbfe1577be4da28c53ec04459d9ba8de185ff35f4f038074afd669277c70c6", "file_docstring": "", "contexts": ["package com.github.davidmoten.rtree.geometry.internal;", "import com.github.davidmoten.rtree.geometry.Circle;", "import com.github.davidmoten.rtree.geometry.Line;", "import com.github.davidmoten.rtree.geometry.Point;", "import com.github.davidmoten.rtree.geometry.Rectangle;", "import com.github.davidmoten.rtree.internal.util.ObjectsHelper;", "import java.util.Objects;", "import java.util.Optional;"], "methods": [], "classes": [{"original_string": "public final class CircleDouble implements Circle {\n\n    private final double x, y, radius;\n    private final Rectangle mbr;\n\n    private CircleDouble(double x, double y, double radius) {\n        this.x = x;\n        this.y = y;\n        this.radius = radius;\n        this.mbr = RectangleDouble.create(x - radius, y - radius, x + radius, y + radius);\n    }\n\n    public static CircleDouble create(double x, double y, double radius) {\n        return new CircleDouble(x, y, radius);\n    }\n\n    @Override\n    public double x() {\n        return x;\n    }\n\n    @Override\n    public double y() {\n        return y;\n    }\n\n    @Override\n    public double radius() {\n        return radius;\n    }\n\n    @Override\n    public Rectangle mbr() {\n        return mbr;\n    }\n\n    @Override\n    public double distance(Rectangle r) {\n        return Math.max(0, GeometryUtil.distance(x, y, r) - radius);\n    }\n\n    @Override\n    public boolean intersects(Rectangle r) {\n        return distance(r) == 0;\n    }\n\n    @Override\n    public boolean intersects(Circle c) {\n        double total = radius + c.radius();\n        return GeometryUtil.distanceSquared(x, y, c.x(), c.y()) <= total * total;\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(x, y, radius);\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        Optional<CircleDouble> other = ObjectsHelper.asClass(obj, CircleDouble.class);\n        if (other.isPresent()) {\n            return Objects.equals(x, other.get().x) && Objects.equals(y, other.get().y)\n                    && Objects.equals(radius, other.get().radius);\n        } else\n            return false;\n    }\n\n    @Override\n    public boolean intersects(Point point) {\n        return Math.sqrt(sqr(x - point.x()) + sqr(y - point.y())) <= radius;\n    }\n\n    private double sqr(double x) {\n        return x * x;\n    }\n\n    @Override\n    public boolean intersects(Line line) {\n        return line.intersects(this);\n    }\n\n    @Override\n    public boolean isDoublePrecision() {\n        return true;\n    }\n}", "definition": "public final class CircleDouble implements Circle", "class_docstring": "", "name": "CircleDouble", "super_interfaces": ["Circle"], "superclasses": "", "attributes": {"modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "fields": [{"attribute_expression": "private final double x, y, radius;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "double", "name": "x", "syntax_pass": true}, {"attribute_expression": "private final Rectangle mbr;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Rectangle", "name": "mbr", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    private CircleDouble(double x, double y, double radius) {\n        this.x = x;\n        this.y = y;\n        this.radius = radius;\n        this.mbr = RectangleDouble.create(x - radius, y - radius, x + radius, y + radius);\n    }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "", "classes": []}, "name": "CircleDouble", "params": [{"name": "x", "type": "double"}, {"name": "y", "type": "double"}, {"name": "radius", "type": "double"}], "body": "                                                            {\n        this.x = x;\n        this.y = y;\n        this.radius = radius;\n        this.mbr = RectangleDouble.create(x - radius, y - radius, x + radius, y + radius);\n    }", "signature": "private CircleDouble(double x, double y, double radius)"}, {"syntax_pass": true, "original_string": "    public static CircleDouble create(double x, double y, double radius) {\n        return new CircleDouble(x, y, radius);\n    }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "CircleDouble", "classes": []}, "name": "create", "params": [{"name": "x", "type": "double"}, {"name": "y", "type": "double"}, {"name": "radius", "type": "double"}], "body": "                                                                         {\n        return new CircleDouble(x, y, radius);\n    }", "signature": "public static CircleDouble create(double x, double y, double radius)"}, {"syntax_pass": true, "original_string": "    @Override\n    public double x() {\n        return x;\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "double", "classes": []}, "name": "x", "params": [], "body": "                      {\n        return x;\n    }", "signature": "@Override\n    public double x()"}, {"syntax_pass": true, "original_string": "    @Override\n    public double y() {\n        return y;\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "double", "classes": []}, "name": "y", "params": [], "body": "                      {\n        return y;\n    }", "signature": "@Override\n    public double y()"}, {"syntax_pass": true, "original_string": "    @Override\n    public double radius() {\n        return radius;\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "double", "classes": []}, "name": "radius", "params": [], "body": "                           {\n        return radius;\n    }", "signature": "@Override\n    public double radius()"}, {"syntax_pass": true, "original_string": "    @Override\n    public Rectangle mbr() {\n        return mbr;\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Rectangle", "classes": []}, "name": "mbr", "params": [], "body": "                           {\n        return mbr;\n    }", "signature": "@Override\n    public Rectangle mbr()"}, {"syntax_pass": true, "original_string": "    @Override\n    public double distance(Rectangle r) {\n        return Math.max(0, GeometryUtil.distance(x, y, r) - radius);\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "double", "classes": []}, "name": "distance", "params": [{"name": "r", "type": "Rectangle"}], "body": "                                        {\n        return Math.max(0, GeometryUtil.distance(x, y, r) - radius);\n    }", "signature": "@Override\n    public double distance(Rectangle r)"}, {"syntax_pass": true, "original_string": "    @Override\n    public boolean intersects(Rectangle r) {\n        return distance(r) == 0;\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "intersects", "params": [{"name": "r", "type": "Rectangle"}], "body": "                                           {\n        return distance(r) == 0;\n    }", "signature": "@Override\n    public boolean intersects(Rectangle r)"}, {"syntax_pass": true, "original_string": "    @Override\n    public boolean intersects(Circle c) {\n        double total = radius + c.radius();\n        return GeometryUtil.distanceSquared(x, y, c.x(), c.y()) <= total * total;\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "intersects", "params": [{"name": "c", "type": "Circle"}], "body": "                                        {\n        double total = radius + c.radius();\n        return GeometryUtil.distanceSquared(x, y, c.x(), c.y()) <= total * total;\n    }", "signature": "@Override\n    public boolean intersects(Circle c)"}, {"syntax_pass": true, "original_string": "    @Override\n    public int hashCode() {\n        return Objects.hash(x, y, radius);\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "hashCode", "params": [], "body": "                          {\n        return Objects.hash(x, y, radius);\n    }", "signature": "@Override\n    public int hashCode()"}, {"syntax_pass": true, "original_string": "    @Override\n    public boolean equals(Object obj) {\n        Optional<CircleDouble> other = ObjectsHelper.asClass(obj, CircleDouble.class);\n        if (other.isPresent()) {\n            return Objects.equals(x, other.get().x) && Objects.equals(y, other.get().y)\n                    && Objects.equals(radius, other.get().radius);\n        } else\n            return false;\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "equals", "params": [{"name": "obj", "type": "Object"}], "body": "                                      {\n        Optional<CircleDouble> other = ObjectsHelper.asClass(obj, CircleDouble.class);\n        if (other.isPresent()) {\n            return Objects.equals(x, other.get().x) && Objects.equals(y, other.get().y)\n                    && Objects.equals(radius, other.get().radius);\n        } else\n            return false;\n    }", "signature": "@Override\n    public boolean equals(Object obj)"}, {"syntax_pass": true, "original_string": "    @Override\n    public boolean intersects(Point point) {\n        return Math.sqrt(sqr(x - point.x()) + sqr(y - point.y())) <= radius;\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "intersects", "params": [{"name": "point", "type": "Point"}], "body": "                                           {\n        return Math.sqrt(sqr(x - point.x()) + sqr(y - point.y())) <= radius;\n    }", "signature": "@Override\n    public boolean intersects(Point point)"}, {"syntax_pass": true, "original_string": "    private double sqr(double x) {\n        return x * x;\n    }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "double", "classes": []}, "name": "sqr", "params": [{"name": "x", "type": "double"}], "body": "                                 {\n        return x * x;\n    }", "signature": "private double sqr(double x)"}, {"syntax_pass": true, "original_string": "    @Override\n    public boolean intersects(Line line) {\n        return line.intersects(this);\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "intersects", "params": [{"name": "line", "type": "Line"}], "body": "                                         {\n        return line.intersects(this);\n    }", "signature": "@Override\n    public boolean intersects(Line line)"}, {"syntax_pass": true, "original_string": "    @Override\n    public boolean isDoublePrecision() {\n        return true;\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isDoublePrecision", "params": [], "body": "                                       {\n        return true;\n    }", "signature": "@Override\n    public boolean isDoublePrecision()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/com/github/davidmoten/rtree/geometry/internal/LineDouble.java", "original_string": "package com.github.davidmoten.rtree.geometry.internal;\n\nimport com.github.davidmoten.rtree.geometry.Circle;\nimport com.github.davidmoten.rtree.geometry.Geometries;\nimport com.github.davidmoten.rtree.geometry.Line;\nimport com.github.davidmoten.rtree.geometry.Point;\nimport com.github.davidmoten.rtree.geometry.Rectangle;\nimport com.github.davidmoten.rtree.internal.Line2D;\nimport com.github.davidmoten.rtree.internal.RectangleUtil;\nimport com.github.davidmoten.rtree.internal.util.ObjectsHelper;\n\nimport java.util.Objects;\nimport java.util.Optional;\n\n/**\n * A line segment.\n */\npublic final class LineDouble implements Line {\n\n    private final double x1;\n    private final double y1;\n    private final double x2;\n    private final double y2;\n\n    private LineDouble(double x1, double y1, double x2, double y2) {\n        this.x1 = x1;\n        this.y1 = y1;\n        this.x2 = x2;\n        this.y2 = y2;\n    }\n\n    public static LineDouble create(double x1, double y1, double x2, double y2) {\n        return new LineDouble(x1, y1, x2, y2);\n    }\n\n    @Override\n    public double distance(Rectangle r) {\n        if (r.contains(x1, y1) || r.contains(x2, y2)) {\n            return 0;\n        } else {\n            double d1 = distance(r.x1(), r.y1(), r.x1(), r.y2());\n            if (d1 == 0)\n                return 0;\n            double d2 = distance(r.x1(), r.y2(), r.x2(), r.y2());\n            if (d2 == 0)\n                return 0;\n            double d3 = distance(r.x2(), r.y2(), r.x2(), r.y1());\n            double d4 = distance(r.x2(), r.y1(), r.x1(), r.y1());\n            return Math.min(d1, Math.min(d2, Math.min(d3, d4)));\n        }\n    }\n\n    private double distance(double x1, double y1, double x2, double y2) {\n        Line2D line = new Line2D(x1, y1, x2, y2);\n        double d1 = line.ptSegDist(this.x1, this.y1);\n        double d2 = line.ptSegDist(this.x2, this.y2);\n        Line2D line2 = new Line2D(this.x1, this.y1, this.x2, this.y2);\n        double d3 = line2.ptSegDist(x1, y1);\n        if (d3 == 0)\n            return 0;\n        double d4 = line2.ptSegDist(x2, y2);\n        if (d4 == 0)\n            return 0;\n        else\n            return Math.min(d1, Math.min(d2, Math.min(d3, d4)));\n\n    }\n\n    @Override\n    public Rectangle mbr() {\n        return Geometries.rectangle(Math.min(x1, x2), Math.min(y1, y2), Math.max(x1, x2),\n                Math.max(y1, y2));\n    }\n\n    @Override\n    public boolean intersects(Rectangle r) {\n        return RectangleUtil.rectangleIntersectsLine(r.x1(), r.y1(), r.x2() - r.x1(),\n                r.y2() - r.y1(), x1, y1, x2, y2);\n    }\n\n    @Override\n    public double x1() {\n        return x1;\n    }\n\n    @Override\n    public double y1() {\n        return y1;\n    }\n\n    @Override\n    public double x2() {\n        return x2;\n    }\n\n    @Override\n    public double y2() {\n        return y2;\n    }\n\n    @Override\n    public boolean intersects(Line b) {\n        Line2D line1 = new Line2D(x1, y1, x2, y2);\n        Line2D line2 = new Line2D(b.x1(), b.y1(), b.x2(), b.y2());\n        return line2.intersectsLine(line1);\n    }\n\n    @Override\n    public boolean intersects(Point point) {\n        return intersects(point.mbr());\n    }\n\n    @Override\n    public boolean intersects(Circle circle) {\n        return GeometryUtil.lineIntersects(x1, y1, x2, y2, circle);\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(x1, y1, x2, y2);\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        Optional<LineDouble> other = ObjectsHelper.asClass(obj, LineDouble.class);\n        if (other.isPresent()) {\n            return Objects.equals(x1, other.get().x1) && Objects.equals(x2, other.get().x2)\n                    && Objects.equals(y1, other.get().y1) && Objects.equals(y2, other.get().y2);\n        } else\n            return false;\n    }\n\n    @Override\n    public boolean isDoublePrecision() {\n        return true;\n    }\n\n}\n", "file_hash": "a5835708405369f3c16aa4cd1cab7c57212d8d76455b2010fa0e05be9df9ddcb", "file_docstring": "", "contexts": ["package com.github.davidmoten.rtree.geometry.internal;", "import com.github.davidmoten.rtree.geometry.Circle;", "import com.github.davidmoten.rtree.geometry.Geometries;", "import com.github.davidmoten.rtree.geometry.Line;", "import com.github.davidmoten.rtree.geometry.Point;", "import com.github.davidmoten.rtree.geometry.Rectangle;", "import com.github.davidmoten.rtree.internal.Line2D;", "import com.github.davidmoten.rtree.internal.RectangleUtil;", "import com.github.davidmoten.rtree.internal.util.ObjectsHelper;", "import java.util.Objects;", "import java.util.Optional;"], "methods": [], "classes": [{"original_string": "public final class LineDouble implements Line {\n\n    private final double x1;\n    private final double y1;\n    private final double x2;\n    private final double y2;\n\n    private LineDouble(double x1, double y1, double x2, double y2) {\n        this.x1 = x1;\n        this.y1 = y1;\n        this.x2 = x2;\n        this.y2 = y2;\n    }\n\n    public static LineDouble create(double x1, double y1, double x2, double y2) {\n        return new LineDouble(x1, y1, x2, y2);\n    }\n\n    @Override\n    public double distance(Rectangle r) {\n        if (r.contains(x1, y1) || r.contains(x2, y2)) {\n            return 0;\n        } else {\n            double d1 = distance(r.x1(), r.y1(), r.x1(), r.y2());\n            if (d1 == 0)\n                return 0;\n            double d2 = distance(r.x1(), r.y2(), r.x2(), r.y2());\n            if (d2 == 0)\n                return 0;\n            double d3 = distance(r.x2(), r.y2(), r.x2(), r.y1());\n            double d4 = distance(r.x2(), r.y1(), r.x1(), r.y1());\n            return Math.min(d1, Math.min(d2, Math.min(d3, d4)));\n        }\n    }\n\n    private double distance(double x1, double y1, double x2, double y2) {\n        Line2D line = new Line2D(x1, y1, x2, y2);\n        double d1 = line.ptSegDist(this.x1, this.y1);\n        double d2 = line.ptSegDist(this.x2, this.y2);\n        Line2D line2 = new Line2D(this.x1, this.y1, this.x2, this.y2);\n        double d3 = line2.ptSegDist(x1, y1);\n        if (d3 == 0)\n            return 0;\n        double d4 = line2.ptSegDist(x2, y2);\n        if (d4 == 0)\n            return 0;\n        else\n            return Math.min(d1, Math.min(d2, Math.min(d3, d4)));\n\n    }\n\n    @Override\n    public Rectangle mbr() {\n        return Geometries.rectangle(Math.min(x1, x2), Math.min(y1, y2), Math.max(x1, x2),\n                Math.max(y1, y2));\n    }\n\n    @Override\n    public boolean intersects(Rectangle r) {\n        return RectangleUtil.rectangleIntersectsLine(r.x1(), r.y1(), r.x2() - r.x1(),\n                r.y2() - r.y1(), x1, y1, x2, y2);\n    }\n\n    @Override\n    public double x1() {\n        return x1;\n    }\n\n    @Override\n    public double y1() {\n        return y1;\n    }\n\n    @Override\n    public double x2() {\n        return x2;\n    }\n\n    @Override\n    public double y2() {\n        return y2;\n    }\n\n    @Override\n    public boolean intersects(Line b) {\n        Line2D line1 = new Line2D(x1, y1, x2, y2);\n        Line2D line2 = new Line2D(b.x1(), b.y1(), b.x2(), b.y2());\n        return line2.intersectsLine(line1);\n    }\n\n    @Override\n    public boolean intersects(Point point) {\n        return intersects(point.mbr());\n    }\n\n    @Override\n    public boolean intersects(Circle circle) {\n        return GeometryUtil.lineIntersects(x1, y1, x2, y2, circle);\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(x1, y1, x2, y2);\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        Optional<LineDouble> other = ObjectsHelper.asClass(obj, LineDouble.class);\n        if (other.isPresent()) {\n            return Objects.equals(x1, other.get().x1) && Objects.equals(x2, other.get().x2)\n                    && Objects.equals(y1, other.get().y1) && Objects.equals(y2, other.get().y2);\n        } else\n            return false;\n    }\n\n    @Override\n    public boolean isDoublePrecision() {\n        return true;\n    }\n\n}", "definition": "public final class LineDouble implements Line", "class_docstring": "\nA line segment.\n", "name": "LineDouble", "super_interfaces": ["Line"], "superclasses": "", "attributes": {"modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "fields": [{"attribute_expression": "private final double x1;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "double", "name": "x1", "syntax_pass": true}, {"attribute_expression": "private final double y1;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "double", "name": "y1", "syntax_pass": true}, {"attribute_expression": "private final double x2;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "double", "name": "x2", "syntax_pass": true}, {"attribute_expression": "private final double y2;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "double", "name": "y2", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    private LineDouble(double x1, double y1, double x2, double y2) {\n        this.x1 = x1;\n        this.y1 = y1;\n        this.x2 = x2;\n        this.y2 = y2;\n    }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "", "classes": []}, "name": "LineDouble", "params": [{"name": "x1", "type": "double"}, {"name": "y1", "type": "double"}, {"name": "x2", "type": "double"}, {"name": "y2", "type": "double"}], "body": "                                                                   {\n        this.x1 = x1;\n        this.y1 = y1;\n        this.x2 = x2;\n        this.y2 = y2;\n    }", "signature": "private LineDouble(double x1, double y1, double x2, double y2)"}, {"syntax_pass": true, "original_string": "    public static LineDouble create(double x1, double y1, double x2, double y2) {\n        return new LineDouble(x1, y1, x2, y2);\n    }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "LineDouble", "classes": []}, "name": "create", "params": [{"name": "x1", "type": "double"}, {"name": "y1", "type": "double"}, {"name": "x2", "type": "double"}, {"name": "y2", "type": "double"}], "body": "                                                                                {\n        return new LineDouble(x1, y1, x2, y2);\n    }", "signature": "public static LineDouble create(double x1, double y1, double x2, double y2)"}, {"syntax_pass": true, "original_string": "    @Override\n    public double distance(Rectangle r) {\n        if (r.contains(x1, y1) || r.contains(x2, y2)) {\n            return 0;\n        } else {\n            double d1 = distance(r.x1(), r.y1(), r.x1(), r.y2());\n            if (d1 == 0)\n                return 0;\n            double d2 = distance(r.x1(), r.y2(), r.x2(), r.y2());\n            if (d2 == 0)\n                return 0;\n            double d3 = distance(r.x2(), r.y2(), r.x2(), r.y1());\n            double d4 = distance(r.x2(), r.y1(), r.x1(), r.y1());\n            return Math.min(d1, Math.min(d2, Math.min(d3, d4)));\n        }\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "double", "classes": []}, "name": "distance", "params": [{"name": "r", "type": "Rectangle"}], "body": "                                        {\n        if (r.contains(x1, y1) || r.contains(x2, y2)) {\n            return 0;\n        } else {\n            double d1 = distance(r.x1(), r.y1(), r.x1(), r.y2());\n            if (d1 == 0)\n                return 0;\n            double d2 = distance(r.x1(), r.y2(), r.x2(), r.y2());\n            if (d2 == 0)\n                return 0;\n            double d3 = distance(r.x2(), r.y2(), r.x2(), r.y1());\n            double d4 = distance(r.x2(), r.y1(), r.x1(), r.y1());\n            return Math.min(d1, Math.min(d2, Math.min(d3, d4)));\n        }\n    }", "signature": "@Override\n    public double distance(Rectangle r)"}, {"syntax_pass": true, "original_string": "    private double distance(double x1, double y1, double x2, double y2) {\n        Line2D line = new Line2D(x1, y1, x2, y2);\n        double d1 = line.ptSegDist(this.x1, this.y1);\n        double d2 = line.ptSegDist(this.x2, this.y2);\n        Line2D line2 = new Line2D(this.x1, this.y1, this.x2, this.y2);\n        double d3 = line2.ptSegDist(x1, y1);\n        if (d3 == 0)\n            return 0;\n        double d4 = line2.ptSegDist(x2, y2);\n        if (d4 == 0)\n            return 0;\n        else\n            return Math.min(d1, Math.min(d2, Math.min(d3, d4)));\n\n    }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "double", "classes": []}, "name": "distance", "params": [{"name": "x1", "type": "double"}, {"name": "y1", "type": "double"}, {"name": "x2", "type": "double"}, {"name": "y2", "type": "double"}], "body": "                                                                        {\n        Line2D line = new Line2D(x1, y1, x2, y2);\n        double d1 = line.ptSegDist(this.x1, this.y1);\n        double d2 = line.ptSegDist(this.x2, this.y2);\n        Line2D line2 = new Line2D(this.x1, this.y1, this.x2, this.y2);\n        double d3 = line2.ptSegDist(x1, y1);\n        if (d3 == 0)\n            return 0;\n        double d4 = line2.ptSegDist(x2, y2);\n        if (d4 == 0)\n            return 0;\n        else\n            return Math.min(d1, Math.min(d2, Math.min(d3, d4)));\n\n    }", "signature": "private double distance(double x1, double y1, double x2, double y2)"}, {"syntax_pass": true, "original_string": "    @Override\n    public Rectangle mbr() {\n        return Geometries.rectangle(Math.min(x1, x2), Math.min(y1, y2), Math.max(x1, x2),\n                Math.max(y1, y2));\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Rectangle", "classes": []}, "name": "mbr", "params": [], "body": "                           {\n        return Geometries.rectangle(Math.min(x1, x2), Math.min(y1, y2), Math.max(x1, x2),\n                Math.max(y1, y2));\n    }", "signature": "@Override\n    public Rectangle mbr()"}, {"syntax_pass": true, "original_string": "    @Override\n    public boolean intersects(Rectangle r) {\n        return RectangleUtil.rectangleIntersectsLine(r.x1(), r.y1(), r.x2() - r.x1(),\n                r.y2() - r.y1(), x1, y1, x2, y2);\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "intersects", "params": [{"name": "r", "type": "Rectangle"}], "body": "                                           {\n        return RectangleUtil.rectangleIntersectsLine(r.x1(), r.y1(), r.x2() - r.x1(),\n                r.y2() - r.y1(), x1, y1, x2, y2);\n    }", "signature": "@Override\n    public boolean intersects(Rectangle r)"}, {"syntax_pass": true, "original_string": "    @Override\n    public double x1() {\n        return x1;\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "double", "classes": []}, "name": "x1", "params": [], "body": "                       {\n        return x1;\n    }", "signature": "@Override\n    public double x1()"}, {"syntax_pass": true, "original_string": "    @Override\n    public double y1() {\n        return y1;\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "double", "classes": []}, "name": "y1", "params": [], "body": "                       {\n        return y1;\n    }", "signature": "@Override\n    public double y1()"}, {"syntax_pass": true, "original_string": "    @Override\n    public double x2() {\n        return x2;\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "double", "classes": []}, "name": "x2", "params": [], "body": "                       {\n        return x2;\n    }", "signature": "@Override\n    public double x2()"}, {"syntax_pass": true, "original_string": "    @Override\n    public double y2() {\n        return y2;\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "double", "classes": []}, "name": "y2", "params": [], "body": "                       {\n        return y2;\n    }", "signature": "@Override\n    public double y2()"}, {"syntax_pass": true, "original_string": "    @Override\n    public boolean intersects(Line b) {\n        Line2D line1 = new Line2D(x1, y1, x2, y2);\n        Line2D line2 = new Line2D(b.x1(), b.y1(), b.x2(), b.y2());\n        return line2.intersectsLine(line1);\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "intersects", "params": [{"name": "b", "type": "Line"}], "body": "                                      {\n        Line2D line1 = new Line2D(x1, y1, x2, y2);\n        Line2D line2 = new Line2D(b.x1(), b.y1(), b.x2(), b.y2());\n        return line2.intersectsLine(line1);\n    }", "signature": "@Override\n    public boolean intersects(Line b)"}, {"syntax_pass": true, "original_string": "    @Override\n    public boolean intersects(Point point) {\n        return intersects(point.mbr());\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "intersects", "params": [{"name": "point", "type": "Point"}], "body": "                                           {\n        return intersects(point.mbr());\n    }", "signature": "@Override\n    public boolean intersects(Point point)"}, {"syntax_pass": true, "original_string": "    @Override\n    public boolean intersects(Circle circle) {\n        return GeometryUtil.lineIntersects(x1, y1, x2, y2, circle);\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "intersects", "params": [{"name": "circle", "type": "Circle"}], "body": "                                             {\n        return GeometryUtil.lineIntersects(x1, y1, x2, y2, circle);\n    }", "signature": "@Override\n    public boolean intersects(Circle circle)"}, {"syntax_pass": true, "original_string": "    @Override\n    public int hashCode() {\n        return Objects.hash(x1, y1, x2, y2);\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "hashCode", "params": [], "body": "                          {\n        return Objects.hash(x1, y1, x2, y2);\n    }", "signature": "@Override\n    public int hashCode()"}, {"syntax_pass": true, "original_string": "    @Override\n    public boolean equals(Object obj) {\n        Optional<LineDouble> other = ObjectsHelper.asClass(obj, LineDouble.class);\n        if (other.isPresent()) {\n            return Objects.equals(x1, other.get().x1) && Objects.equals(x2, other.get().x2)\n                    && Objects.equals(y1, other.get().y1) && Objects.equals(y2, other.get().y2);\n        } else\n            return false;\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "equals", "params": [{"name": "obj", "type": "Object"}], "body": "                                      {\n        Optional<LineDouble> other = ObjectsHelper.asClass(obj, LineDouble.class);\n        if (other.isPresent()) {\n            return Objects.equals(x1, other.get().x1) && Objects.equals(x2, other.get().x2)\n                    && Objects.equals(y1, other.get().y1) && Objects.equals(y2, other.get().y2);\n        } else\n            return false;\n    }", "signature": "@Override\n    public boolean equals(Object obj)"}, {"syntax_pass": true, "original_string": "    @Override\n    public boolean isDoublePrecision() {\n        return true;\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isDoublePrecision", "params": [], "body": "                                       {\n        return true;\n    }", "signature": "@Override\n    public boolean isDoublePrecision()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/com/github/davidmoten/rtree/geometry/internal/PointDouble.java", "original_string": "package com.github.davidmoten.rtree.geometry.internal;\n\nimport com.github.davidmoten.rtree.geometry.Geometries;\nimport com.github.davidmoten.rtree.geometry.Geometry;\nimport com.github.davidmoten.rtree.geometry.Point;\nimport com.github.davidmoten.rtree.geometry.Rectangle;\n\npublic final class PointDouble implements Point {\n\n    private final double x;\n    private final double y;\n\n    private PointDouble(double x, double y) {\n        this.x = x;\n        this.y = y;\n    }\n\n    public static PointDouble create(double x, double y) {\n        return new PointDouble(x, y);\n    }\n\n    @Override\n    public Rectangle mbr() {\n        return this;\n    }\n\n    @Override\n    public double distance(Rectangle r) {\n        return GeometryUtil.distance(x, y, r);\n    }\n\n    @Override\n    public boolean intersects(Rectangle r) {\n        return r.x1() <= x && x <= r.x2() && r.y1() <= y && y <= r.y2();\n    }\n\n    @Override\n    public double x() {\n        return x;\n    }\n\n    @Override\n    public double y() {\n        return y;\n    }\n\n    @Override\n    public String toString() {\n        return \"Point [x=\" + x() + \", y=\" + y() + \"]\";\n    }\n\n    @Override\n    public Geometry geometry() {\n        return this;\n    }\n\n    @Override\n    public double x1() {\n        return x;\n    }\n\n    @Override\n    public double y1() {\n        return y;\n    }\n\n    @Override\n    public double x2() {\n        return x;\n    }\n\n    @Override\n    public double y2() {\n        return y;\n    }\n\n    @Override\n    public double area() {\n        return 0;\n    }\n\n    @Override\n    public Rectangle add(Rectangle r) {\n        return Geometries.rectangle(Math.min(x, r.x1()), Math.min(y, r.y1()), Math.max(x, r.x2()),\n                Math.max(y, r.y2()));\n    }\n\n    @Override\n    public boolean contains(double x, double y) {\n        return this.x == x && this.y == y;\n    }\n\n    @Override\n    public double intersectionArea(Rectangle r) {\n        return 0;\n    }\n\n    @Override\n    public double perimeter() {\n        return 0;\n    }\n\n    @Override\n    public boolean isDoublePrecision() {\n        return true;\n    }\n\n    @Override\n    public int hashCode() {\n        final int prime = 31;\n        int result = 1;\n        long temp;\n        temp = Double.doubleToLongBits(x);\n        result = prime * result + (int) (temp ^ (temp >>> 32));\n        temp = Double.doubleToLongBits(y);\n        result = prime * result + (int) (temp ^ (temp >>> 32));\n        return result;\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        if (this == obj)\n            return true;\n        if (obj == null)\n            return false;\n        if (getClass() != obj.getClass())\n            return false;\n        PointDouble other = (PointDouble) obj;\n        if (Double.doubleToLongBits(x) != Double.doubleToLongBits(other.x))\n            return false;\n        if (Double.doubleToLongBits(y) != Double.doubleToLongBits(other.y))\n            return false;\n        return true;\n    }\n\n}", "file_hash": "906dd397f3c9b2b183b97b629fa2f488868a5ffee9d86c4d321adea73cf59d60", "file_docstring": "", "contexts": ["package com.github.davidmoten.rtree.geometry.internal;", "import com.github.davidmoten.rtree.geometry.Geometries;", "import com.github.davidmoten.rtree.geometry.Geometry;", "import com.github.davidmoten.rtree.geometry.Point;", "import com.github.davidmoten.rtree.geometry.Rectangle;"], "methods": [], "classes": [{"original_string": "public final class PointDouble implements Point {\n\n    private final double x;\n    private final double y;\n\n    private PointDouble(double x, double y) {\n        this.x = x;\n        this.y = y;\n    }\n\n    public static PointDouble create(double x, double y) {\n        return new PointDouble(x, y);\n    }\n\n    @Override\n    public Rectangle mbr() {\n        return this;\n    }\n\n    @Override\n    public double distance(Rectangle r) {\n        return GeometryUtil.distance(x, y, r);\n    }\n\n    @Override\n    public boolean intersects(Rectangle r) {\n        return r.x1() <= x && x <= r.x2() && r.y1() <= y && y <= r.y2();\n    }\n\n    @Override\n    public double x() {\n        return x;\n    }\n\n    @Override\n    public double y() {\n        return y;\n    }\n\n    @Override\n    public String toString() {\n        return \"Point [x=\" + x() + \", y=\" + y() + \"]\";\n    }\n\n    @Override\n    public Geometry geometry() {\n        return this;\n    }\n\n    @Override\n    public double x1() {\n        return x;\n    }\n\n    @Override\n    public double y1() {\n        return y;\n    }\n\n    @Override\n    public double x2() {\n        return x;\n    }\n\n    @Override\n    public double y2() {\n        return y;\n    }\n\n    @Override\n    public double area() {\n        return 0;\n    }\n\n    @Override\n    public Rectangle add(Rectangle r) {\n        return Geometries.rectangle(Math.min(x, r.x1()), Math.min(y, r.y1()), Math.max(x, r.x2()),\n                Math.max(y, r.y2()));\n    }\n\n    @Override\n    public boolean contains(double x, double y) {\n        return this.x == x && this.y == y;\n    }\n\n    @Override\n    public double intersectionArea(Rectangle r) {\n        return 0;\n    }\n\n    @Override\n    public double perimeter() {\n        return 0;\n    }\n\n    @Override\n    public boolean isDoublePrecision() {\n        return true;\n    }\n\n    @Override\n    public int hashCode() {\n        final int prime = 31;\n        int result = 1;\n        long temp;\n        temp = Double.doubleToLongBits(x);\n        result = prime * result + (int) (temp ^ (temp >>> 32));\n        temp = Double.doubleToLongBits(y);\n        result = prime * result + (int) (temp ^ (temp >>> 32));\n        return result;\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        if (this == obj)\n            return true;\n        if (obj == null)\n            return false;\n        if (getClass() != obj.getClass())\n            return false;\n        PointDouble other = (PointDouble) obj;\n        if (Double.doubleToLongBits(x) != Double.doubleToLongBits(other.x))\n            return false;\n        if (Double.doubleToLongBits(y) != Double.doubleToLongBits(other.y))\n            return false;\n        return true;\n    }\n\n}", "definition": "public final class PointDouble implements Point", "class_docstring": "", "name": "PointDouble", "super_interfaces": ["Point"], "superclasses": "", "attributes": {"modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "fields": [{"attribute_expression": "private final double x;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "double", "name": "x", "syntax_pass": true}, {"attribute_expression": "private final double y;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "double", "name": "y", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    private PointDouble(double x, double y) {\n        this.x = x;\n        this.y = y;\n    }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "", "classes": []}, "name": "PointDouble", "params": [{"name": "x", "type": "double"}, {"name": "y", "type": "double"}], "body": "                                            {\n        this.x = x;\n        this.y = y;\n    }", "signature": "private PointDouble(double x, double y)"}, {"syntax_pass": true, "original_string": "    public static PointDouble create(double x, double y) {\n        return new PointDouble(x, y);\n    }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "PointDouble", "classes": []}, "name": "create", "params": [{"name": "x", "type": "double"}, {"name": "y", "type": "double"}], "body": "                                                         {\n        return new PointDouble(x, y);\n    }", "signature": "public static PointDouble create(double x, double y)"}, {"syntax_pass": true, "original_string": "    @Override\n    public Rectangle mbr() {\n        return this;\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Rectangle", "classes": []}, "name": "mbr", "params": [], "body": "                           {\n        return this;\n    }", "signature": "@Override\n    public Rectangle mbr()"}, {"syntax_pass": true, "original_string": "    @Override\n    public double distance(Rectangle r) {\n        return GeometryUtil.distance(x, y, r);\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "double", "classes": []}, "name": "distance", "params": [{"name": "r", "type": "Rectangle"}], "body": "                                        {\n        return GeometryUtil.distance(x, y, r);\n    }", "signature": "@Override\n    public double distance(Rectangle r)"}, {"syntax_pass": true, "original_string": "    @Override\n    public boolean intersects(Rectangle r) {\n        return r.x1() <= x && x <= r.x2() && r.y1() <= y && y <= r.y2();\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "intersects", "params": [{"name": "r", "type": "Rectangle"}], "body": "                                           {\n        return r.x1() <= x && x <= r.x2() && r.y1() <= y && y <= r.y2();\n    }", "signature": "@Override\n    public boolean intersects(Rectangle r)"}, {"syntax_pass": true, "original_string": "    @Override\n    public double x() {\n        return x;\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "double", "classes": []}, "name": "x", "params": [], "body": "                      {\n        return x;\n    }", "signature": "@Override\n    public double x()"}, {"syntax_pass": true, "original_string": "    @Override\n    public double y() {\n        return y;\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "double", "classes": []}, "name": "y", "params": [], "body": "                      {\n        return y;\n    }", "signature": "@Override\n    public double y()"}, {"syntax_pass": true, "original_string": "    @Override\n    public String toString() {\n        return \"Point [x=\" + x() + \", y=\" + y() + \"]\";\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "toString", "params": [], "body": "                             {\n        return \"Point [x=\" + x() + \", y=\" + y() + \"]\";\n    }", "signature": "@Override\n    public String toString()"}, {"syntax_pass": true, "original_string": "    @Override\n    public Geometry geometry() {\n        return this;\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Geometry", "classes": []}, "name": "geometry", "params": [], "body": "                               {\n        return this;\n    }", "signature": "@Override\n    public Geometry geometry()"}, {"syntax_pass": true, "original_string": "    @Override\n    public double x1() {\n        return x;\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "double", "classes": []}, "name": "x1", "params": [], "body": "                       {\n        return x;\n    }", "signature": "@Override\n    public double x1()"}, {"syntax_pass": true, "original_string": "    @Override\n    public double y1() {\n        return y;\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "double", "classes": []}, "name": "y1", "params": [], "body": "                       {\n        return y;\n    }", "signature": "@Override\n    public double y1()"}, {"syntax_pass": true, "original_string": "    @Override\n    public double x2() {\n        return x;\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "double", "classes": []}, "name": "x2", "params": [], "body": "                       {\n        return x;\n    }", "signature": "@Override\n    public double x2()"}, {"syntax_pass": true, "original_string": "    @Override\n    public double y2() {\n        return y;\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "double", "classes": []}, "name": "y2", "params": [], "body": "                       {\n        return y;\n    }", "signature": "@Override\n    public double y2()"}, {"syntax_pass": true, "original_string": "    @Override\n    public double area() {\n        return 0;\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "double", "classes": []}, "name": "area", "params": [], "body": "                         {\n        return 0;\n    }", "signature": "@Override\n    public double area()"}, {"syntax_pass": true, "original_string": "    @Override\n    public Rectangle add(Rectangle r) {\n        return Geometries.rectangle(Math.min(x, r.x1()), Math.min(y, r.y1()), Math.max(x, r.x2()),\n                Math.max(y, r.y2()));\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Rectangle", "classes": []}, "name": "add", "params": [{"name": "r", "type": "Rectangle"}], "body": "                                      {\n        return Geometries.rectangle(Math.min(x, r.x1()), Math.min(y, r.y1()), Math.max(x, r.x2()),\n                Math.max(y, r.y2()));\n    }", "signature": "@Override\n    public Rectangle add(Rectangle r)"}, {"syntax_pass": true, "original_string": "    @Override\n    public boolean contains(double x, double y) {\n        return this.x == x && this.y == y;\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "contains", "params": [{"name": "x", "type": "double"}, {"name": "y", "type": "double"}], "body": "                                                {\n        return this.x == x && this.y == y;\n    }", "signature": "@Override\n    public boolean contains(double x, double y)"}, {"syntax_pass": true, "original_string": "    @Override\n    public double intersectionArea(Rectangle r) {\n        return 0;\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "double", "classes": []}, "name": "intersectionArea", "params": [{"name": "r", "type": "Rectangle"}], "body": "                                                {\n        return 0;\n    }", "signature": "@Override\n    public double intersectionArea(Rectangle r)"}, {"syntax_pass": true, "original_string": "    @Override\n    public double perimeter() {\n        return 0;\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "double", "classes": []}, "name": "perimeter", "params": [], "body": "                              {\n        return 0;\n    }", "signature": "@Override\n    public double perimeter()"}, {"syntax_pass": true, "original_string": "    @Override\n    public boolean isDoublePrecision() {\n        return true;\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isDoublePrecision", "params": [], "body": "                                       {\n        return true;\n    }", "signature": "@Override\n    public boolean isDoublePrecision()"}, {"syntax_pass": true, "original_string": "    @Override\n    public int hashCode() {\n        final int prime = 31;\n        int result = 1;\n        long temp;\n        temp = Double.doubleToLongBits(x);\n        result = prime * result + (int) (temp ^ (temp >>> 32));\n        temp = Double.doubleToLongBits(y);\n        result = prime * result + (int) (temp ^ (temp >>> 32));\n        return result;\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "hashCode", "params": [], "body": "                          {\n        final int prime = 31;\n        int result = 1;\n        long temp;\n        temp = Double.doubleToLongBits(x);\n        result = prime * result + (int) (temp ^ (temp >>> 32));\n        temp = Double.doubleToLongBits(y);\n        result = prime * result + (int) (temp ^ (temp >>> 32));\n        return result;\n    }", "signature": "@Override\n    public int hashCode()"}, {"syntax_pass": true, "original_string": "    @Override\n    public boolean equals(Object obj) {\n        if (this == obj)\n            return true;\n        if (obj == null)\n            return false;\n        if (getClass() != obj.getClass())\n            return false;\n        PointDouble other = (PointDouble) obj;\n        if (Double.doubleToLongBits(x) != Double.doubleToLongBits(other.x))\n            return false;\n        if (Double.doubleToLongBits(y) != Double.doubleToLongBits(other.y))\n            return false;\n        return true;\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "equals", "params": [{"name": "obj", "type": "Object"}], "body": "                                      {\n        if (this == obj)\n            return true;\n        if (obj == null)\n            return false;\n        if (getClass() != obj.getClass())\n            return false;\n        PointDouble other = (PointDouble) obj;\n        if (Double.doubleToLongBits(x) != Double.doubleToLongBits(other.x))\n            return false;\n        if (Double.doubleToLongBits(y) != Double.doubleToLongBits(other.y))\n            return false;\n        return true;\n    }", "signature": "@Override\n    public boolean equals(Object obj)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/com/github/davidmoten/rtree/internal/FactoryDefault.java", "original_string": "package com.github.davidmoten.rtree.internal;\n\nimport java.util.List;\n\nimport com.github.davidmoten.rtree.Context;\nimport com.github.davidmoten.rtree.Entries;\nimport com.github.davidmoten.rtree.Entry;\nimport com.github.davidmoten.rtree.Factory;\nimport com.github.davidmoten.rtree.Leaf;\nimport com.github.davidmoten.rtree.Node;\nimport com.github.davidmoten.rtree.NonLeaf;\nimport com.github.davidmoten.rtree.geometry.Geometry;\n\npublic final class FactoryDefault<T, S extends Geometry> implements Factory<T, S> {\n\n    private static class Holder {\n        private static final Factory<Object, Geometry> INSTANCE = new FactoryDefault<>();\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    public static <T, S extends Geometry> Factory<T, S> instance() {\n        return (Factory<T, S>) Holder.INSTANCE;\n    }\n\n    @Override\n    public Leaf<T, S> createLeaf(List<Entry<T, S>> entries, Context<T, S> context) {\n        return new LeafDefault<>(entries, context);\n    }\n\n    @Override\n    public NonLeaf<T, S> createNonLeaf(List<? extends Node<T, S>> children, Context<T, S> context) {\n        return new NonLeafDefault<>(children, context);\n    }\n\n    @Override\n    public Entry<T, S> createEntry(T value, S geometry) {\n        return Entries.entry(value, geometry);\n    }\n\n}\n", "file_hash": "483d68ccc3e8f779deb5a3f58ac50e34a2519cb2466b4cb10b78ddf23a551210", "file_docstring": "", "contexts": ["package com.github.davidmoten.rtree.internal;", "import java.util.List;", "import com.github.davidmoten.rtree.Context;", "import com.github.davidmoten.rtree.Entries;", "import com.github.davidmoten.rtree.Entry;", "import com.github.davidmoten.rtree.Factory;", "import com.github.davidmoten.rtree.Leaf;", "import com.github.davidmoten.rtree.Node;", "import com.github.davidmoten.rtree.NonLeaf;", "import com.github.davidmoten.rtree.geometry.Geometry;"], "methods": [], "classes": [{"original_string": "public final class FactoryDefault<T, S extends Geometry> implements Factory<T, S> {\n\n    private static class Holder {\n        private static final Factory<Object, Geometry> INSTANCE = new FactoryDefault<>();\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    public static <T, S extends Geometry> Factory<T, S> instance() {\n        return (Factory<T, S>) Holder.INSTANCE;\n    }\n\n    @Override\n    public Leaf<T, S> createLeaf(List<Entry<T, S>> entries, Context<T, S> context) {\n        return new LeafDefault<>(entries, context);\n    }\n\n    @Override\n    public NonLeaf<T, S> createNonLeaf(List<? extends Node<T, S>> children, Context<T, S> context) {\n        return new NonLeafDefault<>(children, context);\n    }\n\n    @Override\n    public Entry<T, S> createEntry(T value, S geometry) {\n        return Entries.entry(value, geometry);\n    }\n\n}", "definition": "public final class FactoryDefault<T, S extends Geometry> implements Factory<T, S>", "class_docstring": "", "name": "FactoryDefault", "super_interfaces": ["Factory<T, S>"], "superclasses": "", "attributes": {"modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "fields": [], "classes": [{"original_string": "    private static class Holder {\n        private static final Factory<Object, Geometry> INSTANCE = new FactoryDefault<>();\n    }", "definition": "    private static class Holder", "class_docstring": "", "name": "Holder", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "fields": [{"attribute_expression": "private static final Factory<Object, Geometry> INSTANCE = new FactoryDefault<>();", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Factory<Object, Geometry>", "name": "INSTANCE = new FactoryDefault<>()", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": []}]}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @SuppressWarnings(\"unchecked\")\n    public static <T, S extends Geometry> Factory<T, S> instance() {\n        return (Factory<T, S>) Holder.INSTANCE;\n    }", "docstring": "", "attributes": {"modifiers": "@SuppressWarnings(\"unchecked\")\n    public static", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings(\"unchecked\")", "public", "static"], "comments": [], "return_type": "Factory<T, S>", "classes": []}, "name": "instance", "params": [], "body": "                                                                   {\n        return (Factory<T, S>) Holder.INSTANCE;\n    }", "signature": "@SuppressWarnings(\"unchecked\")\n    public static <T, S extends Geometry> Factory<T, S> instance()"}, {"syntax_pass": true, "original_string": "    @Override\n    public Leaf<T, S> createLeaf(List<Entry<T, S>> entries, Context<T, S> context) {\n        return new LeafDefault<>(entries, context);\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Leaf<T, S>", "classes": []}, "name": "createLeaf", "params": [{"name": "entries", "type": "List<Entry<T, S>>"}, {"name": "context", "type": "Context<T, S>"}], "body": "                                                                                   {\n        return new LeafDefault<>(entries, context);\n    }", "signature": "@Override\n    public Leaf<T, S> createLeaf(List<Entry<T, S>> entries, Context<T, S> context)"}, {"syntax_pass": true, "original_string": "    @Override\n    public NonLeaf<T, S> createNonLeaf(List<? extends Node<T, S>> children, Context<T, S> context) {\n        return new NonLeafDefault<>(children, context);\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "NonLeaf<T, S>", "classes": []}, "name": "createNonLeaf", "params": [{"name": "children", "type": "List<? extends Node<T, S>>"}, {"name": "context", "type": "Context<T, S>"}], "body": "                                                                                                   {\n        return new NonLeafDefault<>(children, context);\n    }", "signature": "@Override\n    public NonLeaf<T, S> createNonLeaf(List<? extends Node<T, S>> children, Context<T, S> context)"}, {"syntax_pass": true, "original_string": "    @Override\n    public Entry<T, S> createEntry(T value, S geometry) {\n        return Entries.entry(value, geometry);\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Entry<T, S>", "classes": []}, "name": "createEntry", "params": [{"name": "value", "type": "T"}, {"name": "geometry", "type": "S"}], "body": "                                                        {\n        return Entries.entry(value, geometry);\n    }", "signature": "@Override\n    public Entry<T, S> createEntry(T value, S geometry)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/com/github/davidmoten/rtree/internal/Util.java", "original_string": "package com.github.davidmoten.rtree.internal;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.List;\n\nimport com.github.davidmoten.guavamini.Preconditions;\nimport com.github.davidmoten.rtree.geometry.Geometries;\nimport com.github.davidmoten.rtree.geometry.HasGeometry;\nimport com.github.davidmoten.rtree.geometry.Rectangle;\n\n/**\n * @author dxm\n *\n */\npublic final class Util {\n\n    private Util() {\n        // prevent instantiation\n    }\n\n    /**\n     * Returns the minimum bounding rectangle of a number of items. Benchmarks below\n     * indicate that when the number of items is &gt;1 this method is more\n     * performant than one using {@link Rectangle#add(Rectangle)}.\n     * \n     * <pre>\n     * Benchmark                             Mode  Samples         Score  Score error  Units\n     * c.g.d.r.BenchmarksMbr.mbrList1       thrpt       10  48450492.301   436127.960  ops/s\n     * c.g.d.r.BenchmarksMbr.mbrList2       thrpt       10  46658242.728   987901.581  ops/s\n     * c.g.d.r.BenchmarksMbr.mbrList3       thrpt       10  40357809.306   937827.660  ops/s\n     * c.g.d.r.BenchmarksMbr.mbrList4       thrpt       10  35930532.557   605535.237  ops/s\n     * c.g.d.r.BenchmarksMbr.mbrOldList1    thrpt       10  55848118.198  1342997.309  ops/s\n     * c.g.d.r.BenchmarksMbr.mbrOldList2    thrpt       10  25171873.903   395127.918  ops/s\n     * c.g.d.r.BenchmarksMbr.mbrOldList3    thrpt       10  19222116.139   246965.178  ops/s\n     * c.g.d.r.BenchmarksMbr.mbrOldList4    thrpt       10  14891862.638   198765.157  ops/s\n     * </pre>\n     * \n     * @param items\n     *            items to bound\n     * @return the minimum bounding rectangle containings items\n     */\n    public static Rectangle mbr(Collection<? extends HasGeometry> items) {\n        Preconditions.checkArgument(!items.isEmpty());\n        double minX1 = Double.MAX_VALUE;\n        double minY1 = Double.MAX_VALUE;\n        double maxX2 = -Double.MAX_VALUE;\n        double maxY2 = -Double.MAX_VALUE;\n        boolean isDoublePrecision = false;\n        for (final HasGeometry item : items) {\n            Rectangle r = item.geometry().mbr();\n            if (r.isDoublePrecision()) {\n                isDoublePrecision = true;\n            }\n            if (r.x1() < minX1)\n                minX1 = r.x1();\n            if (r.y1() < minY1)\n                minY1 = r.y1();\n            if (r.x2() > maxX2)\n                maxX2 = r.x2();\n            if (r.y2() > maxY2)\n                maxY2 = r.y2();\n        }\n        if (isDoublePrecision) {\n            return Geometries.rectangle(minX1, minY1, maxX2, maxY2);\n        } else {\n            return Geometries.rectangle((float) minX1, (float) minY1, (float) maxX2, (float) maxY2);\n        }\n    }\n\n    public static <T> List<T> add(List<T> list, T element) {\n        final ArrayList<T> result = new ArrayList<T>(list.size() + 2);\n        result.addAll(list);\n        result.add(element);\n        return result;\n    }\n\n    public static <T> List<T> remove(List<? extends T> list, List<? extends T> elements) {\n        final ArrayList<T> result = new ArrayList<T>(list);\n        result.removeAll(elements);\n        return result;\n    }\n\n    public static <T> List<? extends T> replace(List<? extends T> list, T element,\n            List<T> replacements) {\n        List<T> list2 = new ArrayList<T>(list.size() + replacements.size());\n        for (T node : list)\n            if (node != element)\n                list2.add(node);\n        list2.addAll(replacements);\n        return list2;\n    }\n\n}\n", "file_hash": "739ffbae2a0a579a3cc95e51c84e1b5a9bce5173fdadeee0a34e01dd18002494", "file_docstring": "", "contexts": ["package com.github.davidmoten.rtree.internal;", "import java.util.ArrayList;", "import java.util.Collection;", "import java.util.List;", "import com.github.davidmoten.guavamini.Preconditions;", "import com.github.davidmoten.rtree.geometry.Geometries;", "import com.github.davidmoten.rtree.geometry.HasGeometry;", "import com.github.davidmoten.rtree.geometry.Rectangle;"], "methods": [], "classes": [{"original_string": "public final class Util {\n\n    private Util() {\n        // prevent instantiation\n    }\n\n    /**\n     * Returns the minimum bounding rectangle of a number of items. Benchmarks below\n     * indicate that when the number of items is &gt;1 this method is more\n     * performant than one using {@link Rectangle#add(Rectangle)}.\n     * \n     * <pre>\n     * Benchmark                             Mode  Samples         Score  Score error  Units\n     * c.g.d.r.BenchmarksMbr.mbrList1       thrpt       10  48450492.301   436127.960  ops/s\n     * c.g.d.r.BenchmarksMbr.mbrList2       thrpt       10  46658242.728   987901.581  ops/s\n     * c.g.d.r.BenchmarksMbr.mbrList3       thrpt       10  40357809.306   937827.660  ops/s\n     * c.g.d.r.BenchmarksMbr.mbrList4       thrpt       10  35930532.557   605535.237  ops/s\n     * c.g.d.r.BenchmarksMbr.mbrOldList1    thrpt       10  55848118.198  1342997.309  ops/s\n     * c.g.d.r.BenchmarksMbr.mbrOldList2    thrpt       10  25171873.903   395127.918  ops/s\n     * c.g.d.r.BenchmarksMbr.mbrOldList3    thrpt       10  19222116.139   246965.178  ops/s\n     * c.g.d.r.BenchmarksMbr.mbrOldList4    thrpt       10  14891862.638   198765.157  ops/s\n     * </pre>\n     * \n     * @param items\n     *            items to bound\n     * @return the minimum bounding rectangle containings items\n     */\n    public static Rectangle mbr(Collection<? extends HasGeometry> items) {\n        Preconditions.checkArgument(!items.isEmpty());\n        double minX1 = Double.MAX_VALUE;\n        double minY1 = Double.MAX_VALUE;\n        double maxX2 = -Double.MAX_VALUE;\n        double maxY2 = -Double.MAX_VALUE;\n        boolean isDoublePrecision = false;\n        for (final HasGeometry item : items) {\n            Rectangle r = item.geometry().mbr();\n            if (r.isDoublePrecision()) {\n                isDoublePrecision = true;\n            }\n            if (r.x1() < minX1)\n                minX1 = r.x1();\n            if (r.y1() < minY1)\n                minY1 = r.y1();\n            if (r.x2() > maxX2)\n                maxX2 = r.x2();\n            if (r.y2() > maxY2)\n                maxY2 = r.y2();\n        }\n        if (isDoublePrecision) {\n            return Geometries.rectangle(minX1, minY1, maxX2, maxY2);\n        } else {\n            return Geometries.rectangle((float) minX1, (float) minY1, (float) maxX2, (float) maxY2);\n        }\n    }\n\n    public static <T> List<T> add(List<T> list, T element) {\n        final ArrayList<T> result = new ArrayList<T>(list.size() + 2);\n        result.addAll(list);\n        result.add(element);\n        return result;\n    }\n\n    public static <T> List<T> remove(List<? extends T> list, List<? extends T> elements) {\n        final ArrayList<T> result = new ArrayList<T>(list);\n        result.removeAll(elements);\n        return result;\n    }\n\n    public static <T> List<? extends T> replace(List<? extends T> list, T element,\n            List<T> replacements) {\n        List<T> list2 = new ArrayList<T>(list.size() + replacements.size());\n        for (T node : list)\n            if (node != element)\n                list2.add(node);\n        list2.addAll(replacements);\n        return list2;\n    }\n\n}", "definition": "public final class Util", "class_docstring": "\n@author dxm\n\n", "name": "Util", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    private Util() {\n        // prevent instantiation\n    }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "", "classes": []}, "name": "Util", "params": [], "body": "                   {\n        // prevent instantiation\n    }", "signature": "private Util()"}, {"syntax_pass": true, "original_string": "    public static Rectangle mbr(Collection<? extends HasGeometry> items) {\n        Preconditions.checkArgument(!items.isEmpty());\n        double minX1 = Double.MAX_VALUE;\n        double minY1 = Double.MAX_VALUE;\n        double maxX2 = -Double.MAX_VALUE;\n        double maxY2 = -Double.MAX_VALUE;\n        boolean isDoublePrecision = false;\n        for (final HasGeometry item : items) {\n            Rectangle r = item.geometry().mbr();\n            if (r.isDoublePrecision()) {\n                isDoublePrecision = true;\n            }\n            if (r.x1() < minX1)\n                minX1 = r.x1();\n            if (r.y1() < minY1)\n                minY1 = r.y1();\n            if (r.x2() > maxX2)\n                maxX2 = r.x2();\n            if (r.y2() > maxY2)\n                maxY2 = r.y2();\n        }\n        if (isDoublePrecision) {\n            return Geometries.rectangle(minX1, minY1, maxX2, maxY2);\n        } else {\n            return Geometries.rectangle((float) minX1, (float) minY1, (float) maxX2, (float) maxY2);\n        }\n    }", "docstring": "\nReturns the minimum bounding rectangle of a number of items. Benchmarks below\nindicate that when the number of items is &gt;1 this method is more\nperformant than one using {@link Rectangle#add(Rectangle)}.\n\n<pre>\nBenchmark                             Mode  Samples         Score  Score error  Units\nc.g.d.r.BenchmarksMbr.mbrList1       thrpt       10  48450492.301   436127.960  ops/s\nc.g.d.r.BenchmarksMbr.mbrList2       thrpt       10  46658242.728   987901.581  ops/s\nc.g.d.r.BenchmarksMbr.mbrList3       thrpt       10  40357809.306   937827.660  ops/s\nc.g.d.r.BenchmarksMbr.mbrList4       thrpt       10  35930532.557   605535.237  ops/s\nc.g.d.r.BenchmarksMbr.mbrOldList1    thrpt       10  55848118.198  1342997.309  ops/s\nc.g.d.r.BenchmarksMbr.mbrOldList2    thrpt       10  25171873.903   395127.918  ops/s\nc.g.d.r.BenchmarksMbr.mbrOldList3    thrpt       10  19222116.139   246965.178  ops/s\nc.g.d.r.BenchmarksMbr.mbrOldList4    thrpt       10  14891862.638   198765.157  ops/s\n</pre>\n\n@param items\n           items to bound\n@return the minimum bounding rectangle containings items\n", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Rectangle", "classes": []}, "name": "mbr", "params": [{"name": "items", "type": "Collection<? extends HasGeometry>"}], "body": "                                                                         {\n        Preconditions.checkArgument(!items.isEmpty());\n        double minX1 = Double.MAX_VALUE;\n        double minY1 = Double.MAX_VALUE;\n        double maxX2 = -Double.MAX_VALUE;\n        double maxY2 = -Double.MAX_VALUE;\n        boolean isDoublePrecision = false;\n        for (final HasGeometry item : items) {\n            Rectangle r = item.geometry().mbr();\n            if (r.isDoublePrecision()) {\n                isDoublePrecision = true;\n            }\n            if (r.x1() < minX1)\n                minX1 = r.x1();\n            if (r.y1() < minY1)\n                minY1 = r.y1();\n            if (r.x2() > maxX2)\n                maxX2 = r.x2();\n            if (r.y2() > maxY2)\n                maxY2 = r.y2();\n        }\n        if (isDoublePrecision) {\n            return Geometries.rectangle(minX1, minY1, maxX2, maxY2);\n        } else {\n            return Geometries.rectangle((float) minX1, (float) minY1, (float) maxX2, (float) maxY2);\n        }\n    }", "signature": "public static Rectangle mbr(Collection<? extends HasGeometry> items)"}, {"syntax_pass": true, "original_string": "    public static <T> List<T> add(List<T> list, T element) {\n        final ArrayList<T> result = new ArrayList<T>(list.size() + 2);\n        result.addAll(list);\n        result.add(element);\n        return result;\n    }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "List<T>", "classes": []}, "name": "add", "params": [{"name": "list", "type": "List<T>"}, {"name": "element", "type": "T"}], "body": "                                                           {\n        final ArrayList<T> result = new ArrayList<T>(list.size() + 2);\n        result.addAll(list);\n        result.add(element);\n        return result;\n    }", "signature": "public static <T> List<T> add(List<T> list, T element)"}, {"syntax_pass": true, "original_string": "    public static <T> List<T> remove(List<? extends T> list, List<? extends T> elements) {\n        final ArrayList<T> result = new ArrayList<T>(list);\n        result.removeAll(elements);\n        return result;\n    }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "List<T>", "classes": []}, "name": "remove", "params": [{"name": "list", "type": "List<? extends T>"}, {"name": "elements", "type": "List<? extends T>"}], "body": "                                                                                         {\n        final ArrayList<T> result = new ArrayList<T>(list);\n        result.removeAll(elements);\n        return result;\n    }", "signature": "public static <T> List<T> remove(List<? extends T> list, List<? extends T> elements)"}, {"syntax_pass": true, "original_string": "    public static <T> List<? extends T> replace(List<? extends T> list, T element,\n            List<T> replacements) {\n        List<T> list2 = new ArrayList<T>(list.size() + replacements.size());\n        for (T node : list)\n            if (node != element)\n                list2.add(node);\n        list2.addAll(replacements);\n        return list2;\n    }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "List<? extends T>", "classes": []}, "name": "replace", "params": [{"name": "list", "type": "List<? extends T>"}, {"name": "element", "type": "T"}, {"name": "replacements", "type": "List<T>"}], "body": "                                  {\n        List<T> list2 = new ArrayList<T>(list.size() + replacements.size());\n        for (T node : list)\n            if (node != element)\n                list2.add(node);\n        list2.addAll(replacements);\n        return list2;\n    }", "signature": "public static <T> List<? extends T> replace(List<? extends T> list, T element,\n            List<T> replacements)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/com/github/davidmoten/rtree/internal/Functions.java", "original_string": "package com.github.davidmoten.rtree.internal;\n\nimport rx.functions.Func1;\n\npublic final class Functions {\n\n    private Functions() {\n        // prevent instantiation\n    }\n    \n    public static <T> Func1<T, T> identity() {\n        return t -> t;\n    }\n\n    public static <T> Func1<T, Boolean> alwaysTrue() {\n        return t -> true;\n    }\n\n    public static <T> Func1<T, Boolean> alwaysFalse() {\n        return t -> false;\n    }\n    \n}\n", "file_hash": "7f3f07f7581d95b0f7fb763d1c3bf53b1989d0ce493976b15658a6943481e475", "file_docstring": "", "contexts": ["package com.github.davidmoten.rtree.internal;", "import rx.functions.Func1;"], "methods": [], "classes": [{"original_string": "public final class Functions {\n\n    private Functions() {\n        // prevent instantiation\n    }\n    \n    public static <T> Func1<T, T> identity() {\n        return t -> t;\n    }\n\n    public static <T> Func1<T, Boolean> alwaysTrue() {\n        return t -> true;\n    }\n\n    public static <T> Func1<T, Boolean> alwaysFalse() {\n        return t -> false;\n    }\n    \n}", "definition": "public final class Functions", "class_docstring": "", "name": "Functions", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    private Functions() {\n        // prevent instantiation\n    }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "", "classes": []}, "name": "Functions", "params": [], "body": "                        {\n        // prevent instantiation\n    }", "signature": "private Functions()"}, {"syntax_pass": true, "original_string": "    public static <T> Func1<T, T> identity() {\n        return t -> t;\n    }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Func1<T, T>", "classes": []}, "name": "identity", "params": [], "body": "                                             {\n        return t -> t;\n    }", "signature": "public static <T> Func1<T, T> identity()"}, {"syntax_pass": true, "original_string": "    public static <T> Func1<T, Boolean> alwaysTrue() {\n        return t -> true;\n    }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Func1<T, Boolean>", "classes": []}, "name": "alwaysTrue", "params": [], "body": "                                                     {\n        return t -> true;\n    }", "signature": "public static <T> Func1<T, Boolean> alwaysTrue()"}, {"syntax_pass": true, "original_string": "    public static <T> Func1<T, Boolean> alwaysFalse() {\n        return t -> false;\n    }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Func1<T, Boolean>", "classes": []}, "name": "alwaysFalse", "params": [], "body": "                                                      {\n        return t -> false;\n    }", "signature": "public static <T> Func1<T, Boolean> alwaysFalse()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/com/github/davidmoten/rtree/internal/NonLeafDefault.java", "original_string": "package com.github.davidmoten.rtree.internal;\n\nimport java.util.List;\n\nimport com.github.davidmoten.guavamini.Preconditions;\nimport com.github.davidmoten.rtree.Context;\nimport com.github.davidmoten.rtree.Entry;\nimport com.github.davidmoten.rtree.Node;\nimport com.github.davidmoten.rtree.NonLeaf;\nimport com.github.davidmoten.rtree.geometry.Geometry;\nimport com.github.davidmoten.rtree.geometry.Rectangle;\n\nimport rx.Subscriber;\nimport rx.functions.Func1;\n\npublic final class NonLeafDefault<T, S extends Geometry> implements NonLeaf<T, S> {\n\n    private final List<? extends Node<T, S>> children;\n    private final Rectangle mbr;\n    private final Context<T, S> context;\n\n    public NonLeafDefault(List<? extends Node<T, S>> children, Context<T, S> context) {\n        Preconditions.checkArgument(!children.isEmpty());\n        this.context = context;\n        this.children = children;\n        this.mbr = Util.mbr(children);\n    }\n\n    @Override\n    public Geometry geometry() {\n        return mbr;\n    }\n\n    @Override\n    public void searchWithoutBackpressure(Func1<? super Geometry, Boolean> criterion,\n            Subscriber<? super Entry<T, S>> subscriber) {\n        NonLeafHelper.search(criterion, subscriber, this);\n    }\n\n    @Override\n    public int count() {\n        return children.size();\n    }\n\n    @Override\n    public List<Node<T, S>> add(Entry<? extends T, ? extends S> entry) {\n        return NonLeafHelper.add(entry, this);\n    }\n\n    @Override\n    public NodeAndEntries<T, S> delete(Entry<? extends T, ? extends S> entry, boolean all) {\n        return NonLeafHelper.delete(entry, all, this);\n    }\n\n    @Override\n    public Context<T, S> context() {\n        return context;\n    }\n\n    @Override\n    public Node<T, S> child(int i) {\n        return children.get(i);\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public List<Node<T, S>> children() {\n        return (List<Node<T, S>>) children;\n    }\n}", "file_hash": "3502b88975abe5c9a3143c559db22aebfea06140207e693d0ed5c7a52c48662d", "file_docstring": "", "contexts": ["package com.github.davidmoten.rtree.internal;", "import java.util.List;", "import com.github.davidmoten.guavamini.Preconditions;", "import com.github.davidmoten.rtree.Context;", "import com.github.davidmoten.rtree.Entry;", "import com.github.davidmoten.rtree.Node;", "import com.github.davidmoten.rtree.NonLeaf;", "import com.github.davidmoten.rtree.geometry.Geometry;", "import com.github.davidmoten.rtree.geometry.Rectangle;", "import rx.Subscriber;", "import rx.functions.Func1;"], "methods": [], "classes": [{"original_string": "public final class NonLeafDefault<T, S extends Geometry> implements NonLeaf<T, S> {\n\n    private final List<? extends Node<T, S>> children;\n    private final Rectangle mbr;\n    private final Context<T, S> context;\n\n    public NonLeafDefault(List<? extends Node<T, S>> children, Context<T, S> context) {\n        Preconditions.checkArgument(!children.isEmpty());\n        this.context = context;\n        this.children = children;\n        this.mbr = Util.mbr(children);\n    }\n\n    @Override\n    public Geometry geometry() {\n        return mbr;\n    }\n\n    @Override\n    public void searchWithoutBackpressure(Func1<? super Geometry, Boolean> criterion,\n            Subscriber<? super Entry<T, S>> subscriber) {\n        NonLeafHelper.search(criterion, subscriber, this);\n    }\n\n    @Override\n    public int count() {\n        return children.size();\n    }\n\n    @Override\n    public List<Node<T, S>> add(Entry<? extends T, ? extends S> entry) {\n        return NonLeafHelper.add(entry, this);\n    }\n\n    @Override\n    public NodeAndEntries<T, S> delete(Entry<? extends T, ? extends S> entry, boolean all) {\n        return NonLeafHelper.delete(entry, all, this);\n    }\n\n    @Override\n    public Context<T, S> context() {\n        return context;\n    }\n\n    @Override\n    public Node<T, S> child(int i) {\n        return children.get(i);\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public List<Node<T, S>> children() {\n        return (List<Node<T, S>>) children;\n    }\n}", "definition": "public final class NonLeafDefault<T, S extends Geometry> implements NonLeaf<T, S>", "class_docstring": "", "name": "NonLeafDefault", "super_interfaces": ["NonLeaf<T, S>"], "superclasses": "", "attributes": {"modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "fields": [{"attribute_expression": "private final List<? extends Node<T, S>> children;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "List<? extends Node<T, S>>", "name": "children", "syntax_pass": true}, {"attribute_expression": "private final Rectangle mbr;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Rectangle", "name": "mbr", "syntax_pass": true}, {"attribute_expression": "private final Context<T, S> context;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Context<T, S>", "name": "context", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    public NonLeafDefault(List<? extends Node<T, S>> children, Context<T, S> context) {\n        Preconditions.checkArgument(!children.isEmpty());\n        this.context = context;\n        this.children = children;\n        this.mbr = Util.mbr(children);\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "NonLeafDefault", "params": [{"name": "children", "type": "List<? extends Node<T, S>>"}, {"name": "context", "type": "Context<T, S>"}], "body": "                                                                                      {\n        Preconditions.checkArgument(!children.isEmpty());\n        this.context = context;\n        this.children = children;\n        this.mbr = Util.mbr(children);\n    }", "signature": "public NonLeafDefault(List<? extends Node<T, S>> children, Context<T, S> context)"}, {"syntax_pass": true, "original_string": "    @Override\n    public Geometry geometry() {\n        return mbr;\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Geometry", "classes": []}, "name": "geometry", "params": [], "body": "                               {\n        return mbr;\n    }", "signature": "@Override\n    public Geometry geometry()"}, {"syntax_pass": true, "original_string": "    @Override\n    public void searchWithoutBackpressure(Func1<? super Geometry, Boolean> criterion,\n            Subscriber<? super Entry<T, S>> subscriber) {\n        NonLeafHelper.search(criterion, subscriber, this);\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "searchWithoutBackpressure", "params": [{"name": "criterion", "type": "Func1<? super Geometry, Boolean>"}, {"name": "subscriber", "type": "Subscriber<? super Entry<T, S>>"}], "body": "                                                        {\n        NonLeafHelper.search(criterion, subscriber, this);\n    }", "signature": "@Override\n    public void searchWithoutBackpressure(Func1<? super Geometry, Boolean> criterion,\n            Subscriber<? super Entry<T, S>> subscriber)"}, {"syntax_pass": true, "original_string": "    @Override\n    public int count() {\n        return children.size();\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "count", "params": [], "body": "                       {\n        return children.size();\n    }", "signature": "@Override\n    public int count()"}, {"syntax_pass": true, "original_string": "    @Override\n    public List<Node<T, S>> add(Entry<? extends T, ? extends S> entry) {\n        return NonLeafHelper.add(entry, this);\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "List<Node<T, S>>", "classes": []}, "name": "add", "params": [{"name": "entry", "type": "Entry<? extends T, ? extends S>"}], "body": "                                                                       {\n        return NonLeafHelper.add(entry, this);\n    }", "signature": "@Override\n    public List<Node<T, S>> add(Entry<? extends T, ? extends S> entry)"}, {"syntax_pass": true, "original_string": "    @Override\n    public NodeAndEntries<T, S> delete(Entry<? extends T, ? extends S> entry, boolean all) {\n        return NonLeafHelper.delete(entry, all, this);\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "NodeAndEntries<T, S>", "classes": []}, "name": "delete", "params": [{"name": "entry", "type": "Entry<? extends T, ? extends S>"}, {"name": "all", "type": "boolean"}], "body": "                                                                                           {\n        return NonLeafHelper.delete(entry, all, this);\n    }", "signature": "@Override\n    public NodeAndEntries<T, S> delete(Entry<? extends T, ? extends S> entry, boolean all)"}, {"syntax_pass": true, "original_string": "    @Override\n    public Context<T, S> context() {\n        return context;\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Context<T, S>", "classes": []}, "name": "context", "params": [], "body": "                                   {\n        return context;\n    }", "signature": "@Override\n    public Context<T, S> context()"}, {"syntax_pass": true, "original_string": "    @Override\n    public Node<T, S> child(int i) {\n        return children.get(i);\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Node<T, S>", "classes": []}, "name": "child", "params": [{"name": "i", "type": "int"}], "body": "                                   {\n        return children.get(i);\n    }", "signature": "@Override\n    public Node<T, S> child(int i)"}, {"syntax_pass": true, "original_string": "    @SuppressWarnings(\"unchecked\")\n    @Override\n    public List<Node<T, S>> children() {\n        return (List<Node<T, S>>) children;\n    }", "docstring": "", "attributes": {"modifiers": "@SuppressWarnings(\"unchecked\")\n    @Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["@SuppressWarnings(\"unchecked\")", "public"], "comments": [], "return_type": "List<Node<T, S>>", "classes": []}, "name": "children", "params": [], "body": "                                       {\n        return (List<Node<T, S>>) children;\n    }", "signature": "@SuppressWarnings(\"unchecked\")\n    @Override\n    public List<Node<T, S>> children()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/com/github/davidmoten/rtree/internal/LeafDefault.java", "original_string": "package com.github.davidmoten.rtree.internal;\n\nimport java.util.List;\n\nimport com.github.davidmoten.rtree.Context;\nimport com.github.davidmoten.rtree.Entry;\nimport com.github.davidmoten.rtree.Leaf;\nimport com.github.davidmoten.rtree.Node;\nimport com.github.davidmoten.rtree.geometry.Geometry;\nimport com.github.davidmoten.rtree.geometry.Rectangle;\n\nimport rx.Subscriber;\nimport rx.functions.Func1;\n\npublic final class LeafDefault<T, S extends Geometry> implements Leaf<T, S> {\n\n    private final List<Entry<T, S>> entries;\n    private final Rectangle mbr;\n    private final Context<T, S> context;\n\n    public LeafDefault(List<Entry<T, S>> entries, Context<T, S> context) {\n        this.entries = entries;\n        this.context = context;\n        this.mbr = Util.mbr(entries);\n    }\n\n    @Override\n    public Geometry geometry() {\n        return mbr;\n    }\n\n    @Override\n    public List<Entry<T, S>> entries() {\n        return entries;\n    }\n\n    @Override\n    public void searchWithoutBackpressure(Func1<? super Geometry, Boolean> condition,\n            Subscriber<? super Entry<T, S>> subscriber) {\n        LeafHelper.search(condition, subscriber, this);\n    }\n\n    @Override\n    public int count() {\n        return entries.size();\n    }\n\n    @Override\n    public List<Node<T, S>> add(Entry<? extends T, ? extends S> entry) {\n        return LeafHelper.add(entry, this);\n    }\n\n    @Override\n    public NodeAndEntries<T, S> delete(Entry<? extends T, ? extends S> entry, boolean all) {\n        return LeafHelper.delete(entry, all, this);\n    }\n\n    @Override\n    public Context<T, S> context() {\n        return context;\n    }\n\n    @Override\n    public Entry<T, S> entry(int i) {\n        return entries.get(i);\n    }\n\n}\n", "file_hash": "54a905434ec180e7ffcc0098bddf96eab061ce1f88d19f61b4fb01d854ed26f9", "file_docstring": "", "contexts": ["package com.github.davidmoten.rtree.internal;", "import java.util.List;", "import com.github.davidmoten.rtree.Context;", "import com.github.davidmoten.rtree.Entry;", "import com.github.davidmoten.rtree.Leaf;", "import com.github.davidmoten.rtree.Node;", "import com.github.davidmoten.rtree.geometry.Geometry;", "import com.github.davidmoten.rtree.geometry.Rectangle;", "import rx.Subscriber;", "import rx.functions.Func1;"], "methods": [], "classes": [{"original_string": "public final class LeafDefault<T, S extends Geometry> implements Leaf<T, S> {\n\n    private final List<Entry<T, S>> entries;\n    private final Rectangle mbr;\n    private final Context<T, S> context;\n\n    public LeafDefault(List<Entry<T, S>> entries, Context<T, S> context) {\n        this.entries = entries;\n        this.context = context;\n        this.mbr = Util.mbr(entries);\n    }\n\n    @Override\n    public Geometry geometry() {\n        return mbr;\n    }\n\n    @Override\n    public List<Entry<T, S>> entries() {\n        return entries;\n    }\n\n    @Override\n    public void searchWithoutBackpressure(Func1<? super Geometry, Boolean> condition,\n            Subscriber<? super Entry<T, S>> subscriber) {\n        LeafHelper.search(condition, subscriber, this);\n    }\n\n    @Override\n    public int count() {\n        return entries.size();\n    }\n\n    @Override\n    public List<Node<T, S>> add(Entry<? extends T, ? extends S> entry) {\n        return LeafHelper.add(entry, this);\n    }\n\n    @Override\n    public NodeAndEntries<T, S> delete(Entry<? extends T, ? extends S> entry, boolean all) {\n        return LeafHelper.delete(entry, all, this);\n    }\n\n    @Override\n    public Context<T, S> context() {\n        return context;\n    }\n\n    @Override\n    public Entry<T, S> entry(int i) {\n        return entries.get(i);\n    }\n\n}", "definition": "public final class LeafDefault<T, S extends Geometry> implements Leaf<T, S>", "class_docstring": "", "name": "LeafDefault", "super_interfaces": ["Leaf<T, S>"], "superclasses": "", "attributes": {"modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "fields": [{"attribute_expression": "private final List<Entry<T, S>> entries;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "List<Entry<T, S>>", "name": "entries", "syntax_pass": true}, {"attribute_expression": "private final Rectangle mbr;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Rectangle", "name": "mbr", "syntax_pass": true}, {"attribute_expression": "private final Context<T, S> context;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Context<T, S>", "name": "context", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    public LeafDefault(List<Entry<T, S>> entries, Context<T, S> context) {\n        this.entries = entries;\n        this.context = context;\n        this.mbr = Util.mbr(entries);\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "LeafDefault", "params": [{"name": "entries", "type": "List<Entry<T, S>>"}, {"name": "context", "type": "Context<T, S>"}], "body": "                                                                         {\n        this.entries = entries;\n        this.context = context;\n        this.mbr = Util.mbr(entries);\n    }", "signature": "public LeafDefault(List<Entry<T, S>> entries, Context<T, S> context)"}, {"syntax_pass": true, "original_string": "    @Override\n    public Geometry geometry() {\n        return mbr;\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Geometry", "classes": []}, "name": "geometry", "params": [], "body": "                               {\n        return mbr;\n    }", "signature": "@Override\n    public Geometry geometry()"}, {"syntax_pass": true, "original_string": "    @Override\n    public List<Entry<T, S>> entries() {\n        return entries;\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "List<Entry<T, S>>", "classes": []}, "name": "entries", "params": [], "body": "                                       {\n        return entries;\n    }", "signature": "@Override\n    public List<Entry<T, S>> entries()"}, {"syntax_pass": true, "original_string": "    @Override\n    public void searchWithoutBackpressure(Func1<? super Geometry, Boolean> condition,\n            Subscriber<? super Entry<T, S>> subscriber) {\n        LeafHelper.search(condition, subscriber, this);\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "searchWithoutBackpressure", "params": [{"name": "condition", "type": "Func1<? super Geometry, Boolean>"}, {"name": "subscriber", "type": "Subscriber<? super Entry<T, S>>"}], "body": "                                                        {\n        LeafHelper.search(condition, subscriber, this);\n    }", "signature": "@Override\n    public void searchWithoutBackpressure(Func1<? super Geometry, Boolean> condition,\n            Subscriber<? super Entry<T, S>> subscriber)"}, {"syntax_pass": true, "original_string": "    @Override\n    public int count() {\n        return entries.size();\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "count", "params": [], "body": "                       {\n        return entries.size();\n    }", "signature": "@Override\n    public int count()"}, {"syntax_pass": true, "original_string": "    @Override\n    public List<Node<T, S>> add(Entry<? extends T, ? extends S> entry) {\n        return LeafHelper.add(entry, this);\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "List<Node<T, S>>", "classes": []}, "name": "add", "params": [{"name": "entry", "type": "Entry<? extends T, ? extends S>"}], "body": "                                                                       {\n        return LeafHelper.add(entry, this);\n    }", "signature": "@Override\n    public List<Node<T, S>> add(Entry<? extends T, ? extends S> entry)"}, {"syntax_pass": true, "original_string": "    @Override\n    public NodeAndEntries<T, S> delete(Entry<? extends T, ? extends S> entry, boolean all) {\n        return LeafHelper.delete(entry, all, this);\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "NodeAndEntries<T, S>", "classes": []}, "name": "delete", "params": [{"name": "entry", "type": "Entry<? extends T, ? extends S>"}, {"name": "all", "type": "boolean"}], "body": "                                                                                           {\n        return LeafHelper.delete(entry, all, this);\n    }", "signature": "@Override\n    public NodeAndEntries<T, S> delete(Entry<? extends T, ? extends S> entry, boolean all)"}, {"syntax_pass": true, "original_string": "    @Override\n    public Context<T, S> context() {\n        return context;\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Context<T, S>", "classes": []}, "name": "context", "params": [], "body": "                                   {\n        return context;\n    }", "signature": "@Override\n    public Context<T, S> context()"}, {"syntax_pass": true, "original_string": "    @Override\n    public Entry<T, S> entry(int i) {\n        return entries.get(i);\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Entry<T, S>", "classes": []}, "name": "entry", "params": [{"name": "i", "type": "int"}], "body": "                                    {\n        return entries.get(i);\n    }", "signature": "@Override\n    public Entry<T, S> entry(int i)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/com/github/davidmoten/rtree/internal/NodeAndEntries.java", "original_string": "package com.github.davidmoten.rtree.internal;\n\nimport java.util.List;\nimport java.util.Optional;\n\nimport com.github.davidmoten.rtree.Entry;\nimport com.github.davidmoten.rtree.Node;\nimport com.github.davidmoten.rtree.geometry.Geometry;\n\n/**\n * Used for tracking deletions through recursive calls.\n * \n * @param <T>\n *            value type\n * @param <S> geometry type\n */\npublic final class NodeAndEntries<T, S extends Geometry> {\n\n    private final Optional<? extends Node<T, S>> node;\n    private final List<Entry<T, S>> entries;\n    private final int count;\n\n    /**\n     * Constructor.\n     * \n     * @param node\n     *            absent = whole node was deleted present = either an unchanged\n     *            node because of no removal or the newly created node without\n     *            the deleted entry\n     * @param entries\n     *            from nodes that dropped below minChildren in size and thus\n     *            their entries are to be redistributed (readded to the tree)\n     * @param countDeleted\n     *            count of the number of entries removed\n     */\n    public NodeAndEntries(Optional<? extends Node<T, S>> node, List<Entry<T, S>> entries,\n            int countDeleted) {\n        this.node = node;\n        this.entries = entries;\n        this.count = countDeleted;\n    }\n\n    public Optional<? extends Node<T, S>> node() {\n        return node;\n    }\n\n    public List<Entry<T, S>> entriesToAdd() {\n        return entries;\n    }\n\n    public int countDeleted() {\n        return count;\n    }\n\n}\n", "file_hash": "cf89e50222534484ab8c86f086c9003c654f41997ee7a38264955fc3f0134482", "file_docstring": "", "contexts": ["package com.github.davidmoten.rtree.internal;", "import java.util.List;", "import java.util.Optional;", "import com.github.davidmoten.rtree.Entry;", "import com.github.davidmoten.rtree.Node;", "import com.github.davidmoten.rtree.geometry.Geometry;"], "methods": [], "classes": [{"original_string": "public final class NodeAndEntries<T, S extends Geometry> {\n\n    private final Optional<? extends Node<T, S>> node;\n    private final List<Entry<T, S>> entries;\n    private final int count;\n\n    /**\n     * Constructor.\n     * \n     * @param node\n     *            absent = whole node was deleted present = either an unchanged\n     *            node because of no removal or the newly created node without\n     *            the deleted entry\n     * @param entries\n     *            from nodes that dropped below minChildren in size and thus\n     *            their entries are to be redistributed (readded to the tree)\n     * @param countDeleted\n     *            count of the number of entries removed\n     */\n    public NodeAndEntries(Optional<? extends Node<T, S>> node, List<Entry<T, S>> entries,\n            int countDeleted) {\n        this.node = node;\n        this.entries = entries;\n        this.count = countDeleted;\n    }\n\n    public Optional<? extends Node<T, S>> node() {\n        return node;\n    }\n\n    public List<Entry<T, S>> entriesToAdd() {\n        return entries;\n    }\n\n    public int countDeleted() {\n        return count;\n    }\n\n}", "definition": "public final class NodeAndEntries<T, S extends Geometry>", "class_docstring": "\nUsed for tracking deletions through recursive calls.\n\n@param <T>\n           value type\n@param <S> geometry type\n", "name": "NodeAndEntries", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "fields": [{"attribute_expression": "private final Optional<? extends Node<T, S>> node;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Optional<? extends Node<T, S>>", "name": "node", "syntax_pass": true}, {"attribute_expression": "private final List<Entry<T, S>> entries;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "List<Entry<T, S>>", "name": "entries", "syntax_pass": true}, {"attribute_expression": "private final int count;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "int", "name": "count", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    public NodeAndEntries(Optional<? extends Node<T, S>> node, List<Entry<T, S>> entries,\n            int countDeleted) {\n        this.node = node;\n        this.entries = entries;\n        this.count = countDeleted;\n    }", "docstring": "\nConstructor.\n\n@param node\n           absent = whole node was deleted present = either an unchanged\n           node because of no removal or the newly created node without\n           the deleted entry\n@param entries\n           from nodes that dropped below minChildren in size and thus\n           their entries are to be redistributed (readded to the tree)\n@param countDeleted\n           count of the number of entries removed\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "NodeAndEntries", "params": [{"name": "node", "type": "Optional<? extends Node<T, S>>"}, {"name": "entries", "type": "List<Entry<T, S>>"}, {"name": "countDeleted", "type": "int"}], "body": "                              {\n        this.node = node;\n        this.entries = entries;\n        this.count = countDeleted;\n    }", "signature": "public NodeAndEntries(Optional<? extends Node<T, S>> node, List<Entry<T, S>> entries,\n            int countDeleted)"}, {"syntax_pass": true, "original_string": "    public Optional<? extends Node<T, S>> node() {\n        return node;\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Optional<? extends Node<T, S>>", "classes": []}, "name": "node", "params": [], "body": "                                                 {\n        return node;\n    }", "signature": "public Optional<? extends Node<T, S>> node()"}, {"syntax_pass": true, "original_string": "    public List<Entry<T, S>> entriesToAdd() {\n        return entries;\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "List<Entry<T, S>>", "classes": []}, "name": "entriesToAdd", "params": [], "body": "                                            {\n        return entries;\n    }", "signature": "public List<Entry<T, S>> entriesToAdd()"}, {"syntax_pass": true, "original_string": "    public int countDeleted() {\n        return count;\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "countDeleted", "params": [], "body": "                              {\n        return count;\n    }", "signature": "public int countDeleted()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/com/github/davidmoten/rtree/internal/Line2D.java", "original_string": "package com.github.davidmoten.rtree.internal;\n\n/**\n * Port of java.awt.geom.Line2D. Created because Android does not support\n * java.awt.*.\n */\npublic final class Line2D {\n\n    private final double x1, x2, y1, y2;\n\n    public Line2D(double x1, double y1, double x2, double y2) {\n        this.x1 = x1;\n        this.x2 = x2;\n        this.y1 = y1;\n        this.y2 = y2;\n    }\n\n    public double getX1() {\n        return x1;\n    }\n\n    public double getX2() {\n        return x2;\n    }\n\n    public double getY1() {\n        return y1;\n    }\n\n    public double getY2() {\n        return y2;\n    }\n\n    /**\n     * Returns the distance from a point to this line segment. The distance measured\n     * is the distance between the specified point and the closest point between the\n     * current line's end points. If the specified point intersects the line segment\n     * in between the end points, this method returns 0.0.\n     *\n     * @param px\n     *            the X coordinate of the specified point being measured against\n     *            this line segment\n     * @param py\n     *            the Y coordinate of the specified point being measured against\n     *            this line segment\n     * @return a double value that is the distance from the specified point to the\n     *         current line segment.\n     * @since 1.2\n     */\n    public double ptSegDist(double px, double py) {\n        return ptSegDist(getX1(), getY1(), getX2(), getY2(), px, py);\n    }\n\n    /**\n     * Returns the distance from a point to a line segment. The distance measured is\n     * the distance between the specified point and the closest point between the\n     * specified end points. If the specified point intersects the line segment in\n     * between the end points, this method returns 0.0.\n     *\n     * @param x1\n     *            the X coordinate of the start point of the specified line segment\n     * @param y1\n     *            the Y coordinate of the start point of the specified line segment\n     * @param x2\n     *            the X coordinate of the end point of the specified line segment\n     * @param y2\n     *            the Y coordinate of the end point of the specified line segment\n     * @param px\n     *            the X coordinate of the specified point being measured against the\n     *            specified line segment\n     * @param py\n     *            the Y coordinate of the specified point being measured against the\n     *            specified line segment\n     * @return a double value that is the distance from the specified point to the\n     *         specified line segment.\n     * @since 1.2\n     */\n    public static double ptSegDist(double x1, double y1, double x2, double y2, double px,\n            double py) {\n        return Math.sqrt(ptSegDistSq(x1, y1, x2, y2, px, py));\n    }\n\n    /**\n     * Returns the square of the distance from a point to a line segment. The\n     * distance measured is the distance between the specified point and the closest\n     * point between the specified end points. If the specified point intersects the\n     * line segment in between the end points, this method returns 0.0.\n     *\n     * @param x1\n     *            the X coordinate of the start point of the specified line segment\n     * @param y1\n     *            the Y coordinate of the start point of the specified line segment\n     * @param x2\n     *            the X coordinate of the end point of the specified line segment\n     * @param y2\n     *            the Y coordinate of the end point of the specified line segment\n     * @param px\n     *            the X coordinate of the specified point being measured against the\n     *            specified line segment\n     * @param py\n     *            the Y coordinate of the specified point being measured against the\n     *            specified line segment\n     * @return a double value that is the square of the distance from the specified\n     *         point to the specified line segment.\n     * @since 1.2\n     */\n    public static double ptSegDistSq(double x1, double y1, double x2, double y2, double px,\n            double py) {\n        // Adjust vectors relative to x1,y1\n        // x2,y2 becomes relative vector from x1,y1 to end of segment\n        x2 -= x1;\n        y2 -= y1;\n        // px,py becomes relative vector from x1,y1 to test point\n        px -= x1;\n        py -= y1;\n        double dotprod = px * x2 + py * y2;\n        double projlenSq;\n        if (dotprod <= 0.0) {\n            // px,py is on the side of x1,y1 away from x2,y2\n            // distance to segment is length of px,py vector\n            // \"length of its (clipped) projection\" is now 0.0\n            projlenSq = 0.0;\n        } else {\n            // switch to backwards vectors relative to x2,y2\n            // x2,y2 are already the negative of x1,y1=>x2,y2\n            // to get px,py to be the negative of px,py=>x2,y2\n            // the dot product of two negated vectors is the same\n            // as the dot product of the two normal vectors\n            px = x2 - px;\n            py = y2 - py;\n            dotprod = px * x2 + py * y2;\n            if (dotprod <= 0.0) {\n                // px,py is on the side of x2,y2 away from x1,y1\n                // distance to segment is length of (backwards) px,py vector\n                // \"length of its (clipped) projection\" is now 0.0\n                projlenSq = 0.0;\n            } else {\n                // px,py is between x1,y1 and x2,y2\n                // dotprod is the length of the px,py vector\n                // projected on the x2,y2=>x1,y1 vector times the\n                // length of the x2,y2=>x1,y1 vector\n                projlenSq = dotprod * dotprod / (x2 * x2 + y2 * y2);\n            }\n        }\n        // Distance to line is now the length of the relative point\n        // vector minus the length of its projection onto the line\n        // (which is zero if the projection falls outside the range\n        // of the line segment).\n        double lenSq = px * px + py * py - projlenSq;\n        if (lenSq < 0) {\n            lenSq = 0;\n        }\n        return lenSq;\n    }\n\n    /**\n     * Tests if the specified line segment intersects this line segment.\n     * \n     * @param l\n     *            the specified <code>Line2D</code>\n     * @return <code>true</code> if this line segment and the specified line segment\n     *         intersect each other; <code>false</code> otherwise.\n     * @since 1.2\n     */\n    public boolean intersectsLine(Line2D l) {\n        return linesIntersect(l.getX1(), l.getY1(), l.getX2(), l.getY2(), getX1(), getY1(), getX2(),\n                getY2());\n    }\n\n    /**\n     * Tests if the line segment from {@code (x1,y1)} to {@code (x2,y2)} intersects\n     * the line segment from {@code (x3,y3)} to {@code (x4,y4)}.\n     *\n     * @param x1\n     *            the X coordinate of the start point of the first specified line\n     *            segment\n     * @param y1\n     *            the Y coordinate of the start point of the first specified line\n     *            segment\n     * @param x2\n     *            the X coordinate of the end point of the first specified line\n     *            segment\n     * @param y2\n     *            the Y coordinate of the end point of the first specified line\n     *            segment\n     * @param x3\n     *            the X coordinate of the start point of the second specified line\n     *            segment\n     * @param y3\n     *            the Y coordinate of the start point of the second specified line\n     *            segment\n     * @param x4\n     *            the X coordinate of the end point of the second specified line\n     *            segment\n     * @param y4\n     *            the Y coordinate of the end point of the second specified line\n     *            segment\n     * @return <code>true</code> if the first specified line segment and the second\n     *         specified line segment intersect each other; <code>false</code>\n     *         otherwise.\n     * @since 1.2\n     */\n    public static boolean linesIntersect(double x1, double y1, double x2, double y2, double x3,\n            double y3, double x4, double y4) {\n        return ((relativeCCW(x1, y1, x2, y2, x3, y3) * relativeCCW(x1, y1, x2, y2, x4, y4) <= 0)\n                && (relativeCCW(x3, y3, x4, y4, x1, y1)\n                        * relativeCCW(x3, y3, x4, y4, x2, y2) <= 0));\n    }\n\n    /**\n     * Returns an indicator of where the specified point {@code (px,py)} lies with\n     * respect to the line segment from {@code (x1,y1)} to {@code (x2,y2)}. The\n     * return value can be either 1, -1, or 0 and indicates in which direction the\n     * specified line must pivot around its first end point, {@code (x1,y1)}, in\n     * order to point at the specified point {@code (px,py)}.\n     * <p>\n     * A return value of 1 indicates that the line segment must turn in the\n     * direction that takes the positive X axis towards the negative Y axis. In the\n     * default coordinate system used by Java 2D, this direction is\n     * counterclockwise.\n     * <p>\n     * A return value of -1 indicates that the line segment must turn in the\n     * direction that takes the positive X axis towards the positive Y axis. In the\n     * default coordinate system, this direction is clockwise.\n     * <p>\n     * A return value of 0 indicates that the point lies exactly on the line\n     * segment. Note that an indicator value of 0 is rare and not useful for\n     * determining collinearity because of floating point rounding issues.\n     * <p>\n     * If the point is colinear with the line segment, but not between the end\n     * points, then the value will be -1 if the point lies \"beyond {@code (x1,y1)}\"\n     * or 1 if the point lies \"beyond {@code (x2,y2)}\".\n     *\n     * @param x1\n     *            the X coordinate of the start point of the specified line segment\n     * @param y1\n     *            the Y coordinate of the start point of the specified line segment\n     * @param x2\n     *            the X coordinate of the end point of the specified line segment\n     * @param y2\n     *            the Y coordinate of the end point of the specified line segment\n     * @param px\n     *            the X coordinate of the specified point to be compared with the\n     *            specified line segment\n     * @param py\n     *            the Y coordinate of the specified point to be compared with the\n     *            specified line segment\n     * @return an integer that indicates the position of the third specified\n     *         coordinates with respect to the line segment formed by the first two\n     *         specified coordinates.\n     * @since 1.2\n     */\n    private static int relativeCCW(double x1, double y1, double x2, double y2, double px,\n            double py) {\n        x2 -= x1;\n        y2 -= y1;\n        px -= x1;\n        py -= y1;\n        double ccw = px * y2 - py * x2;\n        if (ccw == 0.0) {\n            // The point is colinear, classify based on which side of\n            // the segment the point falls on. We can calculate a\n            // relative value using the projection of px,py onto the\n            // segment - a negative value indicates the point projects\n            // outside of the segment in the direction of the particular\n            // endpoint used as the origin for the projection.\n            ccw = px * x2 + py * y2;\n            if (ccw > 0.0) {\n                // Reverse the projection to be relative to the original x2,y2\n                // x2 and y2 are simply negated.\n                // px and py need to have (x2 - x1) or (y2 - y1) subtracted\n                // from them (based on the original values)\n                // Since we really want to get a positive answer when the\n                // point is \"beyond (x2,y2)\", then we want to calculate\n                // the inverse anyway - thus we leave x2 & y2 negated.\n                px -= x2;\n                py -= y2;\n                ccw = px * x2 + py * y2;\n                if (ccw < 0.0) {\n                    ccw = 0.0;\n                }\n            }\n        }\n        return (ccw < 0.0) ? -1 : ((ccw > 0.0) ? 1 : 0);\n    }\n}\n", "file_hash": "95aa2ab6de12a774664daef1b1fc289d2518cdcbd7ed140db3916d8e3dd7ec57", "file_docstring": "", "contexts": ["package com.github.davidmoten.rtree.internal;"], "methods": [], "classes": [{"original_string": "public final class Line2D {\n\n    private final double x1, x2, y1, y2;\n\n    public Line2D(double x1, double y1, double x2, double y2) {\n        this.x1 = x1;\n        this.x2 = x2;\n        this.y1 = y1;\n        this.y2 = y2;\n    }\n\n    public double getX1() {\n        return x1;\n    }\n\n    public double getX2() {\n        return x2;\n    }\n\n    public double getY1() {\n        return y1;\n    }\n\n    public double getY2() {\n        return y2;\n    }\n\n    /**\n     * Returns the distance from a point to this line segment. The distance measured\n     * is the distance between the specified point and the closest point between the\n     * current line's end points. If the specified point intersects the line segment\n     * in between the end points, this method returns 0.0.\n     *\n     * @param px\n     *            the X coordinate of the specified point being measured against\n     *            this line segment\n     * @param py\n     *            the Y coordinate of the specified point being measured against\n     *            this line segment\n     * @return a double value that is the distance from the specified point to the\n     *         current line segment.\n     * @since 1.2\n     */\n    public double ptSegDist(double px, double py) {\n        return ptSegDist(getX1(), getY1(), getX2(), getY2(), px, py);\n    }\n\n    /**\n     * Returns the distance from a point to a line segment. The distance measured is\n     * the distance between the specified point and the closest point between the\n     * specified end points. If the specified point intersects the line segment in\n     * between the end points, this method returns 0.0.\n     *\n     * @param x1\n     *            the X coordinate of the start point of the specified line segment\n     * @param y1\n     *            the Y coordinate of the start point of the specified line segment\n     * @param x2\n     *            the X coordinate of the end point of the specified line segment\n     * @param y2\n     *            the Y coordinate of the end point of the specified line segment\n     * @param px\n     *            the X coordinate of the specified point being measured against the\n     *            specified line segment\n     * @param py\n     *            the Y coordinate of the specified point being measured against the\n     *            specified line segment\n     * @return a double value that is the distance from the specified point to the\n     *         specified line segment.\n     * @since 1.2\n     */\n    public static double ptSegDist(double x1, double y1, double x2, double y2, double px,\n            double py) {\n        return Math.sqrt(ptSegDistSq(x1, y1, x2, y2, px, py));\n    }\n\n    /**\n     * Returns the square of the distance from a point to a line segment. The\n     * distance measured is the distance between the specified point and the closest\n     * point between the specified end points. If the specified point intersects the\n     * line segment in between the end points, this method returns 0.0.\n     *\n     * @param x1\n     *            the X coordinate of the start point of the specified line segment\n     * @param y1\n     *            the Y coordinate of the start point of the specified line segment\n     * @param x2\n     *            the X coordinate of the end point of the specified line segment\n     * @param y2\n     *            the Y coordinate of the end point of the specified line segment\n     * @param px\n     *            the X coordinate of the specified point being measured against the\n     *            specified line segment\n     * @param py\n     *            the Y coordinate of the specified point being measured against the\n     *            specified line segment\n     * @return a double value that is the square of the distance from the specified\n     *         point to the specified line segment.\n     * @since 1.2\n     */\n    public static double ptSegDistSq(double x1, double y1, double x2, double y2, double px,\n            double py) {\n        // Adjust vectors relative to x1,y1\n        // x2,y2 becomes relative vector from x1,y1 to end of segment\n        x2 -= x1;\n        y2 -= y1;\n        // px,py becomes relative vector from x1,y1 to test point\n        px -= x1;\n        py -= y1;\n        double dotprod = px * x2 + py * y2;\n        double projlenSq;\n        if (dotprod <= 0.0) {\n            // px,py is on the side of x1,y1 away from x2,y2\n            // distance to segment is length of px,py vector\n            // \"length of its (clipped) projection\" is now 0.0\n            projlenSq = 0.0;\n        } else {\n            // switch to backwards vectors relative to x2,y2\n            // x2,y2 are already the negative of x1,y1=>x2,y2\n            // to get px,py to be the negative of px,py=>x2,y2\n            // the dot product of two negated vectors is the same\n            // as the dot product of the two normal vectors\n            px = x2 - px;\n            py = y2 - py;\n            dotprod = px * x2 + py * y2;\n            if (dotprod <= 0.0) {\n                // px,py is on the side of x2,y2 away from x1,y1\n                // distance to segment is length of (backwards) px,py vector\n                // \"length of its (clipped) projection\" is now 0.0\n                projlenSq = 0.0;\n            } else {\n                // px,py is between x1,y1 and x2,y2\n                // dotprod is the length of the px,py vector\n                // projected on the x2,y2=>x1,y1 vector times the\n                // length of the x2,y2=>x1,y1 vector\n                projlenSq = dotprod * dotprod / (x2 * x2 + y2 * y2);\n            }\n        }\n        // Distance to line is now the length of the relative point\n        // vector minus the length of its projection onto the line\n        // (which is zero if the projection falls outside the range\n        // of the line segment).\n        double lenSq = px * px + py * py - projlenSq;\n        if (lenSq < 0) {\n            lenSq = 0;\n        }\n        return lenSq;\n    }\n\n    /**\n     * Tests if the specified line segment intersects this line segment.\n     * \n     * @param l\n     *            the specified <code>Line2D</code>\n     * @return <code>true</code> if this line segment and the specified line segment\n     *         intersect each other; <code>false</code> otherwise.\n     * @since 1.2\n     */\n    public boolean intersectsLine(Line2D l) {\n        return linesIntersect(l.getX1(), l.getY1(), l.getX2(), l.getY2(), getX1(), getY1(), getX2(),\n                getY2());\n    }\n\n    /**\n     * Tests if the line segment from {@code (x1,y1)} to {@code (x2,y2)} intersects\n     * the line segment from {@code (x3,y3)} to {@code (x4,y4)}.\n     *\n     * @param x1\n     *            the X coordinate of the start point of the first specified line\n     *            segment\n     * @param y1\n     *            the Y coordinate of the start point of the first specified line\n     *            segment\n     * @param x2\n     *            the X coordinate of the end point of the first specified line\n     *            segment\n     * @param y2\n     *            the Y coordinate of the end point of the first specified line\n     *            segment\n     * @param x3\n     *            the X coordinate of the start point of the second specified line\n     *            segment\n     * @param y3\n     *            the Y coordinate of the start point of the second specified line\n     *            segment\n     * @param x4\n     *            the X coordinate of the end point of the second specified line\n     *            segment\n     * @param y4\n     *            the Y coordinate of the end point of the second specified line\n     *            segment\n     * @return <code>true</code> if the first specified line segment and the second\n     *         specified line segment intersect each other; <code>false</code>\n     *         otherwise.\n     * @since 1.2\n     */\n    public static boolean linesIntersect(double x1, double y1, double x2, double y2, double x3,\n            double y3, double x4, double y4) {\n        return ((relativeCCW(x1, y1, x2, y2, x3, y3) * relativeCCW(x1, y1, x2, y2, x4, y4) <= 0)\n                && (relativeCCW(x3, y3, x4, y4, x1, y1)\n                        * relativeCCW(x3, y3, x4, y4, x2, y2) <= 0));\n    }\n\n    /**\n     * Returns an indicator of where the specified point {@code (px,py)} lies with\n     * respect to the line segment from {@code (x1,y1)} to {@code (x2,y2)}. The\n     * return value can be either 1, -1, or 0 and indicates in which direction the\n     * specified line must pivot around its first end point, {@code (x1,y1)}, in\n     * order to point at the specified point {@code (px,py)}.\n     * <p>\n     * A return value of 1 indicates that the line segment must turn in the\n     * direction that takes the positive X axis towards the negative Y axis. In the\n     * default coordinate system used by Java 2D, this direction is\n     * counterclockwise.\n     * <p>\n     * A return value of -1 indicates that the line segment must turn in the\n     * direction that takes the positive X axis towards the positive Y axis. In the\n     * default coordinate system, this direction is clockwise.\n     * <p>\n     * A return value of 0 indicates that the point lies exactly on the line\n     * segment. Note that an indicator value of 0 is rare and not useful for\n     * determining collinearity because of floating point rounding issues.\n     * <p>\n     * If the point is colinear with the line segment, but not between the end\n     * points, then the value will be -1 if the point lies \"beyond {@code (x1,y1)}\"\n     * or 1 if the point lies \"beyond {@code (x2,y2)}\".\n     *\n     * @param x1\n     *            the X coordinate of the start point of the specified line segment\n     * @param y1\n     *            the Y coordinate of the start point of the specified line segment\n     * @param x2\n     *            the X coordinate of the end point of the specified line segment\n     * @param y2\n     *            the Y coordinate of the end point of the specified line segment\n     * @param px\n     *            the X coordinate of the specified point to be compared with the\n     *            specified line segment\n     * @param py\n     *            the Y coordinate of the specified point to be compared with the\n     *            specified line segment\n     * @return an integer that indicates the position of the third specified\n     *         coordinates with respect to the line segment formed by the first two\n     *         specified coordinates.\n     * @since 1.2\n     */\n    private static int relativeCCW(double x1, double y1, double x2, double y2, double px,\n            double py) {\n        x2 -= x1;\n        y2 -= y1;\n        px -= x1;\n        py -= y1;\n        double ccw = px * y2 - py * x2;\n        if (ccw == 0.0) {\n            // The point is colinear, classify based on which side of\n            // the segment the point falls on. We can calculate a\n            // relative value using the projection of px,py onto the\n            // segment - a negative value indicates the point projects\n            // outside of the segment in the direction of the particular\n            // endpoint used as the origin for the projection.\n            ccw = px * x2 + py * y2;\n            if (ccw > 0.0) {\n                // Reverse the projection to be relative to the original x2,y2\n                // x2 and y2 are simply negated.\n                // px and py need to have (x2 - x1) or (y2 - y1) subtracted\n                // from them (based on the original values)\n                // Since we really want to get a positive answer when the\n                // point is \"beyond (x2,y2)\", then we want to calculate\n                // the inverse anyway - thus we leave x2 & y2 negated.\n                px -= x2;\n                py -= y2;\n                ccw = px * x2 + py * y2;\n                if (ccw < 0.0) {\n                    ccw = 0.0;\n                }\n            }\n        }\n        return (ccw < 0.0) ? -1 : ((ccw > 0.0) ? 1 : 0);\n    }\n}", "definition": "public final class Line2D", "class_docstring": "\nPort of java.awt.geom.Line2D. Created because Android does not support\njava.awt.*.\n", "name": "Line2D", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "fields": [{"attribute_expression": "private final double x1, x2, y1, y2;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "double", "name": "x1", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    public Line2D(double x1, double y1, double x2, double y2) {\n        this.x1 = x1;\n        this.x2 = x2;\n        this.y1 = y1;\n        this.y2 = y2;\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "Line2D", "params": [{"name": "x1", "type": "double"}, {"name": "y1", "type": "double"}, {"name": "x2", "type": "double"}, {"name": "y2", "type": "double"}], "body": "                                                              {\n        this.x1 = x1;\n        this.x2 = x2;\n        this.y1 = y1;\n        this.y2 = y2;\n    }", "signature": "public Line2D(double x1, double y1, double x2, double y2)"}, {"syntax_pass": true, "original_string": "    public double getX1() {\n        return x1;\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "double", "classes": []}, "name": "getX1", "params": [], "body": "                          {\n        return x1;\n    }", "signature": "public double getX1()"}, {"syntax_pass": true, "original_string": "    public double getX2() {\n        return x2;\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "double", "classes": []}, "name": "getX2", "params": [], "body": "                          {\n        return x2;\n    }", "signature": "public double getX2()"}, {"syntax_pass": true, "original_string": "    public double getY1() {\n        return y1;\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "double", "classes": []}, "name": "getY1", "params": [], "body": "                          {\n        return y1;\n    }", "signature": "public double getY1()"}, {"syntax_pass": true, "original_string": "    public double getY2() {\n        return y2;\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "double", "classes": []}, "name": "getY2", "params": [], "body": "                          {\n        return y2;\n    }", "signature": "public double getY2()"}, {"syntax_pass": true, "original_string": "    public double ptSegDist(double px, double py) {\n        return ptSegDist(getX1(), getY1(), getX2(), getY2(), px, py);\n    }", "docstring": "\nReturns the distance from a point to this line segment. The distance measured\nis the distance between the specified point and the closest point between the\ncurrent line's end points. If the specified point intersects the line segment\nin between the end points, this method returns 0.0.\n\n@param px\n           the X coordinate of the specified point being measured against\n           this line segment\n@param py\n           the Y coordinate of the specified point being measured against\n           this line segment\n@return a double value that is the distance from the specified point to the\n        current line segment.\n@since 1.2\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "double", "classes": []}, "name": "ptSegDist", "params": [{"name": "px", "type": "double"}, {"name": "py", "type": "double"}], "body": "                                                  {\n        return ptSegDist(getX1(), getY1(), getX2(), getY2(), px, py);\n    }", "signature": "public double ptSegDist(double px, double py)"}, {"syntax_pass": true, "original_string": "    public static double ptSegDist(double x1, double y1, double x2, double y2, double px,\n            double py) {\n        return Math.sqrt(ptSegDistSq(x1, y1, x2, y2, px, py));\n    }", "docstring": "\nReturns the distance from a point to a line segment. The distance measured is\nthe distance between the specified point and the closest point between the\nspecified end points. If the specified point intersects the line segment in\nbetween the end points, this method returns 0.0.\n\n@param x1\n           the X coordinate of the start point of the specified line segment\n@param y1\n           the Y coordinate of the start point of the specified line segment\n@param x2\n           the X coordinate of the end point of the specified line segment\n@param y2\n           the Y coordinate of the end point of the specified line segment\n@param px\n           the X coordinate of the specified point being measured against the\n           specified line segment\n@param py\n           the Y coordinate of the specified point being measured against the\n           specified line segment\n@return a double value that is the distance from the specified point to the\n        specified line segment.\n@since 1.2\n", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "double", "classes": []}, "name": "ptSegDist", "params": [{"name": "x1", "type": "double"}, {"name": "y1", "type": "double"}, {"name": "x2", "type": "double"}, {"name": "y2", "type": "double"}, {"name": "px", "type": "double"}, {"name": "py", "type": "double"}], "body": "                       {\n        return Math.sqrt(ptSegDistSq(x1, y1, x2, y2, px, py));\n    }", "signature": "public static double ptSegDist(double x1, double y1, double x2, double y2, double px,\n            double py)"}, {"syntax_pass": true, "original_string": "    public static double ptSegDistSq(double x1, double y1, double x2, double y2, double px,\n            double py) {\n        // Adjust vectors relative to x1,y1\n        // x2,y2 becomes relative vector from x1,y1 to end of segment\n        x2 -= x1;\n        y2 -= y1;\n        // px,py becomes relative vector from x1,y1 to test point\n        px -= x1;\n        py -= y1;\n        double dotprod = px * x2 + py * y2;\n        double projlenSq;\n        if (dotprod <= 0.0) {\n            // px,py is on the side of x1,y1 away from x2,y2\n            // distance to segment is length of px,py vector\n            // \"length of its (clipped) projection\" is now 0.0\n            projlenSq = 0.0;\n        } else {\n            // switch to backwards vectors relative to x2,y2\n            // x2,y2 are already the negative of x1,y1=>x2,y2\n            // to get px,py to be the negative of px,py=>x2,y2\n            // the dot product of two negated vectors is the same\n            // as the dot product of the two normal vectors\n            px = x2 - px;\n            py = y2 - py;\n            dotprod = px * x2 + py * y2;\n            if (dotprod <= 0.0) {\n                // px,py is on the side of x2,y2 away from x1,y1\n                // distance to segment is length of (backwards) px,py vector\n                // \"length of its (clipped) projection\" is now 0.0\n                projlenSq = 0.0;\n            } else {\n                // px,py is between x1,y1 and x2,y2\n                // dotprod is the length of the px,py vector\n                // projected on the x2,y2=>x1,y1 vector times the\n                // length of the x2,y2=>x1,y1 vector\n                projlenSq = dotprod * dotprod / (x2 * x2 + y2 * y2);\n            }\n        }\n        // Distance to line is now the length of the relative point\n        // vector minus the length of its projection onto the line\n        // (which is zero if the projection falls outside the range\n        // of the line segment).\n        double lenSq = px * px + py * py - projlenSq;\n        if (lenSq < 0) {\n            lenSq = 0;\n        }\n        return lenSq;\n    }", "docstring": "\nReturns the square of the distance from a point to a line segment. The\ndistance measured is the distance between the specified point and the closest\npoint between the specified end points. If the specified point intersects the\nline segment in between the end points, this method returns 0.0.\n\n@param x1\n           the X coordinate of the start point of the specified line segment\n@param y1\n           the Y coordinate of the start point of the specified line segment\n@param x2\n           the X coordinate of the end point of the specified line segment\n@param y2\n           the Y coordinate of the end point of the specified line segment\n@param px\n           the X coordinate of the specified point being measured against the\n           specified line segment\n@param py\n           the Y coordinate of the specified point being measured against the\n           specified line segment\n@return a double value that is the square of the distance from the specified\n        point to the specified line segment.\n@since 1.2\n", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "double", "classes": []}, "name": "ptSegDistSq", "params": [{"name": "x1", "type": "double"}, {"name": "y1", "type": "double"}, {"name": "x2", "type": "double"}, {"name": "y2", "type": "double"}, {"name": "px", "type": "double"}, {"name": "py", "type": "double"}], "body": "                       {\n        // Adjust vectors relative to x1,y1\n        // x2,y2 becomes relative vector from x1,y1 to end of segment\n        x2 -= x1;\n        y2 -= y1;\n        // px,py becomes relative vector from x1,y1 to test point\n        px -= x1;\n        py -= y1;\n        double dotprod = px * x2 + py * y2;\n        double projlenSq;\n        if (dotprod <= 0.0) {\n            // px,py is on the side of x1,y1 away from x2,y2\n            // distance to segment is length of px,py vector\n            // \"length of its (clipped) projection\" is now 0.0\n            projlenSq = 0.0;\n        } else {\n            // switch to backwards vectors relative to x2,y2\n            // x2,y2 are already the negative of x1,y1=>x2,y2\n            // to get px,py to be the negative of px,py=>x2,y2\n            // the dot product of two negated vectors is the same\n            // as the dot product of the two normal vectors\n            px = x2 - px;\n            py = y2 - py;\n            dotprod = px * x2 + py * y2;\n            if (dotprod <= 0.0) {\n                // px,py is on the side of x2,y2 away from x1,y1\n                // distance to segment is length of (backwards) px,py vector\n                // \"length of its (clipped) projection\" is now 0.0\n                projlenSq = 0.0;\n            } else {\n                // px,py is between x1,y1 and x2,y2\n                // dotprod is the length of the px,py vector\n                // projected on the x2,y2=>x1,y1 vector times the\n                // length of the x2,y2=>x1,y1 vector\n                projlenSq = dotprod * dotprod / (x2 * x2 + y2 * y2);\n            }\n        }\n        // Distance to line is now the length of the relative point\n        // vector minus the length of its projection onto the line\n        // (which is zero if the projection falls outside the range\n        // of the line segment).\n        double lenSq = px * px + py * py - projlenSq;\n        if (lenSq < 0) {\n            lenSq = 0;\n        }\n        return lenSq;\n    }", "signature": "public static double ptSegDistSq(double x1, double y1, double x2, double y2, double px,\n            double py)"}, {"syntax_pass": true, "original_string": "    public boolean intersectsLine(Line2D l) {\n        return linesIntersect(l.getX1(), l.getY1(), l.getX2(), l.getY2(), getX1(), getY1(), getX2(),\n                getY2());\n    }", "docstring": "\nTests if the specified line segment intersects this line segment.\n\n@param l\n           the specified <code>Line2D</code>\n@return <code>true</code> if this line segment and the specified line segment\n        intersect each other; <code>false</code> otherwise.\n@since 1.2\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "intersectsLine", "params": [{"name": "l", "type": "Line2D"}], "body": "                                            {\n        return linesIntersect(l.getX1(), l.getY1(), l.getX2(), l.getY2(), getX1(), getY1(), getX2(),\n                getY2());\n    }", "signature": "public boolean intersectsLine(Line2D l)"}, {"syntax_pass": true, "original_string": "    public static boolean linesIntersect(double x1, double y1, double x2, double y2, double x3,\n            double y3, double x4, double y4) {\n        return ((relativeCCW(x1, y1, x2, y2, x3, y3) * relativeCCW(x1, y1, x2, y2, x4, y4) <= 0)\n                && (relativeCCW(x3, y3, x4, y4, x1, y1)\n                        * relativeCCW(x3, y3, x4, y4, x2, y2) <= 0));\n    }", "docstring": "\nTests if the line segment from {@code (x1,y1)} to {@code (x2,y2)} intersects\nthe line segment from {@code (x3,y3)} to {@code (x4,y4)}.\n\n@param x1\n           the X coordinate of the start point of the first specified line\n           segment\n@param y1\n           the Y coordinate of the start point of the first specified line\n           segment\n@param x2\n           the X coordinate of the end point of the first specified line\n           segment\n@param y2\n           the Y coordinate of the end point of the first specified line\n           segment\n@param x3\n           the X coordinate of the start point of the second specified line\n           segment\n@param y3\n           the Y coordinate of the start point of the second specified line\n           segment\n@param x4\n           the X coordinate of the end point of the second specified line\n           segment\n@param y4\n           the Y coordinate of the end point of the second specified line\n           segment\n@return <code>true</code> if the first specified line segment and the second\n        specified line segment intersect each other; <code>false</code>\n        otherwise.\n@since 1.2\n", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "boolean", "classes": []}, "name": "linesIntersect", "params": [{"name": "x1", "type": "double"}, {"name": "y1", "type": "double"}, {"name": "x2", "type": "double"}, {"name": "y2", "type": "double"}, {"name": "x3", "type": "double"}, {"name": "y3", "type": "double"}, {"name": "x4", "type": "double"}, {"name": "y4", "type": "double"}], "body": "                                             {\n        return ((relativeCCW(x1, y1, x2, y2, x3, y3) * relativeCCW(x1, y1, x2, y2, x4, y4) <= 0)\n                && (relativeCCW(x3, y3, x4, y4, x1, y1)\n                        * relativeCCW(x3, y3, x4, y4, x2, y2) <= 0));\n    }", "signature": "public static boolean linesIntersect(double x1, double y1, double x2, double y2, double x3,\n            double y3, double x4, double y4)"}, {"syntax_pass": true, "original_string": "    private static int relativeCCW(double x1, double y1, double x2, double y2, double px,\n            double py) {\n        x2 -= x1;\n        y2 -= y1;\n        px -= x1;\n        py -= y1;\n        double ccw = px * y2 - py * x2;\n        if (ccw == 0.0) {\n            // The point is colinear, classify based on which side of\n            // the segment the point falls on. We can calculate a\n            // relative value using the projection of px,py onto the\n            // segment - a negative value indicates the point projects\n            // outside of the segment in the direction of the particular\n            // endpoint used as the origin for the projection.\n            ccw = px * x2 + py * y2;\n            if (ccw > 0.0) {\n                // Reverse the projection to be relative to the original x2,y2\n                // x2 and y2 are simply negated.\n                // px and py need to have (x2 - x1) or (y2 - y1) subtracted\n                // from them (based on the original values)\n                // Since we really want to get a positive answer when the\n                // point is \"beyond (x2,y2)\", then we want to calculate\n                // the inverse anyway - thus we leave x2 & y2 negated.\n                px -= x2;\n                py -= y2;\n                ccw = px * x2 + py * y2;\n                if (ccw < 0.0) {\n                    ccw = 0.0;\n                }\n            }\n        }\n        return (ccw < 0.0) ? -1 : ((ccw > 0.0) ? 1 : 0);\n    }", "docstring": "\nReturns an indicator of where the specified point {@code (px,py)} lies with\nrespect to the line segment from {@code (x1,y1)} to {@code (x2,y2)}. The\nreturn value can be either 1, -1, or 0 and indicates in which direction the\nspecified line must pivot around its first end point, {@code (x1,y1)}, in\norder to point at the specified point {@code (px,py)}.\n<p>\nA return value of 1 indicates that the line segment must turn in the\ndirection that takes the positive X axis towards the negative Y axis. In the\ndefault coordinate system used by Java 2D, this direction is\ncounterclockwise.\n<p>\nA return value of -1 indicates that the line segment must turn in the\ndirection that takes the positive X axis towards the positive Y axis. In the\ndefault coordinate system, this direction is clockwise.\n<p>\nA return value of 0 indicates that the point lies exactly on the line\nsegment. Note that an indicator value of 0 is rare and not useful for\ndetermining collinearity because of floating point rounding issues.\n<p>\nIf the point is colinear with the line segment, but not between the end\npoints, then the value will be -1 if the point lies \"beyond {@code (x1,y1)}\"\nor 1 if the point lies \"beyond {@code (x2,y2)}\".\n\n@param x1\n           the X coordinate of the start point of the specified line segment\n@param y1\n           the Y coordinate of the start point of the specified line segment\n@param x2\n           the X coordinate of the end point of the specified line segment\n@param y2\n           the Y coordinate of the end point of the specified line segment\n@param px\n           the X coordinate of the specified point to be compared with the\n           specified line segment\n@param py\n           the Y coordinate of the specified point to be compared with the\n           specified line segment\n@return an integer that indicates the position of the third specified\n        coordinates with respect to the line segment formed by the first two\n        specified coordinates.\n@since 1.2\n", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "int", "classes": []}, "name": "relativeCCW", "params": [{"name": "x1", "type": "double"}, {"name": "y1", "type": "double"}, {"name": "x2", "type": "double"}, {"name": "y2", "type": "double"}, {"name": "px", "type": "double"}, {"name": "py", "type": "double"}], "body": "                       {\n        x2 -= x1;\n        y2 -= y1;\n        px -= x1;\n        py -= y1;\n        double ccw = px * y2 - py * x2;\n        if (ccw == 0.0) {\n            // The point is colinear, classify based on which side of\n            // the segment the point falls on. We can calculate a\n            // relative value using the projection of px,py onto the\n            // segment - a negative value indicates the point projects\n            // outside of the segment in the direction of the particular\n            // endpoint used as the origin for the projection.\n            ccw = px * x2 + py * y2;\n            if (ccw > 0.0) {\n                // Reverse the projection to be relative to the original x2,y2\n                // x2 and y2 are simply negated.\n                // px and py need to have (x2 - x1) or (y2 - y1) subtracted\n                // from them (based on the original values)\n                // Since we really want to get a positive answer when the\n                // point is \"beyond (x2,y2)\", then we want to calculate\n                // the inverse anyway - thus we leave x2 & y2 negated.\n                px -= x2;\n                py -= y2;\n                ccw = px * x2 + py * y2;\n                if (ccw < 0.0) {\n                    ccw = 0.0;\n                }\n            }\n        }\n        return (ccw < 0.0) ? -1 : ((ccw > 0.0) ? 1 : 0);\n    }", "signature": "private static int relativeCCW(double x1, double y1, double x2, double y2, double px,\n            double py)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/com/github/davidmoten/rtree/internal/LeafHelper.java", "original_string": "package com.github.davidmoten.rtree.internal;\n\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Optional;\n\nimport com.github.davidmoten.rtree.Context;\nimport com.github.davidmoten.rtree.Entry;\nimport com.github.davidmoten.rtree.Leaf;\nimport com.github.davidmoten.rtree.Node;\nimport com.github.davidmoten.rtree.geometry.Geometry;\nimport com.github.davidmoten.rtree.geometry.ListPair;\n\nimport rx.Subscriber;\nimport rx.functions.Func1;\n\nimport static java.util.Optional.of;\n\npublic final class LeafHelper {\n\n    private LeafHelper() {\n        // prevent instantiation\n    }\n\n    public static <T, S extends Geometry> NodeAndEntries<T, S> delete(\n            Entry<? extends T, ? extends S> entry, boolean all, Leaf<T, S> leaf) {\n        List<Entry<T, S>> entries = leaf.entries();\n        if (!entries.contains(entry)) {\n            return new NodeAndEntries<>(of(leaf), Collections.emptyList(), 0);\n        } else {\n            final List<Entry<T, S>> entries2 = new ArrayList<>(entries);\n            entries2.remove(entry);\n            int numDeleted = 1;\n            // keep deleting if all specified\n            while (all && entries2.remove(entry))\n                numDeleted += 1;\n\n            if (entries2.size() >= leaf.context().minChildren()) {\n                Leaf<T, S> node = leaf.context().factory().createLeaf(entries2, leaf.context());\n                return new NodeAndEntries<>(of(node), Collections.emptyList(),\n                        numDeleted);\n            } else {\n                return new NodeAndEntries<T, S>(Optional.empty(), entries2,\n                        numDeleted);\n            }\n        }\n    }\n\n    public static <T, S extends Geometry> List<Node<T, S>> add(\n            Entry<? extends T, ? extends S> entry, Leaf<T, S> leaf) {\n        List<Entry<T, S>> entries = leaf.entries();\n        Context<T, S> context = leaf.context();\n        @SuppressWarnings(\"unchecked\")\n        final List<Entry<T, S>> entries2 = Util.add(entries, (Entry<T, S>) entry);\n        if (entries2.size() <= context.maxChildren())\n            return Collections\n                    .singletonList((Node<T, S>) context.factory().createLeaf(entries2, context));\n        else {\n            ListPair<Entry<T, S>> pair = context.splitter().split(entries2, context.minChildren());\n            return makeLeaves(pair, context);\n        }\n    }\n\n    private static <T, S extends Geometry> List<Node<T, S>> makeLeaves(ListPair<Entry<T, S>> pair,\n            Context<T, S> context) {\n        List<Node<T, S>> list = new ArrayList<Node<T, S>>(2);\n        list.add(context.factory().createLeaf(pair.group1().list(), context));\n        list.add(context.factory().createLeaf(pair.group2().list(), context));\n        return list;\n    }\n\n    public static <T, S extends Geometry> void search(Func1<? super Geometry, Boolean> condition,\n            Subscriber<? super Entry<T, S>> subscriber, Leaf<T, S> leaf) {\n\n        if (!condition.call(leaf.geometry().mbr())) {\n            return;\n        }\n\n        for (int i = 0; i < leaf.count(); i++) {\n            Entry<T, S> entry = leaf.entry(i);\n            if (subscriber.isUnsubscribed()) {\n                return;\n            } else {\n                if (condition.call(entry.geometry())) {\n                    subscriber.onNext(entry);\n                }\n            }\n        }\n    }\n\n}\n", "file_hash": "7e3827b7dcab534141ecaf523cf5734193510bc1177ea2a119a2333ec2c6c4fe", "file_docstring": "", "contexts": ["package com.github.davidmoten.rtree.internal;", "import java.util.ArrayList;", "import java.util.Collections;", "import java.util.List;", "import java.util.Optional;", "import com.github.davidmoten.rtree.Context;", "import com.github.davidmoten.rtree.Entry;", "import com.github.davidmoten.rtree.Leaf;", "import com.github.davidmoten.rtree.Node;", "import com.github.davidmoten.rtree.geometry.Geometry;", "import com.github.davidmoten.rtree.geometry.ListPair;", "import rx.Subscriber;", "import rx.functions.Func1;", "import static java.util.Optional.of;"], "methods": [], "classes": [{"original_string": "public final class LeafHelper {\n\n    private LeafHelper() {\n        // prevent instantiation\n    }\n\n    public static <T, S extends Geometry> NodeAndEntries<T, S> delete(\n            Entry<? extends T, ? extends S> entry, boolean all, Leaf<T, S> leaf) {\n        List<Entry<T, S>> entries = leaf.entries();\n        if (!entries.contains(entry)) {\n            return new NodeAndEntries<>(of(leaf), Collections.emptyList(), 0);\n        } else {\n            final List<Entry<T, S>> entries2 = new ArrayList<>(entries);\n            entries2.remove(entry);\n            int numDeleted = 1;\n            // keep deleting if all specified\n            while (all && entries2.remove(entry))\n                numDeleted += 1;\n\n            if (entries2.size() >= leaf.context().minChildren()) {\n                Leaf<T, S> node = leaf.context().factory().createLeaf(entries2, leaf.context());\n                return new NodeAndEntries<>(of(node), Collections.emptyList(),\n                        numDeleted);\n            } else {\n                return new NodeAndEntries<T, S>(Optional.empty(), entries2,\n                        numDeleted);\n            }\n        }\n    }\n\n    public static <T, S extends Geometry> List<Node<T, S>> add(\n            Entry<? extends T, ? extends S> entry, Leaf<T, S> leaf) {\n        List<Entry<T, S>> entries = leaf.entries();\n        Context<T, S> context = leaf.context();\n        @SuppressWarnings(\"unchecked\")\n        final List<Entry<T, S>> entries2 = Util.add(entries, (Entry<T, S>) entry);\n        if (entries2.size() <= context.maxChildren())\n            return Collections\n                    .singletonList((Node<T, S>) context.factory().createLeaf(entries2, context));\n        else {\n            ListPair<Entry<T, S>> pair = context.splitter().split(entries2, context.minChildren());\n            return makeLeaves(pair, context);\n        }\n    }\n\n    private static <T, S extends Geometry> List<Node<T, S>> makeLeaves(ListPair<Entry<T, S>> pair,\n            Context<T, S> context) {\n        List<Node<T, S>> list = new ArrayList<Node<T, S>>(2);\n        list.add(context.factory().createLeaf(pair.group1().list(), context));\n        list.add(context.factory().createLeaf(pair.group2().list(), context));\n        return list;\n    }\n\n    public static <T, S extends Geometry> void search(Func1<? super Geometry, Boolean> condition,\n            Subscriber<? super Entry<T, S>> subscriber, Leaf<T, S> leaf) {\n\n        if (!condition.call(leaf.geometry().mbr())) {\n            return;\n        }\n\n        for (int i = 0; i < leaf.count(); i++) {\n            Entry<T, S> entry = leaf.entry(i);\n            if (subscriber.isUnsubscribed()) {\n                return;\n            } else {\n                if (condition.call(entry.geometry())) {\n                    subscriber.onNext(entry);\n                }\n            }\n        }\n    }\n\n}", "definition": "public final class LeafHelper", "class_docstring": "", "name": "LeafHelper", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    private LeafHelper() {\n        // prevent instantiation\n    }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "", "classes": []}, "name": "LeafHelper", "params": [], "body": "                         {\n        // prevent instantiation\n    }", "signature": "private LeafHelper()"}, {"syntax_pass": true, "original_string": "    public static <T, S extends Geometry> NodeAndEntries<T, S> delete(\n            Entry<? extends T, ? extends S> entry, boolean all, Leaf<T, S> leaf) {\n        List<Entry<T, S>> entries = leaf.entries();\n        if (!entries.contains(entry)) {\n            return new NodeAndEntries<>(of(leaf), Collections.emptyList(), 0);\n        } else {\n            final List<Entry<T, S>> entries2 = new ArrayList<>(entries);\n            entries2.remove(entry);\n            int numDeleted = 1;\n            // keep deleting if all specified\n            while (all && entries2.remove(entry))\n                numDeleted += 1;\n\n            if (entries2.size() >= leaf.context().minChildren()) {\n                Leaf<T, S> node = leaf.context().factory().createLeaf(entries2, leaf.context());\n                return new NodeAndEntries<>(of(node), Collections.emptyList(),\n                        numDeleted);\n            } else {\n                return new NodeAndEntries<T, S>(Optional.empty(), entries2,\n                        numDeleted);\n            }\n        }\n    }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "NodeAndEntries<T, S>", "classes": []}, "name": "delete", "params": [{"name": "entry", "type": "Entry<? extends T, ? extends S>"}, {"name": "all", "type": "boolean"}, {"name": "leaf", "type": "Leaf<T, S>"}], "body": "                                                                                 {\n        List<Entry<T, S>> entries = leaf.entries();\n        if (!entries.contains(entry)) {\n            return new NodeAndEntries<>(of(leaf), Collections.emptyList(), 0);\n        } else {\n            final List<Entry<T, S>> entries2 = new ArrayList<>(entries);\n            entries2.remove(entry);\n            int numDeleted = 1;\n            // keep deleting if all specified\n            while (all && entries2.remove(entry))\n                numDeleted += 1;\n\n            if (entries2.size() >= leaf.context().minChildren()) {\n                Leaf<T, S> node = leaf.context().factory().createLeaf(entries2, leaf.context());\n                return new NodeAndEntries<>(of(node), Collections.emptyList(),\n                        numDeleted);\n            } else {\n                return new NodeAndEntries<T, S>(Optional.empty(), entries2,\n                        numDeleted);\n            }\n        }\n    }", "signature": "public static <T, S extends Geometry> NodeAndEntries<T, S> delete(\n            Entry<? extends T, ? extends S> entry, boolean all, Leaf<T, S> leaf)"}, {"syntax_pass": true, "original_string": "    public static <T, S extends Geometry> List<Node<T, S>> add(\n            Entry<? extends T, ? extends S> entry, Leaf<T, S> leaf) {\n        List<Entry<T, S>> entries = leaf.entries();\n        Context<T, S> context = leaf.context();\n        @SuppressWarnings(\"unchecked\")\n        final List<Entry<T, S>> entries2 = Util.add(entries, (Entry<T, S>) entry);\n        if (entries2.size() <= context.maxChildren())\n            return Collections\n                    .singletonList((Node<T, S>) context.factory().createLeaf(entries2, context));\n        else {\n            ListPair<Entry<T, S>> pair = context.splitter().split(entries2, context.minChildren());\n            return makeLeaves(pair, context);\n        }\n    }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "List<Node<T, S>>", "classes": []}, "name": "add", "params": [{"name": "entry", "type": "Entry<? extends T, ? extends S>"}, {"name": "leaf", "type": "Leaf<T, S>"}], "body": "                                                                    {\n        List<Entry<T, S>> entries = leaf.entries();\n        Context<T, S> context = leaf.context();\n        @SuppressWarnings(\"unchecked\")\n        final List<Entry<T, S>> entries2 = Util.add(entries, (Entry<T, S>) entry);\n        if (entries2.size() <= context.maxChildren())\n            return Collections\n                    .singletonList((Node<T, S>) context.factory().createLeaf(entries2, context));\n        else {\n            ListPair<Entry<T, S>> pair = context.splitter().split(entries2, context.minChildren());\n            return makeLeaves(pair, context);\n        }\n    }", "signature": "public static <T, S extends Geometry> List<Node<T, S>> add(\n            Entry<? extends T, ? extends S> entry, Leaf<T, S> leaf)"}, {"syntax_pass": true, "original_string": "    private static <T, S extends Geometry> List<Node<T, S>> makeLeaves(ListPair<Entry<T, S>> pair,\n            Context<T, S> context) {\n        List<Node<T, S>> list = new ArrayList<Node<T, S>>(2);\n        list.add(context.factory().createLeaf(pair.group1().list(), context));\n        list.add(context.factory().createLeaf(pair.group2().list(), context));\n        return list;\n    }", "docstring": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "List<Node<T, S>>", "classes": []}, "name": "makeLeaves", "params": [{"name": "pair", "type": "ListPair<Entry<T, S>>"}, {"name": "context", "type": "Context<T, S>"}], "body": "                                   {\n        List<Node<T, S>> list = new ArrayList<Node<T, S>>(2);\n        list.add(context.factory().createLeaf(pair.group1().list(), context));\n        list.add(context.factory().createLeaf(pair.group2().list(), context));\n        return list;\n    }", "signature": "private static <T, S extends Geometry> List<Node<T, S>> makeLeaves(ListPair<Entry<T, S>> pair,\n            Context<T, S> context)"}, {"syntax_pass": true, "original_string": "    public static <T, S extends Geometry> void search(Func1<? super Geometry, Boolean> condition,\n            Subscriber<? super Entry<T, S>> subscriber, Leaf<T, S> leaf) {\n\n        if (!condition.call(leaf.geometry().mbr())) {\n            return;\n        }\n\n        for (int i = 0; i < leaf.count(); i++) {\n            Entry<T, S> entry = leaf.entry(i);\n            if (subscriber.isUnsubscribed()) {\n                return;\n            } else {\n                if (condition.call(entry.geometry())) {\n                    subscriber.onNext(entry);\n                }\n            }\n        }\n    }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "void", "classes": []}, "name": "search", "params": [{"name": "condition", "type": "Func1<? super Geometry, Boolean>"}, {"name": "subscriber", "type": "Subscriber<? super Entry<T, S>>"}, {"name": "leaf", "type": "Leaf<T, S>"}], "body": "                                                                         {\n\n        if (!condition.call(leaf.geometry().mbr())) {\n            return;\n        }\n\n        for (int i = 0; i < leaf.count(); i++) {\n            Entry<T, S> entry = leaf.entry(i);\n            if (subscriber.isUnsubscribed()) {\n                return;\n            } else {\n                if (condition.call(entry.geometry())) {\n                    subscriber.onNext(entry);\n                }\n            }\n        }\n    }", "signature": "public static <T, S extends Geometry> void search(Func1<? super Geometry, Boolean> condition,\n            Subscriber<? super Entry<T, S>> subscriber, Leaf<T, S> leaf)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/com/github/davidmoten/rtree/internal/Comparators.java", "original_string": "package com.github.davidmoten.rtree.internal;\n\nimport java.util.Comparator;\nimport java.util.List;\n\nimport com.github.davidmoten.rtree.Entry;\nimport com.github.davidmoten.rtree.Selector;\nimport com.github.davidmoten.rtree.Splitter;\nimport com.github.davidmoten.rtree.geometry.Geometry;\nimport com.github.davidmoten.rtree.geometry.HasGeometry;\nimport com.github.davidmoten.rtree.geometry.Rectangle;\n\n/**\n * Utility functions asociated with {@link Comparator}s, especially for use with\n * {@link Selector}s and {@link Splitter}s.\n * \n */\npublic final class Comparators {\n\n    private Comparators() {\n        // prevent instantiation\n    }\n\n    public static <T extends HasGeometry> Comparator<HasGeometry> overlapAreaThenAreaIncreaseThenAreaComparator(\n            final Rectangle r, final List<T> list) {\n        return new Comparator<HasGeometry>() {\n\n            @Override\n            public int compare(HasGeometry g1, HasGeometry g2) {\n                int value = Double.compare(overlapArea(r, list, g1), overlapArea(r, list, g2));\n                if (value == 0) {\n                    value = Double.compare(areaIncrease(r, g1), areaIncrease(r, g2));\n                    if (value == 0) {\n                        value = Double.compare(area(r, g1), area(r, g2));\n                    }\n                }\n                return value;\n            }\n        };\n    }\n\n    private static double area(final Rectangle r, HasGeometry g1) {\n        return g1.geometry().mbr().add(r).area();\n    }\n\n    public static <T extends HasGeometry> Comparator<HasGeometry> areaIncreaseThenAreaComparator(\n            final Rectangle r) {\n        return new Comparator<HasGeometry>() {\n            @Override\n            public int compare(HasGeometry g1, HasGeometry g2) {\n                int value = Double.compare(areaIncrease(r, g1), areaIncrease(r, g2));\n                if (value == 0) {\n                    value = Double.compare(area(r, g1), area(r, g2));\n                }\n                return value;\n            }\n        };\n    }\n\n    private static float overlapArea(Rectangle r, List<? extends HasGeometry> list, HasGeometry g) {\n        Rectangle gPlusR = g.geometry().mbr().add(r);\n        float m = 0;\n        for (HasGeometry other : list) {\n            if (other != g) {\n                m += gPlusR.intersectionArea(other.geometry().mbr());\n            }\n        }\n        return m;\n    }\n\n    private static double areaIncrease(Rectangle r, HasGeometry g) {\n        Rectangle gPlusR = g.geometry().mbr().add(r);\n        return gPlusR.area() - g.geometry().mbr().area();\n    }\n\n    /**\n     * <p>\n     * Returns a comparator that can be used to sort entries returned by search\n     * methods. For example:\n     * </p>\n     * <p>\n     * <code>search(100).toSortedList(ascendingDistance(r))</code>\n     * </p>\n     * \n     * @param <T>\n     *            the value type\n     * @param <S>\n     *            the entry type\n     * @param r\n     *            rectangle to measure distance to\n     * @return a comparator to sort by ascending distance from the rectangle\n     */\n    public static <T, S extends Geometry> Comparator<Entry<T, S>> ascendingDistance(\n            final Rectangle r) {\n        return new Comparator<Entry<T, S>>() {\n            @Override\n            public int compare(Entry<T, S> e1, Entry<T, S> e2) {\n                return Double.compare(e1.geometry().distance(r), e2.geometry().distance(r));\n            }\n        };\n    }\n\n}\n", "file_hash": "4d2f19be3ad1ab907ecaeead241cf0ca507abda2a99d02d107ae2bd47b3e16d9", "file_docstring": "", "contexts": ["package com.github.davidmoten.rtree.internal;", "import java.util.Comparator;", "import java.util.List;", "import com.github.davidmoten.rtree.Entry;", "import com.github.davidmoten.rtree.Selector;", "import com.github.davidmoten.rtree.Splitter;", "import com.github.davidmoten.rtree.geometry.Geometry;", "import com.github.davidmoten.rtree.geometry.HasGeometry;", "import com.github.davidmoten.rtree.geometry.Rectangle;"], "methods": [], "classes": [{"original_string": "public final class Comparators {\n\n    private Comparators() {\n        // prevent instantiation\n    }\n\n    public static <T extends HasGeometry> Comparator<HasGeometry> overlapAreaThenAreaIncreaseThenAreaComparator(\n            final Rectangle r, final List<T> list) {\n        return new Comparator<HasGeometry>() {\n\n            @Override\n            public int compare(HasGeometry g1, HasGeometry g2) {\n                int value = Double.compare(overlapArea(r, list, g1), overlapArea(r, list, g2));\n                if (value == 0) {\n                    value = Double.compare(areaIncrease(r, g1), areaIncrease(r, g2));\n                    if (value == 0) {\n                        value = Double.compare(area(r, g1), area(r, g2));\n                    }\n                }\n                return value;\n            }\n        };\n    }\n\n    private static double area(final Rectangle r, HasGeometry g1) {\n        return g1.geometry().mbr().add(r).area();\n    }\n\n    public static <T extends HasGeometry> Comparator<HasGeometry> areaIncreaseThenAreaComparator(\n            final Rectangle r) {\n        return new Comparator<HasGeometry>() {\n            @Override\n            public int compare(HasGeometry g1, HasGeometry g2) {\n                int value = Double.compare(areaIncrease(r, g1), areaIncrease(r, g2));\n                if (value == 0) {\n                    value = Double.compare(area(r, g1), area(r, g2));\n                }\n                return value;\n            }\n        };\n    }\n\n    private static float overlapArea(Rectangle r, List<? extends HasGeometry> list, HasGeometry g) {\n        Rectangle gPlusR = g.geometry().mbr().add(r);\n        float m = 0;\n        for (HasGeometry other : list) {\n            if (other != g) {\n                m += gPlusR.intersectionArea(other.geometry().mbr());\n            }\n        }\n        return m;\n    }\n\n    private static double areaIncrease(Rectangle r, HasGeometry g) {\n        Rectangle gPlusR = g.geometry().mbr().add(r);\n        return gPlusR.area() - g.geometry().mbr().area();\n    }\n\n    /**\n     * <p>\n     * Returns a comparator that can be used to sort entries returned by search\n     * methods. For example:\n     * </p>\n     * <p>\n     * <code>search(100).toSortedList(ascendingDistance(r))</code>\n     * </p>\n     * \n     * @param <T>\n     *            the value type\n     * @param <S>\n     *            the entry type\n     * @param r\n     *            rectangle to measure distance to\n     * @return a comparator to sort by ascending distance from the rectangle\n     */\n    public static <T, S extends Geometry> Comparator<Entry<T, S>> ascendingDistance(\n            final Rectangle r) {\n        return new Comparator<Entry<T, S>>() {\n            @Override\n            public int compare(Entry<T, S> e1, Entry<T, S> e2) {\n                return Double.compare(e1.geometry().distance(r), e2.geometry().distance(r));\n            }\n        };\n    }\n\n}", "definition": "public final class Comparators", "class_docstring": "\nUtility functions asociated with {@link Comparator}s, especially for use with\n{@link Selector}s and {@link Splitter}s.\n\n", "name": "Comparators", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    private Comparators() {\n        // prevent instantiation\n    }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "", "classes": []}, "name": "Comparators", "params": [], "body": "                          {\n        // prevent instantiation\n    }", "signature": "private Comparators()"}, {"syntax_pass": true, "original_string": "    public static <T extends HasGeometry> Comparator<HasGeometry> overlapAreaThenAreaIncreaseThenAreaComparator(\n            final Rectangle r, final List<T> list) {\n        return new Comparator<HasGeometry>() {\n\n            @Override\n            public int compare(HasGeometry g1, HasGeometry g2) {\n                int value = Double.compare(overlapArea(r, list, g1), overlapArea(r, list, g2));\n                if (value == 0) {\n                    value = Double.compare(areaIncrease(r, g1), areaIncrease(r, g2));\n                    if (value == 0) {\n                        value = Double.compare(area(r, g1), area(r, g2));\n                    }\n                }\n                return value;\n            }\n        };\n    }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Comparator<HasGeometry>", "classes": []}, "name": "overlapAreaThenAreaIncreaseThenAreaComparator", "params": [{"name": "r", "type": "Rectangle"}, {"name": "list", "type": "List<T>"}], "body": "                                                   {\n        return new Comparator<HasGeometry>() {\n\n            @Override\n            public int compare(HasGeometry g1, HasGeometry g2) {\n                int value = Double.compare(overlapArea(r, list, g1), overlapArea(r, list, g2));\n                if (value == 0) {\n                    value = Double.compare(areaIncrease(r, g1), areaIncrease(r, g2));\n                    if (value == 0) {\n                        value = Double.compare(area(r, g1), area(r, g2));\n                    }\n                }\n                return value;\n            }\n        };\n    }", "signature": "public static <T extends HasGeometry> Comparator<HasGeometry> overlapAreaThenAreaIncreaseThenAreaComparator(\n            final Rectangle r, final List<T> list)"}, {"syntax_pass": true, "original_string": "    private static double area(final Rectangle r, HasGeometry g1) {\n        return g1.geometry().mbr().add(r).area();\n    }", "docstring": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "double", "classes": []}, "name": "area", "params": [{"name": "r", "type": "Rectangle"}, {"name": "g1", "type": "HasGeometry"}], "body": "                                                                  {\n        return g1.geometry().mbr().add(r).area();\n    }", "signature": "private static double area(final Rectangle r, HasGeometry g1)"}, {"syntax_pass": true, "original_string": "    public static <T extends HasGeometry> Comparator<HasGeometry> areaIncreaseThenAreaComparator(\n            final Rectangle r) {\n        return new Comparator<HasGeometry>() {\n            @Override\n            public int compare(HasGeometry g1, HasGeometry g2) {\n                int value = Double.compare(areaIncrease(r, g1), areaIncrease(r, g2));\n                if (value == 0) {\n                    value = Double.compare(area(r, g1), area(r, g2));\n                }\n                return value;\n            }\n        };\n    }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Comparator<HasGeometry>", "classes": []}, "name": "areaIncreaseThenAreaComparator", "params": [{"name": "r", "type": "Rectangle"}], "body": "                               {\n        return new Comparator<HasGeometry>() {\n            @Override\n            public int compare(HasGeometry g1, HasGeometry g2) {\n                int value = Double.compare(areaIncrease(r, g1), areaIncrease(r, g2));\n                if (value == 0) {\n                    value = Double.compare(area(r, g1), area(r, g2));\n                }\n                return value;\n            }\n        };\n    }", "signature": "public static <T extends HasGeometry> Comparator<HasGeometry> areaIncreaseThenAreaComparator(\n            final Rectangle r)"}, {"syntax_pass": true, "original_string": "    private static float overlapArea(Rectangle r, List<? extends HasGeometry> list, HasGeometry g) {\n        Rectangle gPlusR = g.geometry().mbr().add(r);\n        float m = 0;\n        for (HasGeometry other : list) {\n            if (other != g) {\n                m += gPlusR.intersectionArea(other.geometry().mbr());\n            }\n        }\n        return m;\n    }", "docstring": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "float", "classes": []}, "name": "overlapArea", "params": [{"name": "r", "type": "Rectangle"}, {"name": "list", "type": "List<? extends HasGeometry>"}, {"name": "g", "type": "HasGeometry"}], "body": "                                                                                                   {\n        Rectangle gPlusR = g.geometry().mbr().add(r);\n        float m = 0;\n        for (HasGeometry other : list) {\n            if (other != g) {\n                m += gPlusR.intersectionArea(other.geometry().mbr());\n            }\n        }\n        return m;\n    }", "signature": "private static float overlapArea(Rectangle r, List<? extends HasGeometry> list, HasGeometry g)"}, {"syntax_pass": true, "original_string": "    private static double areaIncrease(Rectangle r, HasGeometry g) {\n        Rectangle gPlusR = g.geometry().mbr().add(r);\n        return gPlusR.area() - g.geometry().mbr().area();\n    }", "docstring": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "double", "classes": []}, "name": "areaIncrease", "params": [{"name": "r", "type": "Rectangle"}, {"name": "g", "type": "HasGeometry"}], "body": "                                                                   {\n        Rectangle gPlusR = g.geometry().mbr().add(r);\n        return gPlusR.area() - g.geometry().mbr().area();\n    }", "signature": "private static double areaIncrease(Rectangle r, HasGeometry g)"}, {"syntax_pass": true, "original_string": "    public static <T, S extends Geometry> Comparator<Entry<T, S>> ascendingDistance(\n            final Rectangle r) {\n        return new Comparator<Entry<T, S>>() {\n            @Override\n            public int compare(Entry<T, S> e1, Entry<T, S> e2) {\n                return Double.compare(e1.geometry().distance(r), e2.geometry().distance(r));\n            }\n        };\n    }", "docstring": "\n<p>\nReturns a comparator that can be used to sort entries returned by search\nmethods. For example:\n</p>\n<p>\n<code>search(100).toSortedList(ascendingDistance(r))</code>\n</p>\n\n@param <T>\n           the value type\n@param <S>\n           the entry type\n@param r\n           rectangle to measure distance to\n@return a comparator to sort by ascending distance from the rectangle\n", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Comparator<Entry<T, S>>", "classes": []}, "name": "ascendingDistance", "params": [{"name": "r", "type": "Rectangle"}], "body": "                               {\n        return new Comparator<Entry<T, S>>() {\n            @Override\n            public int compare(Entry<T, S> e1, Entry<T, S> e2) {\n                return Double.compare(e1.geometry().distance(r), e2.geometry().distance(r));\n            }\n        };\n    }", "signature": "public static <T, S extends Geometry> Comparator<Entry<T, S>> ascendingDistance(\n            final Rectangle r)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/com/github/davidmoten/rtree/internal/NonLeafHelper.java", "original_string": "package com.github.davidmoten.rtree.internal;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Optional;\n\nimport com.github.davidmoten.rtree.Context;\nimport com.github.davidmoten.rtree.Entry;\nimport com.github.davidmoten.rtree.Node;\nimport com.github.davidmoten.rtree.NonLeaf;\nimport com.github.davidmoten.rtree.geometry.Geometry;\nimport com.github.davidmoten.rtree.geometry.ListPair;\n\nimport rx.Subscriber;\nimport rx.functions.Func1;\n\nimport static java.util.Optional.of;\n\npublic final class NonLeafHelper {\n\n    private NonLeafHelper() {\n        // prevent instantiation\n    }\n\n    public static <T, S extends Geometry> void search(Func1<? super Geometry, Boolean> criterion,\n            Subscriber<? super Entry<T, S>> subscriber, NonLeaf<T, S> node) {\n        if (!criterion.call(node.geometry().mbr()))\n            return;\n\n        int numChildren = node.count();\n        for (int i = 0; i < numChildren; i++) {\n            if (subscriber.isUnsubscribed()) {\n                return;\n            } else {\n                Node<T, S> child = node.child(i);\n                child.searchWithoutBackpressure(criterion, subscriber);\n            }\n        }\n    }\n\n    public static <T, S extends Geometry> List<Node<T, S>> add(\n            Entry<? extends T, ? extends S> entry, NonLeaf<T, S> node) {\n        Context<T, S> context = node.context();\n        List<Node<T, S>> children = node.children();\n        final Node<T, S> child = context.selector().select(entry.geometry().mbr(), children);\n        List<Node<T, S>> list = child.add(entry);\n        List<? extends Node<T, S>> children2 = Util.replace(children, child, list);\n        if (children2.size() <= context.maxChildren())\n            return Collections.singletonList(\n                    (Node<T, S>) context.factory().createNonLeaf(children2, context));\n        else {\n            ListPair<? extends Node<T, S>> pair = context.splitter().split(children2,\n                    context.minChildren());\n            return makeNonLeaves(pair, context);\n        }\n    }\n\n    private static <T, S extends Geometry> List<Node<T, S>> makeNonLeaves(\n            ListPair<? extends Node<T, S>> pair, Context<T, S> context) {\n        List<Node<T, S>> list = new ArrayList<Node<T, S>>();\n        list.add(context.factory().createNonLeaf(pair.group1().list(), context));\n        list.add(context.factory().createNonLeaf(pair.group2().list(), context));\n        return list;\n    }\n\n    public static <T, S extends Geometry> NodeAndEntries<T, S> delete(\n            Entry<? extends T, ? extends S> entry, boolean all, NonLeaf<T, S> node) {\n        // the result of performing a delete of the given entry from this node\n        // will be that zero or more entries will be needed to be added back to\n        // the root of the tree (because num entries of their node fell below\n        // minChildren),\n        // zero or more children will need to be removed from this node,\n        // zero or more nodes to be added as children to this node(because\n        // entries have been deleted from them and they still have enough\n        // members to be active)\n        List<Entry<T, S>> addTheseEntries = new ArrayList<Entry<T, S>>();\n        List<Node<T, S>> removeTheseNodes = new ArrayList<Node<T, S>>();\n        List<Node<T, S>> addTheseNodes = new ArrayList<Node<T, S>>();\n        int countDeleted = 0;\n        List<? extends Node<T, S>> children = node.children();\n        for (final Node<T, S> child : children) {\n            if (entry.geometry().intersects(child.geometry().mbr())) {\n                final NodeAndEntries<T, S> result = child.delete(entry, all);\n                if (result.node().isPresent()) {\n                    if (result.node().get() != child) {\n                        // deletion occurred and child is above minChildren so\n                        // we update it\n                        addTheseNodes.add(result.node().get());\n                        removeTheseNodes.add(child);\n                        addTheseEntries.addAll(result.entriesToAdd());\n                        countDeleted += result.countDeleted();\n                        if (!all)\n                            break;\n                    }\n                    // else nothing was deleted from that child\n                } else {\n                    // deletion occurred and brought child below minChildren\n                    // so we redistribute its entries\n                    removeTheseNodes.add(child);\n                    addTheseEntries.addAll(result.entriesToAdd());\n                    countDeleted += result.countDeleted();\n                    if (!all)\n                        break;\n                }\n            }\n        }\n        if (removeTheseNodes.isEmpty())\n            return new NodeAndEntries<>(of(node), Collections.emptyList(), 0);\n        else {\n            List<Node<T, S>> nodes = Util.remove(children, removeTheseNodes);\n            nodes.addAll(addTheseNodes);\n            if (nodes.isEmpty())\n                return new NodeAndEntries<>(Optional.empty(), addTheseEntries,\n                        countDeleted);\n            else {\n                NonLeaf<T, S> nd = node.context().factory().createNonLeaf(nodes, node.context());\n                return new NodeAndEntries<>(of(nd), addTheseEntries, countDeleted);\n            }\n        }\n    }\n\n}\n", "file_hash": "44666c07a0f74eff604440ca7f0e798e04e8a6067dbb8da5f814e737d144d906", "file_docstring": "", "contexts": ["package com.github.davidmoten.rtree.internal;", "import java.util.ArrayList;", "import java.util.Collections;", "import java.util.List;", "import java.util.Optional;", "import com.github.davidmoten.rtree.Context;", "import com.github.davidmoten.rtree.Entry;", "import com.github.davidmoten.rtree.Node;", "import com.github.davidmoten.rtree.NonLeaf;", "import com.github.davidmoten.rtree.geometry.Geometry;", "import com.github.davidmoten.rtree.geometry.ListPair;", "import rx.Subscriber;", "import rx.functions.Func1;", "import static java.util.Optional.of;"], "methods": [], "classes": [{"original_string": "public final class NonLeafHelper {\n\n    private NonLeafHelper() {\n        // prevent instantiation\n    }\n\n    public static <T, S extends Geometry> void search(Func1<? super Geometry, Boolean> criterion,\n            Subscriber<? super Entry<T, S>> subscriber, NonLeaf<T, S> node) {\n        if (!criterion.call(node.geometry().mbr()))\n            return;\n\n        int numChildren = node.count();\n        for (int i = 0; i < numChildren; i++) {\n            if (subscriber.isUnsubscribed()) {\n                return;\n            } else {\n                Node<T, S> child = node.child(i);\n                child.searchWithoutBackpressure(criterion, subscriber);\n            }\n        }\n    }\n\n    public static <T, S extends Geometry> List<Node<T, S>> add(\n            Entry<? extends T, ? extends S> entry, NonLeaf<T, S> node) {\n        Context<T, S> context = node.context();\n        List<Node<T, S>> children = node.children();\n        final Node<T, S> child = context.selector().select(entry.geometry().mbr(), children);\n        List<Node<T, S>> list = child.add(entry);\n        List<? extends Node<T, S>> children2 = Util.replace(children, child, list);\n        if (children2.size() <= context.maxChildren())\n            return Collections.singletonList(\n                    (Node<T, S>) context.factory().createNonLeaf(children2, context));\n        else {\n            ListPair<? extends Node<T, S>> pair = context.splitter().split(children2,\n                    context.minChildren());\n            return makeNonLeaves(pair, context);\n        }\n    }\n\n    private static <T, S extends Geometry> List<Node<T, S>> makeNonLeaves(\n            ListPair<? extends Node<T, S>> pair, Context<T, S> context) {\n        List<Node<T, S>> list = new ArrayList<Node<T, S>>();\n        list.add(context.factory().createNonLeaf(pair.group1().list(), context));\n        list.add(context.factory().createNonLeaf(pair.group2().list(), context));\n        return list;\n    }\n\n    public static <T, S extends Geometry> NodeAndEntries<T, S> delete(\n            Entry<? extends T, ? extends S> entry, boolean all, NonLeaf<T, S> node) {\n        // the result of performing a delete of the given entry from this node\n        // will be that zero or more entries will be needed to be added back to\n        // the root of the tree (because num entries of their node fell below\n        // minChildren),\n        // zero or more children will need to be removed from this node,\n        // zero or more nodes to be added as children to this node(because\n        // entries have been deleted from them and they still have enough\n        // members to be active)\n        List<Entry<T, S>> addTheseEntries = new ArrayList<Entry<T, S>>();\n        List<Node<T, S>> removeTheseNodes = new ArrayList<Node<T, S>>();\n        List<Node<T, S>> addTheseNodes = new ArrayList<Node<T, S>>();\n        int countDeleted = 0;\n        List<? extends Node<T, S>> children = node.children();\n        for (final Node<T, S> child : children) {\n            if (entry.geometry().intersects(child.geometry().mbr())) {\n                final NodeAndEntries<T, S> result = child.delete(entry, all);\n                if (result.node().isPresent()) {\n                    if (result.node().get() != child) {\n                        // deletion occurred and child is above minChildren so\n                        // we update it\n                        addTheseNodes.add(result.node().get());\n                        removeTheseNodes.add(child);\n                        addTheseEntries.addAll(result.entriesToAdd());\n                        countDeleted += result.countDeleted();\n                        if (!all)\n                            break;\n                    }\n                    // else nothing was deleted from that child\n                } else {\n                    // deletion occurred and brought child below minChildren\n                    // so we redistribute its entries\n                    removeTheseNodes.add(child);\n                    addTheseEntries.addAll(result.entriesToAdd());\n                    countDeleted += result.countDeleted();\n                    if (!all)\n                        break;\n                }\n            }\n        }\n        if (removeTheseNodes.isEmpty())\n            return new NodeAndEntries<>(of(node), Collections.emptyList(), 0);\n        else {\n            List<Node<T, S>> nodes = Util.remove(children, removeTheseNodes);\n            nodes.addAll(addTheseNodes);\n            if (nodes.isEmpty())\n                return new NodeAndEntries<>(Optional.empty(), addTheseEntries,\n                        countDeleted);\n            else {\n                NonLeaf<T, S> nd = node.context().factory().createNonLeaf(nodes, node.context());\n                return new NodeAndEntries<>(of(nd), addTheseEntries, countDeleted);\n            }\n        }\n    }\n\n}", "definition": "public final class NonLeafHelper", "class_docstring": "", "name": "NonLeafHelper", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    private NonLeafHelper() {\n        // prevent instantiation\n    }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "", "classes": []}, "name": "NonLeafHelper", "params": [], "body": "                            {\n        // prevent instantiation\n    }", "signature": "private NonLeafHelper()"}, {"syntax_pass": true, "original_string": "    public static <T, S extends Geometry> void search(Func1<? super Geometry, Boolean> criterion,\n            Subscriber<? super Entry<T, S>> subscriber, NonLeaf<T, S> node) {\n        if (!criterion.call(node.geometry().mbr()))\n            return;\n\n        int numChildren = node.count();\n        for (int i = 0; i < numChildren; i++) {\n            if (subscriber.isUnsubscribed()) {\n                return;\n            } else {\n                Node<T, S> child = node.child(i);\n                child.searchWithoutBackpressure(criterion, subscriber);\n            }\n        }\n    }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "void", "classes": []}, "name": "search", "params": [{"name": "criterion", "type": "Func1<? super Geometry, Boolean>"}, {"name": "subscriber", "type": "Subscriber<? super Entry<T, S>>"}, {"name": "node", "type": "NonLeaf<T, S>"}], "body": "                                                                            {\n        if (!criterion.call(node.geometry().mbr()))\n            return;\n\n        int numChildren = node.count();\n        for (int i = 0; i < numChildren; i++) {\n            if (subscriber.isUnsubscribed()) {\n                return;\n            } else {\n                Node<T, S> child = node.child(i);\n                child.searchWithoutBackpressure(criterion, subscriber);\n            }\n        }\n    }", "signature": "public static <T, S extends Geometry> void search(Func1<? super Geometry, Boolean> criterion,\n            Subscriber<? super Entry<T, S>> subscriber, NonLeaf<T, S> node)"}, {"syntax_pass": true, "original_string": "    public static <T, S extends Geometry> List<Node<T, S>> add(\n            Entry<? extends T, ? extends S> entry, NonLeaf<T, S> node) {\n        Context<T, S> context = node.context();\n        List<Node<T, S>> children = node.children();\n        final Node<T, S> child = context.selector().select(entry.geometry().mbr(), children);\n        List<Node<T, S>> list = child.add(entry);\n        List<? extends Node<T, S>> children2 = Util.replace(children, child, list);\n        if (children2.size() <= context.maxChildren())\n            return Collections.singletonList(\n                    (Node<T, S>) context.factory().createNonLeaf(children2, context));\n        else {\n            ListPair<? extends Node<T, S>> pair = context.splitter().split(children2,\n                    context.minChildren());\n            return makeNonLeaves(pair, context);\n        }\n    }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "List<Node<T, S>>", "classes": []}, "name": "add", "params": [{"name": "entry", "type": "Entry<? extends T, ? extends S>"}, {"name": "node", "type": "NonLeaf<T, S>"}], "body": "                                                                       {\n        Context<T, S> context = node.context();\n        List<Node<T, S>> children = node.children();\n        final Node<T, S> child = context.selector().select(entry.geometry().mbr(), children);\n        List<Node<T, S>> list = child.add(entry);\n        List<? extends Node<T, S>> children2 = Util.replace(children, child, list);\n        if (children2.size() <= context.maxChildren())\n            return Collections.singletonList(\n                    (Node<T, S>) context.factory().createNonLeaf(children2, context));\n        else {\n            ListPair<? extends Node<T, S>> pair = context.splitter().split(children2,\n                    context.minChildren());\n            return makeNonLeaves(pair, context);\n        }\n    }", "signature": "public static <T, S extends Geometry> List<Node<T, S>> add(\n            Entry<? extends T, ? extends S> entry, NonLeaf<T, S> node)"}, {"syntax_pass": true, "original_string": "    private static <T, S extends Geometry> List<Node<T, S>> makeNonLeaves(\n            ListPair<? extends Node<T, S>> pair, Context<T, S> context) {\n        List<Node<T, S>> list = new ArrayList<Node<T, S>>();\n        list.add(context.factory().createNonLeaf(pair.group1().list(), context));\n        list.add(context.factory().createNonLeaf(pair.group2().list(), context));\n        return list;\n    }", "docstring": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "List<Node<T, S>>", "classes": []}, "name": "makeNonLeaves", "params": [{"name": "pair", "type": "ListPair<? extends Node<T, S>>"}, {"name": "context", "type": "Context<T, S>"}], "body": "                                                                        {\n        List<Node<T, S>> list = new ArrayList<Node<T, S>>();\n        list.add(context.factory().createNonLeaf(pair.group1().list(), context));\n        list.add(context.factory().createNonLeaf(pair.group2().list(), context));\n        return list;\n    }", "signature": "private static <T, S extends Geometry> List<Node<T, S>> makeNonLeaves(\n            ListPair<? extends Node<T, S>> pair, Context<T, S> context)"}, {"syntax_pass": true, "original_string": "    public static <T, S extends Geometry> NodeAndEntries<T, S> delete(\n            Entry<? extends T, ? extends S> entry, boolean all, NonLeaf<T, S> node) {\n        // the result of performing a delete of the given entry from this node\n        // will be that zero or more entries will be needed to be added back to\n        // the root of the tree (because num entries of their node fell below\n        // minChildren),\n        // zero or more children will need to be removed from this node,\n        // zero or more nodes to be added as children to this node(because\n        // entries have been deleted from them and they still have enough\n        // members to be active)\n        List<Entry<T, S>> addTheseEntries = new ArrayList<Entry<T, S>>();\n        List<Node<T, S>> removeTheseNodes = new ArrayList<Node<T, S>>();\n        List<Node<T, S>> addTheseNodes = new ArrayList<Node<T, S>>();\n        int countDeleted = 0;\n        List<? extends Node<T, S>> children = node.children();\n        for (final Node<T, S> child : children) {\n            if (entry.geometry().intersects(child.geometry().mbr())) {\n                final NodeAndEntries<T, S> result = child.delete(entry, all);\n                if (result.node().isPresent()) {\n                    if (result.node().get() != child) {\n                        // deletion occurred and child is above minChildren so\n                        // we update it\n                        addTheseNodes.add(result.node().get());\n                        removeTheseNodes.add(child);\n                        addTheseEntries.addAll(result.entriesToAdd());\n                        countDeleted += result.countDeleted();\n                        if (!all)\n                            break;\n                    }\n                    // else nothing was deleted from that child\n                } else {\n                    // deletion occurred and brought child below minChildren\n                    // so we redistribute its entries\n                    removeTheseNodes.add(child);\n                    addTheseEntries.addAll(result.entriesToAdd());\n                    countDeleted += result.countDeleted();\n                    if (!all)\n                        break;\n                }\n            }\n        }\n        if (removeTheseNodes.isEmpty())\n            return new NodeAndEntries<>(of(node), Collections.emptyList(), 0);\n        else {\n            List<Node<T, S>> nodes = Util.remove(children, removeTheseNodes);\n            nodes.addAll(addTheseNodes);\n            if (nodes.isEmpty())\n                return new NodeAndEntries<>(Optional.empty(), addTheseEntries,\n                        countDeleted);\n            else {\n                NonLeaf<T, S> nd = node.context().factory().createNonLeaf(nodes, node.context());\n                return new NodeAndEntries<>(of(nd), addTheseEntries, countDeleted);\n            }\n        }\n    }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "NodeAndEntries<T, S>", "classes": []}, "name": "delete", "params": [{"name": "entry", "type": "Entry<? extends T, ? extends S>"}, {"name": "all", "type": "boolean"}, {"name": "node", "type": "NonLeaf<T, S>"}], "body": "                                                                                    {\n        // the result of performing a delete of the given entry from this node\n        // will be that zero or more entries will be needed to be added back to\n        // the root of the tree (because num entries of their node fell below\n        // minChildren),\n        // zero or more children will need to be removed from this node,\n        // zero or more nodes to be added as children to this node(because\n        // entries have been deleted from them and they still have enough\n        // members to be active)\n        List<Entry<T, S>> addTheseEntries = new ArrayList<Entry<T, S>>();\n        List<Node<T, S>> removeTheseNodes = new ArrayList<Node<T, S>>();\n        List<Node<T, S>> addTheseNodes = new ArrayList<Node<T, S>>();\n        int countDeleted = 0;\n        List<? extends Node<T, S>> children = node.children();\n        for (final Node<T, S> child : children) {\n            if (entry.geometry().intersects(child.geometry().mbr())) {\n                final NodeAndEntries<T, S> result = child.delete(entry, all);\n                if (result.node().isPresent()) {\n                    if (result.node().get() != child) {\n                        // deletion occurred and child is above minChildren so\n                        // we update it\n                        addTheseNodes.add(result.node().get());\n                        removeTheseNodes.add(child);\n                        addTheseEntries.addAll(result.entriesToAdd());\n                        countDeleted += result.countDeleted();\n                        if (!all)\n                            break;\n                    }\n                    // else nothing was deleted from that child\n                } else {\n                    // deletion occurred and brought child below minChildren\n                    // so we redistribute its entries\n                    removeTheseNodes.add(child);\n                    addTheseEntries.addAll(result.entriesToAdd());\n                    countDeleted += result.countDeleted();\n                    if (!all)\n                        break;\n                }\n            }\n        }\n        if (removeTheseNodes.isEmpty())\n            return new NodeAndEntries<>(of(node), Collections.emptyList(), 0);\n        else {\n            List<Node<T, S>> nodes = Util.remove(children, removeTheseNodes);\n            nodes.addAll(addTheseNodes);\n            if (nodes.isEmpty())\n                return new NodeAndEntries<>(Optional.empty(), addTheseEntries,\n                        countDeleted);\n            else {\n                NonLeaf<T, S> nd = node.context().factory().createNonLeaf(nodes, node.context());\n                return new NodeAndEntries<>(of(nd), addTheseEntries, countDeleted);\n            }\n        }\n    }", "signature": "public static <T, S extends Geometry> NodeAndEntries<T, S> delete(\n            Entry<? extends T, ? extends S> entry, boolean all, NonLeaf<T, S> node)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/com/github/davidmoten/rtree/internal/EntryDefault.java", "original_string": "package com.github.davidmoten.rtree.internal;\n\nimport com.github.davidmoten.guavamini.Preconditions;\nimport com.github.davidmoten.rtree.Entry;\nimport com.github.davidmoten.rtree.geometry.Geometry;\nimport com.github.davidmoten.rtree.internal.util.ObjectsHelper;\n\nimport java.util.Objects;\nimport java.util.Optional;\n\n/**\n * An entry in the R-tree which has a spatial representation.\n * \n * @param <T>\n *            value type\n * @param <S>\n *            geometry type\n */\npublic final class EntryDefault<T, S extends Geometry> implements Entry<T, S> {\n    private final T value;\n    private final S geometry;\n\n    /**\n     * Constructor.\n     * \n     * @param value\n     *            the value of the entry\n     * @param geometry\n     *            the geometry of the value\n     */\n    public EntryDefault(T value, S geometry) {\n        Preconditions.checkNotNull(geometry);\n        this.value = value;\n        this.geometry = geometry;\n    }\n\n    /**\n     * Factory method.\n     * \n     * @param <T>\n     *            type of value\n     * @param <S>\n     *            type of geometry\n     * @param value\n     *            object being given a spatial context\n     * @param geometry\n     *            geometry associated with the value\n     * @return entry wrapping value and associated geometry\n     */\n    public static <T, S extends Geometry> Entry<T, S> entry(T value, S geometry) {\n        return new EntryDefault<T, S>(value, geometry);\n    }\n\n    /**\n     * Returns the value wrapped by this {@link EntryDefault}.\n     * \n     * @return the entry value\n     */\n    @Override\n    public T value() {\n        return value;\n    }\n\n    @Override\n    public S geometry() {\n        return geometry;\n    }\n\n    @Override\n    public String toString() {\n        String builder = \"Entry [value=\" + value + \", geometry=\" + geometry + \"]\";\n        return builder;\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(value, geometry);\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        @SuppressWarnings(\"rawtypes\")\n        Optional<EntryDefault> other = ObjectsHelper.asClass(obj, EntryDefault.class);\n        if (other.isPresent()) {\n            return Objects.equals(value, other.get().value)\n                    && Objects.equals(geometry, other.get().geometry);\n        } else\n            return false;\n    }\n\n}\n", "file_hash": "ad57d8dce3aaa45c6e12fb61fb786cad1670427b6497ec4f154046ce3ffa848d", "file_docstring": "", "contexts": ["package com.github.davidmoten.rtree.internal;", "import com.github.davidmoten.guavamini.Preconditions;", "import com.github.davidmoten.rtree.Entry;", "import com.github.davidmoten.rtree.geometry.Geometry;", "import com.github.davidmoten.rtree.internal.util.ObjectsHelper;", "import java.util.Objects;", "import java.util.Optional;"], "methods": [], "classes": [{"original_string": "public final class EntryDefault<T, S extends Geometry> implements Entry<T, S> {\n    private final T value;\n    private final S geometry;\n\n    /**\n     * Constructor.\n     * \n     * @param value\n     *            the value of the entry\n     * @param geometry\n     *            the geometry of the value\n     */\n    public EntryDefault(T value, S geometry) {\n        Preconditions.checkNotNull(geometry);\n        this.value = value;\n        this.geometry = geometry;\n    }\n\n    /**\n     * Factory method.\n     * \n     * @param <T>\n     *            type of value\n     * @param <S>\n     *            type of geometry\n     * @param value\n     *            object being given a spatial context\n     * @param geometry\n     *            geometry associated with the value\n     * @return entry wrapping value and associated geometry\n     */\n    public static <T, S extends Geometry> Entry<T, S> entry(T value, S geometry) {\n        return new EntryDefault<T, S>(value, geometry);\n    }\n\n    /**\n     * Returns the value wrapped by this {@link EntryDefault}.\n     * \n     * @return the entry value\n     */\n    @Override\n    public T value() {\n        return value;\n    }\n\n    @Override\n    public S geometry() {\n        return geometry;\n    }\n\n    @Override\n    public String toString() {\n        String builder = \"Entry [value=\" + value + \", geometry=\" + geometry + \"]\";\n        return builder;\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(value, geometry);\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        @SuppressWarnings(\"rawtypes\")\n        Optional<EntryDefault> other = ObjectsHelper.asClass(obj, EntryDefault.class);\n        if (other.isPresent()) {\n            return Objects.equals(value, other.get().value)\n                    && Objects.equals(geometry, other.get().geometry);\n        } else\n            return false;\n    }\n\n}", "definition": "public final class EntryDefault<T, S extends Geometry> implements Entry<T, S>", "class_docstring": "\nAn entry in the R-tree which has a spatial representation.\n\n@param <T>\n           value type\n@param <S>\n           geometry type\n", "name": "EntryDefault", "super_interfaces": ["Entry<T, S>"], "superclasses": "", "attributes": {"modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "fields": [{"attribute_expression": "private final T value;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "T", "name": "value", "syntax_pass": true}, {"attribute_expression": "private final S geometry;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "S", "name": "geometry", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    public EntryDefault(T value, S geometry) {\n        Preconditions.checkNotNull(geometry);\n        this.value = value;\n        this.geometry = geometry;\n    }", "docstring": "\nConstructor.\n\n@param value\n           the value of the entry\n@param geometry\n           the geometry of the value\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "EntryDefault", "params": [{"name": "value", "type": "T"}, {"name": "geometry", "type": "S"}], "body": "                                             {\n        Preconditions.checkNotNull(geometry);\n        this.value = value;\n        this.geometry = geometry;\n    }", "signature": "public EntryDefault(T value, S geometry)"}, {"syntax_pass": true, "original_string": "    public static <T, S extends Geometry> Entry<T, S> entry(T value, S geometry) {\n        return new EntryDefault<T, S>(value, geometry);\n    }", "docstring": "\nFactory method.\n\n@param <T>\n           type of value\n@param <S>\n           type of geometry\n@param value\n           object being given a spatial context\n@param geometry\n           geometry associated with the value\n@return entry wrapping value and associated geometry\n", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Entry<T, S>", "classes": []}, "name": "entry", "params": [{"name": "value", "type": "T"}, {"name": "geometry", "type": "S"}], "body": "                                                                                 {\n        return new EntryDefault<T, S>(value, geometry);\n    }", "signature": "public static <T, S extends Geometry> Entry<T, S> entry(T value, S geometry)"}, {"syntax_pass": true, "original_string": "    @Override\n    public T value() {\n        return value;\n    }", "docstring": "\nReturns the value wrapped by this {@link EntryDefault}.\n\n@return the entry value\n", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "T", "classes": []}, "name": "value", "params": [], "body": "                     {\n        return value;\n    }", "signature": "@Override\n    public T value()"}, {"syntax_pass": true, "original_string": "    @Override\n    public S geometry() {\n        return geometry;\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "S", "classes": []}, "name": "geometry", "params": [], "body": "                        {\n        return geometry;\n    }", "signature": "@Override\n    public S geometry()"}, {"syntax_pass": true, "original_string": "    @Override\n    public String toString() {\n        String builder = \"Entry [value=\" + value + \", geometry=\" + geometry + \"]\";\n        return builder;\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "toString", "params": [], "body": "                             {\n        String builder = \"Entry [value=\" + value + \", geometry=\" + geometry + \"]\";\n        return builder;\n    }", "signature": "@Override\n    public String toString()"}, {"syntax_pass": true, "original_string": "    @Override\n    public int hashCode() {\n        return Objects.hash(value, geometry);\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "hashCode", "params": [], "body": "                          {\n        return Objects.hash(value, geometry);\n    }", "signature": "@Override\n    public int hashCode()"}, {"syntax_pass": true, "original_string": "    @Override\n    public boolean equals(Object obj) {\n        @SuppressWarnings(\"rawtypes\")\n        Optional<EntryDefault> other = ObjectsHelper.asClass(obj, EntryDefault.class);\n        if (other.isPresent()) {\n            return Objects.equals(value, other.get().value)\n                    && Objects.equals(geometry, other.get().geometry);\n        } else\n            return false;\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "equals", "params": [{"name": "obj", "type": "Object"}], "body": "                                      {\n        @SuppressWarnings(\"rawtypes\")\n        Optional<EntryDefault> other = ObjectsHelper.asClass(obj, EntryDefault.class);\n        if (other.isPresent()) {\n            return Objects.equals(value, other.get().value)\n                    && Objects.equals(geometry, other.get().geometry);\n        } else\n            return false;\n    }", "signature": "@Override\n    public boolean equals(Object obj)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/com/github/davidmoten/rtree/internal/RectangleUtil.java", "original_string": "package com.github.davidmoten.rtree.internal;\n\npublic final class RectangleUtil {\n\n    private RectangleUtil() {\n        // prevent instantiation\n    }\n\n    /**\n     * The bitmask that indicates that a point lies to the left of this\n     * <code>Rectangle2D</code>.\n     * \n     * @since 1.2\n     */\n    public static final int OUT_LEFT = 1;\n\n    /**\n     * The bitmask that indicates that a point lies above this\n     * <code>Rectangle2D</code>.\n     * \n     * @since 1.2\n     */\n    public static final int OUT_TOP = 2;\n\n    /**\n     * The bitmask that indicates that a point lies to the right of this\n     * <code>Rectangle2D</code>.\n     * \n     * @since 1.2\n     */\n    public static final int OUT_RIGHT = 4;\n\n    /**\n     * The bitmask that indicates that a point lies below this\n     * <code>Rectangle2D</code>.\n     * \n     * @since 1.2\n     */\n    public static final int OUT_BOTTOM = 8;\n    \n    public static boolean rectangleIntersectsLine(double rectX, double rectY, double rectWidth, double rectHeight,\n            double x1, double y1, double x2, double y2) {\n        return _rectangleIntersectsLine(rectX, rectY, rectWidth, rectHeight, x1, y1, x2, y2)\n                || Line2D.linesIntersect(rectX, rectY, rectX + rectWidth, rectY + rectHeight, x1, y1, x2, y2);\n    }\n    \n    private static boolean _rectangleIntersectsLine(double rectX, double rectY, double rectWidth,\n            double rectHeight, double x1, double y1, double x2, double y2) {\n        if (rectangleCornerOnSegment(rectX, rectY, rectWidth, rectHeight, x1, y1, x2, y2)) {\n            return true;\n        }\n        int out1, out2;\n        if ((out2 = outcode(rectX, rectY, rectWidth, rectHeight, x2, y2)) == 0) {\n            return true;\n        }\n        while ((out1 = outcode(rectX, rectY, rectWidth, rectHeight, x1, y1)) != 0) {\n            if ((out1 & out2) != 0) {\n                return false;\n            }\n            if ((out1 & (OUT_LEFT | OUT_RIGHT)) != 0) {\n                double x = rectX;\n                if ((out1 & OUT_RIGHT) != 0) {\n                    x += rectWidth;\n                }\n                y1 = y1 + (x - x1) * (y2 - y1) / (x2 - x1);\n                x1 = x;\n            } else {\n                double y = rectY;\n                if ((out1 & OUT_BOTTOM) != 0) {\n                    y += rectHeight;\n                }\n                x1 = x1 + (y - y1) * (x2 - x1) / (y2 - y1);\n                y1 = y;\n            }\n        }\n        return true;\n    }\n\n    private static boolean rectangleCornerOnSegment(double rectX, double rectY, double rectWidth,\n            double rectHeight, double x1, double y1, double x2, double y2) {\n        if (pointOnSegment(rectX, rectY, x1, y1, x2, y2)) {\n            return true;\n        } else if (pointOnSegment(rectX + rectWidth, rectY, x1, y1, x2, y2)) {\n            return true;\n        } else if (pointOnSegment(rectX, rectY + rectHeight, x1, y1, x2, y2)) {\n            return true;\n        } else if (pointOnSegment(rectX + rectWidth, rectY + rectHeight, x1, y1, x2, y2)) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    private static final double PRECISION = 0.00000001;\n\n    private static boolean pointOnSegment(double x, double y, double x1, double y1, double x2,\n            double y2) {\n        if (x < x1 || x > x2 || y < y1 || y > y2) {\n            return false;\n        } else {\n            double v = (y2 - y1) * (x - x1) - (x2 - x1) * (y - y1);\n            return Math.abs(v) < PRECISION;\n        }\n    }\n\n    private static int outcode(double rectX, double rectY, double rectWidth, double rectHeight,\n            double x, double y) {\n        int out = 0;\n        if (rectWidth <= 0) {\n            out |= OUT_LEFT | OUT_RIGHT;\n        } else if (x < rectX) {\n            out |= OUT_LEFT;\n        } else if (x > rectX + rectWidth) {\n            out |= OUT_RIGHT;\n        }\n        if (rectHeight <= 0) {\n            out |= OUT_TOP | OUT_BOTTOM;\n        } else if (y < rectY) {\n            out |= OUT_TOP;\n        } else if (y > rectY + rectHeight) {\n            out |= OUT_BOTTOM;\n        }\n        return out;\n    }\n\n}\n", "file_hash": "c3f2275f27383927923260770c043cc89687acd19c749b8e2f9e22c5c329fc10", "file_docstring": "", "contexts": ["package com.github.davidmoten.rtree.internal;"], "methods": [], "classes": [{"original_string": "public final class RectangleUtil {\n\n    private RectangleUtil() {\n        // prevent instantiation\n    }\n\n    /**\n     * The bitmask that indicates that a point lies to the left of this\n     * <code>Rectangle2D</code>.\n     * \n     * @since 1.2\n     */\n    public static final int OUT_LEFT = 1;\n\n    /**\n     * The bitmask that indicates that a point lies above this\n     * <code>Rectangle2D</code>.\n     * \n     * @since 1.2\n     */\n    public static final int OUT_TOP = 2;\n\n    /**\n     * The bitmask that indicates that a point lies to the right of this\n     * <code>Rectangle2D</code>.\n     * \n     * @since 1.2\n     */\n    public static final int OUT_RIGHT = 4;\n\n    /**\n     * The bitmask that indicates that a point lies below this\n     * <code>Rectangle2D</code>.\n     * \n     * @since 1.2\n     */\n    public static final int OUT_BOTTOM = 8;\n    \n    public static boolean rectangleIntersectsLine(double rectX, double rectY, double rectWidth, double rectHeight,\n            double x1, double y1, double x2, double y2) {\n        return _rectangleIntersectsLine(rectX, rectY, rectWidth, rectHeight, x1, y1, x2, y2)\n                || Line2D.linesIntersect(rectX, rectY, rectX + rectWidth, rectY + rectHeight, x1, y1, x2, y2);\n    }\n    \n    private static boolean _rectangleIntersectsLine(double rectX, double rectY, double rectWidth,\n            double rectHeight, double x1, double y1, double x2, double y2) {\n        if (rectangleCornerOnSegment(rectX, rectY, rectWidth, rectHeight, x1, y1, x2, y2)) {\n            return true;\n        }\n        int out1, out2;\n        if ((out2 = outcode(rectX, rectY, rectWidth, rectHeight, x2, y2)) == 0) {\n            return true;\n        }\n        while ((out1 = outcode(rectX, rectY, rectWidth, rectHeight, x1, y1)) != 0) {\n            if ((out1 & out2) != 0) {\n                return false;\n            }\n            if ((out1 & (OUT_LEFT | OUT_RIGHT)) != 0) {\n                double x = rectX;\n                if ((out1 & OUT_RIGHT) != 0) {\n                    x += rectWidth;\n                }\n                y1 = y1 + (x - x1) * (y2 - y1) / (x2 - x1);\n                x1 = x;\n            } else {\n                double y = rectY;\n                if ((out1 & OUT_BOTTOM) != 0) {\n                    y += rectHeight;\n                }\n                x1 = x1 + (y - y1) * (x2 - x1) / (y2 - y1);\n                y1 = y;\n            }\n        }\n        return true;\n    }\n\n    private static boolean rectangleCornerOnSegment(double rectX, double rectY, double rectWidth,\n            double rectHeight, double x1, double y1, double x2, double y2) {\n        if (pointOnSegment(rectX, rectY, x1, y1, x2, y2)) {\n            return true;\n        } else if (pointOnSegment(rectX + rectWidth, rectY, x1, y1, x2, y2)) {\n            return true;\n        } else if (pointOnSegment(rectX, rectY + rectHeight, x1, y1, x2, y2)) {\n            return true;\n        } else if (pointOnSegment(rectX + rectWidth, rectY + rectHeight, x1, y1, x2, y2)) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    private static final double PRECISION = 0.00000001;\n\n    private static boolean pointOnSegment(double x, double y, double x1, double y1, double x2,\n            double y2) {\n        if (x < x1 || x > x2 || y < y1 || y > y2) {\n            return false;\n        } else {\n            double v = (y2 - y1) * (x - x1) - (x2 - x1) * (y - y1);\n            return Math.abs(v) < PRECISION;\n        }\n    }\n\n    private static int outcode(double rectX, double rectY, double rectWidth, double rectHeight,\n            double x, double y) {\n        int out = 0;\n        if (rectWidth <= 0) {\n            out |= OUT_LEFT | OUT_RIGHT;\n        } else if (x < rectX) {\n            out |= OUT_LEFT;\n        } else if (x > rectX + rectWidth) {\n            out |= OUT_RIGHT;\n        }\n        if (rectHeight <= 0) {\n            out |= OUT_TOP | OUT_BOTTOM;\n        } else if (y < rectY) {\n            out |= OUT_TOP;\n        } else if (y > rectY + rectHeight) {\n            out |= OUT_BOTTOM;\n        }\n        return out;\n    }\n\n}", "definition": "public final class RectangleUtil", "class_docstring": "", "name": "RectangleUtil", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "fields": [{"attribute_expression": "public static final int OUT_LEFT = 1;", "docstring": "\nThe bitmask that indicates that a point lies to the left of this\n<code>Rectangle2D</code>.\n\n@since 1.2\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "int", "name": "OUT_LEFT = 1", "syntax_pass": true}, {"attribute_expression": "public static final int OUT_TOP = 2;", "docstring": "\nThe bitmask that indicates that a point lies above this\n<code>Rectangle2D</code>.\n\n@since 1.2\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "int", "name": "OUT_TOP = 2", "syntax_pass": true}, {"attribute_expression": "public static final int OUT_RIGHT = 4;", "docstring": "\nThe bitmask that indicates that a point lies to the right of this\n<code>Rectangle2D</code>.\n\n@since 1.2\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "int", "name": "OUT_RIGHT = 4", "syntax_pass": true}, {"attribute_expression": "public static final int OUT_BOTTOM = 8;", "docstring": "\nThe bitmask that indicates that a point lies below this\n<code>Rectangle2D</code>.\n\n@since 1.2\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "int", "name": "OUT_BOTTOM = 8", "syntax_pass": true}, {"attribute_expression": "private static final double PRECISION = 0.00000001;", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "double", "name": "PRECISION = 0.00000001", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    private RectangleUtil() {\n        // prevent instantiation\n    }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "", "classes": []}, "name": "RectangleUtil", "params": [], "body": "                            {\n        // prevent instantiation\n    }", "signature": "private RectangleUtil()"}, {"syntax_pass": true, "original_string": "    public static boolean rectangleIntersectsLine(double rectX, double rectY, double rectWidth, double rectHeight,\n            double x1, double y1, double x2, double y2) {\n        return _rectangleIntersectsLine(rectX, rectY, rectWidth, rectHeight, x1, y1, x2, y2)\n                || Line2D.linesIntersect(rectX, rectY, rectX + rectWidth, rectY + rectHeight, x1, y1, x2, y2);\n    }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "boolean", "classes": []}, "name": "rectangleIntersectsLine", "params": [{"name": "rectX", "type": "double"}, {"name": "rectY", "type": "double"}, {"name": "rectWidth", "type": "double"}, {"name": "rectHeight", "type": "double"}, {"name": "x1", "type": "double"}, {"name": "y1", "type": "double"}, {"name": "x2", "type": "double"}, {"name": "y2", "type": "double"}], "body": "                                                        {\n        return _rectangleIntersectsLine(rectX, rectY, rectWidth, rectHeight, x1, y1, x2, y2)\n                || Line2D.linesIntersect(rectX, rectY, rectX + rectWidth, rectY + rectHeight, x1, y1, x2, y2);\n    }", "signature": "public static boolean rectangleIntersectsLine(double rectX, double rectY, double rectWidth, double rectHeight,\n            double x1, double y1, double x2, double y2)"}, {"syntax_pass": true, "original_string": "    private static boolean _rectangleIntersectsLine(double rectX, double rectY, double rectWidth,\n            double rectHeight, double x1, double y1, double x2, double y2) {\n        if (rectangleCornerOnSegment(rectX, rectY, rectWidth, rectHeight, x1, y1, x2, y2)) {\n            return true;\n        }\n        int out1, out2;\n        if ((out2 = outcode(rectX, rectY, rectWidth, rectHeight, x2, y2)) == 0) {\n            return true;\n        }\n        while ((out1 = outcode(rectX, rectY, rectWidth, rectHeight, x1, y1)) != 0) {\n            if ((out1 & out2) != 0) {\n                return false;\n            }\n            if ((out1 & (OUT_LEFT | OUT_RIGHT)) != 0) {\n                double x = rectX;\n                if ((out1 & OUT_RIGHT) != 0) {\n                    x += rectWidth;\n                }\n                y1 = y1 + (x - x1) * (y2 - y1) / (x2 - x1);\n                x1 = x;\n            } else {\n                double y = rectY;\n                if ((out1 & OUT_BOTTOM) != 0) {\n                    y += rectHeight;\n                }\n                x1 = x1 + (y - y1) * (x2 - x1) / (y2 - y1);\n                y1 = y;\n            }\n        }\n        return true;\n    }", "docstring": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "boolean", "classes": []}, "name": "_rectangleIntersectsLine", "params": [{"name": "rectX", "type": "double"}, {"name": "rectY", "type": "double"}, {"name": "rectWidth", "type": "double"}, {"name": "rectHeight", "type": "double"}, {"name": "x1", "type": "double"}, {"name": "y1", "type": "double"}, {"name": "x2", "type": "double"}, {"name": "y2", "type": "double"}], "body": "                                                                           {\n        if (rectangleCornerOnSegment(rectX, rectY, rectWidth, rectHeight, x1, y1, x2, y2)) {\n            return true;\n        }\n        int out1, out2;\n        if ((out2 = outcode(rectX, rectY, rectWidth, rectHeight, x2, y2)) == 0) {\n            return true;\n        }\n        while ((out1 = outcode(rectX, rectY, rectWidth, rectHeight, x1, y1)) != 0) {\n            if ((out1 & out2) != 0) {\n                return false;\n            }\n            if ((out1 & (OUT_LEFT | OUT_RIGHT)) != 0) {\n                double x = rectX;\n                if ((out1 & OUT_RIGHT) != 0) {\n                    x += rectWidth;\n                }\n                y1 = y1 + (x - x1) * (y2 - y1) / (x2 - x1);\n                x1 = x;\n            } else {\n                double y = rectY;\n                if ((out1 & OUT_BOTTOM) != 0) {\n                    y += rectHeight;\n                }\n                x1 = x1 + (y - y1) * (x2 - x1) / (y2 - y1);\n                y1 = y;\n            }\n        }\n        return true;\n    }", "signature": "private static boolean _rectangleIntersectsLine(double rectX, double rectY, double rectWidth,\n            double rectHeight, double x1, double y1, double x2, double y2)"}, {"syntax_pass": true, "original_string": "    private static boolean rectangleCornerOnSegment(double rectX, double rectY, double rectWidth,\n            double rectHeight, double x1, double y1, double x2, double y2) {\n        if (pointOnSegment(rectX, rectY, x1, y1, x2, y2)) {\n            return true;\n        } else if (pointOnSegment(rectX + rectWidth, rectY, x1, y1, x2, y2)) {\n            return true;\n        } else if (pointOnSegment(rectX, rectY + rectHeight, x1, y1, x2, y2)) {\n            return true;\n        } else if (pointOnSegment(rectX + rectWidth, rectY + rectHeight, x1, y1, x2, y2)) {\n            return true;\n        } else {\n            return false;\n        }\n    }", "docstring": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "boolean", "classes": []}, "name": "rectangleCornerOnSegment", "params": [{"name": "rectX", "type": "double"}, {"name": "rectY", "type": "double"}, {"name": "rectWidth", "type": "double"}, {"name": "rectHeight", "type": "double"}, {"name": "x1", "type": "double"}, {"name": "y1", "type": "double"}, {"name": "x2", "type": "double"}, {"name": "y2", "type": "double"}], "body": "                                                                           {\n        if (pointOnSegment(rectX, rectY, x1, y1, x2, y2)) {\n            return true;\n        } else if (pointOnSegment(rectX + rectWidth, rectY, x1, y1, x2, y2)) {\n            return true;\n        } else if (pointOnSegment(rectX, rectY + rectHeight, x1, y1, x2, y2)) {\n            return true;\n        } else if (pointOnSegment(rectX + rectWidth, rectY + rectHeight, x1, y1, x2, y2)) {\n            return true;\n        } else {\n            return false;\n        }\n    }", "signature": "private static boolean rectangleCornerOnSegment(double rectX, double rectY, double rectWidth,\n            double rectHeight, double x1, double y1, double x2, double y2)"}, {"syntax_pass": true, "original_string": "    private static boolean pointOnSegment(double x, double y, double x1, double y1, double x2,\n            double y2) {\n        if (x < x1 || x > x2 || y < y1 || y > y2) {\n            return false;\n        } else {\n            double v = (y2 - y1) * (x - x1) - (x2 - x1) * (y - y1);\n            return Math.abs(v) < PRECISION;\n        }\n    }", "docstring": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "boolean", "classes": []}, "name": "pointOnSegment", "params": [{"name": "x", "type": "double"}, {"name": "y", "type": "double"}, {"name": "x1", "type": "double"}, {"name": "y1", "type": "double"}, {"name": "x2", "type": "double"}, {"name": "y2", "type": "double"}], "body": "                       {\n        if (x < x1 || x > x2 || y < y1 || y > y2) {\n            return false;\n        } else {\n            double v = (y2 - y1) * (x - x1) - (x2 - x1) * (y - y1);\n            return Math.abs(v) < PRECISION;\n        }\n    }", "signature": "private static boolean pointOnSegment(double x, double y, double x1, double y1, double x2,\n            double y2)"}, {"syntax_pass": true, "original_string": "    private static int outcode(double rectX, double rectY, double rectWidth, double rectHeight,\n            double x, double y) {\n        int out = 0;\n        if (rectWidth <= 0) {\n            out |= OUT_LEFT | OUT_RIGHT;\n        } else if (x < rectX) {\n            out |= OUT_LEFT;\n        } else if (x > rectX + rectWidth) {\n            out |= OUT_RIGHT;\n        }\n        if (rectHeight <= 0) {\n            out |= OUT_TOP | OUT_BOTTOM;\n        } else if (y < rectY) {\n            out |= OUT_TOP;\n        } else if (y > rectY + rectHeight) {\n            out |= OUT_BOTTOM;\n        }\n        return out;\n    }", "docstring": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "int", "classes": []}, "name": "outcode", "params": [{"name": "rectX", "type": "double"}, {"name": "rectY", "type": "double"}, {"name": "rectWidth", "type": "double"}, {"name": "rectHeight", "type": "double"}, {"name": "x", "type": "double"}, {"name": "y", "type": "double"}], "body": "                                {\n        int out = 0;\n        if (rectWidth <= 0) {\n            out |= OUT_LEFT | OUT_RIGHT;\n        } else if (x < rectX) {\n            out |= OUT_LEFT;\n        } else if (x > rectX + rectWidth) {\n            out |= OUT_RIGHT;\n        }\n        if (rectHeight <= 0) {\n            out |= OUT_TOP | OUT_BOTTOM;\n        } else if (y < rectY) {\n            out |= OUT_TOP;\n        } else if (y > rectY + rectHeight) {\n            out |= OUT_BOTTOM;\n        }\n        return out;\n    }", "signature": "private static int outcode(double rectX, double rectY, double rectWidth, double rectHeight,\n            double x, double y)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/com/github/davidmoten/rtree/internal/operators/OperatorBoundedPriorityQueue.java", "original_string": "package com.github.davidmoten.rtree.internal.operators;\n\nimport java.util.Comparator;\nimport java.util.List;\n\nimport com.github.davidmoten.rtree.internal.util.BoundedPriorityQueue;\n\nimport rx.Observable.Operator;\nimport rx.Subscriber;\n\npublic final class OperatorBoundedPriorityQueue<T> implements Operator<T, T> {\n\n    private final int maximumSize;\n    private final Comparator<? super T> comparator;\n\n    public OperatorBoundedPriorityQueue(int maximumSize, Comparator<? super T> comparator) {\n        this.maximumSize = maximumSize;\n        this.comparator = comparator;\n    }\n\n    @Override\n    public Subscriber<? super T> call(final Subscriber<? super T> child) {\n        final BoundedPriorityQueue<T> q = new BoundedPriorityQueue<T>(maximumSize, comparator);\n        return new Subscriber<T>(child) {\n\n            @Override\n            public void onStart() {\n                request(Long.MAX_VALUE);\n            }\n\n            @Override\n            public void onCompleted() {\n                List<T> list = q.asOrderedList();\n                for (T t:list) {\n                    if (isUnsubscribed()) {\n                        return;\n                    } else {\n                        child.onNext(t);\n                    }\n                }\n                if (!isUnsubscribed()) {\n                    child.onCompleted();\n                }\n            }\n\n            @Override\n            public void onError(Throwable t) {\n                if (!isUnsubscribed())\n                    child.onError(t);\n            }\n\n            @Override\n            public void onNext(T t) {\n                if (!isUnsubscribed())\n                    q.add(t);\n            }\n        };\n    }\n\n}\n", "file_hash": "b868b524a0bc7d4ff7a2d395713250e357930b1d369f398834fd6f2aa1eabb43", "file_docstring": "", "contexts": ["package com.github.davidmoten.rtree.internal.operators;", "import java.util.Comparator;", "import java.util.List;", "import com.github.davidmoten.rtree.internal.util.BoundedPriorityQueue;", "import rx.Observable.Operator;", "import rx.Subscriber;"], "methods": [], "classes": [{"original_string": "public final class OperatorBoundedPriorityQueue<T> implements Operator<T, T> {\n\n    private final int maximumSize;\n    private final Comparator<? super T> comparator;\n\n    public OperatorBoundedPriorityQueue(int maximumSize, Comparator<? super T> comparator) {\n        this.maximumSize = maximumSize;\n        this.comparator = comparator;\n    }\n\n    @Override\n    public Subscriber<? super T> call(final Subscriber<? super T> child) {\n        final BoundedPriorityQueue<T> q = new BoundedPriorityQueue<T>(maximumSize, comparator);\n        return new Subscriber<T>(child) {\n\n            @Override\n            public void onStart() {\n                request(Long.MAX_VALUE);\n            }\n\n            @Override\n            public void onCompleted() {\n                List<T> list = q.asOrderedList();\n                for (T t:list) {\n                    if (isUnsubscribed()) {\n                        return;\n                    } else {\n                        child.onNext(t);\n                    }\n                }\n                if (!isUnsubscribed()) {\n                    child.onCompleted();\n                }\n            }\n\n            @Override\n            public void onError(Throwable t) {\n                if (!isUnsubscribed())\n                    child.onError(t);\n            }\n\n            @Override\n            public void onNext(T t) {\n                if (!isUnsubscribed())\n                    q.add(t);\n            }\n        };\n    }\n\n}", "definition": "public final class OperatorBoundedPriorityQueue<T> implements Operator<T, T>", "class_docstring": "", "name": "OperatorBoundedPriorityQueue", "super_interfaces": ["Operator<T, T>"], "superclasses": "", "attributes": {"modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "fields": [{"attribute_expression": "private final int maximumSize;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "int", "name": "maximumSize", "syntax_pass": true}, {"attribute_expression": "private final Comparator<? super T> comparator;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Comparator<? super T>", "name": "comparator", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    public OperatorBoundedPriorityQueue(int maximumSize, Comparator<? super T> comparator) {\n        this.maximumSize = maximumSize;\n        this.comparator = comparator;\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "OperatorBoundedPriorityQueue", "params": [{"name": "maximumSize", "type": "int"}, {"name": "comparator", "type": "Comparator<? super T>"}], "body": "                                                                                           {\n        this.maximumSize = maximumSize;\n        this.comparator = comparator;\n    }", "signature": "public OperatorBoundedPriorityQueue(int maximumSize, Comparator<? super T> comparator)"}, {"syntax_pass": true, "original_string": "    @Override\n    public Subscriber<? super T> call(final Subscriber<? super T> child) {\n        final BoundedPriorityQueue<T> q = new BoundedPriorityQueue<T>(maximumSize, comparator);\n        return new Subscriber<T>(child) {\n\n            @Override\n            public void onStart() {\n                request(Long.MAX_VALUE);\n            }\n\n            @Override\n            public void onCompleted() {\n                List<T> list = q.asOrderedList();\n                for (T t:list) {\n                    if (isUnsubscribed()) {\n                        return;\n                    } else {\n                        child.onNext(t);\n                    }\n                }\n                if (!isUnsubscribed()) {\n                    child.onCompleted();\n                }\n            }\n\n            @Override\n            public void onError(Throwable t) {\n                if (!isUnsubscribed())\n                    child.onError(t);\n            }\n\n            @Override\n            public void onNext(T t) {\n                if (!isUnsubscribed())\n                    q.add(t);\n            }\n        };\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Subscriber<? super T>", "classes": []}, "name": "call", "params": [{"name": "child", "type": "Subscriber<? super T>"}], "body": "                                                                         {\n        final BoundedPriorityQueue<T> q = new BoundedPriorityQueue<T>(maximumSize, comparator);\n        return new Subscriber<T>(child) {\n\n            @Override\n            public void onStart() {\n                request(Long.MAX_VALUE);\n            }\n\n            @Override\n            public void onCompleted() {\n                List<T> list = q.asOrderedList();\n                for (T t:list) {\n                    if (isUnsubscribed()) {\n                        return;\n                    } else {\n                        child.onNext(t);\n                    }\n                }\n                if (!isUnsubscribed()) {\n                    child.onCompleted();\n                }\n            }\n\n            @Override\n            public void onError(Throwable t) {\n                if (!isUnsubscribed())\n                    child.onError(t);\n            }\n\n            @Override\n            public void onNext(T t) {\n                if (!isUnsubscribed())\n                    q.add(t);\n            }\n        };\n    }", "signature": "@Override\n    public Subscriber<? super T> call(final Subscriber<? super T> child)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/com/github/davidmoten/rtree/internal/util/ObjectsHelper.java", "original_string": "package com.github.davidmoten.rtree.internal.util;\n\n\nimport com.github.davidmoten.guavamini.annotations.VisibleForTesting;\n\nimport java.util.Optional;\n\npublic final class ObjectsHelper {\n\n    private ObjectsHelper() {\n        // prevent instantiation\n    }\n\n    @VisibleForTesting\n    static void instantiateForTestCoveragePurposesOnly() {\n        new ObjectsHelper();\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    public static <T> Optional<T> asClass(Object object, Class<T> cls) {\n        if (object == null) {\n            return Optional.empty();\n        } else if (object.getClass() != cls) {\n            return Optional.empty();\n        } else {\n            return Optional.of((T) object);\n        }\n    }\n\n}\n", "file_hash": "f222ea44040496fe6e96481b1f3da904003d34a14c5c90483a7abb0067924c48", "file_docstring": "", "contexts": ["package com.github.davidmoten.rtree.internal.util;", "import com.github.davidmoten.guavamini.annotations.VisibleForTesting;", "import java.util.Optional;"], "methods": [], "classes": [{"original_string": "public final class ObjectsHelper {\n\n    private ObjectsHelper() {\n        // prevent instantiation\n    }\n\n    @VisibleForTesting\n    static void instantiateForTestCoveragePurposesOnly() {\n        new ObjectsHelper();\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    public static <T> Optional<T> asClass(Object object, Class<T> cls) {\n        if (object == null) {\n            return Optional.empty();\n        } else if (object.getClass() != cls) {\n            return Optional.empty();\n        } else {\n            return Optional.of((T) object);\n        }\n    }\n\n}", "definition": "public final class ObjectsHelper", "class_docstring": "", "name": "ObjectsHelper", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    private ObjectsHelper() {\n        // prevent instantiation\n    }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "", "classes": []}, "name": "ObjectsHelper", "params": [], "body": "                            {\n        // prevent instantiation\n    }", "signature": "private ObjectsHelper()"}, {"syntax_pass": true, "original_string": "    @VisibleForTesting\n    static void instantiateForTestCoveragePurposesOnly() {\n        new ObjectsHelper();\n    }", "docstring": "", "attributes": {"modifiers": "@VisibleForTesting\n    static", "marker_annotations": ["@VisibleForTesting"], "non_marker_annotations": ["static"], "comments": [], "return_type": "void", "classes": []}, "name": "instantiateForTestCoveragePurposesOnly", "params": [], "body": "                                                         {\n        new ObjectsHelper();\n    }", "signature": "@VisibleForTesting\n    static void instantiateForTestCoveragePurposesOnly()"}, {"syntax_pass": true, "original_string": "    @SuppressWarnings(\"unchecked\")\n    public static <T> Optional<T> asClass(Object object, Class<T> cls) {\n        if (object == null) {\n            return Optional.empty();\n        } else if (object.getClass() != cls) {\n            return Optional.empty();\n        } else {\n            return Optional.of((T) object);\n        }\n    }", "docstring": "", "attributes": {"modifiers": "@SuppressWarnings(\"unchecked\")\n    public static", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings(\"unchecked\")", "public", "static"], "comments": [], "return_type": "Optional<T>", "classes": []}, "name": "asClass", "params": [{"name": "object", "type": "Object"}, {"name": "cls", "type": "Class<T>"}], "body": "                                                                       {\n        if (object == null) {\n            return Optional.empty();\n        } else if (object.getClass() != cls) {\n            return Optional.empty();\n        } else {\n            return Optional.of((T) object);\n        }\n    }", "signature": "@SuppressWarnings(\"unchecked\")\n    public static <T> Optional<T> asClass(Object object, Class<T> cls)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/com/github/davidmoten/rtree/internal/util/Pair.java", "original_string": "package com.github.davidmoten.rtree.internal.util;\n\npublic final class Pair<T> {\n\n    private final T value1;\n    private final T value2;\n\n    public Pair(T value1, T value2) {\n        this.value1 = value1;\n        this.value2 = value2;\n    }\n\n    public T value1() {\n        return value1;\n    }\n\n    public T value2() {\n        return value2;\n    }\n\n}\n", "file_hash": "6382dffd3f547bc69c60d21424549f4401a1b50e8fee1915f36257ba56a13ff4", "file_docstring": "", "contexts": ["package com.github.davidmoten.rtree.internal.util;"], "methods": [], "classes": [{"original_string": "public final class Pair<T> {\n\n    private final T value1;\n    private final T value2;\n\n    public Pair(T value1, T value2) {\n        this.value1 = value1;\n        this.value2 = value2;\n    }\n\n    public T value1() {\n        return value1;\n    }\n\n    public T value2() {\n        return value2;\n    }\n\n}", "definition": "public final class Pair<T>", "class_docstring": "", "name": "Pair", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "fields": [{"attribute_expression": "private final T value1;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "T", "name": "value1", "syntax_pass": true}, {"attribute_expression": "private final T value2;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "T", "name": "value2", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    public Pair(T value1, T value2) {\n        this.value1 = value1;\n        this.value2 = value2;\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "Pair", "params": [{"name": "value1", "type": "T"}, {"name": "value2", "type": "T"}], "body": "                                    {\n        this.value1 = value1;\n        this.value2 = value2;\n    }", "signature": "public Pair(T value1, T value2)"}, {"syntax_pass": true, "original_string": "    public T value1() {\n        return value1;\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "T", "classes": []}, "name": "value1", "params": [], "body": "                      {\n        return value1;\n    }", "signature": "public T value1()"}, {"syntax_pass": true, "original_string": "    public T value2() {\n        return value2;\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "T", "classes": []}, "name": "value2", "params": [], "body": "                      {\n        return value2;\n    }", "signature": "public T value2()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/com/github/davidmoten/rtree/internal/util/ImmutableStack.java", "original_string": "package com.github.davidmoten.rtree.internal.util;\n\n\nimport java.util.Iterator;\nimport java.util.Optional;\n\nimport static java.util.Optional.of;\n\n\npublic final class ImmutableStack<T> implements Iterable<T> {\n    private final Optional<T> head;\n    private final Optional<ImmutableStack<T>> tail;\n\n    private static ImmutableStack<?> EMPTY = new ImmutableStack<>();\n\n    public ImmutableStack(final T head, final ImmutableStack<T> tail) {\n        this(of(head), of(tail));\n    }\n\n    private ImmutableStack(Optional<T> head, Optional<ImmutableStack<T>> tail) {\n        this.head = head;\n        this.tail = tail;\n    }\n\n    public static <T> ImmutableStack<T> create(T t) {\n        return new ImmutableStack<>(of(t), of(ImmutableStack.empty()));\n    }\n\n    public ImmutableStack() {\n        this(Optional.empty(), Optional.empty());\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    public static <S> ImmutableStack<S> empty() {\n        return (ImmutableStack<S>) EMPTY;\n    }\n\n    public boolean isEmpty() {\n        return !head.isPresent();\n    }\n\n    public T peek() {\n        // if (isEmpty())\n        // throw new RuntimeException(\"cannot peek on empty stack\");\n        // else\n        return this.head.get();\n    }\n\n    public ImmutableStack<T> pop() {\n        // if (isEmpty())\n        // throw new RuntimeException(\"cannot pop on empty stack\");\n        // else\n        return this.tail.get();\n    }\n\n    public ImmutableStack<T> push(T value) {\n        return new ImmutableStack<T>(value, this);\n    }\n\n    @Override\n    public Iterator<T> iterator() {\n        return new StackIterator<T>(this);\n    }\n\n    private static class StackIterator<U> implements Iterator<U> {\n        private ImmutableStack<U> stack;\n\n        public StackIterator(final ImmutableStack<U> stack) {\n            this.stack = stack;\n        }\n\n        @Override\n        public boolean hasNext() {\n            return !this.stack.isEmpty();\n        }\n\n        @Override\n        public U next() {\n            final U result = this.stack.peek();\n            this.stack = this.stack.pop();\n            return result;\n        }\n\n        @Override\n        public void remove() {\n            throw new RuntimeException(\"not supported\");\n        }\n    }\n\n}", "file_hash": "a4b13e340eef6c568b4fab68a1921f0d0549254545445b6b6855b1745f530365", "file_docstring": "", "contexts": ["package com.github.davidmoten.rtree.internal.util;", "import java.util.Iterator;", "import java.util.Optional;", "import static java.util.Optional.of;"], "methods": [], "classes": [{"original_string": "public final class ImmutableStack<T> implements Iterable<T> {\n    private final Optional<T> head;\n    private final Optional<ImmutableStack<T>> tail;\n\n    private static ImmutableStack<?> EMPTY = new ImmutableStack<>();\n\n    public ImmutableStack(final T head, final ImmutableStack<T> tail) {\n        this(of(head), of(tail));\n    }\n\n    private ImmutableStack(Optional<T> head, Optional<ImmutableStack<T>> tail) {\n        this.head = head;\n        this.tail = tail;\n    }\n\n    public static <T> ImmutableStack<T> create(T t) {\n        return new ImmutableStack<>(of(t), of(ImmutableStack.empty()));\n    }\n\n    public ImmutableStack() {\n        this(Optional.empty(), Optional.empty());\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    public static <S> ImmutableStack<S> empty() {\n        return (ImmutableStack<S>) EMPTY;\n    }\n\n    public boolean isEmpty() {\n        return !head.isPresent();\n    }\n\n    public T peek() {\n        // if (isEmpty())\n        // throw new RuntimeException(\"cannot peek on empty stack\");\n        // else\n        return this.head.get();\n    }\n\n    public ImmutableStack<T> pop() {\n        // if (isEmpty())\n        // throw new RuntimeException(\"cannot pop on empty stack\");\n        // else\n        return this.tail.get();\n    }\n\n    public ImmutableStack<T> push(T value) {\n        return new ImmutableStack<T>(value, this);\n    }\n\n    @Override\n    public Iterator<T> iterator() {\n        return new StackIterator<T>(this);\n    }\n\n    private static class StackIterator<U> implements Iterator<U> {\n        private ImmutableStack<U> stack;\n\n        public StackIterator(final ImmutableStack<U> stack) {\n            this.stack = stack;\n        }\n\n        @Override\n        public boolean hasNext() {\n            return !this.stack.isEmpty();\n        }\n\n        @Override\n        public U next() {\n            final U result = this.stack.peek();\n            this.stack = this.stack.pop();\n            return result;\n        }\n\n        @Override\n        public void remove() {\n            throw new RuntimeException(\"not supported\");\n        }\n    }\n\n}", "definition": "public final class ImmutableStack<T> implements Iterable<T>", "class_docstring": "", "name": "ImmutableStack", "super_interfaces": ["Iterable<T>"], "superclasses": "", "attributes": {"modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "fields": [{"attribute_expression": "private final Optional<T> head;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Optional<T>", "name": "head", "syntax_pass": true}, {"attribute_expression": "private final Optional<ImmutableStack<T>> tail;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Optional<ImmutableStack<T>>", "name": "tail", "syntax_pass": true}, {"attribute_expression": "private static ImmutableStack<?> EMPTY = new ImmutableStack<>();", "docstring": "", "modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "type": "ImmutableStack<?>", "name": "EMPTY = new ImmutableStack<>()", "syntax_pass": true}], "classes": [{"original_string": "    private static class StackIterator<U> implements Iterator<U> {\n        private ImmutableStack<U> stack;\n\n        public StackIterator(final ImmutableStack<U> stack) {\n            this.stack = stack;\n        }\n\n        @Override\n        public boolean hasNext() {\n            return !this.stack.isEmpty();\n        }\n\n        @Override\n        public U next() {\n            final U result = this.stack.peek();\n            this.stack = this.stack.pop();\n            return result;\n        }\n\n        @Override\n        public void remove() {\n            throw new RuntimeException(\"not supported\");\n        }\n    }", "definition": "    private static class StackIterator<U> implements Iterator<U>", "class_docstring": "", "name": "StackIterator", "super_interfaces": ["Iterator<U>"], "superclasses": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "fields": [{"attribute_expression": "private ImmutableStack<U> stack;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "ImmutableStack<U>", "name": "stack", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        public StackIterator(final ImmutableStack<U> stack) {\n            this.stack = stack;\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "StackIterator", "params": [{"name": "stack", "type": "ImmutableStack<U>"}], "body": "                                                            {\n            this.stack = stack;\n        }", "signature": "public StackIterator(final ImmutableStack<U> stack)"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean hasNext() {\n            return !this.stack.isEmpty();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "hasNext", "params": [], "body": "                                 {\n            return !this.stack.isEmpty();\n        }", "signature": "@Override\n        public boolean hasNext()"}, {"syntax_pass": true, "original_string": "        @Override\n        public U next() {\n            final U result = this.stack.peek();\n            this.stack = this.stack.pop();\n            return result;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "U", "classes": []}, "name": "next", "params": [], "body": "                        {\n            final U result = this.stack.peek();\n            this.stack = this.stack.pop();\n            return result;\n        }", "signature": "@Override\n        public U next()"}, {"syntax_pass": true, "original_string": "        @Override\n        public void remove() {\n            throw new RuntimeException(\"not supported\");\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "remove", "params": [], "body": "                             {\n            throw new RuntimeException(\"not supported\");\n        }", "signature": "@Override\n        public void remove()"}]}]}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    public ImmutableStack(final T head, final ImmutableStack<T> tail) {\n        this(of(head), of(tail));\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "ImmutableStack", "params": [{"name": "head", "type": "T"}, {"name": "tail", "type": "ImmutableStack<T>"}], "body": "                                                                      {\n        this(of(head), of(tail));\n    }", "signature": "public ImmutableStack(final T head, final ImmutableStack<T> tail)"}, {"syntax_pass": true, "original_string": "    private ImmutableStack(Optional<T> head, Optional<ImmutableStack<T>> tail) {\n        this.head = head;\n        this.tail = tail;\n    }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "", "classes": []}, "name": "ImmutableStack", "params": [{"name": "head", "type": "Optional<T>"}, {"name": "tail", "type": "Optional<ImmutableStack<T>>"}], "body": "                                                                               {\n        this.head = head;\n        this.tail = tail;\n    }", "signature": "private ImmutableStack(Optional<T> head, Optional<ImmutableStack<T>> tail)"}, {"syntax_pass": true, "original_string": "    public static <T> ImmutableStack<T> create(T t) {\n        return new ImmutableStack<>(of(t), of(ImmutableStack.empty()));\n    }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "ImmutableStack<T>", "classes": []}, "name": "create", "params": [{"name": "t", "type": "T"}], "body": "                                                    {\n        return new ImmutableStack<>(of(t), of(ImmutableStack.empty()));\n    }", "signature": "public static <T> ImmutableStack<T> create(T t)"}, {"syntax_pass": true, "original_string": "    public ImmutableStack() {\n        this(Optional.empty(), Optional.empty());\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "ImmutableStack", "params": [], "body": "                            {\n        this(Optional.empty(), Optional.empty());\n    }", "signature": "public ImmutableStack()"}, {"syntax_pass": true, "original_string": "    @SuppressWarnings(\"unchecked\")\n    public static <S> ImmutableStack<S> empty() {\n        return (ImmutableStack<S>) EMPTY;\n    }", "docstring": "", "attributes": {"modifiers": "@SuppressWarnings(\"unchecked\")\n    public static", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings(\"unchecked\")", "public", "static"], "comments": [], "return_type": "ImmutableStack<S>", "classes": []}, "name": "empty", "params": [], "body": "                                                {\n        return (ImmutableStack<S>) EMPTY;\n    }", "signature": "@SuppressWarnings(\"unchecked\")\n    public static <S> ImmutableStack<S> empty()"}, {"syntax_pass": true, "original_string": "    public boolean isEmpty() {\n        return !head.isPresent();\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isEmpty", "params": [], "body": "                             {\n        return !head.isPresent();\n    }", "signature": "public boolean isEmpty()"}, {"syntax_pass": true, "original_string": "    public T peek() {\n        // if (isEmpty())\n        // throw new RuntimeException(\"cannot peek on empty stack\");\n        // else\n        return this.head.get();\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "T", "classes": []}, "name": "peek", "params": [], "body": "                    {\n        // if (isEmpty())\n        // throw new RuntimeException(\"cannot peek on empty stack\");\n        // else\n        return this.head.get();\n    }", "signature": "public T peek()"}, {"syntax_pass": true, "original_string": "    public ImmutableStack<T> pop() {\n        // if (isEmpty())\n        // throw new RuntimeException(\"cannot pop on empty stack\");\n        // else\n        return this.tail.get();\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ImmutableStack<T>", "classes": []}, "name": "pop", "params": [], "body": "                                   {\n        // if (isEmpty())\n        // throw new RuntimeException(\"cannot pop on empty stack\");\n        // else\n        return this.tail.get();\n    }", "signature": "public ImmutableStack<T> pop()"}, {"syntax_pass": true, "original_string": "    public ImmutableStack<T> push(T value) {\n        return new ImmutableStack<T>(value, this);\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ImmutableStack<T>", "classes": []}, "name": "push", "params": [{"name": "value", "type": "T"}], "body": "                                           {\n        return new ImmutableStack<T>(value, this);\n    }", "signature": "public ImmutableStack<T> push(T value)"}, {"syntax_pass": true, "original_string": "    @Override\n    public Iterator<T> iterator() {\n        return new StackIterator<T>(this);\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Iterator<T>", "classes": []}, "name": "iterator", "params": [], "body": "                                  {\n        return new StackIterator<T>(this);\n    }", "signature": "@Override\n    public Iterator<T> iterator()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/com/github/davidmoten/rtree/internal/util/BoundedPriorityQueue.java", "original_string": "package com.github.davidmoten.rtree.internal.util;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.List;\nimport java.util.PriorityQueue;\n\nimport com.github.davidmoten.guavamini.Preconditions;\n\npublic final class BoundedPriorityQueue<T> {\n\n    private final PriorityQueue<T> queue; /* backing data structure */\n    private final Comparator<? super T> comparator;\n    private final int maxSize;\n\n    /**\n     * Constructs a {@link BoundedPriorityQueue} with the specified\n     * {@code maxSize} and {@code comparator}.\n     *\n     * @param maxSize\n     *            - The maximum size the queue can reach, must be a positive\n     *            integer.\n     * @param comparator\n     *            - The comparator to be used to compare the elements in the\n     *            queue, must be non-null.\n     */\n    public BoundedPriorityQueue(final int maxSize, final Comparator<? super T> comparator) {\n        Preconditions.checkArgument(maxSize > 0, \"maxSize must be > 0\");\n        Preconditions.checkNotNull(comparator, \"comparator cannot be null\");\n        this.queue = new PriorityQueue<T>(reverse(comparator));\n        this.comparator = comparator;\n        this.maxSize = maxSize;\n    }\n\n    private static <T> Comparator<T> reverse(final Comparator<T> comparator) {\n        return (o1, o2) -> comparator.compare(o2, o1);\n    }\n\n    public static <T> BoundedPriorityQueue<T> create(final int maxSize,\n            final Comparator<? super T> comparator) {\n        return new BoundedPriorityQueue<T>(maxSize, comparator);\n    }\n\n    /**\n     * Adds an element to the queue. If the queue contains {@code maxSize}\n     * elements, {@code e} will be compared to the lowest element in the queue\n     * using {@code comparator}. If {@code e} is greater than or equal to the\n     * lowest element, that element will be removed and {@code e} will be added\n     * instead. Otherwise, the queue will not be modified and {@code e} will not\n     * be added.\n     *\n     * @param t\n     *            - Element to be added, must be non-null.\n     */\n    public void add(final T t) {\n        if (t == null) {\n            throw new NullPointerException(\"cannot add null to the queue\");\n        }\n        if (queue.size() >= maxSize) {\n            final T maxElement = queue.peek();\n            if (comparator.compare(maxElement, t) < 1) {\n                return;\n            } else {\n                queue.poll();\n            }\n        }\n        queue.add(t);\n    }\n\n    /**\n     * @return Returns a view of the queue as a\n     *         {@link Collections#unmodifiableList(java.util.List)}\n     *         unmodifiableList sorted in reverse order.\n     */\n    public List<T> asList() {\n        return Collections.unmodifiableList(new ArrayList<>(queue));\n    }\n\n    public List<T> asOrderedList() {\n        List<T> list = new ArrayList<>(queue);\n        list.sort(comparator);\n        return list;\n    }\n\n}", "file_hash": "6a6298f986e21b0e4a86ed857227bc483e5117ac5e7bd4a32e5b37f9ac39db61", "file_docstring": "", "contexts": ["package com.github.davidmoten.rtree.internal.util;", "import java.util.ArrayList;", "import java.util.Collections;", "import java.util.Comparator;", "import java.util.List;", "import java.util.PriorityQueue;", "import com.github.davidmoten.guavamini.Preconditions;"], "methods": [], "classes": [{"original_string": "public final class BoundedPriorityQueue<T> {\n\n    private final PriorityQueue<T> queue; /* backing data structure */\n    private final Comparator<? super T> comparator;\n    private final int maxSize;\n\n    /**\n     * Constructs a {@link BoundedPriorityQueue} with the specified\n     * {@code maxSize} and {@code comparator}.\n     *\n     * @param maxSize\n     *            - The maximum size the queue can reach, must be a positive\n     *            integer.\n     * @param comparator\n     *            - The comparator to be used to compare the elements in the\n     *            queue, must be non-null.\n     */\n    public BoundedPriorityQueue(final int maxSize, final Comparator<? super T> comparator) {\n        Preconditions.checkArgument(maxSize > 0, \"maxSize must be > 0\");\n        Preconditions.checkNotNull(comparator, \"comparator cannot be null\");\n        this.queue = new PriorityQueue<T>(reverse(comparator));\n        this.comparator = comparator;\n        this.maxSize = maxSize;\n    }\n\n    private static <T> Comparator<T> reverse(final Comparator<T> comparator) {\n        return (o1, o2) -> comparator.compare(o2, o1);\n    }\n\n    public static <T> BoundedPriorityQueue<T> create(final int maxSize,\n            final Comparator<? super T> comparator) {\n        return new BoundedPriorityQueue<T>(maxSize, comparator);\n    }\n\n    /**\n     * Adds an element to the queue. If the queue contains {@code maxSize}\n     * elements, {@code e} will be compared to the lowest element in the queue\n     * using {@code comparator}. If {@code e} is greater than or equal to the\n     * lowest element, that element will be removed and {@code e} will be added\n     * instead. Otherwise, the queue will not be modified and {@code e} will not\n     * be added.\n     *\n     * @param t\n     *            - Element to be added, must be non-null.\n     */\n    public void add(final T t) {\n        if (t == null) {\n            throw new NullPointerException(\"cannot add null to the queue\");\n        }\n        if (queue.size() >= maxSize) {\n            final T maxElement = queue.peek();\n            if (comparator.compare(maxElement, t) < 1) {\n                return;\n            } else {\n                queue.poll();\n            }\n        }\n        queue.add(t);\n    }\n\n    /**\n     * @return Returns a view of the queue as a\n     *         {@link Collections#unmodifiableList(java.util.List)}\n     *         unmodifiableList sorted in reverse order.\n     */\n    public List<T> asList() {\n        return Collections.unmodifiableList(new ArrayList<>(queue));\n    }\n\n    public List<T> asOrderedList() {\n        List<T> list = new ArrayList<>(queue);\n        list.sort(comparator);\n        return list;\n    }\n\n}", "definition": "public final class BoundedPriorityQueue<T>", "class_docstring": "", "name": "BoundedPriorityQueue", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "fields": [{"attribute_expression": "private final PriorityQueue<T> queue;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "PriorityQueue<T>", "name": "queue", "syntax_pass": true}, {"attribute_expression": "private final Comparator<? super T> comparator;", "docstring": " backing data structure", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Comparator<? super T>", "name": "comparator", "syntax_pass": true}, {"attribute_expression": "private final int maxSize;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "int", "name": "maxSize", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    public BoundedPriorityQueue(final int maxSize, final Comparator<? super T> comparator) {\n        Preconditions.checkArgument(maxSize > 0, \"maxSize must be > 0\");\n        Preconditions.checkNotNull(comparator, \"comparator cannot be null\");\n        this.queue = new PriorityQueue<T>(reverse(comparator));\n        this.comparator = comparator;\n        this.maxSize = maxSize;\n    }", "docstring": "\nConstructs a {@link BoundedPriorityQueue} with the specified\n{@code maxSize} and {@code comparator}.\n\n@param maxSize\n           - The maximum size the queue can reach, must be a positive\n           integer.\n@param comparator\n           - The comparator to be used to compare the elements in the\n           queue, must be non-null.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "BoundedPriorityQueue", "params": [{"name": "maxSize", "type": "int"}, {"name": "comparator", "type": "Comparator<? super T>"}], "body": "                                                                                           {\n        Preconditions.checkArgument(maxSize > 0, \"maxSize must be > 0\");\n        Preconditions.checkNotNull(comparator, \"comparator cannot be null\");\n        this.queue = new PriorityQueue<T>(reverse(comparator));\n        this.comparator = comparator;\n        this.maxSize = maxSize;\n    }", "signature": "public BoundedPriorityQueue(final int maxSize, final Comparator<? super T> comparator)"}, {"syntax_pass": true, "original_string": "    private static <T> Comparator<T> reverse(final Comparator<T> comparator) {\n        return (o1, o2) -> comparator.compare(o2, o1);\n    }", "docstring": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "Comparator<T>", "classes": []}, "name": "reverse", "params": [{"name": "comparator", "type": "Comparator<T>"}], "body": "                                                                             {\n        return (o1, o2) -> comparator.compare(o2, o1);\n    }", "signature": "private static <T> Comparator<T> reverse(final Comparator<T> comparator)"}, {"syntax_pass": true, "original_string": "    public static <T> BoundedPriorityQueue<T> create(final int maxSize,\n            final Comparator<? super T> comparator) {\n        return new BoundedPriorityQueue<T>(maxSize, comparator);\n    }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "BoundedPriorityQueue<T>", "classes": []}, "name": "create", "params": [{"name": "maxSize", "type": "int"}, {"name": "comparator", "type": "Comparator<? super T>"}], "body": "                                                    {\n        return new BoundedPriorityQueue<T>(maxSize, comparator);\n    }", "signature": "public static <T> BoundedPriorityQueue<T> create(final int maxSize,\n            final Comparator<? super T> comparator)"}, {"syntax_pass": true, "original_string": "    public void add(final T t) {\n        if (t == null) {\n            throw new NullPointerException(\"cannot add null to the queue\");\n        }\n        if (queue.size() >= maxSize) {\n            final T maxElement = queue.peek();\n            if (comparator.compare(maxElement, t) < 1) {\n                return;\n            } else {\n                queue.poll();\n            }\n        }\n        queue.add(t);\n    }", "docstring": "\nAdds an element to the queue. If the queue contains {@code maxSize}\nelements, {@code e} will be compared to the lowest element in the queue\nusing {@code comparator}. If {@code e} is greater than or equal to the\nlowest element, that element will be removed and {@code e} will be added\ninstead. Otherwise, the queue will not be modified and {@code e} will not\nbe added.\n\n@param t\n           - Element to be added, must be non-null.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "add", "params": [{"name": "t", "type": "T"}], "body": "                               {\n        if (t == null) {\n            throw new NullPointerException(\"cannot add null to the queue\");\n        }\n        if (queue.size() >= maxSize) {\n            final T maxElement = queue.peek();\n            if (comparator.compare(maxElement, t) < 1) {\n                return;\n            } else {\n                queue.poll();\n            }\n        }\n        queue.add(t);\n    }", "signature": "public void add(final T t)"}, {"syntax_pass": true, "original_string": "    public List<T> asList() {\n        return Collections.unmodifiableList(new ArrayList<>(queue));\n    }", "docstring": "\n@return Returns a view of the queue as a\n        {@link Collections#unmodifiableList(java.util.List)}\n        unmodifiableList sorted in reverse order.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "List<T>", "classes": []}, "name": "asList", "params": [], "body": "                            {\n        return Collections.unmodifiableList(new ArrayList<>(queue));\n    }", "signature": "public List<T> asList()"}, {"syntax_pass": true, "original_string": "    public List<T> asOrderedList() {\n        List<T> list = new ArrayList<>(queue);\n        list.sort(comparator);\n        return list;\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "List<T>", "classes": []}, "name": "asOrderedList", "params": [], "body": "                                   {\n        List<T> list = new ArrayList<>(queue);\n        list.sort(comparator);\n        return list;\n    }", "signature": "public List<T> asOrderedList()"}]}], "interfaces": [], "records": []}]