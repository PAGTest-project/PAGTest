[{"uris": "src/test/java/com/github/davidmoten/rtree/GreekEarthquakes.java.GreekEarthquakes", "name": "GreekEarthquakes", "file_path": "src/test/java/com/github/davidmoten/rtree/GreekEarthquakes.java", "superclasses": "", "methods": ["[Observable<Entry<Object, Point>>]entries(Precision)", "[List<Entry<Object, Point>>]entriesList(Precision)", "[void]main(String[])"], "method_uris": ["src/test/java/com/github/davidmoten/rtree/GreekEarthquakes.java.GreekEarthquakes.[Observable<Entry<Object, Point>>]entries(Precision)", "src/test/java/com/github/davidmoten/rtree/GreekEarthquakes.java.GreekEarthquakes.[List<Entry<Object, Point>>]entriesList(Precision)", "src/test/java/com/github/davidmoten/rtree/GreekEarthquakes.java.GreekEarthquakes.[void]main(String[])"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class GreekEarthquakes {\n\n    public static Observable<Entry<Object, Point>> entries(final Precision precision) {\n        Observable<String> source = Observable.using(new Func0<InputStream>() {\n            @Override\n            public InputStream call() {\n                try {\n                    return new GZIPInputStream(GreekEarthquakes.class\n                            .getResourceAsStream(\"/greek-earthquakes-1964-2000.txt.gz\"));\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n        }, new Func1<InputStream, Observable<String>>() {\n            @Override\n            public Observable<String> call(InputStream is) {\n                return StringObservable.from(new InputStreamReader(is));\n            }\n        }, new Action1<InputStream>() {\n            @Override\n            public void call(InputStream is) {\n                try {\n                    is.close();\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n        });\n        return StringObservable.split(source, \"\\n\")\n                .flatMap(new Func1<String, Observable<Entry<Object, Point>>>() {\n\n                    @Override\n                    public Observable<Entry<Object, Point>> call(String line) {\n                        if (line.trim().length() > 0) {\n                            String[] items = line.split(\" \");\n                            double lat = Double.parseDouble(items[0]);\n                            double lon = Double.parseDouble(items[1]);\n                            Entry<Object, Point> entry;\n                            if (precision == Precision.DOUBLE)\n                                entry = Entries.entry(new Object(), Geometries.point(lat, lon));\n                            else\n                                entry = Entries.entry(new Object(),\n                                        Geometries.point((float) lat, (float) lon));\n                            return Observable.just(entry);\n                        } else\n                            return Observable.empty();\n                    }\n                });\n    }\n\n    static List<Entry<Object, Point>> entriesList(Precision precision) {\n        List<Entry<Object, Point>> result = entries(precision).toList().toBlocking().single();\n        System.out.println(\"loaded greek earthquakes into list\");\n        return result;\n    }\n\n    public static void main(String[] args) throws InterruptedException {\n        RTree<Object, Point> tree = RTree.star().create();\n        tree = tree.add(entries(Precision.SINGLE)).last().toBlocking().single();\n        System.gc();\n        Thread.sleep(10000000);\n        System.out.println(tree.size());\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/com/github/davidmoten/rtree/BenchmarksRTree.java.BenchmarksRTree", "name": "BenchmarksRTree", "file_path": "src/test/java/com/github/davidmoten/rtree/BenchmarksRTree.java", "superclasses": "", "methods": ["[RTree<Object, Point>]defaultRTreeInsertOneEntryIntoGreekDataEntriesMaxChildren004()", "[byte[]]createFlatBuffersByteArrayGreek()", "[RTree<Object, Point>]createFlatBuffersGreek()", "[RTree<Object, Point>]defaultRTreeCreation010()", "[RTree<Object, Point>]starRTreeCreation010()", "[RTree<Object, Point>]flatBufferRTreeCreation010()", "[RTree<Object, Point>]bulkLoadingRTreeCreation010()", "[RTree<Object, Point>]bulkLoadingFullRTreeCreation010()", "[void]defaultRTreeSearchOfGreekDataPointsMaxChildren004(Blackhole)", "[RTree<Object, Point>]defaultRTreeInsertOneEntryIntoGreekDataEntriesMaxChildren010()", "[void]defaultRTreeSearchOfGreekDataPointsMaxChildren010(Blackhole)", "[RTree<Object, Point>]rStarTreeInsertOneEntryIntoGreekDataEntriesMaxChildren004()", "[RTree<Object, Point>]rStarTreeInsertOneEntryIntoGreekDataEntriesMaxChildren010()", "[void]rStarTreeSearchOfGreekDataPointsMaxChildren004(Blackhole)", "[void]rStarTreeSearchOfGreekDataPointsMaxChildren010(Blackhole)", "[void]rStarTreeSearchOfGreekDataPointsMaxChildren010FlatBuffers(Blackhole)", "[void]rStarTreeSearchOfGreekDataPointsMaxChildren010FlatBuffersBackpressure(Blackhole)", "[void]rStarTreeSearchOfGreekDataPointsMaxChildren010WithBackpressure(Blackhole)", "[RTree<Object, Point>]defaultRTreeInsertOneEntryIntoGreekDataEntriesMaxChildren032()", "[void]defaultRTreeSearchOfGreekDataPointsMaxChildren032(Blackhole)", "[RTree<Object, Point>]rStarTreeInsertOneEntryIntoGreekDataEntriesMaxChildren032()", "[void]rStarTreeSearchOfGreekDataPointsMaxChildren032(Blackhole)", "[RTree<Object, Point>]defaultRTreeInsertOneEntryIntoGreekDataEntriesMaxChildren128()", "[void]defaultRTreeSearchOfGreekDataPointsMaxChildren128(Blackhole)", "[RTree<Object, Point>]rStarTreeInsertOneEntryIntoGreekDataEntriesMaxChildren128()", "[void]rStarTreeSearchOfGreekDataPointsMaxChildren128(Blackhole)", "[RTree<Object, Rectangle>]defaultRTreeInsertOneEntryInto1000EntriesMaxChildren004()", "[void]defaultRTreeSearchOf1000PointsMaxChildren004(Blackhole)", "[RTree<Object, Rectangle>]defaultRTreeInsertOneEntryInto1000EntriesMaxChildren010()", "[void]defaultRTreeSearchOf1000PointsMaxChildren010(Blackhole)", "[RTree<Object, Rectangle>]rStarTreeInsertOneEntryInto1000EntriesMaxChildren004()", "[RTree<Object, Rectangle>]rStarTreeInsertOneEntryInto1000EntriesMaxChildren010()", "[void]rStarTreeSearchOf1000PointsMaxChildren004(Blackhole)", "[void]rStarTreeSearchOf1000PointsMaxChildren010(Blackhole)", "[RTree<Object, Rectangle>]defaultRTreeInsertOneEntryInto1000EntriesMaxChildren032()", "[void]defaultRTreeSearchOf1000PointsMaxChildren032(Blackhole)", "[RTree<Object, Rectangle>]rStarTreeInsertOneEntryInto1000EntriesMaxChildren032()", "[void]rStarTreeSearchOf1000PointsMaxChildren032(Blackhole)", "[RTree<Object, Rectangle>]defaultRTreeInsertOneEntryInto1000EntriesMaxChildren128()", "[void]defaultRTreeSearchOf1000PointsMaxChildren128(Blackhole)", "[RTree<Object, Rectangle>]rStarTreeInsertOneEntryInto1000EntriesMaxChildren128()", "[void]rStarTreeSearchOf1000PointsMaxChildren128(Blackhole)", "[void]rStarTreeDeleteOneEveryOccurrenceFromGreekDataChildren010()", "[void]searchNearestGreek(Blackhole)", "[RTree<Object, Point>]deleteAll(RTree<Object, Point>)", "[void]search(RTree<Object, Rectangle>,Blackhole)", "[void]searchGreek(RTree<Object, Point>,Blackhole)", "[Action1<Object>]consumeWith(Blackhole)", "[void]searchGreekBackpressure(RTree<Object, Point>,Blackhole)", "[Rectangle]searchRectangle()", "[void]searchNearestGreek(RTree<Object, Point>,Blackhole)", "[void]searchGreekWithBackpressure(RTree<Object, Point>,Blackhole)", "[RTree<Object, Rectangle>]insertRectangle(RTree<Object, Rectangle>)", "[RTree<Object, Point>]insertPoint(RTree<Object, Point>)", "[void]main(String[])"], "method_uris": ["src/test/java/com/github/davidmoten/rtree/BenchmarksRTree.java.BenchmarksRTree.[RTree<Object, Point>]defaultRTreeInsertOneEntryIntoGreekDataEntriesMaxChildren004()", "src/test/java/com/github/davidmoten/rtree/BenchmarksRTree.java.BenchmarksRTree.[byte[]]createFlatBuffersByteArrayGreek()", "src/test/java/com/github/davidmoten/rtree/BenchmarksRTree.java.BenchmarksRTree.[RTree<Object, Point>]createFlatBuffersGreek()", "src/test/java/com/github/davidmoten/rtree/BenchmarksRTree.java.BenchmarksRTree.[RTree<Object, Point>]defaultRTreeCreation010()", "src/test/java/com/github/davidmoten/rtree/BenchmarksRTree.java.BenchmarksRTree.[RTree<Object, Point>]starRTreeCreation010()", "src/test/java/com/github/davidmoten/rtree/BenchmarksRTree.java.BenchmarksRTree.[RTree<Object, Point>]flatBufferRTreeCreation010()", "src/test/java/com/github/davidmoten/rtree/BenchmarksRTree.java.BenchmarksRTree.[RTree<Object, Point>]bulkLoadingRTreeCreation010()", "src/test/java/com/github/davidmoten/rtree/BenchmarksRTree.java.BenchmarksRTree.[RTree<Object, Point>]bulkLoadingFullRTreeCreation010()", "src/test/java/com/github/davidmoten/rtree/BenchmarksRTree.java.BenchmarksRTree.[void]defaultRTreeSearchOfGreekDataPointsMaxChildren004(Blackhole)", "src/test/java/com/github/davidmoten/rtree/BenchmarksRTree.java.BenchmarksRTree.[RTree<Object, Point>]defaultRTreeInsertOneEntryIntoGreekDataEntriesMaxChildren010()", "src/test/java/com/github/davidmoten/rtree/BenchmarksRTree.java.BenchmarksRTree.[void]defaultRTreeSearchOfGreekDataPointsMaxChildren010(Blackhole)", "src/test/java/com/github/davidmoten/rtree/BenchmarksRTree.java.BenchmarksRTree.[RTree<Object, Point>]rStarTreeInsertOneEntryIntoGreekDataEntriesMaxChildren004()", "src/test/java/com/github/davidmoten/rtree/BenchmarksRTree.java.BenchmarksRTree.[RTree<Object, Point>]rStarTreeInsertOneEntryIntoGreekDataEntriesMaxChildren010()", "src/test/java/com/github/davidmoten/rtree/BenchmarksRTree.java.BenchmarksRTree.[void]rStarTreeSearchOfGreekDataPointsMaxChildren004(Blackhole)", "src/test/java/com/github/davidmoten/rtree/BenchmarksRTree.java.BenchmarksRTree.[void]rStarTreeSearchOfGreekDataPointsMaxChildren010(Blackhole)", "src/test/java/com/github/davidmoten/rtree/BenchmarksRTree.java.BenchmarksRTree.[void]rStarTreeSearchOfGreekDataPointsMaxChildren010FlatBuffers(Blackhole)", "src/test/java/com/github/davidmoten/rtree/BenchmarksRTree.java.BenchmarksRTree.[void]rStarTreeSearchOfGreekDataPointsMaxChildren010FlatBuffersBackpressure(Blackhole)", "src/test/java/com/github/davidmoten/rtree/BenchmarksRTree.java.BenchmarksRTree.[void]rStarTreeSearchOfGreekDataPointsMaxChildren010WithBackpressure(Blackhole)", "src/test/java/com/github/davidmoten/rtree/BenchmarksRTree.java.BenchmarksRTree.[RTree<Object, Point>]defaultRTreeInsertOneEntryIntoGreekDataEntriesMaxChildren032()", "src/test/java/com/github/davidmoten/rtree/BenchmarksRTree.java.BenchmarksRTree.[void]defaultRTreeSearchOfGreekDataPointsMaxChildren032(Blackhole)", "src/test/java/com/github/davidmoten/rtree/BenchmarksRTree.java.BenchmarksRTree.[RTree<Object, Point>]rStarTreeInsertOneEntryIntoGreekDataEntriesMaxChildren032()", "src/test/java/com/github/davidmoten/rtree/BenchmarksRTree.java.BenchmarksRTree.[void]rStarTreeSearchOfGreekDataPointsMaxChildren032(Blackhole)", "src/test/java/com/github/davidmoten/rtree/BenchmarksRTree.java.BenchmarksRTree.[RTree<Object, Point>]defaultRTreeInsertOneEntryIntoGreekDataEntriesMaxChildren128()", "src/test/java/com/github/davidmoten/rtree/BenchmarksRTree.java.BenchmarksRTree.[void]defaultRTreeSearchOfGreekDataPointsMaxChildren128(Blackhole)", "src/test/java/com/github/davidmoten/rtree/BenchmarksRTree.java.BenchmarksRTree.[RTree<Object, Point>]rStarTreeInsertOneEntryIntoGreekDataEntriesMaxChildren128()", "src/test/java/com/github/davidmoten/rtree/BenchmarksRTree.java.BenchmarksRTree.[void]rStarTreeSearchOfGreekDataPointsMaxChildren128(Blackhole)", "src/test/java/com/github/davidmoten/rtree/BenchmarksRTree.java.BenchmarksRTree.[RTree<Object, Rectangle>]defaultRTreeInsertOneEntryInto1000EntriesMaxChildren004()", "src/test/java/com/github/davidmoten/rtree/BenchmarksRTree.java.BenchmarksRTree.[void]defaultRTreeSearchOf1000PointsMaxChildren004(Blackhole)", "src/test/java/com/github/davidmoten/rtree/BenchmarksRTree.java.BenchmarksRTree.[RTree<Object, Rectangle>]defaultRTreeInsertOneEntryInto1000EntriesMaxChildren010()", "src/test/java/com/github/davidmoten/rtree/BenchmarksRTree.java.BenchmarksRTree.[void]defaultRTreeSearchOf1000PointsMaxChildren010(Blackhole)", "src/test/java/com/github/davidmoten/rtree/BenchmarksRTree.java.BenchmarksRTree.[RTree<Object, Rectangle>]rStarTreeInsertOneEntryInto1000EntriesMaxChildren004()", "src/test/java/com/github/davidmoten/rtree/BenchmarksRTree.java.BenchmarksRTree.[RTree<Object, Rectangle>]rStarTreeInsertOneEntryInto1000EntriesMaxChildren010()", "src/test/java/com/github/davidmoten/rtree/BenchmarksRTree.java.BenchmarksRTree.[void]rStarTreeSearchOf1000PointsMaxChildren004(Blackhole)", "src/test/java/com/github/davidmoten/rtree/BenchmarksRTree.java.BenchmarksRTree.[void]rStarTreeSearchOf1000PointsMaxChildren010(Blackhole)", "src/test/java/com/github/davidmoten/rtree/BenchmarksRTree.java.BenchmarksRTree.[RTree<Object, Rectangle>]defaultRTreeInsertOneEntryInto1000EntriesMaxChildren032()", "src/test/java/com/github/davidmoten/rtree/BenchmarksRTree.java.BenchmarksRTree.[void]defaultRTreeSearchOf1000PointsMaxChildren032(Blackhole)", "src/test/java/com/github/davidmoten/rtree/BenchmarksRTree.java.BenchmarksRTree.[RTree<Object, Rectangle>]rStarTreeInsertOneEntryInto1000EntriesMaxChildren032()", "src/test/java/com/github/davidmoten/rtree/BenchmarksRTree.java.BenchmarksRTree.[void]rStarTreeSearchOf1000PointsMaxChildren032(Blackhole)", "src/test/java/com/github/davidmoten/rtree/BenchmarksRTree.java.BenchmarksRTree.[RTree<Object, Rectangle>]defaultRTreeInsertOneEntryInto1000EntriesMaxChildren128()", "src/test/java/com/github/davidmoten/rtree/BenchmarksRTree.java.BenchmarksRTree.[void]defaultRTreeSearchOf1000PointsMaxChildren128(Blackhole)", "src/test/java/com/github/davidmoten/rtree/BenchmarksRTree.java.BenchmarksRTree.[RTree<Object, Rectangle>]rStarTreeInsertOneEntryInto1000EntriesMaxChildren128()", "src/test/java/com/github/davidmoten/rtree/BenchmarksRTree.java.BenchmarksRTree.[void]rStarTreeSearchOf1000PointsMaxChildren128(Blackhole)", "src/test/java/com/github/davidmoten/rtree/BenchmarksRTree.java.BenchmarksRTree.[void]rStarTreeDeleteOneEveryOccurrenceFromGreekDataChildren010()", "src/test/java/com/github/davidmoten/rtree/BenchmarksRTree.java.BenchmarksRTree.[void]searchNearestGreek(Blackhole)", "src/test/java/com/github/davidmoten/rtree/BenchmarksRTree.java.BenchmarksRTree.[RTree<Object, Point>]deleteAll(RTree<Object, Point>)", "src/test/java/com/github/davidmoten/rtree/BenchmarksRTree.java.BenchmarksRTree.[void]search(RTree<Object, Rectangle>,Blackhole)", "src/test/java/com/github/davidmoten/rtree/BenchmarksRTree.java.BenchmarksRTree.[void]searchGreek(RTree<Object, Point>,Blackhole)", "src/test/java/com/github/davidmoten/rtree/BenchmarksRTree.java.BenchmarksRTree.[Action1<Object>]consumeWith(Blackhole)", "src/test/java/com/github/davidmoten/rtree/BenchmarksRTree.java.BenchmarksRTree.[void]searchGreekBackpressure(RTree<Object, Point>,Blackhole)", "src/test/java/com/github/davidmoten/rtree/BenchmarksRTree.java.BenchmarksRTree.[Rectangle]searchRectangle()", "src/test/java/com/github/davidmoten/rtree/BenchmarksRTree.java.BenchmarksRTree.[void]searchNearestGreek(RTree<Object, Point>,Blackhole)", "src/test/java/com/github/davidmoten/rtree/BenchmarksRTree.java.BenchmarksRTree.[void]searchGreekWithBackpressure(RTree<Object, Point>,Blackhole)", "src/test/java/com/github/davidmoten/rtree/BenchmarksRTree.java.BenchmarksRTree.[RTree<Object, Rectangle>]insertRectangle(RTree<Object, Rectangle>)", "src/test/java/com/github/davidmoten/rtree/BenchmarksRTree.java.BenchmarksRTree.[RTree<Object, Point>]insertPoint(RTree<Object, Point>)", "src/test/java/com/github/davidmoten/rtree/BenchmarksRTree.java.BenchmarksRTree.[void]main(String[])"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "@State(Scope.Benchmark)\npublic class BenchmarksRTree {\n\n    private final static Precision precision = Precision.DOUBLE;\n\n    private final List<Entry<Object, Point>> entries = GreekEarthquakes.entriesList(precision);\n\n    private final List<Entry<Object, Rectangle>> some = entries1000(precision);\n\n    private final RTree<Object, Point> defaultTreeM4 = RTree.maxChildren(4).<Object, Point> create()\n            .add(entries);\n\n    private final RTree<Object, Point> defaultTreeM10 = RTree.maxChildren(10)\n            .<Object, Point> create().add(entries);\n\n    private final RTree<Object, Point> starTreeM4 = RTree.maxChildren(4).star()\n            .<Object, Point> create().add(entries);\n\n    private final RTree<Object, Point> starTreeM10 = RTree.maxChildren(10).star()\n            .<Object, Point> create().add(entries);\n\n    private final RTree<Object, Point> defaultTreeM32 = RTree.maxChildren(32)\n            .<Object, Point> create().add(entries);\n\n    private final RTree<Object, Point> starTreeM32 = RTree.maxChildren(32).star()\n            .<Object, Point> create().add(entries);\n\n    private final RTree<Object, Point> defaultTreeM128 = RTree.maxChildren(128)\n            .<Object, Point> create().add(entries);\n\n    private final RTree<Object, Point> starTreeM128 = RTree.maxChildren(128).star()\n            .<Object, Point> create().add(entries);\n\n    private final RTree<Object, Rectangle> smallDefaultTreeM4 = RTree.maxChildren(4)\n            .<Object, Rectangle> create().add(some);\n\n    private final RTree<Object, Rectangle> smallDefaultTreeM10 = RTree.maxChildren(10)\n            .<Object, Rectangle> create().add(some);\n\n    private final RTree<Object, Rectangle> smallStarTreeM4 = RTree.maxChildren(4).star()\n            .<Object, Rectangle> create().add(some);\n\n    private final RTree<Object, Rectangle> smallStarTreeM10 = RTree.maxChildren(10).star()\n            .<Object, Rectangle> create().add(some);\n\n    private final RTree<Object, Rectangle> smallDefaultTreeM32 = RTree.maxChildren(32)\n            .<Object, Rectangle> create().add(some);\n\n    private final RTree<Object, Rectangle> smallStarTreeM32 = RTree.maxChildren(32).star()\n            .<Object, Rectangle> create().add(some);\n\n    private final RTree<Object, Rectangle> smallDefaultTreeM128 = RTree.maxChildren(128)\n            .<Object, Rectangle> create().add(some);\n\n    private final RTree<Object, Rectangle> smallStarTreeM128 = RTree.maxChildren(128).star()\n            .<Object, Rectangle> create().add(some);\n\n    private final byte[] byteArrayGreek = createFlatBuffersByteArrayGreek();\n\n    private final RTree<Object, Point> starTreeM10FlatBuffers = createFlatBuffersGreek();\n\n    @Benchmark\n    public RTree<Object, Point> defaultRTreeInsertOneEntryIntoGreekDataEntriesMaxChildren004() {\n        return insertPoint(defaultTreeM4);\n    }\n\n    private byte[] createFlatBuffersByteArrayGreek() {\n        RTree<Object, Point> tree = RTree.maxChildren(10).star().<Object, Point> create()\n                .add(entries);\n        final ByteArrayOutputStream os = new ByteArrayOutputStream();\n        Func1<Object, byte[]> serializer = new Func1<Object, byte[]>() {\n            @Override\n            public byte[] call(Object o) {\n                return new byte[0];\n            }\n        };\n        Func1<byte[], Object> deserializer = new Func1<byte[], Object>() {\n            @Override\n            public Object call(byte[] bytes) {\n                return null;\n            }\n        };\n        Serializer<Object, Point> fbSerializer = SerializerFlatBuffers.create(serializer,\n                deserializer);\n        try {\n            fbSerializer.write(tree, os);\n            os.close();\n            return os.toByteArray();\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    private RTree<Object, Point> createFlatBuffersGreek() {\n        Func1<Object, byte[]> serializer = new Func1<Object, byte[]>() {\n            @Override\n            public byte[] call(Object o) {\n                return new byte[0];\n            }\n        };\n        Func1<byte[], Object> deserializer = new Func1<byte[], Object>() {\n            @Override\n            public Object call(byte[] bytes) {\n                return null;\n            }\n        };\n        Serializer<Object, Point> fbSerializer = SerializerFlatBuffers.create(serializer,\n                deserializer);\n        try {\n            ByteArrayInputStream is = new ByteArrayInputStream(byteArrayGreek);\n            return fbSerializer.read(is, byteArrayGreek.length, InternalStructure.SINGLE_ARRAY);\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    @Benchmark\n    public RTree<Object, Point> defaultRTreeCreation010() {\n        return RTree.maxChildren(10).<Object, Point> create().add(entries);\n    }\n\n    @Benchmark\n    public RTree<Object, Point> starRTreeCreation010() {\n        return RTree.maxChildren(10).star().<Object, Point> create().add(entries);\n    }\n\n    @Benchmark\n    public RTree<Object, Point> flatBufferRTreeCreation010() {\n        return createFlatBuffersGreek();\n    }\n\n    @Benchmark\n    public RTree<Object, Point> bulkLoadingRTreeCreation010() {\n        return RTree.maxChildren(10).<Object, Point> create(entries);\n    }\n\n    @Benchmark\n    public RTree<Object, Point> bulkLoadingFullRTreeCreation010() {\n        return RTree.maxChildren(10).loadingFactor(1.0).<Object, Point> create(entries);\n    }\n\n    @Benchmark\n    public void defaultRTreeSearchOfGreekDataPointsMaxChildren004(Blackhole bh) {\n        searchGreek(defaultTreeM4, bh);\n    }\n\n    @Benchmark\n    public RTree<Object, Point> defaultRTreeInsertOneEntryIntoGreekDataEntriesMaxChildren010() {\n        return insertPoint(defaultTreeM10);\n    }\n\n    @Benchmark\n    public void defaultRTreeSearchOfGreekDataPointsMaxChildren010(Blackhole bh) {\n        searchGreek(defaultTreeM10, bh);\n    }\n\n    @Benchmark\n    public RTree<Object, Point> rStarTreeInsertOneEntryIntoGreekDataEntriesMaxChildren004() {\n        return insertPoint(starTreeM4);\n    }\n\n    @Benchmark\n    public RTree<Object, Point> rStarTreeInsertOneEntryIntoGreekDataEntriesMaxChildren010() {\n        return insertPoint(starTreeM10);\n    }\n\n    @Benchmark\n    public void rStarTreeSearchOfGreekDataPointsMaxChildren004(Blackhole bh) {\n        searchGreek(starTreeM4, bh);\n    }\n\n    @Benchmark\n    public void rStarTreeSearchOfGreekDataPointsMaxChildren010(Blackhole bh) {\n        searchGreek(starTreeM10, bh);\n    }\n\n    @Benchmark\n    public void rStarTreeSearchOfGreekDataPointsMaxChildren010FlatBuffers(Blackhole bh) {\n        searchGreek(starTreeM10FlatBuffers, bh);\n    }\n\n    @Benchmark\n    public void rStarTreeSearchOfGreekDataPointsMaxChildren010FlatBuffersBackpressure(\n            Blackhole bh) {\n        searchGreekBackpressure(starTreeM10FlatBuffers, bh);\n    }\n\n    @Benchmark\n    public void rStarTreeSearchOfGreekDataPointsMaxChildren010WithBackpressure(Blackhole bh) {\n        searchGreekWithBackpressure(starTreeM10, bh);\n    }\n\n    @Benchmark\n    public RTree<Object, Point> defaultRTreeInsertOneEntryIntoGreekDataEntriesMaxChildren032() {\n        return insertPoint(defaultTreeM32);\n    }\n\n    @Benchmark\n    public void defaultRTreeSearchOfGreekDataPointsMaxChildren032(Blackhole bh) {\n        searchGreek(defaultTreeM32, bh);\n    }\n\n    @Benchmark\n    public RTree<Object, Point> rStarTreeInsertOneEntryIntoGreekDataEntriesMaxChildren032() {\n        return insertPoint(starTreeM32);\n    }\n\n    @Benchmark\n    public void rStarTreeSearchOfGreekDataPointsMaxChildren032(Blackhole bh) {\n        searchGreek(starTreeM32, bh);\n    }\n\n    @Benchmark\n    public RTree<Object, Point> defaultRTreeInsertOneEntryIntoGreekDataEntriesMaxChildren128() {\n        return insertPoint(defaultTreeM128);\n    }\n\n    @Benchmark\n    public void defaultRTreeSearchOfGreekDataPointsMaxChildren128(Blackhole bh) {\n        searchGreek(defaultTreeM128, bh);\n    }\n\n    @Benchmark\n    public RTree<Object, Point> rStarTreeInsertOneEntryIntoGreekDataEntriesMaxChildren128() {\n        return insertPoint(starTreeM128);\n    }\n\n    @Benchmark\n    public void rStarTreeSearchOfGreekDataPointsMaxChildren128(Blackhole bh) {\n        searchGreek(starTreeM128, bh);\n    }\n\n    @Benchmark\n    public RTree<Object, Rectangle> defaultRTreeInsertOneEntryInto1000EntriesMaxChildren004() {\n        return insertRectangle(smallDefaultTreeM4);\n    }\n\n    @Benchmark\n    public void defaultRTreeSearchOf1000PointsMaxChildren004(Blackhole bh) {\n        search(smallDefaultTreeM4, bh);\n    }\n\n    @Benchmark\n    public RTree<Object, Rectangle> defaultRTreeInsertOneEntryInto1000EntriesMaxChildren010() {\n        return insertRectangle(smallDefaultTreeM10);\n    }\n\n    @Benchmark\n    public void defaultRTreeSearchOf1000PointsMaxChildren010(Blackhole bh) {\n        search(smallDefaultTreeM10, bh);\n    }\n\n    @Benchmark\n    public RTree<Object, Rectangle> rStarTreeInsertOneEntryInto1000EntriesMaxChildren004() {\n        return insertRectangle(smallStarTreeM4);\n    }\n\n    @Benchmark\n    public RTree<Object, Rectangle> rStarTreeInsertOneEntryInto1000EntriesMaxChildren010() {\n        return insertRectangle(smallStarTreeM10);\n    }\n\n    @Benchmark\n    public void rStarTreeSearchOf1000PointsMaxChildren004(Blackhole bh) {\n        search(smallStarTreeM4, bh);\n    }\n\n    @Benchmark\n    public void rStarTreeSearchOf1000PointsMaxChildren010(Blackhole bh) {\n        search(smallStarTreeM10, bh);\n    }\n\n    @Benchmark\n    public RTree<Object, Rectangle> defaultRTreeInsertOneEntryInto1000EntriesMaxChildren032() {\n        return insertRectangle(smallDefaultTreeM32);\n    }\n\n    @Benchmark\n    public void defaultRTreeSearchOf1000PointsMaxChildren032(Blackhole bh) {\n        search(smallDefaultTreeM32, bh);\n    }\n\n    @Benchmark\n    public RTree<Object, Rectangle> rStarTreeInsertOneEntryInto1000EntriesMaxChildren032() {\n        return insertRectangle(smallStarTreeM32);\n    }\n\n    @Benchmark\n    public void rStarTreeSearchOf1000PointsMaxChildren032(Blackhole bh) {\n        search(smallStarTreeM32, bh);\n    }\n\n    @Benchmark\n    public RTree<Object, Rectangle> defaultRTreeInsertOneEntryInto1000EntriesMaxChildren128() {\n        return insertRectangle(smallDefaultTreeM128);\n    }\n\n    @Benchmark\n    public void defaultRTreeSearchOf1000PointsMaxChildren128(Blackhole bh) {\n        search(smallDefaultTreeM128, bh);\n    }\n\n    @Benchmark\n    public RTree<Object, Rectangle> rStarTreeInsertOneEntryInto1000EntriesMaxChildren128() {\n        return insertRectangle(smallStarTreeM128);\n    }\n\n    @Benchmark\n    public void rStarTreeSearchOf1000PointsMaxChildren128(Blackhole bh) {\n        search(smallStarTreeM128, bh);\n    }\n\n    @Benchmark\n    public void rStarTreeDeleteOneEveryOccurrenceFromGreekDataChildren010() {\n        deleteAll(starTreeM10);\n    }\n\n    @Benchmark\n    public void searchNearestGreek(Blackhole bh) {\n        searchNearestGreek(starTreeM4, bh);\n    }\n\n    private RTree<Object, Point> deleteAll(RTree<Object, Point> tree) {\n        return tree.delete(entries.get(1000), true);\n    }\n\n    private void search(RTree<Object, Rectangle> tree, Blackhole bh) {\n        // returns 10 results\n        tree.search(Geometries.rectangle(500, 500, 630, 630)).subscribe(consumeWith(bh));\n    }\n\n    private void searchGreek(RTree<Object, Point> tree, Blackhole bh) {\n        // should return 22 results\n        tree.search(Geometries.rectangle(40, 27.0, 40.5, 27.5)).subscribe(consumeWith(bh));\n    }\n\n    private Action1<Object> consumeWith(final Blackhole bh) {\n        return new Action1<Object>() {\n\n            @Override\n            public void call(Object t) {\n                bh.consume(t);\n            }\n        };\n    }\n\n    private void searchGreekBackpressure(RTree<Object, Point> tree, Blackhole bh) {\n        // should return 22 results\n        final Rectangle r = searchRectangle();\n        tree.search(r).take(1000).subscribe(consumeWith(bh));\n    }\n\n    private static Rectangle searchRectangle() {\n        final Rectangle r;\n        if (precision == Precision.DOUBLE) {\n            r = Geometries.rectangle(40, 27.0, 40.5, 27.5);\n        } else {\n            r = Geometries.rectangle(40f, 27.0f, 40.5f, 27.5f);\n        }\n        return r;\n    }\n\n    private void searchNearestGreek(RTree<Object, Point> tree, Blackhole bh) {\n        final Point p;\n        if (precision == Precision.DOUBLE) {\n            p = Geometries.point(40.0, 27.0);\n        } else {\n            p = Geometries.point(40.0f, 27.0f);\n        }\n        tree.nearest(p, 1, 300).subscribe(consumeWith(bh));\n    }\n\n    private void searchGreekWithBackpressure(RTree<Object, Point> tree, final Blackhole bh) {\n        // should return 22 results\n        tree.search(searchRectangle()).subscribe(new Subscriber<Object>() {\n\n            @Override\n            public void onStart() {\n                request(1);\n            }\n\n            @Override\n            public void onCompleted() {\n\n            }\n\n            @Override\n            public void onError(Throwable arg0) {\n\n            }\n\n            @Override\n            public void onNext(Object t) {\n                request(1);\n                bh.consume(t);\n            }\n        });\n    }\n\n    private RTree<Object, Rectangle> insertRectangle(RTree<Object, Rectangle> tree) {\n        return tree.add(new Object(), RTreeTest.random(precision));\n    }\n\n    private RTree<Object, Point> insertPoint(RTree<Object, Point> tree) {\n        if (precision == Precision.DOUBLE) {\n            return tree.add(new Object(),\n                    Geometries.point(Math.random() * 1000, Math.random() * 1000));\n        } else {\n            return tree.add(new Object(),\n                    Geometries.point((float) Math.random() * 1000, (float) Math.random() * 1000));\n        }\n    }\n\n    public static void main(String[] args) {\n        BenchmarksRTree b = new BenchmarksRTree();\n        System.out.println(\"starting searches\");\n        while (true)\n            b.starTreeM4.search(searchRectangle()).subscribe();\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private final static Precision precision = Precision.DOUBLE;", "docstring": "", "modifiers": "private final static", "marker_annotations": [], "non_marker_annotations": ["private", "final", "static"], "comments": [], "type": "Precision", "name": "precision = Precision.DOUBLE", "syntax_pass": true}, {"attribute_expression": "private final List<Entry<Object, Point>> entries = GreekEarthquakes.entriesList(precision);", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "List<Entry<Object, Point>>", "name": "entries = GreekEarthquakes.entriesList(precision)", "syntax_pass": true}, {"attribute_expression": "private final List<Entry<Object, Rectangle>> some = entries1000(precision);", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "List<Entry<Object, Rectangle>>", "name": "some = entries1000(precision)", "syntax_pass": true}, {"attribute_expression": "private final RTree<Object, Point> defaultTreeM4 = RTree.maxChildren(4).<Object, Point> create()\n            .add(entries);", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "RTree<Object, Point>", "name": "defaultTreeM4 = RTree.maxChildren(4).<Object, Point> create()\n            .add(entries)", "syntax_pass": true}, {"attribute_expression": "private final RTree<Object, Point> defaultTreeM10 = RTree.maxChildren(10)\n            .<Object, Point> create().add(entries);", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "RTree<Object, Point>", "name": "defaultTreeM10 = RTree.maxChildren(10)\n            .<Object, Point> create().add(entries)", "syntax_pass": true}, {"attribute_expression": "private final RTree<Object, Point> starTreeM4 = RTree.maxChildren(4).star()\n            .<Object, Point> create().add(entries);", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "RTree<Object, Point>", "name": "starTreeM4 = RTree.maxChildren(4).star()\n            .<Object, Point> create().add(entries)", "syntax_pass": true}, {"attribute_expression": "private final RTree<Object, Point> starTreeM10 = RTree.maxChildren(10).star()\n            .<Object, Point> create().add(entries);", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "RTree<Object, Point>", "name": "starTreeM10 = RTree.maxChildren(10).star()\n            .<Object, Point> create().add(entries)", "syntax_pass": true}, {"attribute_expression": "private final RTree<Object, Point> defaultTreeM32 = RTree.maxChildren(32)\n            .<Object, Point> create().add(entries);", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "RTree<Object, Point>", "name": "defaultTreeM32 = RTree.maxChildren(32)\n            .<Object, Point> create().add(entries)", "syntax_pass": true}, {"attribute_expression": "private final RTree<Object, Point> starTreeM32 = RTree.maxChildren(32).star()\n            .<Object, Point> create().add(entries);", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "RTree<Object, Point>", "name": "starTreeM32 = RTree.maxChildren(32).star()\n            .<Object, Point> create().add(entries)", "syntax_pass": true}, {"attribute_expression": "private final RTree<Object, Point> defaultTreeM128 = RTree.maxChildren(128)\n            .<Object, Point> create().add(entries);", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "RTree<Object, Point>", "name": "defaultTreeM128 = RTree.maxChildren(128)\n            .<Object, Point> create().add(entries)", "syntax_pass": true}, {"attribute_expression": "private final RTree<Object, Point> starTreeM128 = RTree.maxChildren(128).star()\n            .<Object, Point> create().add(entries);", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "RTree<Object, Point>", "name": "starTreeM128 = RTree.maxChildren(128).star()\n            .<Object, Point> create().add(entries)", "syntax_pass": true}, {"attribute_expression": "private final RTree<Object, Rectangle> smallDefaultTreeM4 = RTree.maxChildren(4)\n            .<Object, Rectangle> create().add(some);", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "RTree<Object, Rectangle>", "name": "smallDefaultTreeM4 = RTree.maxChildren(4)\n            .<Object, Rectangle> create().add(some)", "syntax_pass": true}, {"attribute_expression": "private final RTree<Object, Rectangle> smallDefaultTreeM10 = RTree.maxChildren(10)\n            .<Object, Rectangle> create().add(some);", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "RTree<Object, Rectangle>", "name": "smallDefaultTreeM10 = RTree.maxChildren(10)\n            .<Object, Rectangle> create().add(some)", "syntax_pass": true}, {"attribute_expression": "private final RTree<Object, Rectangle> smallStarTreeM4 = RTree.maxChildren(4).star()\n            .<Object, Rectangle> create().add(some);", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "RTree<Object, Rectangle>", "name": "smallStarTreeM4 = RTree.maxChildren(4).star()\n            .<Object, Rectangle> create().add(some)", "syntax_pass": true}, {"attribute_expression": "private final RTree<Object, Rectangle> smallStarTreeM10 = RTree.maxChildren(10).star()\n            .<Object, Rectangle> create().add(some);", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "RTree<Object, Rectangle>", "name": "smallStarTreeM10 = RTree.maxChildren(10).star()\n            .<Object, Rectangle> create().add(some)", "syntax_pass": true}, {"attribute_expression": "private final RTree<Object, Rectangle> smallDefaultTreeM32 = RTree.maxChildren(32)\n            .<Object, Rectangle> create().add(some);", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "RTree<Object, Rectangle>", "name": "smallDefaultTreeM32 = RTree.maxChildren(32)\n            .<Object, Rectangle> create().add(some)", "syntax_pass": true}, {"attribute_expression": "private final RTree<Object, Rectangle> smallStarTreeM32 = RTree.maxChildren(32).star()\n            .<Object, Rectangle> create().add(some);", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "RTree<Object, Rectangle>", "name": "smallStarTreeM32 = RTree.maxChildren(32).star()\n            .<Object, Rectangle> create().add(some)", "syntax_pass": true}, {"attribute_expression": "private final RTree<Object, Rectangle> smallDefaultTreeM128 = RTree.maxChildren(128)\n            .<Object, Rectangle> create().add(some);", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "RTree<Object, Rectangle>", "name": "smallDefaultTreeM128 = RTree.maxChildren(128)\n            .<Object, Rectangle> create().add(some)", "syntax_pass": true}, {"attribute_expression": "private final RTree<Object, Rectangle> smallStarTreeM128 = RTree.maxChildren(128).star()\n            .<Object, Rectangle> create().add(some);", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "RTree<Object, Rectangle>", "name": "smallStarTreeM128 = RTree.maxChildren(128).star()\n            .<Object, Rectangle> create().add(some)", "syntax_pass": true}, {"attribute_expression": "private final byte[] byteArrayGreek = createFlatBuffersByteArrayGreek();", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "byte[]", "name": "byteArrayGreek = createFlatBuffersByteArrayGreek()", "syntax_pass": true}, {"attribute_expression": "private final RTree<Object, Point> starTreeM10FlatBuffers = createFlatBuffersGreek();", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "RTree<Object, Point>", "name": "starTreeM10FlatBuffers = createFlatBuffersGreek()", "syntax_pass": true}]}, {"uris": "src/test/java/com/github/davidmoten/rtree/Utilities.java.Utilities", "name": "Utilities", "file_path": "src/test/java/com/github/davidmoten/rtree/Utilities.java", "superclasses": "", "methods": ["[List<Entry<Object, Rectangle>>]entries1000(Precision)"], "method_uris": ["src/test/java/com/github/davidmoten/rtree/Utilities.java.Utilities.[List<Entry<Object, Rectangle>>]entries1000(Precision)"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class Utilities {\n\n    static List<Entry<Object, Rectangle>> entries1000(Precision precision) {\n        List<Entry<Object, Rectangle>> list = new ArrayList<Entry<Object, Rectangle>>();\n        BufferedReader br = new BufferedReader(\n                new InputStreamReader(BenchmarksRTree.class.getResourceAsStream(\"/1000.txt\")));\n        String line;\n        try {\n            while ((line = br.readLine()) != null) {\n                String[] items = line.split(\" \");\n                double x = Double.parseDouble(items[0]);\n                double y = Double.parseDouble(items[1]);\n                Entry<Object, Rectangle> entry;\n                if (precision == Precision.DOUBLE)\n                    entry = Entries.entry(new Object(), Geometries.rectangle(x, y, x + 1, y + 1));\n                else\n                    entry = Entries.entry(new Object(), Geometries.rectangle((float) x, (float) y,\n                            (float) x + 1, (float) y + 1));\n                list.add(entry);\n            }\n            br.close();\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n        return list;\n    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/com/github/davidmoten/rtree/GalleryMain.java.GalleryMain", "name": "GalleryMain", "file_path": "src/test/java/com/github/davidmoten/rtree/GalleryMain.java", "superclasses": "", "methods": ["[void]main(String[])"], "method_uris": ["src/test/java/com/github/davidmoten/rtree/GalleryMain.java.GalleryMain.[void]main(String[])"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class GalleryMain {\n\n    public static void main(String[] args) {\n        Observable<Entry<Object, Point>> entries = GreekEarthquakes.entries(Precision.DOUBLE)\n                .cache();\n\n        List<Integer> sizes = Arrays.asList(100, 1000, 10000, 1000000);\n        List<Integer> maxChildrenValues = Arrays.asList(4, 8, 16, 32, 64, 128);\n        for (int size : sizes)\n            for (int maxChildren : maxChildrenValues) {\n                if (size > maxChildren) {\n                    System.out.println(\"saving \" + size + \" m=\" + maxChildren);\n                    RTree<Object, Point> tree = RTree.maxChildren(maxChildren)\n                            .<Object, Point>create().add(entries.take(size)).last().toBlocking()\n                            .single();\n                    tree.visualize(600, 600)\n                            .save(\"target/greek-\" + size + \"-\" + maxChildren + \"-quad.png\");\n                    RTree<Object, Point> tree2 = RTree.star().maxChildren(maxChildren)\n                            .<Object, Point>create().add(entries.take(size)).last().toBlocking()\n                            .single();\n                    tree2.visualize(600, 600)\n                            .save(\"target/greek-\" + size + \"-\" + maxChildren + \"-star.png\");\n                }\n            }\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/com/github/davidmoten/rtree/Mbr.java.Mbr", "name": "Mbr", "file_path": "src/test/java/com/github/davidmoten/rtree/Mbr.java", "superclasses": "", "methods": ["[]Mbr(Rectangle)", "[Geometry]geometry()"], "method_uris": ["src/test/java/com/github/davidmoten/rtree/Mbr.java.Mbr.[]Mbr(Rectangle)", "src/test/java/com/github/davidmoten/rtree/Mbr.java.Mbr.[Geometry]geometry()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class Mbr implements HasGeometry {\n\n    private final Rectangle r;\n\n    public Mbr(Rectangle r) {\n        this.r = r;\n    }\n\n    @Override\n    public Geometry geometry() {\n        return r;\n    }\n\n}", "super_interfaces": ["HasGeometry"], "fields": [{"attribute_expression": "private final Rectangle r;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Rectangle", "name": "r", "syntax_pass": true}]}, {"uris": "src/test/java/com/github/davidmoten/rtree/StringSplitTest.java.StringSplitTest", "name": "StringSplitTest", "file_path": "src/test/java/com/github/davidmoten/rtree/StringSplitTest.java", "superclasses": "", "methods": ["[void]testSplitOnEmptyStream()", "[void]testSplitOnStreamThatThrowsExceptionImmediately()"], "method_uris": ["src/test/java/com/github/davidmoten/rtree/StringSplitTest.java.StringSplitTest.[void]testSplitOnEmptyStream()", "src/test/java/com/github/davidmoten/rtree/StringSplitTest.java.StringSplitTest.[void]testSplitOnStreamThatThrowsExceptionImmediately()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class StringSplitTest {\n\n    // TODO remove this when 0.22.0 released\n    // @Test\n    public void testSplitOnEmptyStream() {\n        assertEquals(0, (int) StringObservable.split(Observable.<String> empty(), \"\\n\").count()\n                .toBlocking().single());\n    }\n\n    // TODO remove thiese when 0.22 released of rxjava-string\n    // @Test\n    public void testSplitOnStreamThatThrowsExceptionImmediately() {\n        RuntimeException ex = new RuntimeException(\"boo\");\n        try {\n            StringObservable.split(Observable.<String> error(ex), \"\\n\").count().toBlocking()\n                    .single();\n            fail();\n        } catch (RuntimeException e) {\n            assertEquals(ex, e);\n        }\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/main/java/com/github/davidmoten/rtree/SelectorRStar.java.SelectorRStar", "name": "SelectorRStar", "file_path": "src/main/java/com/github/davidmoten/rtree/SelectorRStar.java", "superclasses": "", "methods": ["[Node<T, S>]select(Geometry,List<? extends Node<T, S>>)"], "method_uris": ["src/main/java/com/github/davidmoten/rtree/SelectorRStar.java.SelectorRStar.[Node<T, S>]select(Geometry,List<? extends Node<T, S>>)"], "overrides": null, "attributes": [], "class_docstring": "\nUses minimal overlap area selector for leaf nodes and minimal areea increase\nselector for non-leaf nodes.\n", "original_string": "public final class SelectorRStar implements Selector {\n\n    private static Selector overlapAreaSelector = new SelectorMinimalOverlapArea();\n    private static Selector areaIncreaseSelector = new SelectorMinimalAreaIncrease();\n\n    @Override\n    public <T, S extends Geometry> Node<T, S> select(Geometry g, List<? extends Node<T, S>> nodes) {\n        boolean leafNodes = nodes.get(0) instanceof Leaf;\n        if (leafNodes)\n            return overlapAreaSelector.select(g, nodes);\n        else\n            return areaIncreaseSelector.select(g, nodes);\n    }\n\n}", "super_interfaces": ["Selector"], "fields": [{"attribute_expression": "private static Selector overlapAreaSelector = new SelectorMinimalOverlapArea();", "docstring": "", "modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "type": "Selector", "name": "overlapAreaSelector = new SelectorMinimalOverlapArea()", "syntax_pass": true}, {"attribute_expression": "private static Selector areaIncreaseSelector = new SelectorMinimalAreaIncrease();", "docstring": "", "modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "type": "Selector", "name": "areaIncreaseSelector = new SelectorMinimalAreaIncrease()", "syntax_pass": true}]}, {"uris": "src/main/java/com/github/davidmoten/rtree/SelectorMinimalOverlapArea.java.SelectorMinimalOverlapArea", "name": "SelectorMinimalOverlapArea", "file_path": "src/main/java/com/github/davidmoten/rtree/SelectorMinimalOverlapArea.java", "superclasses": "", "methods": ["[Node<T, S>]select(Geometry,List<? extends Node<T, S>>)"], "method_uris": ["src/main/java/com/github/davidmoten/rtree/SelectorMinimalOverlapArea.java.SelectorMinimalOverlapArea.[Node<T, S>]select(Geometry,List<? extends Node<T, S>>)"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public final class SelectorMinimalOverlapArea implements Selector {\n\n    @Override\n    public <T, S extends Geometry> Node<T, S> select(Geometry g, List<? extends Node<T, S>> nodes) {\n        return min(nodes,\n                Comparators.overlapAreaThenAreaIncreaseThenAreaComparator(g.mbr(), nodes));\n    }\n\n}", "super_interfaces": ["Selector"], "fields": []}, {"uris": "src/main/java/com/github/davidmoten/rtree/NodePosition.java.NodePosition", "name": "NodePosition", "file_path": "src/main/java/com/github/davidmoten/rtree/NodePosition.java", "superclasses": "", "methods": ["[]NodePosition(Node<T, S>,int)", "[Node<T, S>]node()", "[int]position()", "[NodePosition<T, S>]nextPosition()", "[String]toString()"], "method_uris": ["src/main/java/com/github/davidmoten/rtree/NodePosition.java.NodePosition.[]NodePosition(Node<T, S>,int)", "src/main/java/com/github/davidmoten/rtree/NodePosition.java.NodePosition.[Node<T, S>]node()", "src/main/java/com/github/davidmoten/rtree/NodePosition.java.NodePosition.[int]position()", "src/main/java/com/github/davidmoten/rtree/NodePosition.java.NodePosition.[NodePosition<T, S>]nextPosition()", "src/main/java/com/github/davidmoten/rtree/NodePosition.java.NodePosition.[String]toString()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "final class NodePosition<T, S extends Geometry> {\n\n    private final Node<T, S> node;\n    private final int position;\n\n    NodePosition(Node<T, S> node, int position) {\n        Preconditions.checkNotNull(node);\n        this.node = node;\n        this.position = position;\n    }\n\n    Node<T, S> node() {\n        return node;\n    }\n\n    int position() {\n        return position;\n    }\n\n    NodePosition<T, S> nextPosition() {\n        return new NodePosition<T, S>(node, position + 1);\n    }\n\n    @Override\n    public String toString() {\n        String builder = \"NodePosition [node=\" +\n                node +\n                \", position=\" +\n                position +\n                \"]\";\n        return builder;\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private final Node<T, S> node;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Node<T, S>", "name": "node", "syntax_pass": true}, {"attribute_expression": "private final int position;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "int", "name": "position", "syntax_pass": true}]}, {"uris": "src/main/java/com/github/davidmoten/rtree/Visualizer.java.Visualizer", "name": "Visualizer", "file_path": "src/main/java/com/github/davidmoten/rtree/Visualizer.java", "superclasses": "", "methods": ["[]Visualizer(RTree<?, Geometry>,int,int,Rectangle)", "[int]calculateMaxDepth(Optional<? extends Node<R, S>>)", "[int]calculateDepth(Node<R, S>,int)", "[BufferedImage]createImage()", "[List<RectangleDepth>]getNodeDepthsSortedByDepth(Node<T, S>)", "[List<RectangleDepth>]getRectangleDepths(Node<T, S>,int)", "[void]drawNode(Graphics2D,List<RectangleDepth>)", "[void]drawRectangle(Graphics2D,Rectangle)", "[int]rnd(double)", "[void]save(File,String)", "[void]save(String,String)", "[void]save(String)"], "method_uris": ["src/main/java/com/github/davidmoten/rtree/Visualizer.java.Visualizer.[]Visualizer(RTree<?, Geometry>,int,int,Rectangle)", "src/main/java/com/github/davidmoten/rtree/Visualizer.java.Visualizer.[int]calculateMaxDepth(Optional<? extends Node<R, S>>)", "src/main/java/com/github/davidmoten/rtree/Visualizer.java.Visualizer.[int]calculateDepth(Node<R, S>,int)", "src/main/java/com/github/davidmoten/rtree/Visualizer.java.Visualizer.[BufferedImage]createImage()", "src/main/java/com/github/davidmoten/rtree/Visualizer.java.Visualizer.[List<RectangleDepth>]getNodeDepthsSortedByDepth(Node<T, S>)", "src/main/java/com/github/davidmoten/rtree/Visualizer.java.Visualizer.[List<RectangleDepth>]getRectangleDepths(Node<T, S>,int)", "src/main/java/com/github/davidmoten/rtree/Visualizer.java.Visualizer.[void]drawNode(Graphics2D,List<RectangleDepth>)", "src/main/java/com/github/davidmoten/rtree/Visualizer.java.Visualizer.[void]drawRectangle(Graphics2D,Rectangle)", "src/main/java/com/github/davidmoten/rtree/Visualizer.java.Visualizer.[int]rnd(double)", "src/main/java/com/github/davidmoten/rtree/Visualizer.java.Visualizer.[void]save(File,String)", "src/main/java/com/github/davidmoten/rtree/Visualizer.java.Visualizer.[void]save(String,String)", "src/main/java/com/github/davidmoten/rtree/Visualizer.java.Visualizer.[void]save(String)"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public final class Visualizer {\n\n    private final RTree<?, Geometry> tree;\n    private final int width;\n    private final int height;\n    private final Rectangle view;\n    private final int maxDepth;\n\n    Visualizer(RTree<?, Geometry> tree, int width, int height, Rectangle view) {\n        this.tree = tree;\n        this.width = width;\n        this.height = height;\n        this.view = view;\n        this.maxDepth = calculateMaxDepth(tree.root());\n    }\n\n    private static <R, S extends Geometry> int calculateMaxDepth(\n            Optional<? extends Node<R, S>> root) {\n        if (!root.isPresent()) {\n            return 0;\n        } else {\n            return calculateDepth(root.get(), 0);\n        }\n    }\n\n    private static <R, S extends Geometry> int calculateDepth(Node<R, S> node, int depth) {\n        if (node instanceof Leaf) {\n            return depth + 1;\n        } else {\n            return calculateDepth(((NonLeaf<R, S>) node).child(0), depth + 1);\n        }\n    }\n\n    public BufferedImage createImage() {\n        final BufferedImage image = new BufferedImage(width, height, BufferedImage.TYPE_INT_ARGB);\n        final Graphics2D g = (Graphics2D) image.getGraphics();\n        g.setBackground(Color.white);\n        g.clearRect(0, 0, width, height);\n        g.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, 0.75f));\n\n        if (tree.root().isPresent()) {\n            final List<RectangleDepth> nodeDepths = getNodeDepthsSortedByDepth(tree.root().get());\n            drawNode(g, nodeDepths);\n        }\n        return image;\n    }\n\n    private <T, S extends Geometry> List<RectangleDepth> getNodeDepthsSortedByDepth(\n            Node<T, S> root) {\n        final List<RectangleDepth> list = getRectangleDepths(root, 0);\n        list.sort(Comparator.comparing(RectangleDepth::getDepth));\n        return list;\n    }\n\n    private <T, S extends Geometry> List<RectangleDepth> getRectangleDepths(Node<T, S> node,\n            int depth) {\n        final List<RectangleDepth> list = new ArrayList<RectangleDepth>();\n        list.add(new RectangleDepth(node.geometry().mbr(), depth));\n        if (node instanceof Leaf) {\n            final Leaf<T, S> leaf = (Leaf<T, S>) node;\n            for (final Entry<T, S> entry : leaf.entries()) {\n                list.add(new RectangleDepth(entry.geometry().mbr(), depth + 2));\n            }\n        } else {\n            final NonLeaf<T, S> n = (NonLeaf<T, S>) node;\n            for (int i = 0; i < n.count(); i++) {\n                list.addAll(getRectangleDepths(n.child(i), depth + 1));\n            }\n        }\n        return list;\n    }\n\n    private void drawNode(Graphics2D g, List<RectangleDepth> nodes) {\n        for (final RectangleDepth node : nodes) {\n            final Color color = Color.getHSBColor(node.getDepth() / (maxDepth + 1f), 1f, 1f);\n            g.setStroke(new BasicStroke(Math.max(0.5f, maxDepth - node.getDepth() + 1 - 1)));\n            g.setColor(color);\n            final Rectangle r = node.getRectangle();\n            drawRectangle(g, r);\n        }\n    }\n\n    private void drawRectangle(Graphics2D g, Rectangle r) {\n        final double x1 = (r.x1() - view.x1()) / (view.x2() - view.x1()) * width;\n        final double y1 = (r.y1() - view.y1()) / (view.y2() - view.y1()) * height;\n        final double x2 = (r.x2() - view.x1()) / (view.x2() - view.x1()) * width;\n        final double y2 = (r.y2() - view.y1()) / (view.y2() - view.y1()) * height;\n        g.drawRect(rnd(x1), rnd(y1), Math.max(rnd(x2 - x1), 1), Math.max(rnd(y2 - y1), 1));\n    }\n\n    private static int rnd(double d) {\n        return (int) Math.round(d);\n    }\n\n    public void save(File file, String imageFormat) {\n        ImageSaver.save(createImage(), file, imageFormat);\n    }\n\n    public void save(String filename, String imageFormat) {\n        save(new File(filename), imageFormat);\n    }\n\n    public void save(String filename) {\n        save(new File(filename), \"PNG\");\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private final RTree<?, Geometry> tree;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "RTree<?, Geometry>", "name": "tree", "syntax_pass": true}, {"attribute_expression": "private final int width;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "int", "name": "width", "syntax_pass": true}, {"attribute_expression": "private final int height;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "int", "name": "height", "syntax_pass": true}, {"attribute_expression": "private final Rectangle view;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Rectangle", "name": "view", "syntax_pass": true}, {"attribute_expression": "private final int maxDepth;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "int", "name": "maxDepth", "syntax_pass": true}]}, {"uris": "src/main/java/com/github/davidmoten/rtree/Serializers.java.Serializers", "name": "Serializers", "file_path": "src/main/java/com/github/davidmoten/rtree/Serializers.java", "superclasses": "", "methods": ["[]Serializers()", "[SerializerBuilder]flatBuffers()", "[Func1<String, byte[]>]createStringSerializer(Charset)", "[Func1<byte[], String>]createStringDeserializer(Charset)", "[Func1<Serializable, byte[]>]javaIoSerializer()", "[Func1<byte[], Serializable>]javaIoDeserializer()"], "method_uris": ["src/main/java/com/github/davidmoten/rtree/Serializers.java.Serializers.[]Serializers()", "src/main/java/com/github/davidmoten/rtree/Serializers.java.Serializers.[SerializerBuilder]flatBuffers()", "src/main/java/com/github/davidmoten/rtree/Serializers.java.Serializers.[Func1<String, byte[]>]createStringSerializer(Charset)", "src/main/java/com/github/davidmoten/rtree/Serializers.java.Serializers.[Func1<byte[], String>]createStringDeserializer(Charset)", "src/main/java/com/github/davidmoten/rtree/Serializers.java.Serializers.[Func1<Serializable, byte[]>]javaIoSerializer()", "src/main/java/com/github/davidmoten/rtree/Serializers.java.Serializers.[Func1<byte[], Serializable>]javaIoDeserializer()"], "overrides": null, "attributes": [{"original_string": "    public static class SerializerBuilder {\n\n        private Method method = Method.FLATBUFFERS;\n\n        private SerializerBuilder() {\n\n        }\n\n        public <T> SerializerTypedBuilder<T> serializer(Func1<? super T, byte[]> serializer) {\n            return new SerializerTypedBuilder<T>(serializer, null, method);\n        }\n\n        public <T> SerializerTypedBuilder<T> deserializer(Func1<byte[], ? extends T> deserializer) {\n            return new SerializerTypedBuilder<T>(null, deserializer, method);\n        }\n\n        public <S extends Geometry> Serializer<String, S> string(Charset charset) {\n            Func1<String, byte[]> serializer = createStringSerializer(charset);\n            Func1<byte[], String> deserializer = createStringDeserializer(charset);\n            return new SerializerTypedBuilder<String>(serializer, deserializer, method).create();\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        public <T extends Serializable, S extends Geometry> Serializer<T, S> javaIo() {\n            Func1<T, byte[]> serializer = (Func1<T, byte[]>) javaIoSerializer();\n            Func1<byte[], T> deserializer = (Func1<byte[], T>) javaIoDeserializer();\n            return new SerializerTypedBuilder<T>(serializer, deserializer, method).create();\n        }\n\n        public <S extends Geometry> Serializer<String, S> utf8() {\n            return string(Charset.forName(\"UTF-8\"));\n        }\n\n        public <S extends Geometry> Serializer<byte[], S> bytes() {\n            Func1<byte[], byte[]> serializer = Functions.identity();\n            Func1<byte[], byte[]> deserializer = Functions.identity();\n            return new SerializerTypedBuilder<byte[]>(serializer, deserializer, method).create();\n        }\n\n        public SerializerBuilder method(Method method) {\n            this.method = method;\n            return this;\n        }\n\n    }", "definition": "    public static class SerializerBuilder", "class_docstring": "", "name": "SerializerBuilder", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [{"attribute_expression": "private Method method = Method.FLATBUFFERS;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Method", "name": "method = Method.FLATBUFFERS", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        private SerializerBuilder() {\n\n        }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "", "classes": []}, "name": "SerializerBuilder", "params": [], "body": "                                    {\n\n        }", "signature": "private SerializerBuilder()"}, {"syntax_pass": true, "original_string": "        public <T> SerializerTypedBuilder<T> serializer(Func1<? super T, byte[]> serializer) {\n            return new SerializerTypedBuilder<T>(serializer, null, method);\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "SerializerTypedBuilder<T>", "classes": []}, "name": "serializer", "params": [{"name": "serializer", "type": "Func1<? super T, byte[]>"}], "body": "                                                                                             {\n            return new SerializerTypedBuilder<T>(serializer, null, method);\n        }", "signature": "public <T> SerializerTypedBuilder<T> serializer(Func1<? super T, byte[]> serializer)"}, {"syntax_pass": true, "original_string": "        public <T> SerializerTypedBuilder<T> deserializer(Func1<byte[], ? extends T> deserializer) {\n            return new SerializerTypedBuilder<T>(null, deserializer, method);\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "SerializerTypedBuilder<T>", "classes": []}, "name": "deserializer", "params": [{"name": "deserializer", "type": "Func1<byte[], ? extends T>"}], "body": "                                                                                                   {\n            return new SerializerTypedBuilder<T>(null, deserializer, method);\n        }", "signature": "public <T> SerializerTypedBuilder<T> deserializer(Func1<byte[], ? extends T> deserializer)"}, {"syntax_pass": true, "original_string": "        public <S extends Geometry> Serializer<String, S> string(Charset charset) {\n            Func1<String, byte[]> serializer = createStringSerializer(charset);\n            Func1<byte[], String> deserializer = createStringDeserializer(charset);\n            return new SerializerTypedBuilder<String>(serializer, deserializer, method).create();\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Serializer<String, S>", "classes": []}, "name": "string", "params": [{"name": "charset", "type": "Charset"}], "body": "                                                                                  {\n            Func1<String, byte[]> serializer = createStringSerializer(charset);\n            Func1<byte[], String> deserializer = createStringDeserializer(charset);\n            return new SerializerTypedBuilder<String>(serializer, deserializer, method).create();\n        }", "signature": "public <S extends Geometry> Serializer<String, S> string(Charset charset)"}, {"syntax_pass": true, "original_string": "        @SuppressWarnings(\"unchecked\")\n        public <T extends Serializable, S extends Geometry> Serializer<T, S> javaIo() {\n            Func1<T, byte[]> serializer = (Func1<T, byte[]>) javaIoSerializer();\n            Func1<byte[], T> deserializer = (Func1<byte[], T>) javaIoDeserializer();\n            return new SerializerTypedBuilder<T>(serializer, deserializer, method).create();\n        }", "docstring": "", "attributes": {"modifiers": "@SuppressWarnings(\"unchecked\")\n        public", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings(\"unchecked\")", "public"], "comments": [], "return_type": "Serializer<T, S>", "classes": []}, "name": "javaIo", "params": [], "body": "                                                                                      {\n            Func1<T, byte[]> serializer = (Func1<T, byte[]>) javaIoSerializer();\n            Func1<byte[], T> deserializer = (Func1<byte[], T>) javaIoDeserializer();\n            return new SerializerTypedBuilder<T>(serializer, deserializer, method).create();\n        }", "signature": "@SuppressWarnings(\"unchecked\")\n        public <T extends Serializable, S extends Geometry> Serializer<T, S> javaIo()"}, {"syntax_pass": true, "original_string": "        public <S extends Geometry> Serializer<String, S> utf8() {\n            return string(Charset.forName(\"UTF-8\"));\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Serializer<String, S>", "classes": []}, "name": "utf8", "params": [], "body": "                                                                 {\n            return string(Charset.forName(\"UTF-8\"));\n        }", "signature": "public <S extends Geometry> Serializer<String, S> utf8()"}, {"syntax_pass": true, "original_string": "        public <S extends Geometry> Serializer<byte[], S> bytes() {\n            Func1<byte[], byte[]> serializer = Functions.identity();\n            Func1<byte[], byte[]> deserializer = Functions.identity();\n            return new SerializerTypedBuilder<byte[]>(serializer, deserializer, method).create();\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Serializer<byte[], S>", "classes": []}, "name": "bytes", "params": [], "body": "                                                                  {\n            Func1<byte[], byte[]> serializer = Functions.identity();\n            Func1<byte[], byte[]> deserializer = Functions.identity();\n            return new SerializerTypedBuilder<byte[]>(serializer, deserializer, method).create();\n        }", "signature": "public <S extends Geometry> Serializer<byte[], S> bytes()"}, {"syntax_pass": true, "original_string": "        public SerializerBuilder method(Method method) {\n            this.method = method;\n            return this;\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "SerializerBuilder", "classes": []}, "name": "method", "params": [{"name": "method", "type": "Method"}], "body": "                                                       {\n            this.method = method;\n            return this;\n        }", "signature": "public SerializerBuilder method(Method method)"}]}, {"original_string": "    public static final class SerializerTypedBuilder<T> {\n\n        private Func1<? super T, byte[]> serializer;\n        private Func1<byte[], ? extends T> deserializer;\n        private Method method;\n        private Func0<Kryo> kryoFactory = new Func0<Kryo>() {\n            @Override\n            public Kryo call() {\n                return new Kryo();\n            }\n        };\n\n        private SerializerTypedBuilder(Func1<? super T, byte[]> serializer,\n                Func1<byte[], ? extends T> deserializer, Method method) {\n            this.serializer = serializer;\n            this.deserializer = deserializer;\n            this.method = method;\n        }\n\n        public SerializerTypedBuilder<T> serializer(Func1<? super T, byte[]> serializer) {\n            this.serializer = serializer;\n            return this;\n        }\n\n        public SerializerTypedBuilder<T> deserializer(Func1<byte[], ? extends T> deserializer) {\n            this.deserializer = deserializer;\n            return this;\n        }\n\n        public SerializerTypedBuilder<T> method(Method method) {\n            // TODO remove this check when kryo ready\n            Preconditions.checkArgument(method != Method.KRYO,\n                    \"kryo serialization not implemented yet\");\n            this.method = method;\n            return this;\n        }\n\n        // TODO enable when ready\n        @SuppressWarnings(\"unused\")\n        private SerializerTypedBuilder<T> kryo(Func0<Kryo> kryoFactory) {\n            this.method = Method.KRYO;\n            this.kryoFactory = kryoFactory;\n            return this;\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        public <S extends Geometry> Serializer<T, S> create() {\n            if (method == Method.FLATBUFFERS) {\n                if (serializer == null) {\n                    serializer = (Func1<T, byte[]>) javaIoSerializer();\n                }\n                if (deserializer == null) {\n                    deserializer = (Func1<byte[], T>) javaIoDeserializer();\n                }\n                return SerializerFlatBuffers.create(serializer, deserializer);\n            } else {\n                return SerializerKryo.create(serializer, deserializer, kryoFactory);\n            }\n        }\n\n    }", "definition": "    public static final class SerializerTypedBuilder<T>", "class_docstring": "", "name": "SerializerTypedBuilder", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "fields": [{"attribute_expression": "private Func1<? super T, byte[]> serializer;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Func1<? super T, byte[]>", "name": "serializer", "syntax_pass": true}, {"attribute_expression": "private Func1<byte[], ? extends T> deserializer;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Func1<byte[], ? extends T>", "name": "deserializer", "syntax_pass": true}, {"attribute_expression": "private Method method;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Method", "name": "method", "syntax_pass": true}, {"attribute_expression": "private Func0<Kryo> kryoFactory = new Func0<Kryo>() {\n            @Override\n            public Kryo call() {\n                return new Kryo();\n            }\n        };", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Func0<Kryo>", "name": "kryoFactory = new Func0<Kryo>() {\n            @Override\n            public Kryo call() {\n                return new Kryo();\n            }\n        }", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        private SerializerTypedBuilder(Func1<? super T, byte[]> serializer,\n                Func1<byte[], ? extends T> deserializer, Method method) {\n            this.serializer = serializer;\n            this.deserializer = deserializer;\n            this.method = method;\n        }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "", "classes": []}, "name": "SerializerTypedBuilder", "params": [{"name": "serializer", "type": "Func1<? super T, byte[]>"}, {"name": "deserializer", "type": "Func1<byte[], ? extends T>"}, {"name": "method", "type": "Method"}], "body": "                                                                        {\n            this.serializer = serializer;\n            this.deserializer = deserializer;\n            this.method = method;\n        }", "signature": "private SerializerTypedBuilder(Func1<? super T, byte[]> serializer,\n                Func1<byte[], ? extends T> deserializer, Method method)"}, {"syntax_pass": true, "original_string": "        public SerializerTypedBuilder<T> serializer(Func1<? super T, byte[]> serializer) {\n            this.serializer = serializer;\n            return this;\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "SerializerTypedBuilder<T>", "classes": []}, "name": "serializer", "params": [{"name": "serializer", "type": "Func1<? super T, byte[]>"}], "body": "                                                                                         {\n            this.serializer = serializer;\n            return this;\n        }", "signature": "public SerializerTypedBuilder<T> serializer(Func1<? super T, byte[]> serializer)"}, {"syntax_pass": true, "original_string": "        public SerializerTypedBuilder<T> deserializer(Func1<byte[], ? extends T> deserializer) {\n            this.deserializer = deserializer;\n            return this;\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "SerializerTypedBuilder<T>", "classes": []}, "name": "deserializer", "params": [{"name": "deserializer", "type": "Func1<byte[], ? extends T>"}], "body": "                                                                                               {\n            this.deserializer = deserializer;\n            return this;\n        }", "signature": "public SerializerTypedBuilder<T> deserializer(Func1<byte[], ? extends T> deserializer)"}, {"syntax_pass": true, "original_string": "        public SerializerTypedBuilder<T> method(Method method) {\n            // TODO remove this check when kryo ready\n            Preconditions.checkArgument(method != Method.KRYO,\n                    \"kryo serialization not implemented yet\");\n            this.method = method;\n            return this;\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "SerializerTypedBuilder<T>", "classes": []}, "name": "method", "params": [{"name": "method", "type": "Method"}], "body": "                                                               {\n            // TODO remove this check when kryo ready\n            Preconditions.checkArgument(method != Method.KRYO,\n                    \"kryo serialization not implemented yet\");\n            this.method = method;\n            return this;\n        }", "signature": "public SerializerTypedBuilder<T> method(Method method)"}, {"syntax_pass": true, "original_string": "        @SuppressWarnings(\"unused\")\n        private SerializerTypedBuilder<T> kryo(Func0<Kryo> kryoFactory) {\n            this.method = Method.KRYO;\n            this.kryoFactory = kryoFactory;\n            return this;\n        }", "docstring": " TODO enable when ready", "attributes": {"modifiers": "@SuppressWarnings(\"unused\")\n        private", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings(\"unused\")", "private"], "comments": [], "return_type": "SerializerTypedBuilder<T>", "classes": []}, "name": "kryo", "params": [{"name": "kryoFactory", "type": "Func0<Kryo>"}], "body": "                                                                        {\n            this.method = Method.KRYO;\n            this.kryoFactory = kryoFactory;\n            return this;\n        }", "signature": "@SuppressWarnings(\"unused\")\n        private SerializerTypedBuilder<T> kryo(Func0<Kryo> kryoFactory)"}, {"syntax_pass": true, "original_string": "        @SuppressWarnings(\"unchecked\")\n        public <S extends Geometry> Serializer<T, S> create() {\n            if (method == Method.FLATBUFFERS) {\n                if (serializer == null) {\n                    serializer = (Func1<T, byte[]>) javaIoSerializer();\n                }\n                if (deserializer == null) {\n                    deserializer = (Func1<byte[], T>) javaIoDeserializer();\n                }\n                return SerializerFlatBuffers.create(serializer, deserializer);\n            } else {\n                return SerializerKryo.create(serializer, deserializer, kryoFactory);\n            }\n        }", "docstring": "", "attributes": {"modifiers": "@SuppressWarnings(\"unchecked\")\n        public", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings(\"unchecked\")", "public"], "comments": [], "return_type": "Serializer<T, S>", "classes": []}, "name": "create", "params": [], "body": "                                                              {\n            if (method == Method.FLATBUFFERS) {\n                if (serializer == null) {\n                    serializer = (Func1<T, byte[]>) javaIoSerializer();\n                }\n                if (deserializer == null) {\n                    deserializer = (Func1<byte[], T>) javaIoDeserializer();\n                }\n                return SerializerFlatBuffers.create(serializer, deserializer);\n            } else {\n                return SerializerKryo.create(serializer, deserializer, kryoFactory);\n            }\n        }", "signature": "@SuppressWarnings(\"unchecked\")\n        public <S extends Geometry> Serializer<T, S> create()"}]}], "class_docstring": "", "original_string": "public final class Serializers {\n\n    private Serializers() {\n        // prevent instantiation\n    }\n\n    public static class SerializerBuilder {\n\n        private Method method = Method.FLATBUFFERS;\n\n        private SerializerBuilder() {\n\n        }\n\n        public <T> SerializerTypedBuilder<T> serializer(Func1<? super T, byte[]> serializer) {\n            return new SerializerTypedBuilder<T>(serializer, null, method);\n        }\n\n        public <T> SerializerTypedBuilder<T> deserializer(Func1<byte[], ? extends T> deserializer) {\n            return new SerializerTypedBuilder<T>(null, deserializer, method);\n        }\n\n        public <S extends Geometry> Serializer<String, S> string(Charset charset) {\n            Func1<String, byte[]> serializer = createStringSerializer(charset);\n            Func1<byte[], String> deserializer = createStringDeserializer(charset);\n            return new SerializerTypedBuilder<String>(serializer, deserializer, method).create();\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        public <T extends Serializable, S extends Geometry> Serializer<T, S> javaIo() {\n            Func1<T, byte[]> serializer = (Func1<T, byte[]>) javaIoSerializer();\n            Func1<byte[], T> deserializer = (Func1<byte[], T>) javaIoDeserializer();\n            return new SerializerTypedBuilder<T>(serializer, deserializer, method).create();\n        }\n\n        public <S extends Geometry> Serializer<String, S> utf8() {\n            return string(Charset.forName(\"UTF-8\"));\n        }\n\n        public <S extends Geometry> Serializer<byte[], S> bytes() {\n            Func1<byte[], byte[]> serializer = Functions.identity();\n            Func1<byte[], byte[]> deserializer = Functions.identity();\n            return new SerializerTypedBuilder<byte[]>(serializer, deserializer, method).create();\n        }\n\n        public SerializerBuilder method(Method method) {\n            this.method = method;\n            return this;\n        }\n\n    }\n\n    public static final class SerializerTypedBuilder<T> {\n\n        private Func1<? super T, byte[]> serializer;\n        private Func1<byte[], ? extends T> deserializer;\n        private Method method;\n        private Func0<Kryo> kryoFactory = new Func0<Kryo>() {\n            @Override\n            public Kryo call() {\n                return new Kryo();\n            }\n        };\n\n        private SerializerTypedBuilder(Func1<? super T, byte[]> serializer,\n                Func1<byte[], ? extends T> deserializer, Method method) {\n            this.serializer = serializer;\n            this.deserializer = deserializer;\n            this.method = method;\n        }\n\n        public SerializerTypedBuilder<T> serializer(Func1<? super T, byte[]> serializer) {\n            this.serializer = serializer;\n            return this;\n        }\n\n        public SerializerTypedBuilder<T> deserializer(Func1<byte[], ? extends T> deserializer) {\n            this.deserializer = deserializer;\n            return this;\n        }\n\n        public SerializerTypedBuilder<T> method(Method method) {\n            // TODO remove this check when kryo ready\n            Preconditions.checkArgument(method != Method.KRYO,\n                    \"kryo serialization not implemented yet\");\n            this.method = method;\n            return this;\n        }\n\n        // TODO enable when ready\n        @SuppressWarnings(\"unused\")\n        private SerializerTypedBuilder<T> kryo(Func0<Kryo> kryoFactory) {\n            this.method = Method.KRYO;\n            this.kryoFactory = kryoFactory;\n            return this;\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        public <S extends Geometry> Serializer<T, S> create() {\n            if (method == Method.FLATBUFFERS) {\n                if (serializer == null) {\n                    serializer = (Func1<T, byte[]>) javaIoSerializer();\n                }\n                if (deserializer == null) {\n                    deserializer = (Func1<byte[], T>) javaIoDeserializer();\n                }\n                return SerializerFlatBuffers.create(serializer, deserializer);\n            } else {\n                return SerializerKryo.create(serializer, deserializer, kryoFactory);\n            }\n        }\n\n    }\n\n    public static <T, S extends Geometry> SerializerBuilder flatBuffers() {\n        return new SerializerBuilder().method(Method.FLATBUFFERS);\n    }\n\n    public enum Method {\n        FLATBUFFERS, KRYO;\n    }\n\n    private static Func1<String, byte[]> createStringSerializer(final Charset charset) {\n        return new Func1<String, byte[]>() {\n            @Override\n            public byte[] call(String s) {\n                return s.getBytes(charset);\n            }\n        };\n    }\n\n    private static <T> Func1<byte[], String> createStringDeserializer(final Charset charset) {\n        return new Func1<byte[], String>() {\n            @Override\n            public String call(byte[] bytes) {\n                return new String(bytes, charset);\n            }\n        };\n    }\n\n    private static Func1<Serializable, byte[]> javaIoSerializer() {\n        return new Func1<Serializable, byte[]>() {\n            @Override\n            public byte[] call(Serializable o) {\n                ByteArrayOutputStream bytes = new ByteArrayOutputStream();\n                ObjectOutputStream oos = null;\n                try {\n                    oos = new ObjectOutputStream(bytes);\n                    oos.writeObject(o);\n                    oos.close();\n                    return bytes.toByteArray();\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                } finally {\n                    try {\n                        if (oos != null)\n                            oos.close();\n                    } catch (IOException e) {\n                        // ignore\n                    }\n                }\n            }\n        };\n    }\n\n    private static Func1<byte[], Serializable> javaIoDeserializer() {\n        return new Func1<byte[], Serializable>() {\n            @Override\n            public Serializable call(byte[] bytes) {\n                ByteArrayInputStream is = new ByteArrayInputStream(bytes);\n                ObjectInputStream ois = null;\n                try {\n                    ois = new ObjectInputStream(is);\n                    return (Serializable) ois.readObject();\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                } catch (ClassNotFoundException e) {\n                    throw new RuntimeException(e);\n                } finally {\n                    if (ois != null)\n                        try {\n                            ois.close();\n                        } catch (IOException e) {\n                            // ignore\n                        }\n                }\n            }\n        };\n    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/main/java/com/github/davidmoten/rtree/SplitterRStar.java.SplitterRStar", "name": "SplitterRStar", "file_path": "src/main/java/com/github/davidmoten/rtree/SplitterRStar.java", "superclasses": "", "methods": ["[]SplitterRStar()", "[ListPair<T>]split(List<T>,int)", "[Comparator<HasGeometry>]comparator(SortType)", "[double]marginValueSum(List<ListPair<T>>)", "[List<ListPair<T>>]getPairs(int,List<T>)", "[double]overlap(ListPair<? extends HasGeometry>)"], "method_uris": ["src/main/java/com/github/davidmoten/rtree/SplitterRStar.java.SplitterRStar.[]SplitterRStar()", "src/main/java/com/github/davidmoten/rtree/SplitterRStar.java.SplitterRStar.[ListPair<T>]split(List<T>,int)", "src/main/java/com/github/davidmoten/rtree/SplitterRStar.java.SplitterRStar.[Comparator<HasGeometry>]comparator(SortType)", "src/main/java/com/github/davidmoten/rtree/SplitterRStar.java.SplitterRStar.[double]marginValueSum(List<ListPair<T>>)", "src/main/java/com/github/davidmoten/rtree/SplitterRStar.java.SplitterRStar.[List<ListPair<T>>]getPairs(int,List<T>)", "src/main/java/com/github/davidmoten/rtree/SplitterRStar.java.SplitterRStar.[double]overlap(ListPair<? extends HasGeometry>)"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public final class SplitterRStar implements Splitter {\n\n    private final Comparator<ListPair<?>> comparator;\n\n    public SplitterRStar() {\n        this.comparator = new Comparator<ListPair<?>>() {\n\n            @Override\n            public int compare(ListPair<?> p1, ListPair<?> p2) {\n                // check overlap first then areaSum\n                int value = Double.compare(overlap(p1), overlap(p2));\n                if (value == 0) {\n                    return Double.compare(p1.areaSum(), p2.areaSum());\n                } else {\n                    return value;\n                }\n            }\n        };\n    }\n\n    @Override\n    public <T extends HasGeometry> ListPair<T> split(List<T> items, int minSize) {\n        Preconditions.checkArgument(!items.isEmpty());\n        // sort nodes into increasing x, calculate min overlap where both groups\n        // have more than minChildren\n\n        // compute S the sum of all margin-values of the lists above\n        // the list with the least S is then used to find minimum overlap\n\n        List<ListPair<T>> pairs = null;\n        double lowestMarginSum = Double.POSITIVE_INFINITY;\n        List<T> list = null;\n        for (SortType sortType : SortType.values()) {\n            if (list == null) {\n                list = new ArrayList<T>(items);\n            }\n            Collections.sort(list, comparator(sortType));\n            List<ListPair<T>> p = getPairs(minSize, list);\n            double marginSum = marginValueSum(p);\n            if (marginSum <= lowestMarginSum) {\n                lowestMarginSum = marginSum;\n                pairs = p;\n                // because p uses subViews of list we need to create a new one\n                // for further comparisons\n                list = null;\n            }\n        }\n        return Collections.min(pairs, comparator);\n    }\n\n    private static Comparator<HasGeometry> comparator(SortType sortType) {\n        switch (sortType) {\n        case X_LOWER:\n            return INCREASING_X_LOWER;\n        case X_UPPER:\n            return INCREASING_X_UPPER;\n        case Y_LOWER:\n            return INCREASING_Y_LOWER;\n        case Y_UPPER:\n            return INCREASING_Y_UPPER;\n        default:\n            throw new IllegalArgumentException(\"unknown SortType \" + sortType);\n        }\n    }\n\n    private enum SortType {\n        X_LOWER, X_UPPER, Y_LOWER, Y_UPPER;\n    }\n\n    private static <T extends HasGeometry> double marginValueSum(List<ListPair<T>> list) {\n        double sum = 0;\n        for (ListPair<T> p : list)\n            sum += p.marginSum();\n        return sum;\n    }\n\n    @VisibleForTesting\n    static <T extends HasGeometry> List<ListPair<T>> getPairs(int minSize, List<T> list) {\n        List<ListPair<T>> pairs = new ArrayList<ListPair<T>>(list.size() - 2 * minSize + 1);\n        for (int i = minSize; i < list.size() - minSize + 1; i++) {\n            // Note that subList returns a view of list so creating list1 and\n            // list2 doesn't\n            // necessarily incur array allocation costs.\n            List<T> list1 = list.subList(0, i);\n            List<T> list2 = list.subList(i, list.size());\n            ListPair<T> pair = new ListPair<T>(list1, list2);\n            pairs.add(pair);\n        }\n        return pairs;\n    }\n\n    private static final Comparator<HasGeometry> INCREASING_X_LOWER = new Comparator<HasGeometry>() {\n\n        @Override\n        public int compare(HasGeometry n1, HasGeometry n2) {\n            return Double.compare(n1.geometry().mbr().x1(), n2.geometry().mbr().x1());\n        }\n    };\n\n    private static final Comparator<HasGeometry> INCREASING_X_UPPER = new Comparator<HasGeometry>() {\n\n        @Override\n        public int compare(HasGeometry n1, HasGeometry n2) {\n            return Double.compare(n1.geometry().mbr().x2(), n2.geometry().mbr().x2());\n        }\n    };\n\n    private static final Comparator<HasGeometry> INCREASING_Y_LOWER = new Comparator<HasGeometry>() {\n\n        @Override\n        public int compare(HasGeometry n1, HasGeometry n2) {\n            return Double.compare(n1.geometry().mbr().y1(), n2.geometry().mbr().y1());\n        }\n    };\n\n    private static final Comparator<HasGeometry> INCREASING_Y_UPPER = new Comparator<HasGeometry>() {\n\n        @Override\n        public int compare(HasGeometry n1, HasGeometry n2) {\n            return Double.compare(n1.geometry().mbr().y2(), n2.geometry().mbr().y2());\n        }\n    };\n\n    private static double overlap(ListPair<? extends HasGeometry> pair) {\n        return pair.group1().geometry().mbr().intersectionArea(pair.group2().geometry().mbr());\n    }\n\n}", "super_interfaces": ["Splitter"], "fields": [{"attribute_expression": "private final Comparator<ListPair<?>> comparator;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Comparator<ListPair<?>>", "name": "comparator", "syntax_pass": true}, {"attribute_expression": "private static final Comparator<HasGeometry> INCREASING_X_LOWER = new Comparator<HasGeometry>() {\n\n        @Override\n        public int compare(HasGeometry n1, HasGeometry n2) {\n            return Double.compare(n1.geometry().mbr().x1(), n2.geometry().mbr().x1());\n        }\n    };", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Comparator<HasGeometry>", "name": "INCREASING_X_LOWER = new Comparator<HasGeometry>() {\n\n        @Override\n        public int compare(HasGeometry n1, HasGeometry n2) {\n            return Double.compare(n1.geometry().mbr().x1(), n2.geometry().mbr().x1());\n        }\n    }", "syntax_pass": true}, {"attribute_expression": "private static final Comparator<HasGeometry> INCREASING_X_UPPER = new Comparator<HasGeometry>() {\n\n        @Override\n        public int compare(HasGeometry n1, HasGeometry n2) {\n            return Double.compare(n1.geometry().mbr().x2(), n2.geometry().mbr().x2());\n        }\n    };", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Comparator<HasGeometry>", "name": "INCREASING_X_UPPER = new Comparator<HasGeometry>() {\n\n        @Override\n        public int compare(HasGeometry n1, HasGeometry n2) {\n            return Double.compare(n1.geometry().mbr().x2(), n2.geometry().mbr().x2());\n        }\n    }", "syntax_pass": true}, {"attribute_expression": "private static final Comparator<HasGeometry> INCREASING_Y_LOWER = new Comparator<HasGeometry>() {\n\n        @Override\n        public int compare(HasGeometry n1, HasGeometry n2) {\n            return Double.compare(n1.geometry().mbr().y1(), n2.geometry().mbr().y1());\n        }\n    };", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Comparator<HasGeometry>", "name": "INCREASING_Y_LOWER = new Comparator<HasGeometry>() {\n\n        @Override\n        public int compare(HasGeometry n1, HasGeometry n2) {\n            return Double.compare(n1.geometry().mbr().y1(), n2.geometry().mbr().y1());\n        }\n    }", "syntax_pass": true}, {"attribute_expression": "private static final Comparator<HasGeometry> INCREASING_Y_UPPER = new Comparator<HasGeometry>() {\n\n        @Override\n        public int compare(HasGeometry n1, HasGeometry n2) {\n            return Double.compare(n1.geometry().mbr().y2(), n2.geometry().mbr().y2());\n        }\n    };", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Comparator<HasGeometry>", "name": "INCREASING_Y_UPPER = new Comparator<HasGeometry>() {\n\n        @Override\n        public int compare(HasGeometry n1, HasGeometry n2) {\n            return Double.compare(n1.geometry().mbr().y2(), n2.geometry().mbr().y2());\n        }\n    }", "syntax_pass": true}]}, {"uris": "src/main/java/com/github/davidmoten/rtree/ImageSaver.java.ImageSaver", "name": "ImageSaver", "file_path": "src/main/java/com/github/davidmoten/rtree/ImageSaver.java", "superclasses": "", "methods": ["[]ImageSaver()", "[void]save(BufferedImage,File,String)", "[void]run(Callable<Void>)"], "method_uris": ["src/main/java/com/github/davidmoten/rtree/ImageSaver.java.ImageSaver.[]ImageSaver()", "src/main/java/com/github/davidmoten/rtree/ImageSaver.java.ImageSaver.[void]save(BufferedImage,File,String)", "src/main/java/com/github/davidmoten/rtree/ImageSaver.java.ImageSaver.[void]run(Callable<Void>)"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "final class ImageSaver {\n\n    private ImageSaver() {\n        // prevent instantiation\n    }\n\n    static void save(final BufferedImage image, final File file, final String imageFormat) {\n        // this is an ugly workaround to achieve 100% coverage (the pesky\n        // IOException catch)\n        // The performance hit of making this allocation should be negligible\n        // compared to the cost of IO\n        Callable<Void> callable = new Callable<Void>() {\n            @Override\n            public Void call() throws Exception {\n                ImageIO.write(image, imageFormat, file);\n                return null;\n            }\n        };\n        run(callable);\n    }\n\n    static void run(Callable<Void> callable) {\n        try {\n            callable.call();\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/main/java/com/github/davidmoten/rtree/Factories.java.Factories", "name": "Factories", "file_path": "src/main/java/com/github/davidmoten/rtree/Factories.java", "superclasses": "", "methods": ["[]Factories()", "[Factory<T, S>]defaultFactory()"], "method_uris": ["src/main/java/com/github/davidmoten/rtree/Factories.java.Factories.[]Factories()", "src/main/java/com/github/davidmoten/rtree/Factories.java.Factories.[Factory<T, S>]defaultFactory()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public final class Factories {\n\n    private Factories() {\n        // prevent instantiation\n    }\n\n    public static <T, S extends Geometry> Factory<T, S> defaultFactory() {\n        return FactoryDefault.instance();\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/main/java/com/github/davidmoten/rtree/RectangleDepth.java.RectangleDepth", "name": "RectangleDepth", "file_path": "src/main/java/com/github/davidmoten/rtree/RectangleDepth.java", "superclasses": "", "methods": ["[]RectangleDepth(Rectangle,int)", "[Rectangle]getRectangle()", "[int]getDepth()"], "method_uris": ["src/main/java/com/github/davidmoten/rtree/RectangleDepth.java.RectangleDepth.[]RectangleDepth(Rectangle,int)", "src/main/java/com/github/davidmoten/rtree/RectangleDepth.java.RectangleDepth.[Rectangle]getRectangle()", "src/main/java/com/github/davidmoten/rtree/RectangleDepth.java.RectangleDepth.[int]getDepth()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "final class RectangleDepth {\n    private final Rectangle rectangle;\n    private final int depth;\n\n    RectangleDepth(Rectangle rectangle, int depth) {\n        super();\n        this.rectangle = rectangle;\n        this.depth = depth;\n    }\n\n    Rectangle getRectangle() {\n        return rectangle;\n    }\n\n    int getDepth() {\n        return depth;\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private final Rectangle rectangle;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Rectangle", "name": "rectangle", "syntax_pass": true}, {"attribute_expression": "private final int depth;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "int", "name": "depth", "syntax_pass": true}]}, {"uris": "src/main/java/com/github/davidmoten/rtree/Context.java.Context", "name": "Context", "file_path": "src/main/java/com/github/davidmoten/rtree/Context.java", "superclasses": "", "methods": ["[]Context(int,int,Selector,Splitter,Factory<T, S>)", "[int]maxChildren()", "[int]minChildren()", "[Splitter]splitter()", "[Selector]selector()", "[Factory<T, S>]factory()"], "method_uris": ["src/main/java/com/github/davidmoten/rtree/Context.java.Context.[]Context(int,int,Selector,Splitter,Factory<T, S>)", "src/main/java/com/github/davidmoten/rtree/Context.java.Context.[int]maxChildren()", "src/main/java/com/github/davidmoten/rtree/Context.java.Context.[int]minChildren()", "src/main/java/com/github/davidmoten/rtree/Context.java.Context.[Splitter]splitter()", "src/main/java/com/github/davidmoten/rtree/Context.java.Context.[Selector]selector()", "src/main/java/com/github/davidmoten/rtree/Context.java.Context.[Factory<T, S>]factory()"], "overrides": null, "attributes": [], "class_docstring": "\nConfigures an RTree prior to instantiation of an {@link RTree}.\n@param <T> value type\n@param <S> geometry type\n", "original_string": "public final class Context<T, S extends Geometry> {\n\n    private final int maxChildren;\n    private final int minChildren;\n    private final Splitter splitter;\n    private final Selector selector;\n    private final Factory<T, S> factory;\n\n    /**\n     * Constructor.\n     * \n     * @param minChildren\n     *            minimum number of children per node (at least 1)\n     * @param maxChildren\n     *            max number of children per node (minimum is 3)\n     * @param selector\n     *            algorithm to select search path\n     * @param splitter\n     *            algorithm to split the children across two new nodes\n     * @param factory\n     *            node creation factory\n     */\n    public Context(int minChildren, int maxChildren, Selector selector, Splitter splitter,\n            Factory<T, S> factory) {\n        Preconditions.checkNotNull(splitter);\n        Preconditions.checkNotNull(selector);\n        Preconditions.checkArgument(maxChildren > 2);\n        Preconditions.checkArgument(minChildren >= 1);\n        Preconditions.checkArgument(minChildren < maxChildren);\n        Preconditions.checkNotNull(factory);\n        this.selector = selector;\n        this.maxChildren = maxChildren;\n        this.minChildren = minChildren;\n        this.splitter = splitter;\n        this.factory = factory;\n    }\n\n    public int maxChildren() {\n        return maxChildren;\n    }\n\n    public int minChildren() {\n        return minChildren;\n    }\n\n    public Splitter splitter() {\n        return splitter;\n    }\n\n    public Selector selector() {\n        return selector;\n    }\n\n    public Factory<T, S> factory() {\n        return factory;\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private final int maxChildren;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "int", "name": "maxChildren", "syntax_pass": true}, {"attribute_expression": "private final int minChildren;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "int", "name": "minChildren", "syntax_pass": true}, {"attribute_expression": "private final Splitter splitter;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Splitter", "name": "splitter", "syntax_pass": true}, {"attribute_expression": "private final Selector selector;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Selector", "name": "selector", "syntax_pass": true}, {"attribute_expression": "private final Factory<T, S> factory;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Factory<T, S>", "name": "factory", "syntax_pass": true}]}, {"uris": "src/main/java/com/github/davidmoten/rtree/OnSubscribeSearch.java.OnSubscribeSearch", "name": "OnSubscribeSearch", "file_path": "src/main/java/com/github/davidmoten/rtree/OnSubscribeSearch.java", "superclasses": "", "methods": ["[]OnSubscribeSearch(Node<T, S>,Func1<? super Geometry, Boolean>)", "[void]call(Subscriber<? super Entry<T, S>>)", "[long]getAndAddRequest(AtomicLong,long)"], "method_uris": ["src/main/java/com/github/davidmoten/rtree/OnSubscribeSearch.java.OnSubscribeSearch.[]OnSubscribeSearch(Node<T, S>,Func1<? super Geometry, Boolean>)", "src/main/java/com/github/davidmoten/rtree/OnSubscribeSearch.java.OnSubscribeSearch.[void]call(Subscriber<? super Entry<T, S>>)", "src/main/java/com/github/davidmoten/rtree/OnSubscribeSearch.java.OnSubscribeSearch.[long]getAndAddRequest(AtomicLong,long)"], "overrides": null, "attributes": [{"original_string": "    @VisibleForTesting\n    static class SearchProducer<T, S extends Geometry> implements Producer {\n\n        private final Subscriber<? super Entry<T, S>> subscriber;\n        private final Node<T, S> node;\n        private final Func1<? super Geometry, Boolean> condition;\n        private volatile ImmutableStack<NodePosition<T, S>> stack;\n        private final AtomicLong requested = new AtomicLong(0);\n\n        SearchProducer(Node<T, S> node, Func1<? super Geometry, Boolean> condition,\n                Subscriber<? super Entry<T, S>> subscriber) {\n            this.node = node;\n            this.condition = condition;\n            this.subscriber = subscriber;\n            stack = ImmutableStack.create(new NodePosition<T, S>(node, 0));\n        }\n\n        @Override\n        public void request(long n) {\n            try {\n                if (n <= 0 || requested.get() == Long.MAX_VALUE)\n                    // none requested or already started with fast path\n                    return;\n                else if (n == Long.MAX_VALUE && requested.compareAndSet(0, Long.MAX_VALUE)) {\n                    // fast path\n                    requestAll();\n                } else\n                    requestSome(n);\n            } catch (RuntimeException e) {\n                subscriber.onError(e);\n            }\n        }\n\n        private void requestAll() {\n            node.searchWithoutBackpressure(condition, subscriber);\n            if (!subscriber.isUnsubscribed())\n                subscriber.onCompleted();\n        }\n\n        private void requestSome(long n) {\n            // back pressure path\n            // this algorithm copied roughly from\n            // rxjava-core/OnSubscribeFromIterable.java\n\n            // rxjava used AtomicLongFieldUpdater instead of AtomicLong\n            // but benchmarks showed no benefit here so reverted to AtomicLong\n            long previousCount = getAndAddRequest(requested, n);\n            if (previousCount == 0) {\n                // don't touch stack every time during the loop because\n                // is a volatile and every write forces a thread memory\n                // cache flush\n                ImmutableStack<NodePosition<T, S>> st = stack;\n                while (true) {\n                    // minimize atomic reads by assigning to a variable here\n                    long r = requested.get();\n                    st = Backpressure.search(condition, subscriber, st, r);\n                    if (st.isEmpty()) {\n                        // release some state for gc (although empty stack so not very significant)\n                        stack = null;\n                        if (!subscriber.isUnsubscribed()) {\n                            subscriber.onCompleted();\n                        }\n                        return;\n                    } else {\n                        stack = st;\n                        if (requested.addAndGet(-r) == 0)\n                            return;\n                    }\n                }\n\n            }\n        }\n    }", "definition": "    @VisibleForTesting\n    static class SearchProducer<T, S extends Geometry> implements Producer", "class_docstring": "", "name": "SearchProducer", "super_interfaces": ["Producer"], "superclasses": "", "attributes": {"modifiers": "@VisibleForTesting\n    static", "marker_annotations": ["@VisibleForTesting"], "non_marker_annotations": ["static"], "comments": [], "fields": [{"attribute_expression": "private final Subscriber<? super Entry<T, S>> subscriber;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Subscriber<? super Entry<T, S>>", "name": "subscriber", "syntax_pass": true}, {"attribute_expression": "private final Node<T, S> node;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Node<T, S>", "name": "node", "syntax_pass": true}, {"attribute_expression": "private final Func1<? super Geometry, Boolean> condition;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Func1<? super Geometry, Boolean>", "name": "condition", "syntax_pass": true}, {"attribute_expression": "private volatile ImmutableStack<NodePosition<T, S>> stack;", "docstring": "", "modifiers": "private volatile", "marker_annotations": [], "non_marker_annotations": ["private", "volatile"], "comments": [], "type": "ImmutableStack<NodePosition<T, S>>", "name": "stack", "syntax_pass": true}, {"attribute_expression": "private final AtomicLong requested = new AtomicLong(0);", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "AtomicLong", "name": "requested = new AtomicLong(0)", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        SearchProducer(Node<T, S> node, Func1<? super Geometry, Boolean> condition,\n                Subscriber<? super Entry<T, S>> subscriber) {\n            this.node = node;\n            this.condition = condition;\n            this.subscriber = subscriber;\n            stack = ImmutableStack.create(new NodePosition<T, S>(node, 0));\n        }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "SearchProducer", "params": [{"name": "node", "type": "Node<T, S>"}, {"name": "condition", "type": "Func1<? super Geometry, Boolean>"}, {"name": "subscriber", "type": "Subscriber<? super Entry<T, S>>"}], "body": "                                                            {\n            this.node = node;\n            this.condition = condition;\n            this.subscriber = subscriber;\n            stack = ImmutableStack.create(new NodePosition<T, S>(node, 0));\n        }", "signature": "SearchProducer(Node<T, S> node, Func1<? super Geometry, Boolean> condition,\n                Subscriber<? super Entry<T, S>> subscriber)"}, {"syntax_pass": true, "original_string": "        @Override\n        public void request(long n) {\n            try {\n                if (n <= 0 || requested.get() == Long.MAX_VALUE)\n                    // none requested or already started with fast path\n                    return;\n                else if (n == Long.MAX_VALUE && requested.compareAndSet(0, Long.MAX_VALUE)) {\n                    // fast path\n                    requestAll();\n                } else\n                    requestSome(n);\n            } catch (RuntimeException e) {\n                subscriber.onError(e);\n            }\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "request", "params": [{"name": "n", "type": "long"}], "body": "                                    {\n            try {\n                if (n <= 0 || requested.get() == Long.MAX_VALUE)\n                    // none requested or already started with fast path\n                    return;\n                else if (n == Long.MAX_VALUE && requested.compareAndSet(0, Long.MAX_VALUE)) {\n                    // fast path\n                    requestAll();\n                } else\n                    requestSome(n);\n            } catch (RuntimeException e) {\n                subscriber.onError(e);\n            }\n        }", "signature": "@Override\n        public void request(long n)"}, {"syntax_pass": true, "original_string": "        private void requestAll() {\n            node.searchWithoutBackpressure(condition, subscriber);\n            if (!subscriber.isUnsubscribed())\n                subscriber.onCompleted();\n        }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "name": "requestAll", "params": [], "body": "                                  {\n            node.searchWithoutBackpressure(condition, subscriber);\n            if (!subscriber.isUnsubscribed())\n                subscriber.onCompleted();\n        }", "signature": "private void requestAll()"}, {"syntax_pass": true, "original_string": "        private void requestSome(long n) {\n            // back pressure path\n            // this algorithm copied roughly from\n            // rxjava-core/OnSubscribeFromIterable.java\n\n            // rxjava used AtomicLongFieldUpdater instead of AtomicLong\n            // but benchmarks showed no benefit here so reverted to AtomicLong\n            long previousCount = getAndAddRequest(requested, n);\n            if (previousCount == 0) {\n                // don't touch stack every time during the loop because\n                // is a volatile and every write forces a thread memory\n                // cache flush\n                ImmutableStack<NodePosition<T, S>> st = stack;\n                while (true) {\n                    // minimize atomic reads by assigning to a variable here\n                    long r = requested.get();\n                    st = Backpressure.search(condition, subscriber, st, r);\n                    if (st.isEmpty()) {\n                        // release some state for gc (although empty stack so not very significant)\n                        stack = null;\n                        if (!subscriber.isUnsubscribed()) {\n                            subscriber.onCompleted();\n                        }\n                        return;\n                    } else {\n                        stack = st;\n                        if (requested.addAndGet(-r) == 0)\n                            return;\n                    }\n                }\n\n            }\n        }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "name": "requestSome", "params": [{"name": "n", "type": "long"}], "body": "                                         {\n            // back pressure path\n            // this algorithm copied roughly from\n            // rxjava-core/OnSubscribeFromIterable.java\n\n            // rxjava used AtomicLongFieldUpdater instead of AtomicLong\n            // but benchmarks showed no benefit here so reverted to AtomicLong\n            long previousCount = getAndAddRequest(requested, n);\n            if (previousCount == 0) {\n                // don't touch stack every time during the loop because\n                // is a volatile and every write forces a thread memory\n                // cache flush\n                ImmutableStack<NodePosition<T, S>> st = stack;\n                while (true) {\n                    // minimize atomic reads by assigning to a variable here\n                    long r = requested.get();\n                    st = Backpressure.search(condition, subscriber, st, r);\n                    if (st.isEmpty()) {\n                        // release some state for gc (although empty stack so not very significant)\n                        stack = null;\n                        if (!subscriber.isUnsubscribed()) {\n                            subscriber.onCompleted();\n                        }\n                        return;\n                    } else {\n                        stack = st;\n                        if (requested.addAndGet(-r) == 0)\n                            return;\n                    }\n                }\n\n            }\n        }", "signature": "private void requestSome(long n)"}]}], "class_docstring": "", "original_string": "final class OnSubscribeSearch<T, S extends Geometry> implements OnSubscribe<Entry<T, S>> {\n\n    private final Node<T, S> node;\n    private final Func1<? super Geometry, Boolean> condition;\n\n    OnSubscribeSearch(Node<T, S> node, Func1<? super Geometry, Boolean> condition) {\n        this.node = node;\n        this.condition = condition;\n    }\n\n    @Override\n    public void call(Subscriber<? super Entry<T, S>> subscriber) {\n        subscriber.setProducer(new SearchProducer<T, S>(node, condition, subscriber));\n    }\n\n    @VisibleForTesting\n    static class SearchProducer<T, S extends Geometry> implements Producer {\n\n        private final Subscriber<? super Entry<T, S>> subscriber;\n        private final Node<T, S> node;\n        private final Func1<? super Geometry, Boolean> condition;\n        private volatile ImmutableStack<NodePosition<T, S>> stack;\n        private final AtomicLong requested = new AtomicLong(0);\n\n        SearchProducer(Node<T, S> node, Func1<? super Geometry, Boolean> condition,\n                Subscriber<? super Entry<T, S>> subscriber) {\n            this.node = node;\n            this.condition = condition;\n            this.subscriber = subscriber;\n            stack = ImmutableStack.create(new NodePosition<T, S>(node, 0));\n        }\n\n        @Override\n        public void request(long n) {\n            try {\n                if (n <= 0 || requested.get() == Long.MAX_VALUE)\n                    // none requested or already started with fast path\n                    return;\n                else if (n == Long.MAX_VALUE && requested.compareAndSet(0, Long.MAX_VALUE)) {\n                    // fast path\n                    requestAll();\n                } else\n                    requestSome(n);\n            } catch (RuntimeException e) {\n                subscriber.onError(e);\n            }\n        }\n\n        private void requestAll() {\n            node.searchWithoutBackpressure(condition, subscriber);\n            if (!subscriber.isUnsubscribed())\n                subscriber.onCompleted();\n        }\n\n        private void requestSome(long n) {\n            // back pressure path\n            // this algorithm copied roughly from\n            // rxjava-core/OnSubscribeFromIterable.java\n\n            // rxjava used AtomicLongFieldUpdater instead of AtomicLong\n            // but benchmarks showed no benefit here so reverted to AtomicLong\n            long previousCount = getAndAddRequest(requested, n);\n            if (previousCount == 0) {\n                // don't touch stack every time during the loop because\n                // is a volatile and every write forces a thread memory\n                // cache flush\n                ImmutableStack<NodePosition<T, S>> st = stack;\n                while (true) {\n                    // minimize atomic reads by assigning to a variable here\n                    long r = requested.get();\n                    st = Backpressure.search(condition, subscriber, st, r);\n                    if (st.isEmpty()) {\n                        // release some state for gc (although empty stack so not very significant)\n                        stack = null;\n                        if (!subscriber.isUnsubscribed()) {\n                            subscriber.onCompleted();\n                        }\n                        return;\n                    } else {\n                        stack = st;\n                        if (requested.addAndGet(-r) == 0)\n                            return;\n                    }\n                }\n\n            }\n        }\n    }\n    \n    /**\n     * Adds {@code n} to {@code requested} and returns the value prior to\n     * addition once the addition is successful (uses CAS semantics). If\n     * overflows then sets {@code requested} field to {@code Long.MAX_VALUE}.\n     * \n     * @param requested\n     *            atomic field updater for a request count\n     * @param n\n     *            the number of requests to add to the requested count\n     * @return requested value just prior to successful addition\n     */\n    private static long getAndAddRequest(AtomicLong requested, long n) {\n        // add n to field but check for overflow\n        while (true) {\n            long current = requested.get();\n            long next = current + n;\n            // check for overflow\n            if (next < 0) {\n                next = Long.MAX_VALUE;\n            }\n            if (requested.compareAndSet(current, next)) {\n                return current;\n            }\n        }\n    }\n\n}", "super_interfaces": ["OnSubscribe<Entry<T, S>>"], "fields": [{"attribute_expression": "private final Node<T, S> node;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Node<T, S>", "name": "node", "syntax_pass": true}, {"attribute_expression": "private final Func1<? super Geometry, Boolean> condition;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Func1<? super Geometry, Boolean>", "name": "condition", "syntax_pass": true}]}, {"uris": "src/main/java/com/github/davidmoten/rtree/Entries.java.Entries", "name": "Entries", "file_path": "src/main/java/com/github/davidmoten/rtree/Entries.java", "superclasses": "", "methods": ["[]Entries()", "[Entry<T,S>]entry(T,S)"], "method_uris": ["src/main/java/com/github/davidmoten/rtree/Entries.java.Entries.[]Entries()", "src/main/java/com/github/davidmoten/rtree/Entries.java.Entries.[Entry<T,S>]entry(T,S)"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public final class Entries {\n\n    private Entries() {\n        // prevent instantiation\n    }\n    \n    public static <T, S extends Geometry> Entry<T,S> entry(T object, S geometry) {\n        return EntryDefault.entry(object, geometry);\n    }\n    \n}", "super_interfaces": [], "fields": []}, {"uris": "src/main/java/com/github/davidmoten/rtree/SerializerHelper.java.SerializerHelper", "name": "SerializerHelper", "file_path": "src/main/java/com/github/davidmoten/rtree/SerializerHelper.java", "superclasses": "", "methods": ["[]SerializerHelper()", "[RTree<T, S>]create(Optional<Node<T, S>>,int,Context<T, S>)"], "method_uris": ["src/main/java/com/github/davidmoten/rtree/SerializerHelper.java.SerializerHelper.[]SerializerHelper()", "src/main/java/com/github/davidmoten/rtree/SerializerHelper.java.SerializerHelper.[RTree<T, S>]create(Optional<Node<T, S>>,int,Context<T, S>)"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public final class SerializerHelper {\n    \n    private SerializerHelper() {\n        // prevent instantiation\n    }\n\n    public static <T, S extends Geometry> RTree<T, S> create(Optional<Node<T, S>> root, int size,\n            Context<T, S> context) {\n        return RTree.create(root, size, context);\n    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/main/java/com/github/davidmoten/rtree/SelectorMinimalAreaIncrease.java.SelectorMinimalAreaIncrease", "name": "SelectorMinimalAreaIncrease", "file_path": "src/main/java/com/github/davidmoten/rtree/SelectorMinimalAreaIncrease.java", "superclasses": "", "methods": ["[Node<T, S>]select(Geometry,List<? extends Node<T, S>>)"], "method_uris": ["src/main/java/com/github/davidmoten/rtree/SelectorMinimalAreaIncrease.java.SelectorMinimalAreaIncrease.[Node<T, S>]select(Geometry,List<? extends Node<T, S>>)"], "overrides": null, "attributes": [], "class_docstring": "\nUses minimal area increase to select a node from a list.\n\n", "original_string": "public final class SelectorMinimalAreaIncrease implements Selector {\n\n    @Override\n    public <T, S extends Geometry> Node<T, S> select(Geometry g, List<? extends Node<T, S>> nodes) {\n        return min(nodes, Comparators.areaIncreaseThenAreaComparator(g.mbr()));\n    }\n}", "super_interfaces": ["Selector"], "fields": []}, {"uris": "src/main/java/com/github/davidmoten/rtree/SplitterQuadratic.java.SplitterQuadratic", "name": "SplitterQuadratic", "file_path": "src/main/java/com/github/davidmoten/rtree/SplitterQuadratic.java", "superclasses": "", "methods": ["[ListPair<T>]split(List<T>,int)", "[void]assignRemaining(List<T>,List<T>,List<T>,int)", "[T]getBestCandidateForGroup(List<T>,List<T>,Rectangle)", "[Pair<T>]worstCombination(List<T>)"], "method_uris": ["src/main/java/com/github/davidmoten/rtree/SplitterQuadratic.java.SplitterQuadratic.[ListPair<T>]split(List<T>,int)", "src/main/java/com/github/davidmoten/rtree/SplitterQuadratic.java.SplitterQuadratic.[void]assignRemaining(List<T>,List<T>,List<T>,int)", "src/main/java/com/github/davidmoten/rtree/SplitterQuadratic.java.SplitterQuadratic.[T]getBestCandidateForGroup(List<T>,List<T>,Rectangle)", "src/main/java/com/github/davidmoten/rtree/SplitterQuadratic.java.SplitterQuadratic.[Pair<T>]worstCombination(List<T>)"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public final class SplitterQuadratic implements Splitter {\n\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public <T extends HasGeometry> ListPair<T> split(List<T> items, int minSize) {\n        Preconditions.checkArgument(items.size() >= 2);\n\n        // according to\n        // http://en.wikipedia.org/wiki/R-tree#Splitting_an_overflowing_node\n\n        // find the worst combination pairwise in the list and use them to start\n        // the two groups\n        final Pair<T> worstCombination = worstCombination(items);\n\n        // worst combination to have in the same node is now e1,e2.\n\n        // establish a group around e1 and another group around e2\n        final List<T> group1 = Lists.newArrayList(worstCombination.value1());\n        final List<T> group2 = Lists.newArrayList(worstCombination.value2());\n\n        final List<T> remaining = new ArrayList<T>(items);\n        remaining.remove(worstCombination.value1());\n        remaining.remove(worstCombination.value2());\n\n        final int minGroupSize = items.size() / 2;\n\n        // now add the remainder to the groups using least mbr area increase\n        // except in the case where minimumSize would be contradicted\n        while (remaining.size() > 0) {\n            assignRemaining(group1, group2, remaining, minGroupSize);\n        }\n        return new ListPair<T>(group1, group2);\n    }\n\n    private <T extends HasGeometry> void assignRemaining(final List<T> group1, final List<T> group2,\n            final List<T> remaining, final int minGroupSize) {\n        final Rectangle mbr1 = Util.mbr(group1);\n        final Rectangle mbr2 = Util.mbr(group2);\n        final T item1 = getBestCandidateForGroup(remaining, group1, mbr1);\n        final T item2 = getBestCandidateForGroup(remaining, group2, mbr2);\n        final boolean area1LessThanArea2 = item1.geometry().mbr().add(mbr1).area() <= item2\n                .geometry().mbr().add(mbr2).area();\n\n        if (area1LessThanArea2 && (group2.size() + remaining.size() - 1 >= minGroupSize)\n                || !area1LessThanArea2 && (group1.size() + remaining.size() == minGroupSize)) {\n            group1.add(item1);\n            remaining.remove(item1);\n        } else {\n            group2.add(item2);\n            remaining.remove(item2);\n        }\n    }\n\n    @VisibleForTesting\n    static <T extends HasGeometry> T getBestCandidateForGroup(List<T> list, List<T> group,\n            Rectangle groupMbr) {\n        // TODO reduce allocations by not using Optional\n        Optional<T> minEntry = Optional.empty();\n        Optional<Double> minArea = Optional.empty();\n        for (final T entry : list) {\n            double area = groupMbr.add(entry.geometry().mbr()).area();\n            if (!minArea.isPresent() || area < minArea.get()) {\n                minArea = of(area);\n                minEntry = of(entry);\n            }\n        }\n        return minEntry.get();\n    }\n\n    @VisibleForTesting\n    static <T extends HasGeometry> Pair<T> worstCombination(List<T> items) {\n        //TODO reduce allocations by not using Optional\n        Optional<T> e1 = Optional.empty();\n        Optional<T> e2 = Optional.empty();\n        {\n            Optional<Double> maxArea = Optional.empty();\n            for (int i = 0; i < items.size(); i++) {\n                for (int j = i + 1; j < items.size(); j++) {\n                    T entry1 = items.get(i);\n                    T entry2 = items.get(j);\n                    final double area = entry1.geometry().mbr().add(entry2.geometry().mbr()).area();\n                    if (!maxArea.isPresent() || area > maxArea.get()) {\n                        e1 = of(entry1);\n                        e2 = of(entry2);\n                        maxArea = of(area);\n                    }\n                }\n            }\n        }\n        if (e1.isPresent()) {\n            return new Pair<>(e1.get(), e2.get());\n        } else {\n            // all items are the same item\n            return new Pair<>(items.get(0), items.get(1));\n        }\n    }\n}", "super_interfaces": ["Splitter"], "fields": []}, {"uris": "src/main/java/com/github/davidmoten/rtree/Backpressure.java.Backpressure", "name": "Backpressure", "file_path": "src/main/java/com/github/davidmoten/rtree/Backpressure.java", "superclasses": "", "methods": ["[]Backpressure()", "[ImmutableStack<NodePosition<T, S>>]search(Func1<? super Geometry, Boolean>,Subscriber<? super Entry<T, S>>,ImmutableStack<NodePosition<T, S>>,long)", "[ImmutableStack<NodePosition<T, S>>]searchAndReturnStack(Func1<? super Geometry, Boolean>,Subscriber<? super Entry<T, S>>,StackAndRequest<NodePosition<T, S>>)", "[StackAndRequest<NodePosition<T, S>>]searchLeaf(Func1<? super Geometry, Boolean>,Subscriber<? super Entry<T, S>>,StackAndRequest<NodePosition<T, S>>,NodePosition<T, S>)", "[ImmutableStack<NodePosition<T, S>>]searchNonLeaf(Func1<? super Geometry, Boolean>,ImmutableStack<NodePosition<T, S>>,NodePosition<T, S>)", "[ImmutableStack<NodePosition<T, S>>]searchAfterLastInNode(ImmutableStack<NodePosition<T, S>>)"], "method_uris": ["src/main/java/com/github/davidmoten/rtree/Backpressure.java.Backpressure.[]Backpressure()", "src/main/java/com/github/davidmoten/rtree/Backpressure.java.Backpressure.[ImmutableStack<NodePosition<T, S>>]search(Func1<? super Geometry, Boolean>,Subscriber<? super Entry<T, S>>,ImmutableStack<NodePosition<T, S>>,long)", "src/main/java/com/github/davidmoten/rtree/Backpressure.java.Backpressure.[ImmutableStack<NodePosition<T, S>>]searchAndReturnStack(Func1<? super Geometry, Boolean>,Subscriber<? super Entry<T, S>>,StackAndRequest<NodePosition<T, S>>)", "src/main/java/com/github/davidmoten/rtree/Backpressure.java.Backpressure.[StackAndRequest<NodePosition<T, S>>]searchLeaf(Func1<? super Geometry, Boolean>,Subscriber<? super Entry<T, S>>,StackAndRequest<NodePosition<T, S>>,NodePosition<T, S>)", "src/main/java/com/github/davidmoten/rtree/Backpressure.java.Backpressure.[ImmutableStack<NodePosition<T, S>>]searchNonLeaf(Func1<? super Geometry, Boolean>,ImmutableStack<NodePosition<T, S>>,NodePosition<T, S>)", "src/main/java/com/github/davidmoten/rtree/Backpressure.java.Backpressure.[ImmutableStack<NodePosition<T, S>>]searchAfterLastInNode(ImmutableStack<NodePosition<T, S>>)"], "overrides": null, "attributes": [{"original_string": "    private static class StackAndRequest<T> {\n        private final ImmutableStack<T> stack;\n        private final long request;\n\n        StackAndRequest(ImmutableStack<T> stack, long request) {\n            this.stack = stack;\n            this.request = request;\n        }\n\n        static <T> StackAndRequest<T> create(ImmutableStack<T> stack, long request) {\n            return new StackAndRequest<T>(stack, request);\n        }\n\n    }", "definition": "    private static class StackAndRequest<T>", "class_docstring": "", "name": "StackAndRequest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "fields": [{"attribute_expression": "private final ImmutableStack<T> stack;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "ImmutableStack<T>", "name": "stack", "syntax_pass": true}, {"attribute_expression": "private final long request;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "long", "name": "request", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        StackAndRequest(ImmutableStack<T> stack, long request) {\n            this.stack = stack;\n            this.request = request;\n        }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "StackAndRequest", "params": [{"name": "stack", "type": "ImmutableStack<T>"}, {"name": "request", "type": "long"}], "body": "                                                               {\n            this.stack = stack;\n            this.request = request;\n        }", "signature": "StackAndRequest(ImmutableStack<T> stack, long request)"}, {"syntax_pass": true, "original_string": "        static <T> StackAndRequest<T> create(ImmutableStack<T> stack, long request) {\n            return new StackAndRequest<T>(stack, request);\n        }", "docstring": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "StackAndRequest<T>", "classes": []}, "name": "create", "params": [{"name": "stack", "type": "ImmutableStack<T>"}, {"name": "request", "type": "long"}], "body": "                                                                                    {\n            return new StackAndRequest<T>(stack, request);\n        }", "signature": "static <T> StackAndRequest<T> create(ImmutableStack<T> stack, long request)"}]}], "class_docstring": "\nUtility methods for controlling backpressure of the tree search.\n", "original_string": "final class Backpressure {\n\n    private Backpressure() {\n        // prevent instantiation\n    }\n\n    static <T, S extends Geometry> ImmutableStack<NodePosition<T, S>> search(\n            final Func1<? super Geometry, Boolean> condition,\n            final Subscriber<? super Entry<T, S>> subscriber,\n            final ImmutableStack<NodePosition<T, S>> stack, final long request) {\n        StackAndRequest<NodePosition<T, S>> state = StackAndRequest.create(stack, request);\n        return searchAndReturnStack(condition, subscriber, state);\n    }\n\n    private static <S extends Geometry, T> ImmutableStack<NodePosition<T, S>> searchAndReturnStack(\n            final Func1<? super Geometry, Boolean> condition,\n            final Subscriber<? super Entry<T, S>> subscriber,\n            StackAndRequest<NodePosition<T, S>> state) {\n\n        while (!state.stack.isEmpty()) {\n            NodePosition<T, S> np = state.stack.peek();\n            if (subscriber.isUnsubscribed())\n                return ImmutableStack.empty();\n            else if (state.request <= 0)\n                return state.stack;\n            else if (np.position() == np.node().count()) {\n                // handle after last in node\n                state = StackAndRequest.create(searchAfterLastInNode(state.stack), state.request);\n            } else if (np.node() instanceof NonLeaf) {\n                // handle non-leaf\n                state = StackAndRequest.create(searchNonLeaf(condition, state.stack, np),\n                        state.request);\n            } else {\n                // handle leaf\n                state = searchLeaf(condition, subscriber, state, np);\n            }\n        }\n        return state.stack;\n    }\n\n    private static class StackAndRequest<T> {\n        private final ImmutableStack<T> stack;\n        private final long request;\n\n        StackAndRequest(ImmutableStack<T> stack, long request) {\n            this.stack = stack;\n            this.request = request;\n        }\n\n        static <T> StackAndRequest<T> create(ImmutableStack<T> stack, long request) {\n            return new StackAndRequest<T>(stack, request);\n        }\n\n    }\n\n    private static <T, S extends Geometry> StackAndRequest<NodePosition<T, S>> searchLeaf(\n            final Func1<? super Geometry, Boolean> condition,\n            final Subscriber<? super Entry<T, S>> subscriber,\n            StackAndRequest<NodePosition<T, S>> state, NodePosition<T, S> np) {\n        final long nextRequest;\n        Entry<T, S> entry = ((Leaf<T, S>) np.node()).entry(np.position());\n        if (condition.call(entry.geometry())) {\n            subscriber.onNext(entry);\n            nextRequest = state.request - 1;\n        } else\n            nextRequest = state.request;\n        return StackAndRequest.create(state.stack.pop().push(np.nextPosition()), nextRequest);\n    }\n\n    private static <S extends Geometry, T> ImmutableStack<NodePosition<T, S>> searchNonLeaf(\n            final Func1<? super Geometry, Boolean> condition,\n            ImmutableStack<NodePosition<T, S>> stack, NodePosition<T, S> np) {\n        Node<T, S> child = ((NonLeaf<T, S>) np.node()).child(np.position());\n        if (condition.call(child.geometry())) {\n            stack = stack.push(new NodePosition<T, S>(child, 0));\n        } else {\n            stack = stack.pop().push(np.nextPosition());\n        }\n        return stack;\n    }\n\n    private static <S extends Geometry, T> ImmutableStack<NodePosition<T, S>> searchAfterLastInNode(\n            ImmutableStack<NodePosition<T, S>> stack) {\n        ImmutableStack<NodePosition<T, S>> stack2 = stack.pop();\n        if (stack2.isEmpty())\n            stack = stack2;\n        else {\n            NodePosition<T, S> previous = stack2.peek();\n            stack = stack2.pop().push(previous.nextPosition());\n        }\n        return stack;\n    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/main/java/com/github/davidmoten/rtree/RTree.java.RTree", "name": "RTree", "file_path": "src/main/java/com/github/davidmoten/rtree/RTree.java", "superclasses": "", "methods": ["[]RTree(Optional<? extends Node<T, S>>,int,Context<T, S>)", "[]RTree()", "[]RTree(Node<T, S>,int,Context<T, S>)", "[RTree<T, S>]create(Optional<? extends Node<T, S>>,int,Context<T, S>)", "[RTree<T, S>]create()", "[RTree<T, S>]create(List<Entry<T, S>>)", "[int]calculateDepth()", "[int]calculateDepth(Optional<? extends Node<T, S>>)", "[int]calculateDepth(Node<T, S>,int)", "[Builder]minChildren(int)", "[Builder]maxChildren(int)", "[Builder]splitter(Splitter)", "[Builder]selector(Selector)", "[Builder]star()", "[RTree<T, S>]add(Entry<? extends T, ? extends S>)", "[RTree<T, S>]add(T,S)", "[RTree<T, S>]add(Iterable<Entry<T, S>>)", "[Observable<RTree<T, S>>]add(Observable<Entry<T, S>>)", "[Observable<RTree<T, S>>]delete(Observable<Entry<T, S>>,boolean)", "[RTree<T, S>]delete(Iterable<Entry<T, S>>,boolean)", "[RTree<T, S>]delete(Iterable<Entry<T, S>>)", "[RTree<T, S>]delete(T,S,boolean)", "[RTree<T, S>]delete(T,S)", "[RTree<T, S>]delete(Entry<? extends T, ? extends S>,boolean)", "[RTree<T, S>]delete(Entry<? extends T, ? extends S>)", "[Observable<Entry<T, S>>]search(Func1<? super Geometry, Boolean>)", "[Func1<Geometry, Boolean>]intersects(Rectangle)", "[Observable<Entry<T, S>>]search(Rectangle)", "[Observable<Entry<T, S>>]search(Point)", "[Observable<Entry<T, S>>]search(Circle)", "[Observable<Entry<T, S>>]search(Line)", "[Observable<Entry<T, S>>]search(Rectangle,double)", "[Observable<Entry<T, S>>]search(R,Func2<? super S, ? super R, Boolean>)", "[Observable<Entry<T, S>>]search(R,double,Func2<? super S, ? super R, Double>)", "[Observable<Entry<T, S>>]search(Point,double)", "[Observable<Entry<T, S>>]nearest(Rectangle,double,int)", "[Observable<Entry<T, S>>]nearest(Point,double,int)", "[Observable<Entry<T, S>>]entries()", "[Visualizer]visualize(int,int,Rectangle)", "[Visualizer]visualize(int,int)", "[Rectangle]calculateMaxView(RTree<T, S>)", "[Optional<? extends Node<T, S>>]root()", "[Optional<Rectangle>]mbr()", "[boolean]isEmpty()", "[int]size()", "[Context<T, S>]context()", "[String]asString()", "[String]asString(Node<T, S>,String)"], "method_uris": ["src/main/java/com/github/davidmoten/rtree/RTree.java.RTree.[]RTree(Optional<? extends Node<T, S>>,int,Context<T, S>)", "src/main/java/com/github/davidmoten/rtree/RTree.java.RTree.[]RTree()", "src/main/java/com/github/davidmoten/rtree/RTree.java.RTree.[]RTree(Node<T, S>,int,Context<T, S>)", "src/main/java/com/github/davidmoten/rtree/RTree.java.RTree.[RTree<T, S>]create(Optional<? extends Node<T, S>>,int,Context<T, S>)", "src/main/java/com/github/davidmoten/rtree/RTree.java.RTree.[RTree<T, S>]create()", "src/main/java/com/github/davidmoten/rtree/RTree.java.RTree.[RTree<T, S>]create(List<Entry<T, S>>)", "src/main/java/com/github/davidmoten/rtree/RTree.java.RTree.[int]calculateDepth()", "src/main/java/com/github/davidmoten/rtree/RTree.java.RTree.[int]calculateDepth(Optional<? extends Node<T, S>>)", "src/main/java/com/github/davidmoten/rtree/RTree.java.RTree.[int]calculateDepth(Node<T, S>,int)", "src/main/java/com/github/davidmoten/rtree/RTree.java.RTree.[Builder]minChildren(int)", "src/main/java/com/github/davidmoten/rtree/RTree.java.RTree.[Builder]maxChildren(int)", "src/main/java/com/github/davidmoten/rtree/RTree.java.RTree.[Builder]splitter(Splitter)", "src/main/java/com/github/davidmoten/rtree/RTree.java.RTree.[Builder]selector(Selector)", "src/main/java/com/github/davidmoten/rtree/RTree.java.RTree.[Builder]star()", "src/main/java/com/github/davidmoten/rtree/RTree.java.RTree.[RTree<T, S>]add(Entry<? extends T, ? extends S>)", "src/main/java/com/github/davidmoten/rtree/RTree.java.RTree.[RTree<T, S>]add(T,S)", "src/main/java/com/github/davidmoten/rtree/RTree.java.RTree.[RTree<T, S>]add(Iterable<Entry<T, S>>)", "src/main/java/com/github/davidmoten/rtree/RTree.java.RTree.[Observable<RTree<T, S>>]add(Observable<Entry<T, S>>)", "src/main/java/com/github/davidmoten/rtree/RTree.java.RTree.[Observable<RTree<T, S>>]delete(Observable<Entry<T, S>>,boolean)", "src/main/java/com/github/davidmoten/rtree/RTree.java.RTree.[RTree<T, S>]delete(Iterable<Entry<T, S>>,boolean)", "src/main/java/com/github/davidmoten/rtree/RTree.java.RTree.[RTree<T, S>]delete(Iterable<Entry<T, S>>)", "src/main/java/com/github/davidmoten/rtree/RTree.java.RTree.[RTree<T, S>]delete(T,S,boolean)", "src/main/java/com/github/davidmoten/rtree/RTree.java.RTree.[RTree<T, S>]delete(T,S)", "src/main/java/com/github/davidmoten/rtree/RTree.java.RTree.[RTree<T, S>]delete(Entry<? extends T, ? extends S>,boolean)", "src/main/java/com/github/davidmoten/rtree/RTree.java.RTree.[RTree<T, S>]delete(Entry<? extends T, ? extends S>)", "src/main/java/com/github/davidmoten/rtree/RTree.java.RTree.[Observable<Entry<T, S>>]search(Func1<? super Geometry, Boolean>)", "src/main/java/com/github/davidmoten/rtree/RTree.java.RTree.[Func1<Geometry, Boolean>]intersects(Rectangle)", "src/main/java/com/github/davidmoten/rtree/RTree.java.RTree.[Observable<Entry<T, S>>]search(Rectangle)", "src/main/java/com/github/davidmoten/rtree/RTree.java.RTree.[Observable<Entry<T, S>>]search(Point)", "src/main/java/com/github/davidmoten/rtree/RTree.java.RTree.[Observable<Entry<T, S>>]search(Circle)", "src/main/java/com/github/davidmoten/rtree/RTree.java.RTree.[Observable<Entry<T, S>>]search(Line)", "src/main/java/com/github/davidmoten/rtree/RTree.java.RTree.[Observable<Entry<T, S>>]search(Rectangle,double)", "src/main/java/com/github/davidmoten/rtree/RTree.java.RTree.[Observable<Entry<T, S>>]search(R,Func2<? super S, ? super R, Boolean>)", "src/main/java/com/github/davidmoten/rtree/RTree.java.RTree.[Observable<Entry<T, S>>]search(R,double,Func2<? super S, ? super R, Double>)", "src/main/java/com/github/davidmoten/rtree/RTree.java.RTree.[Observable<Entry<T, S>>]search(Point,double)", "src/main/java/com/github/davidmoten/rtree/RTree.java.RTree.[Observable<Entry<T, S>>]nearest(Rectangle,double,int)", "src/main/java/com/github/davidmoten/rtree/RTree.java.RTree.[Observable<Entry<T, S>>]nearest(Point,double,int)", "src/main/java/com/github/davidmoten/rtree/RTree.java.RTree.[Observable<Entry<T, S>>]entries()", "src/main/java/com/github/davidmoten/rtree/RTree.java.RTree.[Visualizer]visualize(int,int,Rectangle)", "src/main/java/com/github/davidmoten/rtree/RTree.java.RTree.[Visualizer]visualize(int,int)", "src/main/java/com/github/davidmoten/rtree/RTree.java.RTree.[Rectangle]calculateMaxView(RTree<T, S>)", "src/main/java/com/github/davidmoten/rtree/RTree.java.RTree.[Optional<? extends Node<T, S>>]root()", "src/main/java/com/github/davidmoten/rtree/RTree.java.RTree.[Optional<Rectangle>]mbr()", "src/main/java/com/github/davidmoten/rtree/RTree.java.RTree.[boolean]isEmpty()", "src/main/java/com/github/davidmoten/rtree/RTree.java.RTree.[int]size()", "src/main/java/com/github/davidmoten/rtree/RTree.java.RTree.[Context<T, S>]context()", "src/main/java/com/github/davidmoten/rtree/RTree.java.RTree.[String]asString()", "src/main/java/com/github/davidmoten/rtree/RTree.java.RTree.[String]asString(Node<T, S>,String)"], "overrides": null, "attributes": [{"original_string": "    public static class Builder {\n\n        /**\n         * According to http://dbs.mathematik.uni-marburg.de/publications/myPapers\n         * /1990/BKSS90.pdf (R*-tree paper), best filling ratio is 0.4 for both\n         * quadratic split and R*-tree split.\n         */\n        private static final double DEFAULT_FILLING_FACTOR = 0.4;\n        private static final double DEFAULT_LOADING_FACTOR = 0.7;\n        private Optional<Integer> maxChildren = Optional.empty();\n        private Optional<Integer> minChildren = Optional.empty();\n        private Splitter splitter = new SplitterQuadratic();\n        private Selector selector = new SelectorMinimalAreaIncrease();\n        private double loadingFactor;\n        private boolean star = false;\n        private Factory<Object, Geometry> factory = Factories.defaultFactory();\n\n        private Builder() {\n            loadingFactor = DEFAULT_LOADING_FACTOR;\n        }\n\n        /**\n         * The factor is used as the fill ratio during bulk loading.\n         * \n         * @param factor\n         *            loading factor\n         * @return this\n         */\n        public Builder loadingFactor(double factor) {\n            this.loadingFactor = factor;\n            return this;\n        }\n\n        /**\n         * When the number of children in an R-tree node drops below this number the\n         * node is deleted and the children are added on to the R-tree again.\n         * \n         * @param minChildren\n         *            less than this number of children in a node triggers a\n         *            redistribution of its children.\n         * @return builder\n         */\n        public Builder minChildren(int minChildren) {\n            this.minChildren = of(minChildren);\n            return this;\n        }\n\n        /**\n         * Sets the max number of children in an R-tree node.\n         * \n         * @param maxChildren\n         *            max number of children in R-tree node.\n         * @return builder\n         */\n        public Builder maxChildren(int maxChildren) {\n            this.maxChildren = of(maxChildren);\n            return this;\n        }\n\n        /**\n         * Sets the {@link Splitter} to use when maxChildren is reached.\n         * \n         * @param splitter\n         *            node splitting method to use\n         * @return builder\n         */\n        public Builder splitter(Splitter splitter) {\n            this.splitter = splitter;\n            return this;\n        }\n\n        /**\n         * Sets the node {@link Selector} which decides which branches to follow when\n         * inserting or searching.\n         * \n         * @param selector\n         *            selects the branch to follow when inserting or searching\n         * @return builder\n         */\n        public Builder selector(Selector selector) {\n            this.selector = selector;\n            return this;\n        }\n\n        /**\n         * Sets the splitter to {@link SplitterRStar} and selector to\n         * {@link SelectorRStar} and defaults to minChildren=10.\n         * \n         * @return builder\n         */\n        public Builder star() {\n            selector = new SelectorRStar();\n            splitter = new SplitterRStar();\n            star = true;\n            return this;\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        public Builder factory(Factory<?, ? extends Geometry> factory) {\n            // TODO could change the signature of Builder to have types to\n            // support this method but would be breaking change for existing\n            // clients\n            this.factory = (Factory<Object, Geometry>) factory;\n            return this;\n        }\n\n        /**\n         * Builds the {@link RTree}.\n         * \n         * @param <T>\n         *            value type\n         * @param <S>\n         *            geometry type\n         * @return RTree\n         */\n        @SuppressWarnings(\"unchecked\")\n        public <T, S extends Geometry> RTree<T, S> create() {\n            setDefaultCapacity();\n\n            return new RTree<T, S>(Optional.<Node<T, S>>empty(), 0,\n                    new Context<T, S>(minChildren.get(), maxChildren.get(), selector, splitter,\n                            (Factory<T, S>) factory));\n        }\n\n        /**\n         * Create an RTree by bulk loading, using the STR method. STR: a simple and\n         * efficient algorithm for R-tree packing\n         * http://ieeexplore.ieee.org/abstract/document/582015/\n         * <p>\n         * Note: this method mutates the input entries, the internal order of the List\n         * may be changed.\n         * </p>\n         * \n         * @param entries\n         *            entries to be added to the r-tree\n         * @return a loaded RTree\n         */\n        @SuppressWarnings(\"unchecked\")\n        public <T, S extends Geometry> RTree<T, S> create(List<Entry<T, S>> entries) {\n            setDefaultCapacity();\n\n            Context<T, S> context = new Context<T, S>(minChildren.get(), maxChildren.get(),\n                    selector, splitter, (Factory<T, S>) factory);\n            return packingSTR(entries, true, entries.size(), context);\n        }\n\n        private void setDefaultCapacity() {\n            if (!maxChildren.isPresent()) {\n                if (star) {\n                    maxChildren = Optional.of(MAX_CHILDREN_DEFAULT_STAR);\n                } else {\n                    maxChildren = Optional.of(MAX_CHILDREN_DEFAULT_GUTTMAN);\n                }\n            }\n            if (!minChildren.isPresent()) {\n                minChildren = Optional.of((int) Math.round(maxChildren.get() * DEFAULT_FILLING_FACTOR));\n            }\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        private <T, S extends Geometry> RTree<T, S> packingSTR(List<? extends HasGeometry> objects,\n                boolean isLeaf, int size, Context<T, S> context) {\n            int capacity = (int) Math.round(maxChildren.get() * loadingFactor);\n            int nodeCount = (int) Math.ceil(1.0 * objects.size() / capacity);\n\n            if (nodeCount == 0) {\n                return create();\n            } else if (nodeCount == 1) {\n                Node<T, S> root;\n                if (isLeaf) {\n                    root = context.factory().createLeaf((List<Entry<T, S>>) objects, context);\n                } else {\n                    root = context.factory().createNonLeaf((List<Node<T, S>>) objects, context);\n                }\n                return new RTree<T, S>(of(root), size, context);\n            }\n\n            int nodePerSlice = (int) Math.ceil(Math.sqrt(nodeCount));\n            int sliceCapacity = nodePerSlice * capacity;\n            int sliceCount = (int) Math.ceil(1.0 * objects.size() / sliceCapacity);\n            Collections.sort(objects, new MidComparator((short) 0));\n\n            List<Node<T, S>> nodes = new ArrayList<Node<T, S>>(nodeCount);\n            for (int s = 0; s < sliceCount; s++) {\n                @SuppressWarnings(\"rawtypes\")\n                List slice = objects.subList(s * sliceCapacity,\n                        Math.min((s + 1) * sliceCapacity, objects.size()));\n                Collections.sort(slice, new MidComparator((short) 1));\n\n                for (int i = 0; i < slice.size(); i += capacity) {\n                    if (isLeaf) {\n                        List<Entry<T, S>> entries = slice.subList(i,\n                                Math.min(slice.size(), i + capacity));\n                        Node<T, S> leaf = context.factory().createLeaf(entries, context);\n                        nodes.add(leaf);\n                    } else {\n                        List<Node<T, S>> children = slice.subList(i,\n                                Math.min(slice.size(), i + capacity));\n                        Node<T, S> nonleaf = context.factory().createNonLeaf(children, context);\n                        nodes.add(nonleaf);\n                    }\n                }\n            }\n            return packingSTR(nodes, false, size, context);\n        }\n\n        private static final class MidComparator implements Comparator<HasGeometry> {\n            private final short dimension; // leave space for multiple dimensions, 0 for x, 1 for y,\n                                           // ...\n\n            public MidComparator(short dim) {\n                dimension = dim;\n            }\n\n            @Override\n            public int compare(HasGeometry o1, HasGeometry o2) {\n                return Double.compare(mid(o1), mid(o2));\n            }\n\n            private double mid(HasGeometry o) {\n                Rectangle mbr = o.geometry().mbr();\n                if (dimension == 0)\n                    return (mbr.x1() + mbr.x2()) / 2;\n                else\n                    return (mbr.y1() + mbr.y2()) / 2;\n            }\n        }\n\n    }", "definition": "    public static class Builder", "class_docstring": "\nRTree Builder.\n", "name": "Builder", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [{"attribute_expression": "private static final double DEFAULT_FILLING_FACTOR = 0.4;", "docstring": "\nAccording to http://dbs.mathematik.uni-marburg.de/publications/myPapers\n/1990/BKSS90.pdf (R*-tree paper), best filling ratio is 0.4 for both\nquadratic split and R*-tree split.\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "double", "name": "DEFAULT_FILLING_FACTOR = 0.4", "syntax_pass": true}, {"attribute_expression": "private static final double DEFAULT_LOADING_FACTOR = 0.7;", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "double", "name": "DEFAULT_LOADING_FACTOR = 0.7", "syntax_pass": true}, {"attribute_expression": "private Optional<Integer> maxChildren = Optional.empty();", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Optional<Integer>", "name": "maxChildren = Optional.empty()", "syntax_pass": true}, {"attribute_expression": "private Optional<Integer> minChildren = Optional.empty();", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Optional<Integer>", "name": "minChildren = Optional.empty()", "syntax_pass": true}, {"attribute_expression": "private Splitter splitter = new SplitterQuadratic();", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Splitter", "name": "splitter = new SplitterQuadratic()", "syntax_pass": true}, {"attribute_expression": "private Selector selector = new SelectorMinimalAreaIncrease();", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Selector", "name": "selector = new SelectorMinimalAreaIncrease()", "syntax_pass": true}, {"attribute_expression": "private double loadingFactor;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "double", "name": "loadingFactor", "syntax_pass": true}, {"attribute_expression": "private boolean star = false;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "boolean", "name": "star = false", "syntax_pass": true}, {"attribute_expression": "private Factory<Object, Geometry> factory = Factories.defaultFactory();", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Factory<Object, Geometry>", "name": "factory = Factories.defaultFactory()", "syntax_pass": true}], "classes": [{"original_string": "        private static final class MidComparator implements Comparator<HasGeometry> {\n            private final short dimension; // leave space for multiple dimensions, 0 for x, 1 for y,\n                                           // ...\n\n            public MidComparator(short dim) {\n                dimension = dim;\n            }\n\n            @Override\n            public int compare(HasGeometry o1, HasGeometry o2) {\n                return Double.compare(mid(o1), mid(o2));\n            }\n\n            private double mid(HasGeometry o) {\n                Rectangle mbr = o.geometry().mbr();\n                if (dimension == 0)\n                    return (mbr.x1() + mbr.x2()) / 2;\n                else\n                    return (mbr.y1() + mbr.y2()) / 2;\n            }\n        }", "definition": "        private static final class MidComparator implements Comparator<HasGeometry>", "class_docstring": "", "name": "MidComparator", "super_interfaces": ["Comparator<HasGeometry>"], "superclasses": "", "attributes": {"modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "fields": [{"attribute_expression": "private final short dimension;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "short", "name": "dimension", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "            public MidComparator(short dim) {\n                dimension = dim;\n            }", "docstring": " ...", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "MidComparator", "params": [{"name": "dim", "type": "short"}], "body": "                                            {\n                dimension = dim;\n            }", "signature": "public MidComparator(short dim)"}, {"syntax_pass": true, "original_string": "            @Override\n            public int compare(HasGeometry o1, HasGeometry o2) {\n                return Double.compare(mid(o1), mid(o2));\n            }", "docstring": "", "attributes": {"modifiers": "@Override\n            public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "compare", "params": [{"name": "o1", "type": "HasGeometry"}, {"name": "o2", "type": "HasGeometry"}], "body": "                                                               {\n                return Double.compare(mid(o1), mid(o2));\n            }", "signature": "@Override\n            public int compare(HasGeometry o1, HasGeometry o2)"}, {"syntax_pass": true, "original_string": "            private double mid(HasGeometry o) {\n                Rectangle mbr = o.geometry().mbr();\n                if (dimension == 0)\n                    return (mbr.x1() + mbr.x2()) / 2;\n                else\n                    return (mbr.y1() + mbr.y2()) / 2;\n            }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "double", "classes": []}, "name": "mid", "params": [{"name": "o", "type": "HasGeometry"}], "body": "                                              {\n                Rectangle mbr = o.geometry().mbr();\n                if (dimension == 0)\n                    return (mbr.x1() + mbr.x2()) / 2;\n                else\n                    return (mbr.y1() + mbr.y2()) / 2;\n            }", "signature": "private double mid(HasGeometry o)"}]}]}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        private Builder() {\n            loadingFactor = DEFAULT_LOADING_FACTOR;\n        }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "", "classes": []}, "name": "Builder", "params": [], "body": "                          {\n            loadingFactor = DEFAULT_LOADING_FACTOR;\n        }", "signature": "private Builder()"}, {"syntax_pass": true, "original_string": "        public Builder loadingFactor(double factor) {\n            this.loadingFactor = factor;\n            return this;\n        }", "docstring": "\nThe factor is used as the fill ratio during bulk loading.\n\n@param factor\n           loading factor\n@return this\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Builder", "classes": []}, "name": "loadingFactor", "params": [{"name": "factor", "type": "double"}], "body": "                                                    {\n            this.loadingFactor = factor;\n            return this;\n        }", "signature": "public Builder loadingFactor(double factor)"}, {"syntax_pass": true, "original_string": "        public Builder minChildren(int minChildren) {\n            this.minChildren = of(minChildren);\n            return this;\n        }", "docstring": "\nWhen the number of children in an R-tree node drops below this number the\nnode is deleted and the children are added on to the R-tree again.\n\n@param minChildren\n           less than this number of children in a node triggers a\n           redistribution of its children.\n@return builder\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Builder", "classes": []}, "name": "minChildren", "params": [{"name": "minChildren", "type": "int"}], "body": "                                                    {\n            this.minChildren = of(minChildren);\n            return this;\n        }", "signature": "public Builder minChildren(int minChildren)"}, {"syntax_pass": true, "original_string": "        public Builder maxChildren(int maxChildren) {\n            this.maxChildren = of(maxChildren);\n            return this;\n        }", "docstring": "\nSets the max number of children in an R-tree node.\n\n@param maxChildren\n           max number of children in R-tree node.\n@return builder\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Builder", "classes": []}, "name": "maxChildren", "params": [{"name": "maxChildren", "type": "int"}], "body": "                                                    {\n            this.maxChildren = of(maxChildren);\n            return this;\n        }", "signature": "public Builder maxChildren(int maxChildren)"}, {"syntax_pass": true, "original_string": "        public Builder splitter(Splitter splitter) {\n            this.splitter = splitter;\n            return this;\n        }", "docstring": "\nSets the {@link Splitter} to use when maxChildren is reached.\n\n@param splitter\n           node splitting method to use\n@return builder\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Builder", "classes": []}, "name": "splitter", "params": [{"name": "splitter", "type": "Splitter"}], "body": "                                                   {\n            this.splitter = splitter;\n            return this;\n        }", "signature": "public Builder splitter(Splitter splitter)"}, {"syntax_pass": true, "original_string": "        public Builder selector(Selector selector) {\n            this.selector = selector;\n            return this;\n        }", "docstring": "\nSets the node {@link Selector} which decides which branches to follow when\ninserting or searching.\n\n@param selector\n           selects the branch to follow when inserting or searching\n@return builder\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Builder", "classes": []}, "name": "selector", "params": [{"name": "selector", "type": "Selector"}], "body": "                                                   {\n            this.selector = selector;\n            return this;\n        }", "signature": "public Builder selector(Selector selector)"}, {"syntax_pass": true, "original_string": "        public Builder star() {\n            selector = new SelectorRStar();\n            splitter = new SplitterRStar();\n            star = true;\n            return this;\n        }", "docstring": "\nSets the splitter to {@link SplitterRStar} and selector to\n{@link SelectorRStar} and defaults to minChildren=10.\n\n@return builder\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Builder", "classes": []}, "name": "star", "params": [], "body": "                              {\n            selector = new SelectorRStar();\n            splitter = new SplitterRStar();\n            star = true;\n            return this;\n        }", "signature": "public Builder star()"}, {"syntax_pass": true, "original_string": "        @SuppressWarnings(\"unchecked\")\n        public Builder factory(Factory<?, ? extends Geometry> factory) {\n            // TODO could change the signature of Builder to have types to\n            // support this method but would be breaking change for existing\n            // clients\n            this.factory = (Factory<Object, Geometry>) factory;\n            return this;\n        }", "docstring": "", "attributes": {"modifiers": "@SuppressWarnings(\"unchecked\")\n        public", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings(\"unchecked\")", "public"], "comments": [], "return_type": "Builder", "classes": []}, "name": "factory", "params": [{"name": "factory", "type": "Factory<?, ? extends Geometry>"}], "body": "                                                                       {\n            // TODO could change the signature of Builder to have types to\n            // support this method but would be breaking change for existing\n            // clients\n            this.factory = (Factory<Object, Geometry>) factory;\n            return this;\n        }", "signature": "@SuppressWarnings(\"unchecked\")\n        public Builder factory(Factory<?, ? extends Geometry> factory)"}, {"syntax_pass": true, "original_string": "        @SuppressWarnings(\"unchecked\")\n        public <T, S extends Geometry> RTree<T, S> create() {\n            setDefaultCapacity();\n\n            return new RTree<T, S>(Optional.<Node<T, S>>empty(), 0,\n                    new Context<T, S>(minChildren.get(), maxChildren.get(), selector, splitter,\n                            (Factory<T, S>) factory));\n        }", "docstring": "\nBuilds the {@link RTree}.\n\n@param <T>\n           value type\n@param <S>\n           geometry type\n@return RTree\n", "attributes": {"modifiers": "@SuppressWarnings(\"unchecked\")\n        public", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings(\"unchecked\")", "public"], "comments": [], "return_type": "RTree<T, S>", "classes": []}, "name": "create", "params": [], "body": "                                                            {\n            setDefaultCapacity();\n\n            return new RTree<T, S>(Optional.<Node<T, S>>empty(), 0,\n                    new Context<T, S>(minChildren.get(), maxChildren.get(), selector, splitter,\n                            (Factory<T, S>) factory));\n        }", "signature": "@SuppressWarnings(\"unchecked\")\n        public <T, S extends Geometry> RTree<T, S> create()"}, {"syntax_pass": true, "original_string": "        @SuppressWarnings(\"unchecked\")\n        public <T, S extends Geometry> RTree<T, S> create(List<Entry<T, S>> entries) {\n            setDefaultCapacity();\n\n            Context<T, S> context = new Context<T, S>(minChildren.get(), maxChildren.get(),\n                    selector, splitter, (Factory<T, S>) factory);\n            return packingSTR(entries, true, entries.size(), context);\n        }", "docstring": "\nCreate an RTree by bulk loading, using the STR method. STR: a simple and\nefficient algorithm for R-tree packing\nhttp://ieeexplore.ieee.org/abstract/document/582015/\n<p>\nNote: this method mutates the input entries, the internal order of the List\nmay be changed.\n</p>\n\n@param entries\n           entries to be added to the r-tree\n@return a loaded RTree\n", "attributes": {"modifiers": "@SuppressWarnings(\"unchecked\")\n        public", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings(\"unchecked\")", "public"], "comments": [], "return_type": "RTree<T, S>", "classes": []}, "name": "create", "params": [{"name": "entries", "type": "List<Entry<T, S>>"}], "body": "                                                                                     {\n            setDefaultCapacity();\n\n            Context<T, S> context = new Context<T, S>(minChildren.get(), maxChildren.get(),\n                    selector, splitter, (Factory<T, S>) factory);\n            return packingSTR(entries, true, entries.size(), context);\n        }", "signature": "@SuppressWarnings(\"unchecked\")\n        public <T, S extends Geometry> RTree<T, S> create(List<Entry<T, S>> entries)"}, {"syntax_pass": true, "original_string": "        private void setDefaultCapacity() {\n            if (!maxChildren.isPresent()) {\n                if (star) {\n                    maxChildren = Optional.of(MAX_CHILDREN_DEFAULT_STAR);\n                } else {\n                    maxChildren = Optional.of(MAX_CHILDREN_DEFAULT_GUTTMAN);\n                }\n            }\n            if (!minChildren.isPresent()) {\n                minChildren = Optional.of((int) Math.round(maxChildren.get() * DEFAULT_FILLING_FACTOR));\n            }\n        }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "name": "setDefaultCapacity", "params": [], "body": "                                          {\n            if (!maxChildren.isPresent()) {\n                if (star) {\n                    maxChildren = Optional.of(MAX_CHILDREN_DEFAULT_STAR);\n                } else {\n                    maxChildren = Optional.of(MAX_CHILDREN_DEFAULT_GUTTMAN);\n                }\n            }\n            if (!minChildren.isPresent()) {\n                minChildren = Optional.of((int) Math.round(maxChildren.get() * DEFAULT_FILLING_FACTOR));\n            }\n        }", "signature": "private void setDefaultCapacity()"}, {"syntax_pass": true, "original_string": "        @SuppressWarnings(\"unchecked\")\n        private <T, S extends Geometry> RTree<T, S> packingSTR(List<? extends HasGeometry> objects,\n                boolean isLeaf, int size, Context<T, S> context) {\n            int capacity = (int) Math.round(maxChildren.get() * loadingFactor);\n            int nodeCount = (int) Math.ceil(1.0 * objects.size() / capacity);\n\n            if (nodeCount == 0) {\n                return create();\n            } else if (nodeCount == 1) {\n                Node<T, S> root;\n                if (isLeaf) {\n                    root = context.factory().createLeaf((List<Entry<T, S>>) objects, context);\n                } else {\n                    root = context.factory().createNonLeaf((List<Node<T, S>>) objects, context);\n                }\n                return new RTree<T, S>(of(root), size, context);\n            }\n\n            int nodePerSlice = (int) Math.ceil(Math.sqrt(nodeCount));\n            int sliceCapacity = nodePerSlice * capacity;\n            int sliceCount = (int) Math.ceil(1.0 * objects.size() / sliceCapacity);\n            Collections.sort(objects, new MidComparator((short) 0));\n\n            List<Node<T, S>> nodes = new ArrayList<Node<T, S>>(nodeCount);\n            for (int s = 0; s < sliceCount; s++) {\n                @SuppressWarnings(\"rawtypes\")\n                List slice = objects.subList(s * sliceCapacity,\n                        Math.min((s + 1) * sliceCapacity, objects.size()));\n                Collections.sort(slice, new MidComparator((short) 1));\n\n                for (int i = 0; i < slice.size(); i += capacity) {\n                    if (isLeaf) {\n                        List<Entry<T, S>> entries = slice.subList(i,\n                                Math.min(slice.size(), i + capacity));\n                        Node<T, S> leaf = context.factory().createLeaf(entries, context);\n                        nodes.add(leaf);\n                    } else {\n                        List<Node<T, S>> children = slice.subList(i,\n                                Math.min(slice.size(), i + capacity));\n                        Node<T, S> nonleaf = context.factory().createNonLeaf(children, context);\n                        nodes.add(nonleaf);\n                    }\n                }\n            }\n            return packingSTR(nodes, false, size, context);\n        }", "docstring": "", "attributes": {"modifiers": "@SuppressWarnings(\"unchecked\")\n        private", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings(\"unchecked\")", "private"], "comments": [], "return_type": "RTree<T, S>", "classes": []}, "name": "packingSTR", "params": [{"name": "objects", "type": "List<? extends HasGeometry>"}, {"name": "isLeaf", "type": "boolean"}, {"name": "size", "type": "int"}, {"name": "context", "type": "Context<T, S>"}], "body": "                                                                 {\n            int capacity = (int) Math.round(maxChildren.get() * loadingFactor);\n            int nodeCount = (int) Math.ceil(1.0 * objects.size() / capacity);\n\n            if (nodeCount == 0) {\n                return create();\n            } else if (nodeCount == 1) {\n                Node<T, S> root;\n                if (isLeaf) {\n                    root = context.factory().createLeaf((List<Entry<T, S>>) objects, context);\n                } else {\n                    root = context.factory().createNonLeaf((List<Node<T, S>>) objects, context);\n                }\n                return new RTree<T, S>(of(root), size, context);\n            }\n\n            int nodePerSlice = (int) Math.ceil(Math.sqrt(nodeCount));\n            int sliceCapacity = nodePerSlice * capacity;\n            int sliceCount = (int) Math.ceil(1.0 * objects.size() / sliceCapacity);\n            Collections.sort(objects, new MidComparator((short) 0));\n\n            List<Node<T, S>> nodes = new ArrayList<Node<T, S>>(nodeCount);\n            for (int s = 0; s < sliceCount; s++) {\n                @SuppressWarnings(\"rawtypes\")\n                List slice = objects.subList(s * sliceCapacity,\n                        Math.min((s + 1) * sliceCapacity, objects.size()));\n                Collections.sort(slice, new MidComparator((short) 1));\n\n                for (int i = 0; i < slice.size(); i += capacity) {\n                    if (isLeaf) {\n                        List<Entry<T, S>> entries = slice.subList(i,\n                                Math.min(slice.size(), i + capacity));\n                        Node<T, S> leaf = context.factory().createLeaf(entries, context);\n                        nodes.add(leaf);\n                    } else {\n                        List<Node<T, S>> children = slice.subList(i,\n                                Math.min(slice.size(), i + capacity));\n                        Node<T, S> nonleaf = context.factory().createNonLeaf(children, context);\n                        nodes.add(nonleaf);\n                    }\n                }\n            }\n            return packingSTR(nodes, false, size, context);\n        }", "signature": "@SuppressWarnings(\"unchecked\")\n        private <T, S extends Geometry> RTree<T, S> packingSTR(List<? extends HasGeometry> objects,\n                boolean isLeaf, int size, Context<T, S> context)"}]}], "class_docstring": "\nImmutable in-memory 2D R-Tree with configurable splitter heuristic.\n\n@param <T>\n           the entry value type\n@param <S>\n           the entry geometry type\n", "original_string": "public final class RTree<T, S extends Geometry> {\n\n    public static final Rectangle ZERO_RECTANGLE = rectangle(0, 0, 0, 0);\n    private final Optional<? extends Node<T, S>> root;\n    private final Context<T, S> context;\n\n    /**\n     * Benchmarks show that this is a good choice for up to O(10,000) entries when\n     * using Quadratic splitter (Guttman).\n     */\n    public static final int MAX_CHILDREN_DEFAULT_GUTTMAN = 4;\n\n    /**\n     * Benchmarks show that this is the sweet spot for up to O(10,000) entries when\n     * using R*-tree heuristics.\n     */\n    public static final int MAX_CHILDREN_DEFAULT_STAR = 4;\n\n    /**\n     * Current size in Entries of the RTree.\n     */\n    private final int size;\n    private static final Func2<Optional<Rectangle>, Entry<Object, Geometry>, Optional<Rectangle>> RECTANGLE_ACCUMULATOR =\n            (rectangle, entry) ->\n                    rectangle.map(value -> Optional.of(value.add(entry.geometry().mbr())))\n                            .orElseGet(() -> Optional.of(entry.geometry().mbr()));\n\n    /**\n     * Constructor.\n     *\n     * @param root\n     *            the root node of the tree if present\n     * @param context\n     *            options for the R-tree\n     */\n    private RTree(Optional<? extends Node<T, S>> root, int size, Context<T, S> context) {\n        this.root = root;\n        this.size = size;\n        this.context = context;\n    }\n\n    private RTree() {\n        this(Optional.empty(), 0, null);\n    }\n\n    /**\n     * Constructor.\n     * \n     * @param root\n     *            the root node of the R-tree\n     * @param context\n     *            options for the R-tree\n     */\n    private RTree(Node<T, S> root, int size, Context<T, S> context) {\n        this(of(root), size, context);\n    }\n\n    static <T, S extends Geometry> RTree<T, S> create(Optional<? extends Node<T, S>> root, int size,\n            Context<T, S> context) {\n        return new RTree<T, S>(root, size, context);\n    }\n\n    /**\n     * Returns a new Builder instance for {@link RTree}. Defaults to\n     * maxChildren=128, minChildren=64, splitter=QuadraticSplitter.\n     * \n     * @param <T>\n     *            the value type of the entries in the tree\n     * @param <S>\n     *            the geometry type of the entries in the tree\n     * @return a new RTree instance\n     */\n    public static <T, S extends Geometry> RTree<T, S> create() {\n        return new Builder().create();\n    }\n\n    /**\n     * Construct an Rtree through STR bulk loading. Default to maxChildren=128,\n     * minChildren=64 and fill nodes by a factor of 0.7\n     * \n     * @param entries\n     *            entries to add to the R-tree\n     *\n     * @param <T>\n     *            the value type of the entries in the tree\n     * @param <S>\n     *            the geometry type of the entries in the tree\n     * @return a new RTree instance\n     */\n    public static <T, S extends Geometry> RTree<T, S> create(List<Entry<T, S>> entries) {\n        return new Builder().create(entries);\n    }\n\n    /**\n     * The tree is scanned for depth and the depth returned. This involves recursing\n     * down to the leaf level of the tree to get the current depth. Should be\n     * <code>log(n)</code> in complexity.\n     * \n     * @return depth of the R-tree\n     */\n    public int calculateDepth() {\n        return calculateDepth(root);\n    }\n\n    private static <T, S extends Geometry> int calculateDepth(Optional<? extends Node<T, S>> root) {\n        return root.map(node -> calculateDepth(node, 0)).orElse(0);\n    }\n\n    private static <T, S extends Geometry> int calculateDepth(Node<T, S> node, int depth) {\n        if (node instanceof Leaf) {\n            return depth + 1;\n        } else {\n            return calculateDepth(((NonLeaf<T, S>) node).child(0), depth + 1);\n        }\n    }\n\n    /**\n     * When the number of children in an R-tree node drops below this number the\n     * node is deleted and the children are added on to the R-tree again.\n     * \n     * @param minChildren\n     *            less than this number of children in a node triggers a node\n     *            deletion and redistribution of its members\n     * @return builder\n     */\n    public static Builder minChildren(int minChildren) {\n        return new Builder().minChildren(minChildren);\n    }\n\n    /**\n     * Sets the max number of children in an R-tree node.\n     * \n     * @param maxChildren\n     *            max number of children in an R-tree node\n     * @return builder\n     */\n    public static Builder maxChildren(int maxChildren) {\n        return new Builder().maxChildren(maxChildren);\n    }\n\n    /**\n     * Sets the {@link Splitter} to use when maxChildren is reached.\n     * \n     * @param splitter\n     *            the splitter algorithm to use\n     * @return builder\n     */\n    public static Builder splitter(Splitter splitter) {\n        return new Builder().splitter(splitter);\n    }\n\n    /**\n     * Sets the node {@link Selector} which decides which branches to follow when\n     * inserting or searching.\n     * \n     * @param selector\n     *            determines which branches to follow when inserting or searching\n     * @return builder\n     */\n    public static Builder selector(Selector selector) {\n        return new Builder().selector(selector);\n    }\n\n    /**\n     * Sets the splitter to {@link SplitterRStar} and selector to\n     * {@link SelectorRStar} and defaults to minChildren=10.\n     * \n     * @return builder\n     */\n    public static Builder star() {\n        return new Builder().star();\n    }\n\n    /**\n     * RTree Builder.\n     */\n    public static class Builder {\n\n        /**\n         * According to http://dbs.mathematik.uni-marburg.de/publications/myPapers\n         * /1990/BKSS90.pdf (R*-tree paper), best filling ratio is 0.4 for both\n         * quadratic split and R*-tree split.\n         */\n        private static final double DEFAULT_FILLING_FACTOR = 0.4;\n        private static final double DEFAULT_LOADING_FACTOR = 0.7;\n        private Optional<Integer> maxChildren = Optional.empty();\n        private Optional<Integer> minChildren = Optional.empty();\n        private Splitter splitter = new SplitterQuadratic();\n        private Selector selector = new SelectorMinimalAreaIncrease();\n        private double loadingFactor;\n        private boolean star = false;\n        private Factory<Object, Geometry> factory = Factories.defaultFactory();\n\n        private Builder() {\n            loadingFactor = DEFAULT_LOADING_FACTOR;\n        }\n\n        /**\n         * The factor is used as the fill ratio during bulk loading.\n         * \n         * @param factor\n         *            loading factor\n         * @return this\n         */\n        public Builder loadingFactor(double factor) {\n            this.loadingFactor = factor;\n            return this;\n        }\n\n        /**\n         * When the number of children in an R-tree node drops below this number the\n         * node is deleted and the children are added on to the R-tree again.\n         * \n         * @param minChildren\n         *            less than this number of children in a node triggers a\n         *            redistribution of its children.\n         * @return builder\n         */\n        public Builder minChildren(int minChildren) {\n            this.minChildren = of(minChildren);\n            return this;\n        }\n\n        /**\n         * Sets the max number of children in an R-tree node.\n         * \n         * @param maxChildren\n         *            max number of children in R-tree node.\n         * @return builder\n         */\n        public Builder maxChildren(int maxChildren) {\n            this.maxChildren = of(maxChildren);\n            return this;\n        }\n\n        /**\n         * Sets the {@link Splitter} to use when maxChildren is reached.\n         * \n         * @param splitter\n         *            node splitting method to use\n         * @return builder\n         */\n        public Builder splitter(Splitter splitter) {\n            this.splitter = splitter;\n            return this;\n        }\n\n        /**\n         * Sets the node {@link Selector} which decides which branches to follow when\n         * inserting or searching.\n         * \n         * @param selector\n         *            selects the branch to follow when inserting or searching\n         * @return builder\n         */\n        public Builder selector(Selector selector) {\n            this.selector = selector;\n            return this;\n        }\n\n        /**\n         * Sets the splitter to {@link SplitterRStar} and selector to\n         * {@link SelectorRStar} and defaults to minChildren=10.\n         * \n         * @return builder\n         */\n        public Builder star() {\n            selector = new SelectorRStar();\n            splitter = new SplitterRStar();\n            star = true;\n            return this;\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        public Builder factory(Factory<?, ? extends Geometry> factory) {\n            // TODO could change the signature of Builder to have types to\n            // support this method but would be breaking change for existing\n            // clients\n            this.factory = (Factory<Object, Geometry>) factory;\n            return this;\n        }\n\n        /**\n         * Builds the {@link RTree}.\n         * \n         * @param <T>\n         *            value type\n         * @param <S>\n         *            geometry type\n         * @return RTree\n         */\n        @SuppressWarnings(\"unchecked\")\n        public <T, S extends Geometry> RTree<T, S> create() {\n            setDefaultCapacity();\n\n            return new RTree<T, S>(Optional.<Node<T, S>>empty(), 0,\n                    new Context<T, S>(minChildren.get(), maxChildren.get(), selector, splitter,\n                            (Factory<T, S>) factory));\n        }\n\n        /**\n         * Create an RTree by bulk loading, using the STR method. STR: a simple and\n         * efficient algorithm for R-tree packing\n         * http://ieeexplore.ieee.org/abstract/document/582015/\n         * <p>\n         * Note: this method mutates the input entries, the internal order of the List\n         * may be changed.\n         * </p>\n         * \n         * @param entries\n         *            entries to be added to the r-tree\n         * @return a loaded RTree\n         */\n        @SuppressWarnings(\"unchecked\")\n        public <T, S extends Geometry> RTree<T, S> create(List<Entry<T, S>> entries) {\n            setDefaultCapacity();\n\n            Context<T, S> context = new Context<T, S>(minChildren.get(), maxChildren.get(),\n                    selector, splitter, (Factory<T, S>) factory);\n            return packingSTR(entries, true, entries.size(), context);\n        }\n\n        private void setDefaultCapacity() {\n            if (!maxChildren.isPresent()) {\n                if (star) {\n                    maxChildren = Optional.of(MAX_CHILDREN_DEFAULT_STAR);\n                } else {\n                    maxChildren = Optional.of(MAX_CHILDREN_DEFAULT_GUTTMAN);\n                }\n            }\n            if (!minChildren.isPresent()) {\n                minChildren = Optional.of((int) Math.round(maxChildren.get() * DEFAULT_FILLING_FACTOR));\n            }\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        private <T, S extends Geometry> RTree<T, S> packingSTR(List<? extends HasGeometry> objects,\n                boolean isLeaf, int size, Context<T, S> context) {\n            int capacity = (int) Math.round(maxChildren.get() * loadingFactor);\n            int nodeCount = (int) Math.ceil(1.0 * objects.size() / capacity);\n\n            if (nodeCount == 0) {\n                return create();\n            } else if (nodeCount == 1) {\n                Node<T, S> root;\n                if (isLeaf) {\n                    root = context.factory().createLeaf((List<Entry<T, S>>) objects, context);\n                } else {\n                    root = context.factory().createNonLeaf((List<Node<T, S>>) objects, context);\n                }\n                return new RTree<T, S>(of(root), size, context);\n            }\n\n            int nodePerSlice = (int) Math.ceil(Math.sqrt(nodeCount));\n            int sliceCapacity = nodePerSlice * capacity;\n            int sliceCount = (int) Math.ceil(1.0 * objects.size() / sliceCapacity);\n            Collections.sort(objects, new MidComparator((short) 0));\n\n            List<Node<T, S>> nodes = new ArrayList<Node<T, S>>(nodeCount);\n            for (int s = 0; s < sliceCount; s++) {\n                @SuppressWarnings(\"rawtypes\")\n                List slice = objects.subList(s * sliceCapacity,\n                        Math.min((s + 1) * sliceCapacity, objects.size()));\n                Collections.sort(slice, new MidComparator((short) 1));\n\n                for (int i = 0; i < slice.size(); i += capacity) {\n                    if (isLeaf) {\n                        List<Entry<T, S>> entries = slice.subList(i,\n                                Math.min(slice.size(), i + capacity));\n                        Node<T, S> leaf = context.factory().createLeaf(entries, context);\n                        nodes.add(leaf);\n                    } else {\n                        List<Node<T, S>> children = slice.subList(i,\n                                Math.min(slice.size(), i + capacity));\n                        Node<T, S> nonleaf = context.factory().createNonLeaf(children, context);\n                        nodes.add(nonleaf);\n                    }\n                }\n            }\n            return packingSTR(nodes, false, size, context);\n        }\n\n        private static final class MidComparator implements Comparator<HasGeometry> {\n            private final short dimension; // leave space for multiple dimensions, 0 for x, 1 for y,\n                                           // ...\n\n            public MidComparator(short dim) {\n                dimension = dim;\n            }\n\n            @Override\n            public int compare(HasGeometry o1, HasGeometry o2) {\n                return Double.compare(mid(o1), mid(o2));\n            }\n\n            private double mid(HasGeometry o) {\n                Rectangle mbr = o.geometry().mbr();\n                if (dimension == 0)\n                    return (mbr.x1() + mbr.x2()) / 2;\n                else\n                    return (mbr.y1() + mbr.y2()) / 2;\n            }\n        }\n\n    }\n\n    /**\n     * Returns an immutable copy of the RTree with the addition of given entry.\n     * \n     * @param entry\n     *            item to add to the R-tree.\n     * @return a new immutable R-tree including the new entry\n     */\n    @SuppressWarnings(\"unchecked\")\n    public RTree<T, S> add(Entry<? extends T, ? extends S> entry) {\n        if (root.isPresent()) {\n            List<Node<T, S>> nodes = root.get().add(entry);\n            Node<T, S> node;\n            if (nodes.size() == 1)\n                node = nodes.get(0);\n            else {\n                node = context.factory().createNonLeaf(nodes, context);\n            }\n            return new RTree<T, S>(node, size + 1, context);\n        } else {\n            Leaf<T, S> node = context.factory().createLeaf(Lists.newArrayList((Entry<T, S>) entry),\n                    context);\n            return new RTree<T, S>(node, size + 1, context);\n        }\n    }\n\n    /**\n     * Returns an immutable copy of the RTree with the addition of an entry\n     * comprised of the given value and Geometry.\n     * \n     * @param value\n     *            the value of the {@link Entry} to be added\n     * @param geometry\n     *            the geometry of the {@link Entry} to be added\n     * @return a new immutable R-tree including the new entry\n     */\n    public RTree<T, S> add(T value, S geometry) {\n        return add(context.factory().createEntry(value, geometry));\n    }\n\n    /**\n     * Returns an immutable RTree with the current entries and the additional\n     * entries supplied as a parameter.\n     * \n     * @param entries\n     *            entries to add\n     * @return R-tree with entries added\n     */\n    public RTree<T, S> add(Iterable<Entry<T, S>> entries) {\n        RTree<T, S> tree = this;\n        for (Entry<T, S> entry : entries)\n            tree = tree.add(entry);\n        return tree;\n    }\n\n    /**\n     * Returns the Observable sequence of trees created by progressively adding\n     * entries.\n     * \n     * @param entries\n     *            the entries to add\n     * @return a sequence of trees\n     */\n    public Observable<RTree<T, S>> add(Observable<Entry<T, S>> entries) {\n        return entries.scan(this, (tree, entry) -> tree.add(entry));\n    }\n\n    /**\n     * Returns the Observable sequence of trees created by progressively deleting\n     * entries.\n     * \n     * @param entries\n     *            the entries to add\n     * @param all\n     *            if true delete all matching otherwise just first matching\n     * @return a sequence of trees\n     */\n    public Observable<RTree<T, S>> delete(Observable<Entry<T, S>> entries, final boolean all) {\n        return entries.scan(this, new Func2<RTree<T, S>, Entry<T, S>, RTree<T, S>>() {\n\n            @Override\n            public RTree<T, S> call(RTree<T, S> tree, Entry<T, S> entry) {\n                return tree.delete(entry, all);\n            }\n        });\n    }\n\n    /**\n     * Returns a new R-tree with the given entries deleted. If <code>all</code> is\n     * false deletes only one if exists. If <code>all</code> is true deletes all\n     * matching entries.\n     * \n     * @param entries\n     *            entries to delete\n     * @param all\n     *            if false deletes one if exists else deletes all\n     * @return R-tree with entries deleted\n     */\n    public RTree<T, S> delete(Iterable<Entry<T, S>> entries, boolean all) {\n        RTree<T, S> tree = this;\n        for (Entry<T, S> entry : entries)\n            tree = tree.delete(entry, all);\n        return tree;\n    }\n\n    /**\n     * Returns a new R-tree with the given entries deleted but only one matching\n     * occurence of each entry is deleted.\n     * \n     * @param entries\n     *            entries to delete\n     * @return R-tree with entries deleted up to one matching occurence per entry\n     */\n    public RTree<T, S> delete(Iterable<Entry<T, S>> entries) {\n        RTree<T, S> tree = this;\n        for (Entry<T, S> entry : entries)\n            tree = tree.delete(entry);\n        return tree;\n    }\n\n    /**\n     * If <code>all</code> is false deletes one entry matching the given value and\n     * Geometry. If <code>all</code> is true deletes all entries matching the given\n     * value and geometry. This method has no effect if the entry is not present.\n     * The entry must match on both value and geometry to be deleted.\n     * \n     * @param value\n     *            the value of the {@link Entry} to be deleted\n     * @param geometry\n     *            the geometry of the {@link Entry} to be deleted\n     * @param all\n     *            if false deletes one if exists else deletes all\n     * @return a new immutable R-tree without one or many instances of the specified\n     *         entry if it exists otherwise returns the original RTree object\n     */\n    public RTree<T, S> delete(T value, S geometry, boolean all) {\n        return delete(context.factory().createEntry(value, geometry), all);\n    }\n\n    /**\n     * Deletes maximum one entry matching the given value and geometry. This method\n     * has no effect if the entry is not present. The entry must match on both value\n     * and geometry to be deleted.\n     * \n     * @param value\n     *            the value to be matched for deletion\n     * @param geometry\n     *            the geometry to be matched for deletion\n     * @return an immutable RTree without one entry (if found) matching the given\n     *         value and geometry\n     */\n    public RTree<T, S> delete(T value, S geometry) {\n        return delete(context.factory().createEntry(value, geometry), false);\n    }\n\n    /**\n     * Deletes one or all matching entries depending on the value of\n     * <code>all</code>. If multiple copies of the entry are in the R-tree only one\n     * will be deleted if all is false otherwise all matching entries will be\n     * deleted. The entry must match on both value and geometry to be deleted.\n     * \n     * @param entry\n     *            the {@link Entry} to be deleted\n     * @param all\n     *            if true deletes all matches otherwise deletes first found\n     * @return a new immutable R-tree without one instance of the specified entry\n     */\n    public RTree<T, S> delete(Entry<? extends T, ? extends S> entry, boolean all) {\n        if (root.isPresent()) {\n            NodeAndEntries<T, S> nodeAndEntries = root.get().delete(entry, all);\n            if (nodeAndEntries.node().isPresent() && nodeAndEntries.node().get() == root.get())\n                return this;\n            else\n                return new RTree<T, S>(nodeAndEntries.node(),\n                        size - nodeAndEntries.countDeleted() - nodeAndEntries.entriesToAdd().size(),\n                        context).add(nodeAndEntries.entriesToAdd());\n        } else\n            return this;\n    }\n\n    /**\n     * Deletes one entry if it exists, returning an immutable copy of the RTree\n     * without that entry. If multiple copies of the entry are in the R-tree only\n     * one will be deleted. The entry must match on both value and geometry to be\n     * deleted.\n     * \n     * @param entry\n     *            the {@link Entry} to be deleted\n     * @return a new immutable R-tree without one instance of the specified entry\n     */\n    public RTree<T, S> delete(Entry<? extends T, ? extends S> entry) {\n        return delete(entry, false);\n    }\n\n    /**\n     * <p>\n     * Returns an Observable sequence of {@link Entry} that satisfy the given\n     * condition. Note that this method is well-behaved only if:\n     *\n     * \n     * <p>\n     * {@code condition(g)} is true for {@link Geometry} g implies\n     * {@code condition(r)} is true for the minimum bounding rectangles of the\n     * ancestor nodes.\n     * \n     * <p>\n     * {@code distance(g) < D} is an example of such a condition.\n     * \n     * \n     * @param condition\n     *            return Entries whose geometry satisfies the given condition\n     * @return sequence of matching entries\n     */\n    @VisibleForTesting\n    Observable<Entry<T, S>> search(Func1<? super Geometry, Boolean> condition) {\n        return root\n                .map(node -> Observable.unsafeCreate(new OnSubscribeSearch<>(node, condition)))\n                .orElseGet(Observable::empty);\n    }\n\n    /**\n     * Returns a predicate function that indicates if {@link Geometry} intersects\n     * with a given rectangle.\n     * \n     * @param r\n     *            the rectangle to check intersection with\n     * @return whether the geometry and the rectangle intersect\n     */\n    public static Func1<Geometry, Boolean> intersects(final Rectangle r) {\n        return g -> g.intersects(r);\n    }\n\n    /**\n     * Returns the always true predicate. See {@link RTree#entries()} for example\n     * use.\n     */\n    private static final Func1<Geometry, Boolean> ALWAYS_TRUE = rectangle -> true;\n\n    /**\n     * Returns an {@link Observable} sequence of all {@link Entry}s in the R-tree\n     * whose minimum bounding rectangle intersects with the given rectangle.\n     * \n     * @param r\n     *            rectangle to check intersection with the entry mbr\n     * @return entries that intersect with the rectangle r\n     */\n    public Observable<Entry<T, S>> search(final Rectangle r) {\n        return search(intersects(r));\n    }\n\n    /**\n     * Returns an {@link Observable} sequence of all {@link Entry}s in the R-tree\n     * whose minimum bounding rectangle intersects with the given point.\n     * \n     * @param p\n     *            point to check intersection with the entry mbr\n     * @return entries that intersect with the point p\n     */\n    public Observable<Entry<T, S>> search(final Point p) {\n        return search(p.mbr());\n    }\n\n    public Observable<Entry<T, S>> search(Circle circle) {\n        return search(circle, Intersects.geometryIntersectsCircle);\n    }\n\n    public Observable<Entry<T, S>> search(Line line) {\n        return search(line, Intersects.geometryIntersectsLine);\n    }\n\n    /**\n     * Returns an {@link Observable} sequence of all {@link Entry}s in the R-tree\n     * whose minimum bounding rectangles are strictly less than maxDistance from the\n     * given rectangle.\n     * \n     * @param r\n     *            rectangle to measure distance from\n     * @param maxDistance\n     *            entries returned must be within this distance from rectangle r\n     * @return the sequence of matching entries\n     */\n    public Observable<Entry<T, S>> search(final Rectangle r, final double maxDistance) {\n        return search(g -> g.distance(r) < maxDistance);\n    }\n\n    /**\n     * Returns the intersections with the the given (arbitrary) geometry using an\n     * intersection function to filter the search results returned from a search of\n     * the mbr of <code>g</code>.\n     * \n     * @param <R>\n     *            type of geometry being searched for intersection with\n     * @param g\n     *            geometry being searched for intersection with\n     * @param intersects\n     *            function to determine if the two geometries intersect\n     * @return a sequence of entries that intersect with g\n     */\n    public <R extends Geometry> Observable<Entry<T, S>> search(final R g,\n                                                               final Func2<? super S, ? super R, Boolean> intersects) {\n        return search(g.mbr()).filter(entry -> intersects.call(entry.geometry(), g));\n    }\n\n    /**\n     * Returns all entries strictly less than <code>maxDistance</code> from the\n     * given geometry. Because the geometry may be of an arbitrary type it is\n     * necessary to also pass a distance function.\n     * \n     * @param <R>\n     *            type of the geometry being searched for\n     * @param g\n     *            geometry to search for entries within maxDistance of\n     * @param maxDistance\n     *            strict max distance that entries must be from g\n     * @param distance\n     *            function to calculate the distance between geometries of type S\n     *            and R.\n     * @return entries strictly less than maxDistance from g\n     */\n    public <R extends Geometry> Observable<Entry<T, S>> search(final R g, final double maxDistance,\n        final Func2<? super S, ? super R, Double> distance) {\n        // just use the mbr initially\n        return search(entry -> entry.distance(g.mbr()) < maxDistance)\n                // refine with distance function\n                .filter(entry -> distance.call(entry.geometry(), g) < maxDistance);\n    }\n\n    /**\n     * Returns an {@link Observable} sequence of all {@link Entry}s in the R-tree\n     * whose minimum bounding rectangles are within maxDistance from the given\n     * point.\n     * \n     * @param p\n     *            point to measure distance from\n     * @param maxDistance\n     *            entries returned must be within this distance from point p\n     * @return the sequence of matching entries\n     */\n    public Observable<Entry<T, S>> search(final Point p, final double maxDistance) {\n        return search(p.mbr(), maxDistance);\n    }\n\n    /**\n     * Returns the nearest k entries (k=maxCount) to the given rectangle where the\n     * entries are strictly less than a given maximum distance from the rectangle.\n     * \n     * @param r\n     *            rectangle\n     * @param maxDistance\n     *            max distance of returned entries from the rectangle\n     * @param maxCount\n     *            max number of entries to return\n     * @return nearest entries to maxCount, in ascending order of distance\n     */\n    public Observable<Entry<T, S>> nearest(final Rectangle r, final double maxDistance,\n            int maxCount) {\n        return search(r, maxDistance).lift(new OperatorBoundedPriorityQueue<Entry<T, S>>(maxCount,\n                Comparators.<T, S>ascendingDistance(r)));\n    }\n\n    /**\n     * Returns the nearest k entries (k=maxCount) to the given point where the\n     * entries are strictly less than a given maximum distance from the point.\n     * \n     * @param p\n     *            point\n     * @param maxDistance\n     *            max distance of returned entries from the point\n     * @param maxCount\n     *            max number of entries to return\n     * @return nearest entries to maxCount, in ascending order of distance\n     */\n    public Observable<Entry<T, S>> nearest(final Point p, final double maxDistance, int maxCount) {\n        return nearest(p.mbr(), maxDistance, maxCount);\n    }\n\n    /**\n     * Returns all entries in the tree as an {@link Observable} sequence.\n     * \n     * @return all entries in the R-tree\n     */\n    public Observable<Entry<T, S>> entries() {\n        return search(ALWAYS_TRUE);\n    }\n\n    /**\n     * Returns a {@link Visualizer} for an image of given width and height and\n     * restricted to the given view of the coordinates. The points in the view are\n     * scaled to match the aspect ratio defined by the width and height.\n     * \n     * @param width\n     *            of the image in pixels\n     * @param height\n     *            of the image in pixels\n     * @param view\n     *            using the coordinate system of the entries\n     * @return visualizer\n     */\n    @SuppressWarnings(\"unchecked\")\n    public Visualizer visualize(int width, int height, Rectangle view) {\n        return new Visualizer((RTree<?, Geometry>) this, width, height, view);\n    }\n\n    /**\n     * Returns a {@link Visualizer} for an image of given width and height and\n     * restricted to the the smallest view that fully contains the coordinates. The\n     * points in the view are scaled to match the aspect ratio defined by the width\n     * and height.\n     * \n     * @param width\n     *            of the image in pixels\n     * @param height\n     *            of the image in pixels\n     * @return visualizer\n     */\n    public Visualizer visualize(int width, int height) {\n        return visualize(width, height, calculateMaxView(this));\n    }\n\n    private Rectangle calculateMaxView(RTree<T, S> tree) {\n        @SuppressWarnings(\"unchecked\")\n        Func2<Optional<Rectangle>, Entry<T, S>, Optional<Rectangle>> ra = //\n                (Func2<Optional<Rectangle>, Entry<T, S>, Optional<Rectangle>>) //\n                (Func2<?,?,?>) //\n                RECTANGLE_ACCUMULATOR;\n        return tree.entries()\n                .reduce(Optional.empty(), ra)\n                .toBlocking().single()\n                .orElse(ZERO_RECTANGLE);\n    }\n\n    public Optional<? extends Node<T, S>> root() {\n        return root;\n    }\n\n    /**\n     * If the RTree has no entries returns {@link Optional#absent} otherwise returns\n     * the minimum bounding rectangle of all entries in the RTree.\n     * \n     * @return minimum bounding rectangle of all entries in RTree\n     */\n    public Optional<Rectangle> mbr() {\n        return root.map(r -> r.geometry().mbr());\n    }\n\n    /**\n     * Returns true if and only if the R-tree is empty of entries.\n     * \n     * @return is R-tree empty\n     */\n    public boolean isEmpty() {\n        return size == 0;\n    }\n\n    /**\n     * Returns the number of entries in the RTree.\n     * \n     * @return the number of entries\n     */\n    public int size() {\n        return size;\n    }\n\n    /**\n     * Returns a {@link Context} containing the configuration of the RTree at the\n     * time of instantiation.\n     * \n     * @return the configuration of the RTree prior to instantiation\n     */\n    public Context<T, S> context() {\n        return context;\n    }\n\n    /**\n     * Returns a human readable form of the RTree. Here's an example:\n     * \n     * <pre>\n     * mbr=Rectangle [x1=10.0, y1=4.0, x2=62.0, y2=85.0]\n     *   mbr=Rectangle [x1=28.0, y1=4.0, x2=34.0, y2=85.0]\n     *     entry=Entry [value=2, geometry=Point [x=29.0, y=4.0]]\n     *     entry=Entry [value=1, geometry=Point [x=28.0, y=19.0]]\n     *     entry=Entry [value=4, geometry=Point [x=34.0, y=85.0]]\n     *   mbr=Rectangle [x1=10.0, y1=45.0, x2=62.0, y2=63.0]\n     *     entry=Entry [value=5, geometry=Point [x=62.0, y=45.0]]\n     *     entry=Entry [value=3, geometry=Point [x=10.0, y=63.0]]\n     * </pre>\n     * \n     * @return a string representation of the RTree\n     */\n    public String asString() {\n        if (!root.isPresent())\n            return \"\";\n        else\n            return asString(root.get(), \"\");\n    }\n\n    private static final String MARGIN_INCREMENT = \"  \";\n\n    private String asString(Node<T, S> node, String margin) {\n        StringBuilder s = new StringBuilder();\n        s.append(margin);\n        s.append(\"mbr=\");\n        s.append(node.geometry());\n        s.append('\\n');\n        if (node instanceof NonLeaf) {\n            NonLeaf<T, S> n = (NonLeaf<T, S>) node;\n            for (int i = 0; i < n.count(); i++) {\n                Node<T, S> child = n.child(i);\n                s.append(asString(child, margin + MARGIN_INCREMENT));\n            }\n        } else {\n            Leaf<T, S> leaf = (Leaf<T, S>) node;\n\n            for (Entry<T, S> entry : leaf.entries()) {\n                s.append(margin);\n                s.append(MARGIN_INCREMENT);\n                s.append(\"entry=\");\n                s.append(entry);\n                s.append('\\n');\n            }\n        }\n        return s.toString();\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "public static final Rectangle ZERO_RECTANGLE = rectangle(0, 0, 0, 0);", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "Rectangle", "name": "ZERO_RECTANGLE = rectangle(0, 0, 0, 0)", "syntax_pass": true}, {"attribute_expression": "private final Optional<? extends Node<T, S>> root;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Optional<? extends Node<T, S>>", "name": "root", "syntax_pass": true}, {"attribute_expression": "private final Context<T, S> context;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Context<T, S>", "name": "context", "syntax_pass": true}, {"attribute_expression": "public static final int MAX_CHILDREN_DEFAULT_GUTTMAN = 4;", "docstring": "\nBenchmarks show that this is a good choice for up to O(10,000) entries when\nusing Quadratic splitter (Guttman).\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "int", "name": "MAX_CHILDREN_DEFAULT_GUTTMAN = 4", "syntax_pass": true}, {"attribute_expression": "public static final int MAX_CHILDREN_DEFAULT_STAR = 4;", "docstring": "\nBenchmarks show that this is the sweet spot for up to O(10,000) entries when\nusing R*-tree heuristics.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "int", "name": "MAX_CHILDREN_DEFAULT_STAR = 4", "syntax_pass": true}, {"attribute_expression": "private final int size;", "docstring": "\nCurrent size in Entries of the RTree.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "int", "name": "size", "syntax_pass": true}, {"attribute_expression": "private static final Func2<Optional<Rectangle>, Entry<Object, Geometry>, Optional<Rectangle>> RECTANGLE_ACCUMULATOR =\n            (rectangle, entry) ->\n                    rectangle.map(value -> Optional.of(value.add(entry.geometry().mbr())))\n                            .orElseGet(() -> Optional.of(entry.geometry().mbr()));", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Func2<Optional<Rectangle>, Entry<Object, Geometry>, Optional<Rectangle>>", "name": "RECTANGLE_ACCUMULATOR =\n            (rectangle, entry) ->\n                    rectangle.map(value -> Optional.of(value.add(entry.geometry().mbr())))\n                            .orElseGet(() -> Optional.of(entry.geometry().mbr()))", "syntax_pass": true}, {"attribute_expression": "private static final Func1<Geometry, Boolean> ALWAYS_TRUE = rectangle -> true;", "docstring": "\nReturns the always true predicate. See {@link RTree#entries()} for example\nuse.\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Func1<Geometry, Boolean>", "name": "ALWAYS_TRUE = rectangle -> true", "syntax_pass": true}, {"attribute_expression": "private static final String MARGIN_INCREMENT = \"  \";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "MARGIN_INCREMENT = \"  \"", "syntax_pass": true}]}, {"uris": "src/main/java/com/github/davidmoten/rtree/fbs/SerializerFlatBuffers.java.SerializerFlatBuffers", "name": "SerializerFlatBuffers", "file_path": "src/main/java/com/github/davidmoten/rtree/fbs/SerializerFlatBuffers.java", "superclasses": "", "methods": ["[]SerializerFlatBuffers(Func1<? super T, byte[]>,Func1<byte[], ? extends T>)", "[Serializer<T, S>]create(Func1<? super T, byte[]>,Func1<byte[], ? extends T>)", "[void]write(RTree<T, S>,OutputStream)", "[int]toBounds(FlatBufferBuilder,Rectangle)", "[int]addNode(Node<T, S>,FlatBufferBuilder,Func1<? super T, byte[]>)", "[RTree<T, S>]read(InputStream,long,InternalStructure)", "[Node<T, S>]toNodeDefault(Node_,Context<T, S>,Func1<byte[], ? extends T>)", "[byte[]]readFully(InputStream,int)"], "method_uris": ["src/main/java/com/github/davidmoten/rtree/fbs/SerializerFlatBuffers.java.SerializerFlatBuffers.[]SerializerFlatBuffers(Func1<? super T, byte[]>,Func1<byte[], ? extends T>)", "src/main/java/com/github/davidmoten/rtree/fbs/SerializerFlatBuffers.java.SerializerFlatBuffers.[Serializer<T, S>]create(Func1<? super T, byte[]>,Func1<byte[], ? extends T>)", "src/main/java/com/github/davidmoten/rtree/fbs/SerializerFlatBuffers.java.SerializerFlatBuffers.[void]write(RTree<T, S>,OutputStream)", "src/main/java/com/github/davidmoten/rtree/fbs/SerializerFlatBuffers.java.SerializerFlatBuffers.[int]toBounds(FlatBufferBuilder,Rectangle)", "src/main/java/com/github/davidmoten/rtree/fbs/SerializerFlatBuffers.java.SerializerFlatBuffers.[int]addNode(Node<T, S>,FlatBufferBuilder,Func1<? super T, byte[]>)", "src/main/java/com/github/davidmoten/rtree/fbs/SerializerFlatBuffers.java.SerializerFlatBuffers.[RTree<T, S>]read(InputStream,long,InternalStructure)", "src/main/java/com/github/davidmoten/rtree/fbs/SerializerFlatBuffers.java.SerializerFlatBuffers.[Node<T, S>]toNodeDefault(Node_,Context<T, S>,Func1<byte[], ? extends T>)", "src/main/java/com/github/davidmoten/rtree/fbs/SerializerFlatBuffers.java.SerializerFlatBuffers.[byte[]]readFully(InputStream,int)"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public final class SerializerFlatBuffers<T, S extends Geometry> implements Serializer<T, S> {\n\n    private final FactoryFlatBuffers<T, S> factory;\n\n    private SerializerFlatBuffers(Func1<? super T, byte[]> serializer,\n            Func1<byte[], ? extends T> deserializer) {\n        this.factory = new FactoryFlatBuffers<T, S>(serializer, deserializer);\n    }\n\n    public static <T, S extends Geometry> Serializer<T, S> create(\n            Func1<? super T, byte[]> serializer, Func1<byte[], ? extends T> deserializer) {\n        return new SerializerFlatBuffers<T, S>(serializer, deserializer);\n    }\n\n    @Override\n    public void write(RTree<T, S> tree, OutputStream os) throws IOException {\n        FlatBufferBuilder builder = new FlatBufferBuilder();\n        final Rectangle mbb;\n        if (tree.root().isPresent()) {\n            mbb = tree.root().get().geometry().mbr();\n        } else {\n            mbb = Geometries.rectangle(0, 0, 0, 0);\n        }\n        int b = toBounds(builder, mbb);\n        Context_.startContext_(builder);\n        Context_.addBounds(builder, b);\n        Context_.addMinChildren(builder, tree.context().minChildren());\n        Context_.addMaxChildren(builder, tree.context().maxChildren());\n        int c = Context_.endContext_(builder);\n        final int n;\n        if (tree.root().isPresent()) {\n            n = addNode(tree.root().get(), builder, factory.serializer());\n        } else {\n            // won't be used\n            n = 0;\n        }\n        // int t = Tree_.createTree_(builder, c, n, tree.size());\n        Tree_.startTree_(builder);\n        Tree_.addContext(builder, c);\n        Tree_.addSize(builder, tree.size());\n        if (tree.size() > 0) {\n            Tree_.addRoot(builder, n);\n        }\n        int t = Tree_.endTree_(builder);\n        Tree_.finishTree_Buffer(builder, t);\n\n        ByteBuffer bb = builder.dataBuffer();\n        os.write(bb.array(), bb.position(), bb.remaining());\n    }\n\n    private static int toBounds(FlatBufferBuilder builder, final Rectangle r) {\n        Bounds_.startBounds_(builder);\n        if (r.isDoublePrecision()) {\n            Bounds_.addType(builder, BoundsType_.BoundsDouble);\n            int box = BoxDouble_.createBoxDouble_(builder, r.x1(), r.y1(), r.x2(), r.y2());\n            Bounds_.addBoxDouble(builder, box);\n        } else {\n            Bounds_.addType(builder, BoundsType_.BoundsFloat);\n            int box = BoxFloat_.createBoxFloat_(builder, (float) r.x1(), (float) r.y1(),\n                    (float) r.x2(), (float) r.y2());\n            Bounds_.addBoxFloat(builder, box);\n        }\n        return Bounds_.endBounds_(builder);\n    }\n\n    private static <T, S extends Geometry> int addNode(Node<T, S> node, FlatBufferBuilder builder,\n            Func1<? super T, byte[]> serializer) {\n        if (node instanceof Leaf) {\n            Leaf<T, S> leaf = (Leaf<T, S>) node;\n            return FlatBuffersHelper.addEntries(leaf.entries(), builder, serializer);\n        } else {\n            NonLeaf<T, S> nonLeaf = (NonLeaf<T, S>) node;\n            int[] nodes = new int[nonLeaf.count()];\n            for (int i = 0; i < nonLeaf.count(); i++) {\n                Node<T, S> child = nonLeaf.child(i);\n                nodes[i] = addNode(child, builder, serializer);\n            }\n            int ch = Node_.createChildrenVector(builder, nodes);\n            Rectangle mbb = nonLeaf.geometry().mbr();\n            int b = toBounds(builder, mbb);\n            Node_.startNode_(builder);\n            Node_.addChildren(builder, ch);\n            Node_.addMbb(builder, b);\n            return Node_.endNode_(builder);\n        }\n    }\n\n    @Override\n    public RTree<T, S> read(InputStream is, long sizeBytes, InternalStructure structure)\n            throws IOException {\n        byte[] bytes = readFully(is, (int) sizeBytes);\n        Tree_ t = Tree_.getRootAsTree_(ByteBuffer.wrap(bytes));\n        Context<T, S> context = new Context<T, S>(t.context().minChildren(),\n                t.context().maxChildren(), new SelectorRStar(), new SplitterRStar(), factory);\n        Node_ node = t.root();\n        if (node == null) {\n            return SerializerHelper.create(Optional.empty(), 0, context);\n        } else {\n            final Node<T, S> root;\n            if (structure == InternalStructure.SINGLE_ARRAY) {\n                if (node.childrenLength() > 0) {\n                    root = new NonLeafFlatBuffers<T, S>(node, context, factory.deserializer());\n                } else {\n                    root = new LeafFlatBuffers<T, S>(node, context, factory.deserializer());\n                }\n            } else {\n                root = toNodeDefault(node, context, factory.deserializer());\n            }\n            return SerializerHelper.create(Optional.of(root), (int) t.size(), context);\n        }\n    }\n\n    private static <T, S extends Geometry> Node<T, S> toNodeDefault(Node_ node,\n            Context<T, S> context, Func1<byte[], ? extends T> deserializer) {\n        int numChildren = node.childrenLength();\n        if (numChildren > 0) {\n            List<Node<T, S>> children = new ArrayList<Node<T, S>>(numChildren);\n            for (int i = 0; i < numChildren; i++) {\n                children.add(toNodeDefault(node.children(i), context, deserializer));\n            }\n            return new NonLeafDefault<T, S>(children, context);\n        } else {\n            List<Entry<T, S>> entries = FlatBuffersHelper.createEntries(node, deserializer);\n            return new LeafDefault<T, S>(entries, context);\n        }\n    }\n\n    @VisibleForTesting\n    static byte[] readFully(InputStream is, int numBytes) throws IOException {\n        byte[] b = new byte[numBytes];\n        int count = 0;\n        do {\n            int n = is.read(b, count, numBytes - count);\n            if (n > 0) {\n                count += n;\n            } else {\n                throw new RuntimeException(\"unexpected\");\n            }\n        } while (count < numBytes);\n        return b;\n    }\n\n}", "super_interfaces": ["Serializer<T, S>"], "fields": [{"attribute_expression": "private final FactoryFlatBuffers<T, S> factory;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "FactoryFlatBuffers<T, S>", "name": "factory", "syntax_pass": true}]}, {"uris": "src/main/java/com/github/davidmoten/rtree/fbs/NonLeafFlatBuffers.java.NonLeafFlatBuffers", "name": "NonLeafFlatBuffers", "file_path": "src/main/java/com/github/davidmoten/rtree/fbs/NonLeafFlatBuffers.java", "superclasses": "", "methods": ["[]NonLeafFlatBuffers(Node_,Context<T, S>,Func1<byte[], ? extends T>)", "[List<Node<T, S>>]add(Entry<? extends T, ? extends S>)", "[NodeAndEntries<T, S>]delete(Entry<? extends T, ? extends S>,boolean)", "[void]searchWithoutBackpressure(Func1<? super Geometry, Boolean>,Subscriber<? super Entry<T, S>>)", "[void]searchWithoutBackpressure(Node_,Func1<? super Geometry, Boolean>,Subscriber<? super Entry<T, S>>,Func1<byte[], ? extends T>,Entry_,Geometry_,Bounds_)", "[List<Node<T, S>>]createChildren()", "[int]count()", "[Context<T, S>]context()", "[Geometry]geometry()", "[Node<T, S>]child(int)", "[List<Node<T, S>>]children()", "[String]toString()"], "method_uris": ["src/main/java/com/github/davidmoten/rtree/fbs/NonLeafFlatBuffers.java.NonLeafFlatBuffers.[]NonLeafFlatBuffers(Node_,Context<T, S>,Func1<byte[], ? extends T>)", "src/main/java/com/github/davidmoten/rtree/fbs/NonLeafFlatBuffers.java.NonLeafFlatBuffers.[List<Node<T, S>>]add(Entry<? extends T, ? extends S>)", "src/main/java/com/github/davidmoten/rtree/fbs/NonLeafFlatBuffers.java.NonLeafFlatBuffers.[NodeAndEntries<T, S>]delete(Entry<? extends T, ? extends S>,boolean)", "src/main/java/com/github/davidmoten/rtree/fbs/NonLeafFlatBuffers.java.NonLeafFlatBuffers.[void]searchWithoutBackpressure(Func1<? super Geometry, Boolean>,Subscriber<? super Entry<T, S>>)", "src/main/java/com/github/davidmoten/rtree/fbs/NonLeafFlatBuffers.java.NonLeafFlatBuffers.[void]searchWithoutBackpressure(Node_,Func1<? super Geometry, Boolean>,Subscriber<? super Entry<T, S>>,Func1<byte[], ? extends T>,Entry_,Geometry_,Bounds_)", "src/main/java/com/github/davidmoten/rtree/fbs/NonLeafFlatBuffers.java.NonLeafFlatBuffers.[List<Node<T, S>>]createChildren()", "src/main/java/com/github/davidmoten/rtree/fbs/NonLeafFlatBuffers.java.NonLeafFlatBuffers.[int]count()", "src/main/java/com/github/davidmoten/rtree/fbs/NonLeafFlatBuffers.java.NonLeafFlatBuffers.[Context<T, S>]context()", "src/main/java/com/github/davidmoten/rtree/fbs/NonLeafFlatBuffers.java.NonLeafFlatBuffers.[Geometry]geometry()", "src/main/java/com/github/davidmoten/rtree/fbs/NonLeafFlatBuffers.java.NonLeafFlatBuffers.[Node<T, S>]child(int)", "src/main/java/com/github/davidmoten/rtree/fbs/NonLeafFlatBuffers.java.NonLeafFlatBuffers.[List<Node<T, S>>]children()", "src/main/java/com/github/davidmoten/rtree/fbs/NonLeafFlatBuffers.java.NonLeafFlatBuffers.[String]toString()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "final class NonLeafFlatBuffers<T, S extends Geometry> implements NonLeaf<T, S> {\n\n    private final Node_ node;\n    private final Context<T, S> context;\n    private final Func1<byte[], ? extends T> deserializer;\n\n    NonLeafFlatBuffers(Node_ node, Context<T, S> context, Func1<byte[], ? extends T> deserializer) {\n        Preconditions.checkNotNull(node);\n        // remove precondition because reduces performance\n        // Preconditions.checkArgument(node.childrenLength() > 0);\n        this.node = node;\n        this.context = context;\n        this.deserializer = deserializer;\n    }\n\n    @Override\n    public List<Node<T, S>> add(Entry<? extends T, ? extends S> entry) {\n        return NonLeafHelper.add(entry, this);\n    }\n\n    @Override\n    public NodeAndEntries<T, S> delete(Entry<? extends T, ? extends S> entry, boolean all) {\n        return NonLeafHelper.delete(entry, all, this);\n    }\n\n    @Override\n    public void searchWithoutBackpressure(Func1<? super Geometry, Boolean> criterion,\n            Subscriber<? super Entry<T, S>> subscriber) {\n        // pass through entry and geometry and box instances to be reused for\n        // flatbuffers extraction this reduces allocation/gc costs (but of\n        // course introduces some mutable ugliness into the codebase)\n        searchWithoutBackpressure(node, criterion, subscriber, deserializer, new Entry_(),\n                new Geometry_(), new Bounds_());\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private static <T, S extends Geometry> void searchWithoutBackpressure(Node_ node,\n            Func1<? super Geometry, Boolean> criterion, Subscriber<? super Entry<T, S>> subscriber,\n            Func1<byte[], ? extends T> deserializer, Entry_ entry, Geometry_ geometry,\n            Bounds_ bounds) {\n        {\n            // write bounds from node to bounds variable\n            node.mbb(bounds);\n            final Rectangle rect;\n            if (bounds.type() == BoundsType_.BoundsDouble) {\n                BoxDouble_ b = bounds.boxDouble();\n                rect = Geometries.rectangle(b.minX(), b.minY(), b.maxX(), b.maxY());\n            } else {\n                BoxFloat_ b = bounds.boxFloat();\n                rect = Geometries.rectangle(b.minX(), b.minY(), b.maxX(), b.maxY());\n            }\n            if (!criterion.call(rect)) {\n                return;\n            }\n        }\n        int numChildren = node.childrenLength();\n        // reduce allocations by reusing objects\n        Node_ child = new Node_();\n        if (numChildren > 0) {\n            for (int i = 0; i < numChildren; i++) {\n                if (subscriber.isUnsubscribed())\n                    return;\n                node.children(child, i);\n                searchWithoutBackpressure(child, criterion, subscriber, deserializer, entry,\n                        geometry, bounds);\n            }\n        } else {\n            int numEntries = node.entriesLength();\n            // reduce allocations by reusing objects\n            // check all entries\n            for (int i = 0; i < numEntries; i++) {\n                if (subscriber.isUnsubscribed())\n                    return;\n                // set entry\n                node.entries(entry, i);\n                // set geometry\n                entry.geometry(geometry);\n                final Geometry g = toGeometry(geometry);\n                if (criterion.call(g)) {\n                    T t = parseObject(deserializer, entry);\n                    Entry<T, S> ent = Entries.entry(t, (S) g);\n                    subscriber.onNext(ent);\n                }\n            }\n        }\n\n    }\n\n    private List<Node<T, S>> createChildren() {\n\n        // reduce allocations by resusing objects\n        int numChildren = node.childrenLength();\n        List<Node<T, S>> children = new ArrayList<Node<T, S>>(numChildren);\n        for (int i = 0; i < numChildren; i++) {\n            Node_ child = node.children(i);\n            if (child.childrenLength() > 0) {\n                children.add(new NonLeafFlatBuffers<T, S>(child, context, deserializer));\n            } else {\n                children.add(new LeafFlatBuffers<T, S>(child, context, deserializer));\n            }\n        }\n        return children;\n    }\n\n    @Override\n    public int count() {\n        return node.childrenLength();\n    }\n\n    @Override\n    public Context<T, S> context() {\n        return context;\n    }\n\n    @Override\n    public Geometry geometry() {\n        return FlatBuffersHelper.createBox(node.mbb());\n    }\n\n    @Override\n    public Node<T, S> child(int i) {\n        Node_ child = node.children(i);\n        if (child.childrenLength() > 0)\n            return new NonLeafFlatBuffers<T, S>(child, context, deserializer);\n        else\n            return new LeafFlatBuffers<T, S>(child, context, deserializer);\n    }\n\n    @Override\n    public List<Node<T, S>> children() {\n        return createChildren();\n    }\n\n    @Override\n    public String toString() {\n        return \"Node [\" + (node.childrenLength() > 0 ? \"NonLeaf\" : \"Leaf\") + \",\"\n                + createBox(node.mbb()).toString() + \"]\";\n    }\n\n}", "super_interfaces": ["NonLeaf<T, S>"], "fields": [{"attribute_expression": "private final Node_ node;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Node_", "name": "node", "syntax_pass": true}, {"attribute_expression": "private final Context<T, S> context;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Context<T, S>", "name": "context", "syntax_pass": true}, {"attribute_expression": "private final Func1<byte[], ? extends T> deserializer;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Func1<byte[], ? extends T>", "name": "deserializer", "syntax_pass": true}]}, {"uris": "src/main/java/com/github/davidmoten/rtree/fbs/LeafFlatBuffers.java.LeafFlatBuffers", "name": "LeafFlatBuffers", "file_path": "src/main/java/com/github/davidmoten/rtree/fbs/LeafFlatBuffers.java", "superclasses": "", "methods": ["[]LeafFlatBuffers(List<Entry<T, S>>,Context<T, S>,Func1<? super T, byte[]>,Func1<byte[], ? extends T>)", "[]LeafFlatBuffers(Node_,Context<T, S>,Func1<byte[], ? extends T>)", "[Node_]createNode(List<Entry<T, S>>,Func1<? super T, byte[]>)", "[List<Node<T, S>>]add(Entry<? extends T, ? extends S>)", "[NodeAndEntries<T, S>]delete(Entry<? extends T, ? extends S>,boolean)", "[void]searchWithoutBackpressure(Func1<? super Geometry, Boolean>,Subscriber<? super Entry<T, S>>)", "[int]count()", "[Context<T, S>]context()", "[Geometry]geometry()", "[List<Entry<T, S>>]entries()", "[Entry<T, S>]entry(int)"], "method_uris": ["src/main/java/com/github/davidmoten/rtree/fbs/LeafFlatBuffers.java.LeafFlatBuffers.[]LeafFlatBuffers(List<Entry<T, S>>,Context<T, S>,Func1<? super T, byte[]>,Func1<byte[], ? extends T>)", "src/main/java/com/github/davidmoten/rtree/fbs/LeafFlatBuffers.java.LeafFlatBuffers.[]LeafFlatBuffers(Node_,Context<T, S>,Func1<byte[], ? extends T>)", "src/main/java/com/github/davidmoten/rtree/fbs/LeafFlatBuffers.java.LeafFlatBuffers.[Node_]createNode(List<Entry<T, S>>,Func1<? super T, byte[]>)", "src/main/java/com/github/davidmoten/rtree/fbs/LeafFlatBuffers.java.LeafFlatBuffers.[List<Node<T, S>>]add(Entry<? extends T, ? extends S>)", "src/main/java/com/github/davidmoten/rtree/fbs/LeafFlatBuffers.java.LeafFlatBuffers.[NodeAndEntries<T, S>]delete(Entry<? extends T, ? extends S>,boolean)", "src/main/java/com/github/davidmoten/rtree/fbs/LeafFlatBuffers.java.LeafFlatBuffers.[void]searchWithoutBackpressure(Func1<? super Geometry, Boolean>,Subscriber<? super Entry<T, S>>)", "src/main/java/com/github/davidmoten/rtree/fbs/LeafFlatBuffers.java.LeafFlatBuffers.[int]count()", "src/main/java/com/github/davidmoten/rtree/fbs/LeafFlatBuffers.java.LeafFlatBuffers.[Context<T, S>]context()", "src/main/java/com/github/davidmoten/rtree/fbs/LeafFlatBuffers.java.LeafFlatBuffers.[Geometry]geometry()", "src/main/java/com/github/davidmoten/rtree/fbs/LeafFlatBuffers.java.LeafFlatBuffers.[List<Entry<T, S>>]entries()", "src/main/java/com/github/davidmoten/rtree/fbs/LeafFlatBuffers.java.LeafFlatBuffers.[Entry<T, S>]entry(int)"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "final class LeafFlatBuffers<T, S extends Geometry> implements Leaf<T, S> {\n\n    private final Node_ node;\n    private final Context<T, S> context;\n    private final Func1<byte[], ? extends T> deserializer;\n\n    LeafFlatBuffers(List<Entry<T, S>> entries, Context<T, S> context,\n            Func1<? super T, byte[]> serializer, Func1<byte[], ? extends T> deserializer) {\n        this(createNode(entries, serializer), context, deserializer);\n    }\n\n    LeafFlatBuffers(Node_ node, Context<T, S> context, Func1<byte[], ? extends T> deserializer) {\n        this.context = context;\n        this.deserializer = deserializer;\n        this.node = node;\n    }\n\n    private static <T, S extends Geometry> Node_ createNode(List<Entry<T, S>> entries,\n            Func1<? super T, byte[]> serializer) {\n        FlatBufferBuilder builder = new FlatBufferBuilder(0);\n        builder.finish(FlatBuffersHelper.addEntries(entries, builder, serializer));\n        return Node_.getRootAsNode_(builder.dataBuffer());\n    }\n\n    @Override\n    public List<Node<T, S>> add(Entry<? extends T, ? extends S> entry) {\n        return LeafHelper.add(entry, this);\n    }\n\n    @Override\n    public NodeAndEntries<T, S> delete(Entry<? extends T, ? extends S> entry, boolean all) {\n        return LeafHelper.delete(entry, all, this);\n    }\n\n    @Override\n    public void searchWithoutBackpressure(Func1<? super Geometry, Boolean> condition,\n            Subscriber<? super Entry<T, S>> subscriber) {\n        // only called when the root of the tree is a Leaf\n        // normally the searchWithoutBackpressure is executed completely within the\n        // NonLeafFlatBuffers class to reduce object creation\n        LeafHelper.search(condition, subscriber, this);\n    }\n\n    @Override\n    public int count() {\n        return node.entriesLength();\n    }\n\n    @Override\n    public Context<T, S> context() {\n        return context;\n    }\n\n    @Override\n    public Geometry geometry() {\n        Bounds_ b = node.mbb();\n        // create on demand to reduce memory use (though not gc pressure)\n        if (b.type() == BoundsType_.BoundsDouble) {\n            BoxDouble_ r = b.boxDouble();\n            return Geometries.rectangle(r.minX(), r.minY(), r.maxX(), r.maxY());\n        } else {\n            BoxFloat_ r = b.boxFloat();\n            return Geometries.rectangle(r.minX(), r.minY(), r.maxX(), r.maxY());\n        }\n    }\n\n    @Override\n    public List<Entry<T, S>> entries() {\n        return FlatBuffersHelper.createEntries(node, deserializer);\n    }\n\n    @Override\n    public Entry<T, S> entry(int i) {\n        return FlatBuffersHelper.createEntry(node, deserializer, i);\n    }\n\n}", "super_interfaces": ["Leaf<T, S>"], "fields": [{"attribute_expression": "private final Node_ node;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Node_", "name": "node", "syntax_pass": true}, {"attribute_expression": "private final Context<T, S> context;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Context<T, S>", "name": "context", "syntax_pass": true}, {"attribute_expression": "private final Func1<byte[], ? extends T> deserializer;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Func1<byte[], ? extends T>", "name": "deserializer", "syntax_pass": true}]}, {"uris": "src/main/java/com/github/davidmoten/rtree/fbs/FlatBuffersHelper.java.FlatBuffersHelper", "name": "FlatBuffersHelper", "file_path": "src/main/java/com/github/davidmoten/rtree/fbs/FlatBuffersHelper.java", "superclasses": "", "methods": ["[]FlatBuffersHelper()", "[int]addEntries(List<Entry<T, S>>,FlatBufferBuilder,Func1<? super T, byte[]>)", "[List<Entry<T, S>>]createEntries(Node_,Func1<byte[], ? extends T>)", "[Entry<T, S>]createEntry(Node_,Func1<byte[], ? extends T>,Entry_,Geometry_,int)", "[Entry<T, S>]createEntry(Node_,Func1<byte[], ? extends T>,int)", "[T]parseObject(Func1<byte[], ? extends T>,Entry_)", "[S]toGeometry(Geometry_)", "[Geometry]createBox(BoxDouble_)", "[Geometry]createBox(BoxFloat_)", "[Rectangle]createBox(Bounds_)", "[Line]createLine(BoxFloat_)", "[Line]createLine(BoxDouble_)"], "method_uris": ["src/main/java/com/github/davidmoten/rtree/fbs/FlatBuffersHelper.java.FlatBuffersHelper.[]FlatBuffersHelper()", "src/main/java/com/github/davidmoten/rtree/fbs/FlatBuffersHelper.java.FlatBuffersHelper.[int]addEntries(List<Entry<T, S>>,FlatBufferBuilder,Func1<? super T, byte[]>)", "src/main/java/com/github/davidmoten/rtree/fbs/FlatBuffersHelper.java.FlatBuffersHelper.[List<Entry<T, S>>]createEntries(Node_,Func1<byte[], ? extends T>)", "src/main/java/com/github/davidmoten/rtree/fbs/FlatBuffersHelper.java.FlatBuffersHelper.[Entry<T, S>]createEntry(Node_,Func1<byte[], ? extends T>,Entry_,Geometry_,int)", "src/main/java/com/github/davidmoten/rtree/fbs/FlatBuffersHelper.java.FlatBuffersHelper.[Entry<T, S>]createEntry(Node_,Func1<byte[], ? extends T>,int)", "src/main/java/com/github/davidmoten/rtree/fbs/FlatBuffersHelper.java.FlatBuffersHelper.[T]parseObject(Func1<byte[], ? extends T>,Entry_)", "src/main/java/com/github/davidmoten/rtree/fbs/FlatBuffersHelper.java.FlatBuffersHelper.[S]toGeometry(Geometry_)", "src/main/java/com/github/davidmoten/rtree/fbs/FlatBuffersHelper.java.FlatBuffersHelper.[Geometry]createBox(BoxDouble_)", "src/main/java/com/github/davidmoten/rtree/fbs/FlatBuffersHelper.java.FlatBuffersHelper.[Geometry]createBox(BoxFloat_)", "src/main/java/com/github/davidmoten/rtree/fbs/FlatBuffersHelper.java.FlatBuffersHelper.[Rectangle]createBox(Bounds_)", "src/main/java/com/github/davidmoten/rtree/fbs/FlatBuffersHelper.java.FlatBuffersHelper.[Line]createLine(BoxFloat_)", "src/main/java/com/github/davidmoten/rtree/fbs/FlatBuffersHelper.java.FlatBuffersHelper.[Line]createLine(BoxDouble_)"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "final class FlatBuffersHelper {\n\n    private FlatBuffersHelper() {\n        // prevent instantiation\n    }\n\n    static <T, S extends Geometry> int addEntries(List<Entry<T, S>> entries,\n            FlatBufferBuilder builder, Func1<? super T, byte[]> serializer) {\n        int[] entries2 = new int[entries.size()];\n        for (int i = 0; i < entries.size(); i++) {\n            Geometry g = entries.get(i).geometry();\n            final int geom;\n            final byte geomType;\n            // Must check Point before Rectangle because Point is instance of\n            // Rectangle\n            if (g instanceof Point) {\n                Point p = (Point) g;\n                if (p.isDoublePrecision()) {\n                    geom = PointDouble_.createPointDouble_(builder, p.x(), p.y());\n                    geomType = GeometryType_.PointDouble;\n                } else {\n                    geom = PointFloat_.createPointFloat_(builder, (float) p.x(), (float) p.y());\n                    geomType = GeometryType_.PointFloat;\n                }\n            } else if (g instanceof Rectangle) {\n                Rectangle b = (Rectangle) g;\n                if (b.isDoublePrecision()) {\n                    geom = BoxDouble_.createBoxDouble_(builder, b.x1(), b.y1(), b.x2(), b.y2());\n                    geomType = GeometryType_.BoxDouble;\n                } else {\n                    geom = BoxFloat_.createBoxFloat_(builder, (float) b.x1(), (float) b.y1(),\n                            (float) b.x2(), (float) b.y2());\n                    geomType = GeometryType_.BoxFloat;\n                }\n            } else if (g instanceof Circle) {\n                Circle c = (Circle) g;\n                if (c.isDoublePrecision()) {\n                    geom = CircleDouble_.createCircleDouble_(builder, c.x(), c.y(), c.radius());\n                    geomType = GeometryType_.CircleDouble;\n                } else {\n                    geom = CircleFloat_.createCircleFloat_(builder, (float) c.x(), (float) c.y(),\n                            (float) c.radius());\n                    geomType = GeometryType_.CircleFloat;\n                }\n            } else if (g instanceof Line) {\n                Line c = (Line) g;\n                if (c.isDoublePrecision()) {\n                    geom = LineDouble_.createLineDouble_(builder, c.x1(), c.y1(), c.x2(), c.y2());\n                    geomType = GeometryType_.LineDouble;\n                } else {\n                    geom = LineFloat_.createLineFloat_(builder, (float) c.x1(), (float) c.y1(),\n                            (float) c.x2(), (float) c.y2());\n                    geomType = GeometryType_.LineFloat;\n                }\n            } else\n                throw new RuntimeException(\"unexpected\");\n\n            Geometry_.startGeometry_(builder);\n            if (geomType == GeometryType_.BoxFloat) {\n                Geometry_.addBoxFloat(builder, geom);\n            } else if (geomType == GeometryType_.BoxDouble) {\n                Geometry_.addBoxDouble(builder, geom);\n            } else if (geomType == GeometryType_.PointFloat) {\n                Geometry_.addPointFloat(builder, geom);\n            } else if (geomType == GeometryType_.PointDouble) {\n                Geometry_.addPointDouble(builder, geom);\n            } else if (geomType == GeometryType_.CircleFloat) {\n                Geometry_.addCircleFloat(builder, geom);\n            } else if (geomType == GeometryType_.CircleDouble) {\n                Geometry_.addCircleDouble(builder, geom);\n            } else if (geomType == GeometryType_.LineFloat) {\n                Geometry_.addLineFloat(builder, geom);\n            } else if (geomType == GeometryType_.LineDouble) {\n                Geometry_.addLineDouble(builder, geom);\n            } else\n                throw new RuntimeException(\"unexpected\");\n\n            Geometry_.addType(builder, geomType);\n            int geo = Geometry_.endGeometry_(builder);\n            int obj = Entry_.createObjectVector(builder, serializer.call(entries.get(i).value()));\n            entries2[i] = Entry_.createEntry_(builder, geo, obj);\n        }\n\n        int ents = Node_.createEntriesVector(builder, entries2);\n\n        Rectangle mbb = Util.mbr(entries);\n        Bounds_.startBounds_(builder);\n        if (mbb.isDoublePrecision()) {\n            int b = BoxDouble_.createBoxDouble_(builder, mbb.x1(), mbb.y1(), mbb.x2(), mbb.y2());\n            Bounds_.addBoxDouble(builder, b);\n            Bounds_.addType(builder, BoundsType_.BoundsDouble);\n        } else {\n            int b = BoxFloat_.createBoxFloat_(builder, (float) mbb.x1(), (float) mbb.y1(),\n                    (float) mbb.x2(), (float) mbb.y2());\n            Bounds_.addBoxFloat(builder, b);\n            Bounds_.addType(builder, BoundsType_.BoundsFloat);\n        }\n        int bounds = Bounds_.endBounds_(builder);\n\n        Node_.startNode_(builder);\n        Node_.addMbb(builder, bounds);\n        Node_.addEntries(builder, ents);\n        return Node_.endNode_(builder);\n\n    }\n\n    static <T, S extends Geometry> List<Entry<T, S>> createEntries(Node_ node,\n            Func1<byte[], ? extends T> deserializer) {\n        int numEntries = node.entriesLength();\n        List<Entry<T, S>> entries = new ArrayList<Entry<T, S>>(numEntries);\n        Preconditions.checkArgument(numEntries > 0);\n        Entry_ entry = new Entry_();\n        Geometry_ geom = new Geometry_();\n        for (int i = 0; i < numEntries; i++) {\n            Entry<T, S> ent = createEntry(node, deserializer, entry, geom, i);\n            entries.add(ent);\n        }\n        return entries;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private static <T, S extends Geometry> Entry<T, S> createEntry(Node_ node,\n            Func1<byte[], ? extends T> deserializer, Entry_ entry, Geometry_ geom, int i) {\n        node.entries(entry, i);\n        entry.geometry(geom);\n        final Geometry g = toGeometry(geom);\n        return Entries.entry(parseObject(deserializer, entry), (S) g);\n    }\n\n    static <T, S extends Geometry> Entry<T, S> createEntry(Node_ node,\n            Func1<byte[], ? extends T> deserializer, int i) {\n        return createEntry(node, deserializer, new Entry_(), new Geometry_(), i);\n    }\n\n    static <T> T parseObject(Func1<byte[], ? extends T> deserializer, Entry_ entry) {\n        ByteBuffer bb = entry.objectAsByteBuffer();\n        if (bb == null) {\n            return null;\n        } else {\n            byte[] bytes = Arrays.copyOfRange(bb.array(), bb.position(), bb.limit());\n            T t = deserializer.call(bytes);\n            return t;\n        }\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    static <S extends Geometry> S toGeometry(Geometry_ g) {\n        final Geometry result;\n        byte type = g.type();\n        if (type == GeometryType_.BoxFloat) {\n            result = createBox(g.boxFloat());\n        } else if (type == GeometryType_.BoxDouble) {\n            result = createBox(g.boxDouble());\n        } else if (type == GeometryType_.PointFloat) {\n            PointFloat_ p = g.pointFloat();\n            result = Geometries.point(p.x(), p.y());\n        } else if (type == GeometryType_.PointDouble) {\n            PointDouble_ p = g.pointDouble();\n            result = Geometries.point(p.x(), p.y());\n        } else if (type == GeometryType_.CircleFloat) {\n            CircleFloat_ c = g.circleFloat();\n            result = Geometries.circle(c.x(), c.y(), c.radius());\n        } else if (type == GeometryType_.CircleDouble) {\n            CircleDouble_ c = g.circleDouble();\n            result = Geometries.circle(c.x(), c.y(), c.radius());\n        } else if (type == GeometryType_.LineFloat) {\n            result = createLine(g.lineFloat());\n        } else if (type == GeometryType_.LineDouble) {\n            result = createLine(g.lineDouble());\n        } else\n            throw new RuntimeException(\"unexpected\");\n        return (S) result;\n    }\n\n    private static Geometry createBox(BoxDouble_ b) {\n        return Geometries.rectangle(b.minX(), b.minY(), b.maxX(), b.maxY());\n    }\n\n    private static Geometry createBox(BoxFloat_ b) {\n        return Geometries.rectangle(b.minX(), b.minY(), b.maxX(), b.maxY());\n    }\n\n    static Rectangle createBox(Bounds_ b) {\n        if (b.type() == BoundsType_.BoundsDouble) {\n            BoxDouble_ r = b.boxDouble();\n            return Geometries.rectangle(r.minX(), r.minY(), r.maxX(), r.maxY());\n        } else {\n            BoxFloat_ r = b.boxFloat();\n            return Geometries.rectangle(r.minX(), r.minY(), r.maxX(), r.maxY());\n        }\n    }\n\n    static Line createLine(BoxFloat_ b) {\n        return Geometries.line(b.minX(), b.minY(), b.maxX(), b.maxY());\n    }\n\n    static Line createLine(BoxDouble_ b) {\n        return Geometries.line(b.minX(), b.minY(), b.maxX(), b.maxY());\n    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/main/java/com/github/davidmoten/rtree/fbs/FactoryFlatBuffers.java.FactoryFlatBuffers", "name": "FactoryFlatBuffers", "file_path": "src/main/java/com/github/davidmoten/rtree/fbs/FactoryFlatBuffers.java", "superclasses": "", "methods": ["[]FactoryFlatBuffers(Func1<? super T, byte[]>,Func1<byte[], ? extends T>)", "[Leaf<T, S>]createLeaf(List<Entry<T, S>>,Context<T, S>)", "[NonLeaf<T, S>]createNonLeaf(List<? extends Node<T, S>>,Context<T, S>)", "[Entry<T, S>]createEntry(T,S)", "[Func1<? super T, byte[]>]serializer()", "[Func1<byte[], ? extends T>]deserializer()"], "method_uris": ["src/main/java/com/github/davidmoten/rtree/fbs/FactoryFlatBuffers.java.FactoryFlatBuffers.[]FactoryFlatBuffers(Func1<? super T, byte[]>,Func1<byte[], ? extends T>)", "src/main/java/com/github/davidmoten/rtree/fbs/FactoryFlatBuffers.java.FactoryFlatBuffers.[Leaf<T, S>]createLeaf(List<Entry<T, S>>,Context<T, S>)", "src/main/java/com/github/davidmoten/rtree/fbs/FactoryFlatBuffers.java.FactoryFlatBuffers.[NonLeaf<T, S>]createNonLeaf(List<? extends Node<T, S>>,Context<T, S>)", "src/main/java/com/github/davidmoten/rtree/fbs/FactoryFlatBuffers.java.FactoryFlatBuffers.[Entry<T, S>]createEntry(T,S)", "src/main/java/com/github/davidmoten/rtree/fbs/FactoryFlatBuffers.java.FactoryFlatBuffers.[Func1<? super T, byte[]>]serializer()", "src/main/java/com/github/davidmoten/rtree/fbs/FactoryFlatBuffers.java.FactoryFlatBuffers.[Func1<byte[], ? extends T>]deserializer()"], "overrides": null, "attributes": [], "class_docstring": "\nConserves memory in comparison to {@link FactoryDefault} especially for\nlarger {@code maxChildren} by saving Leaf objects to byte arrays and using\nFlatBuffers to access the byte array.\n\n@param <T>\n           the object type\n@param <S>\n           the geometry type\n", "original_string": "public final class FactoryFlatBuffers<T, S extends Geometry> implements Factory<T, S> {\n    private final Func1<? super T, byte[]> serializer;\n    private final Func1<byte[], ? extends T> deserializer;\n\n    public FactoryFlatBuffers(Func1<? super T, byte[]> serializer, Func1<byte[], ? extends T> deserializer) {\n        Preconditions.checkNotNull(serializer);\n        Preconditions.checkNotNull(deserializer);\n        this.serializer = serializer;\n        this.deserializer = deserializer;\n    }\n\n    @Override\n    public Leaf<T, S> createLeaf(List<Entry<T, S>> entries, Context<T, S> context) {\n        return new LeafFlatBuffers<T, S>(entries, context, serializer, deserializer);\n    }\n\n    @Override\n    public NonLeaf<T, S> createNonLeaf(List<? extends Node<T, S>> children, Context<T, S> context) {\n        return new NonLeafDefault<T, S>(children, context);\n    }\n\n    @Override\n    public Entry<T, S> createEntry(T value, S geometry) {\n        return Entries.entry(value, geometry);\n    }\n\n    public Func1<? super T, byte[]> serializer() {\n        return serializer;\n    }\n\n    public Func1<byte[], ? extends T> deserializer() {\n        return deserializer;\n    }\n\n}", "super_interfaces": ["Factory<T, S>"], "fields": [{"attribute_expression": "private final Func1<? super T, byte[]> serializer;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Func1<? super T, byte[]>", "name": "serializer", "syntax_pass": true}, {"attribute_expression": "private final Func1<byte[], ? extends T> deserializer;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Func1<byte[], ? extends T>", "name": "deserializer", "syntax_pass": true}]}, {"uris": "src/main/java/com/github/davidmoten/rtree/fbs/generated/BoxFloat_.java.BoxFloat_", "name": "BoxFloat_", "file_path": "src/main/java/com/github/davidmoten/rtree/fbs/generated/BoxFloat_.java", "superclasses": "Struct", "methods": ["[void]__init(int,ByteBuffer)", "[BoxFloat_]__assign(int,ByteBuffer)", "[float]minX()", "[float]minY()", "[float]maxX()", "[float]maxY()", "[int]createBoxFloat_(FlatBufferBuilder,float,float,float,float)"], "method_uris": ["src/main/java/com/github/davidmoten/rtree/fbs/generated/BoxFloat_.java.BoxFloat_.[void]__init(int,ByteBuffer)", "src/main/java/com/github/davidmoten/rtree/fbs/generated/BoxFloat_.java.BoxFloat_.[BoxFloat_]__assign(int,ByteBuffer)", "src/main/java/com/github/davidmoten/rtree/fbs/generated/BoxFloat_.java.BoxFloat_.[float]minX()", "src/main/java/com/github/davidmoten/rtree/fbs/generated/BoxFloat_.java.BoxFloat_.[float]minY()", "src/main/java/com/github/davidmoten/rtree/fbs/generated/BoxFloat_.java.BoxFloat_.[float]maxX()", "src/main/java/com/github/davidmoten/rtree/fbs/generated/BoxFloat_.java.BoxFloat_.[float]maxY()", "src/main/java/com/github/davidmoten/rtree/fbs/generated/BoxFloat_.java.BoxFloat_.[int]createBoxFloat_(FlatBufferBuilder,float,float,float,float)"], "overrides": null, "attributes": [{"original_string": "  public static final class Vector extends BaseVector {\n    public Vector __assign(int _vector, int _element_size, ByteBuffer _bb) { __reset(_vector, _element_size, _bb); return this; }\n\n    public BoxFloat_ get(int j) { return get(new BoxFloat_(), j); }\n    public BoxFloat_ get(BoxFloat_ obj, int j) {  return obj.__assign(__element(j), bb); }\n  }", "definition": "  public static final class Vector extends BaseVector", "class_docstring": "", "name": "Vector", "super_interfaces": [], "superclasses": "BaseVector", "attributes": {"modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    public Vector __assign(int _vector, int _element_size, ByteBuffer _bb) { __reset(_vector, _element_size, _bb); return this; }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Vector", "classes": []}, "name": "__assign", "params": [{"name": "_vector", "type": "int"}, {"name": "_element_size", "type": "int"}, {"name": "_bb", "type": "ByteBuffer"}], "body": "                                                                           { __reset(_vector, _element_size, _bb); return this; }", "signature": "public Vector __assign(int _vector, int _element_size, ByteBuffer _bb)"}, {"syntax_pass": true, "original_string": "    public BoxFloat_ get(int j) { return get(new BoxFloat_(), j); }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "BoxFloat_", "classes": []}, "name": "get", "params": [{"name": "j", "type": "int"}], "body": "                                { return get(new BoxFloat_(), j); }", "signature": "public BoxFloat_ get(int j)"}, {"syntax_pass": true, "original_string": "    public BoxFloat_ get(BoxFloat_ obj, int j) {  return obj.__assign(__element(j), bb); }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "BoxFloat_", "classes": []}, "name": "get", "params": [{"name": "obj", "type": "BoxFloat_"}, {"name": "j", "type": "int"}], "body": "                                               {  return obj.__assign(__element(j), bb); }", "signature": "public BoxFloat_ get(BoxFloat_ obj, int j)"}]}], "class_docstring": "", "original_string": "@SuppressWarnings(\"unused\")\npublic final class BoxFloat_ extends Struct {\n  public void __init(int _i, ByteBuffer _bb) { __reset(_i, _bb); }\n  public BoxFloat_ __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }\n\n  public float minX() { return bb.getFloat(bb_pos + 0); }\n  public float minY() { return bb.getFloat(bb_pos + 4); }\n  public float maxX() { return bb.getFloat(bb_pos + 8); }\n  public float maxY() { return bb.getFloat(bb_pos + 12); }\n\n  public static int createBoxFloat_(FlatBufferBuilder builder, float minX, float minY, float maxX, float maxY) {\n    builder.prep(4, 16);\n    builder.putFloat(maxY);\n    builder.putFloat(maxX);\n    builder.putFloat(minY);\n    builder.putFloat(minX);\n    return builder.offset();\n  }\n\n  public static final class Vector extends BaseVector {\n    public Vector __assign(int _vector, int _element_size, ByteBuffer _bb) { __reset(_vector, _element_size, _bb); return this; }\n\n    public BoxFloat_ get(int j) { return get(new BoxFloat_(), j); }\n    public BoxFloat_ get(BoxFloat_ obj, int j) {  return obj.__assign(__element(j), bb); }\n  }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/main/java/com/github/davidmoten/rtree/fbs/generated/PointDouble_.java.PointDouble_", "name": "PointDouble_", "file_path": "src/main/java/com/github/davidmoten/rtree/fbs/generated/PointDouble_.java", "superclasses": "Struct", "methods": ["[void]__init(int,ByteBuffer)", "[PointDouble_]__assign(int,ByteBuffer)", "[double]x()", "[double]y()", "[int]createPointDouble_(FlatBufferBuilder,double,double)"], "method_uris": ["src/main/java/com/github/davidmoten/rtree/fbs/generated/PointDouble_.java.PointDouble_.[void]__init(int,ByteBuffer)", "src/main/java/com/github/davidmoten/rtree/fbs/generated/PointDouble_.java.PointDouble_.[PointDouble_]__assign(int,ByteBuffer)", "src/main/java/com/github/davidmoten/rtree/fbs/generated/PointDouble_.java.PointDouble_.[double]x()", "src/main/java/com/github/davidmoten/rtree/fbs/generated/PointDouble_.java.PointDouble_.[double]y()", "src/main/java/com/github/davidmoten/rtree/fbs/generated/PointDouble_.java.PointDouble_.[int]createPointDouble_(FlatBufferBuilder,double,double)"], "overrides": null, "attributes": [{"original_string": "  public static final class Vector extends BaseVector {\n    public Vector __assign(int _vector, int _element_size, ByteBuffer _bb) { __reset(_vector, _element_size, _bb); return this; }\n\n    public PointDouble_ get(int j) { return get(new PointDouble_(), j); }\n    public PointDouble_ get(PointDouble_ obj, int j) {  return obj.__assign(__element(j), bb); }\n  }", "definition": "  public static final class Vector extends BaseVector", "class_docstring": "", "name": "Vector", "super_interfaces": [], "superclasses": "BaseVector", "attributes": {"modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    public Vector __assign(int _vector, int _element_size, ByteBuffer _bb) { __reset(_vector, _element_size, _bb); return this; }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Vector", "classes": []}, "name": "__assign", "params": [{"name": "_vector", "type": "int"}, {"name": "_element_size", "type": "int"}, {"name": "_bb", "type": "ByteBuffer"}], "body": "                                                                           { __reset(_vector, _element_size, _bb); return this; }", "signature": "public Vector __assign(int _vector, int _element_size, ByteBuffer _bb)"}, {"syntax_pass": true, "original_string": "    public PointDouble_ get(int j) { return get(new PointDouble_(), j); }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "PointDouble_", "classes": []}, "name": "get", "params": [{"name": "j", "type": "int"}], "body": "                                   { return get(new PointDouble_(), j); }", "signature": "public PointDouble_ get(int j)"}, {"syntax_pass": true, "original_string": "    public PointDouble_ get(PointDouble_ obj, int j) {  return obj.__assign(__element(j), bb); }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "PointDouble_", "classes": []}, "name": "get", "params": [{"name": "obj", "type": "PointDouble_"}, {"name": "j", "type": "int"}], "body": "                                                     {  return obj.__assign(__element(j), bb); }", "signature": "public PointDouble_ get(PointDouble_ obj, int j)"}]}], "class_docstring": "", "original_string": "@SuppressWarnings(\"unused\")\npublic final class PointDouble_ extends Struct {\n  public void __init(int _i, ByteBuffer _bb) { __reset(_i, _bb); }\n  public PointDouble_ __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }\n\n  public double x() { return bb.getDouble(bb_pos + 0); }\n  public double y() { return bb.getDouble(bb_pos + 8); }\n\n  public static int createPointDouble_(FlatBufferBuilder builder, double x, double y) {\n    builder.prep(8, 16);\n    builder.putDouble(y);\n    builder.putDouble(x);\n    return builder.offset();\n  }\n\n  public static final class Vector extends BaseVector {\n    public Vector __assign(int _vector, int _element_size, ByteBuffer _bb) { __reset(_vector, _element_size, _bb); return this; }\n\n    public PointDouble_ get(int j) { return get(new PointDouble_(), j); }\n    public PointDouble_ get(PointDouble_ obj, int j) {  return obj.__assign(__element(j), bb); }\n  }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/main/java/com/github/davidmoten/rtree/fbs/generated/Tree_.java.Tree_", "name": "Tree_", "file_path": "src/main/java/com/github/davidmoten/rtree/fbs/generated/Tree_.java", "superclasses": "Table", "methods": ["[void]ValidateVersion()", "[Tree_]getRootAsTree_(ByteBuffer)", "[Tree_]getRootAsTree_(ByteBuffer,Tree_)", "[void]__init(int,ByteBuffer)", "[Tree_]__assign(int,ByteBuffer)", "[com.github.davidmoten.rtree.fbs.generated.Context_]context()", "[com.github.davidmoten.rtree.fbs.generated.Context_]context(com.github.davidmoten.rtree.fbs.generated.Context_)", "[com.github.davidmoten.rtree.fbs.generated.Node_]root()", "[com.github.davidmoten.rtree.fbs.generated.Node_]root(com.github.davidmoten.rtree.fbs.generated.Node_)", "[long]size()", "[int]createTree_(FlatBufferBuilder,int,int,long)", "[void]startTree_(FlatBufferBuilder)", "[void]addContext(FlatBufferBuilder,int)", "[void]addRoot(FlatBufferBuilder,int)", "[void]addSize(FlatBufferBuilder,long)", "[int]endTree_(FlatBufferBuilder)", "[void]finishTree_Buffer(FlatBufferBuilder,int)", "[void]finishSizePrefixedTree_Buffer(FlatBufferBuilder,int)"], "method_uris": ["src/main/java/com/github/davidmoten/rtree/fbs/generated/Tree_.java.Tree_.[void]ValidateVersion()", "src/main/java/com/github/davidmoten/rtree/fbs/generated/Tree_.java.Tree_.[Tree_]getRootAsTree_(ByteBuffer)", "src/main/java/com/github/davidmoten/rtree/fbs/generated/Tree_.java.Tree_.[Tree_]getRootAsTree_(ByteBuffer,Tree_)", "src/main/java/com/github/davidmoten/rtree/fbs/generated/Tree_.java.Tree_.[void]__init(int,ByteBuffer)", "src/main/java/com/github/davidmoten/rtree/fbs/generated/Tree_.java.Tree_.[Tree_]__assign(int,ByteBuffer)", "src/main/java/com/github/davidmoten/rtree/fbs/generated/Tree_.java.Tree_.[com.github.davidmoten.rtree.fbs.generated.Context_]context()", "src/main/java/com/github/davidmoten/rtree/fbs/generated/Tree_.java.Tree_.[com.github.davidmoten.rtree.fbs.generated.Context_]context(com.github.davidmoten.rtree.fbs.generated.Context_)", "src/main/java/com/github/davidmoten/rtree/fbs/generated/Tree_.java.Tree_.[com.github.davidmoten.rtree.fbs.generated.Node_]root()", "src/main/java/com/github/davidmoten/rtree/fbs/generated/Tree_.java.Tree_.[com.github.davidmoten.rtree.fbs.generated.Node_]root(com.github.davidmoten.rtree.fbs.generated.Node_)", "src/main/java/com/github/davidmoten/rtree/fbs/generated/Tree_.java.Tree_.[long]size()", "src/main/java/com/github/davidmoten/rtree/fbs/generated/Tree_.java.Tree_.[int]createTree_(FlatBufferBuilder,int,int,long)", "src/main/java/com/github/davidmoten/rtree/fbs/generated/Tree_.java.Tree_.[void]startTree_(FlatBufferBuilder)", "src/main/java/com/github/davidmoten/rtree/fbs/generated/Tree_.java.Tree_.[void]addContext(FlatBufferBuilder,int)", "src/main/java/com/github/davidmoten/rtree/fbs/generated/Tree_.java.Tree_.[void]addRoot(FlatBufferBuilder,int)", "src/main/java/com/github/davidmoten/rtree/fbs/generated/Tree_.java.Tree_.[void]addSize(FlatBufferBuilder,long)", "src/main/java/com/github/davidmoten/rtree/fbs/generated/Tree_.java.Tree_.[int]endTree_(FlatBufferBuilder)", "src/main/java/com/github/davidmoten/rtree/fbs/generated/Tree_.java.Tree_.[void]finishTree_Buffer(FlatBufferBuilder,int)", "src/main/java/com/github/davidmoten/rtree/fbs/generated/Tree_.java.Tree_.[void]finishSizePrefixedTree_Buffer(FlatBufferBuilder,int)"], "overrides": null, "attributes": [{"original_string": "  public static final class Vector extends BaseVector {\n    public Vector __assign(int _vector, int _element_size, ByteBuffer _bb) { __reset(_vector, _element_size, _bb); return this; }\n\n    public Tree_ get(int j) { return get(new Tree_(), j); }\n    public Tree_ get(Tree_ obj, int j) {  return obj.__assign(__indirect(__element(j), bb), bb); }\n  }", "definition": "  public static final class Vector extends BaseVector", "class_docstring": "", "name": "Vector", "super_interfaces": [], "superclasses": "BaseVector", "attributes": {"modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    public Vector __assign(int _vector, int _element_size, ByteBuffer _bb) { __reset(_vector, _element_size, _bb); return this; }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Vector", "classes": []}, "name": "__assign", "params": [{"name": "_vector", "type": "int"}, {"name": "_element_size", "type": "int"}, {"name": "_bb", "type": "ByteBuffer"}], "body": "                                                                           { __reset(_vector, _element_size, _bb); return this; }", "signature": "public Vector __assign(int _vector, int _element_size, ByteBuffer _bb)"}, {"syntax_pass": true, "original_string": "    public Tree_ get(int j) { return get(new Tree_(), j); }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Tree_", "classes": []}, "name": "get", "params": [{"name": "j", "type": "int"}], "body": "                            { return get(new Tree_(), j); }", "signature": "public Tree_ get(int j)"}, {"syntax_pass": true, "original_string": "    public Tree_ get(Tree_ obj, int j) {  return obj.__assign(__indirect(__element(j), bb), bb); }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Tree_", "classes": []}, "name": "get", "params": [{"name": "obj", "type": "Tree_"}, {"name": "j", "type": "int"}], "body": "                                       {  return obj.__assign(__indirect(__element(j), bb), bb); }", "signature": "public Tree_ get(Tree_ obj, int j)"}]}], "class_docstring": "", "original_string": "@SuppressWarnings(\"unused\")\npublic final class Tree_ extends Table {\n  public static void ValidateVersion() { Constants.FLATBUFFERS_2_0_8(); }\n  public static Tree_ getRootAsTree_(ByteBuffer _bb) { return getRootAsTree_(_bb, new Tree_()); }\n  public static Tree_ getRootAsTree_(ByteBuffer _bb, Tree_ obj) { _bb.order(ByteOrder.LITTLE_ENDIAN); return (obj.__assign(_bb.getInt(_bb.position()) + _bb.position(), _bb)); }\n  public void __init(int _i, ByteBuffer _bb) { __reset(_i, _bb); }\n  public Tree_ __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }\n\n  public com.github.davidmoten.rtree.fbs.generated.Context_ context() { return context(new com.github.davidmoten.rtree.fbs.generated.Context_()); }\n  public com.github.davidmoten.rtree.fbs.generated.Context_ context(com.github.davidmoten.rtree.fbs.generated.Context_ obj) { int o = __offset(4); return o != 0 ? obj.__assign(__indirect(o + bb_pos), bb) : null; }\n  public com.github.davidmoten.rtree.fbs.generated.Node_ root() { return root(new com.github.davidmoten.rtree.fbs.generated.Node_()); }\n  public com.github.davidmoten.rtree.fbs.generated.Node_ root(com.github.davidmoten.rtree.fbs.generated.Node_ obj) { int o = __offset(6); return o != 0 ? obj.__assign(__indirect(o + bb_pos), bb) : null; }\n  public long size() { int o = __offset(8); return o != 0 ? (long)bb.getInt(o + bb_pos) & 0xFFFFFFFFL : 0L; }\n\n  public static int createTree_(FlatBufferBuilder builder,\n      int contextOffset,\n      int rootOffset,\n      long size) {\n    builder.startTable(3);\n    Tree_.addSize(builder, size);\n    Tree_.addRoot(builder, rootOffset);\n    Tree_.addContext(builder, contextOffset);\n    return Tree_.endTree_(builder);\n  }\n\n  public static void startTree_(FlatBufferBuilder builder) { builder.startTable(3); }\n  public static void addContext(FlatBufferBuilder builder, int contextOffset) { builder.addOffset(0, contextOffset, 0); }\n  public static void addRoot(FlatBufferBuilder builder, int rootOffset) { builder.addOffset(1, rootOffset, 0); }\n  public static void addSize(FlatBufferBuilder builder, long size) { builder.addInt(2, (int)size, (int)0L); }\n  public static int endTree_(FlatBufferBuilder builder) {\n    int o = builder.endTable();\n    return o;\n  }\n  public static void finishTree_Buffer(FlatBufferBuilder builder, int offset) { builder.finish(offset); }\n  public static void finishSizePrefixedTree_Buffer(FlatBufferBuilder builder, int offset) { builder.finishSizePrefixed(offset); }\n\n  public static final class Vector extends BaseVector {\n    public Vector __assign(int _vector, int _element_size, ByteBuffer _bb) { __reset(_vector, _element_size, _bb); return this; }\n\n    public Tree_ get(int j) { return get(new Tree_(), j); }\n    public Tree_ get(Tree_ obj, int j) {  return obj.__assign(__indirect(__element(j), bb), bb); }\n  }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/main/java/com/github/davidmoten/rtree/fbs/generated/Geometry_.java.Geometry_", "name": "Geometry_", "file_path": "src/main/java/com/github/davidmoten/rtree/fbs/generated/Geometry_.java", "superclasses": "Table", "methods": ["[void]ValidateVersion()", "[Geometry_]getRootAsGeometry_(ByteBuffer)", "[Geometry_]getRootAsGeometry_(ByteBuffer,Geometry_)", "[void]__init(int,ByteBuffer)", "[Geometry_]__assign(int,ByteBuffer)", "[byte]type()", "[com.github.davidmoten.rtree.fbs.generated.BoxFloat_]boxFloat()", "[com.github.davidmoten.rtree.fbs.generated.BoxFloat_]boxFloat(com.github.davidmoten.rtree.fbs.generated.BoxFloat_)", "[com.github.davidmoten.rtree.fbs.generated.PointFloat_]pointFloat()", "[com.github.davidmoten.rtree.fbs.generated.PointFloat_]pointFloat(com.github.davidmoten.rtree.fbs.generated.PointFloat_)", "[com.github.davidmoten.rtree.fbs.generated.CircleFloat_]circleFloat()", "[com.github.davidmoten.rtree.fbs.generated.CircleFloat_]circleFloat(com.github.davidmoten.rtree.fbs.generated.CircleFloat_)", "[com.github.davidmoten.rtree.fbs.generated.BoxFloat_]lineFloat()", "[com.github.davidmoten.rtree.fbs.generated.BoxFloat_]lineFloat(com.github.davidmoten.rtree.fbs.generated.BoxFloat_)", "[com.github.davidmoten.rtree.fbs.generated.BoxDouble_]boxDouble()", "[com.github.davidmoten.rtree.fbs.generated.BoxDouble_]boxDouble(com.github.davidmoten.rtree.fbs.generated.BoxDouble_)", "[com.github.davidmoten.rtree.fbs.generated.PointDouble_]pointDouble()", "[com.github.davidmoten.rtree.fbs.generated.PointDouble_]pointDouble(com.github.davidmoten.rtree.fbs.generated.PointDouble_)", "[com.github.davidmoten.rtree.fbs.generated.CircleDouble_]circleDouble()", "[com.github.davidmoten.rtree.fbs.generated.CircleDouble_]circleDouble(com.github.davidmoten.rtree.fbs.generated.CircleDouble_)", "[com.github.davidmoten.rtree.fbs.generated.BoxDouble_]lineDouble()", "[com.github.davidmoten.rtree.fbs.generated.BoxDouble_]lineDouble(com.github.davidmoten.rtree.fbs.generated.BoxDouble_)", "[void]startGeometry_(FlatBufferBuilder)", "[void]addType(FlatBufferBuilder,byte)", "[void]addBoxFloat(FlatBufferBuilder,int)", "[void]addPointFloat(FlatBufferBuilder,int)", "[void]addCircleFloat(FlatBufferBuilder,int)", "[void]addLineFloat(FlatBufferBuilder,int)", "[void]addBoxDouble(FlatBufferBuilder,int)", "[void]addPointDouble(FlatBufferBuilder,int)", "[void]addCircleDouble(FlatBufferBuilder,int)", "[void]addLineDouble(FlatBufferBuilder,int)", "[int]endGeometry_(FlatBufferBuilder)"], "method_uris": ["src/main/java/com/github/davidmoten/rtree/fbs/generated/Geometry_.java.Geometry_.[void]ValidateVersion()", "src/main/java/com/github/davidmoten/rtree/fbs/generated/Geometry_.java.Geometry_.[Geometry_]getRootAsGeometry_(ByteBuffer)", "src/main/java/com/github/davidmoten/rtree/fbs/generated/Geometry_.java.Geometry_.[Geometry_]getRootAsGeometry_(ByteBuffer,Geometry_)", "src/main/java/com/github/davidmoten/rtree/fbs/generated/Geometry_.java.Geometry_.[void]__init(int,ByteBuffer)", "src/main/java/com/github/davidmoten/rtree/fbs/generated/Geometry_.java.Geometry_.[Geometry_]__assign(int,ByteBuffer)", "src/main/java/com/github/davidmoten/rtree/fbs/generated/Geometry_.java.Geometry_.[byte]type()", "src/main/java/com/github/davidmoten/rtree/fbs/generated/Geometry_.java.Geometry_.[com.github.davidmoten.rtree.fbs.generated.BoxFloat_]boxFloat()", "src/main/java/com/github/davidmoten/rtree/fbs/generated/Geometry_.java.Geometry_.[com.github.davidmoten.rtree.fbs.generated.BoxFloat_]boxFloat(com.github.davidmoten.rtree.fbs.generated.BoxFloat_)", "src/main/java/com/github/davidmoten/rtree/fbs/generated/Geometry_.java.Geometry_.[com.github.davidmoten.rtree.fbs.generated.PointFloat_]pointFloat()", "src/main/java/com/github/davidmoten/rtree/fbs/generated/Geometry_.java.Geometry_.[com.github.davidmoten.rtree.fbs.generated.PointFloat_]pointFloat(com.github.davidmoten.rtree.fbs.generated.PointFloat_)", "src/main/java/com/github/davidmoten/rtree/fbs/generated/Geometry_.java.Geometry_.[com.github.davidmoten.rtree.fbs.generated.CircleFloat_]circleFloat()", "src/main/java/com/github/davidmoten/rtree/fbs/generated/Geometry_.java.Geometry_.[com.github.davidmoten.rtree.fbs.generated.CircleFloat_]circleFloat(com.github.davidmoten.rtree.fbs.generated.CircleFloat_)", "src/main/java/com/github/davidmoten/rtree/fbs/generated/Geometry_.java.Geometry_.[com.github.davidmoten.rtree.fbs.generated.BoxFloat_]lineFloat()", "src/main/java/com/github/davidmoten/rtree/fbs/generated/Geometry_.java.Geometry_.[com.github.davidmoten.rtree.fbs.generated.BoxFloat_]lineFloat(com.github.davidmoten.rtree.fbs.generated.BoxFloat_)", "src/main/java/com/github/davidmoten/rtree/fbs/generated/Geometry_.java.Geometry_.[com.github.davidmoten.rtree.fbs.generated.BoxDouble_]boxDouble()", "src/main/java/com/github/davidmoten/rtree/fbs/generated/Geometry_.java.Geometry_.[com.github.davidmoten.rtree.fbs.generated.BoxDouble_]boxDouble(com.github.davidmoten.rtree.fbs.generated.BoxDouble_)", "src/main/java/com/github/davidmoten/rtree/fbs/generated/Geometry_.java.Geometry_.[com.github.davidmoten.rtree.fbs.generated.PointDouble_]pointDouble()", "src/main/java/com/github/davidmoten/rtree/fbs/generated/Geometry_.java.Geometry_.[com.github.davidmoten.rtree.fbs.generated.PointDouble_]pointDouble(com.github.davidmoten.rtree.fbs.generated.PointDouble_)", "src/main/java/com/github/davidmoten/rtree/fbs/generated/Geometry_.java.Geometry_.[com.github.davidmoten.rtree.fbs.generated.CircleDouble_]circleDouble()", "src/main/java/com/github/davidmoten/rtree/fbs/generated/Geometry_.java.Geometry_.[com.github.davidmoten.rtree.fbs.generated.CircleDouble_]circleDouble(com.github.davidmoten.rtree.fbs.generated.CircleDouble_)", "src/main/java/com/github/davidmoten/rtree/fbs/generated/Geometry_.java.Geometry_.[com.github.davidmoten.rtree.fbs.generated.BoxDouble_]lineDouble()", "src/main/java/com/github/davidmoten/rtree/fbs/generated/Geometry_.java.Geometry_.[com.github.davidmoten.rtree.fbs.generated.BoxDouble_]lineDouble(com.github.davidmoten.rtree.fbs.generated.BoxDouble_)", "src/main/java/com/github/davidmoten/rtree/fbs/generated/Geometry_.java.Geometry_.[void]startGeometry_(FlatBufferBuilder)", "src/main/java/com/github/davidmoten/rtree/fbs/generated/Geometry_.java.Geometry_.[void]addType(FlatBufferBuilder,byte)", "src/main/java/com/github/davidmoten/rtree/fbs/generated/Geometry_.java.Geometry_.[void]addBoxFloat(FlatBufferBuilder,int)", "src/main/java/com/github/davidmoten/rtree/fbs/generated/Geometry_.java.Geometry_.[void]addPointFloat(FlatBufferBuilder,int)", "src/main/java/com/github/davidmoten/rtree/fbs/generated/Geometry_.java.Geometry_.[void]addCircleFloat(FlatBufferBuilder,int)", "src/main/java/com/github/davidmoten/rtree/fbs/generated/Geometry_.java.Geometry_.[void]addLineFloat(FlatBufferBuilder,int)", "src/main/java/com/github/davidmoten/rtree/fbs/generated/Geometry_.java.Geometry_.[void]addBoxDouble(FlatBufferBuilder,int)", "src/main/java/com/github/davidmoten/rtree/fbs/generated/Geometry_.java.Geometry_.[void]addPointDouble(FlatBufferBuilder,int)", "src/main/java/com/github/davidmoten/rtree/fbs/generated/Geometry_.java.Geometry_.[void]addCircleDouble(FlatBufferBuilder,int)", "src/main/java/com/github/davidmoten/rtree/fbs/generated/Geometry_.java.Geometry_.[void]addLineDouble(FlatBufferBuilder,int)", "src/main/java/com/github/davidmoten/rtree/fbs/generated/Geometry_.java.Geometry_.[int]endGeometry_(FlatBufferBuilder)"], "overrides": null, "attributes": [{"original_string": "  public static final class Vector extends BaseVector {\n    public Vector __assign(int _vector, int _element_size, ByteBuffer _bb) { __reset(_vector, _element_size, _bb); return this; }\n\n    public Geometry_ get(int j) { return get(new Geometry_(), j); }\n    public Geometry_ get(Geometry_ obj, int j) {  return obj.__assign(__indirect(__element(j), bb), bb); }\n  }", "definition": "  public static final class Vector extends BaseVector", "class_docstring": "", "name": "Vector", "super_interfaces": [], "superclasses": "BaseVector", "attributes": {"modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    public Vector __assign(int _vector, int _element_size, ByteBuffer _bb) { __reset(_vector, _element_size, _bb); return this; }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Vector", "classes": []}, "name": "__assign", "params": [{"name": "_vector", "type": "int"}, {"name": "_element_size", "type": "int"}, {"name": "_bb", "type": "ByteBuffer"}], "body": "                                                                           { __reset(_vector, _element_size, _bb); return this; }", "signature": "public Vector __assign(int _vector, int _element_size, ByteBuffer _bb)"}, {"syntax_pass": true, "original_string": "    public Geometry_ get(int j) { return get(new Geometry_(), j); }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Geometry_", "classes": []}, "name": "get", "params": [{"name": "j", "type": "int"}], "body": "                                { return get(new Geometry_(), j); }", "signature": "public Geometry_ get(int j)"}, {"syntax_pass": true, "original_string": "    public Geometry_ get(Geometry_ obj, int j) {  return obj.__assign(__indirect(__element(j), bb), bb); }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Geometry_", "classes": []}, "name": "get", "params": [{"name": "obj", "type": "Geometry_"}, {"name": "j", "type": "int"}], "body": "                                               {  return obj.__assign(__indirect(__element(j), bb), bb); }", "signature": "public Geometry_ get(Geometry_ obj, int j)"}]}], "class_docstring": "", "original_string": "@SuppressWarnings(\"unused\")\npublic final class Geometry_ extends Table {\n  public static void ValidateVersion() { Constants.FLATBUFFERS_2_0_8(); }\n  public static Geometry_ getRootAsGeometry_(ByteBuffer _bb) { return getRootAsGeometry_(_bb, new Geometry_()); }\n  public static Geometry_ getRootAsGeometry_(ByteBuffer _bb, Geometry_ obj) { _bb.order(ByteOrder.LITTLE_ENDIAN); return (obj.__assign(_bb.getInt(_bb.position()) + _bb.position(), _bb)); }\n  public void __init(int _i, ByteBuffer _bb) { __reset(_i, _bb); }\n  public Geometry_ __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }\n\n  public byte type() { int o = __offset(4); return o != 0 ? bb.get(o + bb_pos) : 0; }\n  public com.github.davidmoten.rtree.fbs.generated.BoxFloat_ boxFloat() { return boxFloat(new com.github.davidmoten.rtree.fbs.generated.BoxFloat_()); }\n  public com.github.davidmoten.rtree.fbs.generated.BoxFloat_ boxFloat(com.github.davidmoten.rtree.fbs.generated.BoxFloat_ obj) { int o = __offset(6); return o != 0 ? obj.__assign(o + bb_pos, bb) : null; }\n  public com.github.davidmoten.rtree.fbs.generated.PointFloat_ pointFloat() { return pointFloat(new com.github.davidmoten.rtree.fbs.generated.PointFloat_()); }\n  public com.github.davidmoten.rtree.fbs.generated.PointFloat_ pointFloat(com.github.davidmoten.rtree.fbs.generated.PointFloat_ obj) { int o = __offset(8); return o != 0 ? obj.__assign(o + bb_pos, bb) : null; }\n  public com.github.davidmoten.rtree.fbs.generated.CircleFloat_ circleFloat() { return circleFloat(new com.github.davidmoten.rtree.fbs.generated.CircleFloat_()); }\n  public com.github.davidmoten.rtree.fbs.generated.CircleFloat_ circleFloat(com.github.davidmoten.rtree.fbs.generated.CircleFloat_ obj) { int o = __offset(10); return o != 0 ? obj.__assign(o + bb_pos, bb) : null; }\n  public com.github.davidmoten.rtree.fbs.generated.BoxFloat_ lineFloat() { return lineFloat(new com.github.davidmoten.rtree.fbs.generated.BoxFloat_()); }\n  public com.github.davidmoten.rtree.fbs.generated.BoxFloat_ lineFloat(com.github.davidmoten.rtree.fbs.generated.BoxFloat_ obj) { int o = __offset(12); return o != 0 ? obj.__assign(o + bb_pos, bb) : null; }\n  public com.github.davidmoten.rtree.fbs.generated.BoxDouble_ boxDouble() { return boxDouble(new com.github.davidmoten.rtree.fbs.generated.BoxDouble_()); }\n  public com.github.davidmoten.rtree.fbs.generated.BoxDouble_ boxDouble(com.github.davidmoten.rtree.fbs.generated.BoxDouble_ obj) { int o = __offset(14); return o != 0 ? obj.__assign(o + bb_pos, bb) : null; }\n  public com.github.davidmoten.rtree.fbs.generated.PointDouble_ pointDouble() { return pointDouble(new com.github.davidmoten.rtree.fbs.generated.PointDouble_()); }\n  public com.github.davidmoten.rtree.fbs.generated.PointDouble_ pointDouble(com.github.davidmoten.rtree.fbs.generated.PointDouble_ obj) { int o = __offset(16); return o != 0 ? obj.__assign(o + bb_pos, bb) : null; }\n  public com.github.davidmoten.rtree.fbs.generated.CircleDouble_ circleDouble() { return circleDouble(new com.github.davidmoten.rtree.fbs.generated.CircleDouble_()); }\n  public com.github.davidmoten.rtree.fbs.generated.CircleDouble_ circleDouble(com.github.davidmoten.rtree.fbs.generated.CircleDouble_ obj) { int o = __offset(18); return o != 0 ? obj.__assign(o + bb_pos, bb) : null; }\n  public com.github.davidmoten.rtree.fbs.generated.BoxDouble_ lineDouble() { return lineDouble(new com.github.davidmoten.rtree.fbs.generated.BoxDouble_()); }\n  public com.github.davidmoten.rtree.fbs.generated.BoxDouble_ lineDouble(com.github.davidmoten.rtree.fbs.generated.BoxDouble_ obj) { int o = __offset(20); return o != 0 ? obj.__assign(o + bb_pos, bb) : null; }\n\n  public static void startGeometry_(FlatBufferBuilder builder) { builder.startTable(9); }\n  public static void addType(FlatBufferBuilder builder, byte type) { builder.addByte(0, type, 0); }\n  public static void addBoxFloat(FlatBufferBuilder builder, int boxFloatOffset) { builder.addStruct(1, boxFloatOffset, 0); }\n  public static void addPointFloat(FlatBufferBuilder builder, int pointFloatOffset) { builder.addStruct(2, pointFloatOffset, 0); }\n  public static void addCircleFloat(FlatBufferBuilder builder, int circleFloatOffset) { builder.addStruct(3, circleFloatOffset, 0); }\n  public static void addLineFloat(FlatBufferBuilder builder, int lineFloatOffset) { builder.addStruct(4, lineFloatOffset, 0); }\n  public static void addBoxDouble(FlatBufferBuilder builder, int boxDoubleOffset) { builder.addStruct(5, boxDoubleOffset, 0); }\n  public static void addPointDouble(FlatBufferBuilder builder, int pointDoubleOffset) { builder.addStruct(6, pointDoubleOffset, 0); }\n  public static void addCircleDouble(FlatBufferBuilder builder, int circleDoubleOffset) { builder.addStruct(7, circleDoubleOffset, 0); }\n  public static void addLineDouble(FlatBufferBuilder builder, int lineDoubleOffset) { builder.addStruct(8, lineDoubleOffset, 0); }\n  public static int endGeometry_(FlatBufferBuilder builder) {\n    int o = builder.endTable();\n    return o;\n  }\n\n  public static final class Vector extends BaseVector {\n    public Vector __assign(int _vector, int _element_size, ByteBuffer _bb) { __reset(_vector, _element_size, _bb); return this; }\n\n    public Geometry_ get(int j) { return get(new Geometry_(), j); }\n    public Geometry_ get(Geometry_ obj, int j) {  return obj.__assign(__indirect(__element(j), bb), bb); }\n  }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/main/java/com/github/davidmoten/rtree/fbs/generated/Bounds_.java.Bounds_", "name": "Bounds_", "file_path": "src/main/java/com/github/davidmoten/rtree/fbs/generated/Bounds_.java", "superclasses": "Table", "methods": ["[void]ValidateVersion()", "[Bounds_]getRootAsBounds_(ByteBuffer)", "[Bounds_]getRootAsBounds_(ByteBuffer,Bounds_)", "[void]__init(int,ByteBuffer)", "[Bounds_]__assign(int,ByteBuffer)", "[byte]type()", "[com.github.davidmoten.rtree.fbs.generated.BoxFloat_]boxFloat()", "[com.github.davidmoten.rtree.fbs.generated.BoxFloat_]boxFloat(com.github.davidmoten.rtree.fbs.generated.BoxFloat_)", "[com.github.davidmoten.rtree.fbs.generated.BoxDouble_]boxDouble()", "[com.github.davidmoten.rtree.fbs.generated.BoxDouble_]boxDouble(com.github.davidmoten.rtree.fbs.generated.BoxDouble_)", "[void]startBounds_(FlatBufferBuilder)", "[void]addType(FlatBufferBuilder,byte)", "[void]addBoxFloat(FlatBufferBuilder,int)", "[void]addBoxDouble(FlatBufferBuilder,int)", "[int]endBounds_(FlatBufferBuilder)"], "method_uris": ["src/main/java/com/github/davidmoten/rtree/fbs/generated/Bounds_.java.Bounds_.[void]ValidateVersion()", "src/main/java/com/github/davidmoten/rtree/fbs/generated/Bounds_.java.Bounds_.[Bounds_]getRootAsBounds_(ByteBuffer)", "src/main/java/com/github/davidmoten/rtree/fbs/generated/Bounds_.java.Bounds_.[Bounds_]getRootAsBounds_(ByteBuffer,Bounds_)", "src/main/java/com/github/davidmoten/rtree/fbs/generated/Bounds_.java.Bounds_.[void]__init(int,ByteBuffer)", "src/main/java/com/github/davidmoten/rtree/fbs/generated/Bounds_.java.Bounds_.[Bounds_]__assign(int,ByteBuffer)", "src/main/java/com/github/davidmoten/rtree/fbs/generated/Bounds_.java.Bounds_.[byte]type()", "src/main/java/com/github/davidmoten/rtree/fbs/generated/Bounds_.java.Bounds_.[com.github.davidmoten.rtree.fbs.generated.BoxFloat_]boxFloat()", "src/main/java/com/github/davidmoten/rtree/fbs/generated/Bounds_.java.Bounds_.[com.github.davidmoten.rtree.fbs.generated.BoxFloat_]boxFloat(com.github.davidmoten.rtree.fbs.generated.BoxFloat_)", "src/main/java/com/github/davidmoten/rtree/fbs/generated/Bounds_.java.Bounds_.[com.github.davidmoten.rtree.fbs.generated.BoxDouble_]boxDouble()", "src/main/java/com/github/davidmoten/rtree/fbs/generated/Bounds_.java.Bounds_.[com.github.davidmoten.rtree.fbs.generated.BoxDouble_]boxDouble(com.github.davidmoten.rtree.fbs.generated.BoxDouble_)", "src/main/java/com/github/davidmoten/rtree/fbs/generated/Bounds_.java.Bounds_.[void]startBounds_(FlatBufferBuilder)", "src/main/java/com/github/davidmoten/rtree/fbs/generated/Bounds_.java.Bounds_.[void]addType(FlatBufferBuilder,byte)", "src/main/java/com/github/davidmoten/rtree/fbs/generated/Bounds_.java.Bounds_.[void]addBoxFloat(FlatBufferBuilder,int)", "src/main/java/com/github/davidmoten/rtree/fbs/generated/Bounds_.java.Bounds_.[void]addBoxDouble(FlatBufferBuilder,int)", "src/main/java/com/github/davidmoten/rtree/fbs/generated/Bounds_.java.Bounds_.[int]endBounds_(FlatBufferBuilder)"], "overrides": null, "attributes": [{"original_string": "  public static final class Vector extends BaseVector {\n    public Vector __assign(int _vector, int _element_size, ByteBuffer _bb) { __reset(_vector, _element_size, _bb); return this; }\n\n    public Bounds_ get(int j) { return get(new Bounds_(), j); }\n    public Bounds_ get(Bounds_ obj, int j) {  return obj.__assign(__indirect(__element(j), bb), bb); }\n  }", "definition": "  public static final class Vector extends BaseVector", "class_docstring": "", "name": "Vector", "super_interfaces": [], "superclasses": "BaseVector", "attributes": {"modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    public Vector __assign(int _vector, int _element_size, ByteBuffer _bb) { __reset(_vector, _element_size, _bb); return this; }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Vector", "classes": []}, "name": "__assign", "params": [{"name": "_vector", "type": "int"}, {"name": "_element_size", "type": "int"}, {"name": "_bb", "type": "ByteBuffer"}], "body": "                                                                           { __reset(_vector, _element_size, _bb); return this; }", "signature": "public Vector __assign(int _vector, int _element_size, ByteBuffer _bb)"}, {"syntax_pass": true, "original_string": "    public Bounds_ get(int j) { return get(new Bounds_(), j); }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Bounds_", "classes": []}, "name": "get", "params": [{"name": "j", "type": "int"}], "body": "                              { return get(new Bounds_(), j); }", "signature": "public Bounds_ get(int j)"}, {"syntax_pass": true, "original_string": "    public Bounds_ get(Bounds_ obj, int j) {  return obj.__assign(__indirect(__element(j), bb), bb); }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Bounds_", "classes": []}, "name": "get", "params": [{"name": "obj", "type": "Bounds_"}, {"name": "j", "type": "int"}], "body": "                                           {  return obj.__assign(__indirect(__element(j), bb), bb); }", "signature": "public Bounds_ get(Bounds_ obj, int j)"}]}], "class_docstring": "", "original_string": "@SuppressWarnings(\"unused\")\npublic final class Bounds_ extends Table {\n  public static void ValidateVersion() { Constants.FLATBUFFERS_2_0_8(); }\n  public static Bounds_ getRootAsBounds_(ByteBuffer _bb) { return getRootAsBounds_(_bb, new Bounds_()); }\n  public static Bounds_ getRootAsBounds_(ByteBuffer _bb, Bounds_ obj) { _bb.order(ByteOrder.LITTLE_ENDIAN); return (obj.__assign(_bb.getInt(_bb.position()) + _bb.position(), _bb)); }\n  public void __init(int _i, ByteBuffer _bb) { __reset(_i, _bb); }\n  public Bounds_ __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }\n\n  public byte type() { int o = __offset(4); return o != 0 ? bb.get(o + bb_pos) : 0; }\n  public com.github.davidmoten.rtree.fbs.generated.BoxFloat_ boxFloat() { return boxFloat(new com.github.davidmoten.rtree.fbs.generated.BoxFloat_()); }\n  public com.github.davidmoten.rtree.fbs.generated.BoxFloat_ boxFloat(com.github.davidmoten.rtree.fbs.generated.BoxFloat_ obj) { int o = __offset(6); return o != 0 ? obj.__assign(o + bb_pos, bb) : null; }\n  public com.github.davidmoten.rtree.fbs.generated.BoxDouble_ boxDouble() { return boxDouble(new com.github.davidmoten.rtree.fbs.generated.BoxDouble_()); }\n  public com.github.davidmoten.rtree.fbs.generated.BoxDouble_ boxDouble(com.github.davidmoten.rtree.fbs.generated.BoxDouble_ obj) { int o = __offset(8); return o != 0 ? obj.__assign(o + bb_pos, bb) : null; }\n\n  public static void startBounds_(FlatBufferBuilder builder) { builder.startTable(3); }\n  public static void addType(FlatBufferBuilder builder, byte type) { builder.addByte(0, type, 0); }\n  public static void addBoxFloat(FlatBufferBuilder builder, int boxFloatOffset) { builder.addStruct(1, boxFloatOffset, 0); }\n  public static void addBoxDouble(FlatBufferBuilder builder, int boxDoubleOffset) { builder.addStruct(2, boxDoubleOffset, 0); }\n  public static int endBounds_(FlatBufferBuilder builder) {\n    int o = builder.endTable();\n    return o;\n  }\n\n  public static final class Vector extends BaseVector {\n    public Vector __assign(int _vector, int _element_size, ByteBuffer _bb) { __reset(_vector, _element_size, _bb); return this; }\n\n    public Bounds_ get(int j) { return get(new Bounds_(), j); }\n    public Bounds_ get(Bounds_ obj, int j) {  return obj.__assign(__indirect(__element(j), bb), bb); }\n  }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/main/java/com/github/davidmoten/rtree/fbs/generated/PointFloat_.java.PointFloat_", "name": "PointFloat_", "file_path": "src/main/java/com/github/davidmoten/rtree/fbs/generated/PointFloat_.java", "superclasses": "Struct", "methods": ["[void]__init(int,ByteBuffer)", "[PointFloat_]__assign(int,ByteBuffer)", "[float]x()", "[float]y()", "[int]createPointFloat_(FlatBufferBuilder,float,float)"], "method_uris": ["src/main/java/com/github/davidmoten/rtree/fbs/generated/PointFloat_.java.PointFloat_.[void]__init(int,ByteBuffer)", "src/main/java/com/github/davidmoten/rtree/fbs/generated/PointFloat_.java.PointFloat_.[PointFloat_]__assign(int,ByteBuffer)", "src/main/java/com/github/davidmoten/rtree/fbs/generated/PointFloat_.java.PointFloat_.[float]x()", "src/main/java/com/github/davidmoten/rtree/fbs/generated/PointFloat_.java.PointFloat_.[float]y()", "src/main/java/com/github/davidmoten/rtree/fbs/generated/PointFloat_.java.PointFloat_.[int]createPointFloat_(FlatBufferBuilder,float,float)"], "overrides": null, "attributes": [{"original_string": "  public static final class Vector extends BaseVector {\n    public Vector __assign(int _vector, int _element_size, ByteBuffer _bb) { __reset(_vector, _element_size, _bb); return this; }\n\n    public PointFloat_ get(int j) { return get(new PointFloat_(), j); }\n    public PointFloat_ get(PointFloat_ obj, int j) {  return obj.__assign(__element(j), bb); }\n  }", "definition": "  public static final class Vector extends BaseVector", "class_docstring": "", "name": "Vector", "super_interfaces": [], "superclasses": "BaseVector", "attributes": {"modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    public Vector __assign(int _vector, int _element_size, ByteBuffer _bb) { __reset(_vector, _element_size, _bb); return this; }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Vector", "classes": []}, "name": "__assign", "params": [{"name": "_vector", "type": "int"}, {"name": "_element_size", "type": "int"}, {"name": "_bb", "type": "ByteBuffer"}], "body": "                                                                           { __reset(_vector, _element_size, _bb); return this; }", "signature": "public Vector __assign(int _vector, int _element_size, ByteBuffer _bb)"}, {"syntax_pass": true, "original_string": "    public PointFloat_ get(int j) { return get(new PointFloat_(), j); }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "PointFloat_", "classes": []}, "name": "get", "params": [{"name": "j", "type": "int"}], "body": "                                  { return get(new PointFloat_(), j); }", "signature": "public PointFloat_ get(int j)"}, {"syntax_pass": true, "original_string": "    public PointFloat_ get(PointFloat_ obj, int j) {  return obj.__assign(__element(j), bb); }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "PointFloat_", "classes": []}, "name": "get", "params": [{"name": "obj", "type": "PointFloat_"}, {"name": "j", "type": "int"}], "body": "                                                   {  return obj.__assign(__element(j), bb); }", "signature": "public PointFloat_ get(PointFloat_ obj, int j)"}]}], "class_docstring": "", "original_string": "@SuppressWarnings(\"unused\")\npublic final class PointFloat_ extends Struct {\n  public void __init(int _i, ByteBuffer _bb) { __reset(_i, _bb); }\n  public PointFloat_ __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }\n\n  public float x() { return bb.getFloat(bb_pos + 0); }\n  public float y() { return bb.getFloat(bb_pos + 4); }\n\n  public static int createPointFloat_(FlatBufferBuilder builder, float x, float y) {\n    builder.prep(4, 8);\n    builder.putFloat(y);\n    builder.putFloat(x);\n    return builder.offset();\n  }\n\n  public static final class Vector extends BaseVector {\n    public Vector __assign(int _vector, int _element_size, ByteBuffer _bb) { __reset(_vector, _element_size, _bb); return this; }\n\n    public PointFloat_ get(int j) { return get(new PointFloat_(), j); }\n    public PointFloat_ get(PointFloat_ obj, int j) {  return obj.__assign(__element(j), bb); }\n  }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/main/java/com/github/davidmoten/rtree/fbs/generated/Entry_.java.Entry_", "name": "Entry_", "file_path": "src/main/java/com/github/davidmoten/rtree/fbs/generated/Entry_.java", "superclasses": "Table", "methods": ["[void]ValidateVersion()", "[Entry_]getRootAsEntry_(ByteBuffer)", "[Entry_]getRootAsEntry_(ByteBuffer,Entry_)", "[void]__init(int,ByteBuffer)", "[Entry_]__assign(int,ByteBuffer)", "[com.github.davidmoten.rtree.fbs.generated.Geometry_]geometry()", "[com.github.davidmoten.rtree.fbs.generated.Geometry_]geometry(com.github.davidmoten.rtree.fbs.generated.Geometry_)", "[byte]object(int)", "[int]objectLength()", "[ByteVector]objectVector()", "[ByteVector]objectVector(ByteVector)", "[ByteBuffer]objectAsByteBuffer()", "[ByteBuffer]objectInByteBuffer(ByteBuffer)", "[int]createEntry_(FlatBufferBuilder,int,int)", "[void]startEntry_(FlatBufferBuilder)", "[void]addGeometry(FlatBufferBuilder,int)", "[void]addObject(FlatBufferBuilder,int)", "[int]createObjectVector(FlatBufferBuilder,byte[])", "[int]createObjectVector(FlatBufferBuilder,ByteBuffer)", "[void]startObjectVector(FlatBufferBuilder,int)", "[int]endEntry_(FlatBufferBuilder)"], "method_uris": ["src/main/java/com/github/davidmoten/rtree/fbs/generated/Entry_.java.Entry_.[void]ValidateVersion()", "src/main/java/com/github/davidmoten/rtree/fbs/generated/Entry_.java.Entry_.[Entry_]getRootAsEntry_(ByteBuffer)", "src/main/java/com/github/davidmoten/rtree/fbs/generated/Entry_.java.Entry_.[Entry_]getRootAsEntry_(ByteBuffer,Entry_)", "src/main/java/com/github/davidmoten/rtree/fbs/generated/Entry_.java.Entry_.[void]__init(int,ByteBuffer)", "src/main/java/com/github/davidmoten/rtree/fbs/generated/Entry_.java.Entry_.[Entry_]__assign(int,ByteBuffer)", "src/main/java/com/github/davidmoten/rtree/fbs/generated/Entry_.java.Entry_.[com.github.davidmoten.rtree.fbs.generated.Geometry_]geometry()", "src/main/java/com/github/davidmoten/rtree/fbs/generated/Entry_.java.Entry_.[com.github.davidmoten.rtree.fbs.generated.Geometry_]geometry(com.github.davidmoten.rtree.fbs.generated.Geometry_)", "src/main/java/com/github/davidmoten/rtree/fbs/generated/Entry_.java.Entry_.[byte]object(int)", "src/main/java/com/github/davidmoten/rtree/fbs/generated/Entry_.java.Entry_.[int]objectLength()", "src/main/java/com/github/davidmoten/rtree/fbs/generated/Entry_.java.Entry_.[ByteVector]objectVector()", "src/main/java/com/github/davidmoten/rtree/fbs/generated/Entry_.java.Entry_.[ByteVector]objectVector(ByteVector)", "src/main/java/com/github/davidmoten/rtree/fbs/generated/Entry_.java.Entry_.[ByteBuffer]objectAsByteBuffer()", "src/main/java/com/github/davidmoten/rtree/fbs/generated/Entry_.java.Entry_.[ByteBuffer]objectInByteBuffer(ByteBuffer)", "src/main/java/com/github/davidmoten/rtree/fbs/generated/Entry_.java.Entry_.[int]createEntry_(FlatBufferBuilder,int,int)", "src/main/java/com/github/davidmoten/rtree/fbs/generated/Entry_.java.Entry_.[void]startEntry_(FlatBufferBuilder)", "src/main/java/com/github/davidmoten/rtree/fbs/generated/Entry_.java.Entry_.[void]addGeometry(FlatBufferBuilder,int)", "src/main/java/com/github/davidmoten/rtree/fbs/generated/Entry_.java.Entry_.[void]addObject(FlatBufferBuilder,int)", "src/main/java/com/github/davidmoten/rtree/fbs/generated/Entry_.java.Entry_.[int]createObjectVector(FlatBufferBuilder,byte[])", "src/main/java/com/github/davidmoten/rtree/fbs/generated/Entry_.java.Entry_.[int]createObjectVector(FlatBufferBuilder,ByteBuffer)", "src/main/java/com/github/davidmoten/rtree/fbs/generated/Entry_.java.Entry_.[void]startObjectVector(FlatBufferBuilder,int)", "src/main/java/com/github/davidmoten/rtree/fbs/generated/Entry_.java.Entry_.[int]endEntry_(FlatBufferBuilder)"], "overrides": null, "attributes": [{"original_string": "  public static final class Vector extends BaseVector {\n    public Vector __assign(int _vector, int _element_size, ByteBuffer _bb) { __reset(_vector, _element_size, _bb); return this; }\n\n    public Entry_ get(int j) { return get(new Entry_(), j); }\n    public Entry_ get(Entry_ obj, int j) {  return obj.__assign(__indirect(__element(j), bb), bb); }\n  }", "definition": "  public static final class Vector extends BaseVector", "class_docstring": "", "name": "Vector", "super_interfaces": [], "superclasses": "BaseVector", "attributes": {"modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    public Vector __assign(int _vector, int _element_size, ByteBuffer _bb) { __reset(_vector, _element_size, _bb); return this; }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Vector", "classes": []}, "name": "__assign", "params": [{"name": "_vector", "type": "int"}, {"name": "_element_size", "type": "int"}, {"name": "_bb", "type": "ByteBuffer"}], "body": "                                                                           { __reset(_vector, _element_size, _bb); return this; }", "signature": "public Vector __assign(int _vector, int _element_size, ByteBuffer _bb)"}, {"syntax_pass": true, "original_string": "    public Entry_ get(int j) { return get(new Entry_(), j); }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Entry_", "classes": []}, "name": "get", "params": [{"name": "j", "type": "int"}], "body": "                             { return get(new Entry_(), j); }", "signature": "public Entry_ get(int j)"}, {"syntax_pass": true, "original_string": "    public Entry_ get(Entry_ obj, int j) {  return obj.__assign(__indirect(__element(j), bb), bb); }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Entry_", "classes": []}, "name": "get", "params": [{"name": "obj", "type": "Entry_"}, {"name": "j", "type": "int"}], "body": "                                         {  return obj.__assign(__indirect(__element(j), bb), bb); }", "signature": "public Entry_ get(Entry_ obj, int j)"}]}], "class_docstring": "", "original_string": "@SuppressWarnings(\"unused\")\npublic final class Entry_ extends Table {\n  public static void ValidateVersion() { Constants.FLATBUFFERS_2_0_8(); }\n  public static Entry_ getRootAsEntry_(ByteBuffer _bb) { return getRootAsEntry_(_bb, new Entry_()); }\n  public static Entry_ getRootAsEntry_(ByteBuffer _bb, Entry_ obj) { _bb.order(ByteOrder.LITTLE_ENDIAN); return (obj.__assign(_bb.getInt(_bb.position()) + _bb.position(), _bb)); }\n  public void __init(int _i, ByteBuffer _bb) { __reset(_i, _bb); }\n  public Entry_ __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }\n\n  public com.github.davidmoten.rtree.fbs.generated.Geometry_ geometry() { return geometry(new com.github.davidmoten.rtree.fbs.generated.Geometry_()); }\n  public com.github.davidmoten.rtree.fbs.generated.Geometry_ geometry(com.github.davidmoten.rtree.fbs.generated.Geometry_ obj) { int o = __offset(4); return o != 0 ? obj.__assign(__indirect(o + bb_pos), bb) : null; }\n  public byte object(int j) { int o = __offset(6); return o != 0 ? bb.get(__vector(o) + j * 1) : 0; }\n  public int objectLength() { int o = __offset(6); return o != 0 ? __vector_len(o) : 0; }\n  public ByteVector objectVector() { return objectVector(new ByteVector()); }\n  public ByteVector objectVector(ByteVector obj) { int o = __offset(6); return o != 0 ? obj.__assign(__vector(o), bb) : null; }\n  public ByteBuffer objectAsByteBuffer() { return __vector_as_bytebuffer(6, 1); }\n  public ByteBuffer objectInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 6, 1); }\n\n  public static int createEntry_(FlatBufferBuilder builder,\n      int geometryOffset,\n      int objectOffset) {\n    builder.startTable(2);\n    Entry_.addObject(builder, objectOffset);\n    Entry_.addGeometry(builder, geometryOffset);\n    return Entry_.endEntry_(builder);\n  }\n\n  public static void startEntry_(FlatBufferBuilder builder) { builder.startTable(2); }\n  public static void addGeometry(FlatBufferBuilder builder, int geometryOffset) { builder.addOffset(0, geometryOffset, 0); }\n  public static void addObject(FlatBufferBuilder builder, int objectOffset) { builder.addOffset(1, objectOffset, 0); }\n  public static int createObjectVector(FlatBufferBuilder builder, byte[] data) { return builder.createByteVector(data); }\n  public static int createObjectVector(FlatBufferBuilder builder, ByteBuffer data) { return builder.createByteVector(data); }\n  public static void startObjectVector(FlatBufferBuilder builder, int numElems) { builder.startVector(1, numElems, 1); }\n  public static int endEntry_(FlatBufferBuilder builder) {\n    int o = builder.endTable();\n    return o;\n  }\n\n  public static final class Vector extends BaseVector {\n    public Vector __assign(int _vector, int _element_size, ByteBuffer _bb) { __reset(_vector, _element_size, _bb); return this; }\n\n    public Entry_ get(int j) { return get(new Entry_(), j); }\n    public Entry_ get(Entry_ obj, int j) {  return obj.__assign(__indirect(__element(j), bb), bb); }\n  }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/main/java/com/github/davidmoten/rtree/fbs/generated/LineFloat_.java.LineFloat_", "name": "LineFloat_", "file_path": "src/main/java/com/github/davidmoten/rtree/fbs/generated/LineFloat_.java", "superclasses": "Struct", "methods": ["[void]__init(int,ByteBuffer)", "[LineFloat_]__assign(int,ByteBuffer)", "[float]minX()", "[float]minY()", "[float]maxX()", "[float]maxY()", "[int]createLineFloat_(FlatBufferBuilder,float,float,float,float)"], "method_uris": ["src/main/java/com/github/davidmoten/rtree/fbs/generated/LineFloat_.java.LineFloat_.[void]__init(int,ByteBuffer)", "src/main/java/com/github/davidmoten/rtree/fbs/generated/LineFloat_.java.LineFloat_.[LineFloat_]__assign(int,ByteBuffer)", "src/main/java/com/github/davidmoten/rtree/fbs/generated/LineFloat_.java.LineFloat_.[float]minX()", "src/main/java/com/github/davidmoten/rtree/fbs/generated/LineFloat_.java.LineFloat_.[float]minY()", "src/main/java/com/github/davidmoten/rtree/fbs/generated/LineFloat_.java.LineFloat_.[float]maxX()", "src/main/java/com/github/davidmoten/rtree/fbs/generated/LineFloat_.java.LineFloat_.[float]maxY()", "src/main/java/com/github/davidmoten/rtree/fbs/generated/LineFloat_.java.LineFloat_.[int]createLineFloat_(FlatBufferBuilder,float,float,float,float)"], "overrides": null, "attributes": [{"original_string": "  public static final class Vector extends BaseVector {\n    public Vector __assign(int _vector, int _element_size, ByteBuffer _bb) { __reset(_vector, _element_size, _bb); return this; }\n\n    public LineFloat_ get(int j) { return get(new LineFloat_(), j); }\n    public LineFloat_ get(LineFloat_ obj, int j) {  return obj.__assign(__element(j), bb); }\n  }", "definition": "  public static final class Vector extends BaseVector", "class_docstring": "", "name": "Vector", "super_interfaces": [], "superclasses": "BaseVector", "attributes": {"modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    public Vector __assign(int _vector, int _element_size, ByteBuffer _bb) { __reset(_vector, _element_size, _bb); return this; }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Vector", "classes": []}, "name": "__assign", "params": [{"name": "_vector", "type": "int"}, {"name": "_element_size", "type": "int"}, {"name": "_bb", "type": "ByteBuffer"}], "body": "                                                                           { __reset(_vector, _element_size, _bb); return this; }", "signature": "public Vector __assign(int _vector, int _element_size, ByteBuffer _bb)"}, {"syntax_pass": true, "original_string": "    public LineFloat_ get(int j) { return get(new LineFloat_(), j); }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "LineFloat_", "classes": []}, "name": "get", "params": [{"name": "j", "type": "int"}], "body": "                                 { return get(new LineFloat_(), j); }", "signature": "public LineFloat_ get(int j)"}, {"syntax_pass": true, "original_string": "    public LineFloat_ get(LineFloat_ obj, int j) {  return obj.__assign(__element(j), bb); }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "LineFloat_", "classes": []}, "name": "get", "params": [{"name": "obj", "type": "LineFloat_"}, {"name": "j", "type": "int"}], "body": "                                                 {  return obj.__assign(__element(j), bb); }", "signature": "public LineFloat_ get(LineFloat_ obj, int j)"}]}], "class_docstring": "", "original_string": "@SuppressWarnings(\"unused\")\npublic final class LineFloat_ extends Struct {\n  public void __init(int _i, ByteBuffer _bb) { __reset(_i, _bb); }\n  public LineFloat_ __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }\n\n  public float minX() { return bb.getFloat(bb_pos + 0); }\n  public float minY() { return bb.getFloat(bb_pos + 4); }\n  public float maxX() { return bb.getFloat(bb_pos + 8); }\n  public float maxY() { return bb.getFloat(bb_pos + 12); }\n\n  public static int createLineFloat_(FlatBufferBuilder builder, float minX, float minY, float maxX, float maxY) {\n    builder.prep(4, 16);\n    builder.putFloat(maxY);\n    builder.putFloat(maxX);\n    builder.putFloat(minY);\n    builder.putFloat(minX);\n    return builder.offset();\n  }\n\n  public static final class Vector extends BaseVector {\n    public Vector __assign(int _vector, int _element_size, ByteBuffer _bb) { __reset(_vector, _element_size, _bb); return this; }\n\n    public LineFloat_ get(int j) { return get(new LineFloat_(), j); }\n    public LineFloat_ get(LineFloat_ obj, int j) {  return obj.__assign(__element(j), bb); }\n  }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/main/java/com/github/davidmoten/rtree/fbs/generated/CircleDouble_.java.CircleDouble_", "name": "CircleDouble_", "file_path": "src/main/java/com/github/davidmoten/rtree/fbs/generated/CircleDouble_.java", "superclasses": "Struct", "methods": ["[void]__init(int,ByteBuffer)", "[CircleDouble_]__assign(int,ByteBuffer)", "[double]x()", "[double]y()", "[double]radius()", "[int]createCircleDouble_(FlatBufferBuilder,double,double,double)"], "method_uris": ["src/main/java/com/github/davidmoten/rtree/fbs/generated/CircleDouble_.java.CircleDouble_.[void]__init(int,ByteBuffer)", "src/main/java/com/github/davidmoten/rtree/fbs/generated/CircleDouble_.java.CircleDouble_.[CircleDouble_]__assign(int,ByteBuffer)", "src/main/java/com/github/davidmoten/rtree/fbs/generated/CircleDouble_.java.CircleDouble_.[double]x()", "src/main/java/com/github/davidmoten/rtree/fbs/generated/CircleDouble_.java.CircleDouble_.[double]y()", "src/main/java/com/github/davidmoten/rtree/fbs/generated/CircleDouble_.java.CircleDouble_.[double]radius()", "src/main/java/com/github/davidmoten/rtree/fbs/generated/CircleDouble_.java.CircleDouble_.[int]createCircleDouble_(FlatBufferBuilder,double,double,double)"], "overrides": null, "attributes": [{"original_string": "  public static final class Vector extends BaseVector {\n    public Vector __assign(int _vector, int _element_size, ByteBuffer _bb) { __reset(_vector, _element_size, _bb); return this; }\n\n    public CircleDouble_ get(int j) { return get(new CircleDouble_(), j); }\n    public CircleDouble_ get(CircleDouble_ obj, int j) {  return obj.__assign(__element(j), bb); }\n  }", "definition": "  public static final class Vector extends BaseVector", "class_docstring": "", "name": "Vector", "super_interfaces": [], "superclasses": "BaseVector", "attributes": {"modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    public Vector __assign(int _vector, int _element_size, ByteBuffer _bb) { __reset(_vector, _element_size, _bb); return this; }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Vector", "classes": []}, "name": "__assign", "params": [{"name": "_vector", "type": "int"}, {"name": "_element_size", "type": "int"}, {"name": "_bb", "type": "ByteBuffer"}], "body": "                                                                           { __reset(_vector, _element_size, _bb); return this; }", "signature": "public Vector __assign(int _vector, int _element_size, ByteBuffer _bb)"}, {"syntax_pass": true, "original_string": "    public CircleDouble_ get(int j) { return get(new CircleDouble_(), j); }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "CircleDouble_", "classes": []}, "name": "get", "params": [{"name": "j", "type": "int"}], "body": "                                    { return get(new CircleDouble_(), j); }", "signature": "public CircleDouble_ get(int j)"}, {"syntax_pass": true, "original_string": "    public CircleDouble_ get(CircleDouble_ obj, int j) {  return obj.__assign(__element(j), bb); }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "CircleDouble_", "classes": []}, "name": "get", "params": [{"name": "obj", "type": "CircleDouble_"}, {"name": "j", "type": "int"}], "body": "                                                       {  return obj.__assign(__element(j), bb); }", "signature": "public CircleDouble_ get(CircleDouble_ obj, int j)"}]}], "class_docstring": "", "original_string": "@SuppressWarnings(\"unused\")\npublic final class CircleDouble_ extends Struct {\n  public void __init(int _i, ByteBuffer _bb) { __reset(_i, _bb); }\n  public CircleDouble_ __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }\n\n  public double x() { return bb.getDouble(bb_pos + 0); }\n  public double y() { return bb.getDouble(bb_pos + 8); }\n  public double radius() { return bb.getDouble(bb_pos + 16); }\n\n  public static int createCircleDouble_(FlatBufferBuilder builder, double x, double y, double radius) {\n    builder.prep(8, 24);\n    builder.putDouble(radius);\n    builder.putDouble(y);\n    builder.putDouble(x);\n    return builder.offset();\n  }\n\n  public static final class Vector extends BaseVector {\n    public Vector __assign(int _vector, int _element_size, ByteBuffer _bb) { __reset(_vector, _element_size, _bb); return this; }\n\n    public CircleDouble_ get(int j) { return get(new CircleDouble_(), j); }\n    public CircleDouble_ get(CircleDouble_ obj, int j) {  return obj.__assign(__element(j), bb); }\n  }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/main/java/com/github/davidmoten/rtree/fbs/generated/BoundsType_.java.BoundsType_", "name": "BoundsType_", "file_path": "src/main/java/com/github/davidmoten/rtree/fbs/generated/BoundsType_.java", "superclasses": "", "methods": ["[]BoundsType_()", "[String]name(int)"], "method_uris": ["src/main/java/com/github/davidmoten/rtree/fbs/generated/BoundsType_.java.BoundsType_.[]BoundsType_()", "src/main/java/com/github/davidmoten/rtree/fbs/generated/BoundsType_.java.BoundsType_.[String]name(int)"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public final class BoundsType_ {\n  private BoundsType_() { }\n  public static final byte BoundsFloat = 0;\n  public static final byte BoundsDouble = 1;\n\n  public static final String[] names = { \"BoundsFloat\", \"BoundsDouble\", };\n\n  public static String name(int e) { return names[e]; }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "public static final byte BoundsFloat = 0;", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "byte", "name": "BoundsFloat = 0", "syntax_pass": true}, {"attribute_expression": "public static final byte BoundsDouble = 1;", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "byte", "name": "BoundsDouble = 1", "syntax_pass": true}, {"attribute_expression": "public static final String[] names = { \"BoundsFloat\", \"BoundsDouble\", };", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "String[]", "name": "names = { \"BoundsFloat\", \"BoundsDouble\", }", "syntax_pass": true}]}, {"uris": "src/main/java/com/github/davidmoten/rtree/fbs/generated/Context_.java.Context_", "name": "Context_", "file_path": "src/main/java/com/github/davidmoten/rtree/fbs/generated/Context_.java", "superclasses": "Table", "methods": ["[void]ValidateVersion()", "[Context_]getRootAsContext_(ByteBuffer)", "[Context_]getRootAsContext_(ByteBuffer,Context_)", "[void]__init(int,ByteBuffer)", "[Context_]__assign(int,ByteBuffer)", "[com.github.davidmoten.rtree.fbs.generated.Bounds_]bounds()", "[com.github.davidmoten.rtree.fbs.generated.Bounds_]bounds(com.github.davidmoten.rtree.fbs.generated.Bounds_)", "[int]minChildren()", "[int]maxChildren()", "[int]createContext_(FlatBufferBuilder,int,int,int)", "[void]startContext_(FlatBufferBuilder)", "[void]addBounds(FlatBufferBuilder,int)", "[void]addMinChildren(FlatBufferBuilder,int)", "[void]addMaxChildren(FlatBufferBuilder,int)", "[int]endContext_(FlatBufferBuilder)"], "method_uris": ["src/main/java/com/github/davidmoten/rtree/fbs/generated/Context_.java.Context_.[void]ValidateVersion()", "src/main/java/com/github/davidmoten/rtree/fbs/generated/Context_.java.Context_.[Context_]getRootAsContext_(ByteBuffer)", "src/main/java/com/github/davidmoten/rtree/fbs/generated/Context_.java.Context_.[Context_]getRootAsContext_(ByteBuffer,Context_)", "src/main/java/com/github/davidmoten/rtree/fbs/generated/Context_.java.Context_.[void]__init(int,ByteBuffer)", "src/main/java/com/github/davidmoten/rtree/fbs/generated/Context_.java.Context_.[Context_]__assign(int,ByteBuffer)", "src/main/java/com/github/davidmoten/rtree/fbs/generated/Context_.java.Context_.[com.github.davidmoten.rtree.fbs.generated.Bounds_]bounds()", "src/main/java/com/github/davidmoten/rtree/fbs/generated/Context_.java.Context_.[com.github.davidmoten.rtree.fbs.generated.Bounds_]bounds(com.github.davidmoten.rtree.fbs.generated.Bounds_)", "src/main/java/com/github/davidmoten/rtree/fbs/generated/Context_.java.Context_.[int]minChildren()", "src/main/java/com/github/davidmoten/rtree/fbs/generated/Context_.java.Context_.[int]maxChildren()", "src/main/java/com/github/davidmoten/rtree/fbs/generated/Context_.java.Context_.[int]createContext_(FlatBufferBuilder,int,int,int)", "src/main/java/com/github/davidmoten/rtree/fbs/generated/Context_.java.Context_.[void]startContext_(FlatBufferBuilder)", "src/main/java/com/github/davidmoten/rtree/fbs/generated/Context_.java.Context_.[void]addBounds(FlatBufferBuilder,int)", "src/main/java/com/github/davidmoten/rtree/fbs/generated/Context_.java.Context_.[void]addMinChildren(FlatBufferBuilder,int)", "src/main/java/com/github/davidmoten/rtree/fbs/generated/Context_.java.Context_.[void]addMaxChildren(FlatBufferBuilder,int)", "src/main/java/com/github/davidmoten/rtree/fbs/generated/Context_.java.Context_.[int]endContext_(FlatBufferBuilder)"], "overrides": null, "attributes": [{"original_string": "  public static final class Vector extends BaseVector {\n    public Vector __assign(int _vector, int _element_size, ByteBuffer _bb) { __reset(_vector, _element_size, _bb); return this; }\n\n    public Context_ get(int j) { return get(new Context_(), j); }\n    public Context_ get(Context_ obj, int j) {  return obj.__assign(__indirect(__element(j), bb), bb); }\n  }", "definition": "  public static final class Vector extends BaseVector", "class_docstring": "", "name": "Vector", "super_interfaces": [], "superclasses": "BaseVector", "attributes": {"modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    public Vector __assign(int _vector, int _element_size, ByteBuffer _bb) { __reset(_vector, _element_size, _bb); return this; }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Vector", "classes": []}, "name": "__assign", "params": [{"name": "_vector", "type": "int"}, {"name": "_element_size", "type": "int"}, {"name": "_bb", "type": "ByteBuffer"}], "body": "                                                                           { __reset(_vector, _element_size, _bb); return this; }", "signature": "public Vector __assign(int _vector, int _element_size, ByteBuffer _bb)"}, {"syntax_pass": true, "original_string": "    public Context_ get(int j) { return get(new Context_(), j); }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Context_", "classes": []}, "name": "get", "params": [{"name": "j", "type": "int"}], "body": "                               { return get(new Context_(), j); }", "signature": "public Context_ get(int j)"}, {"syntax_pass": true, "original_string": "    public Context_ get(Context_ obj, int j) {  return obj.__assign(__indirect(__element(j), bb), bb); }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Context_", "classes": []}, "name": "get", "params": [{"name": "obj", "type": "Context_"}, {"name": "j", "type": "int"}], "body": "                                             {  return obj.__assign(__indirect(__element(j), bb), bb); }", "signature": "public Context_ get(Context_ obj, int j)"}]}], "class_docstring": "", "original_string": "@SuppressWarnings(\"unused\")\npublic final class Context_ extends Table {\n  public static void ValidateVersion() { Constants.FLATBUFFERS_2_0_8(); }\n  public static Context_ getRootAsContext_(ByteBuffer _bb) { return getRootAsContext_(_bb, new Context_()); }\n  public static Context_ getRootAsContext_(ByteBuffer _bb, Context_ obj) { _bb.order(ByteOrder.LITTLE_ENDIAN); return (obj.__assign(_bb.getInt(_bb.position()) + _bb.position(), _bb)); }\n  public void __init(int _i, ByteBuffer _bb) { __reset(_i, _bb); }\n  public Context_ __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }\n\n  public com.github.davidmoten.rtree.fbs.generated.Bounds_ bounds() { return bounds(new com.github.davidmoten.rtree.fbs.generated.Bounds_()); }\n  public com.github.davidmoten.rtree.fbs.generated.Bounds_ bounds(com.github.davidmoten.rtree.fbs.generated.Bounds_ obj) { int o = __offset(4); return o != 0 ? obj.__assign(__indirect(o + bb_pos), bb) : null; }\n  public int minChildren() { int o = __offset(6); return o != 0 ? bb.getInt(o + bb_pos) : 0; }\n  public int maxChildren() { int o = __offset(8); return o != 0 ? bb.getInt(o + bb_pos) : 0; }\n\n  public static int createContext_(FlatBufferBuilder builder,\n      int boundsOffset,\n      int minChildren,\n      int maxChildren) {\n    builder.startTable(3);\n    Context_.addMaxChildren(builder, maxChildren);\n    Context_.addMinChildren(builder, minChildren);\n    Context_.addBounds(builder, boundsOffset);\n    return Context_.endContext_(builder);\n  }\n\n  public static void startContext_(FlatBufferBuilder builder) { builder.startTable(3); }\n  public static void addBounds(FlatBufferBuilder builder, int boundsOffset) { builder.addOffset(0, boundsOffset, 0); }\n  public static void addMinChildren(FlatBufferBuilder builder, int minChildren) { builder.addInt(1, minChildren, 0); }\n  public static void addMaxChildren(FlatBufferBuilder builder, int maxChildren) { builder.addInt(2, maxChildren, 0); }\n  public static int endContext_(FlatBufferBuilder builder) {\n    int o = builder.endTable();\n    return o;\n  }\n\n  public static final class Vector extends BaseVector {\n    public Vector __assign(int _vector, int _element_size, ByteBuffer _bb) { __reset(_vector, _element_size, _bb); return this; }\n\n    public Context_ get(int j) { return get(new Context_(), j); }\n    public Context_ get(Context_ obj, int j) {  return obj.__assign(__indirect(__element(j), bb), bb); }\n  }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/main/java/com/github/davidmoten/rtree/fbs/generated/GeometryType_.java.GeometryType_", "name": "GeometryType_", "file_path": "src/main/java/com/github/davidmoten/rtree/fbs/generated/GeometryType_.java", "superclasses": "", "methods": ["[]GeometryType_()", "[String]name(int)"], "method_uris": ["src/main/java/com/github/davidmoten/rtree/fbs/generated/GeometryType_.java.GeometryType_.[]GeometryType_()", "src/main/java/com/github/davidmoten/rtree/fbs/generated/GeometryType_.java.GeometryType_.[String]name(int)"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public final class GeometryType_ {\n  private GeometryType_() { }\n  public static final byte PointFloat = 0;\n  public static final byte BoxFloat = 1;\n  public static final byte CircleFloat = 2;\n  public static final byte LineFloat = 3;\n  public static final byte PointDouble = 4;\n  public static final byte BoxDouble = 5;\n  public static final byte CircleDouble = 6;\n  public static final byte LineDouble = 7;\n\n  public static final String[] names = { \"PointFloat\", \"BoxFloat\", \"CircleFloat\", \"LineFloat\", \"PointDouble\", \"BoxDouble\", \"CircleDouble\", \"LineDouble\", };\n\n  public static String name(int e) { return names[e]; }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "public static final byte PointFloat = 0;", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "byte", "name": "PointFloat = 0", "syntax_pass": true}, {"attribute_expression": "public static final byte BoxFloat = 1;", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "byte", "name": "BoxFloat = 1", "syntax_pass": true}, {"attribute_expression": "public static final byte CircleFloat = 2;", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "byte", "name": "CircleFloat = 2", "syntax_pass": true}, {"attribute_expression": "public static final byte LineFloat = 3;", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "byte", "name": "LineFloat = 3", "syntax_pass": true}, {"attribute_expression": "public static final byte PointDouble = 4;", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "byte", "name": "PointDouble = 4", "syntax_pass": true}, {"attribute_expression": "public static final byte BoxDouble = 5;", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "byte", "name": "BoxDouble = 5", "syntax_pass": true}, {"attribute_expression": "public static final byte CircleDouble = 6;", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "byte", "name": "CircleDouble = 6", "syntax_pass": true}, {"attribute_expression": "public static final byte LineDouble = 7;", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "byte", "name": "LineDouble = 7", "syntax_pass": true}, {"attribute_expression": "public static final String[] names = { \"PointFloat\", \"BoxFloat\", \"CircleFloat\", \"LineFloat\", \"PointDouble\", \"BoxDouble\", \"CircleDouble\", \"LineDouble\", };", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "String[]", "name": "names = { \"PointFloat\", \"BoxFloat\", \"CircleFloat\", \"LineFloat\", \"PointDouble\", \"BoxDouble\", \"CircleDouble\", \"LineDouble\", }", "syntax_pass": true}]}, {"uris": "src/main/java/com/github/davidmoten/rtree/fbs/generated/CircleFloat_.java.CircleFloat_", "name": "CircleFloat_", "file_path": "src/main/java/com/github/davidmoten/rtree/fbs/generated/CircleFloat_.java", "superclasses": "Struct", "methods": ["[void]__init(int,ByteBuffer)", "[CircleFloat_]__assign(int,ByteBuffer)", "[float]x()", "[float]y()", "[float]radius()", "[int]createCircleFloat_(FlatBufferBuilder,float,float,float)"], "method_uris": ["src/main/java/com/github/davidmoten/rtree/fbs/generated/CircleFloat_.java.CircleFloat_.[void]__init(int,ByteBuffer)", "src/main/java/com/github/davidmoten/rtree/fbs/generated/CircleFloat_.java.CircleFloat_.[CircleFloat_]__assign(int,ByteBuffer)", "src/main/java/com/github/davidmoten/rtree/fbs/generated/CircleFloat_.java.CircleFloat_.[float]x()", "src/main/java/com/github/davidmoten/rtree/fbs/generated/CircleFloat_.java.CircleFloat_.[float]y()", "src/main/java/com/github/davidmoten/rtree/fbs/generated/CircleFloat_.java.CircleFloat_.[float]radius()", "src/main/java/com/github/davidmoten/rtree/fbs/generated/CircleFloat_.java.CircleFloat_.[int]createCircleFloat_(FlatBufferBuilder,float,float,float)"], "overrides": null, "attributes": [{"original_string": "  public static final class Vector extends BaseVector {\n    public Vector __assign(int _vector, int _element_size, ByteBuffer _bb) { __reset(_vector, _element_size, _bb); return this; }\n\n    public CircleFloat_ get(int j) { return get(new CircleFloat_(), j); }\n    public CircleFloat_ get(CircleFloat_ obj, int j) {  return obj.__assign(__element(j), bb); }\n  }", "definition": "  public static final class Vector extends BaseVector", "class_docstring": "", "name": "Vector", "super_interfaces": [], "superclasses": "BaseVector", "attributes": {"modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    public Vector __assign(int _vector, int _element_size, ByteBuffer _bb) { __reset(_vector, _element_size, _bb); return this; }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Vector", "classes": []}, "name": "__assign", "params": [{"name": "_vector", "type": "int"}, {"name": "_element_size", "type": "int"}, {"name": "_bb", "type": "ByteBuffer"}], "body": "                                                                           { __reset(_vector, _element_size, _bb); return this; }", "signature": "public Vector __assign(int _vector, int _element_size, ByteBuffer _bb)"}, {"syntax_pass": true, "original_string": "    public CircleFloat_ get(int j) { return get(new CircleFloat_(), j); }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "CircleFloat_", "classes": []}, "name": "get", "params": [{"name": "j", "type": "int"}], "body": "                                   { return get(new CircleFloat_(), j); }", "signature": "public CircleFloat_ get(int j)"}, {"syntax_pass": true, "original_string": "    public CircleFloat_ get(CircleFloat_ obj, int j) {  return obj.__assign(__element(j), bb); }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "CircleFloat_", "classes": []}, "name": "get", "params": [{"name": "obj", "type": "CircleFloat_"}, {"name": "j", "type": "int"}], "body": "                                                     {  return obj.__assign(__element(j), bb); }", "signature": "public CircleFloat_ get(CircleFloat_ obj, int j)"}]}], "class_docstring": "", "original_string": "@SuppressWarnings(\"unused\")\npublic final class CircleFloat_ extends Struct {\n  public void __init(int _i, ByteBuffer _bb) { __reset(_i, _bb); }\n  public CircleFloat_ __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }\n\n  public float x() { return bb.getFloat(bb_pos + 0); }\n  public float y() { return bb.getFloat(bb_pos + 4); }\n  public float radius() { return bb.getFloat(bb_pos + 8); }\n\n  public static int createCircleFloat_(FlatBufferBuilder builder, float x, float y, float radius) {\n    builder.prep(4, 12);\n    builder.putFloat(radius);\n    builder.putFloat(y);\n    builder.putFloat(x);\n    return builder.offset();\n  }\n\n  public static final class Vector extends BaseVector {\n    public Vector __assign(int _vector, int _element_size, ByteBuffer _bb) { __reset(_vector, _element_size, _bb); return this; }\n\n    public CircleFloat_ get(int j) { return get(new CircleFloat_(), j); }\n    public CircleFloat_ get(CircleFloat_ obj, int j) {  return obj.__assign(__element(j), bb); }\n  }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/main/java/com/github/davidmoten/rtree/fbs/generated/Node_.java.Node_", "name": "Node_", "file_path": "src/main/java/com/github/davidmoten/rtree/fbs/generated/Node_.java", "superclasses": "Table", "methods": ["[void]ValidateVersion()", "[Node_]getRootAsNode_(ByteBuffer)", "[Node_]getRootAsNode_(ByteBuffer,Node_)", "[void]__init(int,ByteBuffer)", "[Node_]__assign(int,ByteBuffer)", "[com.github.davidmoten.rtree.fbs.generated.Bounds_]mbb()", "[com.github.davidmoten.rtree.fbs.generated.Bounds_]mbb(com.github.davidmoten.rtree.fbs.generated.Bounds_)", "[com.github.davidmoten.rtree.fbs.generated.Node_]children(int)", "[com.github.davidmoten.rtree.fbs.generated.Node_]children(com.github.davidmoten.rtree.fbs.generated.Node_,int)", "[int]childrenLength()", "[com.github.davidmoten.rtree.fbs.generated.Node_.Vector]childrenVector()", "[com.github.davidmoten.rtree.fbs.generated.Node_.Vector]childrenVector(com.github.davidmoten.rtree.fbs.generated.Node_.Vector)", "[com.github.davidmoten.rtree.fbs.generated.Entry_]entries(int)", "[com.github.davidmoten.rtree.fbs.generated.Entry_]entries(com.github.davidmoten.rtree.fbs.generated.Entry_,int)", "[int]entriesLength()", "[com.github.davidmoten.rtree.fbs.generated.Entry_.Vector]entriesVector()", "[com.github.davidmoten.rtree.fbs.generated.Entry_.Vector]entriesVector(com.github.davidmoten.rtree.fbs.generated.Entry_.Vector)", "[int]createNode_(FlatBufferBuilder,int,int,int)", "[void]startNode_(FlatBufferBuilder)", "[void]addMbb(FlatBufferBuilder,int)", "[void]addChildren(FlatBufferBuilder,int)", "[int]createChildrenVector(FlatBufferBuilder,int[])", "[void]startChildrenVector(FlatBufferBuilder,int)", "[void]addEntries(FlatBufferBuilder,int)", "[int]createEntriesVector(FlatBufferBuilder,int[])", "[void]startEntriesVector(FlatBufferBuilder,int)", "[int]endNode_(FlatBufferBuilder)"], "method_uris": ["src/main/java/com/github/davidmoten/rtree/fbs/generated/Node_.java.Node_.[void]ValidateVersion()", "src/main/java/com/github/davidmoten/rtree/fbs/generated/Node_.java.Node_.[Node_]getRootAsNode_(ByteBuffer)", "src/main/java/com/github/davidmoten/rtree/fbs/generated/Node_.java.Node_.[Node_]getRootAsNode_(ByteBuffer,Node_)", "src/main/java/com/github/davidmoten/rtree/fbs/generated/Node_.java.Node_.[void]__init(int,ByteBuffer)", "src/main/java/com/github/davidmoten/rtree/fbs/generated/Node_.java.Node_.[Node_]__assign(int,ByteBuffer)", "src/main/java/com/github/davidmoten/rtree/fbs/generated/Node_.java.Node_.[com.github.davidmoten.rtree.fbs.generated.Bounds_]mbb()", "src/main/java/com/github/davidmoten/rtree/fbs/generated/Node_.java.Node_.[com.github.davidmoten.rtree.fbs.generated.Bounds_]mbb(com.github.davidmoten.rtree.fbs.generated.Bounds_)", "src/main/java/com/github/davidmoten/rtree/fbs/generated/Node_.java.Node_.[com.github.davidmoten.rtree.fbs.generated.Node_]children(int)", "src/main/java/com/github/davidmoten/rtree/fbs/generated/Node_.java.Node_.[com.github.davidmoten.rtree.fbs.generated.Node_]children(com.github.davidmoten.rtree.fbs.generated.Node_,int)", "src/main/java/com/github/davidmoten/rtree/fbs/generated/Node_.java.Node_.[int]childrenLength()", "src/main/java/com/github/davidmoten/rtree/fbs/generated/Node_.java.Node_.[com.github.davidmoten.rtree.fbs.generated.Node_.Vector]childrenVector()", "src/main/java/com/github/davidmoten/rtree/fbs/generated/Node_.java.Node_.[com.github.davidmoten.rtree.fbs.generated.Node_.Vector]childrenVector(com.github.davidmoten.rtree.fbs.generated.Node_.Vector)", "src/main/java/com/github/davidmoten/rtree/fbs/generated/Node_.java.Node_.[com.github.davidmoten.rtree.fbs.generated.Entry_]entries(int)", "src/main/java/com/github/davidmoten/rtree/fbs/generated/Node_.java.Node_.[com.github.davidmoten.rtree.fbs.generated.Entry_]entries(com.github.davidmoten.rtree.fbs.generated.Entry_,int)", "src/main/java/com/github/davidmoten/rtree/fbs/generated/Node_.java.Node_.[int]entriesLength()", "src/main/java/com/github/davidmoten/rtree/fbs/generated/Node_.java.Node_.[com.github.davidmoten.rtree.fbs.generated.Entry_.Vector]entriesVector()", "src/main/java/com/github/davidmoten/rtree/fbs/generated/Node_.java.Node_.[com.github.davidmoten.rtree.fbs.generated.Entry_.Vector]entriesVector(com.github.davidmoten.rtree.fbs.generated.Entry_.Vector)", "src/main/java/com/github/davidmoten/rtree/fbs/generated/Node_.java.Node_.[int]createNode_(FlatBufferBuilder,int,int,int)", "src/main/java/com/github/davidmoten/rtree/fbs/generated/Node_.java.Node_.[void]startNode_(FlatBufferBuilder)", "src/main/java/com/github/davidmoten/rtree/fbs/generated/Node_.java.Node_.[void]addMbb(FlatBufferBuilder,int)", "src/main/java/com/github/davidmoten/rtree/fbs/generated/Node_.java.Node_.[void]addChildren(FlatBufferBuilder,int)", "src/main/java/com/github/davidmoten/rtree/fbs/generated/Node_.java.Node_.[int]createChildrenVector(FlatBufferBuilder,int[])", "src/main/java/com/github/davidmoten/rtree/fbs/generated/Node_.java.Node_.[void]startChildrenVector(FlatBufferBuilder,int)", "src/main/java/com/github/davidmoten/rtree/fbs/generated/Node_.java.Node_.[void]addEntries(FlatBufferBuilder,int)", "src/main/java/com/github/davidmoten/rtree/fbs/generated/Node_.java.Node_.[int]createEntriesVector(FlatBufferBuilder,int[])", "src/main/java/com/github/davidmoten/rtree/fbs/generated/Node_.java.Node_.[void]startEntriesVector(FlatBufferBuilder,int)", "src/main/java/com/github/davidmoten/rtree/fbs/generated/Node_.java.Node_.[int]endNode_(FlatBufferBuilder)"], "overrides": null, "attributes": [{"original_string": "  public static final class Vector extends BaseVector {\n    public Vector __assign(int _vector, int _element_size, ByteBuffer _bb) { __reset(_vector, _element_size, _bb); return this; }\n\n    public Node_ get(int j) { return get(new Node_(), j); }\n    public Node_ get(Node_ obj, int j) {  return obj.__assign(__indirect(__element(j), bb), bb); }\n  }", "definition": "  public static final class Vector extends BaseVector", "class_docstring": "", "name": "Vector", "super_interfaces": [], "superclasses": "BaseVector", "attributes": {"modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    public Vector __assign(int _vector, int _element_size, ByteBuffer _bb) { __reset(_vector, _element_size, _bb); return this; }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Vector", "classes": []}, "name": "__assign", "params": [{"name": "_vector", "type": "int"}, {"name": "_element_size", "type": "int"}, {"name": "_bb", "type": "ByteBuffer"}], "body": "                                                                           { __reset(_vector, _element_size, _bb); return this; }", "signature": "public Vector __assign(int _vector, int _element_size, ByteBuffer _bb)"}, {"syntax_pass": true, "original_string": "    public Node_ get(int j) { return get(new Node_(), j); }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Node_", "classes": []}, "name": "get", "params": [{"name": "j", "type": "int"}], "body": "                            { return get(new Node_(), j); }", "signature": "public Node_ get(int j)"}, {"syntax_pass": true, "original_string": "    public Node_ get(Node_ obj, int j) {  return obj.__assign(__indirect(__element(j), bb), bb); }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Node_", "classes": []}, "name": "get", "params": [{"name": "obj", "type": "Node_"}, {"name": "j", "type": "int"}], "body": "                                       {  return obj.__assign(__indirect(__element(j), bb), bb); }", "signature": "public Node_ get(Node_ obj, int j)"}]}], "class_docstring": "", "original_string": "@SuppressWarnings(\"unused\")\npublic final class Node_ extends Table {\n  public static void ValidateVersion() { Constants.FLATBUFFERS_2_0_8(); }\n  public static Node_ getRootAsNode_(ByteBuffer _bb) { return getRootAsNode_(_bb, new Node_()); }\n  public static Node_ getRootAsNode_(ByteBuffer _bb, Node_ obj) { _bb.order(ByteOrder.LITTLE_ENDIAN); return (obj.__assign(_bb.getInt(_bb.position()) + _bb.position(), _bb)); }\n  public void __init(int _i, ByteBuffer _bb) { __reset(_i, _bb); }\n  public Node_ __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }\n\n  public com.github.davidmoten.rtree.fbs.generated.Bounds_ mbb() { return mbb(new com.github.davidmoten.rtree.fbs.generated.Bounds_()); }\n  public com.github.davidmoten.rtree.fbs.generated.Bounds_ mbb(com.github.davidmoten.rtree.fbs.generated.Bounds_ obj) { int o = __offset(4); return o != 0 ? obj.__assign(__indirect(o + bb_pos), bb) : null; }\n  public com.github.davidmoten.rtree.fbs.generated.Node_ children(int j) { return children(new com.github.davidmoten.rtree.fbs.generated.Node_(), j); }\n  public com.github.davidmoten.rtree.fbs.generated.Node_ children(com.github.davidmoten.rtree.fbs.generated.Node_ obj, int j) { int o = __offset(6); return o != 0 ? obj.__assign(__indirect(__vector(o) + j * 4), bb) : null; }\n  public int childrenLength() { int o = __offset(6); return o != 0 ? __vector_len(o) : 0; }\n  public com.github.davidmoten.rtree.fbs.generated.Node_.Vector childrenVector() { return childrenVector(new com.github.davidmoten.rtree.fbs.generated.Node_.Vector()); }\n  public com.github.davidmoten.rtree.fbs.generated.Node_.Vector childrenVector(com.github.davidmoten.rtree.fbs.generated.Node_.Vector obj) { int o = __offset(6); return o != 0 ? obj.__assign(__vector(o), 4, bb) : null; }\n  public com.github.davidmoten.rtree.fbs.generated.Entry_ entries(int j) { return entries(new com.github.davidmoten.rtree.fbs.generated.Entry_(), j); }\n  public com.github.davidmoten.rtree.fbs.generated.Entry_ entries(com.github.davidmoten.rtree.fbs.generated.Entry_ obj, int j) { int o = __offset(8); return o != 0 ? obj.__assign(__indirect(__vector(o) + j * 4), bb) : null; }\n  public int entriesLength() { int o = __offset(8); return o != 0 ? __vector_len(o) : 0; }\n  public com.github.davidmoten.rtree.fbs.generated.Entry_.Vector entriesVector() { return entriesVector(new com.github.davidmoten.rtree.fbs.generated.Entry_.Vector()); }\n  public com.github.davidmoten.rtree.fbs.generated.Entry_.Vector entriesVector(com.github.davidmoten.rtree.fbs.generated.Entry_.Vector obj) { int o = __offset(8); return o != 0 ? obj.__assign(__vector(o), 4, bb) : null; }\n\n  public static int createNode_(FlatBufferBuilder builder,\n      int mbbOffset,\n      int childrenOffset,\n      int entriesOffset) {\n    builder.startTable(3);\n    Node_.addEntries(builder, entriesOffset);\n    Node_.addChildren(builder, childrenOffset);\n    Node_.addMbb(builder, mbbOffset);\n    return Node_.endNode_(builder);\n  }\n\n  public static void startNode_(FlatBufferBuilder builder) { builder.startTable(3); }\n  public static void addMbb(FlatBufferBuilder builder, int mbbOffset) { builder.addOffset(0, mbbOffset, 0); }\n  public static void addChildren(FlatBufferBuilder builder, int childrenOffset) { builder.addOffset(1, childrenOffset, 0); }\n  public static int createChildrenVector(FlatBufferBuilder builder, int[] data) { builder.startVector(4, data.length, 4); for (int i = data.length - 1; i >= 0; i--) builder.addOffset(data[i]); return builder.endVector(); }\n  public static void startChildrenVector(FlatBufferBuilder builder, int numElems) { builder.startVector(4, numElems, 4); }\n  public static void addEntries(FlatBufferBuilder builder, int entriesOffset) { builder.addOffset(2, entriesOffset, 0); }\n  public static int createEntriesVector(FlatBufferBuilder builder, int[] data) { builder.startVector(4, data.length, 4); for (int i = data.length - 1; i >= 0; i--) builder.addOffset(data[i]); return builder.endVector(); }\n  public static void startEntriesVector(FlatBufferBuilder builder, int numElems) { builder.startVector(4, numElems, 4); }\n  public static int endNode_(FlatBufferBuilder builder) {\n    int o = builder.endTable();\n    return o;\n  }\n\n  public static final class Vector extends BaseVector {\n    public Vector __assign(int _vector, int _element_size, ByteBuffer _bb) { __reset(_vector, _element_size, _bb); return this; }\n\n    public Node_ get(int j) { return get(new Node_(), j); }\n    public Node_ get(Node_ obj, int j) {  return obj.__assign(__indirect(__element(j), bb), bb); }\n  }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/main/java/com/github/davidmoten/rtree/fbs/generated/LineDouble_.java.LineDouble_", "name": "LineDouble_", "file_path": "src/main/java/com/github/davidmoten/rtree/fbs/generated/LineDouble_.java", "superclasses": "Struct", "methods": ["[void]__init(int,ByteBuffer)", "[LineDouble_]__assign(int,ByteBuffer)", "[double]minX()", "[double]minY()", "[double]maxX()", "[double]maxY()", "[int]createLineDouble_(FlatBufferBuilder,double,double,double,double)"], "method_uris": ["src/main/java/com/github/davidmoten/rtree/fbs/generated/LineDouble_.java.LineDouble_.[void]__init(int,ByteBuffer)", "src/main/java/com/github/davidmoten/rtree/fbs/generated/LineDouble_.java.LineDouble_.[LineDouble_]__assign(int,ByteBuffer)", "src/main/java/com/github/davidmoten/rtree/fbs/generated/LineDouble_.java.LineDouble_.[double]minX()", "src/main/java/com/github/davidmoten/rtree/fbs/generated/LineDouble_.java.LineDouble_.[double]minY()", "src/main/java/com/github/davidmoten/rtree/fbs/generated/LineDouble_.java.LineDouble_.[double]maxX()", "src/main/java/com/github/davidmoten/rtree/fbs/generated/LineDouble_.java.LineDouble_.[double]maxY()", "src/main/java/com/github/davidmoten/rtree/fbs/generated/LineDouble_.java.LineDouble_.[int]createLineDouble_(FlatBufferBuilder,double,double,double,double)"], "overrides": null, "attributes": [{"original_string": "  public static final class Vector extends BaseVector {\n    public Vector __assign(int _vector, int _element_size, ByteBuffer _bb) { __reset(_vector, _element_size, _bb); return this; }\n\n    public LineDouble_ get(int j) { return get(new LineDouble_(), j); }\n    public LineDouble_ get(LineDouble_ obj, int j) {  return obj.__assign(__element(j), bb); }\n  }", "definition": "  public static final class Vector extends BaseVector", "class_docstring": "", "name": "Vector", "super_interfaces": [], "superclasses": "BaseVector", "attributes": {"modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    public Vector __assign(int _vector, int _element_size, ByteBuffer _bb) { __reset(_vector, _element_size, _bb); return this; }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Vector", "classes": []}, "name": "__assign", "params": [{"name": "_vector", "type": "int"}, {"name": "_element_size", "type": "int"}, {"name": "_bb", "type": "ByteBuffer"}], "body": "                                                                           { __reset(_vector, _element_size, _bb); return this; }", "signature": "public Vector __assign(int _vector, int _element_size, ByteBuffer _bb)"}, {"syntax_pass": true, "original_string": "    public LineDouble_ get(int j) { return get(new LineDouble_(), j); }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "LineDouble_", "classes": []}, "name": "get", "params": [{"name": "j", "type": "int"}], "body": "                                  { return get(new LineDouble_(), j); }", "signature": "public LineDouble_ get(int j)"}, {"syntax_pass": true, "original_string": "    public LineDouble_ get(LineDouble_ obj, int j) {  return obj.__assign(__element(j), bb); }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "LineDouble_", "classes": []}, "name": "get", "params": [{"name": "obj", "type": "LineDouble_"}, {"name": "j", "type": "int"}], "body": "                                                   {  return obj.__assign(__element(j), bb); }", "signature": "public LineDouble_ get(LineDouble_ obj, int j)"}]}], "class_docstring": "", "original_string": "@SuppressWarnings(\"unused\")\npublic final class LineDouble_ extends Struct {\n  public void __init(int _i, ByteBuffer _bb) { __reset(_i, _bb); }\n  public LineDouble_ __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }\n\n  public double minX() { return bb.getDouble(bb_pos + 0); }\n  public double minY() { return bb.getDouble(bb_pos + 8); }\n  public double maxX() { return bb.getDouble(bb_pos + 16); }\n  public double maxY() { return bb.getDouble(bb_pos + 24); }\n\n  public static int createLineDouble_(FlatBufferBuilder builder, double minX, double minY, double maxX, double maxY) {\n    builder.prep(8, 32);\n    builder.putDouble(maxY);\n    builder.putDouble(maxX);\n    builder.putDouble(minY);\n    builder.putDouble(minX);\n    return builder.offset();\n  }\n\n  public static final class Vector extends BaseVector {\n    public Vector __assign(int _vector, int _element_size, ByteBuffer _bb) { __reset(_vector, _element_size, _bb); return this; }\n\n    public LineDouble_ get(int j) { return get(new LineDouble_(), j); }\n    public LineDouble_ get(LineDouble_ obj, int j) {  return obj.__assign(__element(j), bb); }\n  }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/main/java/com/github/davidmoten/rtree/fbs/generated/BoxDouble_.java.BoxDouble_", "name": "BoxDouble_", "file_path": "src/main/java/com/github/davidmoten/rtree/fbs/generated/BoxDouble_.java", "superclasses": "Struct", "methods": ["[void]__init(int,ByteBuffer)", "[BoxDouble_]__assign(int,ByteBuffer)", "[double]minX()", "[double]minY()", "[double]maxX()", "[double]maxY()", "[int]createBoxDouble_(FlatBufferBuilder,double,double,double,double)"], "method_uris": ["src/main/java/com/github/davidmoten/rtree/fbs/generated/BoxDouble_.java.BoxDouble_.[void]__init(int,ByteBuffer)", "src/main/java/com/github/davidmoten/rtree/fbs/generated/BoxDouble_.java.BoxDouble_.[BoxDouble_]__assign(int,ByteBuffer)", "src/main/java/com/github/davidmoten/rtree/fbs/generated/BoxDouble_.java.BoxDouble_.[double]minX()", "src/main/java/com/github/davidmoten/rtree/fbs/generated/BoxDouble_.java.BoxDouble_.[double]minY()", "src/main/java/com/github/davidmoten/rtree/fbs/generated/BoxDouble_.java.BoxDouble_.[double]maxX()", "src/main/java/com/github/davidmoten/rtree/fbs/generated/BoxDouble_.java.BoxDouble_.[double]maxY()", "src/main/java/com/github/davidmoten/rtree/fbs/generated/BoxDouble_.java.BoxDouble_.[int]createBoxDouble_(FlatBufferBuilder,double,double,double,double)"], "overrides": null, "attributes": [{"original_string": "  public static final class Vector extends BaseVector {\n    public Vector __assign(int _vector, int _element_size, ByteBuffer _bb) { __reset(_vector, _element_size, _bb); return this; }\n\n    public BoxDouble_ get(int j) { return get(new BoxDouble_(), j); }\n    public BoxDouble_ get(BoxDouble_ obj, int j) {  return obj.__assign(__element(j), bb); }\n  }", "definition": "  public static final class Vector extends BaseVector", "class_docstring": "", "name": "Vector", "super_interfaces": [], "superclasses": "BaseVector", "attributes": {"modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    public Vector __assign(int _vector, int _element_size, ByteBuffer _bb) { __reset(_vector, _element_size, _bb); return this; }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Vector", "classes": []}, "name": "__assign", "params": [{"name": "_vector", "type": "int"}, {"name": "_element_size", "type": "int"}, {"name": "_bb", "type": "ByteBuffer"}], "body": "                                                                           { __reset(_vector, _element_size, _bb); return this; }", "signature": "public Vector __assign(int _vector, int _element_size, ByteBuffer _bb)"}, {"syntax_pass": true, "original_string": "    public BoxDouble_ get(int j) { return get(new BoxDouble_(), j); }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "BoxDouble_", "classes": []}, "name": "get", "params": [{"name": "j", "type": "int"}], "body": "                                 { return get(new BoxDouble_(), j); }", "signature": "public BoxDouble_ get(int j)"}, {"syntax_pass": true, "original_string": "    public BoxDouble_ get(BoxDouble_ obj, int j) {  return obj.__assign(__element(j), bb); }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "BoxDouble_", "classes": []}, "name": "get", "params": [{"name": "obj", "type": "BoxDouble_"}, {"name": "j", "type": "int"}], "body": "                                                 {  return obj.__assign(__element(j), bb); }", "signature": "public BoxDouble_ get(BoxDouble_ obj, int j)"}]}], "class_docstring": "", "original_string": "@SuppressWarnings(\"unused\")\npublic final class BoxDouble_ extends Struct {\n  public void __init(int _i, ByteBuffer _bb) { __reset(_i, _bb); }\n  public BoxDouble_ __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }\n\n  public double minX() { return bb.getDouble(bb_pos + 0); }\n  public double minY() { return bb.getDouble(bb_pos + 8); }\n  public double maxX() { return bb.getDouble(bb_pos + 16); }\n  public double maxY() { return bb.getDouble(bb_pos + 24); }\n\n  public static int createBoxDouble_(FlatBufferBuilder builder, double minX, double minY, double maxX, double maxY) {\n    builder.prep(8, 32);\n    builder.putDouble(maxY);\n    builder.putDouble(maxX);\n    builder.putDouble(minY);\n    builder.putDouble(minX);\n    return builder.offset();\n  }\n\n  public static final class Vector extends BaseVector {\n    public Vector __assign(int _vector, int _element_size, ByteBuffer _bb) { __reset(_vector, _element_size, _bb); return this; }\n\n    public BoxDouble_ get(int j) { return get(new BoxDouble_(), j); }\n    public BoxDouble_ get(BoxDouble_ obj, int j) {  return obj.__assign(__element(j), bb); }\n  }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/main/java/com/github/davidmoten/rtree/kryo/SerializerKryo.java.SerializerKryo", "name": "SerializerKryo", "file_path": "src/main/java/com/github/davidmoten/rtree/kryo/SerializerKryo.java", "superclasses": "", "methods": ["[]SerializerKryo(Func1<? super T, byte[]>,Func1<byte[], ? extends T>,Func0<Kryo>)", "[void]write(RTree<T, S>,OutputStream)", "[void]write(Kryo,Output,RTree<T, S>)", "[void]writeNode(Node<T, S>,Output)", "[void]writeValue(Output,T)", "[void]writeRectangle(Output,S)", "[void]writeGeometry(Output,S)", "[void]writeBounds(Output,Rectangle)", "[void]writeContext(Context<T, S>,Output)", "[RTree<T, S>]read(InputStream,long,InternalStructure)", "[RTree<T, S>]read(Input)", "[Node<T, S>]readNode(Input)", "[Context<T, S>]readContext(Input)", "[Serializer<T, S>]create(Func1<? super T, byte[]>,Func1<byte[], ? extends T>,Func0<Kryo>)"], "method_uris": ["src/main/java/com/github/davidmoten/rtree/kryo/SerializerKryo.java.SerializerKryo.[]SerializerKryo(Func1<? super T, byte[]>,Func1<byte[], ? extends T>,Func0<Kryo>)", "src/main/java/com/github/davidmoten/rtree/kryo/SerializerKryo.java.SerializerKryo.[void]write(RTree<T, S>,OutputStream)", "src/main/java/com/github/davidmoten/rtree/kryo/SerializerKryo.java.SerializerKryo.[void]write(Kryo,Output,RTree<T, S>)", "src/main/java/com/github/davidmoten/rtree/kryo/SerializerKryo.java.SerializerKryo.[void]writeNode(Node<T, S>,Output)", "src/main/java/com/github/davidmoten/rtree/kryo/SerializerKryo.java.SerializerKryo.[void]writeValue(Output,T)", "src/main/java/com/github/davidmoten/rtree/kryo/SerializerKryo.java.SerializerKryo.[void]writeRectangle(Output,S)", "src/main/java/com/github/davidmoten/rtree/kryo/SerializerKryo.java.SerializerKryo.[void]writeGeometry(Output,S)", "src/main/java/com/github/davidmoten/rtree/kryo/SerializerKryo.java.SerializerKryo.[void]writeBounds(Output,Rectangle)", "src/main/java/com/github/davidmoten/rtree/kryo/SerializerKryo.java.SerializerKryo.[void]writeContext(Context<T, S>,Output)", "src/main/java/com/github/davidmoten/rtree/kryo/SerializerKryo.java.SerializerKryo.[RTree<T, S>]read(InputStream,long,InternalStructure)", "src/main/java/com/github/davidmoten/rtree/kryo/SerializerKryo.java.SerializerKryo.[RTree<T, S>]read(Input)", "src/main/java/com/github/davidmoten/rtree/kryo/SerializerKryo.java.SerializerKryo.[Node<T, S>]readNode(Input)", "src/main/java/com/github/davidmoten/rtree/kryo/SerializerKryo.java.SerializerKryo.[Context<T, S>]readContext(Input)", "src/main/java/com/github/davidmoten/rtree/kryo/SerializerKryo.java.SerializerKryo.[Serializer<T, S>]create(Func1<? super T, byte[]>,Func1<byte[], ? extends T>,Func0<Kryo>)"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class SerializerKryo<T, S extends Geometry> implements Serializer<T, S> {\n\n    private final Func1<? super T, byte[]> serializer;\n    private final Func1<byte[], ? extends T> deserializer;\n    private final Func0<Kryo> kryoFactory;\n\n    public SerializerKryo(Func1<? super T, byte[]> serializer,\n            Func1<byte[], ? extends T> deserializer, Func0<Kryo> kryoFactory) {\n        this.serializer = serializer;\n        this.deserializer = deserializer;\n        this.kryoFactory = kryoFactory;\n    }\n\n    @Override\n    public void write(RTree<T, S> tree, OutputStream os) throws IOException {\n        Output output = new Output(os);\n        Kryo kryo = kryoFactory.call();\n        write(kryo, output, tree);\n    }\n\n    private void write(Kryo kryo, Output output, RTree<T, S> tree) {\n        writeContext(tree.context(), output);\n        output.writeBoolean(tree.root().isPresent());\n        output.writeInt(tree.size());\n        if (tree.root().isPresent()) {\n            writeNode(tree.root().get(), output);\n        }\n    }\n\n    private void writeNode(Node<T, S> node, Output output) {\n        boolean isLeaf = node instanceof Leaf;\n        output.writeBoolean(isLeaf);\n        if (isLeaf) {\n            Leaf<T, S> leaf = (Leaf<T, S>) node;\n            writeBounds(output, leaf.geometry().mbr());\n            output.writeInt(leaf.count());\n            for (Entry<T, S> entry : leaf.entries()) {\n                S g = entry.geometry();\n                writeValue(output, entry.value());\n                writeGeometry(output, g);\n            }\n        } else {\n            NonLeaf<T, S> nonLeaf = (NonLeaf<T, S>) node;\n            writeBounds(output, nonLeaf.geometry().mbr());\n            output.writeInt(nonLeaf.count());\n            for (Node<T, S> nd : nonLeaf.children()) {\n                writeNode(nd, output);\n            }\n        }\n    }\n\n    private void writeValue(Output output, T t) {\n        byte[] bytes = serializer.call(t);\n        output.write(bytes.length);\n        output.write(bytes);\n    }\n\n    private void writeRectangle(Output output, S g) {\n        Rectangle r = (Rectangle) g;\n        output.write(0);\n        writeBounds(output, r);\n    }\n\n    private void writeGeometry(Output output, S g) {\n        if (g instanceof Rectangle) {\n            writeRectangle(output, g);\n        } else {\n            throw new RuntimeException(\"unexpected\");\n        }\n    }\n\n    private void writeBounds(Output output, Rectangle mbr) {\n        output.writeBoolean(mbr.isDoublePrecision());\n        if (mbr.isDoublePrecision()) {\n            output.writeDouble(mbr.x1());\n            output.writeDouble(mbr.y1());\n            output.writeDouble(mbr.y1());\n            output.writeDouble(mbr.y2());\n        } else {\n            output.writeFloat((float) mbr.x1());\n            output.writeFloat((float) mbr.y1());\n            output.writeFloat((float) mbr.y1());\n            output.writeFloat((float) mbr.y2());\n        }\n    }\n\n    private void writeContext(Context<T, S> context, Output output) {\n        output.writeInt(context.minChildren());\n        output.writeInt(context.maxChildren());\n    }\n\n    @Override\n    public RTree<T, S> read(InputStream is, long sizeBytes, InternalStructure structure)\n            throws IOException {\n        Input input = new Input(is);\n        return read(input);\n    }\n\n    private static <T, S extends Geometry> RTree<T, S> read(Input input) {\n        Context<T, S> context = readContext(input);\n        boolean hasRoot = input.readBoolean();\n        int size = input.readInt();\n        Optional<Node<T, S>> root;\n        if (hasRoot) {\n            root = Optional.of(SerializerKryo.readNode(input));\n        } else {\n            root = Optional.empty();\n        }\n        return SerializerHelper.create(root, size, context);\n    }\n\n    private static <T, S extends Geometry> Node<T, S> readNode(Input input) {\n        // TODO\n        return null;\n    }\n\n    private static <T, S extends Geometry> Context<T, S> readContext(Input input) {\n        return new Context<T, S>(2, 4, new SelectorRStar(), new SplitterRStar(),\n                FactoryDefault.<T, S>instance());\n    }\n\n    public static <T, S extends Geometry> Serializer<T, S> create(\n            Func1<? super T, byte[]> serializer, Func1<byte[], ? extends T> deserializer,\n            Func0<Kryo> kryoFactory) {\n        return new SerializerKryo<T, S>(serializer, deserializer, kryoFactory);\n    }\n\n}", "super_interfaces": ["Serializer<T, S>"], "fields": [{"attribute_expression": "private final Func1<? super T, byte[]> serializer;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Func1<? super T, byte[]>", "name": "serializer", "syntax_pass": true}, {"attribute_expression": "private final Func1<byte[], ? extends T> deserializer;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Func1<byte[], ? extends T>", "name": "deserializer", "syntax_pass": true}, {"attribute_expression": "private final Func0<Kryo> kryoFactory;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Func0<Kryo>", "name": "kryoFactory", "syntax_pass": true}]}, {"uris": "src/main/java/com/github/davidmoten/rtree/geometry/Group.java.Group", "name": "Group", "file_path": "src/main/java/com/github/davidmoten/rtree/geometry/Group.java", "superclasses": "", "methods": ["[]Group(List<T>)", "[List<T>]list()", "[Geometry]geometry()"], "method_uris": ["src/main/java/com/github/davidmoten/rtree/geometry/Group.java.Group.[]Group(List<T>)", "src/main/java/com/github/davidmoten/rtree/geometry/Group.java.Group.[List<T>]list()", "src/main/java/com/github/davidmoten/rtree/geometry/Group.java.Group.[Geometry]geometry()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class Group<T extends HasGeometry> implements HasGeometry {\n\n    private final List<T> list;\n    private final Rectangle mbr;\n\n    public Group(List<T> list) {\n        this.list = list;\n        this.mbr = Util.mbr(list);\n    }\n\n    public List<T> list() {\n        return list;\n    }\n\n    @Override\n    public Geometry geometry() {\n        return mbr;\n    }\n\n}", "super_interfaces": ["HasGeometry"], "fields": [{"attribute_expression": "private final List<T> list;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "List<T>", "name": "list", "syntax_pass": true}, {"attribute_expression": "private final Rectangle mbr;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Rectangle", "name": "mbr", "syntax_pass": true}]}, {"uris": "src/main/java/com/github/davidmoten/rtree/geometry/Geometries.java.Geometries", "name": "Geometries", "file_path": "src/main/java/com/github/davidmoten/rtree/geometry/Geometries.java", "superclasses": "", "methods": ["[]Geometries()", "[Point]point(double,double)", "[Point]point(float,float)", "[Point]pointGeographic(double,double)", "[Point]pointGeographic(float,float)", "[Rectangle]rectangle(double,double,double,double)", "[Rectangle]rectangle(float,float,float,float)", "[Rectangle]rectangleGeographic(double,double,double,double)", "[Rectangle]rectangleGeographic(float,float,float,float)", "[Rectangle]rectangleDouble(double,double,double,double)", "[Circle]circle(double,double,double)", "[Circle]circle(float,float,float)", "[Line]line(double,double,double,double)", "[Line]line(float,float,float,float)", "[double]normalizeLongitude(double)", "[float]normalizeLongitude(float)", "[double]normalizeLongitudeDouble(double)"], "method_uris": ["src/main/java/com/github/davidmoten/rtree/geometry/Geometries.java.Geometries.[]Geometries()", "src/main/java/com/github/davidmoten/rtree/geometry/Geometries.java.Geometries.[Point]point(double,double)", "src/main/java/com/github/davidmoten/rtree/geometry/Geometries.java.Geometries.[Point]point(float,float)", "src/main/java/com/github/davidmoten/rtree/geometry/Geometries.java.Geometries.[Point]pointGeographic(double,double)", "src/main/java/com/github/davidmoten/rtree/geometry/Geometries.java.Geometries.[Point]pointGeographic(float,float)", "src/main/java/com/github/davidmoten/rtree/geometry/Geometries.java.Geometries.[Rectangle]rectangle(double,double,double,double)", "src/main/java/com/github/davidmoten/rtree/geometry/Geometries.java.Geometries.[Rectangle]rectangle(float,float,float,float)", "src/main/java/com/github/davidmoten/rtree/geometry/Geometries.java.Geometries.[Rectangle]rectangleGeographic(double,double,double,double)", "src/main/java/com/github/davidmoten/rtree/geometry/Geometries.java.Geometries.[Rectangle]rectangleGeographic(float,float,float,float)", "src/main/java/com/github/davidmoten/rtree/geometry/Geometries.java.Geometries.[Rectangle]rectangleDouble(double,double,double,double)", "src/main/java/com/github/davidmoten/rtree/geometry/Geometries.java.Geometries.[Circle]circle(double,double,double)", "src/main/java/com/github/davidmoten/rtree/geometry/Geometries.java.Geometries.[Circle]circle(float,float,float)", "src/main/java/com/github/davidmoten/rtree/geometry/Geometries.java.Geometries.[Line]line(double,double,double,double)", "src/main/java/com/github/davidmoten/rtree/geometry/Geometries.java.Geometries.[Line]line(float,float,float,float)", "src/main/java/com/github/davidmoten/rtree/geometry/Geometries.java.Geometries.[double]normalizeLongitude(double)", "src/main/java/com/github/davidmoten/rtree/geometry/Geometries.java.Geometries.[float]normalizeLongitude(float)", "src/main/java/com/github/davidmoten/rtree/geometry/Geometries.java.Geometries.[double]normalizeLongitudeDouble(double)"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public final class Geometries {\n\n    private Geometries() {\n        // prevent instantiation\n    }\n\n    public static Point point(double x, double y) {\n        return PointDouble.create(x, y);\n    }\n\n    public static Point point(float x, float y) {\n        return PointFloat.create(x, y);\n    }\n\n    public static Point pointGeographic(double lon, double lat) {\n        return point(normalizeLongitudeDouble(lon), lat);\n    }\n\n    public static Point pointGeographic(float lon, float lat) {\n        return point(normalizeLongitude(lon), lat);\n    }\n\n    public static Rectangle rectangle(double x1, double y1, double x2, double y2) {\n        return rectangleDouble(x1, y1, x2, y2);\n    }\n\n    public static Rectangle rectangle(float x1, float y1, float x2, float y2) {\n        return RectangleFloat.create(x1, y1, x2, y2);\n    }\n\n    public static Rectangle rectangleGeographic(double lon1, double lat1, double lon2,\n            double lat2) {\n        return rectangleGeographic((float) lon1, (float) lat1, (float) lon2, (float) lat2);\n    }\n\n    public static Rectangle rectangleGeographic(float lon1, float lat1, float lon2, float lat2) {\n        float x1 = normalizeLongitude(lon1);\n        float x2 = normalizeLongitude(lon2);\n        if (x2 < x1) {\n            x2 += 360;\n        }\n        return rectangle(x1, lat1, x2, lat2);\n    }\n\n    private static Rectangle rectangleDouble(double x1, double y1, double x2, double y2) {\n        return  RectangleDouble.create(x1, y1, x2, y2);\n    }\n\n    public static Circle circle(double x, double y, double radius) {\n        return CircleDouble.create(x, y, radius);\n    }\n\n    public static Circle circle(float x, float y, float radius) {\n        return CircleFloat.create(x, y, radius);\n    }\n\n    public static Line line(double x1, double y1, double x2, double y2) {\n        return LineDouble.create(x1, y1, x2, y2);\n    }\n\n    public static Line line(float x1, float y1, float x2, float y2) {\n        return LineFloat.create(x1, y1, x2, y2);\n    }\n\n    @VisibleForTesting\n    static double normalizeLongitude(double d) {\n        return normalizeLongitude((float) d);\n    }\n\n    private static float normalizeLongitude(float d) {\n        if (d == -180.0f)\n            return -180.0f;\n        else {\n            float sign = Math.signum(d);\n            float x = Math.abs(d) / 360;\n            float x2 = (x - (float) Math.floor(x)) * 360;\n            if (x2 >= 180)\n                x2 -= 360;\n            return x2 * sign;\n        }\n    }\n\n    private static double normalizeLongitudeDouble(double d) {\n        if (d == -180.0f)\n            return -180.0d;\n        else {\n            double sign = Math.signum(d);\n            double x = Math.abs(d) / 360;\n            double x2 = (x - (float) Math.floor(x)) * 360;\n            if (x2 >= 180)\n                x2 -= 360;\n            return x2 * sign;\n        }\n    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/main/java/com/github/davidmoten/rtree/geometry/ListPair.java.ListPair", "name": "ListPair", "file_path": "src/main/java/com/github/davidmoten/rtree/geometry/ListPair.java", "superclasses": "", "methods": ["[]ListPair(List<T>,List<T>)", "[Group<T>]group1()", "[Group<T>]group2()", "[double]areaSum()", "[double]marginSum()"], "method_uris": ["src/main/java/com/github/davidmoten/rtree/geometry/ListPair.java.ListPair.[]ListPair(List<T>,List<T>)", "src/main/java/com/github/davidmoten/rtree/geometry/ListPair.java.ListPair.[Group<T>]group1()", "src/main/java/com/github/davidmoten/rtree/geometry/ListPair.java.ListPair.[Group<T>]group2()", "src/main/java/com/github/davidmoten/rtree/geometry/ListPair.java.ListPair.[double]areaSum()", "src/main/java/com/github/davidmoten/rtree/geometry/ListPair.java.ListPair.[double]marginSum()"], "overrides": null, "attributes": [], "class_docstring": "\n\nNot thread safe.\n\n@param <T>\n           list type\n", "original_string": "public final class ListPair<T extends HasGeometry> {\n    private final Group<T> group1;\n    private final Group<T> group2;\n    // these non-final variable mean that this class is not thread-safe\n    // because access to them is not synchronized\n    private double areaSum = -1;\n    private final double marginSum;\n\n    public ListPair(List<T> list1, List<T> list2) {\n        this.group1 = new Group<T>(list1);\n        this.group2 = new Group<T>(list2);\n        this.marginSum = group1.geometry().mbr().perimeter() + group2.geometry().mbr().perimeter();\n    }\n\n    public Group<T> group1() {\n        return group1;\n    }\n\n    public Group<T> group2() {\n        return group2;\n    }\n\n    public double areaSum() {\n        if (areaSum == -1)\n            areaSum = group1.geometry().mbr().area() + group2.geometry().mbr().area();\n        return areaSum;\n    }\n\n    public double marginSum() {\n        return marginSum;\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private final Group<T> group1;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Group<T>", "name": "group1", "syntax_pass": true}, {"attribute_expression": "private final Group<T> group2;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Group<T>", "name": "group2", "syntax_pass": true}, {"attribute_expression": "private double areaSum = -1;", "docstring": " because access to them is not synchronized", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "double", "name": "areaSum = -1", "syntax_pass": true}, {"attribute_expression": "private final double marginSum;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "double", "name": "marginSum", "syntax_pass": true}]}, {"uris": "src/main/java/com/github/davidmoten/rtree/geometry/Intersects.java.Intersects", "name": "Intersects", "file_path": "src/main/java/com/github/davidmoten/rtree/geometry/Intersects.java", "superclasses": "", "methods": ["[]Intersects()"], "method_uris": ["src/main/java/com/github/davidmoten/rtree/geometry/Intersects.java.Intersects.[]Intersects()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public final class Intersects {\n\n    private Intersects() {\n        // prevent instantiation\n    }\n\n    public static final Func2<Rectangle, Circle, Boolean> rectangleIntersectsCircle = new Func2<Rectangle, Circle, Boolean>() {\n        @Override\n        public Boolean call(Rectangle rectangle, Circle circle) {\n            return circleIntersectsRectangle.call(circle, rectangle);\n        }\n    };\n\n    public static final Func2<Circle, Rectangle, Boolean> circleIntersectsRectangle = new Func2<Circle, Rectangle, Boolean>() {\n        @Override\n        public Boolean call(Circle circle, Rectangle rectangle) {\n            return circle.intersects(rectangle);\n        }\n    };\n\n    public static final Func2<Point, Circle, Boolean> pointIntersectsCircle = new Func2<Point, Circle, Boolean>() {\n        @Override\n        public Boolean call(Point point, Circle circle) {\n            return circleIntersectsPoint.call(circle, point);\n        }\n    };\n\n    public static final Func2<Circle, Point, Boolean> circleIntersectsPoint = new Func2<Circle, Point, Boolean>() {\n        @Override\n        public Boolean call(Circle circle, Point point) {\n            return circle.intersects(point);\n        }\n    };\n\n    public static final Func2<Circle, Circle, Boolean> circleIntersectsCircle = new Func2<Circle, Circle, Boolean>() {\n        @Override\n        public Boolean call(Circle a, Circle b) {\n            return a.intersects(b);\n        }\n    };\n\n    public static final Func2<Line, Line, Boolean> lineIntersectsLine = new Func2<Line, Line, Boolean>() {\n        @Override\n        public Boolean call(Line a, Line b) {\n            return a.intersects(b);\n        }\n    };\n\n    public static final Func2<Line, Rectangle, Boolean> lineIntersectsRectangle = new Func2<Line, Rectangle, Boolean>() {\n        @Override\n        public Boolean call(Line a, Rectangle r) {\n            return rectangleIntersectsLine.call(r, a);\n        }\n    };\n\n    public static final Func2<Rectangle, Line, Boolean> rectangleIntersectsLine = new Func2<Rectangle, Line, Boolean>() {\n        @Override\n        public Boolean call(Rectangle r, Line a) {\n            return a.intersects(r);\n        }\n    };\n\n    public static final Func2<Line, Circle, Boolean> lineIntersectsCircle = new Func2<Line, Circle, Boolean>() {\n        @Override\n        public Boolean call(Line a, Circle c) {\n            return circleIntersectsLine.call(c, a);\n        }\n    };\n\n    public static final Func2<Circle, Line, Boolean> circleIntersectsLine = new Func2<Circle, Line, Boolean>() {\n        @Override\n        public Boolean call(Circle c, Line a) {\n            return a.intersects(c);\n        }\n    };\n\n    public static final Func2<Line, Point, Boolean> lineIntersectsPoint = new Func2<Line, Point, Boolean>() {\n\n        @Override\n        public Boolean call(Line line, Point point) {\n            return pointIntersectsLine.call(point, line);\n        }\n    };\n\n    public static final Func2<Point, Line, Boolean> pointIntersectsLine = new Func2<Point, Line, Boolean>() {\n\n        @Override\n        public Boolean call(Point point, Line line) {\n            return line.intersects(point);\n        }\n    };\n\n    public static final Func2<Geometry, Line, Boolean> geometryIntersectsLine = new Func2<Geometry, Line, Boolean>() {\n\n        @Override\n        public Boolean call(Geometry geometry, Line line) {\n            if (geometry instanceof Line)\n                return line.intersects((Line) geometry);\n            else if (geometry instanceof Circle)\n                return line.intersects((Circle) geometry);\n            else if (geometry instanceof Point)\n                return line.intersects((Point) geometry);\n            else if (geometry instanceof Rectangle)\n                return line.intersects((Rectangle) geometry);\n            else\n                throw new RuntimeException(\"unrecognized geometry: \" + geometry);\n        }\n    };\n\n    public static final Func2<Geometry, Circle, Boolean> geometryIntersectsCircle = new Func2<Geometry, Circle, Boolean>() {\n\n        @Override\n        public Boolean call(Geometry geometry, Circle circle) {\n            if (geometry instanceof Line)\n                return circle.intersects((Line) geometry);\n            else if (geometry instanceof Circle)\n                return circle.intersects((Circle) geometry);\n            else if (geometry instanceof Point)\n                return circle.intersects((Point) geometry);\n            else if (geometry instanceof Rectangle)\n                return circle.intersects((Rectangle) geometry);\n            else\n                throw new RuntimeException(\"unrecognized geometry: \" + geometry);\n        }\n    };\n\n    public static final Func2<Circle, Geometry, Boolean> circleIntersectsGeometry = new Func2<Circle, Geometry, Boolean>() {\n\n        @Override\n        public Boolean call(Circle circle, Geometry geometry) {\n            return geometryIntersectsCircle.call(geometry, circle);\n        }\n    };\n\n    public static final Func2<Geometry, Rectangle, Boolean> geometryIntersectsRectangle = new Func2<Geometry, Rectangle, Boolean>() {\n\n        @Override\n        public Boolean call(Geometry geometry, Rectangle r) {\n            if (geometry instanceof Line)\n                return geometry.intersects(r);\n            else if (geometry instanceof Circle)\n                return geometry.intersects(r);\n            else if (geometry instanceof Point)\n                return geometry.intersects(r);\n            else if (geometry instanceof Rectangle)\n                return r.intersects((Rectangle) geometry);\n            else\n                throw new RuntimeException(\"unrecognized geometry: \" + geometry);\n        }\n    };\n\n    public static final Func2<Rectangle, Geometry, Boolean> rectangleIntersectsGeometry = new Func2<Rectangle, Geometry, Boolean>() {\n\n        @Override\n        public Boolean call(Rectangle r, Geometry geometry) {\n            return geometryIntersectsRectangle.call(geometry, r);\n        }\n    };\n\n    public static final Func2<Geometry, Point, Boolean> geometryIntersectsPoint = new Func2<Geometry, Point, Boolean>() {\n\n        @Override\n        public Boolean call(Geometry geometry, Point point) {\n            return geometryIntersectsRectangle.call(geometry, point.mbr());\n        }\n    };\n\n    public static final Func2<Point, Geometry, Boolean> pointIntersectsGeometry = new Func2<Point, Geometry, Boolean>() {\n\n        @Override\n        public Boolean call(Point point, Geometry geometry) {\n            return geometryIntersectsPoint.call(geometry, point);\n        }\n    };\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "public static final Func2<Rectangle, Circle, Boolean> rectangleIntersectsCircle = new Func2<Rectangle, Circle, Boolean>() {\n        @Override\n        public Boolean call(Rectangle rectangle, Circle circle) {\n            return circleIntersectsRectangle.call(circle, rectangle);\n        }\n    };", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "Func2<Rectangle, Circle, Boolean>", "name": "rectangleIntersectsCircle = new Func2<Rectangle, Circle, Boolean>() {\n        @Override\n        public Boolean call(Rectangle rectangle, Circle circle) {\n            return circleIntersectsRectangle.call(circle, rectangle);\n        }\n    }", "syntax_pass": true}, {"attribute_expression": "public static final Func2<Circle, Rectangle, Boolean> circleIntersectsRectangle = new Func2<Circle, Rectangle, Boolean>() {\n        @Override\n        public Boolean call(Circle circle, Rectangle rectangle) {\n            return circle.intersects(rectangle);\n        }\n    };", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "Func2<Circle, Rectangle, Boolean>", "name": "circleIntersectsRectangle = new Func2<Circle, Rectangle, Boolean>() {\n        @Override\n        public Boolean call(Circle circle, Rectangle rectangle) {\n            return circle.intersects(rectangle);\n        }\n    }", "syntax_pass": true}, {"attribute_expression": "public static final Func2<Point, Circle, Boolean> pointIntersectsCircle = new Func2<Point, Circle, Boolean>() {\n        @Override\n        public Boolean call(Point point, Circle circle) {\n            return circleIntersectsPoint.call(circle, point);\n        }\n    };", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "Func2<Point, Circle, Boolean>", "name": "pointIntersectsCircle = new Func2<Point, Circle, Boolean>() {\n        @Override\n        public Boolean call(Point point, Circle circle) {\n            return circleIntersectsPoint.call(circle, point);\n        }\n    }", "syntax_pass": true}, {"attribute_expression": "public static final Func2<Circle, Point, Boolean> circleIntersectsPoint = new Func2<Circle, Point, Boolean>() {\n        @Override\n        public Boolean call(Circle circle, Point point) {\n            return circle.intersects(point);\n        }\n    };", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "Func2<Circle, Point, Boolean>", "name": "circleIntersectsPoint = new Func2<Circle, Point, Boolean>() {\n        @Override\n        public Boolean call(Circle circle, Point point) {\n            return circle.intersects(point);\n        }\n    }", "syntax_pass": true}, {"attribute_expression": "public static final Func2<Circle, Circle, Boolean> circleIntersectsCircle = new Func2<Circle, Circle, Boolean>() {\n        @Override\n        public Boolean call(Circle a, Circle b) {\n            return a.intersects(b);\n        }\n    };", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "Func2<Circle, Circle, Boolean>", "name": "circleIntersectsCircle = new Func2<Circle, Circle, Boolean>() {\n        @Override\n        public Boolean call(Circle a, Circle b) {\n            return a.intersects(b);\n        }\n    }", "syntax_pass": true}, {"attribute_expression": "public static final Func2<Line, Line, Boolean> lineIntersectsLine = new Func2<Line, Line, Boolean>() {\n        @Override\n        public Boolean call(Line a, Line b) {\n            return a.intersects(b);\n        }\n    };", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "Func2<Line, Line, Boolean>", "name": "lineIntersectsLine = new Func2<Line, Line, Boolean>() {\n        @Override\n        public Boolean call(Line a, Line b) {\n            return a.intersects(b);\n        }\n    }", "syntax_pass": true}, {"attribute_expression": "public static final Func2<Line, Rectangle, Boolean> lineIntersectsRectangle = new Func2<Line, Rectangle, Boolean>() {\n        @Override\n        public Boolean call(Line a, Rectangle r) {\n            return rectangleIntersectsLine.call(r, a);\n        }\n    };", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "Func2<Line, Rectangle, Boolean>", "name": "lineIntersectsRectangle = new Func2<Line, Rectangle, Boolean>() {\n        @Override\n        public Boolean call(Line a, Rectangle r) {\n            return rectangleIntersectsLine.call(r, a);\n        }\n    }", "syntax_pass": true}, {"attribute_expression": "public static final Func2<Rectangle, Line, Boolean> rectangleIntersectsLine = new Func2<Rectangle, Line, Boolean>() {\n        @Override\n        public Boolean call(Rectangle r, Line a) {\n            return a.intersects(r);\n        }\n    };", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "Func2<Rectangle, Line, Boolean>", "name": "rectangleIntersectsLine = new Func2<Rectangle, Line, Boolean>() {\n        @Override\n        public Boolean call(Rectangle r, Line a) {\n            return a.intersects(r);\n        }\n    }", "syntax_pass": true}, {"attribute_expression": "public static final Func2<Line, Circle, Boolean> lineIntersectsCircle = new Func2<Line, Circle, Boolean>() {\n        @Override\n        public Boolean call(Line a, Circle c) {\n            return circleIntersectsLine.call(c, a);\n        }\n    };", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "Func2<Line, Circle, Boolean>", "name": "lineIntersectsCircle = new Func2<Line, Circle, Boolean>() {\n        @Override\n        public Boolean call(Line a, Circle c) {\n            return circleIntersectsLine.call(c, a);\n        }\n    }", "syntax_pass": true}, {"attribute_expression": "public static final Func2<Circle, Line, Boolean> circleIntersectsLine = new Func2<Circle, Line, Boolean>() {\n        @Override\n        public Boolean call(Circle c, Line a) {\n            return a.intersects(c);\n        }\n    };", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "Func2<Circle, Line, Boolean>", "name": "circleIntersectsLine = new Func2<Circle, Line, Boolean>() {\n        @Override\n        public Boolean call(Circle c, Line a) {\n            return a.intersects(c);\n        }\n    }", "syntax_pass": true}, {"attribute_expression": "public static final Func2<Line, Point, Boolean> lineIntersectsPoint = new Func2<Line, Point, Boolean>() {\n\n        @Override\n        public Boolean call(Line line, Point point) {\n            return pointIntersectsLine.call(point, line);\n        }\n    };", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "Func2<Line, Point, Boolean>", "name": "lineIntersectsPoint = new Func2<Line, Point, Boolean>() {\n\n        @Override\n        public Boolean call(Line line, Point point) {\n            return pointIntersectsLine.call(point, line);\n        }\n    }", "syntax_pass": true}, {"attribute_expression": "public static final Func2<Point, Line, Boolean> pointIntersectsLine = new Func2<Point, Line, Boolean>() {\n\n        @Override\n        public Boolean call(Point point, Line line) {\n            return line.intersects(point);\n        }\n    };", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "Func2<Point, Line, Boolean>", "name": "pointIntersectsLine = new Func2<Point, Line, Boolean>() {\n\n        @Override\n        public Boolean call(Point point, Line line) {\n            return line.intersects(point);\n        }\n    }", "syntax_pass": true}, {"attribute_expression": "public static final Func2<Geometry, Line, Boolean> geometryIntersectsLine = new Func2<Geometry, Line, Boolean>() {\n\n        @Override\n        public Boolean call(Geometry geometry, Line line) {\n            if (geometry instanceof Line)\n                return line.intersects((Line) geometry);\n            else if (geometry instanceof Circle)\n                return line.intersects((Circle) geometry);\n            else if (geometry instanceof Point)\n                return line.intersects((Point) geometry);\n            else if (geometry instanceof Rectangle)\n                return line.intersects((Rectangle) geometry);\n            else\n                throw new RuntimeException(\"unrecognized geometry: \" + geometry);\n        }\n    };", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "Func2<Geometry, Line, Boolean>", "name": "geometryIntersectsLine = new Func2<Geometry, Line, Boolean>() {\n\n        @Override\n        public Boolean call(Geometry geometry, Line line) {\n            if (geometry instanceof Line)\n                return line.intersects((Line) geometry);\n            else if (geometry instanceof Circle)\n                return line.intersects((Circle) geometry);\n            else if (geometry instanceof Point)\n                return line.intersects((Point) geometry);\n            else if (geometry instanceof Rectangle)\n                return line.intersects((Rectangle) geometry);\n            else\n                throw new RuntimeException(\"unrecognized geometry: \" + geometry);\n        }\n    }", "syntax_pass": true}, {"attribute_expression": "public static final Func2<Geometry, Circle, Boolean> geometryIntersectsCircle = new Func2<Geometry, Circle, Boolean>() {\n\n        @Override\n        public Boolean call(Geometry geometry, Circle circle) {\n            if (geometry instanceof Line)\n                return circle.intersects((Line) geometry);\n            else if (geometry instanceof Circle)\n                return circle.intersects((Circle) geometry);\n            else if (geometry instanceof Point)\n                return circle.intersects((Point) geometry);\n            else if (geometry instanceof Rectangle)\n                return circle.intersects((Rectangle) geometry);\n            else\n                throw new RuntimeException(\"unrecognized geometry: \" + geometry);\n        }\n    };", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "Func2<Geometry, Circle, Boolean>", "name": "geometryIntersectsCircle = new Func2<Geometry, Circle, Boolean>() {\n\n        @Override\n        public Boolean call(Geometry geometry, Circle circle) {\n            if (geometry instanceof Line)\n                return circle.intersects((Line) geometry);\n            else if (geometry instanceof Circle)\n                return circle.intersects((Circle) geometry);\n            else if (geometry instanceof Point)\n                return circle.intersects((Point) geometry);\n            else if (geometry instanceof Rectangle)\n                return circle.intersects((Rectangle) geometry);\n            else\n                throw new RuntimeException(\"unrecognized geometry: \" + geometry);\n        }\n    }", "syntax_pass": true}, {"attribute_expression": "public static final Func2<Circle, Geometry, Boolean> circleIntersectsGeometry = new Func2<Circle, Geometry, Boolean>() {\n\n        @Override\n        public Boolean call(Circle circle, Geometry geometry) {\n            return geometryIntersectsCircle.call(geometry, circle);\n        }\n    };", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "Func2<Circle, Geometry, Boolean>", "name": "circleIntersectsGeometry = new Func2<Circle, Geometry, Boolean>() {\n\n        @Override\n        public Boolean call(Circle circle, Geometry geometry) {\n            return geometryIntersectsCircle.call(geometry, circle);\n        }\n    }", "syntax_pass": true}, {"attribute_expression": "public static final Func2<Geometry, Rectangle, Boolean> geometryIntersectsRectangle = new Func2<Geometry, Rectangle, Boolean>() {\n\n        @Override\n        public Boolean call(Geometry geometry, Rectangle r) {\n            if (geometry instanceof Line)\n                return geometry.intersects(r);\n            else if (geometry instanceof Circle)\n                return geometry.intersects(r);\n            else if (geometry instanceof Point)\n                return geometry.intersects(r);\n            else if (geometry instanceof Rectangle)\n                return r.intersects((Rectangle) geometry);\n            else\n                throw new RuntimeException(\"unrecognized geometry: \" + geometry);\n        }\n    };", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "Func2<Geometry, Rectangle, Boolean>", "name": "geometryIntersectsRectangle = new Func2<Geometry, Rectangle, Boolean>() {\n\n        @Override\n        public Boolean call(Geometry geometry, Rectangle r) {\n            if (geometry instanceof Line)\n                return geometry.intersects(r);\n            else if (geometry instanceof Circle)\n                return geometry.intersects(r);\n            else if (geometry instanceof Point)\n                return geometry.intersects(r);\n            else if (geometry instanceof Rectangle)\n                return r.intersects((Rectangle) geometry);\n            else\n                throw new RuntimeException(\"unrecognized geometry: \" + geometry);\n        }\n    }", "syntax_pass": true}, {"attribute_expression": "public static final Func2<Rectangle, Geometry, Boolean> rectangleIntersectsGeometry = new Func2<Rectangle, Geometry, Boolean>() {\n\n        @Override\n        public Boolean call(Rectangle r, Geometry geometry) {\n            return geometryIntersectsRectangle.call(geometry, r);\n        }\n    };", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "Func2<Rectangle, Geometry, Boolean>", "name": "rectangleIntersectsGeometry = new Func2<Rectangle, Geometry, Boolean>() {\n\n        @Override\n        public Boolean call(Rectangle r, Geometry geometry) {\n            return geometryIntersectsRectangle.call(geometry, r);\n        }\n    }", "syntax_pass": true}, {"attribute_expression": "public static final Func2<Geometry, Point, Boolean> geometryIntersectsPoint = new Func2<Geometry, Point, Boolean>() {\n\n        @Override\n        public Boolean call(Geometry geometry, Point point) {\n            return geometryIntersectsRectangle.call(geometry, point.mbr());\n        }\n    };", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "Func2<Geometry, Point, Boolean>", "name": "geometryIntersectsPoint = new Func2<Geometry, Point, Boolean>() {\n\n        @Override\n        public Boolean call(Geometry geometry, Point point) {\n            return geometryIntersectsRectangle.call(geometry, point.mbr());\n        }\n    }", "syntax_pass": true}, {"attribute_expression": "public static final Func2<Point, Geometry, Boolean> pointIntersectsGeometry = new Func2<Point, Geometry, Boolean>() {\n\n        @Override\n        public Boolean call(Point point, Geometry geometry) {\n            return geometryIntersectsPoint.call(geometry, point);\n        }\n    };", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "Func2<Point, Geometry, Boolean>", "name": "pointIntersectsGeometry = new Func2<Point, Geometry, Boolean>() {\n\n        @Override\n        public Boolean call(Point point, Geometry geometry) {\n            return geometryIntersectsPoint.call(geometry, point);\n        }\n    }", "syntax_pass": true}]}, {"uris": "src/main/java/com/github/davidmoten/rtree/geometry/internal/LineFloat.java.LineFloat", "name": "LineFloat", "file_path": "src/main/java/com/github/davidmoten/rtree/geometry/internal/LineFloat.java", "superclasses": "", "methods": ["[]LineFloat(double,double,double,double)", "[LineFloat]create(double,double,double,double)", "[double]distance(Rectangle)", "[double]distance(double,double,double,double)", "[Rectangle]mbr()", "[boolean]intersects(Rectangle)", "[double]x1()", "[double]y1()", "[double]x2()", "[double]y2()", "[boolean]intersects(Line)", "[boolean]intersects(Point)", "[boolean]intersects(Circle)", "[int]hashCode()", "[boolean]equals(Object)", "[boolean]isDoublePrecision()"], "method_uris": ["src/main/java/com/github/davidmoten/rtree/geometry/internal/LineFloat.java.LineFloat.[]LineFloat(double,double,double,double)", "src/main/java/com/github/davidmoten/rtree/geometry/internal/LineFloat.java.LineFloat.[LineFloat]create(double,double,double,double)", "src/main/java/com/github/davidmoten/rtree/geometry/internal/LineFloat.java.LineFloat.[double]distance(Rectangle)", "src/main/java/com/github/davidmoten/rtree/geometry/internal/LineFloat.java.LineFloat.[double]distance(double,double,double,double)", "src/main/java/com/github/davidmoten/rtree/geometry/internal/LineFloat.java.LineFloat.[Rectangle]mbr()", "src/main/java/com/github/davidmoten/rtree/geometry/internal/LineFloat.java.LineFloat.[boolean]intersects(Rectangle)", "src/main/java/com/github/davidmoten/rtree/geometry/internal/LineFloat.java.LineFloat.[double]x1()", "src/main/java/com/github/davidmoten/rtree/geometry/internal/LineFloat.java.LineFloat.[double]y1()", "src/main/java/com/github/davidmoten/rtree/geometry/internal/LineFloat.java.LineFloat.[double]x2()", "src/main/java/com/github/davidmoten/rtree/geometry/internal/LineFloat.java.LineFloat.[double]y2()", "src/main/java/com/github/davidmoten/rtree/geometry/internal/LineFloat.java.LineFloat.[boolean]intersects(Line)", "src/main/java/com/github/davidmoten/rtree/geometry/internal/LineFloat.java.LineFloat.[boolean]intersects(Point)", "src/main/java/com/github/davidmoten/rtree/geometry/internal/LineFloat.java.LineFloat.[boolean]intersects(Circle)", "src/main/java/com/github/davidmoten/rtree/geometry/internal/LineFloat.java.LineFloat.[int]hashCode()", "src/main/java/com/github/davidmoten/rtree/geometry/internal/LineFloat.java.LineFloat.[boolean]equals(Object)", "src/main/java/com/github/davidmoten/rtree/geometry/internal/LineFloat.java.LineFloat.[boolean]isDoublePrecision()"], "overrides": null, "attributes": [], "class_docstring": "\nA line segment.\n", "original_string": "public final class LineFloat implements Line {\n\n    private final double x1;\n    private final double y1;\n    private final double x2;\n    private final double y2;\n\n    private LineFloat(double x1, double y1, double x2, double y2) {\n        this.x1 = x1;\n        this.y1 = y1;\n        this.x2 = x2;\n        this.y2 = y2;\n    }\n\n    public static LineFloat create(double x1, double y1, double x2, double y2) {\n        return new LineFloat(x1, y1, x2, y2);\n    }\n\n    @Override\n    public double distance(Rectangle r) {\n        if (r.contains(x1, y1) || r.contains(x2, y2)) {\n            return 0;\n        } else {\n            double d1 = distance(r.x1(), r.y1(), r.x1(), r.y2());\n            if (d1 == 0)\n                return 0;\n            double d2 = distance(r.x1(), r.y2(), r.x2(), r.y2());\n            if (d2 == 0)\n                return 0;\n            double d3 = distance(r.x2(), r.y2(), r.x2(), r.y1());\n            double d4 = distance(r.x2(), r.y1(), r.x1(), r.y1());\n            return Math.min(d1, Math.min(d2, Math.min(d3, d4)));\n        }\n    }\n\n    private double distance(double x1, double y1, double x2, double y2) {\n        Line2D line = new Line2D(x1, y1, x2, y2);\n        double d1 = line.ptSegDist(this.x1, this.y1);\n        double d2 = line.ptSegDist(this.x2, this.y2);\n        Line2D line2 = new Line2D(this.x1, this.y1, this.x2, this.y2);\n        double d3 = line2.ptSegDist(x1, y1);\n        if (d3 == 0)\n            return 0;\n        double d4 = line2.ptSegDist(x2, y2);\n        if (d4 == 0)\n            return 0;\n        else\n            return Math.min(d1, Math.min(d2, Math.min(d3, d4)));\n\n    }\n\n    @Override\n    public Rectangle mbr() {\n        return Geometries.rectangle(Math.min(x1, x2), Math.min(y1, y2), Math.max(x1, x2),\n                Math.max(y1, y2));\n    }\n\n    @Override\n    public boolean intersects(Rectangle r) {\n        return RectangleUtil.rectangleIntersectsLine(r.x1(), r.y1(), r.x2() - r.x1(),\n                r.y2() - r.y1(), x1, y1, x2, y2);\n    }\n\n    @Override\n    public double x1() {\n        return x1;\n    }\n\n    @Override\n    public double y1() {\n        return y1;\n    }\n\n    @Override\n    public double x2() {\n        return x2;\n    }\n\n    @Override\n    public double y2() {\n        return y2;\n    }\n\n    @Override\n    public boolean intersects(Line b) {\n        Line2D line1 = new Line2D(x1, y1, x2, y2);\n        Line2D line2 = new Line2D(b.x1(), b.y1(), b.x2(), b.y2());\n        return line2.intersectsLine(line1);\n    }\n\n    @Override\n    public boolean intersects(Point point) {\n        return intersects(point.mbr());\n    }\n\n    @Override\n    public boolean intersects(Circle circle) {\n        return GeometryUtil.lineIntersects(x1, y1, x2, y2, circle);\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(x1, y1, x2, y2);\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        Optional<LineFloat> other = ObjectsHelper.asClass(obj, LineFloat.class);\n        if (other.isPresent()) {\n            return Objects.equals(x1, other.get().x1) && Objects.equals(x2, other.get().x2)\n                    && Objects.equals(y1, other.get().y1) && Objects.equals(y2, other.get().y2);\n        } else\n            return false;\n    }\n\n    @Override\n    public boolean isDoublePrecision() {\n        return false;\n    }\n\n}", "super_interfaces": ["Line"], "fields": [{"attribute_expression": "private final double x1;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "double", "name": "x1", "syntax_pass": true}, {"attribute_expression": "private final double y1;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "double", "name": "y1", "syntax_pass": true}, {"attribute_expression": "private final double x2;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "double", "name": "x2", "syntax_pass": true}, {"attribute_expression": "private final double y2;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "double", "name": "y2", "syntax_pass": true}]}, {"uris": "src/main/java/com/github/davidmoten/rtree/geometry/internal/PointFloat.java.PointFloat", "name": "PointFloat", "file_path": "src/main/java/com/github/davidmoten/rtree/geometry/internal/PointFloat.java", "superclasses": "", "methods": ["[]PointFloat(float,float)", "[PointFloat]create(float,float)", "[Rectangle]mbr()", "[double]distance(Rectangle)", "[boolean]intersects(Rectangle)", "[double]x()", "[double]y()", "[int]hashCode()", "[boolean]equals(Object)", "[String]toString()", "[Geometry]geometry()", "[double]x1()", "[double]y1()", "[double]x2()", "[double]y2()", "[double]area()", "[Rectangle]add(Rectangle)", "[boolean]contains(double,double)", "[double]intersectionArea(Rectangle)", "[double]perimeter()", "[boolean]isDoublePrecision()", "[float]xFloat()", "[float]yFloat()"], "method_uris": ["src/main/java/com/github/davidmoten/rtree/geometry/internal/PointFloat.java.PointFloat.[]PointFloat(float,float)", "src/main/java/com/github/davidmoten/rtree/geometry/internal/PointFloat.java.PointFloat.[PointFloat]create(float,float)", "src/main/java/com/github/davidmoten/rtree/geometry/internal/PointFloat.java.PointFloat.[Rectangle]mbr()", "src/main/java/com/github/davidmoten/rtree/geometry/internal/PointFloat.java.PointFloat.[double]distance(Rectangle)", "src/main/java/com/github/davidmoten/rtree/geometry/internal/PointFloat.java.PointFloat.[boolean]intersects(Rectangle)", "src/main/java/com/github/davidmoten/rtree/geometry/internal/PointFloat.java.PointFloat.[double]x()", "src/main/java/com/github/davidmoten/rtree/geometry/internal/PointFloat.java.PointFloat.[double]y()", "src/main/java/com/github/davidmoten/rtree/geometry/internal/PointFloat.java.PointFloat.[int]hashCode()", "src/main/java/com/github/davidmoten/rtree/geometry/internal/PointFloat.java.PointFloat.[boolean]equals(Object)", "src/main/java/com/github/davidmoten/rtree/geometry/internal/PointFloat.java.PointFloat.[String]toString()", "src/main/java/com/github/davidmoten/rtree/geometry/internal/PointFloat.java.PointFloat.[Geometry]geometry()", "src/main/java/com/github/davidmoten/rtree/geometry/internal/PointFloat.java.PointFloat.[double]x1()", "src/main/java/com/github/davidmoten/rtree/geometry/internal/PointFloat.java.PointFloat.[double]y1()", "src/main/java/com/github/davidmoten/rtree/geometry/internal/PointFloat.java.PointFloat.[double]x2()", "src/main/java/com/github/davidmoten/rtree/geometry/internal/PointFloat.java.PointFloat.[double]y2()", "src/main/java/com/github/davidmoten/rtree/geometry/internal/PointFloat.java.PointFloat.[double]area()", "src/main/java/com/github/davidmoten/rtree/geometry/internal/PointFloat.java.PointFloat.[Rectangle]add(Rectangle)", "src/main/java/com/github/davidmoten/rtree/geometry/internal/PointFloat.java.PointFloat.[boolean]contains(double,double)", "src/main/java/com/github/davidmoten/rtree/geometry/internal/PointFloat.java.PointFloat.[double]intersectionArea(Rectangle)", "src/main/java/com/github/davidmoten/rtree/geometry/internal/PointFloat.java.PointFloat.[double]perimeter()", "src/main/java/com/github/davidmoten/rtree/geometry/internal/PointFloat.java.PointFloat.[boolean]isDoublePrecision()", "src/main/java/com/github/davidmoten/rtree/geometry/internal/PointFloat.java.PointFloat.[float]xFloat()", "src/main/java/com/github/davidmoten/rtree/geometry/internal/PointFloat.java.PointFloat.[float]yFloat()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public final class PointFloat implements Point {\n\n    private final float x;\n    private final float y;\n\n    private PointFloat(float x, float y) {\n        this.x = x;\n        this.y = y;\n    }\n\n    public static PointFloat create(float x, float y) {\n        return new PointFloat(x, y);\n    }\n\n    @Override\n    public Rectangle mbr() {\n        return this;\n    }\n\n    @Override\n    public double distance(Rectangle r) {\n        return GeometryUtil.distance(x, y, r);\n    }\n\n    @Override\n    public boolean intersects(Rectangle r) {\n        return r.x1() <= x && x <= r.x2() && r.y1() <= y && y <= r.y2();\n    }\n\n    @Override\n    public double x() {\n        return x;\n    }\n\n    @Override\n    public double y() {\n        return y;\n    }\n\n    @Override\n    public int hashCode() {\n        final int prime = 31;\n        int result = 1;\n        result = prime * result + Float.floatToIntBits(x);\n        result = prime * result + Float.floatToIntBits(y);\n        return result;\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        if (this == obj)\n            return true;\n        if (obj == null)\n            return false;\n        if (getClass() != obj.getClass())\n            return false;\n        PointFloat other = (PointFloat) obj;\n        if (Float.floatToIntBits(x) != Float.floatToIntBits(other.x))\n            return false;\n        if (Float.floatToIntBits(y) != Float.floatToIntBits(other.y))\n            return false;\n        return true;\n    }\n\n    @Override\n    public String toString() {\n        return \"Point [x=\" + x() + \", y=\" + y() + \"]\";\n    }\n\n    @Override\n    public Geometry geometry() {\n        return this;\n    }\n\n    @Override\n    public double x1() {\n        return x;\n    }\n\n    @Override\n    public double y1() {\n        return y;\n    }\n\n    @Override\n    public double x2() {\n        return x;\n    }\n\n    @Override\n    public double y2() {\n        return y;\n    }\n\n    @Override\n    public double area() {\n        return 0;\n    }\n\n    @Override\n    public Rectangle add(Rectangle r) {\n        if (r.isDoublePrecision()) {\n            return RectangleDouble.create(Math.min(x, r.x1()), Math.min(y, r.y1()),\n                    Math.max(x, r.x2()), Math.max(y, r.y2()));\n        } else if (r instanceof RectangleFloat) {\n            RectangleFloat rf = (RectangleFloat) r;\n            return RectangleFloat.create(Math.min(x, rf.x1), Math.min(y, rf.y1), Math.max(x, rf.x2),\n                    Math.max(y, rf.y2));\n        } else if (r instanceof PointFloat) {\n            PointFloat p = (PointFloat) r;\n            return RectangleFloat.create(Math.min(x, p.x), Math.min(y, p.y), Math.max(x, p.x),\n                    Math.max(y, p.y));\n        } else {\n            PointDouble p = (PointDouble) r;\n            return RectangleDouble.create(Math.min(x, p.x()), Math.min(y, p.y()),\n                    Math.max(x, p.x()), Math.max(y, p.y()));\n        }\n    }\n\n    @Override\n    public boolean contains(double x, double y) {\n        return this.x == x && this.y == y;\n    }\n\n    @Override\n    public double intersectionArea(Rectangle r) {\n        return 0;\n    }\n\n    @Override\n    public double perimeter() {\n        return 0;\n    }\n\n    @Override\n    public boolean isDoublePrecision() {\n        return false;\n    }\n\n    public float xFloat() {\n        return x;\n    }\n\n    public float yFloat() {\n        return y;\n    }\n\n}", "super_interfaces": ["Point"], "fields": [{"attribute_expression": "private final float x;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "float", "name": "x", "syntax_pass": true}, {"attribute_expression": "private final float y;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "float", "name": "y", "syntax_pass": true}]}, {"uris": "src/main/java/com/github/davidmoten/rtree/geometry/internal/RectangleDouble.java.RectangleDouble", "name": "RectangleDouble", "file_path": "src/main/java/com/github/davidmoten/rtree/geometry/internal/RectangleDouble.java", "superclasses": "", "methods": ["[]RectangleDouble(double,double,double,double)", "[RectangleDouble]create(double,double,double,double)", "[double]x1()", "[double]y1()", "[double]x2()", "[double]y2()", "[Rectangle]add(Rectangle)", "[boolean]contains(double,double)", "[boolean]intersects(Rectangle)", "[boolean]intersects(RectangleDouble)", "[double]distance(Rectangle)", "[Rectangle]mbr()", "[String]toString()", "[int]hashCode()", "[boolean]equals(Object)", "[double]intersectionArea(Rectangle)", "[Geometry]geometry()", "[double]max(double,double)", "[double]min(double,double)", "[double]perimeter()", "[double]area()", "[boolean]isDoublePrecision()"], "method_uris": ["src/main/java/com/github/davidmoten/rtree/geometry/internal/RectangleDouble.java.RectangleDouble.[]RectangleDouble(double,double,double,double)", "src/main/java/com/github/davidmoten/rtree/geometry/internal/RectangleDouble.java.RectangleDouble.[RectangleDouble]create(double,double,double,double)", "src/main/java/com/github/davidmoten/rtree/geometry/internal/RectangleDouble.java.RectangleDouble.[double]x1()", "src/main/java/com/github/davidmoten/rtree/geometry/internal/RectangleDouble.java.RectangleDouble.[double]y1()", "src/main/java/com/github/davidmoten/rtree/geometry/internal/RectangleDouble.java.RectangleDouble.[double]x2()", "src/main/java/com/github/davidmoten/rtree/geometry/internal/RectangleDouble.java.RectangleDouble.[double]y2()", "src/main/java/com/github/davidmoten/rtree/geometry/internal/RectangleDouble.java.RectangleDouble.[Rectangle]add(Rectangle)", "src/main/java/com/github/davidmoten/rtree/geometry/internal/RectangleDouble.java.RectangleDouble.[boolean]contains(double,double)", "src/main/java/com/github/davidmoten/rtree/geometry/internal/RectangleDouble.java.RectangleDouble.[boolean]intersects(Rectangle)", "src/main/java/com/github/davidmoten/rtree/geometry/internal/RectangleDouble.java.RectangleDouble.[boolean]intersects(RectangleDouble)", "src/main/java/com/github/davidmoten/rtree/geometry/internal/RectangleDouble.java.RectangleDouble.[double]distance(Rectangle)", "src/main/java/com/github/davidmoten/rtree/geometry/internal/RectangleDouble.java.RectangleDouble.[Rectangle]mbr()", "src/main/java/com/github/davidmoten/rtree/geometry/internal/RectangleDouble.java.RectangleDouble.[String]toString()", "src/main/java/com/github/davidmoten/rtree/geometry/internal/RectangleDouble.java.RectangleDouble.[int]hashCode()", "src/main/java/com/github/davidmoten/rtree/geometry/internal/RectangleDouble.java.RectangleDouble.[boolean]equals(Object)", "src/main/java/com/github/davidmoten/rtree/geometry/internal/RectangleDouble.java.RectangleDouble.[double]intersectionArea(Rectangle)", "src/main/java/com/github/davidmoten/rtree/geometry/internal/RectangleDouble.java.RectangleDouble.[Geometry]geometry()", "src/main/java/com/github/davidmoten/rtree/geometry/internal/RectangleDouble.java.RectangleDouble.[double]max(double,double)", "src/main/java/com/github/davidmoten/rtree/geometry/internal/RectangleDouble.java.RectangleDouble.[double]min(double,double)", "src/main/java/com/github/davidmoten/rtree/geometry/internal/RectangleDouble.java.RectangleDouble.[double]perimeter()", "src/main/java/com/github/davidmoten/rtree/geometry/internal/RectangleDouble.java.RectangleDouble.[double]area()", "src/main/java/com/github/davidmoten/rtree/geometry/internal/RectangleDouble.java.RectangleDouble.[boolean]isDoublePrecision()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public final class RectangleDouble implements Rectangle {\n    private final double x1, y1, x2, y2;\n\n    private RectangleDouble(double x1, double y1, double x2, double y2) {\n        Preconditions.checkArgument(x2 >= x1);\n        Preconditions.checkArgument(y2 >= y1);\n        this.x1 = x1;\n        this.y1 = y1;\n        this.x2 = x2;\n        this.y2 = y2;\n    }\n\n    public static RectangleDouble create(double x1, double y1, double x2, double y2) {\n        return new RectangleDouble((double) x1, (double) y1, (double) x2, (double) y2);\n    }\n\n    @Override\n    public double x1() {\n        return x1;\n    }\n\n    @Override\n    public double y1() {\n        return y1;\n    }\n\n    @Override\n    public double x2() {\n        return x2;\n    }\n\n    @Override\n    public double y2() {\n        return  y2;\n    }\n\n    @Override\n    public Rectangle add(Rectangle r) {\n        return new RectangleDouble(min(x1, r.x1()), min(y1, r.y1()), max(x2, r.x2()),\n                max(y2, r.y2()));\n    }\n\n    @Override\n    public boolean contains(double x, double y) {\n        return x >= x1 && x <= x2 && y >= y1 && y <= y2;\n    }\n\n    @Override\n    public boolean intersects(Rectangle r) {\n        if (r instanceof RectangleDouble) {\n            RectangleDouble rd = (RectangleDouble) r;\n            return intersects(rd);\n        } else {\n            return GeometryUtil.intersects(x1, y1, x2, y2, r.x1(), r.y1(), r.x2(), r.y2());\n        }\n    }\n\n    private boolean intersects(RectangleDouble rd) {\n        return GeometryUtil.intersects(x1, y1, x2, y2, rd.x1, rd.y1, rd.x2, rd.y2);\n    }\n\n    @Override\n    public double distance(Rectangle r) {\n        return GeometryUtil.distance(x1, y1, x2, y2, r.x1(), r.y1(), r.x2(), r.y2());\n    }\n\n    @Override\n    public Rectangle mbr() {\n        return this;\n    }\n\n    @Override\n    public String toString() {\n        return \"Rectangle [x1=\" + x1 + \", y1=\" + y1 + \", x2=\" + x2 + \", y2=\" + y2 + \"]\";\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(x1, y1, x2, y2);\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        Optional<RectangleDouble> other = ObjectsHelper.asClass(obj, RectangleDouble.class);\n        if (other.isPresent()) {\n            return Objects.equals(x1, other.get().x1) && Objects.equals(x2, other.get().x2)\n                    && Objects.equals(y1, other.get().y1) && Objects.equals(y2, other.get().y2);\n        } else\n            return false;\n    }\n\n    @Override\n    public double intersectionArea(Rectangle r) {\n        if (!intersects(r))\n            return 0;\n        else {\n            return create(max(x1, r.x1()), max(y1, r.y1()), min(x2, r.x2()), min(y2, r.y2()))\n                    .area();\n        }\n    }\n\n    @Override\n    public Geometry geometry() {\n        return this;\n    }\n\n    private static double max(double a, double b) {\n        if (a < b)\n            return b;\n        else\n            return a;\n    }\n\n    private static double min(double a, double b) {\n        if (a < b)\n            return a;\n        else\n            return b;\n    }\n\n    @Override\n    public double perimeter() {\n        return 2 * (x2 - x1) + 2 * (y2 - y1);\n    }\n\n    @Override\n    public double area() {\n        return (x2 - x1) * (y2 - y1);\n    }\n\n    @Override\n    public boolean isDoublePrecision() {\n        return true;\n    }\n\n}", "super_interfaces": ["Rectangle"], "fields": [{"attribute_expression": "private final double x1, y1, x2, y2;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "double", "name": "x1", "syntax_pass": true}]}, {"uris": "src/main/java/com/github/davidmoten/rtree/geometry/internal/Vector.java.Vector", "name": "Vector", "file_path": "src/main/java/com/github/davidmoten/rtree/geometry/internal/Vector.java", "superclasses": "", "methods": ["[Vector]create(double,double)", "[]Vector(double,double)", "[double]dot(Vector)", "[Vector]times(double)", "[Vector]minus(Vector)", "[double]modulus()", "[double]modulusSquared()"], "method_uris": ["src/main/java/com/github/davidmoten/rtree/geometry/internal/Vector.java.Vector.[Vector]create(double,double)", "src/main/java/com/github/davidmoten/rtree/geometry/internal/Vector.java.Vector.[]Vector(double,double)", "src/main/java/com/github/davidmoten/rtree/geometry/internal/Vector.java.Vector.[double]dot(Vector)", "src/main/java/com/github/davidmoten/rtree/geometry/internal/Vector.java.Vector.[Vector]times(double)", "src/main/java/com/github/davidmoten/rtree/geometry/internal/Vector.java.Vector.[Vector]minus(Vector)", "src/main/java/com/github/davidmoten/rtree/geometry/internal/Vector.java.Vector.[double]modulus()", "src/main/java/com/github/davidmoten/rtree/geometry/internal/Vector.java.Vector.[double]modulusSquared()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "final class Vector {\n\n    final double x;\n    final double y;\n\n    static Vector create(double x, double y) {\n        return new Vector(x, y);\n    }\n\n    Vector(double x, double y) {\n        this.x = x;\n        this.y = y;\n    }\n\n    double dot(Vector v) {\n        return x * v.x + y * v.y;\n    }\n\n    Vector times(double value) {\n        return create(value * x, value * y);\n    }\n\n    Vector minus(Vector v) {\n        return create(x - v.x, y - v.y);\n    }\n\n    double modulus() {\n        return Math.sqrt(modulusSquared());\n    }\n\n    double modulusSquared() {\n        return x * x + y * y;\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "final double x;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "double", "name": "x", "syntax_pass": true}, {"attribute_expression": "final double y;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "double", "name": "y", "syntax_pass": true}]}, {"uris": "src/main/java/com/github/davidmoten/rtree/geometry/internal/GeometryUtil.java.GeometryUtil", "name": "GeometryUtil", "file_path": "src/main/java/com/github/davidmoten/rtree/geometry/internal/GeometryUtil.java", "superclasses": "", "methods": ["[]GeometryUtil()", "[double]distanceSquared(double,double,double,double)", "[double]max(double,double)", "[float]max(float,float)", "[double]min(double,double)", "[float]min(float,float)", "[double]distance(double,double,Rectangle)", "[double]distance(double,double,double,double,double,double)", "[double]distance(double,double,double,double,double,double,double,double)", "[boolean]intersects(double,double,double,double,double,double,double,double)", "[boolean]lineIntersects(double,double,double,double,Circle)"], "method_uris": ["src/main/java/com/github/davidmoten/rtree/geometry/internal/GeometryUtil.java.GeometryUtil.[]GeometryUtil()", "src/main/java/com/github/davidmoten/rtree/geometry/internal/GeometryUtil.java.GeometryUtil.[double]distanceSquared(double,double,double,double)", "src/main/java/com/github/davidmoten/rtree/geometry/internal/GeometryUtil.java.GeometryUtil.[double]max(double,double)", "src/main/java/com/github/davidmoten/rtree/geometry/internal/GeometryUtil.java.GeometryUtil.[float]max(float,float)", "src/main/java/com/github/davidmoten/rtree/geometry/internal/GeometryUtil.java.GeometryUtil.[double]min(double,double)", "src/main/java/com/github/davidmoten/rtree/geometry/internal/GeometryUtil.java.GeometryUtil.[float]min(float,float)", "src/main/java/com/github/davidmoten/rtree/geometry/internal/GeometryUtil.java.GeometryUtil.[double]distance(double,double,Rectangle)", "src/main/java/com/github/davidmoten/rtree/geometry/internal/GeometryUtil.java.GeometryUtil.[double]distance(double,double,double,double,double,double)", "src/main/java/com/github/davidmoten/rtree/geometry/internal/GeometryUtil.java.GeometryUtil.[double]distance(double,double,double,double,double,double,double,double)", "src/main/java/com/github/davidmoten/rtree/geometry/internal/GeometryUtil.java.GeometryUtil.[boolean]intersects(double,double,double,double,double,double,double,double)", "src/main/java/com/github/davidmoten/rtree/geometry/internal/GeometryUtil.java.GeometryUtil.[boolean]lineIntersects(double,double,double,double,Circle)"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public final class GeometryUtil {\n\n    private GeometryUtil() {\n        // prevent instantiation\n    }\n\n    public static double distanceSquared(double x1, double y1, double x2, double y2) {\n        double dx = x2 - x1;\n        double dy = y2 - y1;\n        return dx * dx + dy * dy;\n    }\n\n    public static double max(double a, double b) {\n        if (a < b)\n            return b;\n        else\n            return a;\n    }\n\n    public static float max(float a, float b) {\n        if (a < b)\n            return b;\n        else\n            return a;\n    }\n\n    public static double min(double a, double b) {\n        if (a < b)\n            return a;\n        else\n            return b;\n    }\n\n    public static float min(float a, float b) {\n        if (a < b)\n            return a;\n        else\n            return b;\n    }\n\n    public static double distance(double x, double y, Rectangle r) {\n        return distance(x, y, r.x1(), r.y1(), r.x2(), r.y2());\n    }\n\n    public static double distance(double x, double y, double a1, double b1, double a2, double b2) {\n        return distance(x, y, x, y, a1, b1, a2, b2);\n    }\n\n    public static double distance(double x1, double y1, double x2, double y2, double a1, double b1,\n            double a2, double b2) {\n        if (intersects(x1, y1, x2, y2, a1, b1, a2, b2)) {\n            return 0;\n        }\n        boolean xyMostLeft = x1 < a1;\n        double mostLeftX1 = xyMostLeft ? x1 : a1;\n        double mostRightX1 = xyMostLeft ? a1 : x1;\n        double mostLeftX2 = xyMostLeft ? x2 : a2;\n        double xDifference = max(0, mostLeftX1 == mostRightX1 ? 0 : mostRightX1 - mostLeftX2);\n\n        boolean xyMostDown = y1 < b1;\n        double mostDownY1 = xyMostDown ? y1 : b1;\n        double mostUpY1 = xyMostDown ? b1 : y1;\n        double mostDownY2 = xyMostDown ? y2 : b2;\n\n        double yDifference = max(0, mostDownY1 == mostUpY1 ? 0 : mostUpY1 - mostDownY2);\n\n        return Math.sqrt(xDifference * xDifference + yDifference * yDifference);\n    }\n\n    public static boolean intersects(double x1, double y1, double x2, double y2, double a1,\n            double b1, double a2, double b2) {\n        return x1 <= a2 && a1 <= x2 && y1 <= b2 && b1 <= y2;\n    }\n    \n    public static boolean lineIntersects(double x1, double y1, double x2, double y2, Circle circle) {\n\n        // using Vector Projection\n        // https://en.wikipedia.org/wiki/Vector_projection\n        Vector c = Vector.create(circle.x(), circle.y());\n        Vector a = Vector.create(x1, y1);\n        Vector cMinusA = c.minus(a);\n        double radiusSquared = circle.radius() * circle.radius();\n        if (x1 == x2 && y1 == y2) {\n            return cMinusA.modulusSquared() <= radiusSquared;\n        } else {\n            Vector b = Vector.create(x2, y2);\n            Vector bMinusA = b.minus(a);\n            double bMinusAModulus = bMinusA.modulus();\n            double lambda = cMinusA.dot(bMinusA) / bMinusAModulus;\n            // if projection is on the segment\n            if (lambda >= 0 && lambda <= bMinusAModulus) {\n                Vector dMinusA = bMinusA.times(lambda / bMinusAModulus);\n                // calculate distance to line from c using pythagoras' theorem\n                return cMinusA.modulusSquared() - dMinusA.modulusSquared() <= radiusSquared;\n            } else {\n                // return true if and only if an endpoint is within radius of\n                // centre\n                return cMinusA.modulusSquared() <= radiusSquared\n                        || c.minus(b).modulusSquared() <= radiusSquared;\n            }\n        }\n\n    }\n\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/main/java/com/github/davidmoten/rtree/geometry/internal/CircleFloat.java.CircleFloat", "name": "CircleFloat", "file_path": "src/main/java/com/github/davidmoten/rtree/geometry/internal/CircleFloat.java", "superclasses": "", "methods": ["[]CircleFloat(float,float,float)", "[CircleFloat]create(float,float,float)", "[double]x()", "[double]y()", "[double]radius()", "[Rectangle]mbr()", "[double]distance(Rectangle)", "[boolean]intersects(Rectangle)", "[boolean]intersects(Circle)", "[int]hashCode()", "[boolean]equals(Object)", "[boolean]intersects(Point)", "[double]sqr(double)", "[boolean]intersects(Line)", "[boolean]isDoublePrecision()"], "method_uris": ["src/main/java/com/github/davidmoten/rtree/geometry/internal/CircleFloat.java.CircleFloat.[]CircleFloat(float,float,float)", "src/main/java/com/github/davidmoten/rtree/geometry/internal/CircleFloat.java.CircleFloat.[CircleFloat]create(float,float,float)", "src/main/java/com/github/davidmoten/rtree/geometry/internal/CircleFloat.java.CircleFloat.[double]x()", "src/main/java/com/github/davidmoten/rtree/geometry/internal/CircleFloat.java.CircleFloat.[double]y()", "src/main/java/com/github/davidmoten/rtree/geometry/internal/CircleFloat.java.CircleFloat.[double]radius()", "src/main/java/com/github/davidmoten/rtree/geometry/internal/CircleFloat.java.CircleFloat.[Rectangle]mbr()", "src/main/java/com/github/davidmoten/rtree/geometry/internal/CircleFloat.java.CircleFloat.[double]distance(Rectangle)", "src/main/java/com/github/davidmoten/rtree/geometry/internal/CircleFloat.java.CircleFloat.[boolean]intersects(Rectangle)", "src/main/java/com/github/davidmoten/rtree/geometry/internal/CircleFloat.java.CircleFloat.[boolean]intersects(Circle)", "src/main/java/com/github/davidmoten/rtree/geometry/internal/CircleFloat.java.CircleFloat.[int]hashCode()", "src/main/java/com/github/davidmoten/rtree/geometry/internal/CircleFloat.java.CircleFloat.[boolean]equals(Object)", "src/main/java/com/github/davidmoten/rtree/geometry/internal/CircleFloat.java.CircleFloat.[boolean]intersects(Point)", "src/main/java/com/github/davidmoten/rtree/geometry/internal/CircleFloat.java.CircleFloat.[double]sqr(double)", "src/main/java/com/github/davidmoten/rtree/geometry/internal/CircleFloat.java.CircleFloat.[boolean]intersects(Line)", "src/main/java/com/github/davidmoten/rtree/geometry/internal/CircleFloat.java.CircleFloat.[boolean]isDoublePrecision()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public final class CircleFloat implements Circle {\n\n    private final float x, y, radius;\n    private final Rectangle mbr;\n\n    private CircleFloat(float x, float y, float radius) {\n        this.x = x;\n        this.y = y;\n        this.radius = radius;\n        this.mbr = RectangleFloat.create(x - radius, y - radius, x + radius, y + radius);\n    }\n\n    public static CircleFloat create(float x, float y, float radius) {\n        return new CircleFloat(x, y, radius);\n    }\n\n    @Override\n    public double x() {\n        return x;\n    }\n\n    @Override\n    public double y() {\n        return y;\n    }\n\n    @Override\n    public double radius() {\n        return radius;\n    }\n\n    @Override\n    public Rectangle mbr() {\n        return mbr;\n    }\n\n    @Override\n    public double distance(Rectangle r) {\n        return Math.max(0, GeometryUtil.distance(x, y, r) - radius);\n    }\n\n    @Override\n    public boolean intersects(Rectangle r) {\n        return distance(r) == 0;\n    }\n\n    @Override\n    public boolean intersects(Circle c) {\n        double total = radius + c.radius();\n        return GeometryUtil.distanceSquared(x, y, c.x(), c.y()) <= total * total;\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(x, y, radius);\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        Optional<CircleFloat> other = ObjectsHelper.asClass(obj, CircleFloat.class);\n        if (other.isPresent()) {\n            return Objects.equals(x, other.get().x) && Objects.equals(y, other.get().y)\n                    && Objects.equals(radius, other.get().radius);\n        } else\n            return false;\n    }\n\n    @Override\n    public boolean intersects(Point point) {\n        return Math.sqrt(sqr(x - point.x()) + sqr(y - point.y())) <= radius;\n    }\n\n    private double sqr(double x) {\n        return x * x;\n    }\n\n    @Override\n    public boolean intersects(Line line) {\n        return line.intersects(this);\n    }\n\n    @Override\n    public boolean isDoublePrecision() {\n        return false;\n    }\n}", "super_interfaces": ["Circle"], "fields": [{"attribute_expression": "private final float x, y, radius;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "float", "name": "x", "syntax_pass": true}, {"attribute_expression": "private final Rectangle mbr;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Rectangle", "name": "mbr", "syntax_pass": true}]}, {"uris": "src/main/java/com/github/davidmoten/rtree/geometry/internal/RectangleFloat.java.RectangleFloat", "name": "RectangleFloat", "file_path": "src/main/java/com/github/davidmoten/rtree/geometry/internal/RectangleFloat.java", "superclasses": "", "methods": ["[]RectangleFloat(float,float,float,float)", "[Rectangle]create(float,float,float,float)", "[double]x1()", "[double]y1()", "[double]x2()", "[double]y2()", "[double]area()", "[Rectangle]add(Rectangle)", "[boolean]contains(double,double)", "[boolean]intersects(Rectangle)", "[double]distance(Rectangle)", "[Rectangle]mbr()", "[int]hashCode()", "[boolean]equals(Object)", "[double]intersectionArea(Rectangle)", "[double]perimeter()", "[Geometry]geometry()", "[boolean]isDoublePrecision()", "[String]toString()"], "method_uris": ["src/main/java/com/github/davidmoten/rtree/geometry/internal/RectangleFloat.java.RectangleFloat.[]RectangleFloat(float,float,float,float)", "src/main/java/com/github/davidmoten/rtree/geometry/internal/RectangleFloat.java.RectangleFloat.[Rectangle]create(float,float,float,float)", "src/main/java/com/github/davidmoten/rtree/geometry/internal/RectangleFloat.java.RectangleFloat.[double]x1()", "src/main/java/com/github/davidmoten/rtree/geometry/internal/RectangleFloat.java.RectangleFloat.[double]y1()", "src/main/java/com/github/davidmoten/rtree/geometry/internal/RectangleFloat.java.RectangleFloat.[double]x2()", "src/main/java/com/github/davidmoten/rtree/geometry/internal/RectangleFloat.java.RectangleFloat.[double]y2()", "src/main/java/com/github/davidmoten/rtree/geometry/internal/RectangleFloat.java.RectangleFloat.[double]area()", "src/main/java/com/github/davidmoten/rtree/geometry/internal/RectangleFloat.java.RectangleFloat.[Rectangle]add(Rectangle)", "src/main/java/com/github/davidmoten/rtree/geometry/internal/RectangleFloat.java.RectangleFloat.[boolean]contains(double,double)", "src/main/java/com/github/davidmoten/rtree/geometry/internal/RectangleFloat.java.RectangleFloat.[boolean]intersects(Rectangle)", "src/main/java/com/github/davidmoten/rtree/geometry/internal/RectangleFloat.java.RectangleFloat.[double]distance(Rectangle)", "src/main/java/com/github/davidmoten/rtree/geometry/internal/RectangleFloat.java.RectangleFloat.[Rectangle]mbr()", "src/main/java/com/github/davidmoten/rtree/geometry/internal/RectangleFloat.java.RectangleFloat.[int]hashCode()", "src/main/java/com/github/davidmoten/rtree/geometry/internal/RectangleFloat.java.RectangleFloat.[boolean]equals(Object)", "src/main/java/com/github/davidmoten/rtree/geometry/internal/RectangleFloat.java.RectangleFloat.[double]intersectionArea(Rectangle)", "src/main/java/com/github/davidmoten/rtree/geometry/internal/RectangleFloat.java.RectangleFloat.[double]perimeter()", "src/main/java/com/github/davidmoten/rtree/geometry/internal/RectangleFloat.java.RectangleFloat.[Geometry]geometry()", "src/main/java/com/github/davidmoten/rtree/geometry/internal/RectangleFloat.java.RectangleFloat.[boolean]isDoublePrecision()", "src/main/java/com/github/davidmoten/rtree/geometry/internal/RectangleFloat.java.RectangleFloat.[String]toString()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public final class RectangleFloat implements Rectangle {\n    public final float x1, y1, x2, y2;\n\n    private RectangleFloat(float x1, float y1, float x2, float y2) {\n        Preconditions.checkArgument(x2 >= x1);\n        Preconditions.checkArgument(y2 >= y1);\n        this.x1 = x1;\n        this.y1 = y1;\n        this.x2 = x2;\n        this.y2 = y2;\n    }\n\n    public static Rectangle create(float x1, float y1, float x2, float y2) {\n        return new RectangleFloat(x1, y1, x2, y2);\n    }\n\n    @Override\n    public double x1() {\n        return x1;\n    }\n\n    @Override\n    public double y1() {\n        return y1;\n    }\n\n    @Override\n    public double x2() {\n        return x2;\n    }\n\n    @Override\n    public double y2() {\n        return y2;\n    }\n\n    @Override\n    public double area() {\n        return (x2 - x1) * (y2 - y1);\n    }\n\n    @Override\n    public Rectangle add(Rectangle r) {\n        if (r.isDoublePrecision()) {\n            return RectangleDouble.create(min(x1, r.x1()), min(y1, r.y1()), max(x2, r.x2()),\n                    max(y2, r.y2()));\n        } else if (r instanceof RectangleFloat) {\n            RectangleFloat rf = (RectangleFloat) r;\n            return RectangleFloat.create(min(x1, rf.x1), min(y1, rf.y1), max(x2, rf.x2),\n                    max(y2, rf.y2));\n        } else {\n            PointFloat rf = (PointFloat) r;\n            return RectangleFloat.create(min(x1, rf.xFloat()), min(y1, rf.yFloat()),\n                    max(x2, rf.xFloat()), max(y2, rf.yFloat()));\n        }\n    }\n\n    @Override\n    public boolean contains(double x, double y) {\n        return x >= x1 && x <= x2 && y >= y1 && y <= y2;\n    }\n\n    @Override\n    public boolean intersects(Rectangle r) {\n        return GeometryUtil.intersects(x1, y1, x2, y2, r.x1(), r.y1(), r.x2(), r.y2());\n    }\n\n    @Override\n    public double distance(Rectangle r) {\n        return GeometryUtil.distance(x1, y1, x2, y2, r.x1(), r.y1(), r.x2(), r.y2());\n    }\n\n    @Override\n    public Rectangle mbr() {\n        return this;\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(x1, y1, x2, y2);\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        Optional<RectangleFloat> other = ObjectsHelper.asClass(obj, RectangleFloat.class);\n        if (other.isPresent()) {\n            return Objects.equals(x1, other.get().x1) && Objects.equals(x2, other.get().x2)\n                    && Objects.equals(y1, other.get().y1) && Objects.equals(y2, other.get().y2);\n        } else\n            return false;\n    }\n\n    @Override\n    public double intersectionArea(Rectangle r) {\n        if (!intersects(r))\n            return 0;\n        else\n            return RectangleDouble\n                    .create(max(x1, r.x1()), max(y1, r.y1()), min(x2, r.x2()), min(y2, r.y2()))\n                    .area();\n    }\n\n    @Override\n    public double perimeter() {\n        return 2 * (x2 - x1) + 2 * (y2 - y1);\n    }\n\n    @Override\n    public Geometry geometry() {\n        return this;\n    }\n\n    @Override\n    public boolean isDoublePrecision() {\n        return false;\n    }\n\n    @Override\n    public String toString() {\n        return \"Rectangle [x1=\" + x1 + \", y1=\" + y1 + \", x2=\" + x2 + \", y2=\" + y2 + \"]\";\n    }\n\n}", "super_interfaces": ["Rectangle"], "fields": [{"attribute_expression": "public final float x1, y1, x2, y2;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "float", "name": "x1", "syntax_pass": true}]}, {"uris": "src/main/java/com/github/davidmoten/rtree/geometry/internal/CircleDouble.java.CircleDouble", "name": "CircleDouble", "file_path": "src/main/java/com/github/davidmoten/rtree/geometry/internal/CircleDouble.java", "superclasses": "", "methods": ["[]CircleDouble(double,double,double)", "[CircleDouble]create(double,double,double)", "[double]x()", "[double]y()", "[double]radius()", "[Rectangle]mbr()", "[double]distance(Rectangle)", "[boolean]intersects(Rectangle)", "[boolean]intersects(Circle)", "[int]hashCode()", "[boolean]equals(Object)", "[boolean]intersects(Point)", "[double]sqr(double)", "[boolean]intersects(Line)", "[boolean]isDoublePrecision()"], "method_uris": ["src/main/java/com/github/davidmoten/rtree/geometry/internal/CircleDouble.java.CircleDouble.[]CircleDouble(double,double,double)", "src/main/java/com/github/davidmoten/rtree/geometry/internal/CircleDouble.java.CircleDouble.[CircleDouble]create(double,double,double)", "src/main/java/com/github/davidmoten/rtree/geometry/internal/CircleDouble.java.CircleDouble.[double]x()", "src/main/java/com/github/davidmoten/rtree/geometry/internal/CircleDouble.java.CircleDouble.[double]y()", "src/main/java/com/github/davidmoten/rtree/geometry/internal/CircleDouble.java.CircleDouble.[double]radius()", "src/main/java/com/github/davidmoten/rtree/geometry/internal/CircleDouble.java.CircleDouble.[Rectangle]mbr()", "src/main/java/com/github/davidmoten/rtree/geometry/internal/CircleDouble.java.CircleDouble.[double]distance(Rectangle)", "src/main/java/com/github/davidmoten/rtree/geometry/internal/CircleDouble.java.CircleDouble.[boolean]intersects(Rectangle)", "src/main/java/com/github/davidmoten/rtree/geometry/internal/CircleDouble.java.CircleDouble.[boolean]intersects(Circle)", "src/main/java/com/github/davidmoten/rtree/geometry/internal/CircleDouble.java.CircleDouble.[int]hashCode()", "src/main/java/com/github/davidmoten/rtree/geometry/internal/CircleDouble.java.CircleDouble.[boolean]equals(Object)", "src/main/java/com/github/davidmoten/rtree/geometry/internal/CircleDouble.java.CircleDouble.[boolean]intersects(Point)", "src/main/java/com/github/davidmoten/rtree/geometry/internal/CircleDouble.java.CircleDouble.[double]sqr(double)", "src/main/java/com/github/davidmoten/rtree/geometry/internal/CircleDouble.java.CircleDouble.[boolean]intersects(Line)", "src/main/java/com/github/davidmoten/rtree/geometry/internal/CircleDouble.java.CircleDouble.[boolean]isDoublePrecision()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public final class CircleDouble implements Circle {\n\n    private final double x, y, radius;\n    private final Rectangle mbr;\n\n    private CircleDouble(double x, double y, double radius) {\n        this.x = x;\n        this.y = y;\n        this.radius = radius;\n        this.mbr = RectangleDouble.create(x - radius, y - radius, x + radius, y + radius);\n    }\n\n    public static CircleDouble create(double x, double y, double radius) {\n        return new CircleDouble(x, y, radius);\n    }\n\n    @Override\n    public double x() {\n        return x;\n    }\n\n    @Override\n    public double y() {\n        return y;\n    }\n\n    @Override\n    public double radius() {\n        return radius;\n    }\n\n    @Override\n    public Rectangle mbr() {\n        return mbr;\n    }\n\n    @Override\n    public double distance(Rectangle r) {\n        return Math.max(0, GeometryUtil.distance(x, y, r) - radius);\n    }\n\n    @Override\n    public boolean intersects(Rectangle r) {\n        return distance(r) == 0;\n    }\n\n    @Override\n    public boolean intersects(Circle c) {\n        double total = radius + c.radius();\n        return GeometryUtil.distanceSquared(x, y, c.x(), c.y()) <= total * total;\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(x, y, radius);\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        Optional<CircleDouble> other = ObjectsHelper.asClass(obj, CircleDouble.class);\n        if (other.isPresent()) {\n            return Objects.equals(x, other.get().x) && Objects.equals(y, other.get().y)\n                    && Objects.equals(radius, other.get().radius);\n        } else\n            return false;\n    }\n\n    @Override\n    public boolean intersects(Point point) {\n        return Math.sqrt(sqr(x - point.x()) + sqr(y - point.y())) <= radius;\n    }\n\n    private double sqr(double x) {\n        return x * x;\n    }\n\n    @Override\n    public boolean intersects(Line line) {\n        return line.intersects(this);\n    }\n\n    @Override\n    public boolean isDoublePrecision() {\n        return true;\n    }\n}", "super_interfaces": ["Circle"], "fields": [{"attribute_expression": "private final double x, y, radius;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "double", "name": "x", "syntax_pass": true}, {"attribute_expression": "private final Rectangle mbr;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Rectangle", "name": "mbr", "syntax_pass": true}]}, {"uris": "src/main/java/com/github/davidmoten/rtree/geometry/internal/LineDouble.java.LineDouble", "name": "LineDouble", "file_path": "src/main/java/com/github/davidmoten/rtree/geometry/internal/LineDouble.java", "superclasses": "", "methods": ["[]LineDouble(double,double,double,double)", "[LineDouble]create(double,double,double,double)", "[double]distance(Rectangle)", "[double]distance(double,double,double,double)", "[Rectangle]mbr()", "[boolean]intersects(Rectangle)", "[double]x1()", "[double]y1()", "[double]x2()", "[double]y2()", "[boolean]intersects(Line)", "[boolean]intersects(Point)", "[boolean]intersects(Circle)", "[int]hashCode()", "[boolean]equals(Object)", "[boolean]isDoublePrecision()"], "method_uris": ["src/main/java/com/github/davidmoten/rtree/geometry/internal/LineDouble.java.LineDouble.[]LineDouble(double,double,double,double)", "src/main/java/com/github/davidmoten/rtree/geometry/internal/LineDouble.java.LineDouble.[LineDouble]create(double,double,double,double)", "src/main/java/com/github/davidmoten/rtree/geometry/internal/LineDouble.java.LineDouble.[double]distance(Rectangle)", "src/main/java/com/github/davidmoten/rtree/geometry/internal/LineDouble.java.LineDouble.[double]distance(double,double,double,double)", "src/main/java/com/github/davidmoten/rtree/geometry/internal/LineDouble.java.LineDouble.[Rectangle]mbr()", "src/main/java/com/github/davidmoten/rtree/geometry/internal/LineDouble.java.LineDouble.[boolean]intersects(Rectangle)", "src/main/java/com/github/davidmoten/rtree/geometry/internal/LineDouble.java.LineDouble.[double]x1()", "src/main/java/com/github/davidmoten/rtree/geometry/internal/LineDouble.java.LineDouble.[double]y1()", "src/main/java/com/github/davidmoten/rtree/geometry/internal/LineDouble.java.LineDouble.[double]x2()", "src/main/java/com/github/davidmoten/rtree/geometry/internal/LineDouble.java.LineDouble.[double]y2()", "src/main/java/com/github/davidmoten/rtree/geometry/internal/LineDouble.java.LineDouble.[boolean]intersects(Line)", "src/main/java/com/github/davidmoten/rtree/geometry/internal/LineDouble.java.LineDouble.[boolean]intersects(Point)", "src/main/java/com/github/davidmoten/rtree/geometry/internal/LineDouble.java.LineDouble.[boolean]intersects(Circle)", "src/main/java/com/github/davidmoten/rtree/geometry/internal/LineDouble.java.LineDouble.[int]hashCode()", "src/main/java/com/github/davidmoten/rtree/geometry/internal/LineDouble.java.LineDouble.[boolean]equals(Object)", "src/main/java/com/github/davidmoten/rtree/geometry/internal/LineDouble.java.LineDouble.[boolean]isDoublePrecision()"], "overrides": null, "attributes": [], "class_docstring": "\nA line segment.\n", "original_string": "public final class LineDouble implements Line {\n\n    private final double x1;\n    private final double y1;\n    private final double x2;\n    private final double y2;\n\n    private LineDouble(double x1, double y1, double x2, double y2) {\n        this.x1 = x1;\n        this.y1 = y1;\n        this.x2 = x2;\n        this.y2 = y2;\n    }\n\n    public static LineDouble create(double x1, double y1, double x2, double y2) {\n        return new LineDouble(x1, y1, x2, y2);\n    }\n\n    @Override\n    public double distance(Rectangle r) {\n        if (r.contains(x1, y1) || r.contains(x2, y2)) {\n            return 0;\n        } else {\n            double d1 = distance(r.x1(), r.y1(), r.x1(), r.y2());\n            if (d1 == 0)\n                return 0;\n            double d2 = distance(r.x1(), r.y2(), r.x2(), r.y2());\n            if (d2 == 0)\n                return 0;\n            double d3 = distance(r.x2(), r.y2(), r.x2(), r.y1());\n            double d4 = distance(r.x2(), r.y1(), r.x1(), r.y1());\n            return Math.min(d1, Math.min(d2, Math.min(d3, d4)));\n        }\n    }\n\n    private double distance(double x1, double y1, double x2, double y2) {\n        Line2D line = new Line2D(x1, y1, x2, y2);\n        double d1 = line.ptSegDist(this.x1, this.y1);\n        double d2 = line.ptSegDist(this.x2, this.y2);\n        Line2D line2 = new Line2D(this.x1, this.y1, this.x2, this.y2);\n        double d3 = line2.ptSegDist(x1, y1);\n        if (d3 == 0)\n            return 0;\n        double d4 = line2.ptSegDist(x2, y2);\n        if (d4 == 0)\n            return 0;\n        else\n            return Math.min(d1, Math.min(d2, Math.min(d3, d4)));\n\n    }\n\n    @Override\n    public Rectangle mbr() {\n        return Geometries.rectangle(Math.min(x1, x2), Math.min(y1, y2), Math.max(x1, x2),\n                Math.max(y1, y2));\n    }\n\n    @Override\n    public boolean intersects(Rectangle r) {\n        return RectangleUtil.rectangleIntersectsLine(r.x1(), r.y1(), r.x2() - r.x1(),\n                r.y2() - r.y1(), x1, y1, x2, y2);\n    }\n\n    @Override\n    public double x1() {\n        return x1;\n    }\n\n    @Override\n    public double y1() {\n        return y1;\n    }\n\n    @Override\n    public double x2() {\n        return x2;\n    }\n\n    @Override\n    public double y2() {\n        return y2;\n    }\n\n    @Override\n    public boolean intersects(Line b) {\n        Line2D line1 = new Line2D(x1, y1, x2, y2);\n        Line2D line2 = new Line2D(b.x1(), b.y1(), b.x2(), b.y2());\n        return line2.intersectsLine(line1);\n    }\n\n    @Override\n    public boolean intersects(Point point) {\n        return intersects(point.mbr());\n    }\n\n    @Override\n    public boolean intersects(Circle circle) {\n        return GeometryUtil.lineIntersects(x1, y1, x2, y2, circle);\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(x1, y1, x2, y2);\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        Optional<LineDouble> other = ObjectsHelper.asClass(obj, LineDouble.class);\n        if (other.isPresent()) {\n            return Objects.equals(x1, other.get().x1) && Objects.equals(x2, other.get().x2)\n                    && Objects.equals(y1, other.get().y1) && Objects.equals(y2, other.get().y2);\n        } else\n            return false;\n    }\n\n    @Override\n    public boolean isDoublePrecision() {\n        return true;\n    }\n\n}", "super_interfaces": ["Line"], "fields": [{"attribute_expression": "private final double x1;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "double", "name": "x1", "syntax_pass": true}, {"attribute_expression": "private final double y1;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "double", "name": "y1", "syntax_pass": true}, {"attribute_expression": "private final double x2;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "double", "name": "x2", "syntax_pass": true}, {"attribute_expression": "private final double y2;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "double", "name": "y2", "syntax_pass": true}]}, {"uris": "src/main/java/com/github/davidmoten/rtree/geometry/internal/PointDouble.java.PointDouble", "name": "PointDouble", "file_path": "src/main/java/com/github/davidmoten/rtree/geometry/internal/PointDouble.java", "superclasses": "", "methods": ["[]PointDouble(double,double)", "[PointDouble]create(double,double)", "[Rectangle]mbr()", "[double]distance(Rectangle)", "[boolean]intersects(Rectangle)", "[double]x()", "[double]y()", "[String]toString()", "[Geometry]geometry()", "[double]x1()", "[double]y1()", "[double]x2()", "[double]y2()", "[double]area()", "[Rectangle]add(Rectangle)", "[boolean]contains(double,double)", "[double]intersectionArea(Rectangle)", "[double]perimeter()", "[boolean]isDoublePrecision()", "[int]hashCode()", "[boolean]equals(Object)"], "method_uris": ["src/main/java/com/github/davidmoten/rtree/geometry/internal/PointDouble.java.PointDouble.[]PointDouble(double,double)", "src/main/java/com/github/davidmoten/rtree/geometry/internal/PointDouble.java.PointDouble.[PointDouble]create(double,double)", "src/main/java/com/github/davidmoten/rtree/geometry/internal/PointDouble.java.PointDouble.[Rectangle]mbr()", "src/main/java/com/github/davidmoten/rtree/geometry/internal/PointDouble.java.PointDouble.[double]distance(Rectangle)", "src/main/java/com/github/davidmoten/rtree/geometry/internal/PointDouble.java.PointDouble.[boolean]intersects(Rectangle)", "src/main/java/com/github/davidmoten/rtree/geometry/internal/PointDouble.java.PointDouble.[double]x()", "src/main/java/com/github/davidmoten/rtree/geometry/internal/PointDouble.java.PointDouble.[double]y()", "src/main/java/com/github/davidmoten/rtree/geometry/internal/PointDouble.java.PointDouble.[String]toString()", "src/main/java/com/github/davidmoten/rtree/geometry/internal/PointDouble.java.PointDouble.[Geometry]geometry()", "src/main/java/com/github/davidmoten/rtree/geometry/internal/PointDouble.java.PointDouble.[double]x1()", "src/main/java/com/github/davidmoten/rtree/geometry/internal/PointDouble.java.PointDouble.[double]y1()", "src/main/java/com/github/davidmoten/rtree/geometry/internal/PointDouble.java.PointDouble.[double]x2()", "src/main/java/com/github/davidmoten/rtree/geometry/internal/PointDouble.java.PointDouble.[double]y2()", "src/main/java/com/github/davidmoten/rtree/geometry/internal/PointDouble.java.PointDouble.[double]area()", "src/main/java/com/github/davidmoten/rtree/geometry/internal/PointDouble.java.PointDouble.[Rectangle]add(Rectangle)", "src/main/java/com/github/davidmoten/rtree/geometry/internal/PointDouble.java.PointDouble.[boolean]contains(double,double)", "src/main/java/com/github/davidmoten/rtree/geometry/internal/PointDouble.java.PointDouble.[double]intersectionArea(Rectangle)", "src/main/java/com/github/davidmoten/rtree/geometry/internal/PointDouble.java.PointDouble.[double]perimeter()", "src/main/java/com/github/davidmoten/rtree/geometry/internal/PointDouble.java.PointDouble.[boolean]isDoublePrecision()", "src/main/java/com/github/davidmoten/rtree/geometry/internal/PointDouble.java.PointDouble.[int]hashCode()", "src/main/java/com/github/davidmoten/rtree/geometry/internal/PointDouble.java.PointDouble.[boolean]equals(Object)"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public final class PointDouble implements Point {\n\n    private final double x;\n    private final double y;\n\n    private PointDouble(double x, double y) {\n        this.x = x;\n        this.y = y;\n    }\n\n    public static PointDouble create(double x, double y) {\n        return new PointDouble(x, y);\n    }\n\n    @Override\n    public Rectangle mbr() {\n        return this;\n    }\n\n    @Override\n    public double distance(Rectangle r) {\n        return GeometryUtil.distance(x, y, r);\n    }\n\n    @Override\n    public boolean intersects(Rectangle r) {\n        return r.x1() <= x && x <= r.x2() && r.y1() <= y && y <= r.y2();\n    }\n\n    @Override\n    public double x() {\n        return x;\n    }\n\n    @Override\n    public double y() {\n        return y;\n    }\n\n    @Override\n    public String toString() {\n        return \"Point [x=\" + x() + \", y=\" + y() + \"]\";\n    }\n\n    @Override\n    public Geometry geometry() {\n        return this;\n    }\n\n    @Override\n    public double x1() {\n        return x;\n    }\n\n    @Override\n    public double y1() {\n        return y;\n    }\n\n    @Override\n    public double x2() {\n        return x;\n    }\n\n    @Override\n    public double y2() {\n        return y;\n    }\n\n    @Override\n    public double area() {\n        return 0;\n    }\n\n    @Override\n    public Rectangle add(Rectangle r) {\n        return Geometries.rectangle(Math.min(x, r.x1()), Math.min(y, r.y1()), Math.max(x, r.x2()),\n                Math.max(y, r.y2()));\n    }\n\n    @Override\n    public boolean contains(double x, double y) {\n        return this.x == x && this.y == y;\n    }\n\n    @Override\n    public double intersectionArea(Rectangle r) {\n        return 0;\n    }\n\n    @Override\n    public double perimeter() {\n        return 0;\n    }\n\n    @Override\n    public boolean isDoublePrecision() {\n        return true;\n    }\n\n    @Override\n    public int hashCode() {\n        final int prime = 31;\n        int result = 1;\n        long temp;\n        temp = Double.doubleToLongBits(x);\n        result = prime * result + (int) (temp ^ (temp >>> 32));\n        temp = Double.doubleToLongBits(y);\n        result = prime * result + (int) (temp ^ (temp >>> 32));\n        return result;\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        if (this == obj)\n            return true;\n        if (obj == null)\n            return false;\n        if (getClass() != obj.getClass())\n            return false;\n        PointDouble other = (PointDouble) obj;\n        if (Double.doubleToLongBits(x) != Double.doubleToLongBits(other.x))\n            return false;\n        if (Double.doubleToLongBits(y) != Double.doubleToLongBits(other.y))\n            return false;\n        return true;\n    }\n\n}", "super_interfaces": ["Point"], "fields": [{"attribute_expression": "private final double x;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "double", "name": "x", "syntax_pass": true}, {"attribute_expression": "private final double y;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "double", "name": "y", "syntax_pass": true}]}, {"uris": "src/main/java/com/github/davidmoten/rtree/internal/FactoryDefault.java.FactoryDefault", "name": "FactoryDefault", "file_path": "src/main/java/com/github/davidmoten/rtree/internal/FactoryDefault.java", "superclasses": "", "methods": ["[Factory<T, S>]instance()", "[Leaf<T, S>]createLeaf(List<Entry<T, S>>,Context<T, S>)", "[NonLeaf<T, S>]createNonLeaf(List<? extends Node<T, S>>,Context<T, S>)", "[Entry<T, S>]createEntry(T,S)"], "method_uris": ["src/main/java/com/github/davidmoten/rtree/internal/FactoryDefault.java.FactoryDefault.[Factory<T, S>]instance()", "src/main/java/com/github/davidmoten/rtree/internal/FactoryDefault.java.FactoryDefault.[Leaf<T, S>]createLeaf(List<Entry<T, S>>,Context<T, S>)", "src/main/java/com/github/davidmoten/rtree/internal/FactoryDefault.java.FactoryDefault.[NonLeaf<T, S>]createNonLeaf(List<? extends Node<T, S>>,Context<T, S>)", "src/main/java/com/github/davidmoten/rtree/internal/FactoryDefault.java.FactoryDefault.[Entry<T, S>]createEntry(T,S)"], "overrides": null, "attributes": [{"original_string": "    private static class Holder {\n        private static final Factory<Object, Geometry> INSTANCE = new FactoryDefault<>();\n    }", "definition": "    private static class Holder", "class_docstring": "", "name": "Holder", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "fields": [{"attribute_expression": "private static final Factory<Object, Geometry> INSTANCE = new FactoryDefault<>();", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Factory<Object, Geometry>", "name": "INSTANCE = new FactoryDefault<>()", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": []}], "class_docstring": "", "original_string": "public final class FactoryDefault<T, S extends Geometry> implements Factory<T, S> {\n\n    private static class Holder {\n        private static final Factory<Object, Geometry> INSTANCE = new FactoryDefault<>();\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    public static <T, S extends Geometry> Factory<T, S> instance() {\n        return (Factory<T, S>) Holder.INSTANCE;\n    }\n\n    @Override\n    public Leaf<T, S> createLeaf(List<Entry<T, S>> entries, Context<T, S> context) {\n        return new LeafDefault<>(entries, context);\n    }\n\n    @Override\n    public NonLeaf<T, S> createNonLeaf(List<? extends Node<T, S>> children, Context<T, S> context) {\n        return new NonLeafDefault<>(children, context);\n    }\n\n    @Override\n    public Entry<T, S> createEntry(T value, S geometry) {\n        return Entries.entry(value, geometry);\n    }\n\n}", "super_interfaces": ["Factory<T, S>"], "fields": []}, {"uris": "src/main/java/com/github/davidmoten/rtree/internal/Util.java.Util", "name": "Util", "file_path": "src/main/java/com/github/davidmoten/rtree/internal/Util.java", "superclasses": "", "methods": ["[]Util()", "[Rectangle]mbr(Collection<? extends HasGeometry>)", "[List<T>]add(List<T>,T)", "[List<T>]remove(List<? extends T>,List<? extends T>)", "[List<? extends T>]replace(List<? extends T>,T,List<T>)"], "method_uris": ["src/main/java/com/github/davidmoten/rtree/internal/Util.java.Util.[]Util()", "src/main/java/com/github/davidmoten/rtree/internal/Util.java.Util.[Rectangle]mbr(Collection<? extends HasGeometry>)", "src/main/java/com/github/davidmoten/rtree/internal/Util.java.Util.[List<T>]add(List<T>,T)", "src/main/java/com/github/davidmoten/rtree/internal/Util.java.Util.[List<T>]remove(List<? extends T>,List<? extends T>)", "src/main/java/com/github/davidmoten/rtree/internal/Util.java.Util.[List<? extends T>]replace(List<? extends T>,T,List<T>)"], "overrides": null, "attributes": [], "class_docstring": "\n@author dxm\n\n", "original_string": "public final class Util {\n\n    private Util() {\n        // prevent instantiation\n    }\n\n    /**\n     * Returns the minimum bounding rectangle of a number of items. Benchmarks below\n     * indicate that when the number of items is &gt;1 this method is more\n     * performant than one using {@link Rectangle#add(Rectangle)}.\n     * \n     * <pre>\n     * Benchmark                             Mode  Samples         Score  Score error  Units\n     * c.g.d.r.BenchmarksMbr.mbrList1       thrpt       10  48450492.301   436127.960  ops/s\n     * c.g.d.r.BenchmarksMbr.mbrList2       thrpt       10  46658242.728   987901.581  ops/s\n     * c.g.d.r.BenchmarksMbr.mbrList3       thrpt       10  40357809.306   937827.660  ops/s\n     * c.g.d.r.BenchmarksMbr.mbrList4       thrpt       10  35930532.557   605535.237  ops/s\n     * c.g.d.r.BenchmarksMbr.mbrOldList1    thrpt       10  55848118.198  1342997.309  ops/s\n     * c.g.d.r.BenchmarksMbr.mbrOldList2    thrpt       10  25171873.903   395127.918  ops/s\n     * c.g.d.r.BenchmarksMbr.mbrOldList3    thrpt       10  19222116.139   246965.178  ops/s\n     * c.g.d.r.BenchmarksMbr.mbrOldList4    thrpt       10  14891862.638   198765.157  ops/s\n     * </pre>\n     * \n     * @param items\n     *            items to bound\n     * @return the minimum bounding rectangle containings items\n     */\n    public static Rectangle mbr(Collection<? extends HasGeometry> items) {\n        Preconditions.checkArgument(!items.isEmpty());\n        double minX1 = Double.MAX_VALUE;\n        double minY1 = Double.MAX_VALUE;\n        double maxX2 = -Double.MAX_VALUE;\n        double maxY2 = -Double.MAX_VALUE;\n        boolean isDoublePrecision = false;\n        for (final HasGeometry item : items) {\n            Rectangle r = item.geometry().mbr();\n            if (r.isDoublePrecision()) {\n                isDoublePrecision = true;\n            }\n            if (r.x1() < minX1)\n                minX1 = r.x1();\n            if (r.y1() < minY1)\n                minY1 = r.y1();\n            if (r.x2() > maxX2)\n                maxX2 = r.x2();\n            if (r.y2() > maxY2)\n                maxY2 = r.y2();\n        }\n        if (isDoublePrecision) {\n            return Geometries.rectangle(minX1, minY1, maxX2, maxY2);\n        } else {\n            return Geometries.rectangle((float) minX1, (float) minY1, (float) maxX2, (float) maxY2);\n        }\n    }\n\n    public static <T> List<T> add(List<T> list, T element) {\n        final ArrayList<T> result = new ArrayList<T>(list.size() + 2);\n        result.addAll(list);\n        result.add(element);\n        return result;\n    }\n\n    public static <T> List<T> remove(List<? extends T> list, List<? extends T> elements) {\n        final ArrayList<T> result = new ArrayList<T>(list);\n        result.removeAll(elements);\n        return result;\n    }\n\n    public static <T> List<? extends T> replace(List<? extends T> list, T element,\n            List<T> replacements) {\n        List<T> list2 = new ArrayList<T>(list.size() + replacements.size());\n        for (T node : list)\n            if (node != element)\n                list2.add(node);\n        list2.addAll(replacements);\n        return list2;\n    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/main/java/com/github/davidmoten/rtree/internal/Functions.java.Functions", "name": "Functions", "file_path": "src/main/java/com/github/davidmoten/rtree/internal/Functions.java", "superclasses": "", "methods": ["[]Functions()", "[Func1<T, T>]identity()", "[Func1<T, Boolean>]alwaysTrue()", "[Func1<T, Boolean>]alwaysFalse()"], "method_uris": ["src/main/java/com/github/davidmoten/rtree/internal/Functions.java.Functions.[]Functions()", "src/main/java/com/github/davidmoten/rtree/internal/Functions.java.Functions.[Func1<T, T>]identity()", "src/main/java/com/github/davidmoten/rtree/internal/Functions.java.Functions.[Func1<T, Boolean>]alwaysTrue()", "src/main/java/com/github/davidmoten/rtree/internal/Functions.java.Functions.[Func1<T, Boolean>]alwaysFalse()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public final class Functions {\n\n    private Functions() {\n        // prevent instantiation\n    }\n    \n    public static <T> Func1<T, T> identity() {\n        return t -> t;\n    }\n\n    public static <T> Func1<T, Boolean> alwaysTrue() {\n        return t -> true;\n    }\n\n    public static <T> Func1<T, Boolean> alwaysFalse() {\n        return t -> false;\n    }\n    \n}", "super_interfaces": [], "fields": []}, {"uris": "src/main/java/com/github/davidmoten/rtree/internal/NonLeafDefault.java.NonLeafDefault", "name": "NonLeafDefault", "file_path": "src/main/java/com/github/davidmoten/rtree/internal/NonLeafDefault.java", "superclasses": "", "methods": ["[]NonLeafDefault(List<? extends Node<T, S>>,Context<T, S>)", "[Geometry]geometry()", "[void]searchWithoutBackpressure(Func1<? super Geometry, Boolean>,Subscriber<? super Entry<T, S>>)", "[int]count()", "[List<Node<T, S>>]add(Entry<? extends T, ? extends S>)", "[NodeAndEntries<T, S>]delete(Entry<? extends T, ? extends S>,boolean)", "[Context<T, S>]context()", "[Node<T, S>]child(int)", "[List<Node<T, S>>]children()"], "method_uris": ["src/main/java/com/github/davidmoten/rtree/internal/NonLeafDefault.java.NonLeafDefault.[]NonLeafDefault(List<? extends Node<T, S>>,Context<T, S>)", "src/main/java/com/github/davidmoten/rtree/internal/NonLeafDefault.java.NonLeafDefault.[Geometry]geometry()", "src/main/java/com/github/davidmoten/rtree/internal/NonLeafDefault.java.NonLeafDefault.[void]searchWithoutBackpressure(Func1<? super Geometry, Boolean>,Subscriber<? super Entry<T, S>>)", "src/main/java/com/github/davidmoten/rtree/internal/NonLeafDefault.java.NonLeafDefault.[int]count()", "src/main/java/com/github/davidmoten/rtree/internal/NonLeafDefault.java.NonLeafDefault.[List<Node<T, S>>]add(Entry<? extends T, ? extends S>)", "src/main/java/com/github/davidmoten/rtree/internal/NonLeafDefault.java.NonLeafDefault.[NodeAndEntries<T, S>]delete(Entry<? extends T, ? extends S>,boolean)", "src/main/java/com/github/davidmoten/rtree/internal/NonLeafDefault.java.NonLeafDefault.[Context<T, S>]context()", "src/main/java/com/github/davidmoten/rtree/internal/NonLeafDefault.java.NonLeafDefault.[Node<T, S>]child(int)", "src/main/java/com/github/davidmoten/rtree/internal/NonLeafDefault.java.NonLeafDefault.[List<Node<T, S>>]children()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public final class NonLeafDefault<T, S extends Geometry> implements NonLeaf<T, S> {\n\n    private final List<? extends Node<T, S>> children;\n    private final Rectangle mbr;\n    private final Context<T, S> context;\n\n    public NonLeafDefault(List<? extends Node<T, S>> children, Context<T, S> context) {\n        Preconditions.checkArgument(!children.isEmpty());\n        this.context = context;\n        this.children = children;\n        this.mbr = Util.mbr(children);\n    }\n\n    @Override\n    public Geometry geometry() {\n        return mbr;\n    }\n\n    @Override\n    public void searchWithoutBackpressure(Func1<? super Geometry, Boolean> criterion,\n            Subscriber<? super Entry<T, S>> subscriber) {\n        NonLeafHelper.search(criterion, subscriber, this);\n    }\n\n    @Override\n    public int count() {\n        return children.size();\n    }\n\n    @Override\n    public List<Node<T, S>> add(Entry<? extends T, ? extends S> entry) {\n        return NonLeafHelper.add(entry, this);\n    }\n\n    @Override\n    public NodeAndEntries<T, S> delete(Entry<? extends T, ? extends S> entry, boolean all) {\n        return NonLeafHelper.delete(entry, all, this);\n    }\n\n    @Override\n    public Context<T, S> context() {\n        return context;\n    }\n\n    @Override\n    public Node<T, S> child(int i) {\n        return children.get(i);\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public List<Node<T, S>> children() {\n        return (List<Node<T, S>>) children;\n    }\n}", "super_interfaces": ["NonLeaf<T, S>"], "fields": [{"attribute_expression": "private final List<? extends Node<T, S>> children;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "List<? extends Node<T, S>>", "name": "children", "syntax_pass": true}, {"attribute_expression": "private final Rectangle mbr;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Rectangle", "name": "mbr", "syntax_pass": true}, {"attribute_expression": "private final Context<T, S> context;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Context<T, S>", "name": "context", "syntax_pass": true}]}, {"uris": "src/main/java/com/github/davidmoten/rtree/internal/LeafDefault.java.LeafDefault", "name": "LeafDefault", "file_path": "src/main/java/com/github/davidmoten/rtree/internal/LeafDefault.java", "superclasses": "", "methods": ["[]LeafDefault(List<Entry<T, S>>,Context<T, S>)", "[Geometry]geometry()", "[List<Entry<T, S>>]entries()", "[void]searchWithoutBackpressure(Func1<? super Geometry, Boolean>,Subscriber<? super Entry<T, S>>)", "[int]count()", "[List<Node<T, S>>]add(Entry<? extends T, ? extends S>)", "[NodeAndEntries<T, S>]delete(Entry<? extends T, ? extends S>,boolean)", "[Context<T, S>]context()", "[Entry<T, S>]entry(int)"], "method_uris": ["src/main/java/com/github/davidmoten/rtree/internal/LeafDefault.java.LeafDefault.[]LeafDefault(List<Entry<T, S>>,Context<T, S>)", "src/main/java/com/github/davidmoten/rtree/internal/LeafDefault.java.LeafDefault.[Geometry]geometry()", "src/main/java/com/github/davidmoten/rtree/internal/LeafDefault.java.LeafDefault.[List<Entry<T, S>>]entries()", "src/main/java/com/github/davidmoten/rtree/internal/LeafDefault.java.LeafDefault.[void]searchWithoutBackpressure(Func1<? super Geometry, Boolean>,Subscriber<? super Entry<T, S>>)", "src/main/java/com/github/davidmoten/rtree/internal/LeafDefault.java.LeafDefault.[int]count()", "src/main/java/com/github/davidmoten/rtree/internal/LeafDefault.java.LeafDefault.[List<Node<T, S>>]add(Entry<? extends T, ? extends S>)", "src/main/java/com/github/davidmoten/rtree/internal/LeafDefault.java.LeafDefault.[NodeAndEntries<T, S>]delete(Entry<? extends T, ? extends S>,boolean)", "src/main/java/com/github/davidmoten/rtree/internal/LeafDefault.java.LeafDefault.[Context<T, S>]context()", "src/main/java/com/github/davidmoten/rtree/internal/LeafDefault.java.LeafDefault.[Entry<T, S>]entry(int)"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public final class LeafDefault<T, S extends Geometry> implements Leaf<T, S> {\n\n    private final List<Entry<T, S>> entries;\n    private final Rectangle mbr;\n    private final Context<T, S> context;\n\n    public LeafDefault(List<Entry<T, S>> entries, Context<T, S> context) {\n        this.entries = entries;\n        this.context = context;\n        this.mbr = Util.mbr(entries);\n    }\n\n    @Override\n    public Geometry geometry() {\n        return mbr;\n    }\n\n    @Override\n    public List<Entry<T, S>> entries() {\n        return entries;\n    }\n\n    @Override\n    public void searchWithoutBackpressure(Func1<? super Geometry, Boolean> condition,\n            Subscriber<? super Entry<T, S>> subscriber) {\n        LeafHelper.search(condition, subscriber, this);\n    }\n\n    @Override\n    public int count() {\n        return entries.size();\n    }\n\n    @Override\n    public List<Node<T, S>> add(Entry<? extends T, ? extends S> entry) {\n        return LeafHelper.add(entry, this);\n    }\n\n    @Override\n    public NodeAndEntries<T, S> delete(Entry<? extends T, ? extends S> entry, boolean all) {\n        return LeafHelper.delete(entry, all, this);\n    }\n\n    @Override\n    public Context<T, S> context() {\n        return context;\n    }\n\n    @Override\n    public Entry<T, S> entry(int i) {\n        return entries.get(i);\n    }\n\n}", "super_interfaces": ["Leaf<T, S>"], "fields": [{"attribute_expression": "private final List<Entry<T, S>> entries;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "List<Entry<T, S>>", "name": "entries", "syntax_pass": true}, {"attribute_expression": "private final Rectangle mbr;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Rectangle", "name": "mbr", "syntax_pass": true}, {"attribute_expression": "private final Context<T, S> context;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Context<T, S>", "name": "context", "syntax_pass": true}]}, {"uris": "src/main/java/com/github/davidmoten/rtree/internal/NodeAndEntries.java.NodeAndEntries", "name": "NodeAndEntries", "file_path": "src/main/java/com/github/davidmoten/rtree/internal/NodeAndEntries.java", "superclasses": "", "methods": ["[]NodeAndEntries(Optional<? extends Node<T, S>>,List<Entry<T, S>>,int)", "[Optional<? extends Node<T, S>>]node()", "[List<Entry<T, S>>]entriesToAdd()", "[int]countDeleted()"], "method_uris": ["src/main/java/com/github/davidmoten/rtree/internal/NodeAndEntries.java.NodeAndEntries.[]NodeAndEntries(Optional<? extends Node<T, S>>,List<Entry<T, S>>,int)", "src/main/java/com/github/davidmoten/rtree/internal/NodeAndEntries.java.NodeAndEntries.[Optional<? extends Node<T, S>>]node()", "src/main/java/com/github/davidmoten/rtree/internal/NodeAndEntries.java.NodeAndEntries.[List<Entry<T, S>>]entriesToAdd()", "src/main/java/com/github/davidmoten/rtree/internal/NodeAndEntries.java.NodeAndEntries.[int]countDeleted()"], "overrides": null, "attributes": [], "class_docstring": "\nUsed for tracking deletions through recursive calls.\n\n@param <T>\n           value type\n@param <S> geometry type\n", "original_string": "public final class NodeAndEntries<T, S extends Geometry> {\n\n    private final Optional<? extends Node<T, S>> node;\n    private final List<Entry<T, S>> entries;\n    private final int count;\n\n    /**\n     * Constructor.\n     * \n     * @param node\n     *            absent = whole node was deleted present = either an unchanged\n     *            node because of no removal or the newly created node without\n     *            the deleted entry\n     * @param entries\n     *            from nodes that dropped below minChildren in size and thus\n     *            their entries are to be redistributed (readded to the tree)\n     * @param countDeleted\n     *            count of the number of entries removed\n     */\n    public NodeAndEntries(Optional<? extends Node<T, S>> node, List<Entry<T, S>> entries,\n            int countDeleted) {\n        this.node = node;\n        this.entries = entries;\n        this.count = countDeleted;\n    }\n\n    public Optional<? extends Node<T, S>> node() {\n        return node;\n    }\n\n    public List<Entry<T, S>> entriesToAdd() {\n        return entries;\n    }\n\n    public int countDeleted() {\n        return count;\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private final Optional<? extends Node<T, S>> node;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Optional<? extends Node<T, S>>", "name": "node", "syntax_pass": true}, {"attribute_expression": "private final List<Entry<T, S>> entries;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "List<Entry<T, S>>", "name": "entries", "syntax_pass": true}, {"attribute_expression": "private final int count;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "int", "name": "count", "syntax_pass": true}]}, {"uris": "src/main/java/com/github/davidmoten/rtree/internal/Line2D.java.Line2D", "name": "Line2D", "file_path": "src/main/java/com/github/davidmoten/rtree/internal/Line2D.java", "superclasses": "", "methods": ["[]Line2D(double,double,double,double)", "[double]getX1()", "[double]getX2()", "[double]getY1()", "[double]getY2()", "[double]ptSegDist(double,double)", "[double]ptSegDist(double,double,double,double,double,double)", "[double]ptSegDistSq(double,double,double,double,double,double)", "[boolean]intersectsLine(Line2D)", "[boolean]linesIntersect(double,double,double,double,double,double,double,double)", "[int]relativeCCW(double,double,double,double,double,double)"], "method_uris": ["src/main/java/com/github/davidmoten/rtree/internal/Line2D.java.Line2D.[]Line2D(double,double,double,double)", "src/main/java/com/github/davidmoten/rtree/internal/Line2D.java.Line2D.[double]getX1()", "src/main/java/com/github/davidmoten/rtree/internal/Line2D.java.Line2D.[double]getX2()", "src/main/java/com/github/davidmoten/rtree/internal/Line2D.java.Line2D.[double]getY1()", "src/main/java/com/github/davidmoten/rtree/internal/Line2D.java.Line2D.[double]getY2()", "src/main/java/com/github/davidmoten/rtree/internal/Line2D.java.Line2D.[double]ptSegDist(double,double)", "src/main/java/com/github/davidmoten/rtree/internal/Line2D.java.Line2D.[double]ptSegDist(double,double,double,double,double,double)", "src/main/java/com/github/davidmoten/rtree/internal/Line2D.java.Line2D.[double]ptSegDistSq(double,double,double,double,double,double)", "src/main/java/com/github/davidmoten/rtree/internal/Line2D.java.Line2D.[boolean]intersectsLine(Line2D)", "src/main/java/com/github/davidmoten/rtree/internal/Line2D.java.Line2D.[boolean]linesIntersect(double,double,double,double,double,double,double,double)", "src/main/java/com/github/davidmoten/rtree/internal/Line2D.java.Line2D.[int]relativeCCW(double,double,double,double,double,double)"], "overrides": null, "attributes": [], "class_docstring": "\nPort of java.awt.geom.Line2D. Created because Android does not support\njava.awt.*.\n", "original_string": "public final class Line2D {\n\n    private final double x1, x2, y1, y2;\n\n    public Line2D(double x1, double y1, double x2, double y2) {\n        this.x1 = x1;\n        this.x2 = x2;\n        this.y1 = y1;\n        this.y2 = y2;\n    }\n\n    public double getX1() {\n        return x1;\n    }\n\n    public double getX2() {\n        return x2;\n    }\n\n    public double getY1() {\n        return y1;\n    }\n\n    public double getY2() {\n        return y2;\n    }\n\n    /**\n     * Returns the distance from a point to this line segment. The distance measured\n     * is the distance between the specified point and the closest point between the\n     * current line's end points. If the specified point intersects the line segment\n     * in between the end points, this method returns 0.0.\n     *\n     * @param px\n     *            the X coordinate of the specified point being measured against\n     *            this line segment\n     * @param py\n     *            the Y coordinate of the specified point being measured against\n     *            this line segment\n     * @return a double value that is the distance from the specified point to the\n     *         current line segment.\n     * @since 1.2\n     */\n    public double ptSegDist(double px, double py) {\n        return ptSegDist(getX1(), getY1(), getX2(), getY2(), px, py);\n    }\n\n    /**\n     * Returns the distance from a point to a line segment. The distance measured is\n     * the distance between the specified point and the closest point between the\n     * specified end points. If the specified point intersects the line segment in\n     * between the end points, this method returns 0.0.\n     *\n     * @param x1\n     *            the X coordinate of the start point of the specified line segment\n     * @param y1\n     *            the Y coordinate of the start point of the specified line segment\n     * @param x2\n     *            the X coordinate of the end point of the specified line segment\n     * @param y2\n     *            the Y coordinate of the end point of the specified line segment\n     * @param px\n     *            the X coordinate of the specified point being measured against the\n     *            specified line segment\n     * @param py\n     *            the Y coordinate of the specified point being measured against the\n     *            specified line segment\n     * @return a double value that is the distance from the specified point to the\n     *         specified line segment.\n     * @since 1.2\n     */\n    public static double ptSegDist(double x1, double y1, double x2, double y2, double px,\n            double py) {\n        return Math.sqrt(ptSegDistSq(x1, y1, x2, y2, px, py));\n    }\n\n    /**\n     * Returns the square of the distance from a point to a line segment. The\n     * distance measured is the distance between the specified point and the closest\n     * point between the specified end points. If the specified point intersects the\n     * line segment in between the end points, this method returns 0.0.\n     *\n     * @param x1\n     *            the X coordinate of the start point of the specified line segment\n     * @param y1\n     *            the Y coordinate of the start point of the specified line segment\n     * @param x2\n     *            the X coordinate of the end point of the specified line segment\n     * @param y2\n     *            the Y coordinate of the end point of the specified line segment\n     * @param px\n     *            the X coordinate of the specified point being measured against the\n     *            specified line segment\n     * @param py\n     *            the Y coordinate of the specified point being measured against the\n     *            specified line segment\n     * @return a double value that is the square of the distance from the specified\n     *         point to the specified line segment.\n     * @since 1.2\n     */\n    public static double ptSegDistSq(double x1, double y1, double x2, double y2, double px,\n            double py) {\n        // Adjust vectors relative to x1,y1\n        // x2,y2 becomes relative vector from x1,y1 to end of segment\n        x2 -= x1;\n        y2 -= y1;\n        // px,py becomes relative vector from x1,y1 to test point\n        px -= x1;\n        py -= y1;\n        double dotprod = px * x2 + py * y2;\n        double projlenSq;\n        if (dotprod <= 0.0) {\n            // px,py is on the side of x1,y1 away from x2,y2\n            // distance to segment is length of px,py vector\n            // \"length of its (clipped) projection\" is now 0.0\n            projlenSq = 0.0;\n        } else {\n            // switch to backwards vectors relative to x2,y2\n            // x2,y2 are already the negative of x1,y1=>x2,y2\n            // to get px,py to be the negative of px,py=>x2,y2\n            // the dot product of two negated vectors is the same\n            // as the dot product of the two normal vectors\n            px = x2 - px;\n            py = y2 - py;\n            dotprod = px * x2 + py * y2;\n            if (dotprod <= 0.0) {\n                // px,py is on the side of x2,y2 away from x1,y1\n                // distance to segment is length of (backwards) px,py vector\n                // \"length of its (clipped) projection\" is now 0.0\n                projlenSq = 0.0;\n            } else {\n                // px,py is between x1,y1 and x2,y2\n                // dotprod is the length of the px,py vector\n                // projected on the x2,y2=>x1,y1 vector times the\n                // length of the x2,y2=>x1,y1 vector\n                projlenSq = dotprod * dotprod / (x2 * x2 + y2 * y2);\n            }\n        }\n        // Distance to line is now the length of the relative point\n        // vector minus the length of its projection onto the line\n        // (which is zero if the projection falls outside the range\n        // of the line segment).\n        double lenSq = px * px + py * py - projlenSq;\n        if (lenSq < 0) {\n            lenSq = 0;\n        }\n        return lenSq;\n    }\n\n    /**\n     * Tests if the specified line segment intersects this line segment.\n     * \n     * @param l\n     *            the specified <code>Line2D</code>\n     * @return <code>true</code> if this line segment and the specified line segment\n     *         intersect each other; <code>false</code> otherwise.\n     * @since 1.2\n     */\n    public boolean intersectsLine(Line2D l) {\n        return linesIntersect(l.getX1(), l.getY1(), l.getX2(), l.getY2(), getX1(), getY1(), getX2(),\n                getY2());\n    }\n\n    /**\n     * Tests if the line segment from {@code (x1,y1)} to {@code (x2,y2)} intersects\n     * the line segment from {@code (x3,y3)} to {@code (x4,y4)}.\n     *\n     * @param x1\n     *            the X coordinate of the start point of the first specified line\n     *            segment\n     * @param y1\n     *            the Y coordinate of the start point of the first specified line\n     *            segment\n     * @param x2\n     *            the X coordinate of the end point of the first specified line\n     *            segment\n     * @param y2\n     *            the Y coordinate of the end point of the first specified line\n     *            segment\n     * @param x3\n     *            the X coordinate of the start point of the second specified line\n     *            segment\n     * @param y3\n     *            the Y coordinate of the start point of the second specified line\n     *            segment\n     * @param x4\n     *            the X coordinate of the end point of the second specified line\n     *            segment\n     * @param y4\n     *            the Y coordinate of the end point of the second specified line\n     *            segment\n     * @return <code>true</code> if the first specified line segment and the second\n     *         specified line segment intersect each other; <code>false</code>\n     *         otherwise.\n     * @since 1.2\n     */\n    public static boolean linesIntersect(double x1, double y1, double x2, double y2, double x3,\n            double y3, double x4, double y4) {\n        return ((relativeCCW(x1, y1, x2, y2, x3, y3) * relativeCCW(x1, y1, x2, y2, x4, y4) <= 0)\n                && (relativeCCW(x3, y3, x4, y4, x1, y1)\n                        * relativeCCW(x3, y3, x4, y4, x2, y2) <= 0));\n    }\n\n    /**\n     * Returns an indicator of where the specified point {@code (px,py)} lies with\n     * respect to the line segment from {@code (x1,y1)} to {@code (x2,y2)}. The\n     * return value can be either 1, -1, or 0 and indicates in which direction the\n     * specified line must pivot around its first end point, {@code (x1,y1)}, in\n     * order to point at the specified point {@code (px,py)}.\n     * <p>\n     * A return value of 1 indicates that the line segment must turn in the\n     * direction that takes the positive X axis towards the negative Y axis. In the\n     * default coordinate system used by Java 2D, this direction is\n     * counterclockwise.\n     * <p>\n     * A return value of -1 indicates that the line segment must turn in the\n     * direction that takes the positive X axis towards the positive Y axis. In the\n     * default coordinate system, this direction is clockwise.\n     * <p>\n     * A return value of 0 indicates that the point lies exactly on the line\n     * segment. Note that an indicator value of 0 is rare and not useful for\n     * determining collinearity because of floating point rounding issues.\n     * <p>\n     * If the point is colinear with the line segment, but not between the end\n     * points, then the value will be -1 if the point lies \"beyond {@code (x1,y1)}\"\n     * or 1 if the point lies \"beyond {@code (x2,y2)}\".\n     *\n     * @param x1\n     *            the X coordinate of the start point of the specified line segment\n     * @param y1\n     *            the Y coordinate of the start point of the specified line segment\n     * @param x2\n     *            the X coordinate of the end point of the specified line segment\n     * @param y2\n     *            the Y coordinate of the end point of the specified line segment\n     * @param px\n     *            the X coordinate of the specified point to be compared with the\n     *            specified line segment\n     * @param py\n     *            the Y coordinate of the specified point to be compared with the\n     *            specified line segment\n     * @return an integer that indicates the position of the third specified\n     *         coordinates with respect to the line segment formed by the first two\n     *         specified coordinates.\n     * @since 1.2\n     */\n    private static int relativeCCW(double x1, double y1, double x2, double y2, double px,\n            double py) {\n        x2 -= x1;\n        y2 -= y1;\n        px -= x1;\n        py -= y1;\n        double ccw = px * y2 - py * x2;\n        if (ccw == 0.0) {\n            // The point is colinear, classify based on which side of\n            // the segment the point falls on. We can calculate a\n            // relative value using the projection of px,py onto the\n            // segment - a negative value indicates the point projects\n            // outside of the segment in the direction of the particular\n            // endpoint used as the origin for the projection.\n            ccw = px * x2 + py * y2;\n            if (ccw > 0.0) {\n                // Reverse the projection to be relative to the original x2,y2\n                // x2 and y2 are simply negated.\n                // px and py need to have (x2 - x1) or (y2 - y1) subtracted\n                // from them (based on the original values)\n                // Since we really want to get a positive answer when the\n                // point is \"beyond (x2,y2)\", then we want to calculate\n                // the inverse anyway - thus we leave x2 & y2 negated.\n                px -= x2;\n                py -= y2;\n                ccw = px * x2 + py * y2;\n                if (ccw < 0.0) {\n                    ccw = 0.0;\n                }\n            }\n        }\n        return (ccw < 0.0) ? -1 : ((ccw > 0.0) ? 1 : 0);\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private final double x1, x2, y1, y2;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "double", "name": "x1", "syntax_pass": true}]}, {"uris": "src/main/java/com/github/davidmoten/rtree/internal/LeafHelper.java.LeafHelper", "name": "LeafHelper", "file_path": "src/main/java/com/github/davidmoten/rtree/internal/LeafHelper.java", "superclasses": "", "methods": ["[]LeafHelper()", "[NodeAndEntries<T, S>]delete(Entry<? extends T, ? extends S>,boolean,Leaf<T, S>)", "[List<Node<T, S>>]add(Entry<? extends T, ? extends S>,Leaf<T, S>)", "[List<Node<T, S>>]makeLeaves(ListPair<Entry<T, S>>,Context<T, S>)", "[void]search(Func1<? super Geometry, Boolean>,Subscriber<? super Entry<T, S>>,Leaf<T, S>)"], "method_uris": ["src/main/java/com/github/davidmoten/rtree/internal/LeafHelper.java.LeafHelper.[]LeafHelper()", "src/main/java/com/github/davidmoten/rtree/internal/LeafHelper.java.LeafHelper.[NodeAndEntries<T, S>]delete(Entry<? extends T, ? extends S>,boolean,Leaf<T, S>)", "src/main/java/com/github/davidmoten/rtree/internal/LeafHelper.java.LeafHelper.[List<Node<T, S>>]add(Entry<? extends T, ? extends S>,Leaf<T, S>)", "src/main/java/com/github/davidmoten/rtree/internal/LeafHelper.java.LeafHelper.[List<Node<T, S>>]makeLeaves(ListPair<Entry<T, S>>,Context<T, S>)", "src/main/java/com/github/davidmoten/rtree/internal/LeafHelper.java.LeafHelper.[void]search(Func1<? super Geometry, Boolean>,Subscriber<? super Entry<T, S>>,Leaf<T, S>)"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public final class LeafHelper {\n\n    private LeafHelper() {\n        // prevent instantiation\n    }\n\n    public static <T, S extends Geometry> NodeAndEntries<T, S> delete(\n            Entry<? extends T, ? extends S> entry, boolean all, Leaf<T, S> leaf) {\n        List<Entry<T, S>> entries = leaf.entries();\n        if (!entries.contains(entry)) {\n            return new NodeAndEntries<>(of(leaf), Collections.emptyList(), 0);\n        } else {\n            final List<Entry<T, S>> entries2 = new ArrayList<>(entries);\n            entries2.remove(entry);\n            int numDeleted = 1;\n            // keep deleting if all specified\n            while (all && entries2.remove(entry))\n                numDeleted += 1;\n\n            if (entries2.size() >= leaf.context().minChildren()) {\n                Leaf<T, S> node = leaf.context().factory().createLeaf(entries2, leaf.context());\n                return new NodeAndEntries<>(of(node), Collections.emptyList(),\n                        numDeleted);\n            } else {\n                return new NodeAndEntries<T, S>(Optional.empty(), entries2,\n                        numDeleted);\n            }\n        }\n    }\n\n    public static <T, S extends Geometry> List<Node<T, S>> add(\n            Entry<? extends T, ? extends S> entry, Leaf<T, S> leaf) {\n        List<Entry<T, S>> entries = leaf.entries();\n        Context<T, S> context = leaf.context();\n        @SuppressWarnings(\"unchecked\")\n        final List<Entry<T, S>> entries2 = Util.add(entries, (Entry<T, S>) entry);\n        if (entries2.size() <= context.maxChildren())\n            return Collections\n                    .singletonList((Node<T, S>) context.factory().createLeaf(entries2, context));\n        else {\n            ListPair<Entry<T, S>> pair = context.splitter().split(entries2, context.minChildren());\n            return makeLeaves(pair, context);\n        }\n    }\n\n    private static <T, S extends Geometry> List<Node<T, S>> makeLeaves(ListPair<Entry<T, S>> pair,\n            Context<T, S> context) {\n        List<Node<T, S>> list = new ArrayList<Node<T, S>>(2);\n        list.add(context.factory().createLeaf(pair.group1().list(), context));\n        list.add(context.factory().createLeaf(pair.group2().list(), context));\n        return list;\n    }\n\n    public static <T, S extends Geometry> void search(Func1<? super Geometry, Boolean> condition,\n            Subscriber<? super Entry<T, S>> subscriber, Leaf<T, S> leaf) {\n\n        if (!condition.call(leaf.geometry().mbr())) {\n            return;\n        }\n\n        for (int i = 0; i < leaf.count(); i++) {\n            Entry<T, S> entry = leaf.entry(i);\n            if (subscriber.isUnsubscribed()) {\n                return;\n            } else {\n                if (condition.call(entry.geometry())) {\n                    subscriber.onNext(entry);\n                }\n            }\n        }\n    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/main/java/com/github/davidmoten/rtree/internal/Comparators.java.Comparators", "name": "Comparators", "file_path": "src/main/java/com/github/davidmoten/rtree/internal/Comparators.java", "superclasses": "", "methods": ["[]Comparators()", "[Comparator<HasGeometry>]overlapAreaThenAreaIncreaseThenAreaComparator(Rectangle,List<T>)", "[double]area(Rectangle,HasGeometry)", "[Comparator<HasGeometry>]areaIncreaseThenAreaComparator(Rectangle)", "[float]overlapArea(Rectangle,List<? extends HasGeometry>,HasGeometry)", "[double]areaIncrease(Rectangle,HasGeometry)", "[Comparator<Entry<T, S>>]ascendingDistance(Rectangle)"], "method_uris": ["src/main/java/com/github/davidmoten/rtree/internal/Comparators.java.Comparators.[]Comparators()", "src/main/java/com/github/davidmoten/rtree/internal/Comparators.java.Comparators.[Comparator<HasGeometry>]overlapAreaThenAreaIncreaseThenAreaComparator(Rectangle,List<T>)", "src/main/java/com/github/davidmoten/rtree/internal/Comparators.java.Comparators.[double]area(Rectangle,HasGeometry)", "src/main/java/com/github/davidmoten/rtree/internal/Comparators.java.Comparators.[Comparator<HasGeometry>]areaIncreaseThenAreaComparator(Rectangle)", "src/main/java/com/github/davidmoten/rtree/internal/Comparators.java.Comparators.[float]overlapArea(Rectangle,List<? extends HasGeometry>,HasGeometry)", "src/main/java/com/github/davidmoten/rtree/internal/Comparators.java.Comparators.[double]areaIncrease(Rectangle,HasGeometry)", "src/main/java/com/github/davidmoten/rtree/internal/Comparators.java.Comparators.[Comparator<Entry<T, S>>]ascendingDistance(Rectangle)"], "overrides": null, "attributes": [], "class_docstring": "\nUtility functions asociated with {@link Comparator}s, especially for use with\n{@link Selector}s and {@link Splitter}s.\n\n", "original_string": "public final class Comparators {\n\n    private Comparators() {\n        // prevent instantiation\n    }\n\n    public static <T extends HasGeometry> Comparator<HasGeometry> overlapAreaThenAreaIncreaseThenAreaComparator(\n            final Rectangle r, final List<T> list) {\n        return new Comparator<HasGeometry>() {\n\n            @Override\n            public int compare(HasGeometry g1, HasGeometry g2) {\n                int value = Double.compare(overlapArea(r, list, g1), overlapArea(r, list, g2));\n                if (value == 0) {\n                    value = Double.compare(areaIncrease(r, g1), areaIncrease(r, g2));\n                    if (value == 0) {\n                        value = Double.compare(area(r, g1), area(r, g2));\n                    }\n                }\n                return value;\n            }\n        };\n    }\n\n    private static double area(final Rectangle r, HasGeometry g1) {\n        return g1.geometry().mbr().add(r).area();\n    }\n\n    public static <T extends HasGeometry> Comparator<HasGeometry> areaIncreaseThenAreaComparator(\n            final Rectangle r) {\n        return new Comparator<HasGeometry>() {\n            @Override\n            public int compare(HasGeometry g1, HasGeometry g2) {\n                int value = Double.compare(areaIncrease(r, g1), areaIncrease(r, g2));\n                if (value == 0) {\n                    value = Double.compare(area(r, g1), area(r, g2));\n                }\n                return value;\n            }\n        };\n    }\n\n    private static float overlapArea(Rectangle r, List<? extends HasGeometry> list, HasGeometry g) {\n        Rectangle gPlusR = g.geometry().mbr().add(r);\n        float m = 0;\n        for (HasGeometry other : list) {\n            if (other != g) {\n                m += gPlusR.intersectionArea(other.geometry().mbr());\n            }\n        }\n        return m;\n    }\n\n    private static double areaIncrease(Rectangle r, HasGeometry g) {\n        Rectangle gPlusR = g.geometry().mbr().add(r);\n        return gPlusR.area() - g.geometry().mbr().area();\n    }\n\n    /**\n     * <p>\n     * Returns a comparator that can be used to sort entries returned by search\n     * methods. For example:\n     * </p>\n     * <p>\n     * <code>search(100).toSortedList(ascendingDistance(r))</code>\n     * </p>\n     * \n     * @param <T>\n     *            the value type\n     * @param <S>\n     *            the entry type\n     * @param r\n     *            rectangle to measure distance to\n     * @return a comparator to sort by ascending distance from the rectangle\n     */\n    public static <T, S extends Geometry> Comparator<Entry<T, S>> ascendingDistance(\n            final Rectangle r) {\n        return new Comparator<Entry<T, S>>() {\n            @Override\n            public int compare(Entry<T, S> e1, Entry<T, S> e2) {\n                return Double.compare(e1.geometry().distance(r), e2.geometry().distance(r));\n            }\n        };\n    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/main/java/com/github/davidmoten/rtree/internal/NonLeafHelper.java.NonLeafHelper", "name": "NonLeafHelper", "file_path": "src/main/java/com/github/davidmoten/rtree/internal/NonLeafHelper.java", "superclasses": "", "methods": ["[]NonLeafHelper()", "[void]search(Func1<? super Geometry, Boolean>,Subscriber<? super Entry<T, S>>,NonLeaf<T, S>)", "[List<Node<T, S>>]add(Entry<? extends T, ? extends S>,NonLeaf<T, S>)", "[List<Node<T, S>>]makeNonLeaves(ListPair<? extends Node<T, S>>,Context<T, S>)", "[NodeAndEntries<T, S>]delete(Entry<? extends T, ? extends S>,boolean,NonLeaf<T, S>)"], "method_uris": ["src/main/java/com/github/davidmoten/rtree/internal/NonLeafHelper.java.NonLeafHelper.[]NonLeafHelper()", "src/main/java/com/github/davidmoten/rtree/internal/NonLeafHelper.java.NonLeafHelper.[void]search(Func1<? super Geometry, Boolean>,Subscriber<? super Entry<T, S>>,NonLeaf<T, S>)", "src/main/java/com/github/davidmoten/rtree/internal/NonLeafHelper.java.NonLeafHelper.[List<Node<T, S>>]add(Entry<? extends T, ? extends S>,NonLeaf<T, S>)", "src/main/java/com/github/davidmoten/rtree/internal/NonLeafHelper.java.NonLeafHelper.[List<Node<T, S>>]makeNonLeaves(ListPair<? extends Node<T, S>>,Context<T, S>)", "src/main/java/com/github/davidmoten/rtree/internal/NonLeafHelper.java.NonLeafHelper.[NodeAndEntries<T, S>]delete(Entry<? extends T, ? extends S>,boolean,NonLeaf<T, S>)"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public final class NonLeafHelper {\n\n    private NonLeafHelper() {\n        // prevent instantiation\n    }\n\n    public static <T, S extends Geometry> void search(Func1<? super Geometry, Boolean> criterion,\n            Subscriber<? super Entry<T, S>> subscriber, NonLeaf<T, S> node) {\n        if (!criterion.call(node.geometry().mbr()))\n            return;\n\n        int numChildren = node.count();\n        for (int i = 0; i < numChildren; i++) {\n            if (subscriber.isUnsubscribed()) {\n                return;\n            } else {\n                Node<T, S> child = node.child(i);\n                child.searchWithoutBackpressure(criterion, subscriber);\n            }\n        }\n    }\n\n    public static <T, S extends Geometry> List<Node<T, S>> add(\n            Entry<? extends T, ? extends S> entry, NonLeaf<T, S> node) {\n        Context<T, S> context = node.context();\n        List<Node<T, S>> children = node.children();\n        final Node<T, S> child = context.selector().select(entry.geometry().mbr(), children);\n        List<Node<T, S>> list = child.add(entry);\n        List<? extends Node<T, S>> children2 = Util.replace(children, child, list);\n        if (children2.size() <= context.maxChildren())\n            return Collections.singletonList(\n                    (Node<T, S>) context.factory().createNonLeaf(children2, context));\n        else {\n            ListPair<? extends Node<T, S>> pair = context.splitter().split(children2,\n                    context.minChildren());\n            return makeNonLeaves(pair, context);\n        }\n    }\n\n    private static <T, S extends Geometry> List<Node<T, S>> makeNonLeaves(\n            ListPair<? extends Node<T, S>> pair, Context<T, S> context) {\n        List<Node<T, S>> list = new ArrayList<Node<T, S>>();\n        list.add(context.factory().createNonLeaf(pair.group1().list(), context));\n        list.add(context.factory().createNonLeaf(pair.group2().list(), context));\n        return list;\n    }\n\n    public static <T, S extends Geometry> NodeAndEntries<T, S> delete(\n            Entry<? extends T, ? extends S> entry, boolean all, NonLeaf<T, S> node) {\n        // the result of performing a delete of the given entry from this node\n        // will be that zero or more entries will be needed to be added back to\n        // the root of the tree (because num entries of their node fell below\n        // minChildren),\n        // zero or more children will need to be removed from this node,\n        // zero or more nodes to be added as children to this node(because\n        // entries have been deleted from them and they still have enough\n        // members to be active)\n        List<Entry<T, S>> addTheseEntries = new ArrayList<Entry<T, S>>();\n        List<Node<T, S>> removeTheseNodes = new ArrayList<Node<T, S>>();\n        List<Node<T, S>> addTheseNodes = new ArrayList<Node<T, S>>();\n        int countDeleted = 0;\n        List<? extends Node<T, S>> children = node.children();\n        for (final Node<T, S> child : children) {\n            if (entry.geometry().intersects(child.geometry().mbr())) {\n                final NodeAndEntries<T, S> result = child.delete(entry, all);\n                if (result.node().isPresent()) {\n                    if (result.node().get() != child) {\n                        // deletion occurred and child is above minChildren so\n                        // we update it\n                        addTheseNodes.add(result.node().get());\n                        removeTheseNodes.add(child);\n                        addTheseEntries.addAll(result.entriesToAdd());\n                        countDeleted += result.countDeleted();\n                        if (!all)\n                            break;\n                    }\n                    // else nothing was deleted from that child\n                } else {\n                    // deletion occurred and brought child below minChildren\n                    // so we redistribute its entries\n                    removeTheseNodes.add(child);\n                    addTheseEntries.addAll(result.entriesToAdd());\n                    countDeleted += result.countDeleted();\n                    if (!all)\n                        break;\n                }\n            }\n        }\n        if (removeTheseNodes.isEmpty())\n            return new NodeAndEntries<>(of(node), Collections.emptyList(), 0);\n        else {\n            List<Node<T, S>> nodes = Util.remove(children, removeTheseNodes);\n            nodes.addAll(addTheseNodes);\n            if (nodes.isEmpty())\n                return new NodeAndEntries<>(Optional.empty(), addTheseEntries,\n                        countDeleted);\n            else {\n                NonLeaf<T, S> nd = node.context().factory().createNonLeaf(nodes, node.context());\n                return new NodeAndEntries<>(of(nd), addTheseEntries, countDeleted);\n            }\n        }\n    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/main/java/com/github/davidmoten/rtree/internal/EntryDefault.java.EntryDefault", "name": "EntryDefault", "file_path": "src/main/java/com/github/davidmoten/rtree/internal/EntryDefault.java", "superclasses": "", "methods": ["[]EntryDefault(T,S)", "[Entry<T, S>]entry(T,S)", "[T]value()", "[S]geometry()", "[String]toString()", "[int]hashCode()", "[boolean]equals(Object)"], "method_uris": ["src/main/java/com/github/davidmoten/rtree/internal/EntryDefault.java.EntryDefault.[]EntryDefault(T,S)", "src/main/java/com/github/davidmoten/rtree/internal/EntryDefault.java.EntryDefault.[Entry<T, S>]entry(T,S)", "src/main/java/com/github/davidmoten/rtree/internal/EntryDefault.java.EntryDefault.[T]value()", "src/main/java/com/github/davidmoten/rtree/internal/EntryDefault.java.EntryDefault.[S]geometry()", "src/main/java/com/github/davidmoten/rtree/internal/EntryDefault.java.EntryDefault.[String]toString()", "src/main/java/com/github/davidmoten/rtree/internal/EntryDefault.java.EntryDefault.[int]hashCode()", "src/main/java/com/github/davidmoten/rtree/internal/EntryDefault.java.EntryDefault.[boolean]equals(Object)"], "overrides": null, "attributes": [], "class_docstring": "\nAn entry in the R-tree which has a spatial representation.\n\n@param <T>\n           value type\n@param <S>\n           geometry type\n", "original_string": "public final class EntryDefault<T, S extends Geometry> implements Entry<T, S> {\n    private final T value;\n    private final S geometry;\n\n    /**\n     * Constructor.\n     * \n     * @param value\n     *            the value of the entry\n     * @param geometry\n     *            the geometry of the value\n     */\n    public EntryDefault(T value, S geometry) {\n        Preconditions.checkNotNull(geometry);\n        this.value = value;\n        this.geometry = geometry;\n    }\n\n    /**\n     * Factory method.\n     * \n     * @param <T>\n     *            type of value\n     * @param <S>\n     *            type of geometry\n     * @param value\n     *            object being given a spatial context\n     * @param geometry\n     *            geometry associated with the value\n     * @return entry wrapping value and associated geometry\n     */\n    public static <T, S extends Geometry> Entry<T, S> entry(T value, S geometry) {\n        return new EntryDefault<T, S>(value, geometry);\n    }\n\n    /**\n     * Returns the value wrapped by this {@link EntryDefault}.\n     * \n     * @return the entry value\n     */\n    @Override\n    public T value() {\n        return value;\n    }\n\n    @Override\n    public S geometry() {\n        return geometry;\n    }\n\n    @Override\n    public String toString() {\n        String builder = \"Entry [value=\" + value + \", geometry=\" + geometry + \"]\";\n        return builder;\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(value, geometry);\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        @SuppressWarnings(\"rawtypes\")\n        Optional<EntryDefault> other = ObjectsHelper.asClass(obj, EntryDefault.class);\n        if (other.isPresent()) {\n            return Objects.equals(value, other.get().value)\n                    && Objects.equals(geometry, other.get().geometry);\n        } else\n            return false;\n    }\n\n}", "super_interfaces": ["Entry<T, S>"], "fields": [{"attribute_expression": "private final T value;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "T", "name": "value", "syntax_pass": true}, {"attribute_expression": "private final S geometry;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "S", "name": "geometry", "syntax_pass": true}]}, {"uris": "src/main/java/com/github/davidmoten/rtree/internal/RectangleUtil.java.RectangleUtil", "name": "RectangleUtil", "file_path": "src/main/java/com/github/davidmoten/rtree/internal/RectangleUtil.java", "superclasses": "", "methods": ["[]RectangleUtil()", "[boolean]rectangleIntersectsLine(double,double,double,double,double,double,double,double)", "[boolean]_rectangleIntersectsLine(double,double,double,double,double,double,double,double)", "[boolean]rectangleCornerOnSegment(double,double,double,double,double,double,double,double)", "[boolean]pointOnSegment(double,double,double,double,double,double)", "[int]outcode(double,double,double,double,double,double)"], "method_uris": ["src/main/java/com/github/davidmoten/rtree/internal/RectangleUtil.java.RectangleUtil.[]RectangleUtil()", "src/main/java/com/github/davidmoten/rtree/internal/RectangleUtil.java.RectangleUtil.[boolean]rectangleIntersectsLine(double,double,double,double,double,double,double,double)", "src/main/java/com/github/davidmoten/rtree/internal/RectangleUtil.java.RectangleUtil.[boolean]_rectangleIntersectsLine(double,double,double,double,double,double,double,double)", "src/main/java/com/github/davidmoten/rtree/internal/RectangleUtil.java.RectangleUtil.[boolean]rectangleCornerOnSegment(double,double,double,double,double,double,double,double)", "src/main/java/com/github/davidmoten/rtree/internal/RectangleUtil.java.RectangleUtil.[boolean]pointOnSegment(double,double,double,double,double,double)", "src/main/java/com/github/davidmoten/rtree/internal/RectangleUtil.java.RectangleUtil.[int]outcode(double,double,double,double,double,double)"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public final class RectangleUtil {\n\n    private RectangleUtil() {\n        // prevent instantiation\n    }\n\n    /**\n     * The bitmask that indicates that a point lies to the left of this\n     * <code>Rectangle2D</code>.\n     * \n     * @since 1.2\n     */\n    public static final int OUT_LEFT = 1;\n\n    /**\n     * The bitmask that indicates that a point lies above this\n     * <code>Rectangle2D</code>.\n     * \n     * @since 1.2\n     */\n    public static final int OUT_TOP = 2;\n\n    /**\n     * The bitmask that indicates that a point lies to the right of this\n     * <code>Rectangle2D</code>.\n     * \n     * @since 1.2\n     */\n    public static final int OUT_RIGHT = 4;\n\n    /**\n     * The bitmask that indicates that a point lies below this\n     * <code>Rectangle2D</code>.\n     * \n     * @since 1.2\n     */\n    public static final int OUT_BOTTOM = 8;\n    \n    public static boolean rectangleIntersectsLine(double rectX, double rectY, double rectWidth, double rectHeight,\n            double x1, double y1, double x2, double y2) {\n        return _rectangleIntersectsLine(rectX, rectY, rectWidth, rectHeight, x1, y1, x2, y2)\n                || Line2D.linesIntersect(rectX, rectY, rectX + rectWidth, rectY + rectHeight, x1, y1, x2, y2);\n    }\n    \n    private static boolean _rectangleIntersectsLine(double rectX, double rectY, double rectWidth,\n            double rectHeight, double x1, double y1, double x2, double y2) {\n        if (rectangleCornerOnSegment(rectX, rectY, rectWidth, rectHeight, x1, y1, x2, y2)) {\n            return true;\n        }\n        int out1, out2;\n        if ((out2 = outcode(rectX, rectY, rectWidth, rectHeight, x2, y2)) == 0) {\n            return true;\n        }\n        while ((out1 = outcode(rectX, rectY, rectWidth, rectHeight, x1, y1)) != 0) {\n            if ((out1 & out2) != 0) {\n                return false;\n            }\n            if ((out1 & (OUT_LEFT | OUT_RIGHT)) != 0) {\n                double x = rectX;\n                if ((out1 & OUT_RIGHT) != 0) {\n                    x += rectWidth;\n                }\n                y1 = y1 + (x - x1) * (y2 - y1) / (x2 - x1);\n                x1 = x;\n            } else {\n                double y = rectY;\n                if ((out1 & OUT_BOTTOM) != 0) {\n                    y += rectHeight;\n                }\n                x1 = x1 + (y - y1) * (x2 - x1) / (y2 - y1);\n                y1 = y;\n            }\n        }\n        return true;\n    }\n\n    private static boolean rectangleCornerOnSegment(double rectX, double rectY, double rectWidth,\n            double rectHeight, double x1, double y1, double x2, double y2) {\n        if (pointOnSegment(rectX, rectY, x1, y1, x2, y2)) {\n            return true;\n        } else if (pointOnSegment(rectX + rectWidth, rectY, x1, y1, x2, y2)) {\n            return true;\n        } else if (pointOnSegment(rectX, rectY + rectHeight, x1, y1, x2, y2)) {\n            return true;\n        } else if (pointOnSegment(rectX + rectWidth, rectY + rectHeight, x1, y1, x2, y2)) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    private static final double PRECISION = 0.00000001;\n\n    private static boolean pointOnSegment(double x, double y, double x1, double y1, double x2,\n            double y2) {\n        if (x < x1 || x > x2 || y < y1 || y > y2) {\n            return false;\n        } else {\n            double v = (y2 - y1) * (x - x1) - (x2 - x1) * (y - y1);\n            return Math.abs(v) < PRECISION;\n        }\n    }\n\n    private static int outcode(double rectX, double rectY, double rectWidth, double rectHeight,\n            double x, double y) {\n        int out = 0;\n        if (rectWidth <= 0) {\n            out |= OUT_LEFT | OUT_RIGHT;\n        } else if (x < rectX) {\n            out |= OUT_LEFT;\n        } else if (x > rectX + rectWidth) {\n            out |= OUT_RIGHT;\n        }\n        if (rectHeight <= 0) {\n            out |= OUT_TOP | OUT_BOTTOM;\n        } else if (y < rectY) {\n            out |= OUT_TOP;\n        } else if (y > rectY + rectHeight) {\n            out |= OUT_BOTTOM;\n        }\n        return out;\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "public static final int OUT_LEFT = 1;", "docstring": "\nThe bitmask that indicates that a point lies to the left of this\n<code>Rectangle2D</code>.\n\n@since 1.2\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "int", "name": "OUT_LEFT = 1", "syntax_pass": true}, {"attribute_expression": "public static final int OUT_TOP = 2;", "docstring": "\nThe bitmask that indicates that a point lies above this\n<code>Rectangle2D</code>.\n\n@since 1.2\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "int", "name": "OUT_TOP = 2", "syntax_pass": true}, {"attribute_expression": "public static final int OUT_RIGHT = 4;", "docstring": "\nThe bitmask that indicates that a point lies to the right of this\n<code>Rectangle2D</code>.\n\n@since 1.2\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "int", "name": "OUT_RIGHT = 4", "syntax_pass": true}, {"attribute_expression": "public static final int OUT_BOTTOM = 8;", "docstring": "\nThe bitmask that indicates that a point lies below this\n<code>Rectangle2D</code>.\n\n@since 1.2\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "int", "name": "OUT_BOTTOM = 8", "syntax_pass": true}, {"attribute_expression": "private static final double PRECISION = 0.00000001;", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "double", "name": "PRECISION = 0.00000001", "syntax_pass": true}]}, {"uris": "src/main/java/com/github/davidmoten/rtree/internal/operators/OperatorBoundedPriorityQueue.java.OperatorBoundedPriorityQueue", "name": "OperatorBoundedPriorityQueue", "file_path": "src/main/java/com/github/davidmoten/rtree/internal/operators/OperatorBoundedPriorityQueue.java", "superclasses": "", "methods": ["[]OperatorBoundedPriorityQueue(int,Comparator<? super T>)", "[Subscriber<? super T>]call(Subscriber<? super T>)"], "method_uris": ["src/main/java/com/github/davidmoten/rtree/internal/operators/OperatorBoundedPriorityQueue.java.OperatorBoundedPriorityQueue.[]OperatorBoundedPriorityQueue(int,Comparator<? super T>)", "src/main/java/com/github/davidmoten/rtree/internal/operators/OperatorBoundedPriorityQueue.java.OperatorBoundedPriorityQueue.[Subscriber<? super T>]call(Subscriber<? super T>)"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public final class OperatorBoundedPriorityQueue<T> implements Operator<T, T> {\n\n    private final int maximumSize;\n    private final Comparator<? super T> comparator;\n\n    public OperatorBoundedPriorityQueue(int maximumSize, Comparator<? super T> comparator) {\n        this.maximumSize = maximumSize;\n        this.comparator = comparator;\n    }\n\n    @Override\n    public Subscriber<? super T> call(final Subscriber<? super T> child) {\n        final BoundedPriorityQueue<T> q = new BoundedPriorityQueue<T>(maximumSize, comparator);\n        return new Subscriber<T>(child) {\n\n            @Override\n            public void onStart() {\n                request(Long.MAX_VALUE);\n            }\n\n            @Override\n            public void onCompleted() {\n                List<T> list = q.asOrderedList();\n                for (T t:list) {\n                    if (isUnsubscribed()) {\n                        return;\n                    } else {\n                        child.onNext(t);\n                    }\n                }\n                if (!isUnsubscribed()) {\n                    child.onCompleted();\n                }\n            }\n\n            @Override\n            public void onError(Throwable t) {\n                if (!isUnsubscribed())\n                    child.onError(t);\n            }\n\n            @Override\n            public void onNext(T t) {\n                if (!isUnsubscribed())\n                    q.add(t);\n            }\n        };\n    }\n\n}", "super_interfaces": ["Operator<T, T>"], "fields": [{"attribute_expression": "private final int maximumSize;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "int", "name": "maximumSize", "syntax_pass": true}, {"attribute_expression": "private final Comparator<? super T> comparator;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Comparator<? super T>", "name": "comparator", "syntax_pass": true}]}, {"uris": "src/main/java/com/github/davidmoten/rtree/internal/util/ObjectsHelper.java.ObjectsHelper", "name": "ObjectsHelper", "file_path": "src/main/java/com/github/davidmoten/rtree/internal/util/ObjectsHelper.java", "superclasses": "", "methods": ["[]ObjectsHelper()", "[void]instantiateForTestCoveragePurposesOnly()", "[Optional<T>]asClass(Object,Class<T>)"], "method_uris": ["src/main/java/com/github/davidmoten/rtree/internal/util/ObjectsHelper.java.ObjectsHelper.[]ObjectsHelper()", "src/main/java/com/github/davidmoten/rtree/internal/util/ObjectsHelper.java.ObjectsHelper.[void]instantiateForTestCoveragePurposesOnly()", "src/main/java/com/github/davidmoten/rtree/internal/util/ObjectsHelper.java.ObjectsHelper.[Optional<T>]asClass(Object,Class<T>)"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public final class ObjectsHelper {\n\n    private ObjectsHelper() {\n        // prevent instantiation\n    }\n\n    @VisibleForTesting\n    static void instantiateForTestCoveragePurposesOnly() {\n        new ObjectsHelper();\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    public static <T> Optional<T> asClass(Object object, Class<T> cls) {\n        if (object == null) {\n            return Optional.empty();\n        } else if (object.getClass() != cls) {\n            return Optional.empty();\n        } else {\n            return Optional.of((T) object);\n        }\n    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/main/java/com/github/davidmoten/rtree/internal/util/Pair.java.Pair", "name": "Pair", "file_path": "src/main/java/com/github/davidmoten/rtree/internal/util/Pair.java", "superclasses": "", "methods": ["[]Pair(T,T)", "[T]value1()", "[T]value2()"], "method_uris": ["src/main/java/com/github/davidmoten/rtree/internal/util/Pair.java.Pair.[]Pair(T,T)", "src/main/java/com/github/davidmoten/rtree/internal/util/Pair.java.Pair.[T]value1()", "src/main/java/com/github/davidmoten/rtree/internal/util/Pair.java.Pair.[T]value2()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public final class Pair<T> {\n\n    private final T value1;\n    private final T value2;\n\n    public Pair(T value1, T value2) {\n        this.value1 = value1;\n        this.value2 = value2;\n    }\n\n    public T value1() {\n        return value1;\n    }\n\n    public T value2() {\n        return value2;\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private final T value1;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "T", "name": "value1", "syntax_pass": true}, {"attribute_expression": "private final T value2;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "T", "name": "value2", "syntax_pass": true}]}, {"uris": "src/main/java/com/github/davidmoten/rtree/internal/util/ImmutableStack.java.ImmutableStack", "name": "ImmutableStack", "file_path": "src/main/java/com/github/davidmoten/rtree/internal/util/ImmutableStack.java", "superclasses": "", "methods": ["[]ImmutableStack(T,ImmutableStack<T>)", "[]ImmutableStack(Optional<T>,Optional<ImmutableStack<T>>)", "[ImmutableStack<T>]create(T)", "[]ImmutableStack()", "[ImmutableStack<S>]empty()", "[boolean]isEmpty()", "[T]peek()", "[ImmutableStack<T>]pop()", "[ImmutableStack<T>]push(T)", "[Iterator<T>]iterator()"], "method_uris": ["src/main/java/com/github/davidmoten/rtree/internal/util/ImmutableStack.java.ImmutableStack.[]ImmutableStack(T,ImmutableStack<T>)", "src/main/java/com/github/davidmoten/rtree/internal/util/ImmutableStack.java.ImmutableStack.[]ImmutableStack(Optional<T>,Optional<ImmutableStack<T>>)", "src/main/java/com/github/davidmoten/rtree/internal/util/ImmutableStack.java.ImmutableStack.[ImmutableStack<T>]create(T)", "src/main/java/com/github/davidmoten/rtree/internal/util/ImmutableStack.java.ImmutableStack.[]ImmutableStack()", "src/main/java/com/github/davidmoten/rtree/internal/util/ImmutableStack.java.ImmutableStack.[ImmutableStack<S>]empty()", "src/main/java/com/github/davidmoten/rtree/internal/util/ImmutableStack.java.ImmutableStack.[boolean]isEmpty()", "src/main/java/com/github/davidmoten/rtree/internal/util/ImmutableStack.java.ImmutableStack.[T]peek()", "src/main/java/com/github/davidmoten/rtree/internal/util/ImmutableStack.java.ImmutableStack.[ImmutableStack<T>]pop()", "src/main/java/com/github/davidmoten/rtree/internal/util/ImmutableStack.java.ImmutableStack.[ImmutableStack<T>]push(T)", "src/main/java/com/github/davidmoten/rtree/internal/util/ImmutableStack.java.ImmutableStack.[Iterator<T>]iterator()"], "overrides": null, "attributes": [{"original_string": "    private static class StackIterator<U> implements Iterator<U> {\n        private ImmutableStack<U> stack;\n\n        public StackIterator(final ImmutableStack<U> stack) {\n            this.stack = stack;\n        }\n\n        @Override\n        public boolean hasNext() {\n            return !this.stack.isEmpty();\n        }\n\n        @Override\n        public U next() {\n            final U result = this.stack.peek();\n            this.stack = this.stack.pop();\n            return result;\n        }\n\n        @Override\n        public void remove() {\n            throw new RuntimeException(\"not supported\");\n        }\n    }", "definition": "    private static class StackIterator<U> implements Iterator<U>", "class_docstring": "", "name": "StackIterator", "super_interfaces": ["Iterator<U>"], "superclasses": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "fields": [{"attribute_expression": "private ImmutableStack<U> stack;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "ImmutableStack<U>", "name": "stack", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        public StackIterator(final ImmutableStack<U> stack) {\n            this.stack = stack;\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "StackIterator", "params": [{"name": "stack", "type": "ImmutableStack<U>"}], "body": "                                                            {\n            this.stack = stack;\n        }", "signature": "public StackIterator(final ImmutableStack<U> stack)"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean hasNext() {\n            return !this.stack.isEmpty();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "hasNext", "params": [], "body": "                                 {\n            return !this.stack.isEmpty();\n        }", "signature": "@Override\n        public boolean hasNext()"}, {"syntax_pass": true, "original_string": "        @Override\n        public U next() {\n            final U result = this.stack.peek();\n            this.stack = this.stack.pop();\n            return result;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "U", "classes": []}, "name": "next", "params": [], "body": "                        {\n            final U result = this.stack.peek();\n            this.stack = this.stack.pop();\n            return result;\n        }", "signature": "@Override\n        public U next()"}, {"syntax_pass": true, "original_string": "        @Override\n        public void remove() {\n            throw new RuntimeException(\"not supported\");\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "remove", "params": [], "body": "                             {\n            throw new RuntimeException(\"not supported\");\n        }", "signature": "@Override\n        public void remove()"}]}], "class_docstring": "", "original_string": "public final class ImmutableStack<T> implements Iterable<T> {\n    private final Optional<T> head;\n    private final Optional<ImmutableStack<T>> tail;\n\n    private static ImmutableStack<?> EMPTY = new ImmutableStack<>();\n\n    public ImmutableStack(final T head, final ImmutableStack<T> tail) {\n        this(of(head), of(tail));\n    }\n\n    private ImmutableStack(Optional<T> head, Optional<ImmutableStack<T>> tail) {\n        this.head = head;\n        this.tail = tail;\n    }\n\n    public static <T> ImmutableStack<T> create(T t) {\n        return new ImmutableStack<>(of(t), of(ImmutableStack.empty()));\n    }\n\n    public ImmutableStack() {\n        this(Optional.empty(), Optional.empty());\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    public static <S> ImmutableStack<S> empty() {\n        return (ImmutableStack<S>) EMPTY;\n    }\n\n    public boolean isEmpty() {\n        return !head.isPresent();\n    }\n\n    public T peek() {\n        // if (isEmpty())\n        // throw new RuntimeException(\"cannot peek on empty stack\");\n        // else\n        return this.head.get();\n    }\n\n    public ImmutableStack<T> pop() {\n        // if (isEmpty())\n        // throw new RuntimeException(\"cannot pop on empty stack\");\n        // else\n        return this.tail.get();\n    }\n\n    public ImmutableStack<T> push(T value) {\n        return new ImmutableStack<T>(value, this);\n    }\n\n    @Override\n    public Iterator<T> iterator() {\n        return new StackIterator<T>(this);\n    }\n\n    private static class StackIterator<U> implements Iterator<U> {\n        private ImmutableStack<U> stack;\n\n        public StackIterator(final ImmutableStack<U> stack) {\n            this.stack = stack;\n        }\n\n        @Override\n        public boolean hasNext() {\n            return !this.stack.isEmpty();\n        }\n\n        @Override\n        public U next() {\n            final U result = this.stack.peek();\n            this.stack = this.stack.pop();\n            return result;\n        }\n\n        @Override\n        public void remove() {\n            throw new RuntimeException(\"not supported\");\n        }\n    }\n\n}", "super_interfaces": ["Iterable<T>"], "fields": [{"attribute_expression": "private final Optional<T> head;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Optional<T>", "name": "head", "syntax_pass": true}, {"attribute_expression": "private final Optional<ImmutableStack<T>> tail;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Optional<ImmutableStack<T>>", "name": "tail", "syntax_pass": true}, {"attribute_expression": "private static ImmutableStack<?> EMPTY = new ImmutableStack<>();", "docstring": "", "modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "type": "ImmutableStack<?>", "name": "EMPTY = new ImmutableStack<>()", "syntax_pass": true}]}, {"uris": "src/main/java/com/github/davidmoten/rtree/internal/util/BoundedPriorityQueue.java.BoundedPriorityQueue", "name": "BoundedPriorityQueue", "file_path": "src/main/java/com/github/davidmoten/rtree/internal/util/BoundedPriorityQueue.java", "superclasses": "", "methods": ["[]BoundedPriorityQueue(int,Comparator<? super T>)", "[Comparator<T>]reverse(Comparator<T>)", "[BoundedPriorityQueue<T>]create(int,Comparator<? super T>)", "[void]add(T)", "[List<T>]asList()", "[List<T>]asOrderedList()"], "method_uris": ["src/main/java/com/github/davidmoten/rtree/internal/util/BoundedPriorityQueue.java.BoundedPriorityQueue.[]BoundedPriorityQueue(int,Comparator<? super T>)", "src/main/java/com/github/davidmoten/rtree/internal/util/BoundedPriorityQueue.java.BoundedPriorityQueue.[Comparator<T>]reverse(Comparator<T>)", "src/main/java/com/github/davidmoten/rtree/internal/util/BoundedPriorityQueue.java.BoundedPriorityQueue.[BoundedPriorityQueue<T>]create(int,Comparator<? super T>)", "src/main/java/com/github/davidmoten/rtree/internal/util/BoundedPriorityQueue.java.BoundedPriorityQueue.[void]add(T)", "src/main/java/com/github/davidmoten/rtree/internal/util/BoundedPriorityQueue.java.BoundedPriorityQueue.[List<T>]asList()", "src/main/java/com/github/davidmoten/rtree/internal/util/BoundedPriorityQueue.java.BoundedPriorityQueue.[List<T>]asOrderedList()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public final class BoundedPriorityQueue<T> {\n\n    private final PriorityQueue<T> queue; /* backing data structure */\n    private final Comparator<? super T> comparator;\n    private final int maxSize;\n\n    /**\n     * Constructs a {@link BoundedPriorityQueue} with the specified\n     * {@code maxSize} and {@code comparator}.\n     *\n     * @param maxSize\n     *            - The maximum size the queue can reach, must be a positive\n     *            integer.\n     * @param comparator\n     *            - The comparator to be used to compare the elements in the\n     *            queue, must be non-null.\n     */\n    public BoundedPriorityQueue(final int maxSize, final Comparator<? super T> comparator) {\n        Preconditions.checkArgument(maxSize > 0, \"maxSize must be > 0\");\n        Preconditions.checkNotNull(comparator, \"comparator cannot be null\");\n        this.queue = new PriorityQueue<T>(reverse(comparator));\n        this.comparator = comparator;\n        this.maxSize = maxSize;\n    }\n\n    private static <T> Comparator<T> reverse(final Comparator<T> comparator) {\n        return (o1, o2) -> comparator.compare(o2, o1);\n    }\n\n    public static <T> BoundedPriorityQueue<T> create(final int maxSize,\n            final Comparator<? super T> comparator) {\n        return new BoundedPriorityQueue<T>(maxSize, comparator);\n    }\n\n    /**\n     * Adds an element to the queue. If the queue contains {@code maxSize}\n     * elements, {@code e} will be compared to the lowest element in the queue\n     * using {@code comparator}. If {@code e} is greater than or equal to the\n     * lowest element, that element will be removed and {@code e} will be added\n     * instead. Otherwise, the queue will not be modified and {@code e} will not\n     * be added.\n     *\n     * @param t\n     *            - Element to be added, must be non-null.\n     */\n    public void add(final T t) {\n        if (t == null) {\n            throw new NullPointerException(\"cannot add null to the queue\");\n        }\n        if (queue.size() >= maxSize) {\n            final T maxElement = queue.peek();\n            if (comparator.compare(maxElement, t) < 1) {\n                return;\n            } else {\n                queue.poll();\n            }\n        }\n        queue.add(t);\n    }\n\n    /**\n     * @return Returns a view of the queue as a\n     *         {@link Collections#unmodifiableList(java.util.List)}\n     *         unmodifiableList sorted in reverse order.\n     */\n    public List<T> asList() {\n        return Collections.unmodifiableList(new ArrayList<>(queue));\n    }\n\n    public List<T> asOrderedList() {\n        List<T> list = new ArrayList<>(queue);\n        list.sort(comparator);\n        return list;\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private final PriorityQueue<T> queue;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "PriorityQueue<T>", "name": "queue", "syntax_pass": true}, {"attribute_expression": "private final Comparator<? super T> comparator;", "docstring": " backing data structure", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Comparator<? super T>", "name": "comparator", "syntax_pass": true}, {"attribute_expression": "private final int maxSize;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "int", "name": "maxSize", "syntax_pass": true}]}]