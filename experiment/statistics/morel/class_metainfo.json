[{"uris": "src/test/java/net/hydromatic/morel/LintTest.java.LintTest", "name": "LintTest", "file_path": "src/test/java/net/hydromatic/morel/LintTest.java", "superclasses": "", "methods": ["[Puffin.Program<GlobalState>]makeProgram()"], "method_uris": ["src/test/java/net/hydromatic/morel/LintTest.java.LintTest.[Puffin.Program<GlobalState>]makeProgram()"], "overrides": null, "attributes": [{"original_string": "  private static class Message {\n    final Source source;\n    final int line;\n    final String message;\n\n    Message(Source source, int line, String message) {\n      this.source = source;\n      this.line = line;\n      this.message = message;\n    }\n\n    @Override public String toString() {\n      return source + \":\" + line + \":\" + message;\n    }\n  }", "definition": "  private static class Message", "class_docstring": " Warning that code is not as it should be.", "name": "Message", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "fields": [{"attribute_expression": "final Source source;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "Source", "name": "source", "syntax_pass": true}, {"attribute_expression": "final int line;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "int", "name": "line", "syntax_pass": true}, {"attribute_expression": "final String message;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "String", "name": "message", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    Message(Source source, int line, String message) {\n      this.source = source;\n      this.line = line;\n      this.message = message;\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "Message", "params": [{"name": "source", "type": "Source"}, {"name": "line", "type": "int"}, {"name": "message", "type": "String"}], "body": "                                                     {\n      this.source = source;\n      this.line = line;\n      this.message = message;\n    }", "signature": "Message(Source source, int line, String message)"}, {"syntax_pass": true, "original_string": "    @Override public String toString() {\n      return source + \":\" + line + \":\" + message;\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "toString", "params": [], "body": "                                       {\n      return source + \":\" + line + \":\" + message;\n    }", "signature": "@Override public String toString()"}]}, {"original_string": "  private static class GlobalState {\n    int fileCount = 0;\n    final List<Message> messages = new ArrayList<>();\n  }", "definition": "  private static class GlobalState", "class_docstring": " Internal state of the lint rules.", "name": "GlobalState", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "fields": [{"attribute_expression": "int fileCount = 0;", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "int", "name": "fileCount = 0", "syntax_pass": true}, {"attribute_expression": "final List<Message> messages = new ArrayList<>();", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "List<Message>", "name": "messages = new ArrayList<>()", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": []}, {"original_string": "  private static class FileState {\n    final GlobalState global;\n    int starLine;\n    int atLine;\n    int javadocStartLine;\n    int javadocEndLine;\n    int blockquoteCount;\n    int ulCount;\n\n    FileState(GlobalState global) {\n      this.global = global;\n    }\n\n    void message(String message, Puffin.Line<GlobalState, FileState> line) {\n      global.messages.add(new Message(line.source(), line.fnr(), message));\n    }\n\n    public boolean inJavadoc() {\n      return javadocEndLine < javadocStartLine;\n    }\n  }", "definition": "  private static class FileState", "class_docstring": " Internal state of the lint rules, per file.", "name": "FileState", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "fields": [{"attribute_expression": "final GlobalState global;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "GlobalState", "name": "global", "syntax_pass": true}, {"attribute_expression": "int starLine;", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "int", "name": "starLine", "syntax_pass": true}, {"attribute_expression": "int atLine;", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "int", "name": "atLine", "syntax_pass": true}, {"attribute_expression": "int javadocStartLine;", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "int", "name": "javadocStartLine", "syntax_pass": true}, {"attribute_expression": "int javadocEndLine;", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "int", "name": "javadocEndLine", "syntax_pass": true}, {"attribute_expression": "int blockquoteCount;", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "int", "name": "blockquoteCount", "syntax_pass": true}, {"attribute_expression": "int ulCount;", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "int", "name": "ulCount", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    FileState(GlobalState global) {\n      this.global = global;\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "FileState", "params": [{"name": "global", "type": "GlobalState"}], "body": "                                  {\n      this.global = global;\n    }", "signature": "FileState(GlobalState global)"}, {"syntax_pass": true, "original_string": "    void message(String message, Puffin.Line<GlobalState, FileState> line) {\n      global.messages.add(new Message(line.source(), line.fnr(), message));\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "name": "message", "params": [{"name": "message", "type": "String"}, {"name": "line", "type": "Puffin.Line<GlobalState, FileState>"}], "body": "                                                                           {\n      global.messages.add(new Message(line.source(), line.fnr(), message));\n    }", "signature": "void message(String message, Puffin.Line<GlobalState, FileState> line)"}, {"syntax_pass": true, "original_string": "    public boolean inJavadoc() {\n      return javadocEndLine < javadocStartLine;\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "inJavadoc", "params": [], "body": "                               {\n      return javadocEndLine < javadocStartLine;\n    }", "signature": "public boolean inJavadoc()"}]}], "class_docstring": " Runs Lint-like checks on the source code.\nAlso tests those checks.", "original_string": "public class LintTest {\n  @SuppressWarnings(\"Convert2MethodRef\") // JDK 8 requires lambdas\n  private Puffin.Program<GlobalState> makeProgram() {\n    return Puffin.builder(GlobalState::new, global -> new FileState(global))\n        .add(line -> line.isLast(),\n            line -> {\n              String f = line.filename();\n              final int slash = f.lastIndexOf('/');\n              final String endMarker =\n                  \"// End \" + (slash < 0 ? f : f.substring(slash + 1));\n              if (!line.line().equals(endMarker)\n                  && line.filename().endsWith(\".java\")) {\n                line.state().message(\"File must end with '\" + endMarker + \"'\",\n                    line);\n              }\n            })\n        .add(line -> line.fnr() == 1,\n            line -> line.globalState().fileCount++)\n\n        // Trailing space\n        .add(line -> line.endsWith(\" \"),\n            line -> line.state().message(\"Trailing space\", line))\n\n        // Tab\n        .add(line -> line.contains(\"\\t\"),\n            line -> line.state().message(\"Tab\", line))\n\n        // Nullable\n        .add(line -> line.startsWith(\"import javax.annotation.Nullable;\"),\n            line -> line.state().message(\n                \"use org.checkerframework.checker.nullness.qual.Nullable\",\n                line))\n\n        // Nonnull\n        .add(line -> line.startsWith(\"import javax.annotation.Nonnull;\"),\n            line -> line.state().message(\n                \"use org.checkerframework.checker.nullness.qual.NonNull\",\n                line))\n\n        // Use of 'Static.' other than in an import.\n        .add(line -> (line.contains(\"Assertions.\")\n                || line.contains(\"CoreMatchers.\")\n                || line.contains(\"MatcherAssert.assertThat\")\n                || line.contains(\"Objects.requireNonNull\")\n                || line.contains(\"Ord.forEachIndexed\")\n                || line.contains(\"Pair.forEach\")\n                || line.contains(\"Preconditions.\")\n                || line.contains(\"Static.\"))\n                && line.filename().endsWith(\".java\")\n                && !line.startsWith(\"import static\")\n                && !line.matches(\"^ *// .*$\")\n                && !line.endsWith(\"// lint:skip\")\n                && !line.source().fileOpt()\n                .filter(f -> f.getName().equals(\"LintTest.java\")).isPresent()\n                && !line.source().fileOpt()\n                .filter(f -> f.getName().equals(\"UtilTest.java\")).isPresent(),\n            line -> line.state().message(\"should be static import\", line))\n\n        // In a test,\n        //   assertThat(x.toString(), is(y));\n        // should be\n        //   assertThat(x, hasToString(y)));\n        .add(line -> line.contains(\".toString(), is(\")\n                && line.filename().endsWith(\".java\")\n                && !line.source().fileOpt()\n                .filter(f -> f.getName().equals(\"LintTest.java\")).isPresent(),\n            line -> line.state().message(\"use 'Matchers.hasToString'\", line))\n\n        // Comment without space\n        .add(line -> line.matches(\".* //[^ ].*\")\n                && !line.source().fileOpt()\n                .filter(f -> f.getName().equals(\"LintTest.java\")).isPresent()\n                && !line.contains(\"//--\")\n                && !line.contains(\"//~\")\n                && !line.contains(\"//noinspection\")\n                && !line.contains(\"//CHECKSTYLE\"),\n            line -> line.state().message(\"'//' must be followed by ' '\", line))\n\n        // Javadoc does not require '</p>', so we do not allow '</p>'\n        .add(line -> line.state().inJavadoc()\n                && line.contains(\"</p>\"),\n            line -> line.state().message(\"no '</p>'\", line))\n\n        // No \"**/\"\n        .add(line -> line.contains(\" **/\")\n                && line.state().inJavadoc(),\n            line ->\n                line.state().message(\"no '**/'; use '*/'\",\n                    line))\n\n        // A Javadoc paragraph '<p>' must not be on its own line.\n        .add(line -> line.matches(\"^ *\\\\* <p>\"),\n            line ->\n                line.state().message(\"<p> must not be on its own line\",\n                    line))\n\n        // A Javadoc paragraph '<p>' must be preceded by a blank Javadoc\n        // line.\n        .add(line -> line.matches(\"^ *\\\\*\"),\n            line -> {\n              final FileState f = line.state();\n              if (f.starLine == line.fnr() - 1) {\n                f.message(\"duplicate empty line in javadoc\", line);\n              }\n              f.starLine = line.fnr();\n            })\n        .add(line -> line.matches(\"^ *\\\\* <p>.*\")\n                && line.fnr() - 1 != line.state().starLine,\n            line ->\n                line.state().message(\"<p> must be preceded by blank line\",\n                    line))\n\n        // A non-blank line following a blank line must have a '<p>'\n        .add(line -> line.state().inJavadoc()\n                && line.state().ulCount == 0\n                && line.state().blockquoteCount == 0\n                && line.contains(\"* \")\n                && line.fnr() - 1 == line.state().starLine\n                && line.matches(\"^ *\\\\* [^<@].*\"),\n            line -> line.state().message(\"missing '<p>'\", line))\n\n        // The first \"@param\" of a javadoc block must be preceded by a blank\n        // line.\n        .add(line -> line.matches(\"^ */\\\\*\\\\*.*\"),\n            line -> {\n              final FileState f = line.state();\n              f.javadocStartLine = line.fnr();\n              f.blockquoteCount = 0;\n              f.ulCount = 0;\n            })\n        .add(line -> line.matches(\".*\\\\*/\"),\n            line -> line.state().javadocEndLine = line.fnr())\n        .add(line -> line.matches(\"^ *\\\\* @.*\"),\n            line -> {\n              if (line.state().inJavadoc()\n                  && line.state().atLine < line.state().javadocStartLine\n                  && line.fnr() - 1 != line.state().starLine) {\n                line.state().message(\n                    \"First @tag must be preceded by blank line\",\n                    line);\n              }\n              line.state().atLine = line.fnr();\n            })\n        .add(line -> line.contains(\"<blockquote>\"),\n            line -> line.state().blockquoteCount++)\n        .add(line -> line.contains(\"</blockquote>\"),\n            line -> line.state().blockquoteCount--)\n        .add(line -> line.contains(\"<ul>\"),\n            line -> line.state().ulCount++)\n        .add(line -> line.contains(\"</ul>\"),\n            line -> line.state().ulCount--)\n        .build();\n  }\n\n  // /** Tests that source code has no flaws. */\n  // @Test void testLint() {\n  //   assumeTrue(TestUnsafe.haveGit(), \"Invalid git environment\");\n\n  //   final Puffin.Program<GlobalState> program = makeProgram();\n  //   final List<File> javaFiles = TestUnsafe.getTextFiles();\n\n  //   final GlobalState g;\n  //   StringWriter b = new StringWriter();\n  //   try (PrintWriter pw = new PrintWriter(b)) {\n  //     g = program.execute(javaFiles.parallelStream().map(Sources::of), pw);\n  //   }\n\n  //   assertThat(\"Lint violations:\\n\" + b, g.messages, empty());\n  // }\n\n  /** Warning that code is not as it should be. */\n  private static class Message {\n    final Source source;\n    final int line;\n    final String message;\n\n    Message(Source source, int line, String message) {\n      this.source = source;\n      this.line = line;\n      this.message = message;\n    }\n\n    @Override public String toString() {\n      return source + \":\" + line + \":\" + message;\n    }\n  }\n\n  /** Internal state of the lint rules. */\n  private static class GlobalState {\n    int fileCount = 0;\n    final List<Message> messages = new ArrayList<>();\n  }\n\n  /** Internal state of the lint rules, per file. */\n  private static class FileState {\n    final GlobalState global;\n    int starLine;\n    int atLine;\n    int javadocStartLine;\n    int javadocEndLine;\n    int blockquoteCount;\n    int ulCount;\n\n    FileState(GlobalState global) {\n      this.global = global;\n    }\n\n    void message(String message, Puffin.Line<GlobalState, FileState> line) {\n      global.messages.add(new Message(line.source(), line.fnr(), message));\n    }\n\n    public boolean inJavadoc() {\n      return javadocEndLine < javadocStartLine;\n    }\n  }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/net/hydromatic/morel/MorelTests.java.MorelTests", "name": "MorelTests", "file_path": "src/test/java/net/hydromatic/morel/MorelTests.java", "superclasses": "", "methods": ["[]MorelTests()", "[void]abandon(String)"], "method_uris": ["src/test/java/net/hydromatic/morel/MorelTests.java.MorelTests.[]MorelTests()", "src/test/java/net/hydromatic/morel/MorelTests.java.MorelTests.[void]abandon(String)"], "overrides": null, "attributes": [], "class_docstring": " Utilities for writing tests.", "original_string": "public class MorelTests {\n  private MorelTests() {}\n\n  /** Aborts the test with a given message.\n   * Use this method if you want to abandon a test case half way through.\n   * The test will \"succeed\", because this is an {@link Assumptions} failure.\n   *\n   * @param message Message\n   */\n  @SuppressWarnings(\"ConstantConditions\")\n  public static void abandon(String message) {\n    assumeTrue(false, message);\n  }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/net/hydromatic/morel/Ml.java.Ml", "name": "Ml", "file_path": "src/test/java/net/hydromatic/morel/Ml.java", "superclasses": "", "methods": ["[]Ml(String,Pos,Map<String, DataSet>,Map<Prop, Object>,Tracer)", "[Ml]ml(String)", "[Ml]ml(String,char)", "[void]assertError(Runnable,Matcher<Throwable>)", "[Ml]withParser(Consumer<MorelParserImpl>)", "[Ml]assertParseLiteral(Matcher<Ast.Literal>)", "[Ml]assertParseDecl(Matcher<Ast.Decl>)", "[Ml]assertParseDecl(Class<? extends Ast.Decl>,String)", "[Ml]assertParseStmt(Matcher<AstNode>)", "[Ml]assertParseStmt(Class<? extends AstNode>,String)", "[Ml]assertParse(String)", "[Ml]assertParse(boolean,String)", "[Ml]assertParseSame()", "[Ml]assertParseThrowsParseException(Matcher<String>)", "[Ml]assertParseThrowsIllegalArgumentException(Matcher<String>)", "[Ml]assertParseThrows(Matcher<Throwable>)", "[Ml]withValidate(BiConsumer<TypeResolver.Resolved, Calcite>)", "[Ml]assertType(Matcher<Type>)", "[Ml]assertType(String)", "[Ml]assertTypeThrows(Function<Pos, Matcher<Throwable>>)", "[Ml]assertTypeThrows(Matcher<Throwable>)", "[Ml]assertTypeException(String)", "[Ml]withPrepare(Consumer<CompiledStatement>)", "[Ml]assertCalcite(Matcher<String>)", "[Ml]assertCore(int,Matcher<Core.Decl>)", "[Ml]assertCoreString(Matcher<Core.Decl>,Matcher<Core.Decl>,Matcher<Core.Decl>)", "[Ml]assertAnalyze(Matcher<Map<Core.NamedPat, Analyzer.Use>>)", "[Ml]assertMatchCoverage(MatchCoverage)", "[Matcher<List<E>>]isEmptyList()", "[Ml]assertPlan(Matcher<Code>)", "[Ml]assertEvalIter(Matcher<Iterable<E>>)", "[Ml]assertEval(Matcher<Object>)", "[Ml]assertEval()", "[Ml]assertEvalThrows(Function<Pos, Matcher<Throwable>>)", "[Object]eval(Session,Environment,TypeSystem,AstNode,Calcite)", "[Object]bindingValue(List<Binding>,String)", "[Ml]assertCompileException(Function<Pos, Matcher<CompileException>>)", "[Ml]assertEvalError(Function<Pos, Matcher<Throwable>>)", "[Ml]assertEvalWarnings(Matcher<List<Throwable>>)", "[Ml]assertEvalSame()", "[Ml]assertError(Matcher<String>)", "[Ml]assertError(String)", "[Ml]withBinding(String,DataSet)", "[Ml]with(Prop,Object)", "[Ml]withTracer(Tracer)", "[Ml]withTypeExceptionMatcher(Matcher<Throwable>)", "[Ml]withResultMatcher(Matcher<Object>)", "[Ml]withWarningsMatcher(Matcher<List<Throwable>>)", "[Ml]withExceptionMatcher(Function<Pos, Matcher<Throwable>>)", "[Ml]withCompileExceptionMatcher(Function<Pos, Matcher<CompileException>>)", "[Ml]withTypeException(String)", "[Consumer<T>]exceptionConsumer(Function<Pos, Matcher<T>>)", "[Map<K, V>]plus(Map<K, V>,K,V)"], "method_uris": ["src/test/java/net/hydromatic/morel/Ml.java.Ml.[]Ml(String,Pos,Map<String, DataSet>,Map<Prop, Object>,Tracer)", "src/test/java/net/hydromatic/morel/Ml.java.Ml.[Ml]ml(String)", "src/test/java/net/hydromatic/morel/Ml.java.Ml.[Ml]ml(String,char)", "src/test/java/net/hydromatic/morel/Ml.java.Ml.[void]assertError(Runnable,Matcher<Throwable>)", "src/test/java/net/hydromatic/morel/Ml.java.Ml.[Ml]withParser(Consumer<MorelParserImpl>)", "src/test/java/net/hydromatic/morel/Ml.java.Ml.[Ml]assertParseLiteral(Matcher<Ast.Literal>)", "src/test/java/net/hydromatic/morel/Ml.java.Ml.[Ml]assertParseDecl(Matcher<Ast.Decl>)", "src/test/java/net/hydromatic/morel/Ml.java.Ml.[Ml]assertParseDecl(Class<? extends Ast.Decl>,String)", "src/test/java/net/hydromatic/morel/Ml.java.Ml.[Ml]assertParseStmt(Matcher<AstNode>)", "src/test/java/net/hydromatic/morel/Ml.java.Ml.[Ml]assertParseStmt(Class<? extends AstNode>,String)", "src/test/java/net/hydromatic/morel/Ml.java.Ml.[Ml]assertParse(String)", "src/test/java/net/hydromatic/morel/Ml.java.Ml.[Ml]assertParse(boolean,String)", "src/test/java/net/hydromatic/morel/Ml.java.Ml.[Ml]assertParseSame()", "src/test/java/net/hydromatic/morel/Ml.java.Ml.[Ml]assertParseThrowsParseException(Matcher<String>)", "src/test/java/net/hydromatic/morel/Ml.java.Ml.[Ml]assertParseThrowsIllegalArgumentException(Matcher<String>)", "src/test/java/net/hydromatic/morel/Ml.java.Ml.[Ml]assertParseThrows(Matcher<Throwable>)", "src/test/java/net/hydromatic/morel/Ml.java.Ml.[Ml]withValidate(BiConsumer<TypeResolver.Resolved, Calcite>)", "src/test/java/net/hydromatic/morel/Ml.java.Ml.[Ml]assertType(Matcher<Type>)", "src/test/java/net/hydromatic/morel/Ml.java.Ml.[Ml]assertType(String)", "src/test/java/net/hydromatic/morel/Ml.java.Ml.[Ml]assertTypeThrows(Function<Pos, Matcher<Throwable>>)", "src/test/java/net/hydromatic/morel/Ml.java.Ml.[Ml]assertTypeThrows(Matcher<Throwable>)", "src/test/java/net/hydromatic/morel/Ml.java.Ml.[Ml]assertTypeException(String)", "src/test/java/net/hydromatic/morel/Ml.java.Ml.[Ml]withPrepare(Consumer<CompiledStatement>)", "src/test/java/net/hydromatic/morel/Ml.java.Ml.[Ml]assertCalcite(Matcher<String>)", "src/test/java/net/hydromatic/morel/Ml.java.Ml.[Ml]assertCore(int,Matcher<Core.Decl>)", "src/test/java/net/hydromatic/morel/Ml.java.Ml.[Ml]assertCoreString(Matcher<Core.Decl>,Matcher<Core.Decl>,Matcher<Core.Decl>)", "src/test/java/net/hydromatic/morel/Ml.java.Ml.[Ml]assertAnalyze(Matcher<Map<Core.NamedPat, Analyzer.Use>>)", "src/test/java/net/hydromatic/morel/Ml.java.Ml.[Ml]assertMatchCoverage(MatchCoverage)", "src/test/java/net/hydromatic/morel/Ml.java.Ml.[Matcher<List<E>>]isEmptyList()", "src/test/java/net/hydromatic/morel/Ml.java.Ml.[Ml]assertPlan(Matcher<Code>)", "src/test/java/net/hydromatic/morel/Ml.java.Ml.[Ml]assertEvalIter(Matcher<Iterable<E>>)", "src/test/java/net/hydromatic/morel/Ml.java.Ml.[Ml]assertEval(Matcher<Object>)", "src/test/java/net/hydromatic/morel/Ml.java.Ml.[Ml]assertEval()", "src/test/java/net/hydromatic/morel/Ml.java.Ml.[Ml]assertEvalThrows(Function<Pos, Matcher<Throwable>>)", "src/test/java/net/hydromatic/morel/Ml.java.Ml.[Object]eval(Session,Environment,TypeSystem,AstNode,Calcite)", "src/test/java/net/hydromatic/morel/Ml.java.Ml.[Object]bindingValue(List<Binding>,String)", "src/test/java/net/hydromatic/morel/Ml.java.Ml.[Ml]assertCompileException(Function<Pos, Matcher<CompileException>>)", "src/test/java/net/hydromatic/morel/Ml.java.Ml.[Ml]assertEvalError(Function<Pos, Matcher<Throwable>>)", "src/test/java/net/hydromatic/morel/Ml.java.Ml.[Ml]assertEvalWarnings(Matcher<List<Throwable>>)", "src/test/java/net/hydromatic/morel/Ml.java.Ml.[Ml]assertEvalSame()", "src/test/java/net/hydromatic/morel/Ml.java.Ml.[Ml]assertError(Matcher<String>)", "src/test/java/net/hydromatic/morel/Ml.java.Ml.[Ml]assertError(String)", "src/test/java/net/hydromatic/morel/Ml.java.Ml.[Ml]withBinding(String,DataSet)", "src/test/java/net/hydromatic/morel/Ml.java.Ml.[Ml]with(Prop,Object)", "src/test/java/net/hydromatic/morel/Ml.java.Ml.[Ml]withTracer(Tracer)", "src/test/java/net/hydromatic/morel/Ml.java.Ml.[Ml]withTypeExceptionMatcher(Matcher<Throwable>)", "src/test/java/net/hydromatic/morel/Ml.java.Ml.[Ml]withResultMatcher(Matcher<Object>)", "src/test/java/net/hydromatic/morel/Ml.java.Ml.[Ml]withWarningsMatcher(Matcher<List<Throwable>>)", "src/test/java/net/hydromatic/morel/Ml.java.Ml.[Ml]withExceptionMatcher(Function<Pos, Matcher<Throwable>>)", "src/test/java/net/hydromatic/morel/Ml.java.Ml.[Ml]withCompileExceptionMatcher(Function<Pos, Matcher<CompileException>>)", "src/test/java/net/hydromatic/morel/Ml.java.Ml.[Ml]withTypeException(String)", "src/test/java/net/hydromatic/morel/Ml.java.Ml.[Consumer<T>]exceptionConsumer(Function<Pos, Matcher<T>>)", "src/test/java/net/hydromatic/morel/Ml.java.Ml.[Map<K, V>]plus(Map<K, V>,K,V)"], "overrides": null, "attributes": [], "class_docstring": " Fluent test helper.", "original_string": "class Ml {\n  private final String ml;\n  @Nullable private final Pos pos;\n  private final Map<String, DataSet> dataSetMap;\n  private final Map<Prop, Object> propMap;\n  private final Tracer tracer;\n\n  Ml(String ml, @Nullable Pos pos, Map<String, DataSet> dataSetMap,\n      Map<Prop, Object> propMap, Tracer tracer) {\n    this.ml = ml;\n    this.pos = pos;\n    this.dataSetMap = ImmutableMap.copyOf(dataSetMap);\n    this.propMap = ImmutableMap.copyOf(propMap);\n    this.tracer = tracer;\n  }\n\n  /** Creates an {@code Ml}. */\n  static Ml ml(String ml) {\n    return new Ml(ml, null, ImmutableMap.of(), ImmutableMap.of(),\n        Tracers.empty());\n  }\n\n  /** Creates an {@code Ml} with an error position in it. */\n  static Ml ml(String ml, char delimiter) {\n    Pair<String, Pos> pair = Pos.split(ml, delimiter, \"stdIn\");\n    return new Ml(pair.left, pair.right, ImmutableMap.of(), ImmutableMap.of(),\n        Tracers.empty());\n  }\n\n  /** Runs a task and checks that it throws an exception.\n   *\n   * @param runnable Task to run\n   * @param matcher Checks whether exception is as expected\n   */\n  static void assertError(Runnable runnable,\n      Matcher<Throwable> matcher) {\n    try {\n      runnable.run();\n      fail(\"expected error\");\n    } catch (Throwable e) {\n      assertThat(e, matcher);\n    }\n  }\n\n  Ml withParser(Consumer<MorelParserImpl> action) {\n    final MorelParserImpl parser = new MorelParserImpl(new StringReader(ml));\n    action.accept(parser);\n    return this;\n  }\n\n  Ml assertParseLiteral(Matcher<Ast.Literal> matcher) {\n    return withParser(parser -> {\n      try {\n        final Ast.Literal literal = parser.literalEof();\n        assertThat(literal, matcher);\n      } catch (ParseException e) {\n        throw new RuntimeException(e);\n      }\n    });\n  }\n\n  Ml assertParseDecl(Matcher<Ast.Decl> matcher) {\n    return withParser(parser -> {\n      try {\n        final Ast.Decl decl = parser.declEof();\n        assertThat(decl, matcher);\n      } catch (ParseException e) {\n        throw new RuntimeException(e);\n      }\n    });\n  }\n\n  Ml assertParseDecl(Class<? extends Ast.Decl> clazz,\n      String expected) {\n    return assertParseDecl(isAst(clazz, false, expected));\n  }\n\n  Ml assertParseStmt(Matcher<AstNode> matcher) {\n    return withParser(parser -> {\n      try {\n        final AstNode statement = parser.statementEof();\n        assertThat(statement, matcher);\n      } catch (ParseException e) {\n        throw new RuntimeException(e);\n      }\n    });\n  }\n\n  Ml assertParseStmt(Class<? extends AstNode> clazz,\n      String expected) {\n    return assertParseStmt(isAst(clazz, false, expected));\n  }\n\n  /** Checks that an expression can be parsed and returns the given string\n   * when unparsed. */\n  Ml assertParse(String expected) {\n    return assertParse(false, expected);\n  }\n\n  /** Checks that an expression can be parsed and returns the given string\n   * when unparsed, optionally with full parentheses. */\n  Ml assertParse(boolean parenthesized, String expected) {\n    return assertParseStmt(isAst(AstNode.class, parenthesized, expected));\n  }\n\n  /** Checks that an expression can be parsed and returns the identical\n   * expression when unparsed. */\n  Ml assertParseSame() {\n    return assertParse(ml.replaceAll(\"[\\n ]+\", \" \"));\n  }\n\n  Ml assertParseThrowsParseException(Matcher<String> matcher) {\n    return assertParseThrows(throwsA(ParseException.class, matcher));\n  }\n\n  Ml assertParseThrowsIllegalArgumentException(Matcher<String> matcher) {\n    return assertParseThrows(throwsA(IllegalArgumentException.class, matcher));\n  }\n\n  Ml assertParseThrows(Matcher<Throwable> matcher) {\n    try {\n      final MorelParserImpl parser = new MorelParserImpl(new StringReader(ml));\n      final AstNode statement = parser.statementEof();\n      fail(\"expected error, got \" + statement);\n    } catch (Throwable e) {\n      assertThat(e, matcher);\n    }\n    return this;\n  }\n\n  private Ml withValidate(BiConsumer<TypeResolver.Resolved, Calcite> action) {\n    return withParser(parser -> {\n      final AstNode statement;\n      try {\n        parser.zero(\"stdIn\");\n        statement = parser.statementEof();\n      } catch (ParseException e) {\n        throw new RuntimeException(e);\n      }\n      final Calcite calcite = Calcite.withDataSets(dataSetMap);\n      try {\n        final TypeResolver.Resolved resolved =\n            Compiles.validateExpression(statement, propMap,\n                calcite.foreignValues());\n        tracer.handleCompileException(null);\n        action.accept(resolved, calcite);\n      } catch (TypeResolver.TypeException e) {\n        if (!tracer.onTypeException(e)) {\n          throw e;\n        }\n      } catch (CompileException e) {\n        if (!tracer.handleCompileException(e)) {\n          throw e;\n        }\n      }\n    });\n  }\n\n  Ml assertType(Matcher<Type> matcher) {\n    return withValidate((resolved, calcite) ->\n        assertThat(resolved.typeMap.getType(resolved.exp()), matcher));\n  }\n\n  Ml assertType(String expected) {\n    return assertType(hasMoniker(expected));\n  }\n\n  Ml assertTypeThrows(Function<Pos, Matcher<Throwable>> matcherSupplier) {\n    return assertTypeThrows(matcherSupplier.apply(pos));\n  }\n\n  Ml assertTypeThrows(Matcher<Throwable> matcher) {\n    assertError(() ->\n            withValidate((resolved, calcite) ->\n                fail(\"expected error\")),\n        matcher);\n    return this;\n  }\n\n  Ml assertTypeException(String message) {\n    return withTypeException(message)\n        .assertEval();\n  }\n\n  Ml withPrepare(Consumer<CompiledStatement> action) {\n    return withParser(parser -> {\n      try {\n        final TypeSystem typeSystem = new TypeSystem();\n        final AstNode statement = parser.statementEof();\n        final Environment env = Environments.empty();\n        final Session session = new Session(propMap);\n        final List<CompileException> warningList = new ArrayList<>();\n        final CompiledStatement compiled =\n            Compiles.prepareStatement(typeSystem, session, env, statement,\n                null, warningList::add, tracer);\n        action.accept(compiled);\n      } catch (ParseException e) {\n        throw new RuntimeException(e);\n      }\n    });\n  }\n\n  Ml assertCalcite(Matcher<String> matcher) {\n    try {\n      final MorelParserImpl parser = new MorelParserImpl(new StringReader(ml));\n      final AstNode statement = parser.statementEof();\n      final TypeSystem typeSystem = new TypeSystem();\n\n      final Calcite calcite = Calcite.withDataSets(dataSetMap);\n      final TypeResolver.Resolved resolved =\n          Compiles.validateExpression(statement, propMap,\n              calcite.foreignValues());\n      final Environment env = resolved.env;\n      final Ast.ValDecl valDecl2 = (Ast.ValDecl) resolved.node;\n      final Session session = null;\n      final Resolver resolver = Resolver.of(resolved.typeMap, env, session);\n      final Core.ValDecl valDecl3 = resolver.toCore(valDecl2);\n      assertThat(valDecl3, instanceOf(Core.NonRecValDecl.class));\n      final RelNode rel =\n          new CalciteCompiler(typeSystem, calcite)\n              .toRel(env, Compiles.toExp((Core.NonRecValDecl) valDecl3));\n      requireNonNull(rel);\n      final String relString = RelOptUtil.toString(rel);\n      assertThat(relString, matcher);\n      return this;\n    } catch (ParseException e) {\n      throw new RuntimeException(e);\n    }\n  }\n\n  /** Asserts that the Core string converts to the expected value.\n   *\n   * <p>For pass = 2, the Core string is generated after parsing the current\n   * expression and converting it to Core. Which is usually the original\n   * string. */\n  Ml assertCore(int pass, Matcher<Core.Decl> expected) {\n    final AtomicInteger callCount = new AtomicInteger(0);\n    final Consumer<Core.Decl> consumer = e -> {\n      callCount.incrementAndGet();\n      assertThat(e, expected);\n    };\n    final Tracer tracer = Tracers.withOnCore(this.tracer, pass, consumer);\n\n    final Consumer<Object> consumer2 = o ->\n        assertThat(\"core(\" + pass + \") was never called\",\n            callCount.get(), greaterThan(0));\n    final Tracer tracer2 = Tracers.withOnResult(tracer, consumer2);\n\n    return withTracer(tracer2).assertEval();\n  }\n\n  /** As {@link #assertCore(int, Matcher)} but also checks how the Core\n   * string has changed after inlining. */\n  public Ml assertCoreString(@Nullable Matcher<Core.Decl> beforeMatcher,\n      Matcher<Core.Decl> matcher,\n      @Nullable Matcher<Core.Decl> inlinedMatcher) {\n    return with(Prop.INLINE_PASS_COUNT, 10)\n        .with(Prop.RELATIONALIZE, true)\n        .assertCore(0, beforeMatcher)\n        .assertCore(2, matcher)\n        .assertCore(-1, inlinedMatcher);\n  }\n\n  Ml assertAnalyze(Matcher<Map<Core.NamedPat, Analyzer.Use>> matcher) {\n    final AstNode statement;\n    try {\n      final MorelParserImpl parser = new MorelParserImpl(new StringReader(ml));\n      statement = parser.statementEof();\n    } catch (ParseException parseException) {\n      throw new RuntimeException(parseException);\n    }\n    final TypeSystem typeSystem = new TypeSystem();\n\n    final Session session = null;\n    final Environment env =\n        Environments.env(typeSystem, session, ImmutableMap.of());\n    final Ast.ValDecl valDecl = Compiles.toValDecl(statement);\n    final TypeResolver.Resolved resolved =\n        TypeResolver.deduceType(env, valDecl, typeSystem);\n    final Ast.ValDecl valDecl2 = (Ast.ValDecl) resolved.node;\n    final Resolver resolver = Resolver.of(resolved.typeMap, env, null);\n    final Core.ValDecl valDecl3 = resolver.toCore(valDecl2);\n    final Analyzer.Analysis analysis =\n        Analyzer.analyze(typeSystem, env, valDecl3);\n    assertThat(ImmutableSortedMap.copyOf(analysis.map), matcher);\n    return this;\n  }\n\n  Ml assertMatchCoverage(MatchCoverage expectedCoverage) {\n    final Function<Pos, Matcher<Throwable>> exceptionMatcherFactory;\n    final Matcher<List<Throwable>> warningsMatcher;\n    switch (expectedCoverage) {\n    case OK:\n      // Expect no errors or warnings\n      exceptionMatcherFactory = null;\n      warningsMatcher = isEmptyList();\n      break;\n    case REDUNDANT:\n      exceptionMatcherFactory = pos -> throwsA(\"match redundant\", pos);\n      warningsMatcher = isEmptyList();\n      break;\n    case NON_EXHAUSTIVE_AND_REDUNDANT:\n      exceptionMatcherFactory = pos ->\n          throwsA(\"match nonexhaustive and redundant\", pos);\n      warningsMatcher = isEmptyList();\n      break;\n    case NON_EXHAUSTIVE:\n      exceptionMatcherFactory = null;\n      warningsMatcher =\n          new CustomTypeSafeMatcher<List<Throwable>>(\"non-empty list\") {\n            @Override protected boolean matchesSafely(List<Throwable> list) {\n              return list.stream()\n                  .anyMatch(e ->\n                      e instanceof CompileException\n                          && e.getMessage().equals(\"match nonexhaustive\"));\n            }\n          };\n      break;\n    default:\n      // Java doesn't know the switch is exhaustive; how ironic\n      throw new AssertionError(expectedCoverage);\n    }\n    return withResultMatcher(notNullValue())\n        .withWarningsMatcher(warningsMatcher)\n        .withExceptionMatcher(exceptionMatcherFactory)\n        .assertEval();\n  }\n\n  private static <E> Matcher<List<E>> isEmptyList() {\n    return new CustomTypeSafeMatcher<List<E>>(\"empty list\") {\n      @Override protected boolean matchesSafely(List<E> list) {\n        return list.isEmpty();\n      }\n    };\n  }\n\n  Ml assertPlan(Matcher<Code> planMatcher) {\n    final Consumer<Code> consumer = code ->\n        assertThat(code, planMatcher);\n    final Tracer tracer = Tracers.withOnPlan(this.tracer, consumer);\n    return withTracer(tracer).assertEval();\n  }\n\n  @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n  <E> Ml assertEvalIter(Matcher<Iterable<E>> matcher) {\n    return assertEval((Matcher) matcher);\n  }\n\n  Ml assertEval(Matcher<Object> resultMatcher) {\n    return withResultMatcher(resultMatcher).assertEval();\n  }\n\n  Ml assertEval() {\n    return withValidate((resolved, calcite) -> {\n      final Session session = new Session(propMap);\n      eval(session, resolved.env, resolved.typeMap.typeSystem, resolved.node,\n          calcite);\n    });\n  }\n\n  Ml assertEvalThrows(\n      Function<Pos, Matcher<Throwable>> exceptionMatcherFactory) {\n    return withExceptionMatcher(exceptionMatcherFactory).assertEval();\n  }\n\n  @CanIgnoreReturnValue\n  private <E extends Throwable> Object eval(Session session, Environment env,\n      TypeSystem typeSystem, AstNode statement, Calcite calcite) {\n    final List<Binding> bindings = new ArrayList<>();\n    final List<Throwable> warningList = new ArrayList<>();\n    try {\n      CompiledStatement compiledStatement =\n          Compiles.prepareStatement(typeSystem, session, env, statement,\n              calcite, warningList::add, tracer);\n      session.withoutHandlingExceptions(session1 ->\n          compiledStatement.eval(session1, env, line -> {}, bindings::add));\n      tracer.onException(null);\n    } catch (RuntimeException e) {\n      if (!tracer.onException(e)) {\n        throw e;\n      }\n    }\n    tracer.onWarnings(warningList);\n    final Object result;\n    if (statement instanceof Ast.Exp) {\n      result = bindingValue(bindings, \"it\");\n    } else if (bindings.size() == 1) {\n      result = bindings.get(0).value;\n    } else {\n      Map<String, Object> map = new LinkedHashMap<>();\n      bindings.forEach(b -> {\n        if (!b.id.name.equals(\"it\")) {\n          map.put(b.id.name, b.value);\n        }\n      });\n      result = map;\n    }\n    tracer.onResult(result);\n    tracer.onPlan(session.code);\n    return result;\n  }\n\n  private Object bindingValue(List<Binding> bindings, String name) {\n    for (Binding binding : bindings) {\n      if (binding.id.name.equals(name)) {\n        return binding.value;\n      }\n    }\n    return null;\n  }\n\n  Ml assertCompileException(\n      Function<Pos, Matcher<CompileException>> matcherSupplier) {\n    assertThat(pos, notNullValue());\n    return withResultMatcher(notNullValue())\n        .withCompileExceptionMatcher(matcherSupplier)\n        .assertEval();\n  }\n\n  Ml assertEvalError(Function<Pos, Matcher<Throwable>> matcherSupplier) {\n    assertThat(pos, notNullValue());\n    return withResultMatcher(notNullValue())\n        .withExceptionMatcher(matcherSupplier)\n        .assertEval();\n  }\n\n  Ml assertEvalWarnings(Matcher<List<Throwable>> warningsMatcher) {\n    return withResultMatcher(notNullValue())\n        .withWarningsMatcher(warningsMatcher)\n        .assertEval();\n  }\n\n  Ml assertEvalSame() {\n    final Matchers.LearningMatcher<Object> resultMatcher =\n        Matchers.learning(Object.class);\n    return with(Prop.HYBRID, false)\n        .assertEval(resultMatcher)\n        .with(Prop.HYBRID, true)\n        .assertEval(Matchers.isUnordered(resultMatcher.get()));\n  }\n\n  Ml assertError(Matcher<String> matcher) {\n    // TODO: execute code, and check error occurs\n    return this;\n  }\n\n  Ml assertError(String expected) {\n    return assertError(is(expected));\n  }\n\n  Ml withBinding(String name, DataSet dataSet) {\n    return new Ml(ml, pos, plus(dataSetMap, name, dataSet), propMap, tracer);\n  }\n\n  Ml with(Prop prop, Object value) {\n    return new Ml(ml, pos, dataSetMap, plus(propMap, prop, value), tracer);\n  }\n\n  Ml withTracer(Tracer tracer) {\n    return new Ml(ml, pos, dataSetMap, propMap, tracer);\n  }\n\n  Ml withTypeExceptionMatcher(Matcher<Throwable> matcher) {\n    final Consumer<TypeResolver.TypeException> consumer =\n        o -> assertThat(o, matcher);\n    return withTracer(Tracers.withOnTypeException(tracer, consumer));\n  }\n\n  Ml withResultMatcher(Matcher<Object> matcher) {\n    final Consumer<Object> consumer = o -> assertThat(o, matcher);\n    return withTracer(Tracers.withOnResult(this.tracer, consumer));\n  }\n\n  Ml withWarningsMatcher(Matcher<List<Throwable>> matcher) {\n    final Consumer<List<Throwable>> consumer = warningList ->\n        assertThat(warningList, matcher);\n    return withTracer(Tracers.withOnWarnings(this.tracer, consumer));\n  }\n\n  Ml withExceptionMatcher(\n      @Nullable Function<Pos, Matcher<Throwable>> matcherFactory) {\n    return withTracer(\n        Tracers.withOnException(this.tracer,\n            exceptionConsumer(matcherFactory)));\n  }\n\n  Ml withCompileExceptionMatcher(\n      @Nullable Function<Pos, Matcher<CompileException>> matcherFactory) {\n    return withTracer(\n        Tracers.withOnCompileException(this.tracer,\n            exceptionConsumer(matcherFactory)));\n  }\n\n  Ml withTypeException(String message) {\n    return withTypeExceptionMatcher(throwsA(message));\n  }\n\n  private <T extends Throwable> Consumer<T> exceptionConsumer(\n      Function<Pos, Matcher<T>> exceptionMatcherFactory) {\n    @Nullable Matcher<T> matcher =\n        exceptionMatcherFactory == null\n            ? null\n            : exceptionMatcherFactory.apply(pos);\n    return e -> {\n      if (e != null) {\n        if (matcher != null) {\n          assertThat(e, matcher);\n        } else {\n          if (e instanceof RuntimeException) {\n            throw (RuntimeException) e;\n          }\n          if (e instanceof Error) {\n            throw (Error) e;\n          }\n          throw new RuntimeException(e);\n        }\n      } else {\n        if (matcher != null) {\n          fail(\"expected exception, but none was thrown\");\n        }\n      }\n    };\n  }\n\n  /** Returns a map plus (adding or overwriting) one (key, value) entry. */\n  private static <K, V> Map<K, V> plus(Map<K, V> map, K k, V v) {\n    final ImmutableMap.Builder<K, V> builder = ImmutableMap.builder();\n    if (map.containsKey(k)) {\n      map.forEach((k2, v2) -> {\n        if (!k2.equals(k)) {\n          builder.put(k, v);\n        }\n      });\n    } else {\n      builder.putAll(map);\n    }\n    builder.put(k, v);\n    return builder.build();\n  }\n\n  /** Whether a list of patterns is exhaustive (covers all possible input\n   * values), redundant (covers some input values more than once), both or\n   * neither. */\n  enum MatchCoverage {\n    NON_EXHAUSTIVE,\n    REDUNDANT,\n    NON_EXHAUSTIVE_AND_REDUNDANT,\n    OK\n  }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private final String ml;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "ml", "syntax_pass": true}, {"attribute_expression": "@Nullable private final Pos pos;", "docstring": "", "modifiers": "@Nullable private final", "marker_annotations": ["@Nullable"], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Pos", "name": "pos", "syntax_pass": true}, {"attribute_expression": "private final Map<String, DataSet> dataSetMap;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Map<String, DataSet>", "name": "dataSetMap", "syntax_pass": true}, {"attribute_expression": "private final Map<Prop, Object> propMap;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Map<Prop, Object>", "name": "propMap", "syntax_pass": true}, {"attribute_expression": "private final Tracer tracer;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Tracer", "name": "tracer", "syntax_pass": true}]}, {"uris": "src/test/java/net/hydromatic/morel/TestUtils.java.TestUtils", "name": "TestUtils", "file_path": "src/test/java/net/hydromatic/morel/TestUtils.java", "superclasses": "", "methods": ["[]TestUtils()", "[String]u2n(String)", "[String]n2u(String)", "[E]first(E,E)", "[String]toCamelCase(String)", "[File]urlToFile(URL)", "[File]findDirectory()", "[void]discard(boolean)", "[PrintWriter]printWriter(OutputStream)", "[PrintWriter]printWriter(File)", "[BufferedReader]reader(InputStream)", "[BufferedReader]reader(File)", "[String]diff(File,File)", "[String]diffLines(List<String>,List<String>)", "[List<String>]fileLines(File)", "[ImmutableList<E>]plus(List<E>,E)"], "method_uris": ["src/test/java/net/hydromatic/morel/TestUtils.java.TestUtils.[]TestUtils()", "src/test/java/net/hydromatic/morel/TestUtils.java.TestUtils.[String]u2n(String)", "src/test/java/net/hydromatic/morel/TestUtils.java.TestUtils.[String]n2u(String)", "src/test/java/net/hydromatic/morel/TestUtils.java.TestUtils.[E]first(E,E)", "src/test/java/net/hydromatic/morel/TestUtils.java.TestUtils.[String]toCamelCase(String)", "src/test/java/net/hydromatic/morel/TestUtils.java.TestUtils.[File]urlToFile(URL)", "src/test/java/net/hydromatic/morel/TestUtils.java.TestUtils.[File]findDirectory()", "src/test/java/net/hydromatic/morel/TestUtils.java.TestUtils.[void]discard(boolean)", "src/test/java/net/hydromatic/morel/TestUtils.java.TestUtils.[PrintWriter]printWriter(OutputStream)", "src/test/java/net/hydromatic/morel/TestUtils.java.TestUtils.[PrintWriter]printWriter(File)", "src/test/java/net/hydromatic/morel/TestUtils.java.TestUtils.[BufferedReader]reader(InputStream)", "src/test/java/net/hydromatic/morel/TestUtils.java.TestUtils.[BufferedReader]reader(File)", "src/test/java/net/hydromatic/morel/TestUtils.java.TestUtils.[String]diff(File,File)", "src/test/java/net/hydromatic/morel/TestUtils.java.TestUtils.[String]diffLines(List<String>,List<String>)", "src/test/java/net/hydromatic/morel/TestUtils.java.TestUtils.[List<String>]fileLines(File)", "src/test/java/net/hydromatic/morel/TestUtils.java.TestUtils.[ImmutableList<E>]plus(List<E>,E)"], "overrides": null, "attributes": [], "class_docstring": " Utility methods for testing.", "original_string": "class TestUtils {\n  private TestUtils() {}\n\n  /** Converts a path from Unix to native.\n   *\n   * <p>On Windows, converts forward-slashes to back-slashes;\n   * on Linux, does nothing. */\n  public static String u2n(String s) {\n    return File.separatorChar == '\\\\'\n        ? s.replace('/', '\\\\')\n        : s;\n  }\n\n  /** Converts a path from native to Unix. */\n  public static String n2u(String s) {\n    return File.separatorChar == '\\\\' ? s.replace('\\\\', '/') : s;\n  }\n\n  public static <E> E first(E e0, E e1) {\n    return e0 != null ? e0 : e1;\n  }\n\n  public static String toCamelCase(String name) {\n    StringBuilder buf = new StringBuilder();\n    int nextUpper = -1;\n\n    for (int i = 0; i < name.length(); ++i) {\n      char c = name.charAt(i);\n      if (c == '_') {\n        nextUpper = i + 1;\n      } else {\n        if (nextUpper == i) {\n          c = Character.toUpperCase(c);\n        } else {\n          c = Character.toLowerCase(c);\n        }\n\n        buf.append(c);\n      }\n    }\n\n    return buf.toString();\n  }\n\n  public static File urlToFile(URL url) {\n    if (!\"file\".equals(url.getProtocol())) {\n      return null;\n    }\n    URI uri;\n    try {\n      uri = url.toURI();\n    } catch (URISyntaxException e) {\n      throw new IllegalArgumentException(\"Unable to convert URL \" + url\n          + \" to URI\", e);\n    }\n    if (uri.isOpaque()) {\n      // It is like file:test%20file.c++\n      // getSchemeSpecificPart would return \"test file.c++\"\n      return new File(uri.getSchemeSpecificPart());\n    }\n    // See https://stackoverflow.com/a/17870390/1261287\n    return Paths.get(uri).toFile();\n  }\n\n  /** Returns the root directory of test resources. */\n  static File findDirectory() {\n    final URL inUrl = MainTest.class.getResource(\"/\");\n    assertThat(inUrl, notNullValue());\n    return urlToFile(inUrl);\n  }\n\n  @SuppressWarnings(\"unused\")\n  public static void discard(boolean value) {\n  }\n\n  /** Creates a {@link PrintWriter} to a given output stream using UTF-8\n   * character set.\n   *\n   * <p>Does not use the default character set. */\n  public static PrintWriter printWriter(OutputStream out) {\n    return new PrintWriter(\n        new BufferedWriter(\n            new OutputStreamWriter(out, StandardCharsets.UTF_8)));\n  }\n\n  /** Creates a {@link PrintWriter} to a given file using UTF-8\n   * character set.\n   *\n   * <p>Does not use the default character set. */\n  public static PrintWriter printWriter(File file)\n      throws FileNotFoundException {\n    return printWriter(new FileOutputStream(file));\n  }\n\n  /** Creates a {@link BufferedReader} to a given input stream using UTF-8\n   * character set.\n   *\n   * <p>Does not use the default character set. */\n  public static BufferedReader reader(InputStream in) {\n    return new BufferedReader(\n        new InputStreamReader(in, StandardCharsets.UTF_8));\n  }\n\n  /** Creates a {@link BufferedReader} to read a given file using UTF-8\n   * character set.\n   *\n   * <p>Does not use the default character set. */\n  public static BufferedReader reader(File file)\n      throws FileNotFoundException {\n    return reader(new FileInputStream(file));\n  }\n\n  /** Returns a string containing the difference between the contents of two\n   * files. The string has a similar format to the UNIX 'diff' utility. */\n  public static String diff(File file1, File file2) {\n    List<String> lines1 = fileLines(file1);\n    List<String> lines2 = fileLines(file2);\n    return diffLines(lines1, lines2);\n  }\n\n  /** Returns a string containing the difference between the two sets of\n   * lines. */\n  public static String diffLines(List<String> lines1, List<String> lines2) {\n    final Diff<String> diff = new Diff<>(lines1, lines2);\n    final List<Difference> differences = diff.execute();\n    StringWriter sw = new StringWriter();\n    int offset = 0;\n    for (Difference d : differences) {\n      final int as = d.getAddedStart() + 1;\n      final int ae = d.getAddedEnd() + 1;\n      final int ds = d.getDeletedStart() + 1;\n      final int de = d.getDeletedEnd() + 1;\n      if (ae == 0) {\n        if (de == 0) {\n          // no change\n        } else {\n          // a deletion: \"<ds>,<de>d<as>\"\n          sw.append(String.valueOf(ds));\n          if (de > ds) {\n            sw.append(\",\").append(String.valueOf(de));\n          }\n          sw.append(\"d\").append(String.valueOf(as - 1)).append('\\n');\n          for (int i = ds - 1; i < de; ++i) {\n            sw.append(\"< \").append(lines1.get(i)).append('\\n');\n          }\n        }\n      } else {\n        if (de == 0) {\n          // an addition: \"<ds>a<as,ae>\"\n          sw.append(String.valueOf(ds - 1)).append(\"a\").append(\n              String.valueOf(as));\n          if (ae > as) {\n            sw.append(\",\").append(String.valueOf(ae));\n          }\n          sw.append('\\n');\n          for (int i = as - 1; i < ae; ++i) {\n            sw.append(\"> \").append(lines2.get(i)).append('\\n');\n          }\n        } else {\n          // a change: \"<ds>,<de>c<as>,<ae>\n          sw.append(String.valueOf(ds));\n          if (de > ds) {\n            sw.append(\",\").append(String.valueOf(de));\n          }\n          sw.append(\"c\").append(String.valueOf(as));\n          if (ae > as) {\n            sw.append(\",\").append(String.valueOf(ae));\n          }\n          sw.append('\\n');\n          for (int i = ds - 1; i < de; ++i) {\n            sw.append(\"< \").append(lines1.get(i)).append('\\n');\n          }\n          sw.append(\"---\\n\");\n          for (int i = as - 1; i < ae; ++i) {\n            sw.append(\"> \").append(lines2.get(i)).append('\\n');\n          }\n          offset = offset + (ae - as) - (de - ds);\n        }\n      }\n    }\n    return sw.toString();\n  }\n\n  /** Returns a list of the lines in a given file, or an empty list if the file\n   * does not exist.\n   *\n   * @param file File\n   * @return List of lines\n   */\n  private static List<String> fileLines(File file) {\n    List<String> lines = new ArrayList<>();\n    if (!file.exists()) {\n      return lines;\n    }\n    try (LineNumberReader r = new LineNumberReader(reader(file))) {\n      String line;\n      while ((line = r.readLine()) != null) {\n        lines.add(line);\n      }\n      return lines;\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n\n  /** Returns a list plus one element. */\n  public static <E> ImmutableList<E> plus(List<E> elements, E element) {\n    return ImmutableList.<E>builder()\n        .addAll(elements)\n        .add(element)\n        .build();\n  }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/main/java/net/hydromatic/morel/Main.java.Main", "name": "Main", "file_path": "src/main/java/net/hydromatic/morel/Main.java", "superclasses": "", "methods": ["[void]main(String[])", "[]Main(List<String>,InputStream,PrintStream,Map<String, ForeignValue>,Map<Prop, Object>,boolean)", "[]Main(List<String>,Reader,Writer,Map<String, ForeignValue>,Map<Prop, Object>,boolean)", "[void]readerToString(Reader,StringBuilder)", "[Reader]stripOutLines(Reader)", "[int]min()", "[PrintWriter]buffer(Writer)", "[BufferedReader]buffer(Reader)", "[void]run()"], "method_uris": ["src/main/java/net/hydromatic/morel/Main.java.Main.[void]main(String[])", "src/main/java/net/hydromatic/morel/Main.java.Main.[]Main(List<String>,InputStream,PrintStream,Map<String, ForeignValue>,Map<Prop, Object>,boolean)", "src/main/java/net/hydromatic/morel/Main.java.Main.[]Main(List<String>,Reader,Writer,Map<String, ForeignValue>,Map<Prop, Object>,boolean)", "src/main/java/net/hydromatic/morel/Main.java.Main.[void]readerToString(Reader,StringBuilder)", "src/main/java/net/hydromatic/morel/Main.java.Main.[Reader]stripOutLines(Reader)", "src/main/java/net/hydromatic/morel/Main.java.Main.[int]min()", "src/main/java/net/hydromatic/morel/Main.java.Main.[PrintWriter]buffer(Writer)", "src/main/java/net/hydromatic/morel/Main.java.Main.[BufferedReader]buffer(Reader)", "src/main/java/net/hydromatic/morel/Main.java.Main.[void]run()"], "overrides": null, "attributes": [{"original_string": "  static class Shell implements Session.Shell {\n    protected final Main main;\n    protected final Environment env0;\n    protected final Consumer<String> echoLines;\n    protected final Consumer<String> outLines;\n    protected final Map<String, Binding> bindingMap;\n\n    Shell(Main main, Environment env0, Consumer<String> echoLines,\n        Consumer<String> outLines, Map<String, Binding> bindingMap) {\n      this.main = main;\n      this.env0 = env0;\n      this.echoLines = echoLines;\n      this.outLines = outLines;\n      this.bindingMap = bindingMap;\n    }\n\n    void run(Session session, BufferingReader in2, Consumer<String> echoLines,\n        Consumer<String> outLines) {\n      final MorelParserImpl parser = new MorelParserImpl(in2);\n      final SubShell subShell =\n          new SubShell(main, echoLines, outLines, bindingMap, env0);\n      for (;;) {\n        try {\n          parser.zero(\"stdIn\");\n          final AstNode statement = parser.statementSemicolonOrEof();\n          String code = in2.flush();\n          if (main.idempotent) {\n            if (code.startsWith(\"\\n\")) {\n              code = code.substring(1);\n            }\n          }\n          if (statement == null && code.endsWith(\"\\n\")) {\n            code = code.substring(0, code.length() - 1);\n          }\n          if (main.echo) {\n            echoLines.accept(code);\n          }\n          if (statement == null) {\n            break;\n          }\n          session.withShell(subShell, outLines, session1 ->\n              subShell.command(statement, outLines));\n        } catch (ParseException e) {\n          final String message = e.getMessage();\n          if (message.startsWith(\"Encountered \\\"<EOF>\\\" \")) {\n            break;\n          }\n          String code = in2.flush();\n          if (main.echo) {\n            outLines.accept(code);\n          }\n          outLines.accept(message);\n          if (code.length() == 0) {\n            // If we consumed no input, we're not making progress, so we'll\n            // never finish. Abort.\n            break;\n          }\n        }\n      }\n    }\n\n    @Override public void use(String fileName, boolean silent, Pos pos) {\n      throw new UnsupportedOperationException();\n    }\n\n    @Override public void handle(RuntimeException e, StringBuilder buf) {\n      if (e instanceof MorelException) {\n        final MorelException me = (MorelException) e;\n        me.describeTo(buf)\n            .append(\"\\n\")\n            .append(\"  raised at: \");\n        me.pos().describeTo(buf);\n      } else {\n        buf.append(e);\n      }\n    }\n  }", "definition": "  static class Shell implements Session.Shell", "class_docstring": " Shell (or sub-shell created via\n{@link use net.hydromatic.morel.compile.BuiltIn#INTERACT_USE}) that can\nexecute commands and handle errors.", "name": "Shell", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "fields": [{"attribute_expression": "protected final Main main;", "docstring": "", "modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "type": "Main", "name": "main", "syntax_pass": true}, {"attribute_expression": "protected final Environment env0;", "docstring": "", "modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "type": "Environment", "name": "env0", "syntax_pass": true}, {"attribute_expression": "protected final Consumer<String> echoLines;", "docstring": "", "modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "type": "Consumer<String>", "name": "echoLines", "syntax_pass": true}, {"attribute_expression": "protected final Consumer<String> outLines;", "docstring": "", "modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "type": "Consumer<String>", "name": "outLines", "syntax_pass": true}, {"attribute_expression": "protected final Map<String, Binding> bindingMap;", "docstring": "", "modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "type": "Map<String, Binding>", "name": "bindingMap", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    Shell(Main main, Environment env0, Consumer<String> echoLines,\n        Consumer<String> outLines, Map<String, Binding> bindingMap) {\n      this.main = main;\n      this.env0 = env0;\n      this.echoLines = echoLines;\n      this.outLines = outLines;\n      this.bindingMap = bindingMap;\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "Shell", "params": [{"name": "main", "type": "Main"}, {"name": "env0", "type": "Environment"}, {"name": "echoLines", "type": "Consumer<String>"}, {"name": "outLines", "type": "Consumer<String>"}, {"name": "bindingMap", "type": "Map<String, Binding>"}], "body": "                                                                    {\n      this.main = main;\n      this.env0 = env0;\n      this.echoLines = echoLines;\n      this.outLines = outLines;\n      this.bindingMap = bindingMap;\n    }", "signature": "Shell(Main main, Environment env0, Consumer<String> echoLines,\n        Consumer<String> outLines, Map<String, Binding> bindingMap)"}, {"syntax_pass": true, "original_string": "    void run(Session session, BufferingReader in2, Consumer<String> echoLines,\n        Consumer<String> outLines) {\n      final MorelParserImpl parser = new MorelParserImpl(in2);\n      final SubShell subShell =\n          new SubShell(main, echoLines, outLines, bindingMap, env0);\n      for (;;) {\n        try {\n          parser.zero(\"stdIn\");\n          final AstNode statement = parser.statementSemicolonOrEof();\n          String code = in2.flush();\n          if (main.idempotent) {\n            if (code.startsWith(\"\\n\")) {\n              code = code.substring(1);\n            }\n          }\n          if (statement == null && code.endsWith(\"\\n\")) {\n            code = code.substring(0, code.length() - 1);\n          }\n          if (main.echo) {\n            echoLines.accept(code);\n          }\n          if (statement == null) {\n            break;\n          }\n          session.withShell(subShell, outLines, session1 ->\n              subShell.command(statement, outLines));\n        } catch (ParseException e) {\n          final String message = e.getMessage();\n          if (message.startsWith(\"Encountered \\\"<EOF>\\\" \")) {\n            break;\n          }\n          String code = in2.flush();\n          if (main.echo) {\n            outLines.accept(code);\n          }\n          outLines.accept(message);\n          if (code.length() == 0) {\n            // If we consumed no input, we're not making progress, so we'll\n            // never finish. Abort.\n            break;\n          }\n        }\n      }\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "name": "run", "params": [{"name": "session", "type": "Session"}, {"name": "in2", "type": "BufferingReader"}, {"name": "echoLines", "type": "Consumer<String>"}, {"name": "outLines", "type": "Consumer<String>"}], "body": "                                   {\n      final MorelParserImpl parser = new MorelParserImpl(in2);\n      final SubShell subShell =\n          new SubShell(main, echoLines, outLines, bindingMap, env0);\n      for (;;) {\n        try {\n          parser.zero(\"stdIn\");\n          final AstNode statement = parser.statementSemicolonOrEof();\n          String code = in2.flush();\n          if (main.idempotent) {\n            if (code.startsWith(\"\\n\")) {\n              code = code.substring(1);\n            }\n          }\n          if (statement == null && code.endsWith(\"\\n\")) {\n            code = code.substring(0, code.length() - 1);\n          }\n          if (main.echo) {\n            echoLines.accept(code);\n          }\n          if (statement == null) {\n            break;\n          }\n          session.withShell(subShell, outLines, session1 ->\n              subShell.command(statement, outLines));\n        } catch (ParseException e) {\n          final String message = e.getMessage();\n          if (message.startsWith(\"Encountered \\\"<EOF>\\\" \")) {\n            break;\n          }\n          String code = in2.flush();\n          if (main.echo) {\n            outLines.accept(code);\n          }\n          outLines.accept(message);\n          if (code.length() == 0) {\n            // If we consumed no input, we're not making progress, so we'll\n            // never finish. Abort.\n            break;\n          }\n        }\n      }\n    }", "signature": "void run(Session session, BufferingReader in2, Consumer<String> echoLines,\n        Consumer<String> outLines)"}, {"syntax_pass": true, "original_string": "    @Override public void use(String fileName, boolean silent, Pos pos) {\n      throw new UnsupportedOperationException();\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "use", "params": [{"name": "fileName", "type": "String"}, {"name": "silent", "type": "boolean"}, {"name": "pos", "type": "Pos"}], "body": "                                                                        {\n      throw new UnsupportedOperationException();\n    }", "signature": "@Override public void use(String fileName, boolean silent, Pos pos)"}, {"syntax_pass": true, "original_string": "    @Override public void handle(RuntimeException e, StringBuilder buf) {\n      if (e instanceof MorelException) {\n        final MorelException me = (MorelException) e;\n        me.describeTo(buf)\n            .append(\"\\n\")\n            .append(\"  raised at: \");\n        me.pos().describeTo(buf);\n      } else {\n        buf.append(e);\n      }\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "handle", "params": [{"name": "e", "type": "RuntimeException"}, {"name": "buf", "type": "StringBuilder"}], "body": "                                                                        {\n      if (e instanceof MorelException) {\n        final MorelException me = (MorelException) e;\n        me.describeTo(buf)\n            .append(\"\\n\")\n            .append(\"  raised at: \");\n        me.pos().describeTo(buf);\n      } else {\n        buf.append(e);\n      }\n    }", "signature": "@Override public void handle(RuntimeException e, StringBuilder buf)"}]}, {"original_string": "  static class SubShell extends Shell {\n\n    SubShell(Main main, Consumer<String> echoLines,\n        Consumer<String> outLines,\n        Map<String, Binding> outBindings, Environment env0) {\n      super(main, env0, echoLines, outLines, outBindings);\n    }\n\n    @Override public void use(String fileName, boolean silent, Pos pos) {\n      outLines.accept(\"[opening \" + fileName + \"]\");\n      File file = new File(fileName);\n      if (!file.isAbsolute()) {\n        final File directory =\n            Prop.SCRIPT_DIRECTORY.fileValue(main.session.map);\n        file = new File(directory, fileName);\n      }\n      if (!file.exists()) {\n        outLines.accept(\"[use failed: Io: openIn failed on \"\n            + fileName\n            + \", No such file or directory]\");\n        throw new Codes.MorelRuntimeException(Codes.BuiltInExn.ERROR, pos);\n      }\n      final Consumer<String> echoLines2 = silent ? line -> {} : echoLines;\n      final Consumer<String> outLines2 = silent ? line -> {} : outLines;\n      try (FileReader in = new FileReader(file);\n           Reader bufferedReader =\n               buffer(main.idempotent ? stripOutLines(in) : in)) {\n        run(main.session, new BufferingReader(bufferedReader), echoLines2,\n            outLines2);\n      } catch (IOException e) {\n        e.printStackTrace();\n      }\n    }\n\n    void command(AstNode statement, Consumer<String> outLines) {\n      try {\n        final Environment env = env0.bindAll(bindingMap.values());\n        final Tracer tracer = Tracers.empty();\n        final CompiledStatement compiled =\n            Compiles.prepareStatement(main.typeSystem, main.session, env,\n                statement, null, e -> appendToOutput(e, outLines), tracer);\n        final List<Binding> bindings = new ArrayList<>();\n        compiled.eval(main.session, env, outLines, bindings::add);\n        bindings.forEach(b -> this.bindingMap.put(b.id.name, b));\n      } catch (Codes.MorelRuntimeException e) {\n        appendToOutput(e, outLines);\n      }\n    }\n\n    private void appendToOutput(MorelException e, Consumer<String> outLines) {\n      final StringBuilder buf = new StringBuilder();\n      main.session.handle(e, buf);\n      outLines.accept(buf.toString());\n    }\n  }", "definition": "  static class SubShell extends Shell", "class_docstring": " Shell that is created via the\n{@link use net.hydromatic.morel.compile.BuiltIn#INTERACT_USE}) command.\nLike a top-level shell, it can execute commands and handle errors. But its\ninput is a file, and its output is to the same output as its parent\nshell.", "name": "SubShell", "super_interfaces": [], "superclasses": "Shell", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    SubShell(Main main, Consumer<String> echoLines,\n        Consumer<String> outLines,\n        Map<String, Binding> outBindings, Environment env0) {\n      super(main, env0, echoLines, outLines, outBindings);\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "SubShell", "params": [{"name": "main", "type": "Main"}, {"name": "echoLines", "type": "Consumer<String>"}, {"name": "outLines", "type": "Consumer<String>"}, {"name": "outBindings", "type": "Map<String, Binding>"}, {"name": "env0", "type": "Environment"}], "body": "                                                            {\n      super(main, env0, echoLines, outLines, outBindings);\n    }", "signature": "SubShell(Main main, Consumer<String> echoLines,\n        Consumer<String> outLines,\n        Map<String, Binding> outBindings, Environment env0)"}, {"syntax_pass": true, "original_string": "    @Override public void use(String fileName, boolean silent, Pos pos) {\n      outLines.accept(\"[opening \" + fileName + \"]\");\n      File file = new File(fileName);\n      if (!file.isAbsolute()) {\n        final File directory =\n            Prop.SCRIPT_DIRECTORY.fileValue(main.session.map);\n        file = new File(directory, fileName);\n      }\n      if (!file.exists()) {\n        outLines.accept(\"[use failed: Io: openIn failed on \"\n            + fileName\n            + \", No such file or directory]\");\n        throw new Codes.MorelRuntimeException(Codes.BuiltInExn.ERROR, pos);\n      }\n      final Consumer<String> echoLines2 = silent ? line -> {} : echoLines;\n      final Consumer<String> outLines2 = silent ? line -> {} : outLines;\n      try (FileReader in = new FileReader(file);\n           Reader bufferedReader =\n               buffer(main.idempotent ? stripOutLines(in) : in)) {\n        run(main.session, new BufferingReader(bufferedReader), echoLines2,\n            outLines2);\n      } catch (IOException e) {\n        e.printStackTrace();\n      }\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "use", "params": [{"name": "fileName", "type": "String"}, {"name": "silent", "type": "boolean"}, {"name": "pos", "type": "Pos"}], "body": "                                                                        {\n      outLines.accept(\"[opening \" + fileName + \"]\");\n      File file = new File(fileName);\n      if (!file.isAbsolute()) {\n        final File directory =\n            Prop.SCRIPT_DIRECTORY.fileValue(main.session.map);\n        file = new File(directory, fileName);\n      }\n      if (!file.exists()) {\n        outLines.accept(\"[use failed: Io: openIn failed on \"\n            + fileName\n            + \", No such file or directory]\");\n        throw new Codes.MorelRuntimeException(Codes.BuiltInExn.ERROR, pos);\n      }\n      final Consumer<String> echoLines2 = silent ? line -> {} : echoLines;\n      final Consumer<String> outLines2 = silent ? line -> {} : outLines;\n      try (FileReader in = new FileReader(file);\n           Reader bufferedReader =\n               buffer(main.idempotent ? stripOutLines(in) : in)) {\n        run(main.session, new BufferingReader(bufferedReader), echoLines2,\n            outLines2);\n      } catch (IOException e) {\n        e.printStackTrace();\n      }\n    }", "signature": "@Override public void use(String fileName, boolean silent, Pos pos)"}, {"syntax_pass": true, "original_string": "    void command(AstNode statement, Consumer<String> outLines) {\n      try {\n        final Environment env = env0.bindAll(bindingMap.values());\n        final Tracer tracer = Tracers.empty();\n        final CompiledStatement compiled =\n            Compiles.prepareStatement(main.typeSystem, main.session, env,\n                statement, null, e -> appendToOutput(e, outLines), tracer);\n        final List<Binding> bindings = new ArrayList<>();\n        compiled.eval(main.session, env, outLines, bindings::add);\n        bindings.forEach(b -> this.bindingMap.put(b.id.name, b));\n      } catch (Codes.MorelRuntimeException e) {\n        appendToOutput(e, outLines);\n      }\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "name": "command", "params": [{"name": "statement", "type": "AstNode"}, {"name": "outLines", "type": "Consumer<String>"}], "body": "                                                               {\n      try {\n        final Environment env = env0.bindAll(bindingMap.values());\n        final Tracer tracer = Tracers.empty();\n        final CompiledStatement compiled =\n            Compiles.prepareStatement(main.typeSystem, main.session, env,\n                statement, null, e -> appendToOutput(e, outLines), tracer);\n        final List<Binding> bindings = new ArrayList<>();\n        compiled.eval(main.session, env, outLines, bindings::add);\n        bindings.forEach(b -> this.bindingMap.put(b.id.name, b));\n      } catch (Codes.MorelRuntimeException e) {\n        appendToOutput(e, outLines);\n      }\n    }", "signature": "void command(AstNode statement, Consumer<String> outLines)"}, {"syntax_pass": true, "original_string": "    private void appendToOutput(MorelException e, Consumer<String> outLines) {\n      final StringBuilder buf = new StringBuilder();\n      main.session.handle(e, buf);\n      outLines.accept(buf.toString());\n    }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "name": "appendToOutput", "params": [{"name": "e", "type": "MorelException"}, {"name": "outLines", "type": "Consumer<String>"}], "body": "                                                                             {\n      final StringBuilder buf = new StringBuilder();\n      main.session.handle(e, buf);\n      outLines.accept(buf.toString());\n    }", "signature": "private void appendToOutput(MorelException e, Consumer<String> outLines)"}]}, {"original_string": "  static class BufferingReader extends FilterReader {\n    final StringBuilder buf = new StringBuilder();\n\n    protected BufferingReader(Reader in) {\n      super(in);\n    }\n\n    @Override public int read() throws IOException {\n      int c = super.read();\n      buf.append(c);\n      return c;\n    }\n\n    @Override public int read(char[] cbuf, int off, int len)\n        throws IOException {\n      int n = super.read(cbuf, off, 1);\n      if (n > 0) {\n        buf.append(cbuf, off, n);\n      }\n      return n;\n    }\n\n    public String flush() {\n      return str(buf);\n    }\n  }", "definition": "  static class BufferingReader extends FilterReader", "class_docstring": " Reader that snoops which characters have been read and saves\nthem in a buffer until {@link #flush} is called.", "name": "BufferingReader", "super_interfaces": [], "superclasses": "FilterReader", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "fields": [{"attribute_expression": "final StringBuilder buf = new StringBuilder();", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "StringBuilder", "name": "buf = new StringBuilder()", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    protected BufferingReader(Reader in) {\n      super(in);\n    }", "docstring": "", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "", "classes": []}, "name": "BufferingReader", "params": [{"name": "in", "type": "Reader"}], "body": "                                         {\n      super(in);\n    }", "signature": "protected BufferingReader(Reader in)"}, {"syntax_pass": true, "original_string": "    @Override public int read() throws IOException {\n      int c = super.read();\n      buf.append(c);\n      return c;\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "read", "params": [], "body": "                                                   {\n      int c = super.read();\n      buf.append(c);\n      return c;\n    }", "signature": "@Override public int read()"}, {"syntax_pass": true, "original_string": "    @Override public int read(char[] cbuf, int off, int len)\n        throws IOException {\n      int n = super.read(cbuf, off, 1);\n      if (n > 0) {\n        buf.append(cbuf, off, n);\n      }\n      return n;\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "read", "params": [{"name": "cbuf", "type": "char[]"}, {"name": "off", "type": "int"}, {"name": "len", "type": "int"}], "body": "                           {\n      int n = super.read(cbuf, off, 1);\n      if (n > 0) {\n        buf.append(cbuf, off, n);\n      }\n      return n;\n    }", "signature": "@Override public int read(char[] cbuf, int off, int len)"}, {"syntax_pass": true, "original_string": "    public String flush() {\n      return str(buf);\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "flush", "params": [], "body": "                          {\n      return str(buf);\n    }", "signature": "public String flush()"}]}], "class_docstring": " Standard ML REPL.", "original_string": "public class Main {\n  private final BufferedReader in;\n  private final PrintWriter out;\n  private final boolean echo;\n  private final Map<String, ForeignValue> valueMap;\n  final TypeSystem typeSystem = new TypeSystem();\n  final boolean idempotent;\n  final Session session;\n\n  /** Command-line entry point.\n   *\n   * @param args Command-line arguments */\n  public static void main(String[] args) {\n    final List<String> argList = ImmutableList.copyOf(args);\n    final Map<String, ForeignValue> valueMap = ImmutableMap.of();\n    final Map<Prop, Object> propMap = new LinkedHashMap<>();\n    Prop.DIRECTORY.set(propMap, new File(System.getProperty(\"user.dir\")));\n    final Main main =\n        new Main(argList, System.in, System.out, valueMap, propMap, false);\n    try {\n      main.run();\n    } catch (Throwable e) {\n      e.printStackTrace();\n      System.exit(1);\n    }\n  }\n\n  /** Creates a Main. */\n  public Main(List<String> args, InputStream in, PrintStream out,\n      Map<String, ForeignValue> valueMap, Map<Prop, Object> propMap,\n      boolean idempotent) {\n    this(args, new InputStreamReader(in), new OutputStreamWriter(out),\n        valueMap, propMap, idempotent);\n  }\n\n  /** Creates a Main. */\n  public Main(List<String> argList, Reader in, Writer out,\n      Map<String, ForeignValue> valueMap, Map<Prop, Object> propMap,\n      boolean idempotent) {\n    this.in = buffer(idempotent ? stripOutLines(in) : in);\n    this.out = buffer(out);\n    this.echo = argList.contains(\"--echo\");\n    this.valueMap = ImmutableMap.copyOf(valueMap);\n    this.session = new Session(propMap);\n    this.idempotent = idempotent;\n  }\n\n  private static void readerToString(Reader r, StringBuilder b) {\n    final char[] chars = new char[1024];\n    try {\n      for (;;) {\n        final int read = r.read(chars);\n        if (read < 0) {\n          return;\n        }\n        b.append(chars, 0, read);\n      }\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n\n  private static Reader stripOutLines(Reader in) {\n    final StringBuilder b = new StringBuilder();\n    readerToString(in, b);\n    final String s = str(b);\n    for (int i = 0, n = s.length();;) {\n      int j0 = i == 0 && s.startsWith(\"> \") ? 0 : -1;\n      int j1 = s.indexOf(\"\\n> \", i);\n      int j2 = s.indexOf(\"(*)\", i);\n      int j3 = s.indexOf(\"(*\", i);\n      int j = min(j0, j1, j2, j3);\n      if (j < 0) {\n        b.append(s, i, n);\n        break;\n      }\n      if (j == j0 || j == j1) {\n        // Skip line beginning \"> \"\n        b.append(s, i, j);\n        int k = s.indexOf(\"\\n\", j + 2);\n        if (k < 0) {\n          k = n;\n        }\n        i = k;\n      } else if (j == j2) {\n        // If a line contains \"(*)\", next search begins at the start of the\n        // next line.\n        int k = s.indexOf(\"\\n\", j + \"(*)\".length());\n        if (k < 0) {\n          k = n;\n        }\n        b.append(s, i, k);\n        i = k;\n      } else if (j == j3) {\n        // If a line contains \"(*\", next search begins at the next \"*)\".\n        int k = s.indexOf(\"*)\", j + \"(*\".length());\n        if (k < 0) {\n          k = n;\n        }\n        b.append(s, i, k);\n        i = k;\n      }\n    }\n    return new StringReader(b.toString());\n  }\n\n  /** Returns the minimum non-negative value of the list, or -1 if all are\n   * negative. */\n  private static int min(int... ints) {\n    int count = 0;\n    int min = Integer.MAX_VALUE;\n    for (int i : ints) {\n      if (i >= 0) {\n        ++count;\n        if (i < min) {\n          min = i;\n        }\n      }\n    }\n    return count == 0 ? -1 : min;\n  }\n\n  private static PrintWriter buffer(Writer out) {\n    if (out instanceof PrintWriter) {\n      return (PrintWriter) out;\n    } else {\n      if (!(out instanceof BufferedWriter)) {\n        out = new BufferedWriter(out);\n      }\n      return new PrintWriter(out);\n    }\n  }\n\n  private static BufferedReader buffer(Reader in) {\n    if (in instanceof BufferedReader) {\n      return (BufferedReader) in;\n    } else {\n      return new BufferedReader(in);\n    }\n  }\n\n  public void run() {\n    Environment env = Environments.env(typeSystem, session, valueMap);\n    final Consumer<String> echoLines = out::println;\n    final Consumer<String> outLines =\n        idempotent\n            ? x -> out.println(\"> \" + x.replace(\"\\n\", \"\\n> \"))\n            : echoLines;\n    final Map<String, Binding> outBindings = new LinkedHashMap<>();\n    final Shell shell = new Shell(this, env, echoLines, outLines, outBindings);\n    session.withShell(shell, outLines, session1 ->\n        shell.run(session1, new BufferingReader(in), echoLines, outLines));\n    out.flush();\n  }\n\n  /** Shell (or sub-shell created via\n   * {@link use net.hydromatic.morel.compile.BuiltIn#INTERACT_USE}) that can\n   * execute commands and handle errors. */\n  static class Shell implements Session.Shell {\n    protected final Main main;\n    protected final Environment env0;\n    protected final Consumer<String> echoLines;\n    protected final Consumer<String> outLines;\n    protected final Map<String, Binding> bindingMap;\n\n    Shell(Main main, Environment env0, Consumer<String> echoLines,\n        Consumer<String> outLines, Map<String, Binding> bindingMap) {\n      this.main = main;\n      this.env0 = env0;\n      this.echoLines = echoLines;\n      this.outLines = outLines;\n      this.bindingMap = bindingMap;\n    }\n\n    void run(Session session, BufferingReader in2, Consumer<String> echoLines,\n        Consumer<String> outLines) {\n      final MorelParserImpl parser = new MorelParserImpl(in2);\n      final SubShell subShell =\n          new SubShell(main, echoLines, outLines, bindingMap, env0);\n      for (;;) {\n        try {\n          parser.zero(\"stdIn\");\n          final AstNode statement = parser.statementSemicolonOrEof();\n          String code = in2.flush();\n          if (main.idempotent) {\n            if (code.startsWith(\"\\n\")) {\n              code = code.substring(1);\n            }\n          }\n          if (statement == null && code.endsWith(\"\\n\")) {\n            code = code.substring(0, code.length() - 1);\n          }\n          if (main.echo) {\n            echoLines.accept(code);\n          }\n          if (statement == null) {\n            break;\n          }\n          session.withShell(subShell, outLines, session1 ->\n              subShell.command(statement, outLines));\n        } catch (ParseException e) {\n          final String message = e.getMessage();\n          if (message.startsWith(\"Encountered \\\"<EOF>\\\" \")) {\n            break;\n          }\n          String code = in2.flush();\n          if (main.echo) {\n            outLines.accept(code);\n          }\n          outLines.accept(message);\n          if (code.length() == 0) {\n            // If we consumed no input, we're not making progress, so we'll\n            // never finish. Abort.\n            break;\n          }\n        }\n      }\n    }\n\n    @Override public void use(String fileName, boolean silent, Pos pos) {\n      throw new UnsupportedOperationException();\n    }\n\n    @Override public void handle(RuntimeException e, StringBuilder buf) {\n      if (e instanceof MorelException) {\n        final MorelException me = (MorelException) e;\n        me.describeTo(buf)\n            .append(\"\\n\")\n            .append(\"  raised at: \");\n        me.pos().describeTo(buf);\n      } else {\n        buf.append(e);\n      }\n    }\n  }\n\n  /** Shell that is created via the\n   * {@link use net.hydromatic.morel.compile.BuiltIn#INTERACT_USE}) command.\n   * Like a top-level shell, it can execute commands and handle errors. But its\n   * input is a file, and its output is to the same output as its parent\n   * shell. */\n  static class SubShell extends Shell {\n\n    SubShell(Main main, Consumer<String> echoLines,\n        Consumer<String> outLines,\n        Map<String, Binding> outBindings, Environment env0) {\n      super(main, env0, echoLines, outLines, outBindings);\n    }\n\n    @Override public void use(String fileName, boolean silent, Pos pos) {\n      outLines.accept(\"[opening \" + fileName + \"]\");\n      File file = new File(fileName);\n      if (!file.isAbsolute()) {\n        final File directory =\n            Prop.SCRIPT_DIRECTORY.fileValue(main.session.map);\n        file = new File(directory, fileName);\n      }\n      if (!file.exists()) {\n        outLines.accept(\"[use failed: Io: openIn failed on \"\n            + fileName\n            + \", No such file or directory]\");\n        throw new Codes.MorelRuntimeException(Codes.BuiltInExn.ERROR, pos);\n      }\n      final Consumer<String> echoLines2 = silent ? line -> {} : echoLines;\n      final Consumer<String> outLines2 = silent ? line -> {} : outLines;\n      try (FileReader in = new FileReader(file);\n           Reader bufferedReader =\n               buffer(main.idempotent ? stripOutLines(in) : in)) {\n        run(main.session, new BufferingReader(bufferedReader), echoLines2,\n            outLines2);\n      } catch (IOException e) {\n        e.printStackTrace();\n      }\n    }\n\n    void command(AstNode statement, Consumer<String> outLines) {\n      try {\n        final Environment env = env0.bindAll(bindingMap.values());\n        final Tracer tracer = Tracers.empty();\n        final CompiledStatement compiled =\n            Compiles.prepareStatement(main.typeSystem, main.session, env,\n                statement, null, e -> appendToOutput(e, outLines), tracer);\n        final List<Binding> bindings = new ArrayList<>();\n        compiled.eval(main.session, env, outLines, bindings::add);\n        bindings.forEach(b -> this.bindingMap.put(b.id.name, b));\n      } catch (Codes.MorelRuntimeException e) {\n        appendToOutput(e, outLines);\n      }\n    }\n\n    private void appendToOutput(MorelException e, Consumer<String> outLines) {\n      final StringBuilder buf = new StringBuilder();\n      main.session.handle(e, buf);\n      outLines.accept(buf.toString());\n    }\n  }\n\n  /** Reader that snoops which characters have been read and saves\n   * them in a buffer until {@link #flush} is called. */\n  static class BufferingReader extends FilterReader {\n    final StringBuilder buf = new StringBuilder();\n\n    protected BufferingReader(Reader in) {\n      super(in);\n    }\n\n    @Override public int read() throws IOException {\n      int c = super.read();\n      buf.append(c);\n      return c;\n    }\n\n    @Override public int read(char[] cbuf, int off, int len)\n        throws IOException {\n      int n = super.read(cbuf, off, 1);\n      if (n > 0) {\n        buf.append(cbuf, off, n);\n      }\n      return n;\n    }\n\n    public String flush() {\n      return str(buf);\n    }\n  }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private final BufferedReader in;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "BufferedReader", "name": "in", "syntax_pass": true}, {"attribute_expression": "private final PrintWriter out;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "PrintWriter", "name": "out", "syntax_pass": true}, {"attribute_expression": "private final boolean echo;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "boolean", "name": "echo", "syntax_pass": true}, {"attribute_expression": "private final Map<String, ForeignValue> valueMap;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Map<String, ForeignValue>", "name": "valueMap", "syntax_pass": true}, {"attribute_expression": "final TypeSystem typeSystem = new TypeSystem();", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "TypeSystem", "name": "typeSystem = new TypeSystem()", "syntax_pass": true}, {"attribute_expression": "final boolean idempotent;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "boolean", "name": "idempotent", "syntax_pass": true}, {"attribute_expression": "final Session session;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "Session", "name": "session", "syntax_pass": true}]}, {"uris": "src/main/java/net/hydromatic/morel/Shell.java.Shell", "name": "Shell", "file_path": "src/main/java/net/hydromatic/morel/Shell.java", "superclasses": "", "methods": ["[void]main(String[])", "[Shell]create(List<String>,InputStream,OutputStream)", "[Shell]create(Config,InputStream,OutputStream)", "[]Shell(Config,Terminal)", "[Config]parse(Config,List<String>)", "[void]usage(Consumer<String>)", "[void]help(Consumer<String>)", "[void]pause()", "[boolean]canIgnoreLine(StringBuilder,String)", "[String]banner()", "[void]run()", "[T]instantiate(String,Class<T>)"], "method_uris": ["src/main/java/net/hydromatic/morel/Shell.java.Shell.[void]main(String[])", "src/main/java/net/hydromatic/morel/Shell.java.Shell.[Shell]create(List<String>,InputStream,OutputStream)", "src/main/java/net/hydromatic/morel/Shell.java.Shell.[Shell]create(Config,InputStream,OutputStream)", "src/main/java/net/hydromatic/morel/Shell.java.Shell.[]Shell(Config,Terminal)", "src/main/java/net/hydromatic/morel/Shell.java.Shell.[Config]parse(Config,List<String>)", "src/main/java/net/hydromatic/morel/Shell.java.Shell.[void]usage(Consumer<String>)", "src/main/java/net/hydromatic/morel/Shell.java.Shell.[void]help(Consumer<String>)", "src/main/java/net/hydromatic/morel/Shell.java.Shell.[void]pause()", "src/main/java/net/hydromatic/morel/Shell.java.Shell.[boolean]canIgnoreLine(StringBuilder,String)", "src/main/java/net/hydromatic/morel/Shell.java.Shell.[String]banner()", "src/main/java/net/hydromatic/morel/Shell.java.Shell.[void]run()", "src/main/java/net/hydromatic/morel/Shell.java.Shell.[T]instantiate(String,Class<T>)"], "overrides": null, "attributes": [{"original_string": "  private static class ConfigImpl implements Config {\n    private final boolean banner;\n    private final boolean dumb;\n    private final boolean echo;\n    private final boolean help;\n    private final boolean system;\n    private final ImmutableMap<String, ForeignValue> valueMap;\n    private final File directory;\n    private final Runnable pauseFn;\n    private final int maxUseDepth;\n\n    private ConfigImpl(boolean banner, boolean dumb, boolean system,\n        boolean echo, boolean help, ImmutableMap<String, ForeignValue> valueMap,\n        File directory, Runnable pauseFn, int maxUseDepth) {\n      this.banner = banner;\n      this.dumb = dumb;\n      this.system = system;\n      this.echo = echo;\n      this.help = help;\n      this.valueMap = requireNonNull(valueMap, \"valueMap\");\n      this.directory = requireNonNull(directory, \"directory\");\n      this.pauseFn = requireNonNull(pauseFn, \"pauseFn\");\n      this.maxUseDepth = maxUseDepth;\n    }\n\n    @Override public ConfigImpl withBanner(boolean banner) {\n      if (this.banner == banner) {\n        return this;\n      }\n      return new ConfigImpl(banner, dumb, system, echo, help, valueMap,\n          directory, pauseFn, maxUseDepth);\n    }\n\n    @Override public ConfigImpl withDumb(boolean dumb) {\n      if (this.dumb == dumb) {\n        return this;\n      }\n      return new ConfigImpl(banner, dumb, system, echo, help, valueMap,\n          directory, pauseFn, maxUseDepth);\n    }\n\n    @Override public ConfigImpl withSystem(boolean system) {\n      if (this.system == system) {\n        return this;\n      }\n      return new ConfigImpl(banner, dumb, system, echo, help, valueMap,\n          directory, pauseFn, maxUseDepth);\n    }\n\n    @Override public ConfigImpl withEcho(boolean echo) {\n      if (this.echo == echo) {\n        return this;\n      }\n      return new ConfigImpl(banner, dumb, system, echo, help, valueMap,\n          directory, pauseFn, maxUseDepth);\n    }\n\n    @Override public ConfigImpl withHelp(boolean help) {\n      if (this.help == help) {\n        return this;\n      }\n      return new ConfigImpl(banner, dumb, system, echo, help, valueMap,\n          directory, pauseFn, maxUseDepth);\n    }\n\n    @Override public ConfigImpl withValueMap(\n        Map<String, ForeignValue> valueMap) {\n      if (this.valueMap.equals(valueMap)) {\n        return this;\n      }\n      final ImmutableMap<String, ForeignValue> immutableValueMap =\n          ImmutableMap.copyOf(valueMap);\n      return new ConfigImpl(banner, dumb, system, echo, help, immutableValueMap,\n          directory, pauseFn, maxUseDepth);\n    }\n\n    @Override public ConfigImpl withDirectory(File directory) {\n      if (this.directory.equals(directory)) {\n        return this;\n      }\n      return new ConfigImpl(banner, dumb, system, echo, help, valueMap,\n          directory, pauseFn, maxUseDepth);\n    }\n\n    @Override public Config withPauseFn(Runnable pauseFn) {\n      if (this.pauseFn.equals(pauseFn)) {\n        return this;\n      }\n      return new ConfigImpl(banner, dumb, system, echo, help, valueMap,\n          directory, pauseFn, maxUseDepth);\n    }\n\n    @Override public ConfigImpl withMaxUseDepth(int maxUseDepth) {\n      if (this.maxUseDepth == maxUseDepth) {\n        return this;\n      }\n      return new ConfigImpl(banner, dumb, system, echo, help, valueMap,\n          directory, pauseFn, maxUseDepth);\n    }\n  }", "definition": "  private static class ConfigImpl implements Config", "class_docstring": " Implementation of {@link Config}.", "name": "ConfigImpl", "super_interfaces": ["Config"], "superclasses": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "fields": [{"attribute_expression": "private final boolean banner;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "boolean", "name": "banner", "syntax_pass": true}, {"attribute_expression": "private final boolean dumb;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "boolean", "name": "dumb", "syntax_pass": true}, {"attribute_expression": "private final boolean echo;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "boolean", "name": "echo", "syntax_pass": true}, {"attribute_expression": "private final boolean help;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "boolean", "name": "help", "syntax_pass": true}, {"attribute_expression": "private final boolean system;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "boolean", "name": "system", "syntax_pass": true}, {"attribute_expression": "private final ImmutableMap<String, ForeignValue> valueMap;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "ImmutableMap<String, ForeignValue>", "name": "valueMap", "syntax_pass": true}, {"attribute_expression": "private final File directory;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "File", "name": "directory", "syntax_pass": true}, {"attribute_expression": "private final Runnable pauseFn;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Runnable", "name": "pauseFn", "syntax_pass": true}, {"attribute_expression": "private final int maxUseDepth;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "int", "name": "maxUseDepth", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    private ConfigImpl(boolean banner, boolean dumb, boolean system,\n        boolean echo, boolean help, ImmutableMap<String, ForeignValue> valueMap,\n        File directory, Runnable pauseFn, int maxUseDepth) {\n      this.banner = banner;\n      this.dumb = dumb;\n      this.system = system;\n      this.echo = echo;\n      this.help = help;\n      this.valueMap = requireNonNull(valueMap, \"valueMap\");\n      this.directory = requireNonNull(directory, \"directory\");\n      this.pauseFn = requireNonNull(pauseFn, \"pauseFn\");\n      this.maxUseDepth = maxUseDepth;\n    }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "", "classes": []}, "name": "ConfigImpl", "params": [{"name": "banner", "type": "boolean"}, {"name": "dumb", "type": "boolean"}, {"name": "system", "type": "boolean"}, {"name": "echo", "type": "boolean"}, {"name": "help", "type": "boolean"}, {"name": "valueMap", "type": "ImmutableMap<String, ForeignValue>"}, {"name": "directory", "type": "File"}, {"name": "pauseFn", "type": "Runnable"}, {"name": "maxUseDepth", "type": "int"}], "body": "                                                           {\n      this.banner = banner;\n      this.dumb = dumb;\n      this.system = system;\n      this.echo = echo;\n      this.help = help;\n      this.valueMap = requireNonNull(valueMap, \"valueMap\");\n      this.directory = requireNonNull(directory, \"directory\");\n      this.pauseFn = requireNonNull(pauseFn, \"pauseFn\");\n      this.maxUseDepth = maxUseDepth;\n    }", "signature": "private ConfigImpl(boolean banner, boolean dumb, boolean system,\n        boolean echo, boolean help, ImmutableMap<String, ForeignValue> valueMap,\n        File directory, Runnable pauseFn, int maxUseDepth)"}, {"syntax_pass": true, "original_string": "    @Override public ConfigImpl withBanner(boolean banner) {\n      if (this.banner == banner) {\n        return this;\n      }\n      return new ConfigImpl(banner, dumb, system, echo, help, valueMap,\n          directory, pauseFn, maxUseDepth);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "ConfigImpl", "classes": []}, "name": "withBanner", "params": [{"name": "banner", "type": "boolean"}], "body": "                                                           {\n      if (this.banner == banner) {\n        return this;\n      }\n      return new ConfigImpl(banner, dumb, system, echo, help, valueMap,\n          directory, pauseFn, maxUseDepth);\n    }", "signature": "@Override public ConfigImpl withBanner(boolean banner)"}, {"syntax_pass": true, "original_string": "    @Override public ConfigImpl withDumb(boolean dumb) {\n      if (this.dumb == dumb) {\n        return this;\n      }\n      return new ConfigImpl(banner, dumb, system, echo, help, valueMap,\n          directory, pauseFn, maxUseDepth);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "ConfigImpl", "classes": []}, "name": "withDumb", "params": [{"name": "dumb", "type": "boolean"}], "body": "                                                       {\n      if (this.dumb == dumb) {\n        return this;\n      }\n      return new ConfigImpl(banner, dumb, system, echo, help, valueMap,\n          directory, pauseFn, maxUseDepth);\n    }", "signature": "@Override public ConfigImpl withDumb(boolean dumb)"}, {"syntax_pass": true, "original_string": "    @Override public ConfigImpl withSystem(boolean system) {\n      if (this.system == system) {\n        return this;\n      }\n      return new ConfigImpl(banner, dumb, system, echo, help, valueMap,\n          directory, pauseFn, maxUseDepth);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "ConfigImpl", "classes": []}, "name": "withSystem", "params": [{"name": "system", "type": "boolean"}], "body": "                                                           {\n      if (this.system == system) {\n        return this;\n      }\n      return new ConfigImpl(banner, dumb, system, echo, help, valueMap,\n          directory, pauseFn, maxUseDepth);\n    }", "signature": "@Override public ConfigImpl withSystem(boolean system)"}, {"syntax_pass": true, "original_string": "    @Override public ConfigImpl withEcho(boolean echo) {\n      if (this.echo == echo) {\n        return this;\n      }\n      return new ConfigImpl(banner, dumb, system, echo, help, valueMap,\n          directory, pauseFn, maxUseDepth);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "ConfigImpl", "classes": []}, "name": "withEcho", "params": [{"name": "echo", "type": "boolean"}], "body": "                                                       {\n      if (this.echo == echo) {\n        return this;\n      }\n      return new ConfigImpl(banner, dumb, system, echo, help, valueMap,\n          directory, pauseFn, maxUseDepth);\n    }", "signature": "@Override public ConfigImpl withEcho(boolean echo)"}, {"syntax_pass": true, "original_string": "    @Override public ConfigImpl withHelp(boolean help) {\n      if (this.help == help) {\n        return this;\n      }\n      return new ConfigImpl(banner, dumb, system, echo, help, valueMap,\n          directory, pauseFn, maxUseDepth);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "ConfigImpl", "classes": []}, "name": "withHelp", "params": [{"name": "help", "type": "boolean"}], "body": "                                                       {\n      if (this.help == help) {\n        return this;\n      }\n      return new ConfigImpl(banner, dumb, system, echo, help, valueMap,\n          directory, pauseFn, maxUseDepth);\n    }", "signature": "@Override public ConfigImpl withHelp(boolean help)"}, {"syntax_pass": true, "original_string": "    @Override public ConfigImpl withValueMap(\n        Map<String, ForeignValue> valueMap) {\n      if (this.valueMap.equals(valueMap)) {\n        return this;\n      }\n      final ImmutableMap<String, ForeignValue> immutableValueMap =\n          ImmutableMap.copyOf(valueMap);\n      return new ConfigImpl(banner, dumb, system, echo, help, immutableValueMap,\n          directory, pauseFn, maxUseDepth);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "ConfigImpl", "classes": []}, "name": "withValueMap", "params": [{"name": "valueMap", "type": "Map<String, ForeignValue>"}], "body": "                                            {\n      if (this.valueMap.equals(valueMap)) {\n        return this;\n      }\n      final ImmutableMap<String, ForeignValue> immutableValueMap =\n          ImmutableMap.copyOf(valueMap);\n      return new ConfigImpl(banner, dumb, system, echo, help, immutableValueMap,\n          directory, pauseFn, maxUseDepth);\n    }", "signature": "@Override public ConfigImpl withValueMap(\n        Map<String, ForeignValue> valueMap)"}, {"syntax_pass": true, "original_string": "    @Override public ConfigImpl withDirectory(File directory) {\n      if (this.directory.equals(directory)) {\n        return this;\n      }\n      return new ConfigImpl(banner, dumb, system, echo, help, valueMap,\n          directory, pauseFn, maxUseDepth);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "ConfigImpl", "classes": []}, "name": "withDirectory", "params": [{"name": "directory", "type": "File"}], "body": "                                                              {\n      if (this.directory.equals(directory)) {\n        return this;\n      }\n      return new ConfigImpl(banner, dumb, system, echo, help, valueMap,\n          directory, pauseFn, maxUseDepth);\n    }", "signature": "@Override public ConfigImpl withDirectory(File directory)"}, {"syntax_pass": true, "original_string": "    @Override public Config withPauseFn(Runnable pauseFn) {\n      if (this.pauseFn.equals(pauseFn)) {\n        return this;\n      }\n      return new ConfigImpl(banner, dumb, system, echo, help, valueMap,\n          directory, pauseFn, maxUseDepth);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Config", "classes": []}, "name": "withPauseFn", "params": [{"name": "pauseFn", "type": "Runnable"}], "body": "                                                          {\n      if (this.pauseFn.equals(pauseFn)) {\n        return this;\n      }\n      return new ConfigImpl(banner, dumb, system, echo, help, valueMap,\n          directory, pauseFn, maxUseDepth);\n    }", "signature": "@Override public Config withPauseFn(Runnable pauseFn)"}, {"syntax_pass": true, "original_string": "    @Override public ConfigImpl withMaxUseDepth(int maxUseDepth) {\n      if (this.maxUseDepth == maxUseDepth) {\n        return this;\n      }\n      return new ConfigImpl(banner, dumb, system, echo, help, valueMap,\n          directory, pauseFn, maxUseDepth);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "ConfigImpl", "classes": []}, "name": "withMaxUseDepth", "params": [{"name": "maxUseDepth", "type": "int"}], "body": "                                                                 {\n      if (this.maxUseDepth == maxUseDepth) {\n        return this;\n      }\n      return new ConfigImpl(banner, dumb, system, echo, help, valueMap,\n          directory, pauseFn, maxUseDepth);\n    }", "signature": "@Override public ConfigImpl withMaxUseDepth(int maxUseDepth)"}]}, {"original_string": "  static class SubShell {\n    private final int depth;\n    private final int maxDepth;\n    private final LineFn lineFn;\n    private final boolean echo;\n    private final TypeSystem typeSystem;\n    private final Environment env;\n    private final Consumer<String> outLines;\n    private final Session session;\n    private final File directory;\n\n    SubShell(int depth, int maxDepth, LineFn lineFn,\n        boolean echo, TypeSystem typeSystem, Environment env,\n        Consumer<String> outLines, Session session, File directory) {\n      this.depth = depth;\n      this.maxDepth = maxDepth;\n      this.lineFn = lineFn;\n      this.echo = echo;\n      this.typeSystem = typeSystem;\n      this.env = env;\n      this.outLines = outLines;\n      this.session = session;\n      this.directory = directory;\n    }\n\n    void extracted(@Nullable Map<String, Binding> outBindings) {\n      final StringBuilder buf = new StringBuilder();\n      final Map<String, Binding> bindingMap = new LinkedHashMap<>();\n      final List<Binding> bindings = new ArrayList<>();\n      Environment env1 = env;\n      for (;;) {\n        final Pair<LineType, String> line = lineFn.read(buf);\n        switch (line.left) {\n        case EOF:\n        case QUIT:\n          return;\n\n        case IGNORE:\n          continue;\n\n        case HELP:\n          help(outLines);\n          buf.append(line.right).append(\"\\n\");\n          break;\n\n        case REGULAR:\n          try {\n            buf.append(line.right);\n            if (line.right.endsWith(\";\")) {\n              final String code = str(buf);\n              final MorelParserImpl smlParser =\n                  new MorelParserImpl(new StringReader(code));\n              final AstNode statement;\n              try {\n                smlParser.zero(\"stdIn\");\n                statement = smlParser.statementSemicolon();\n                final Environment env0 = env1;\n                final List<CompileException> warningList = new ArrayList<>();\n                final Tracer tracer = Tracers.empty();\n                final CompiledStatement compiled =\n                    Compiles.prepareStatement(typeSystem, session, env0,\n                        statement, null, warningList::add, tracer);\n                final Use shell = new Use(env0, bindingMap);\n                session.withShell(shell, outLines, session1 ->\n                    compiled.eval(session1, env0, outLines, bindings::add));\n                bindings.forEach(b -> bindingMap.put(b.id.name, b));\n                env1 = env0.bindAll(bindingMap.values());\n                if (outBindings != null) {\n                  outBindings.putAll(bindingMap);\n                }\n                bindingMap.clear();\n                bindings.clear();\n              } catch (ParseException | CompileException e) {\n                outLines.accept(e.getMessage());\n              }\n              if (echo) {\n                outLines.accept(code);\n              }\n            } else {\n              buf.append(\"\\n\");\n            }\n          } catch (IllegalArgumentException e) {\n            outLines.accept(e.getMessage());\n          }\n        }\n      }\n    }\n\n    /** Implementation of the \"use\" function. */\n    private class Use implements Session.Shell {\n      private final Environment env;\n      private final Map<String, Binding> bindings;\n\n      Use(Environment env, Map<String, Binding> bindings) {\n        this.env = env;\n        this.bindings = bindings;\n      }\n\n      @Override public void use(String fileName, boolean silent, Pos pos) {\n        outLines.accept(\"[opening \" + fileName + \"]\");\n        File file = new File(fileName);\n        if (!file.isAbsolute()) {\n          file = new File(directory, fileName);\n        }\n        if (!file.exists()) {\n          outLines.accept(\"[use failed: Io: openIn failed on \"\n              + fileName\n              + \", No such file or directory]\");\n          throw new Codes.MorelRuntimeException(Codes.BuiltInExn.ERROR, pos);\n        }\n        if (depth > maxDepth && maxDepth >= 0) {\n          outLines.accept(\"[use failed: Io: openIn failed on \"\n              + fileName\n              + \", Too many open files]\");\n          throw new Codes.MorelRuntimeException(Codes.BuiltInExn.ERROR, pos);\n        }\n        try (FileReader fileReader = new FileReader(file);\n             BufferedReader bufferedReader = new BufferedReader(fileReader)) {\n          final SubShell subShell =\n              new SubShell(depth + 1, maxDepth, new ReaderLineFn(bufferedReader),\n                  false, typeSystem, env, outLines, session, directory);\n          subShell.extracted(bindings);\n        } catch (IOException e) {\n          e.printStackTrace();\n        }\n      }\n\n      @Override public void handle(RuntimeException e,\n          StringBuilder buf) {\n        if (depth != 1) {\n          throw e;\n        }\n        if (e instanceof MorelException) {\n          final MorelException me = (MorelException) e;\n          me.describeTo(buf)\n              .append(\"\\n\")\n              .append(\"  raised at: \");\n          me.pos().describeTo(buf);\n        } else {\n          buf.append(e);\n        }\n      }\n    }\n  }", "definition": "  static class SubShell", "class_docstring": " Simplified shell that works in both interactive mode (where input and\noutput is a terminal) and batch mode (where input is a file, and output\nis to an array of lines).", "name": "SubShell", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "fields": [{"attribute_expression": "private final int depth;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "int", "name": "depth", "syntax_pass": true}, {"attribute_expression": "private final int maxDepth;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "int", "name": "maxDepth", "syntax_pass": true}, {"attribute_expression": "private final LineFn lineFn;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "LineFn", "name": "lineFn", "syntax_pass": true}, {"attribute_expression": "private final boolean echo;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "boolean", "name": "echo", "syntax_pass": true}, {"attribute_expression": "private final TypeSystem typeSystem;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "TypeSystem", "name": "typeSystem", "syntax_pass": true}, {"attribute_expression": "private final Environment env;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Environment", "name": "env", "syntax_pass": true}, {"attribute_expression": "private final Consumer<String> outLines;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Consumer<String>", "name": "outLines", "syntax_pass": true}, {"attribute_expression": "private final Session session;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Session", "name": "session", "syntax_pass": true}, {"attribute_expression": "private final File directory;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "File", "name": "directory", "syntax_pass": true}], "classes": [{"original_string": "    private class Use implements Session.Shell {\n      private final Environment env;\n      private final Map<String, Binding> bindings;\n\n      Use(Environment env, Map<String, Binding> bindings) {\n        this.env = env;\n        this.bindings = bindings;\n      }\n\n      @Override public void use(String fileName, boolean silent, Pos pos) {\n        outLines.accept(\"[opening \" + fileName + \"]\");\n        File file = new File(fileName);\n        if (!file.isAbsolute()) {\n          file = new File(directory, fileName);\n        }\n        if (!file.exists()) {\n          outLines.accept(\"[use failed: Io: openIn failed on \"\n              + fileName\n              + \", No such file or directory]\");\n          throw new Codes.MorelRuntimeException(Codes.BuiltInExn.ERROR, pos);\n        }\n        if (depth > maxDepth && maxDepth >= 0) {\n          outLines.accept(\"[use failed: Io: openIn failed on \"\n              + fileName\n              + \", Too many open files]\");\n          throw new Codes.MorelRuntimeException(Codes.BuiltInExn.ERROR, pos);\n        }\n        try (FileReader fileReader = new FileReader(file);\n             BufferedReader bufferedReader = new BufferedReader(fileReader)) {\n          final SubShell subShell =\n              new SubShell(depth + 1, maxDepth, new ReaderLineFn(bufferedReader),\n                  false, typeSystem, env, outLines, session, directory);\n          subShell.extracted(bindings);\n        } catch (IOException e) {\n          e.printStackTrace();\n        }\n      }\n\n      @Override public void handle(RuntimeException e,\n          StringBuilder buf) {\n        if (depth != 1) {\n          throw e;\n        }\n        if (e instanceof MorelException) {\n          final MorelException me = (MorelException) e;\n          me.describeTo(buf)\n              .append(\"\\n\")\n              .append(\"  raised at: \");\n          me.pos().describeTo(buf);\n        } else {\n          buf.append(e);\n        }\n      }\n    }", "definition": "    private class Use implements Session.Shell", "class_docstring": " Implementation of the \"use\" function.", "name": "Use", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "fields": [{"attribute_expression": "private final Environment env;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Environment", "name": "env", "syntax_pass": true}, {"attribute_expression": "private final Map<String, Binding> bindings;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Map<String, Binding>", "name": "bindings", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "      Use(Environment env, Map<String, Binding> bindings) {\n        this.env = env;\n        this.bindings = bindings;\n      }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "Use", "params": [{"name": "env", "type": "Environment"}, {"name": "bindings", "type": "Map<String, Binding>"}], "body": "                                                          {\n        this.env = env;\n        this.bindings = bindings;\n      }", "signature": "Use(Environment env, Map<String, Binding> bindings)"}, {"syntax_pass": true, "original_string": "      @Override public void use(String fileName, boolean silent, Pos pos) {\n        outLines.accept(\"[opening \" + fileName + \"]\");\n        File file = new File(fileName);\n        if (!file.isAbsolute()) {\n          file = new File(directory, fileName);\n        }\n        if (!file.exists()) {\n          outLines.accept(\"[use failed: Io: openIn failed on \"\n              + fileName\n              + \", No such file or directory]\");\n          throw new Codes.MorelRuntimeException(Codes.BuiltInExn.ERROR, pos);\n        }\n        if (depth > maxDepth && maxDepth >= 0) {\n          outLines.accept(\"[use failed: Io: openIn failed on \"\n              + fileName\n              + \", Too many open files]\");\n          throw new Codes.MorelRuntimeException(Codes.BuiltInExn.ERROR, pos);\n        }\n        try (FileReader fileReader = new FileReader(file);\n             BufferedReader bufferedReader = new BufferedReader(fileReader)) {\n          final SubShell subShell =\n              new SubShell(depth + 1, maxDepth, new ReaderLineFn(bufferedReader),\n                  false, typeSystem, env, outLines, session, directory);\n          subShell.extracted(bindings);\n        } catch (IOException e) {\n          e.printStackTrace();\n        }\n      }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "use", "params": [{"name": "fileName", "type": "String"}, {"name": "silent", "type": "boolean"}, {"name": "pos", "type": "Pos"}], "body": "                                                                          {\n        outLines.accept(\"[opening \" + fileName + \"]\");\n        File file = new File(fileName);\n        if (!file.isAbsolute()) {\n          file = new File(directory, fileName);\n        }\n        if (!file.exists()) {\n          outLines.accept(\"[use failed: Io: openIn failed on \"\n              + fileName\n              + \", No such file or directory]\");\n          throw new Codes.MorelRuntimeException(Codes.BuiltInExn.ERROR, pos);\n        }\n        if (depth > maxDepth && maxDepth >= 0) {\n          outLines.accept(\"[use failed: Io: openIn failed on \"\n              + fileName\n              + \", Too many open files]\");\n          throw new Codes.MorelRuntimeException(Codes.BuiltInExn.ERROR, pos);\n        }\n        try (FileReader fileReader = new FileReader(file);\n             BufferedReader bufferedReader = new BufferedReader(fileReader)) {\n          final SubShell subShell =\n              new SubShell(depth + 1, maxDepth, new ReaderLineFn(bufferedReader),\n                  false, typeSystem, env, outLines, session, directory);\n          subShell.extracted(bindings);\n        } catch (IOException e) {\n          e.printStackTrace();\n        }\n      }", "signature": "@Override public void use(String fileName, boolean silent, Pos pos)"}, {"syntax_pass": true, "original_string": "      @Override public void handle(RuntimeException e,\n          StringBuilder buf) {\n        if (depth != 1) {\n          throw e;\n        }\n        if (e instanceof MorelException) {\n          final MorelException me = (MorelException) e;\n          me.describeTo(buf)\n              .append(\"\\n\")\n              .append(\"  raised at: \");\n          me.pos().describeTo(buf);\n        } else {\n          buf.append(e);\n        }\n      }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "handle", "params": [{"name": "e", "type": "RuntimeException"}, {"name": "buf", "type": "StringBuilder"}], "body": "                             {\n        if (depth != 1) {\n          throw e;\n        }\n        if (e instanceof MorelException) {\n          final MorelException me = (MorelException) e;\n          me.describeTo(buf)\n              .append(\"\\n\")\n              .append(\"  raised at: \");\n          me.pos().describeTo(buf);\n        } else {\n          buf.append(e);\n        }\n      }", "signature": "@Override public void handle(RuntimeException e,\n          StringBuilder buf)"}]}]}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    SubShell(int depth, int maxDepth, LineFn lineFn,\n        boolean echo, TypeSystem typeSystem, Environment env,\n        Consumer<String> outLines, Session session, File directory) {\n      this.depth = depth;\n      this.maxDepth = maxDepth;\n      this.lineFn = lineFn;\n      this.echo = echo;\n      this.typeSystem = typeSystem;\n      this.env = env;\n      this.outLines = outLines;\n      this.session = session;\n      this.directory = directory;\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "SubShell", "params": [{"name": "depth", "type": "int"}, {"name": "maxDepth", "type": "int"}, {"name": "lineFn", "type": "LineFn"}, {"name": "echo", "type": "boolean"}, {"name": "typeSystem", "type": "TypeSystem"}, {"name": "env", "type": "Environment"}, {"name": "outLines", "type": "Consumer<String>"}, {"name": "session", "type": "Session"}, {"name": "directory", "type": "File"}], "body": "                                                                    {\n      this.depth = depth;\n      this.maxDepth = maxDepth;\n      this.lineFn = lineFn;\n      this.echo = echo;\n      this.typeSystem = typeSystem;\n      this.env = env;\n      this.outLines = outLines;\n      this.session = session;\n      this.directory = directory;\n    }", "signature": "SubShell(int depth, int maxDepth, LineFn lineFn,\n        boolean echo, TypeSystem typeSystem, Environment env,\n        Consumer<String> outLines, Session session, File directory)"}, {"syntax_pass": true, "original_string": "    void extracted(@Nullable Map<String, Binding> outBindings) {\n      final StringBuilder buf = new StringBuilder();\n      final Map<String, Binding> bindingMap = new LinkedHashMap<>();\n      final List<Binding> bindings = new ArrayList<>();\n      Environment env1 = env;\n      for (;;) {\n        final Pair<LineType, String> line = lineFn.read(buf);\n        switch (line.left) {\n        case EOF:\n        case QUIT:\n          return;\n\n        case IGNORE:\n          continue;\n\n        case HELP:\n          help(outLines);\n          buf.append(line.right).append(\"\\n\");\n          break;\n\n        case REGULAR:\n          try {\n            buf.append(line.right);\n            if (line.right.endsWith(\";\")) {\n              final String code = str(buf);\n              final MorelParserImpl smlParser =\n                  new MorelParserImpl(new StringReader(code));\n              final AstNode statement;\n              try {\n                smlParser.zero(\"stdIn\");\n                statement = smlParser.statementSemicolon();\n                final Environment env0 = env1;\n                final List<CompileException> warningList = new ArrayList<>();\n                final Tracer tracer = Tracers.empty();\n                final CompiledStatement compiled =\n                    Compiles.prepareStatement(typeSystem, session, env0,\n                        statement, null, warningList::add, tracer);\n                final Use shell = new Use(env0, bindingMap);\n                session.withShell(shell, outLines, session1 ->\n                    compiled.eval(session1, env0, outLines, bindings::add));\n                bindings.forEach(b -> bindingMap.put(b.id.name, b));\n                env1 = env0.bindAll(bindingMap.values());\n                if (outBindings != null) {\n                  outBindings.putAll(bindingMap);\n                }\n                bindingMap.clear();\n                bindings.clear();\n              } catch (ParseException | CompileException e) {\n                outLines.accept(e.getMessage());\n              }\n              if (echo) {\n                outLines.accept(code);\n              }\n            } else {\n              buf.append(\"\\n\");\n            }\n          } catch (IllegalArgumentException e) {\n            outLines.accept(e.getMessage());\n          }\n        }\n      }\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "name": "extracted", "params": [{"name": "outBindings", "type": "Map<String, Binding>"}], "body": "                                                               {\n      final StringBuilder buf = new StringBuilder();\n      final Map<String, Binding> bindingMap = new LinkedHashMap<>();\n      final List<Binding> bindings = new ArrayList<>();\n      Environment env1 = env;\n      for (;;) {\n        final Pair<LineType, String> line = lineFn.read(buf);\n        switch (line.left) {\n        case EOF:\n        case QUIT:\n          return;\n\n        case IGNORE:\n          continue;\n\n        case HELP:\n          help(outLines);\n          buf.append(line.right).append(\"\\n\");\n          break;\n\n        case REGULAR:\n          try {\n            buf.append(line.right);\n            if (line.right.endsWith(\";\")) {\n              final String code = str(buf);\n              final MorelParserImpl smlParser =\n                  new MorelParserImpl(new StringReader(code));\n              final AstNode statement;\n              try {\n                smlParser.zero(\"stdIn\");\n                statement = smlParser.statementSemicolon();\n                final Environment env0 = env1;\n                final List<CompileException> warningList = new ArrayList<>();\n                final Tracer tracer = Tracers.empty();\n                final CompiledStatement compiled =\n                    Compiles.prepareStatement(typeSystem, session, env0,\n                        statement, null, warningList::add, tracer);\n                final Use shell = new Use(env0, bindingMap);\n                session.withShell(shell, outLines, session1 ->\n                    compiled.eval(session1, env0, outLines, bindings::add));\n                bindings.forEach(b -> bindingMap.put(b.id.name, b));\n                env1 = env0.bindAll(bindingMap.values());\n                if (outBindings != null) {\n                  outBindings.putAll(bindingMap);\n                }\n                bindingMap.clear();\n                bindings.clear();\n              } catch (ParseException | CompileException e) {\n                outLines.accept(e.getMessage());\n              }\n              if (echo) {\n                outLines.accept(code);\n              }\n            } else {\n              buf.append(\"\\n\");\n            }\n          } catch (IllegalArgumentException e) {\n            outLines.accept(e.getMessage());\n          }\n        }\n      }\n    }", "signature": "void extracted(@Nullable Map<String, Binding> outBindings)"}]}, {"original_string": "  static class ReaderLineFn implements LineFn {\n    private final BufferedReader reader;\n\n    ReaderLineFn(BufferedReader reader) {\n      this.reader = reader;\n    }\n\n    @Override public Pair<LineType, String> read(StringBuilder buf) {\n      try {\n        final String line = reader.readLine();\n        if (line == null) {\n          return Pair.of(LineType.EOF, \"\");\n        }\n        if (canIgnoreLine(buf, line)) {\n          return Pair.of(LineType.IGNORE, \"\");\n        }\n        return Pair.of(LineType.REGULAR, line);\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n  }", "definition": "  static class ReaderLineFn implements LineFn", "class_docstring": " Implementation of {@link LineFn} that reads from a reader.", "name": "ReaderLineFn", "super_interfaces": ["LineFn"], "superclasses": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "fields": [{"attribute_expression": "private final BufferedReader reader;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "BufferedReader", "name": "reader", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    ReaderLineFn(BufferedReader reader) {\n      this.reader = reader;\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "ReaderLineFn", "params": [{"name": "reader", "type": "BufferedReader"}], "body": "                                        {\n      this.reader = reader;\n    }", "signature": "ReaderLineFn(BufferedReader reader)"}, {"syntax_pass": true, "original_string": "    @Override public Pair<LineType, String> read(StringBuilder buf) {\n      try {\n        final String line = reader.readLine();\n        if (line == null) {\n          return Pair.of(LineType.EOF, \"\");\n        }\n        if (canIgnoreLine(buf, line)) {\n          return Pair.of(LineType.IGNORE, \"\");\n        }\n        return Pair.of(LineType.REGULAR, line);\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Pair<LineType, String>", "classes": []}, "name": "read", "params": [{"name": "buf", "type": "StringBuilder"}], "body": "                                                                    {\n      try {\n        final String line = reader.readLine();\n        if (line == null) {\n          return Pair.of(LineType.EOF, \"\");\n        }\n        if (canIgnoreLine(buf, line)) {\n          return Pair.of(LineType.IGNORE, \"\");\n        }\n        return Pair.of(LineType.REGULAR, line);\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    }", "signature": "@Override public Pair<LineType, String> read(StringBuilder buf)"}]}, {"original_string": "  private static class TerminalLineFn implements LineFn {\n    private final String minusPrompt;\n    private final String equalsPrompt;\n    private final LineReader lineReader;\n\n    TerminalLineFn(String minusPrompt, String equalsPrompt,\n        LineReader lineReader) {\n      this.minusPrompt = minusPrompt;\n      this.equalsPrompt = equalsPrompt;\n      this.lineReader = lineReader;\n    }\n\n    @Override public Pair<LineType, String> read(StringBuilder buf) {\n      final String line;\n      try {\n        final String prompt = buf.length() == 0 ? minusPrompt : equalsPrompt;\n        final String rightPrompt = null;\n        line = lineReader.readLine(prompt, rightPrompt, (MaskingCallback) null,\n            null);\n      } catch (UserInterruptException e) {\n        return Pair.of(LineType.INTERRUPT, \"\");\n      } catch (EndOfFileException e) {\n        return Pair.of(LineType.EOF, \"\");\n      }\n\n      if (canIgnoreLine(buf, line)) {\n        return Pair.of(LineType.IGNORE, \"\");\n      }\n\n      if (line.equalsIgnoreCase(\"quit\")\n          || line.equalsIgnoreCase(\"exit\")) {\n        return Pair.of(LineType.QUIT, \"\");\n      }\n\n      final ParsedLine pl = lineReader.getParser().parse(line, 0);\n      if (\"help\".equals(pl.word()) || \"?\".equals(pl.word())) {\n        return Pair.of(LineType.HELP, \"\");\n      }\n      return Pair.of(LineType.REGULAR, pl.line());\n    }\n  }", "definition": "  private static class TerminalLineFn implements LineFn", "class_docstring": " Implementation of {@link LineFn} that reads from JLine's terminal.\nIt is used for interactive sessions.", "name": "TerminalLineFn", "super_interfaces": ["LineFn"], "superclasses": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "fields": [{"attribute_expression": "private final String minusPrompt;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "minusPrompt", "syntax_pass": true}, {"attribute_expression": "private final String equalsPrompt;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "equalsPrompt", "syntax_pass": true}, {"attribute_expression": "private final LineReader lineReader;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "LineReader", "name": "lineReader", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    TerminalLineFn(String minusPrompt, String equalsPrompt,\n        LineReader lineReader) {\n      this.minusPrompt = minusPrompt;\n      this.equalsPrompt = equalsPrompt;\n      this.lineReader = lineReader;\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "TerminalLineFn", "params": [{"name": "minusPrompt", "type": "String"}, {"name": "equalsPrompt", "type": "String"}, {"name": "lineReader", "type": "LineReader"}], "body": "                               {\n      this.minusPrompt = minusPrompt;\n      this.equalsPrompt = equalsPrompt;\n      this.lineReader = lineReader;\n    }", "signature": "TerminalLineFn(String minusPrompt, String equalsPrompt,\n        LineReader lineReader)"}, {"syntax_pass": true, "original_string": "    @Override public Pair<LineType, String> read(StringBuilder buf) {\n      final String line;\n      try {\n        final String prompt = buf.length() == 0 ? minusPrompt : equalsPrompt;\n        final String rightPrompt = null;\n        line = lineReader.readLine(prompt, rightPrompt, (MaskingCallback) null,\n            null);\n      } catch (UserInterruptException e) {\n        return Pair.of(LineType.INTERRUPT, \"\");\n      } catch (EndOfFileException e) {\n        return Pair.of(LineType.EOF, \"\");\n      }\n\n      if (canIgnoreLine(buf, line)) {\n        return Pair.of(LineType.IGNORE, \"\");\n      }\n\n      if (line.equalsIgnoreCase(\"quit\")\n          || line.equalsIgnoreCase(\"exit\")) {\n        return Pair.of(LineType.QUIT, \"\");\n      }\n\n      final ParsedLine pl = lineReader.getParser().parse(line, 0);\n      if (\"help\".equals(pl.word()) || \"?\".equals(pl.word())) {\n        return Pair.of(LineType.HELP, \"\");\n      }\n      return Pair.of(LineType.REGULAR, pl.line());\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Pair<LineType, String>", "classes": []}, "name": "read", "params": [{"name": "buf", "type": "StringBuilder"}], "body": "                                                                    {\n      final String line;\n      try {\n        final String prompt = buf.length() == 0 ? minusPrompt : equalsPrompt;\n        final String rightPrompt = null;\n        line = lineReader.readLine(prompt, rightPrompt, (MaskingCallback) null,\n            null);\n      } catch (UserInterruptException e) {\n        return Pair.of(LineType.INTERRUPT, \"\");\n      } catch (EndOfFileException e) {\n        return Pair.of(LineType.EOF, \"\");\n      }\n\n      if (canIgnoreLine(buf, line)) {\n        return Pair.of(LineType.IGNORE, \"\");\n      }\n\n      if (line.equalsIgnoreCase(\"quit\")\n          || line.equalsIgnoreCase(\"exit\")) {\n        return Pair.of(LineType.QUIT, \"\");\n      }\n\n      final ParsedLine pl = lineReader.getParser().parse(line, 0);\n      if (\"help\".equals(pl.word()) || \"?\".equals(pl.word())) {\n        return Pair.of(LineType.HELP, \"\");\n      }\n      return Pair.of(LineType.REGULAR, pl.line());\n    }", "signature": "@Override public Pair<LineType, String> read(StringBuilder buf)"}]}], "class_docstring": " Command shell for ML, powered by JLine3.", "original_string": "public class Shell {\n  private final ConfigImpl config;\n  private final Terminal terminal;\n\n  /** Command-line entry point.\n   *\n   * @param args Command-line arguments */\n  public static void main(String[] args) {\n    try {\n      final Config config =\n          parse(ConfigImpl.DEFAULT\n              .withDirectory(new File(System.getProperty(\"user.dir\"))),\n              ImmutableList.copyOf(args));\n      final Shell main = create(config, System.in, System.out);\n      main.run();\n    } catch (Throwable e) {\n      e.printStackTrace();\n      System.exit(1);\n    }\n  }\n\n  /** Creates a Shell. */\n  public static Shell create(List<String> args, InputStream in,\n      OutputStream out) throws IOException {\n    final Config config = parse(ConfigImpl.DEFAULT, args);\n    return create(config, in, out);\n  }\n\n  /** Creates a Shell. */\n  public static Shell create(Config config, InputStream in,\n      OutputStream out) throws IOException {\n    final TerminalBuilder builder = TerminalBuilder.builder();\n    builder.streams(in, out);\n    final ConfigImpl configImpl = (ConfigImpl) config;\n    builder.system(configImpl.system);\n    builder.dumb(configImpl.dumb);\n    if (configImpl.dumb) {\n      builder.type(\"dumb\");\n    }\n    final Terminal terminal = builder.build();\n    return new Shell(config, terminal);\n  }\n\n  /** Creates a Shell. */\n  public Shell(Config config, Terminal terminal) {\n    this.config = (ConfigImpl) config;\n    this.terminal = terminal;\n  }\n\n  /** Parses an argument list to an equivalent Config. */\n  public static Config parse(Config config, List<String> argList) {\n    ConfigImpl c = (ConfigImpl) config;\n    final ImmutableMap.Builder<String, ForeignValue> valueMapBuilder =\n        ImmutableMap.builder();\n    for (String arg : argList) {\n      if (arg.equals(\"--banner=false\")) {\n        c = c.withBanner(false);\n      }\n      if (arg.equals(\"--terminal=dumb\")) {\n        c = c.withDumb(true);\n      }\n      if (arg.equals(\"--echo\")) {\n        c = c.withEcho(true);\n      }\n      if (arg.equals(\"--help\")) {\n        c = c.withHelp(true);\n      }\n      if (arg.equals(\"--system=false\")) {\n        c = c.withSystem(false);\n      }\n      if (arg.startsWith(\"--foreign=\")) {\n        final String className = arg.substring(\"--foreign=\".length());\n        @SuppressWarnings(\"unchecked\") final Map<String, DataSet> map =\n            instantiate(className, Map.class);\n        valueMapBuilder.putAll(Calcite.withDataSets(map).foreignValues());\n      }\n      if (arg.startsWith(\"--directory=\")) {\n        final String directoryPath = arg.substring(\"--directory=\".length());\n        c = c.withDirectory(new File(directoryPath));\n      }\n      if (arg.startsWith(\"--maxUseDepth=\")) {\n        int maxUseDepth =\n            Integer.parseInt(arg.substring(\"--maxUseDepth=\".length()));\n        c = c.withMaxUseDepth(maxUseDepth);\n      }\n    }\n\n    return c.withValueMap(valueMapBuilder.build());\n  }\n\n  static void usage(Consumer<String> outLines) {\n    String[] usageLines = {\n        \"Usage: java \" + Shell.class.getName(),\n    };\n    Arrays.asList(usageLines).forEach(outLines);\n  }\n\n  static void help(Consumer<String> outLines) {\n    String[] helpLines = {\n        \"List of available commands:\",\n        \"    help   Print this help\",\n        \"    quit   Quit shell\",\n    };\n    Arrays.asList(helpLines).forEach(outLines);\n  }\n\n  /** Pauses after creating the terminal.\n   *\n   * <p>Calls the value set by {@link Config#withPauseFn(Runnable)} which,\n   * for the default config, does nothing;\n   * the instance used in testing pauses for a few milliseconds,\n   * which gives classes time to load and makes test deterministic. */\n  protected final void pause() {\n    config.pauseFn.run();\n  }\n\n  /** Returns whether we can ignore a line. We can ignore a line if it consists\n   * only of comments, spaces, and optionally semicolon, and if we are not on a\n   * continuation line. */\n  private static boolean canIgnoreLine(StringBuilder buf, String line) {\n    final String trimmedLine = line\n        .replaceAll(\"\\\\(\\\\*.*\\\\*\\\\)\", \"\")\n        .replaceAll(\"\\\\(\\\\*\\\\) .*$\", \"\")\n        .trim();\n    return buf.length() == 0\n        && (trimmedLine.isEmpty() || trimmedLine.equals(\";\"));\n  }\n\n  /** Generates a banner to be shown on startup. */\n  private String banner() {\n    return \"morel version 0.4.0\"\n        + \" (java version \\\"\" + System.getProperty(\"java.version\")\n        + \"\\\", JRE \" + System.getProperty(\"java.vendor.version\")\n        + \" (build \" + System.getProperty(\"java.vm.version\")\n        + \"), \" + terminal.getName()\n        + \", \" + terminal.getType() + \")\";\n  }\n\n  public void run() {\n    if (config.help) {\n      usage(terminal.writer()::println);\n      return;\n    }\n\n    final Parser parser = new DefaultParser() {\n      {\n        setEofOnUnclosedQuote(true);\n        setEofOnUnclosedBracket(DefaultParser.Bracket.CURLY,\n            DefaultParser.Bracket.ROUND, DefaultParser.Bracket.SQUARE);\n      }\n\n      @Override public ParsedLine parse(String line, int cursor,\n          ParseContext context) {\n        // Remove from \"(*)\" to end of line, if present\n        if (line.matches(\".*\\\\(\\\\*\\\\).*\")) {\n          line = line.replaceAll(\"\\\\(\\\\*\\\\).*$\", \"\");\n        }\n        return super.parse(line, cursor, context);\n      }\n    };\n\n    final String equalsPrompt = new AttributedStringBuilder()\n        .style(AttributedStyle.DEFAULT.bold()).append(\"=\")\n        .style(AttributedStyle.DEFAULT).append(\" \")\n        .toAnsi(terminal);\n    final String minusPrompt = new AttributedStringBuilder()\n        .style(AttributedStyle.DEFAULT.bold()).append(\"-\")\n        .style(AttributedStyle.DEFAULT).append(\" \")\n        .toAnsi(terminal);\n\n    if (config.banner) {\n      terminal.writer().println(banner());\n    }\n    LineReader lineReader = LineReaderBuilder.builder()\n        .appName(\"morel\")\n        .terminal(terminal)\n        .parser(parser)\n        .variable(LineReader.SECONDARY_PROMPT_PATTERN, equalsPrompt)\n        .build();\n\n    pause();\n    final TypeSystem typeSystem = new TypeSystem();\n    final Map<Prop, Object> map = new LinkedHashMap<>();\n    Prop.DIRECTORY.set(map, config.directory);\n    Prop.SCRIPT_DIRECTORY.set(map, config.directory);\n    final Session session = new Session(map);\n    Environment env = Environments.env(typeSystem, session, config.valueMap);\n    final LineFn lineFn =\n        new TerminalLineFn(minusPrompt, equalsPrompt, lineReader);\n    final SubShell subShell =\n        new SubShell(1, config.maxUseDepth, lineFn, config.echo, typeSystem,\n            env, terminal.writer()::println, session, config.directory);\n    final Map<String, Binding> bindings = new LinkedHashMap<>();\n    subShell.extracted(bindings);\n  }\n\n  /** Instantiates a class.\n   *\n   * <p>Assumes that the class has a public no-arguments constructor. */\n  @NonNull private static <T> T instantiate(String className,\n      @SuppressWarnings(\"SameParameterValue\") Class<T> clazz) {\n    try {\n      final Class<?> aClass = Class.forName(className);\n      return clazz.cast(aClass.getConstructor().newInstance());\n    } catch (ClassNotFoundException | NoSuchMethodException\n        | InstantiationException | InvocationTargetException\n        | IllegalAccessException e) {\n      throw new RuntimeException(\"Cannot load class: \" + className, e);\n    }\n  }\n\n  /** Shell configuration. */\n  @SuppressWarnings(\"unused\")\n  public interface Config {\n    @SuppressWarnings(\"UnstableApiUsage\")\n    Config DEFAULT =\n        new ConfigImpl(true, false, true, false, false, ImmutableMap.of(),\n            new File(\"\"), Runnables.doNothing(), -1);\n\n    Config withBanner(boolean banner);\n    Config withDumb(boolean dumb);\n    Config withSystem(boolean system);\n    Config withEcho(boolean echo);\n    Config withHelp(boolean help);\n    Config withValueMap(Map<String, ForeignValue> valueMap);\n    Config withDirectory(File directory);\n    Config withPauseFn(Runnable runnable);\n    Config withMaxUseDepth(int maxUseDepth);\n  }\n\n  /** Implementation of {@link Config}. */\n  private static class ConfigImpl implements Config {\n    private final boolean banner;\n    private final boolean dumb;\n    private final boolean echo;\n    private final boolean help;\n    private final boolean system;\n    private final ImmutableMap<String, ForeignValue> valueMap;\n    private final File directory;\n    private final Runnable pauseFn;\n    private final int maxUseDepth;\n\n    private ConfigImpl(boolean banner, boolean dumb, boolean system,\n        boolean echo, boolean help, ImmutableMap<String, ForeignValue> valueMap,\n        File directory, Runnable pauseFn, int maxUseDepth) {\n      this.banner = banner;\n      this.dumb = dumb;\n      this.system = system;\n      this.echo = echo;\n      this.help = help;\n      this.valueMap = requireNonNull(valueMap, \"valueMap\");\n      this.directory = requireNonNull(directory, \"directory\");\n      this.pauseFn = requireNonNull(pauseFn, \"pauseFn\");\n      this.maxUseDepth = maxUseDepth;\n    }\n\n    @Override public ConfigImpl withBanner(boolean banner) {\n      if (this.banner == banner) {\n        return this;\n      }\n      return new ConfigImpl(banner, dumb, system, echo, help, valueMap,\n          directory, pauseFn, maxUseDepth);\n    }\n\n    @Override public ConfigImpl withDumb(boolean dumb) {\n      if (this.dumb == dumb) {\n        return this;\n      }\n      return new ConfigImpl(banner, dumb, system, echo, help, valueMap,\n          directory, pauseFn, maxUseDepth);\n    }\n\n    @Override public ConfigImpl withSystem(boolean system) {\n      if (this.system == system) {\n        return this;\n      }\n      return new ConfigImpl(banner, dumb, system, echo, help, valueMap,\n          directory, pauseFn, maxUseDepth);\n    }\n\n    @Override public ConfigImpl withEcho(boolean echo) {\n      if (this.echo == echo) {\n        return this;\n      }\n      return new ConfigImpl(banner, dumb, system, echo, help, valueMap,\n          directory, pauseFn, maxUseDepth);\n    }\n\n    @Override public ConfigImpl withHelp(boolean help) {\n      if (this.help == help) {\n        return this;\n      }\n      return new ConfigImpl(banner, dumb, system, echo, help, valueMap,\n          directory, pauseFn, maxUseDepth);\n    }\n\n    @Override public ConfigImpl withValueMap(\n        Map<String, ForeignValue> valueMap) {\n      if (this.valueMap.equals(valueMap)) {\n        return this;\n      }\n      final ImmutableMap<String, ForeignValue> immutableValueMap =\n          ImmutableMap.copyOf(valueMap);\n      return new ConfigImpl(banner, dumb, system, echo, help, immutableValueMap,\n          directory, pauseFn, maxUseDepth);\n    }\n\n    @Override public ConfigImpl withDirectory(File directory) {\n      if (this.directory.equals(directory)) {\n        return this;\n      }\n      return new ConfigImpl(banner, dumb, system, echo, help, valueMap,\n          directory, pauseFn, maxUseDepth);\n    }\n\n    @Override public Config withPauseFn(Runnable pauseFn) {\n      if (this.pauseFn.equals(pauseFn)) {\n        return this;\n      }\n      return new ConfigImpl(banner, dumb, system, echo, help, valueMap,\n          directory, pauseFn, maxUseDepth);\n    }\n\n    @Override public ConfigImpl withMaxUseDepth(int maxUseDepth) {\n      if (this.maxUseDepth == maxUseDepth) {\n        return this;\n      }\n      return new ConfigImpl(banner, dumb, system, echo, help, valueMap,\n          directory, pauseFn, maxUseDepth);\n    }\n  }\n\n  /** Abstraction of a terminal's line reader. Can read lines from an input\n   * (terminal or file) and categorize the lines. */\n  interface LineFn {\n    Pair<LineType, String> read(StringBuilder buf);\n  }\n\n  /** Type of line from {@link LineFn}. */\n  enum LineType {\n    QUIT,\n    EOF,\n    INTERRUPT,\n    IGNORE,\n    HELP,\n    REGULAR\n  }\n\n  /** Simplified shell that works in both interactive mode (where input and\n   * output is a terminal) and batch mode (where input is a file, and output\n   * is to an array of lines). */\n  static class SubShell {\n    private final int depth;\n    private final int maxDepth;\n    private final LineFn lineFn;\n    private final boolean echo;\n    private final TypeSystem typeSystem;\n    private final Environment env;\n    private final Consumer<String> outLines;\n    private final Session session;\n    private final File directory;\n\n    SubShell(int depth, int maxDepth, LineFn lineFn,\n        boolean echo, TypeSystem typeSystem, Environment env,\n        Consumer<String> outLines, Session session, File directory) {\n      this.depth = depth;\n      this.maxDepth = maxDepth;\n      this.lineFn = lineFn;\n      this.echo = echo;\n      this.typeSystem = typeSystem;\n      this.env = env;\n      this.outLines = outLines;\n      this.session = session;\n      this.directory = directory;\n    }\n\n    void extracted(@Nullable Map<String, Binding> outBindings) {\n      final StringBuilder buf = new StringBuilder();\n      final Map<String, Binding> bindingMap = new LinkedHashMap<>();\n      final List<Binding> bindings = new ArrayList<>();\n      Environment env1 = env;\n      for (;;) {\n        final Pair<LineType, String> line = lineFn.read(buf);\n        switch (line.left) {\n        case EOF:\n        case QUIT:\n          return;\n\n        case IGNORE:\n          continue;\n\n        case HELP:\n          help(outLines);\n          buf.append(line.right).append(\"\\n\");\n          break;\n\n        case REGULAR:\n          try {\n            buf.append(line.right);\n            if (line.right.endsWith(\";\")) {\n              final String code = str(buf);\n              final MorelParserImpl smlParser =\n                  new MorelParserImpl(new StringReader(code));\n              final AstNode statement;\n              try {\n                smlParser.zero(\"stdIn\");\n                statement = smlParser.statementSemicolon();\n                final Environment env0 = env1;\n                final List<CompileException> warningList = new ArrayList<>();\n                final Tracer tracer = Tracers.empty();\n                final CompiledStatement compiled =\n                    Compiles.prepareStatement(typeSystem, session, env0,\n                        statement, null, warningList::add, tracer);\n                final Use shell = new Use(env0, bindingMap);\n                session.withShell(shell, outLines, session1 ->\n                    compiled.eval(session1, env0, outLines, bindings::add));\n                bindings.forEach(b -> bindingMap.put(b.id.name, b));\n                env1 = env0.bindAll(bindingMap.values());\n                if (outBindings != null) {\n                  outBindings.putAll(bindingMap);\n                }\n                bindingMap.clear();\n                bindings.clear();\n              } catch (ParseException | CompileException e) {\n                outLines.accept(e.getMessage());\n              }\n              if (echo) {\n                outLines.accept(code);\n              }\n            } else {\n              buf.append(\"\\n\");\n            }\n          } catch (IllegalArgumentException e) {\n            outLines.accept(e.getMessage());\n          }\n        }\n      }\n    }\n\n    /** Implementation of the \"use\" function. */\n    private class Use implements Session.Shell {\n      private final Environment env;\n      private final Map<String, Binding> bindings;\n\n      Use(Environment env, Map<String, Binding> bindings) {\n        this.env = env;\n        this.bindings = bindings;\n      }\n\n      @Override public void use(String fileName, boolean silent, Pos pos) {\n        outLines.accept(\"[opening \" + fileName + \"]\");\n        File file = new File(fileName);\n        if (!file.isAbsolute()) {\n          file = new File(directory, fileName);\n        }\n        if (!file.exists()) {\n          outLines.accept(\"[use failed: Io: openIn failed on \"\n              + fileName\n              + \", No such file or directory]\");\n          throw new Codes.MorelRuntimeException(Codes.BuiltInExn.ERROR, pos);\n        }\n        if (depth > maxDepth && maxDepth >= 0) {\n          outLines.accept(\"[use failed: Io: openIn failed on \"\n              + fileName\n              + \", Too many open files]\");\n          throw new Codes.MorelRuntimeException(Codes.BuiltInExn.ERROR, pos);\n        }\n        try (FileReader fileReader = new FileReader(file);\n             BufferedReader bufferedReader = new BufferedReader(fileReader)) {\n          final SubShell subShell =\n              new SubShell(depth + 1, maxDepth, new ReaderLineFn(bufferedReader),\n                  false, typeSystem, env, outLines, session, directory);\n          subShell.extracted(bindings);\n        } catch (IOException e) {\n          e.printStackTrace();\n        }\n      }\n\n      @Override public void handle(RuntimeException e,\n          StringBuilder buf) {\n        if (depth != 1) {\n          throw e;\n        }\n        if (e instanceof MorelException) {\n          final MorelException me = (MorelException) e;\n          me.describeTo(buf)\n              .append(\"\\n\")\n              .append(\"  raised at: \");\n          me.pos().describeTo(buf);\n        } else {\n          buf.append(e);\n        }\n      }\n    }\n  }\n\n  /** Implementation of {@link LineFn} that reads from a reader. */\n  static class ReaderLineFn implements LineFn {\n    private final BufferedReader reader;\n\n    ReaderLineFn(BufferedReader reader) {\n      this.reader = reader;\n    }\n\n    @Override public Pair<LineType, String> read(StringBuilder buf) {\n      try {\n        final String line = reader.readLine();\n        if (line == null) {\n          return Pair.of(LineType.EOF, \"\");\n        }\n        if (canIgnoreLine(buf, line)) {\n          return Pair.of(LineType.IGNORE, \"\");\n        }\n        return Pair.of(LineType.REGULAR, line);\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n  }\n\n  /** Implementation of {@link LineFn} that reads from JLine's terminal.\n   * It is used for interactive sessions. */\n  private static class TerminalLineFn implements LineFn {\n    private final String minusPrompt;\n    private final String equalsPrompt;\n    private final LineReader lineReader;\n\n    TerminalLineFn(String minusPrompt, String equalsPrompt,\n        LineReader lineReader) {\n      this.minusPrompt = minusPrompt;\n      this.equalsPrompt = equalsPrompt;\n      this.lineReader = lineReader;\n    }\n\n    @Override public Pair<LineType, String> read(StringBuilder buf) {\n      final String line;\n      try {\n        final String prompt = buf.length() == 0 ? minusPrompt : equalsPrompt;\n        final String rightPrompt = null;\n        line = lineReader.readLine(prompt, rightPrompt, (MaskingCallback) null,\n            null);\n      } catch (UserInterruptException e) {\n        return Pair.of(LineType.INTERRUPT, \"\");\n      } catch (EndOfFileException e) {\n        return Pair.of(LineType.EOF, \"\");\n      }\n\n      if (canIgnoreLine(buf, line)) {\n        return Pair.of(LineType.IGNORE, \"\");\n      }\n\n      if (line.equalsIgnoreCase(\"quit\")\n          || line.equalsIgnoreCase(\"exit\")) {\n        return Pair.of(LineType.QUIT, \"\");\n      }\n\n      final ParsedLine pl = lineReader.getParser().parse(line, 0);\n      if (\"help\".equals(pl.word()) || \"?\".equals(pl.word())) {\n        return Pair.of(LineType.HELP, \"\");\n      }\n      return Pair.of(LineType.REGULAR, pl.line());\n    }\n  }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private final ConfigImpl config;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "ConfigImpl", "name": "config", "syntax_pass": true}, {"attribute_expression": "private final Terminal terminal;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Terminal", "name": "terminal", "syntax_pass": true}]}, {"uris": "src/main/java/net/hydromatic/morel/ast/AstWriter.java.AstWriter", "name": "AstWriter", "file_path": "src/main/java/net/hydromatic/morel/ast/AstWriter.java", "superclasses": "", "methods": ["[]AstWriter(StringBuilder,boolean)", "[]AstWriter()", "[String]toString()", "[AstWriter]withParenthesize(boolean)", "[AstWriter]append(String)", "[AstWriter]id(String)", "[AstWriter]id(String,int)", "[AstWriter]infix(int,AstNode,Op,AstNode,int)", "[AstWriter]prefix(int,Op,AstNode,int)", "[AstWriter]binary(String,AstNode,String,AstNode,int)", "[AstWriter]binary(String,AstNode,String,AstNode,String)", "[AstWriter]append(AstNode,int,int)", "[AstWriter]appendAll(Iterable<? extends AstNode>,int,Op,int)", "[AstWriter]appendAll(Iterable<? extends AstNode>,String)", "[AstWriter]appendAll(Iterable<? extends AstNode>,String,String,String)", "[AstWriter]appendAll(Iterable<? extends AstNode>,String,String,String,String)", "[AstWriter]appendLiteral(Comparable)"], "method_uris": ["src/main/java/net/hydromatic/morel/ast/AstWriter.java.AstWriter.[]AstWriter(StringBuilder,boolean)", "src/main/java/net/hydromatic/morel/ast/AstWriter.java.AstWriter.[]AstWriter()", "src/main/java/net/hydromatic/morel/ast/AstWriter.java.AstWriter.[String]toString()", "src/main/java/net/hydromatic/morel/ast/AstWriter.java.AstWriter.[AstWriter]withParenthesize(boolean)", "src/main/java/net/hydromatic/morel/ast/AstWriter.java.AstWriter.[AstWriter]append(String)", "src/main/java/net/hydromatic/morel/ast/AstWriter.java.AstWriter.[AstWriter]id(String)", "src/main/java/net/hydromatic/morel/ast/AstWriter.java.AstWriter.[AstWriter]id(String,int)", "src/main/java/net/hydromatic/morel/ast/AstWriter.java.AstWriter.[AstWriter]infix(int,AstNode,Op,AstNode,int)", "src/main/java/net/hydromatic/morel/ast/AstWriter.java.AstWriter.[AstWriter]prefix(int,Op,AstNode,int)", "src/main/java/net/hydromatic/morel/ast/AstWriter.java.AstWriter.[AstWriter]binary(String,AstNode,String,AstNode,int)", "src/main/java/net/hydromatic/morel/ast/AstWriter.java.AstWriter.[AstWriter]binary(String,AstNode,String,AstNode,String)", "src/main/java/net/hydromatic/morel/ast/AstWriter.java.AstWriter.[AstWriter]append(AstNode,int,int)", "src/main/java/net/hydromatic/morel/ast/AstWriter.java.AstWriter.[AstWriter]appendAll(Iterable<? extends AstNode>,int,Op,int)", "src/main/java/net/hydromatic/morel/ast/AstWriter.java.AstWriter.[AstWriter]appendAll(Iterable<? extends AstNode>,String)", "src/main/java/net/hydromatic/morel/ast/AstWriter.java.AstWriter.[AstWriter]appendAll(Iterable<? extends AstNode>,String,String,String)", "src/main/java/net/hydromatic/morel/ast/AstWriter.java.AstWriter.[AstWriter]appendAll(Iterable<? extends AstNode>,String,String,String,String)", "src/main/java/net/hydromatic/morel/ast/AstWriter.java.AstWriter.[AstWriter]appendLiteral(Comparable)"], "overrides": null, "attributes": [], "class_docstring": " Context for writing an AST out as a string.", "original_string": "public class AstWriter {\n  private final StringBuilder b;\n  private final boolean parenthesize;\n\n  private AstWriter(StringBuilder b, boolean parenthesize) {\n    this.b = new StringBuilder();\n    this.parenthesize = parenthesize;\n  }\n\n  public AstWriter() {\n    this(new StringBuilder(), false);\n  }\n\n  /** {@inheritDoc}\n   *\n   * <p>Returns the ML source code generated by this writer. */\n  @Override public String toString() {\n    return b.toString();\n  }\n\n  /** Returns a writer that wraps everything in parentheses. */\n  public AstWriter withParenthesize(boolean parenthesize) {\n    return parenthesize == this.parenthesize ? this\n        : new AstWriter(this.b, parenthesize);\n  }\n\n  /** Appends a string to the output. */\n  public AstWriter append(String s) {\n    b.append(s);\n    return this;\n  }\n\n  /** Appends an identifier to the output. */\n  public AstWriter id(String s) {\n    b.append(s);\n    return this;\n  }\n\n  /** Appends a ordinal-qualified-identifier to the output.\n   *\n   * <p>Prints \"v\" for {@code id(\"v\", 0)}, \"v#1\" for {@code id(\"v\", 1)},\n   * and so forth. */\n  public AstWriter id(String s, int i) {\n    b.append(s);\n    if (i > 0) {\n      b.append('_').append(i);\n    }\n    return this;\n  }\n\n  /** Appends a call to an infix operator. */\n  public AstWriter infix(int left, AstNode a0, Op op, AstNode a1, int right) {\n    if (op == Op.APPLY && a0.op == Op.ID) {\n      if (a0 instanceof Ast.Id) {\n        final Op op2 = Op.BY_OP_NAME.get(((Ast.Id) a0).name);\n        if (op2 != null && op2.left > 0) {\n          final List<Ast.Exp> args = ((Ast.Tuple) a1).args;\n          final Ast.InfixCall call =\n              new Ast.InfixCall(Pos.ZERO, op2, args.get(0), args.get(1));\n          return call.unparse(this, left, right);\n        }\n      }\n      if (a0 instanceof Core.Id) {\n        // TODO: obsolete Core.Id for these purposes. The operator should\n        // be a function literal, and we would use a reverse mapping to\n        // figure out which built-in operator it implements, and whether it\n        // is infix (e.g. \"+\") or in a namespace (e.g. \"#translate String\")\n        final Op op2 = Op.BY_OP_NAME.get(((Core.Id) a0).idPat.name);\n        if (op2 != null && op2.left > 0) {\n          final List<Core.Exp> args = ((Core.Tuple) a1).args;\n          return infix(left, args.get(0), op2, args.get(1), right);\n        }\n      }\n    }\n    final boolean p = parenthesize || left > op.left || op.right < right;\n    if (p) {\n      b.append('(');\n      left = right = 0;\n    }\n    append(a0, left, op.left);\n    append(op.padded);\n    append(a1, op.right, right);\n    if (p) {\n      b.append(')');\n    }\n    return this;\n  }\n\n  /** Appends a call to an prefix operator. */\n  public AstWriter prefix(int left, Op op, AstNode a, int right) {\n    final boolean p = parenthesize || left > op.left || op.right < right;\n    if (p) {\n      b.append('(');\n      right = 0;\n    }\n    append(op.padded);\n    a.unparse(this, op.right, right);\n    if (p) {\n      b.append(')');\n    }\n    return this;\n  }\n\n  /** Appends a call to a binary operator (e.g. \"val ... = ...\"). */\n  public AstWriter binary(String left, AstNode a0, String mid, AstNode a1,\n      int right) {\n    append(left);\n    a0.unparse(this, 0, 0);\n    append(mid);\n    a1.unparse(this, 0, right);\n    return this;\n  }\n\n  /** Appends a call to a binary operator (e.g. \"let ... in ... end\"). */\n  public AstWriter binary(String left, AstNode a0, String mid, AstNode a1,\n      String right) {\n    append(left);\n    a0.unparse(this, 0, 0);\n    append(mid);\n    a1.unparse(this, 0, 0);\n    append(right);\n    return this;\n  }\n\n  /** Appends a parse tree node. */\n  public AstWriter append(AstNode node, int left, int right) {\n    final boolean p =\n        parenthesize || left > node.op.left || node.op.right < right;\n    if (p) {\n      b.append('(');\n      left = right = 0;\n    }\n    node.unparse(this, left, right);\n    if (p) {\n      b.append(')');\n    }\n    return this;\n  }\n\n  /** Appends a list of parse tree nodes. */\n  public AstWriter appendAll(Iterable<? extends AstNode> nodes, int left, Op op,\n      int right) {\n    @SuppressWarnings(\"unchecked\")\n    final List<AstNode> nodeList = nodes instanceof List\n        ? (List) nodes : Lists.newArrayList(nodes);\n    for (int i = 0; i < nodeList.size(); i++) {\n      final AstNode node = nodeList.get(i);\n      final int thisLeft = i == 0 ? left : op.left;\n      final int thisRight = i == nodeList.size() - 1 ? right : op.right;\n      if (i > 0) {\n        append(op.padded);\n      }\n      append(node, thisLeft, thisRight);\n    }\n    return this;\n  }\n\n  /** Appends a list of parse tree nodes separated by {@code sep}. */\n  public AstWriter appendAll(Iterable<? extends AstNode> list, String sep) {\n    return appendAll(list, \"\", sep, \"\");\n  }\n\n  /** Appends a list of parse tree nodes separated by {@code sep}, and also with\n   * prefix and suffix: {@code start node0 sep node1 ... sep nodeN end}. */\n  public AstWriter appendAll(Iterable<? extends AstNode> list, String start,\n      String sep, String end) {\n    return appendAll(list, start, sep, end, \"\");\n  }\n\n  /** Appends a list of parse tree nodes separated by {@code sep}, and also with\n   * prefix and suffix: {@code start node0 sep node1 ... sep nodeN end}. */\n  public AstWriter appendAll(Iterable<? extends AstNode> list, String start,\n      String sep, String end, String empty) {\n    String s = start;\n    int i = 0;\n    for (AstNode node : list) {\n      ++i;\n      append(s);\n      s = sep;\n      append(node, 0, 0);\n    }\n    if (i == 0 && empty != null) {\n      append(empty);\n    } else {\n      append(end);\n    }\n    return this;\n  }\n\n  public AstWriter appendLiteral(Comparable value) {\n    if (value instanceof String) {\n      append(\"\\\"\")\n          .append(((String) value)\n              .replace(\"\\\\\", \"\\\\\\\\\")\n              .replace(\"\\\"\", \"\\\\\\\"\"))\n          .append(\"\\\"\");\n    } else if (value instanceof Character) {\n      final Character c = (Character) value;\n      append(\"#\\\"\")\n          .append(c == '\"' ? \"\\\\\\\"\"\n              : c == '\\\\' ? \"\\\\\\\\\"\n                  : c.toString())\n          .append(\"\\\"\");\n    } else if (value instanceof BigDecimal) {\n      BigDecimal c = (BigDecimal) value;\n      if (c.compareTo(BigDecimal.ZERO) < 0) {\n        append(\"~\");\n        c = c.negate();\n      }\n      append(c.toString());\n    } else if (value instanceof BuiltIn) {\n      final BuiltIn builtIn = (BuiltIn) value;\n      if (builtIn.structure != null && !builtIn.structure.equals(\"$\")) {\n        // E.g. \"#find List\" for the List.find function\n        append(\"#\").append(builtIn.mlName)\n            .append(\" \").append(builtIn.structure);\n      } else {\n        append(builtIn.mlName);\n      }\n    } else {\n      append(value.toString());\n    }\n    return this;\n  }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private final StringBuilder b;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "StringBuilder", "name": "b", "syntax_pass": true}, {"attribute_expression": "private final boolean parenthesize;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "boolean", "name": "parenthesize", "syntax_pass": true}]}, {"uris": "src/main/java/net/hydromatic/morel/ast/Pos.java.Pos", "name": "Pos", "file_path": "src/main/java/net/hydromatic/morel/ast/Pos.java", "superclasses": "", "methods": ["[]Pos(String,int,int,int,int)", "[Pos]of(String,String,int,int)", "[Pair<@NonNull String, @NonNull Pos>]split(String,char,String)", "[int]hashCode()", "[boolean]equals(Object)", "[String]toString()", "[StringBuilder]describeTo(StringBuilder)", "[Pos]sum(Iterable<Pos>)", "[Pos]sum(Iterable<E>,Function<E, Pos>)", "[Pos]sum(List<? extends AstNode>)", "[Pos]sum_(List<Pos>)", "[Pos]sum(Iterable<Pos>,int,int,int,int)", "[Pos]plus(Pos)", "[Pos]plusAll(Iterable<Pos>)", "[Pos]plusAll(List<? extends AstNode>)", "[IntPair]lineCol(String,int)"], "method_uris": ["src/main/java/net/hydromatic/morel/ast/Pos.java.Pos.[]Pos(String,int,int,int,int)", "src/main/java/net/hydromatic/morel/ast/Pos.java.Pos.[Pos]of(String,String,int,int)", "src/main/java/net/hydromatic/morel/ast/Pos.java.Pos.[Pair<@NonNull String, @NonNull Pos>]split(String,char,String)", "src/main/java/net/hydromatic/morel/ast/Pos.java.Pos.[int]hashCode()", "src/main/java/net/hydromatic/morel/ast/Pos.java.Pos.[boolean]equals(Object)", "src/main/java/net/hydromatic/morel/ast/Pos.java.Pos.[String]toString()", "src/main/java/net/hydromatic/morel/ast/Pos.java.Pos.[StringBuilder]describeTo(StringBuilder)", "src/main/java/net/hydromatic/morel/ast/Pos.java.Pos.[Pos]sum(Iterable<Pos>)", "src/main/java/net/hydromatic/morel/ast/Pos.java.Pos.[Pos]sum(Iterable<E>,Function<E, Pos>)", "src/main/java/net/hydromatic/morel/ast/Pos.java.Pos.[Pos]sum(List<? extends AstNode>)", "src/main/java/net/hydromatic/morel/ast/Pos.java.Pos.[Pos]sum_(List<Pos>)", "src/main/java/net/hydromatic/morel/ast/Pos.java.Pos.[Pos]sum(Iterable<Pos>,int,int,int,int)", "src/main/java/net/hydromatic/morel/ast/Pos.java.Pos.[Pos]plus(Pos)", "src/main/java/net/hydromatic/morel/ast/Pos.java.Pos.[Pos]plusAll(Iterable<Pos>)", "src/main/java/net/hydromatic/morel/ast/Pos.java.Pos.[Pos]plusAll(List<? extends AstNode>)", "src/main/java/net/hydromatic/morel/ast/Pos.java.Pos.[IntPair]lineCol(String,int)"], "overrides": null, "attributes": [], "class_docstring": " Position of a parse-tree node.", "original_string": "public class Pos {\n  public static final Pos ZERO = new Pos(\"\", 0, 0, 0, 0);\n\n  public final String file;\n  public final int startLine;\n  public final int startColumn;\n  public final int endLine;\n  public final int endColumn;\n\n  /** Creates a Pos. */\n  public Pos(String file, int startLine, int startColumn,\n      int endLine, int endColumn) {\n    this.file = file;\n    this.startLine = startLine;\n    this.startColumn = startColumn;\n    this.endLine = endLine;\n    this.endColumn = endColumn;\n  }\n\n  /** Creates a Pos from two offsets. */\n  public static Pos of(String ml, String file, int startOffset, int endOffset) {\n    IntPair start = lineCol(ml, startOffset);\n    IntPair end = lineCol(ml, endOffset);\n    return new Pos(file, start.source, start.target, end.source, end.target);\n  }\n\n  /** Creates a Pos from a filename and a string with a delimiter character.\n   * The delimiter must occur exactly twice in the string. */\n  public static Pair<@NonNull String, @NonNull Pos> split(String s,\n      char delimiter, String file) {\n    final int i = s.indexOf(delimiter);\n    final int j = s.indexOf(delimiter, i + 1);\n    final int k = s.indexOf(delimiter, j + 1);\n    if (i < 0 || j <= i || k >= 0) {\n      throw new IllegalArgumentException(\"expected exactly two occurrences \"\n          + \"of delimiter, '\" + delimiter + \"'\");\n    }\n    final String s2 = s.substring(0, i)\n        + s.substring(i + 1, j)\n        + s.substring(j + 1);\n    final Pos pos = of(s2, file, i, j - 1);\n    return Pair.of(s2, pos);\n  }\n\n  @Override public int hashCode() {\n    return Objects.hash(startLine, startColumn, endLine, endColumn);\n  }\n\n  @Override public boolean equals(Object o) {\n    return o == this\n        || o instanceof Pos\n        && this.startLine == ((Pos) o).startLine\n        && this.startColumn == ((Pos) o).startColumn\n        && this.endLine == ((Pos) o).endLine\n        && this.endColumn == ((Pos) o).endColumn;\n  }\n\n  @Override public String toString() {\n    return describeTo(new StringBuilder()).toString();\n  }\n\n  public StringBuilder describeTo(StringBuilder buf) {\n    buf.append(file)\n        .append(file.isEmpty() ? \"\" : \":\")\n        .append(startLine)\n        .append('.')\n        .append(startColumn);\n    if (endColumn != startColumn + 1 || endLine != startLine) {\n      buf.append('-')\n          .append(endLine)\n          .append('.')\n          .append(endColumn);\n    }\n    return buf;\n  }\n\n  /**\n   * Combines an iterable of parser positions to create a position which spans\n   * from the beginning of the first to the end of the last.\n   */\n  public static Pos sum(Iterable<Pos> poses) {\n    final List<Pos> list =\n        poses instanceof List\n            ? (List<Pos>) poses\n            : Lists.newArrayList(poses);\n    return sum_(list);\n  }\n\n  public static <E> Pos sum(Iterable<E> elements, Function<E, Pos> fn) {\n    //noinspection StaticPseudoFunctionalStyleMethod\n    return sum(Iterables.transform(elements, fn::apply));\n  }\n\n  public static Pos sum(List<? extends AstNode> nodes) {\n    return sum(nodes, node -> node.pos);\n  }\n\n  /**\n   * Combines a list of parser positions to create a position which spans\n   * from the beginning of the first to the end of the last.\n   */\n  private static Pos sum_(final List<Pos> positions) {\n    switch (positions.size()) {\n    case 0:\n      throw new AssertionError();\n    case 1:\n      return positions.get(0);\n    default:\n      final List<Pos> poses = new AbstractList<Pos>() {\n        public Pos get(int index) {\n          return positions.get(index + 1);\n        }\n        public int size() {\n          return positions.size() - 1;\n        }\n      };\n      final Pos p = positions.get(0);\n      return sum(poses, p.startLine, p.startColumn, p.endLine, p.endColumn);\n    }\n  }\n\n\n  /**\n   * Computes the parser position which is the sum of an array of parser\n   * positions and of a parser position represented by (line, column, endLine,\n   * endColumn).\n   *\n   * @param poses     Array of parser positions\n   * @param line      Start line\n   * @param column    Start column\n   * @param endLine   End line\n   * @param endColumn End column\n   * @return Sum of parser positions\n   */\n  private static Pos sum(\n      Iterable<Pos> poses,\n      int line,\n      int column,\n      int endLine,\n      int endColumn) {\n    int testLine;\n    int testColumn;\n    String file = Pos.ZERO.file;\n    for (Pos pos : poses) {\n      if (pos == null || pos.equals(Pos.ZERO)) {\n        continue;\n      }\n      file = pos.file;\n      testLine = pos.startLine;\n      testColumn = pos.startColumn;\n      if (testLine < line || testLine == line && testColumn < column) {\n        line = testLine;\n        column = testColumn;\n      }\n\n      testLine = pos.endLine;\n      testColumn = pos.endColumn;\n      if (testLine > endLine || testLine == endLine && testColumn > endColumn) {\n        endLine = testLine;\n        endColumn = testColumn;\n      }\n    }\n    return new Pos(file, line, column, endLine, endColumn);\n  }\n\n  public Pos plus(Pos pos) {\n    int startLine = this.startLine;\n    int startColumn = this.startColumn;\n    if (pos.startLine < startLine\n        || pos.startLine == startLine\n        && pos.startColumn < startColumn) {\n      startLine = pos.startLine;\n      startColumn = pos.startColumn;\n    }\n    int endLine = pos.endLine;\n    int endColumn = pos.endColumn;\n    if (this.endLine > endLine\n        || this.endLine == endLine\n        && this.endColumn > endColumn) {\n      endLine = this.endLine;\n      endColumn = this.endColumn;\n    }\n    return new Pos(file, startLine, startColumn, endLine, endColumn);\n  }\n\n  public Pos plusAll(Iterable<Pos> poses) {\n    return sum(poses, startLine, startColumn, endLine, endColumn);\n  }\n\n  public Pos plusAll(@NonNull List<? extends AstNode> nodes) {\n    //noinspection StaticPseudoFunctionalStyleMethod,ConstantConditions\n    return plusAll(Lists.transform(nodes, (AstNode node) -> node.pos));\n  }\n\n  /** Returns the 1-based line. */\n  private static IntPair lineCol(String s, int offset) {\n    int line = 1;\n    int lineStart = 0;\n    int i;\n    final int n = Math.min(s.length(), offset);\n    for (i = 0; i < n; i++) {\n      if (s.charAt(i) == '\\n') {\n        ++line;\n        lineStart = i + 1;\n      }\n    }\n    if (i == offset) {\n      return IntPair.of(line, offset - lineStart + 1);\n    } else {\n      throw new IllegalArgumentException(\"not found\");\n    }\n  }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "public static final Pos ZERO = new Pos(\"\", 0, 0, 0, 0);", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "Pos", "name": "ZERO = new Pos(\"\", 0, 0, 0, 0)", "syntax_pass": true}, {"attribute_expression": "public final String file;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "String", "name": "file", "syntax_pass": true}, {"attribute_expression": "public final int startLine;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "int", "name": "startLine", "syntax_pass": true}, {"attribute_expression": "public final int startColumn;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "int", "name": "startColumn", "syntax_pass": true}, {"attribute_expression": "public final int endLine;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "int", "name": "endLine", "syntax_pass": true}, {"attribute_expression": "public final int endColumn;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "int", "name": "endColumn", "syntax_pass": true}]}, {"uris": "src/main/java/net/hydromatic/morel/ast/FromBuilder.java.FromBuilder", "name": "FromBuilder", "file_path": "src/main/java/net/hydromatic/morel/ast/FromBuilder.java", "superclasses": "", "methods": ["[]FromBuilder(TypeSystem,Environment)", "[void]clear()", "[String]toString()", "[List<Binding>]bindings()", "[FromBuilder]addStep(Core.FromStep)", "[FromBuilder]scan(Core.Pat)", "[FromBuilder]scan(Core.Pat,Core.Exp)", "[FromBuilder]scan(Core.Pat,Core.Exp,Core.Exp)", "[FromBuilder]addAll(Iterable<? extends Core.FromStep>)", "[FromBuilder]where(Core.Exp)", "[FromBuilder]skip(Core.Exp)", "[FromBuilder]take(Core.Exp)", "[FromBuilder]group(SortedMap<Core.IdPat, Core.Exp>,SortedMap<Core.IdPat, Core.Aggregate>)", "[FromBuilder]order(Iterable<Core.OrderItem>)", "[FromBuilder]yield_(Core.Exp)", "[FromBuilder]yield_(boolean,Core.Exp)", "[FromBuilder]yield_(boolean,List<Binding>,Core.Exp)", "[boolean]isTrivial(Core.Tuple,List<Binding>,List<Binding>)", "[TupleType]tupleType(Core.Tuple,List<Binding>,List<Binding>)", "[Core.Exp]build(boolean)", "[Core.From]build()", "[Core.Exp]buildSimplify()"], "method_uris": ["src/main/java/net/hydromatic/morel/ast/FromBuilder.java.FromBuilder.[]FromBuilder(TypeSystem,Environment)", "src/main/java/net/hydromatic/morel/ast/FromBuilder.java.FromBuilder.[void]clear()", "src/main/java/net/hydromatic/morel/ast/FromBuilder.java.FromBuilder.[String]toString()", "src/main/java/net/hydromatic/morel/ast/FromBuilder.java.FromBuilder.[List<Binding>]bindings()", "src/main/java/net/hydromatic/morel/ast/FromBuilder.java.FromBuilder.[FromBuilder]addStep(Core.FromStep)", "src/main/java/net/hydromatic/morel/ast/FromBuilder.java.FromBuilder.[FromBuilder]scan(Core.Pat)", "src/main/java/net/hydromatic/morel/ast/FromBuilder.java.FromBuilder.[FromBuilder]scan(Core.Pat,Core.Exp)", "src/main/java/net/hydromatic/morel/ast/FromBuilder.java.FromBuilder.[FromBuilder]scan(Core.Pat,Core.Exp,Core.Exp)", "src/main/java/net/hydromatic/morel/ast/FromBuilder.java.FromBuilder.[FromBuilder]addAll(Iterable<? extends Core.FromStep>)", "src/main/java/net/hydromatic/morel/ast/FromBuilder.java.FromBuilder.[FromBuilder]where(Core.Exp)", "src/main/java/net/hydromatic/morel/ast/FromBuilder.java.FromBuilder.[FromBuilder]skip(Core.Exp)", "src/main/java/net/hydromatic/morel/ast/FromBuilder.java.FromBuilder.[FromBuilder]take(Core.Exp)", "src/main/java/net/hydromatic/morel/ast/FromBuilder.java.FromBuilder.[FromBuilder]group(SortedMap<Core.IdPat, Core.Exp>,SortedMap<Core.IdPat, Core.Aggregate>)", "src/main/java/net/hydromatic/morel/ast/FromBuilder.java.FromBuilder.[FromBuilder]order(Iterable<Core.OrderItem>)", "src/main/java/net/hydromatic/morel/ast/FromBuilder.java.FromBuilder.[FromBuilder]yield_(Core.Exp)", "src/main/java/net/hydromatic/morel/ast/FromBuilder.java.FromBuilder.[FromBuilder]yield_(boolean,Core.Exp)", "src/main/java/net/hydromatic/morel/ast/FromBuilder.java.FromBuilder.[FromBuilder]yield_(boolean,List<Binding>,Core.Exp)", "src/main/java/net/hydromatic/morel/ast/FromBuilder.java.FromBuilder.[boolean]isTrivial(Core.Tuple,List<Binding>,List<Binding>)", "src/main/java/net/hydromatic/morel/ast/FromBuilder.java.FromBuilder.[TupleType]tupleType(Core.Tuple,List<Binding>,List<Binding>)", "src/main/java/net/hydromatic/morel/ast/FromBuilder.java.FromBuilder.[Core.Exp]build(boolean)", "src/main/java/net/hydromatic/morel/ast/FromBuilder.java.FromBuilder.[Core.From]build()", "src/main/java/net/hydromatic/morel/ast/FromBuilder.java.FromBuilder.[Core.Exp]buildSimplify()"], "overrides": null, "attributes": [{"original_string": "  private class StepHandler extends Visitor {\n    @Override protected void visit(Core.Group group) {\n      group(group.groupExps, group.aggregates);\n    }\n\n    @Override protected void visit(Core.Order order) {\n      order(order.orderItems);\n    }\n\n    @Override protected void visit(Core.Scan scan) {\n      scan(scan.pat, scan.exp, scan.condition);\n    }\n\n    @Override protected void visit(Core.Where where) {\n      where(where.exp);\n    }\n\n    @Override protected void visit(Core.Skip skip) {\n      skip(skip.exp);\n    }\n\n    @Override protected void visit(Core.Take take) {\n      take(take.exp);\n    }\n\n    @Override protected void visit(Core.Yield yield) {\n      yield_(false, yield.bindings, yield.exp);\n    }\n  }", "definition": "  private class StepHandler extends Visitor", "class_docstring": " Calls the method to re-register a step.", "name": "StepHandler", "super_interfaces": [], "superclasses": "Visitor", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @Override protected void visit(Core.Group group) {\n      group(group.groupExps, group.aggregates);\n    }", "docstring": "", "attributes": {"modifiers": "@Override protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "name": "visit", "params": [{"name": "group", "type": "Core.Group"}], "body": "                                                     {\n      group(group.groupExps, group.aggregates);\n    }", "signature": "@Override protected void visit(Core.Group group)"}, {"syntax_pass": true, "original_string": "    @Override protected void visit(Core.Order order) {\n      order(order.orderItems);\n    }", "docstring": "", "attributes": {"modifiers": "@Override protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "name": "visit", "params": [{"name": "order", "type": "Core.Order"}], "body": "                                                     {\n      order(order.orderItems);\n    }", "signature": "@Override protected void visit(Core.Order order)"}, {"syntax_pass": true, "original_string": "    @Override protected void visit(Core.Scan scan) {\n      scan(scan.pat, scan.exp, scan.condition);\n    }", "docstring": "", "attributes": {"modifiers": "@Override protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "name": "visit", "params": [{"name": "scan", "type": "Core.Scan"}], "body": "                                                   {\n      scan(scan.pat, scan.exp, scan.condition);\n    }", "signature": "@Override protected void visit(Core.Scan scan)"}, {"syntax_pass": true, "original_string": "    @Override protected void visit(Core.Where where) {\n      where(where.exp);\n    }", "docstring": "", "attributes": {"modifiers": "@Override protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "name": "visit", "params": [{"name": "where", "type": "Core.Where"}], "body": "                                                     {\n      where(where.exp);\n    }", "signature": "@Override protected void visit(Core.Where where)"}, {"syntax_pass": true, "original_string": "    @Override protected void visit(Core.Skip skip) {\n      skip(skip.exp);\n    }", "docstring": "", "attributes": {"modifiers": "@Override protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "name": "visit", "params": [{"name": "skip", "type": "Core.Skip"}], "body": "                                                   {\n      skip(skip.exp);\n    }", "signature": "@Override protected void visit(Core.Skip skip)"}, {"syntax_pass": true, "original_string": "    @Override protected void visit(Core.Take take) {\n      take(take.exp);\n    }", "docstring": "", "attributes": {"modifiers": "@Override protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "name": "visit", "params": [{"name": "take", "type": "Core.Take"}], "body": "                                                   {\n      take(take.exp);\n    }", "signature": "@Override protected void visit(Core.Take take)"}, {"syntax_pass": true, "original_string": "    @Override protected void visit(Core.Yield yield) {\n      yield_(false, yield.bindings, yield.exp);\n    }", "docstring": "", "attributes": {"modifiers": "@Override protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "name": "visit", "params": [{"name": "yield", "type": "Core.Yield"}], "body": "                                                     {\n      yield_(false, yield.bindings, yield.exp);\n    }", "signature": "@Override protected void visit(Core.Yield yield)"}]}], "class_docstring": " Builds a {@link Core.From}.\n\n<p>Simplifies the following patterns:\n<ul>\n  <li>Converts \"from v in list\" to \"list\"\n  (only works in {@link #buildSimplify()}, not {@link #build()});\n  <li>Removes \"where true\" steps;\n  <li>Removes empty \"order\" steps;\n  <li>Removes trivial {@code yield},\n  e.g. \"from v in list where condition yield v\"\n  becomes \"from v in list where condition\";\n  <li>Inlines {@code from} expressions,\n  e.g. \"from v in (from w in list)\"\n  becomes \"from w in list yield {v = w}\".\n</ul>\n", "original_string": "public class FromBuilder {\n  private final TypeSystem typeSystem;\n  private final @Nullable Environment env;\n  private final List<Core.FromStep> steps = new ArrayList<>();\n  private final List<Binding> bindings = new ArrayList<>();\n\n  /** If non-negative, flags that particular step should be removed if it is not\n   * the last step. (For example, \"yield {i = i}\", which changes the result\n   * shape if the last step but is otherwise a no-op.) */\n  private int removeIfNotLastIndex = Integer.MIN_VALUE;\n  /** If non-negative, flags that particular step should be removed if it is\n   * the last step. (For example, we flatten \"from p in (from q in list)\",\n   * to \"from q in list yield {p = q}\" but we want to remove \"yield {p = q}\"\n   * if it turns out to be the last step.) */\n  private int removeIfLastIndex = Integer.MIN_VALUE;\n\n  /** Use {@link net.hydromatic.morel.ast.CoreBuilder#fromBuilder}. */\n  FromBuilder(TypeSystem typeSystem, @Nullable Environment env) {\n    this.typeSystem = typeSystem;\n    this.env = env;\n  }\n\n  /** Resets state as if this {@code FromBuilder} had just been created. */\n  public void clear() {\n    steps.clear();\n    bindings.clear();\n    removeIfNotLastIndex = Integer.MIN_VALUE;\n    removeIfLastIndex = Integer.MIN_VALUE;\n  }\n\n  @Override public String toString() {\n    return steps.toString();\n  }\n\n  /** Returns the bindings available after the most recent step. */\n  public List<Binding> bindings() {\n    return ImmutableList.copyOf(bindings);\n  }\n\n  private FromBuilder addStep(Core.FromStep step) {\n    if (env != null) {\n      // Validate the step. (Not necessary, but helps find bugs.)\n      RefChecker.of(typeSystem, env.bindAll(bindings))\n          .visitStep(step, bindings);\n    }\n    if (removeIfNotLastIndex == steps.size() - 1) {\n      // A trivial record yield with a single yield, e.g. 'yield {i = i}', has\n      // a purpose only if it is the last step. (It forces the return to be a\n      // record, e.g. '{i: int}' rather than a scalar 'int'.)\n      // We've just about to add a new step, so this is no longer necessary.\n      removeIfNotLastIndex = Integer.MIN_VALUE;\n      removeIfLastIndex = Integer.MIN_VALUE;\n      final Core.FromStep lastStep = getLast(steps);\n      if (lastStep.op == Op.YIELD) {\n        final Core.Yield yield = (Core.Yield) lastStep;\n        if (yield.exp.op == Op.TUPLE) {\n          final Core.Tuple tuple = (Core.Tuple) yield.exp;\n          final Core.FromStep previousStep = steps.get(steps.size() - 2);\n          final List<Binding> previousBindings = previousStep.bindings;\n          if (tuple.args.size() == 1\n              && isTrivial(tuple, previousBindings, yield.bindings)) {\n            steps.remove(steps.size() - 1);\n          }\n        }\n      }\n    }\n    steps.add(step);\n    if (!bindings.equals(step.bindings)) {\n      bindings.clear();\n      bindings.addAll(step.bindings);\n    }\n    return this;\n  }\n\n  /** Creates an unbounded scan, \"from pat\". */\n  public FromBuilder scan(Core.Pat pat) {\n    final Core.Exp extent =\n        core.extent(typeSystem, pat.type, ImmutableRangeSet.of(Range.all()));\n    return scan(pat, extent, core.boolLiteral(true));\n  }\n\n  /** Creates a bounded scan, \"from pat in exp\". */\n  public FromBuilder scan(Core.Pat pat, Core.Exp exp) {\n    return scan(pat, exp, core.boolLiteral(true));\n  }\n\n  public FromBuilder scan(Core.Pat pat, Core.Exp exp, Core.Exp condition) {\n    if (exp.op == Op.FROM\n        && core.boolLiteral(true).equals(condition)\n        && (pat instanceof Core.IdPat\n            && !((Core.From) exp).steps.isEmpty()\n            && getLast(((Core.From) exp).steps).bindings.size() == 1\n            || pat instanceof Core.RecordPat\n                && ((Core.RecordPat) pat).args.stream()\n                    .allMatch(a -> a instanceof Core.IdPat)\n            || pat instanceof Core.TuplePat\n                && ((Core.TuplePat) pat).args.stream()\n                    .allMatch(a -> a instanceof Core.IdPat))) {\n      final Core.From from = (Core.From) exp;\n      final Core.FromStep lastStep = getLast(from.steps);\n      final List<Core.FromStep> steps =\n          lastStep.op == Op.YIELD ? Util.skipLast(from.steps) : from.steps;\n\n      final PairList<String, Core.Exp> nameExps = PairList.of();\n      boolean uselessIfLast = this.bindings.isEmpty();\n      final List<Binding> bindings;\n      if (pat instanceof Core.RecordPat) {\n        final Core.RecordPat recordPat = (Core.RecordPat) pat;\n        this.bindings.forEach(b -> nameExps.add(b.id.name, core.id(b.id)));\n        forEach(recordPat.type().argNameTypes.keySet(), recordPat.args,\n            (name, arg) -> nameExps.add(name, core.id((Core.IdPat) arg)));\n        bindings = null;\n      } else if (pat instanceof Core.TuplePat) {\n        final Core.TuplePat tuplePat = (Core.TuplePat) pat;\n        forEach(tuplePat.args, lastStep.bindings,\n            (arg, binding) ->\n                nameExps.add(((Core.IdPat) arg).name, core.id(binding.id)));\n        bindings = null;\n      } else if (!this.bindings.isEmpty()) {\n        // With at least one binding, and one new variable, the output will be\n        // a record type.\n        final Core.IdPat idPat = (Core.IdPat) pat;\n        this.bindings.forEach(b -> nameExps.add(b.id.name, core.id(b.id)));\n        lastStep.bindings.forEach(b -> nameExps.add(idPat.name, core.id(b.id)));\n        bindings = null;\n      } else {\n        final Core.IdPat idPat = (Core.IdPat) pat;\n        if (lastStep instanceof Core.Yield\n            && ((Core.Yield) lastStep).exp.op != Op.RECORD) {\n          // The last step is a yield scalar, say 'yield x + 1'.\n          // Translate it to a yield singleton record, say 'yield {y = x + 1}'\n          addAll(steps);\n          if (((Core.Yield) lastStep).exp.op == Op.ID\n              && this.bindings.size() == 1) {\n            // The last step is 'yield e'. Skip it.\n            return this;\n          }\n          nameExps.add(idPat.name, ((Core.Yield) lastStep).exp);\n          bindings = ImmutableList.of(Binding.of(idPat));\n          return yield_(false, bindings, core.record(typeSystem, nameExps));\n        }\n        final Binding binding = Iterables.getOnlyElement(lastStep.bindings);\n        nameExps.add(idPat.name, core.id(binding.id));\n        bindings = append(this.bindings, Binding.of(idPat));\n      }\n      addAll(steps);\n      return yield_(uselessIfLast, bindings, core.record(typeSystem, nameExps));\n    }\n    Compiles.acceptBinding(typeSystem, pat, bindings);\n    return addStep(core.scan(bindings, pat, exp, condition));\n  }\n\n  public FromBuilder addAll(Iterable<? extends Core.FromStep> steps) {\n    final StepHandler stepHandler = new StepHandler();\n    steps.forEach(stepHandler::accept);\n    return this;\n  }\n\n  public FromBuilder where(Core.Exp condition) {\n    if (condition.op == Op.BOOL_LITERAL\n        && ((Core.Literal) condition).unwrap(Boolean.class)) {\n      // skip \"where true\"\n      return this;\n    }\n    return addStep(core.where(bindings, condition));\n  }\n\n  public FromBuilder skip(Core.Exp count) {\n    if (count.op == Op.INT_LITERAL\n        && ((Core.Literal) count).value.equals(BigDecimal.ZERO)) {\n      // skip \"skip 0\"\n      return this;\n    }\n    return addStep(core.skip(bindings, count));\n  }\n\n  public FromBuilder take(Core.Exp count) {\n    return addStep(core.take(bindings, count));\n  }\n\n  public FromBuilder group(SortedMap<Core.IdPat, Core.Exp> groupExps,\n      SortedMap<Core.IdPat, Core.Aggregate> aggregates) {\n    return addStep(core.group(groupExps, aggregates));\n  }\n\n  public FromBuilder order(Iterable<Core.OrderItem> orderItems) {\n    final List<Core.OrderItem> orderItemList = ImmutableList.copyOf(orderItems);\n    if (orderItemList.isEmpty()) {\n      // skip empty \"order\"\n      return this;\n    }\n    return addStep(core.order(bindings, orderItems));\n  }\n\n  public FromBuilder yield_(Core.Exp exp) {\n    return yield_(false, exp);\n  }\n\n  public FromBuilder yield_(boolean uselessIfLast, Core.Exp exp) {\n    return yield_(uselessIfLast, null, exp);\n  }\n\n  /** Creates a \"yield\" step.\n   *\n   * <p>When copying, the {@code bindings2} parameter is the\n   * {@link net.hydromatic.morel.ast.Core.Yield#bindings} value of the current\n   * Yield, so that we don't generate new variables (with different ordinals).\n   * Later steps are relying on the variables remaining the same. For example,\n   * in\n   *\n   * <blockquote>{@code\n   * from ... yield {a = b} where a > 5\n   * }</blockquote>\n   *\n   * <p>the {@code a} in {@code a > 5} references {@code IdPat('a', 0)} and we\n   * don't want yield to generate an {@code IdPat('a', 1)}.\n   *\n   * @param uselessIfLast Whether this Yield will be useless if it is the last\n   *                      step. The expression {@code {x = y} } is an example of\n   *                      this\n   * @param bindings2     Desired bindings, or null\n   * @param exp           Expression to yield\n   *\n   * @return This FromBuilder, with a Yield added to the list of steps\n   */\n  public FromBuilder yield_(boolean uselessIfLast,\n      @Nullable List<Binding> bindings2, Core.Exp exp) {\n    boolean uselessIfNotLast = false;\n    switch (exp.op) {\n    case TUPLE:\n      final TupleType tupleType =\n          tupleType((Core.Tuple) exp, bindings, bindings2);\n      switch (tupleType) {\n      case IDENTITY:\n        // A trivial record does not rename, so its only purpose is to change\n        // from a scalar to a record, and even then only when a singleton.\n        if (bindings.size() == 1) {\n          // Singleton record that does not rename, e.g. 'yield {x=x}'\n          // It only has meaning as the last step.\n          if (bindings2 == null) {\n            bindings2 = ImmutableList.copyOf(bindings);\n          }\n          uselessIfNotLast = true;\n          break;\n        } else {\n          // Non-singleton record that does not rename, e.g. 'yield {x=x,y=y}'\n          // It is useless.\n          return this;\n        }\n      case RENAME:\n        if (bindings.size() == 1) {\n          // Singleton record that renames, e.g. 'yield {y=x}'.\n          // It is always useful.\n          break;\n        } else {\n          // Non-singleton record that renames, e.g. 'yield {y=x,z=y}'\n          // It is always useful.\n          break;\n        }\n      }\n      break;\n\n    case ID:\n      if (bindings.size() == 1\n          && ((Core.Id) exp).idPat.equals(bindings.get(0).id)) {\n        return this;\n      }\n    }\n    addStep(bindings2 != null\n        ? core.yield_(bindings2, exp)\n        : core.yield_(typeSystem, exp));\n    removeIfNotLastIndex = uselessIfNotLast ? steps.size() - 1 : Integer.MIN_VALUE;\n    removeIfLastIndex = uselessIfLast ? steps.size() - 1 : Integer.MIN_VALUE;\n    return this;\n  }\n\n  /** Returns whether tuple is something like \"{i = i, j = j}\". */\n  private static boolean isTrivial(Core.Tuple tuple, List<Binding> bindings,\n      @Nullable List<Binding> bindings2) {\n    return tupleType(tuple, bindings, bindings2) == TupleType.IDENTITY;\n  }\n\n  /** Returns whether tuple is something like \"{i = i, j = j}\". */\n  private static TupleType tupleType(Core.Tuple tuple, List<Binding> bindings,\n      @Nullable List<Binding> bindings2) {\n    if (tuple.args.size() != bindings.size()) {\n      return TupleType.OTHER;\n    }\n    final ImmutableList<String> argNames =\n        ImmutableList.copyOf(tuple.type().argNameTypes().keySet());\n    boolean identity = bindings2 == null || bindings.equals(bindings2);\n    for (int i = 0; i < tuple.args.size(); i++) {\n      Core.Exp exp = tuple.args.get(i);\n      if (exp.op != Op.ID) {\n        return TupleType.OTHER;\n      }\n      if (!((Core.Id) exp).idPat.name.equals(argNames.get(i))) {\n        identity = false;\n      }\n    }\n    return identity ? TupleType.IDENTITY : TupleType.RENAME;\n  }\n\n  private Core.Exp build(boolean simplify) {\n    if (removeIfLastIndex == steps.size() - 1) {\n      removeIfLastIndex = Integer.MIN_VALUE;\n      final Core.Yield yield = (Core.Yield) getLast(steps);\n      if (yield.exp.op != Op.TUPLE\n          || ((Core.Tuple) yield.exp).args.size() != 1) {\n        throw new AssertionError(yield.exp);\n      }\n      steps.remove(steps.size() - 1);\n    }\n    if (simplify\n        && steps.size() == 1\n        && steps.get(0).op == Op.SCAN) {\n      final Core.Scan scan = (Core.Scan) steps.get(0);\n      if (scan.pat.op == Op.ID_PAT) {\n        return scan.exp;\n      }\n    }\n    return core.from(typeSystem, steps);\n  }\n\n  public Core.From build() {\n    return (Core.From) build(false);\n  }\n\n  /** As {@link #build}, but also simplifies \"from x in list\" to \"list\". */\n  public Core.Exp buildSimplify() {\n    return build(true);\n  }\n\n  /** Calls the method to re-register a step. */\n  private class StepHandler extends Visitor {\n    @Override protected void visit(Core.Group group) {\n      group(group.groupExps, group.aggregates);\n    }\n\n    @Override protected void visit(Core.Order order) {\n      order(order.orderItems);\n    }\n\n    @Override protected void visit(Core.Scan scan) {\n      scan(scan.pat, scan.exp, scan.condition);\n    }\n\n    @Override protected void visit(Core.Where where) {\n      where(where.exp);\n    }\n\n    @Override protected void visit(Core.Skip skip) {\n      skip(skip.exp);\n    }\n\n    @Override protected void visit(Core.Take take) {\n      take(take.exp);\n    }\n\n    @Override protected void visit(Core.Yield yield) {\n      yield_(false, yield.bindings, yield.exp);\n    }\n  }\n\n  /** Category of expression passed to \"yield\". */\n  private enum TupleType {\n    /** Tuple whose right side are the current fields,\n     * e.g. \"{a = deptno, b = dname}\". */\n    RENAME,\n    /** Tuple whose right side are the current fields\n     * and left side are the same as the right,\n     * e.g. \"{deptno = deptno, dname = dname}\". */\n    IDENTITY,\n    /** Any other tuple,\n     * e.g. \"{a = deptno + 1, dname = dname}\",\n     * \"{deptno = deptno}\" (too few fields). */\n    OTHER\n  }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private final TypeSystem typeSystem;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "TypeSystem", "name": "typeSystem", "syntax_pass": true}, {"attribute_expression": "private final @Nullable Environment env;", "docstring": "", "modifiers": "private final @Nullable", "marker_annotations": ["@Nullable"], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Environment", "name": "env", "syntax_pass": true}, {"attribute_expression": "private final List<Core.FromStep> steps = new ArrayList<>();", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "List<Core.FromStep>", "name": "steps = new ArrayList<>()", "syntax_pass": true}, {"attribute_expression": "private final List<Binding> bindings = new ArrayList<>();", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "List<Binding>", "name": "bindings = new ArrayList<>()", "syntax_pass": true}, {"attribute_expression": "private int removeIfNotLastIndex = Integer.MIN_VALUE;", "docstring": " If non-negative, flags that particular step should be removed if it is not\nthe last step. (For example, \"yield {i = i}\", which changes the result\nshape if the last step but is otherwise a no-op.)", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "int", "name": "removeIfNotLastIndex = Integer.MIN_VALUE", "syntax_pass": true}, {"attribute_expression": "private int removeIfLastIndex = Integer.MIN_VALUE;", "docstring": " If non-negative, flags that particular step should be removed if it is\nthe last step. (For example, we flatten \"from p in (from q in list)\",\nto \"from q in list yield {p = q}\" but we want to remove \"yield {p = q}\"\nif it turns out to be the last step.)", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "int", "name": "removeIfLastIndex = Integer.MIN_VALUE", "syntax_pass": true}]}, {"uris": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle", "name": "Shuttle", "file_path": "src/main/java/net/hydromatic/morel/ast/Shuttle.java", "superclasses": "", "methods": ["[]Shuttle(TypeSystem)", "[List<E>]visitList(List<E>)", "[Map<K, E>]visitMap(Map<K, E>)", "[SortedMap<K, E>]visitSortedMap(SortedMap<K, E>)", "[Ast.Exp]visit(Ast.Literal)", "[Ast.Id]visit(Ast.Id)", "[Ast.Exp]visit(Ast.AnnotatedExp)", "[Ast.Exp]visit(Ast.If)", "[Ast.Let]visit(Ast.Let)", "[Ast.Exp]visit(Ast.Case)", "[Ast.Exp]visit(Ast.InfixCall)", "[Ast.Exp]visit(Ast.PrefixCall)", "[Ast.Pat]visit(Ast.IdPat)", "[Ast.Pat]visit(Ast.LiteralPat)", "[Ast.Pat]visit(Ast.WildcardPat)", "[Ast.Pat]visit(Ast.InfixPat)", "[Ast.Pat]visit(Ast.TuplePat)", "[Ast.Pat]visit(Ast.ListPat)", "[Ast.Pat]visit(Ast.RecordPat)", "[Ast.Pat]visit(Ast.AnnotatedPat)", "[Ast.Pat]visit(Ast.AsPat)", "[Ast.ConPat]visit(Ast.ConPat)", "[Ast.Con0Pat]visit(Ast.Con0Pat)", "[Ast.Exp]visit(Ast.Tuple)", "[Ast.ListExp]visit(Ast.ListExp)", "[Ast.Exp]visit(Ast.Record)", "[Ast.Fn]visit(Ast.Fn)", "[Ast.Apply]visit(Ast.Apply)", "[Ast.Exp]visit(Ast.RecordSelector)", "[Ast.Match]visit(Ast.Match)", "[Ast.Type]visit(Ast.NamedType)", "[Ast.TyVar]visit(Ast.TyVar)", "[Ast.Decl]visit(Ast.FunDecl)", "[Ast.FunBind]visit(Ast.FunBind)", "[Ast.FunMatch]visit(Ast.FunMatch)", "[Ast.ValDecl]visit(Ast.ValDecl)", "[Ast.ValBind]visit(Ast.ValBind)", "[Ast.Exp]visit(Ast.From)", "[AstNode]visit(Ast.Order)", "[AstNode]visit(Ast.OrderItem)", "[Ast.Scan]visit(Ast.Scan)", "[AstNode]visit(Ast.Where)", "[AstNode]visit(Ast.Skip)", "[AstNode]visit(Ast.Take)", "[AstNode]visit(Ast.Yield)", "[AstNode]visit(Ast.Into)", "[AstNode]visit(Ast.Through)", "[AstNode]visit(Ast.Compute)", "[AstNode]visit(Ast.Group)", "[AstNode]visit(Ast.Aggregate)", "[Ast.DatatypeDecl]visit(Ast.DatatypeDecl)", "[Ast.DatatypeBind]visit(Ast.DatatypeBind)", "[AstNode]visit(Ast.TyCon)", "[Ast.RecordType]visit(Ast.RecordType)", "[Ast.Type]visit(Ast.TupleType)", "[Ast.Type]visit(Ast.FunctionType)", "[Ast.Type]visit(Ast.CompositeType)", "[Core.Exp]visit(Core.Apply)", "[Core.Exp]visit(Core.Id)", "[Core.RecordSelector]visit(Core.RecordSelector)", "[Core.Exp]visit(Core.Literal)", "[Core.Exp]visit(Core.Tuple)", "[Core.Exp]visit(Core.Let)", "[Core.Exp]visit(Core.Local)", "[Core.DatatypeDecl]visit(Core.DatatypeDecl)", "[Core.NonRecValDecl]visit(Core.NonRecValDecl)", "[Core.RecValDecl]visit(Core.RecValDecl)", "[Core.IdPat]visit(Core.IdPat)", "[Core.AsPat]visit(Core.AsPat)", "[Core.Pat]visit(Core.LiteralPat)", "[Core.Pat]visit(Core.WildcardPat)", "[Core.Pat]visit(Core.ConPat)", "[Core.Pat]visit(Core.Con0Pat)", "[Core.Pat]visit(Core.TuplePat)", "[Core.Pat]visit(Core.ListPat)", "[Core.Pat]visit(Core.RecordPat)", "[Core.Exp]visit(Core.Fn)", "[Core.Exp]visit(Core.Case)", "[Core.Match]visit(Core.Match)", "[Core.Exp]visit(Core.From)", "[Core.Scan]visit(Core.Scan)", "[Core.Where]visit(Core.Where)", "[Core.Skip]visit(Core.Skip)", "[Core.Take]visit(Core.Take)", "[Core.Group]visit(Core.Group)", "[Core.Aggregate]visit(Core.Aggregate)", "[Core.Order]visit(Core.Order)", "[Core.OrderItem]visit(Core.OrderItem)", "[Core.Yield]visit(Core.Yield)"], "method_uris": ["src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[]Shuttle(TypeSystem)", "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[List<E>]visitList(List<E>)", "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[Map<K, E>]visitMap(Map<K, E>)", "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[SortedMap<K, E>]visitSortedMap(SortedMap<K, E>)", "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[Ast.Exp]visit(Ast.Literal)", "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[Ast.Id]visit(Ast.Id)", "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[Ast.Exp]visit(Ast.AnnotatedExp)", "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[Ast.Exp]visit(Ast.If)", "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[Ast.Let]visit(Ast.Let)", "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[Ast.Exp]visit(Ast.Case)", "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[Ast.Exp]visit(Ast.InfixCall)", "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[Ast.Exp]visit(Ast.PrefixCall)", "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[Ast.Pat]visit(Ast.IdPat)", "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[Ast.Pat]visit(Ast.LiteralPat)", "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[Ast.Pat]visit(Ast.WildcardPat)", "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[Ast.Pat]visit(Ast.InfixPat)", "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[Ast.Pat]visit(Ast.TuplePat)", "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[Ast.Pat]visit(Ast.ListPat)", "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[Ast.Pat]visit(Ast.RecordPat)", "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[Ast.Pat]visit(Ast.AnnotatedPat)", "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[Ast.Pat]visit(Ast.AsPat)", "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[Ast.ConPat]visit(Ast.ConPat)", "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[Ast.Con0Pat]visit(Ast.Con0Pat)", "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[Ast.Exp]visit(Ast.Tuple)", "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[Ast.ListExp]visit(Ast.ListExp)", "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[Ast.Exp]visit(Ast.Record)", "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[Ast.Fn]visit(Ast.Fn)", "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[Ast.Apply]visit(Ast.Apply)", "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[Ast.Exp]visit(Ast.RecordSelector)", "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[Ast.Match]visit(Ast.Match)", "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[Ast.Type]visit(Ast.NamedType)", "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[Ast.TyVar]visit(Ast.TyVar)", "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[Ast.Decl]visit(Ast.FunDecl)", "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[Ast.FunBind]visit(Ast.FunBind)", "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[Ast.FunMatch]visit(Ast.FunMatch)", "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[Ast.ValDecl]visit(Ast.ValDecl)", "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[Ast.ValBind]visit(Ast.ValBind)", "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[Ast.Exp]visit(Ast.From)", "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[AstNode]visit(Ast.Order)", "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[AstNode]visit(Ast.OrderItem)", "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[Ast.Scan]visit(Ast.Scan)", "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[AstNode]visit(Ast.Where)", "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[AstNode]visit(Ast.Skip)", "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[AstNode]visit(Ast.Take)", "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[AstNode]visit(Ast.Yield)", "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[AstNode]visit(Ast.Into)", "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[AstNode]visit(Ast.Through)", "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[AstNode]visit(Ast.Compute)", "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[AstNode]visit(Ast.Group)", "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[AstNode]visit(Ast.Aggregate)", "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[Ast.DatatypeDecl]visit(Ast.DatatypeDecl)", "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[Ast.DatatypeBind]visit(Ast.DatatypeBind)", "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[AstNode]visit(Ast.TyCon)", "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[Ast.RecordType]visit(Ast.RecordType)", "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[Ast.Type]visit(Ast.TupleType)", "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[Ast.Type]visit(Ast.FunctionType)", "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[Ast.Type]visit(Ast.CompositeType)", "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[Core.Exp]visit(Core.Apply)", "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[Core.Exp]visit(Core.Id)", "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[Core.RecordSelector]visit(Core.RecordSelector)", "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[Core.Exp]visit(Core.Literal)", "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[Core.Exp]visit(Core.Tuple)", "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[Core.Exp]visit(Core.Let)", "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[Core.Exp]visit(Core.Local)", "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[Core.DatatypeDecl]visit(Core.DatatypeDecl)", "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[Core.NonRecValDecl]visit(Core.NonRecValDecl)", "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[Core.RecValDecl]visit(Core.RecValDecl)", "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[Core.IdPat]visit(Core.IdPat)", "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[Core.AsPat]visit(Core.AsPat)", "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[Core.Pat]visit(Core.LiteralPat)", "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[Core.Pat]visit(Core.WildcardPat)", "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[Core.Pat]visit(Core.ConPat)", "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[Core.Pat]visit(Core.Con0Pat)", "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[Core.Pat]visit(Core.TuplePat)", "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[Core.Pat]visit(Core.ListPat)", "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[Core.Pat]visit(Core.RecordPat)", "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[Core.Exp]visit(Core.Fn)", "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[Core.Exp]visit(Core.Case)", "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[Core.Match]visit(Core.Match)", "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[Core.Exp]visit(Core.From)", "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[Core.Scan]visit(Core.Scan)", "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[Core.Where]visit(Core.Where)", "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[Core.Skip]visit(Core.Skip)", "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[Core.Take]visit(Core.Take)", "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[Core.Group]visit(Core.Group)", "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[Core.Aggregate]visit(Core.Aggregate)", "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[Core.Order]visit(Core.Order)", "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[Core.OrderItem]visit(Core.OrderItem)", "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[Core.Yield]visit(Core.Yield)"], "overrides": null, "attributes": [], "class_docstring": " Visits and transforms syntax trees.", "original_string": "public class Shuttle {\n  protected final TypeSystem typeSystem;\n\n  /** Creates a Shuttle. */\n  public Shuttle(TypeSystem typeSystem) {\n    this.typeSystem = typeSystem;\n  }\n\n  protected <E extends AstNode> List<E> visitList(List<E> nodes) {\n    final List<E> list = new ArrayList<>();\n    for (E node : nodes) {\n      //noinspection unchecked\n      list.add((E) node.accept(this));\n    }\n    return list;\n  }\n\n  protected <K, E extends AstNode> Map<K, E> visitMap(Map<K, E> nodes) {\n    final Map<K, E> map = new LinkedHashMap<>();\n    //noinspection unchecked\n    nodes.forEach((k, v) -> map.put(k, (E) v.accept(this)));\n    return map;\n  }\n\n  protected <K, E extends AstNode> SortedMap<K, E> visitSortedMap(\n      SortedMap<K, E> nodes) {\n    final SortedMap<K, E> map = new TreeMap<>(nodes.comparator());\n    //noinspection unchecked\n    nodes.forEach((k, v) -> map.put(k, (E) v.accept(this)));\n    return map;\n  }\n\n  // expressions\n\n  protected Ast.Exp visit(Ast.Literal literal) {\n    return literal; // leaf\n  }\n\n  protected Ast.Id visit(Ast.Id id) {\n    return id; // leaf\n  }\n\n  protected Ast.Exp visit(Ast.AnnotatedExp annotatedExp) {\n    return ast.annotatedExp(annotatedExp.pos, annotatedExp.exp.accept(this),\n        annotatedExp.type.accept(this));\n  }\n\n  protected Ast.Exp visit(Ast.If ifThenElse) {\n    return ast.ifThenElse(ifThenElse.pos, ifThenElse.condition.accept(this),\n        ifThenElse.ifTrue.accept(this), ifThenElse.ifFalse.accept(this));\n  }\n\n  protected Ast.Let visit(Ast.Let let) {\n    return ast.let(let.pos, visitList(let.decls), let.exp);\n  }\n\n  protected Ast.Exp visit(Ast.Case caseOf) {\n    return ast.caseOf(caseOf.pos, caseOf.exp.accept(this),\n        visitList(caseOf.matchList));\n  }\n\n  // calls\n\n  protected Ast.Exp visit(Ast.InfixCall infixCall) {\n    return ast.infixCall(infixCall.pos, infixCall.op,\n        infixCall.a0.accept(this), infixCall.a1.accept(this));\n  }\n\n  protected Ast.Exp visit(Ast.PrefixCall prefixCall) {\n    return ast.prefixCall(prefixCall.pos, prefixCall.op,\n        prefixCall.a.accept(this));\n  }\n\n  // patterns\n\n  protected Ast.Pat visit(Ast.IdPat idPat) {\n    return idPat; // leaf\n  }\n\n  protected Ast.Pat visit(Ast.LiteralPat literalPat) {\n    return literalPat; // leaf\n  }\n\n  protected Ast.Pat visit(Ast.WildcardPat wildcardPat) {\n    return wildcardPat; // leaf\n  }\n\n  protected Ast.Pat visit(Ast.InfixPat infixPat) {\n    return infixPat.copy(infixPat.p0.accept(this), infixPat.p1.accept(this));\n  }\n\n  protected Ast.Pat visit(Ast.TuplePat tuplePat) {\n    return tuplePat.copy(visitList(tuplePat.args));\n  }\n\n  protected Ast.Pat visit(Ast.ListPat listPat) {\n    return listPat.copy(visitList(listPat.args));\n  }\n\n  protected Ast.Pat visit(Ast.RecordPat recordPat) {\n    return recordPat.copy(recordPat.ellipsis, visitMap(recordPat.args));\n  }\n\n  protected Ast.Pat visit(Ast.AnnotatedPat annotatedPat) {\n    return annotatedPat.copy(annotatedPat.pat.accept(this),\n        annotatedPat.type.accept(this));\n  }\n\n  protected Ast.Pat visit(Ast.AsPat asPat) {\n    return asPat.copy((Ast.IdPat) asPat.id.accept(this),\n        asPat.pat.accept(this));\n  }\n\n  protected Ast.ConPat visit(Ast.ConPat conPat) {\n    return conPat.copy(conPat.tyCon.accept(this), conPat.pat.accept(this));\n  }\n\n  protected Ast.Con0Pat visit(Ast.Con0Pat con0Pat) {\n    return con0Pat.copy(con0Pat.tyCon.accept(this));\n  }\n\n  // value constructors\n\n  protected Ast.Exp visit(Ast.Tuple tuple) {\n    return ast.tuple(tuple.pos, visitList(tuple.args));\n  }\n\n  protected Ast.ListExp visit(Ast.ListExp list) {\n    return ast.list(list.pos, visitList(list.args));\n  }\n\n  protected Ast.Exp visit(Ast.Record record) {\n    return ast.record(record.pos, visitMap(record.args));\n  }\n\n  // functions and matches\n\n  protected Ast.Fn visit(Ast.Fn fn) {\n    return ast.fn(fn.pos, visitList(fn.matchList));\n  }\n\n  protected Ast.Apply visit(Ast.Apply apply) {\n    return ast.apply(apply.fn.accept(this), apply.arg.accept(this));\n  }\n\n  protected Ast.Exp visit(Ast.RecordSelector recordSelector) {\n    return recordSelector; // leaf\n  }\n\n  protected Ast.Match visit(Ast.Match match) {\n    return ast.match(match.pos, match.pat.accept(this), match.exp.accept(this));\n  }\n\n  // types\n\n  protected Ast.Type visit(Ast.NamedType namedType) {\n    return namedType; // leaf\n  }\n\n  protected Ast.TyVar visit(Ast.TyVar tyVar) {\n    return tyVar; // leaf\n  }\n\n  // declarations\n\n  protected Ast.Decl visit(Ast.FunDecl funDecl) {\n    return ast.funDecl(funDecl.pos, visitList(funDecl.funBinds));\n  }\n\n  protected Ast.FunBind visit(Ast.FunBind funBind) {\n    return ast.funBind(funBind.pos, visitList(funBind.matchList));\n  }\n\n  protected Ast.FunMatch visit(Ast.FunMatch funMatch) {\n    return ast.funMatch(funMatch.pos, funMatch.name,\n        visitList(funMatch.patList),\n        funMatch.returnType == null ? null : funMatch.returnType.accept(this),\n        funMatch.exp.accept(this));\n  }\n\n  protected Ast.ValDecl visit(Ast.ValDecl valDecl) {\n    return ast.valDecl(valDecl.pos, valDecl.rec, visitList(valDecl.valBinds));\n  }\n\n  protected Ast.ValBind visit(Ast.ValBind valBind) {\n    return ast.valBind(valBind.pos, valBind.pat, valBind.exp);\n  }\n\n  protected Ast.Exp visit(Ast.From from) {\n    return ast.from(from.pos, from.steps);\n  }\n\n  protected AstNode visit(Ast.Order order) {\n    return ast.order(order.pos, order.orderItems);\n  }\n\n  protected AstNode visit(Ast.OrderItem orderItem) {\n    return ast.orderItem(orderItem.pos, orderItem.exp, orderItem.direction);\n  }\n\n  protected Ast.Scan visit(Ast.Scan scan) {\n    return ast.scan(scan.pos, scan.pat.accept(this),\n        scan.exp.accept(this),\n        scan.condition == null ? null : scan.condition.accept(this));\n  }\n\n  protected AstNode visit(Ast.Where where) {\n    return ast.where(where.pos, where.exp.accept(this));\n  }\n\n  protected AstNode visit(Ast.Skip skip) {\n    return ast.skip(skip.pos, skip.exp.accept(this));\n  }\n\n  protected AstNode visit(Ast.Take take) {\n    return ast.take(take.pos, take.exp.accept(this));\n  }\n\n  protected AstNode visit(Ast.Yield yield) {\n    return ast.yield(yield.pos, yield.exp.accept(this));\n  }\n\n  protected AstNode visit(Ast.Into into) {\n    return ast.into(into.pos, into.exp);\n  }\n\n  protected AstNode visit(Ast.Through through) {\n    return ast.through(through.pos, through.pat, through.exp);\n  }\n\n  protected AstNode visit(Ast.Compute compute) {\n    return ast.compute(compute.pos, compute.aggregates);\n  }\n\n  protected AstNode visit(Ast.Group group) {\n    return ast.group(group.pos, group.groupExps, group.aggregates);\n  }\n\n  protected AstNode visit(Ast.Aggregate aggregate) {\n    return ast.aggregate(aggregate.pos, aggregate.aggregate, aggregate.argument,\n        aggregate.id);\n  }\n\n  protected Ast.DatatypeDecl visit(Ast.DatatypeDecl datatypeDecl) {\n    return ast.datatypeDecl(datatypeDecl.pos, visitList(datatypeDecl.binds));\n  }\n\n  protected Ast.DatatypeBind visit(Ast.DatatypeBind datatypeBind) {\n    return ast.datatypeBind(datatypeBind.pos, datatypeBind.name.accept(this),\n        visitList(datatypeBind.tyVars), visitList(datatypeBind.tyCons));\n  }\n\n  protected AstNode visit(Ast.TyCon tyCon) {\n    return ast.typeConstructor(tyCon.pos, tyCon.id.accept(this),\n        tyCon.type == null ? null : tyCon.type.accept(this));\n  }\n\n  protected Ast.RecordType visit(Ast.RecordType recordType) {\n    return ast.recordType(recordType.pos, visitMap(recordType.fieldTypes));\n  }\n\n  protected Ast.Type visit(Ast.TupleType tupleType) {\n    return ast.tupleType(tupleType.pos, visitList(tupleType.types));\n  }\n\n  protected Ast.Type visit(Ast.FunctionType functionType) {\n    return ast.functionType(functionType.pos, functionType.paramType,\n        functionType.resultType);\n  }\n\n  protected Ast.Type visit(Ast.CompositeType compositeType) {\n    return ast.compositeType(compositeType.pos,\n        visitList(compositeType.types));\n  }\n\n  // core expressions, patterns\n\n  protected Core.Exp visit(Core.Apply apply) {\n    return apply.copy(apply.fn.accept(this), apply.arg.accept(this));\n  }\n\n  protected Core.Exp visit(Core.Id id) {\n    return id;\n  }\n\n  protected Core.RecordSelector visit(Core.RecordSelector recordSelector) {\n    return recordSelector;\n  }\n\n  protected Core.Exp visit(Core.Literal literal) {\n    return literal;\n  }\n\n  protected Core.Exp visit(Core.Tuple tuple) {\n    return tuple.copy(typeSystem, visitList(tuple.args));\n  }\n\n  protected Core.Exp visit(Core.Let let) {\n    return let.copy(let.decl.accept(this), let.exp.accept(this));\n  }\n\n  protected Core.Exp visit(Core.Local local) {\n    return local.copy(local.dataType, local.exp.accept(this));\n  }\n\n  protected Core.DatatypeDecl visit(Core.DatatypeDecl datatypeDecl) {\n    return datatypeDecl;\n  }\n\n  protected Core.NonRecValDecl visit(Core.NonRecValDecl valDecl) {\n    return valDecl.copy(valDecl.pat.accept(this),\n        valDecl.exp.accept(this));\n  }\n\n  protected Core.RecValDecl visit(Core.RecValDecl valDecl) {\n    return valDecl.copy(visitList(valDecl.list));\n  }\n\n  protected Core.IdPat visit(Core.IdPat idPat) {\n    return idPat;\n  }\n\n  protected Core.AsPat visit(Core.AsPat asPat) {\n    return asPat.copy(asPat.name, asPat.i, asPat.pat.accept(this));\n  }\n\n  protected Core.Pat visit(Core.LiteralPat literalPat) {\n    return literalPat;\n  }\n\n  protected Core.Pat visit(Core.WildcardPat wildcardPat) {\n    return wildcardPat;\n  }\n\n  protected Core.Pat visit(Core.ConPat conPat) {\n    return conPat.copy(conPat.tyCon, conPat.pat.accept(this));\n  }\n\n  protected Core.Pat visit(Core.Con0Pat con0Pat) {\n    return con0Pat;\n  }\n\n  protected Core.Pat visit(Core.TuplePat tuplePat) {\n    return tuplePat.copy(typeSystem, visitList(tuplePat.args));\n  }\n\n  protected Core.Pat visit(Core.ListPat listPat) {\n    return listPat.copy(typeSystem, visitList(listPat.args));\n  }\n\n  protected Core.Pat visit(Core.RecordPat recordPat) {\n    return recordPat.copy(typeSystem, recordPat.type().argNameTypes.keySet(),\n        visitList(recordPat.args));\n  }\n\n  protected Core.Exp visit(Core.Fn fn) {\n    return fn.copy(fn.idPat.accept(this), fn.exp.accept(this));\n  }\n\n  protected Core.Exp visit(Core.Case caseOf) {\n    return caseOf.copy(caseOf.exp.accept(this), visitList(caseOf.matchList));\n  }\n\n  protected Core.Match visit(Core.Match match) {\n    return match.copy(match.pat.accept(this), match.exp.accept(this));\n  }\n\n  protected Core.Exp visit(Core.From from) {\n    return from.copy(typeSystem, null, visitList(from.steps));\n  }\n\n  protected Core.Scan visit(Core.Scan scan) {\n    return scan.copy(scan.bindings, scan.pat.accept(this),\n        scan.exp.accept(this), scan.condition.accept(this));\n  }\n\n  protected Core.Where visit(Core.Where where) {\n    return where.copy(where.exp.accept(this), where.bindings);\n  }\n\n  protected Core.Skip visit(Core.Skip skip) {\n    return skip.copy(skip.exp.accept(this), skip.bindings);\n  }\n\n  protected Core.Take visit(Core.Take take) {\n    return take.copy(take.exp.accept(this), take.bindings);\n  }\n\n  protected Core.Group visit(Core.Group group) {\n    return group.copy(visitSortedMap(group.groupExps),\n        visitSortedMap(group.aggregates));\n  }\n\n  protected Core.Aggregate visit(Core.Aggregate aggregate) {\n    return aggregate.copy(aggregate.type, aggregate.aggregate.accept(this),\n        aggregate.argument == null ? null : aggregate.argument.accept(this));\n  }\n\n  protected Core.Order visit(Core.Order order) {\n    return order.copy(order.bindings, visitList(order.orderItems));\n  }\n\n  protected Core.OrderItem visit(Core.OrderItem orderItem) {\n    return orderItem.copy(orderItem.exp.accept(this), orderItem.direction);\n  }\n\n  protected Core.Yield visit(Core.Yield yield) {\n    return yield.copy(yield.bindings, yield.exp.accept(this));\n  }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "protected final TypeSystem typeSystem;", "docstring": "", "modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "type": "TypeSystem", "name": "typeSystem", "syntax_pass": true}]}, {"uris": "src/main/java/net/hydromatic/morel/ast/Ast.java.Ast", "name": "Ast", "file_path": "src/main/java/net/hydromatic/morel/ast/Ast.java", "superclasses": "", "methods": ["[]Ast()"], "method_uris": ["src/main/java/net/hydromatic/morel/ast/Ast.java.Ast.[]Ast()"], "overrides": null, "attributes": [{"original_string": "  public abstract static class Pat extends AstNode {\n    Pat(Pos pos, Op op) {\n      super(pos, op);\n    }\n\n    public void forEachArg(ObjIntConsumer<Pat> action) {\n      // no args\n    }\n\n    @Override public abstract Pat accept(Shuttle shuttle);\n\n    public void visit(Consumer<Pat> consumer) {\n      consumer.accept(this);\n      forEachArg((arg, i) -> arg.visit(consumer));\n    }\n  }", "definition": "  public abstract static class Pat extends AstNode", "class_docstring": " Base class for a pattern.\n\n<p>For example, \"x\" in \"val x = 5\" is a {@link IdPat};\nthe \"(x, y) in \"val (x, y) = makePair 1 2\" is a {@link TuplePat}.", "name": "Pat", "super_interfaces": [], "superclasses": "AstNode", "attributes": {"modifiers": "public abstract static", "marker_annotations": [], "non_marker_annotations": ["public", "abstract", "static"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    Pat(Pos pos, Op op) {\n      super(pos, op);\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "Pat", "params": [{"name": "pos", "type": "Pos"}, {"name": "op", "type": "Op"}], "body": "                        {\n      super(pos, op);\n    }", "signature": "Pat(Pos pos, Op op)"}, {"syntax_pass": true, "original_string": "    public void forEachArg(ObjIntConsumer<Pat> action) {\n      // no args\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "forEachArg", "params": [{"name": "action", "type": "ObjIntConsumer<Pat>"}], "body": "                                                       {\n      // no args\n    }", "signature": "public void forEachArg(ObjIntConsumer<Pat> action)"}, {"syntax_pass": true, "original_string": "    @Override public abstract Pat accept(Shuttle shuttle);", "docstring": "", "attributes": {"modifiers": "@Override public abstract", "marker_annotations": ["@Override"], "non_marker_annotations": ["public", "abstract"], "comments": [], "return_type": "Pat", "classes": []}, "name": "accept", "params": [{"name": "shuttle", "type": "Shuttle"}], "body": "", "signature": "@Override public abstract Pat accept(Shuttle shuttle)"}, {"syntax_pass": true, "original_string": "    public void visit(Consumer<Pat> consumer) {\n      consumer.accept(this);\n      forEachArg((arg, i) -> arg.visit(consumer));\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "visit", "params": [{"name": "consumer", "type": "Consumer<Pat>"}], "body": "                                              {\n      consumer.accept(this);\n      forEachArg((arg, i) -> arg.visit(consumer));\n    }", "signature": "public void visit(Consumer<Pat> consumer)"}]}, {"original_string": "  public static class IdPat extends Pat {\n    public final String name;\n\n    IdPat(Pos pos, String name) {\n      super(pos, Op.ID_PAT);\n      this.name = name;\n    }\n\n    public Pat accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }\n\n    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }\n\n    AstWriter unparse(AstWriter w, int left, int right) {\n      return w.id(name);\n    }\n  }", "definition": "  public static class IdPat extends Pat", "class_docstring": " Named pattern, the pattern analog of the {@link Id} expression.\n\n<p>For example, \"x\" in \"val x = 5\".", "name": "IdPat", "super_interfaces": [], "superclasses": "Pat", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [{"attribute_expression": "public final String name;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "String", "name": "name", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    IdPat(Pos pos, String name) {\n      super(pos, Op.ID_PAT);\n      this.name = name;\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "IdPat", "params": [{"name": "pos", "type": "Pos"}, {"name": "name", "type": "String"}], "body": "                                {\n      super(pos, Op.ID_PAT);\n      this.name = name;\n    }", "signature": "IdPat(Pos pos, String name)"}, {"syntax_pass": true, "original_string": "    public Pat accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Pat", "classes": []}, "name": "accept", "params": [{"name": "shuttle", "type": "Shuttle"}], "body": "                                       {\n      return shuttle.visit(this);\n    }", "signature": "public Pat accept(Shuttle shuttle)"}, {"syntax_pass": true, "original_string": "    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "accept", "params": [{"name": "visitor", "type": "Visitor"}], "body": "                                                  {\n      visitor.visit(this);\n    }", "signature": "@Override public void accept(Visitor visitor)"}, {"syntax_pass": true, "original_string": "    AstWriter unparse(AstWriter w, int left, int right) {\n      return w.id(name);\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "AstWriter", "classes": []}, "name": "unparse", "params": [{"name": "w", "type": "AstWriter"}, {"name": "left", "type": "int"}, {"name": "right", "type": "int"}], "body": "                                                        {\n      return w.id(name);\n    }", "signature": "AstWriter unparse(AstWriter w, int left, int right)"}]}, {"original_string": "  @SuppressWarnings(\"rawtypes\")\n  public static class LiteralPat extends Pat {\n    public final Comparable value;\n\n    LiteralPat(Pos pos, Op op, Comparable value) {\n      super(pos, op);\n      this.value = requireNonNull(value);\n      checkArgument(op == Op.BOOL_LITERAL_PAT\n          || op == Op.CHAR_LITERAL_PAT\n          || op == Op.INT_LITERAL_PAT\n          || op == Op.REAL_LITERAL_PAT\n          || op == Op.STRING_LITERAL_PAT);\n    }\n\n    @Override public int hashCode() {\n      return value.hashCode();\n    }\n\n    @Override public boolean equals(Object o) {\n      return o == this\n          || o instanceof LiteralPat\n          && this.value.equals(((LiteralPat) o).value);\n    }\n\n    public Pat accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }\n\n    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }\n\n    AstWriter unparse(AstWriter w, int left, int right) {\n      return w.appendLiteral(value);\n    }\n  }", "definition": "  @SuppressWarnings(\"rawtypes\")\n  public static class LiteralPat extends Pat", "class_docstring": " Literal pattern, the pattern analog of the {@link Literal} expression.\n\n<p>For example, \"0\" in \"fun fact 0 = 1 | fact n = n * fact (n - 1)\".", "name": "LiteralPat", "super_interfaces": [], "superclasses": "Pat", "attributes": {"modifiers": "@SuppressWarnings(\"rawtypes\")\n  public static", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings(\"rawtypes\")", "public", "static"], "comments": [], "fields": [{"attribute_expression": "public final Comparable value;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "Comparable", "name": "value", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    LiteralPat(Pos pos, Op op, Comparable value) {\n      super(pos, op);\n      this.value = requireNonNull(value);\n      checkArgument(op == Op.BOOL_LITERAL_PAT\n          || op == Op.CHAR_LITERAL_PAT\n          || op == Op.INT_LITERAL_PAT\n          || op == Op.REAL_LITERAL_PAT\n          || op == Op.STRING_LITERAL_PAT);\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "LiteralPat", "params": [{"name": "pos", "type": "Pos"}, {"name": "op", "type": "Op"}, {"name": "value", "type": "Comparable"}], "body": "                                                 {\n      super(pos, op);\n      this.value = requireNonNull(value);\n      checkArgument(op == Op.BOOL_LITERAL_PAT\n          || op == Op.CHAR_LITERAL_PAT\n          || op == Op.INT_LITERAL_PAT\n          || op == Op.REAL_LITERAL_PAT\n          || op == Op.STRING_LITERAL_PAT);\n    }", "signature": "LiteralPat(Pos pos, Op op, Comparable value)"}, {"syntax_pass": true, "original_string": "    @Override public int hashCode() {\n      return value.hashCode();\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "hashCode", "params": [], "body": "                                    {\n      return value.hashCode();\n    }", "signature": "@Override public int hashCode()"}, {"syntax_pass": true, "original_string": "    @Override public boolean equals(Object o) {\n      return o == this\n          || o instanceof LiteralPat\n          && this.value.equals(((LiteralPat) o).value);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "equals", "params": [{"name": "o", "type": "Object"}], "body": "                                              {\n      return o == this\n          || o instanceof LiteralPat\n          && this.value.equals(((LiteralPat) o).value);\n    }", "signature": "@Override public boolean equals(Object o)"}, {"syntax_pass": true, "original_string": "    public Pat accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Pat", "classes": []}, "name": "accept", "params": [{"name": "shuttle", "type": "Shuttle"}], "body": "                                       {\n      return shuttle.visit(this);\n    }", "signature": "public Pat accept(Shuttle shuttle)"}, {"syntax_pass": true, "original_string": "    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "accept", "params": [{"name": "visitor", "type": "Visitor"}], "body": "                                                  {\n      visitor.visit(this);\n    }", "signature": "@Override public void accept(Visitor visitor)"}, {"syntax_pass": true, "original_string": "    AstWriter unparse(AstWriter w, int left, int right) {\n      return w.appendLiteral(value);\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "AstWriter", "classes": []}, "name": "unparse", "params": [{"name": "w", "type": "AstWriter"}, {"name": "left", "type": "int"}, {"name": "right", "type": "int"}], "body": "                                                        {\n      return w.appendLiteral(value);\n    }", "signature": "AstWriter unparse(AstWriter w, int left, int right)"}]}, {"original_string": "  public static class WildcardPat extends Pat {\n    WildcardPat(Pos pos) {\n      super(pos, Op.WILDCARD_PAT);\n    }\n\n    @Override public int hashCode() {\n      return \"_\".hashCode();\n    }\n\n    @Override public boolean equals(Object o) {\n      return o instanceof WildcardPat;\n    }\n\n    public Pat accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }\n\n    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }\n\n    AstWriter unparse(AstWriter w, int left, int right) {\n      return w.append(\"_\");\n    }\n  }", "definition": "  public static class WildcardPat extends Pat", "class_docstring": " Wildcard pattern.\n\n<p>For example, \"{@code _}\" in \"{@code fn foo _ => 42}\".", "name": "WildcardPat", "super_interfaces": [], "superclasses": "Pat", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    WildcardPat(Pos pos) {\n      super(pos, Op.WILDCARD_PAT);\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "WildcardPat", "params": [{"name": "pos", "type": "Pos"}], "body": "                         {\n      super(pos, Op.WILDCARD_PAT);\n    }", "signature": "WildcardPat(Pos pos)"}, {"syntax_pass": true, "original_string": "    @Override public int hashCode() {\n      return \"_\".hashCode();\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "hashCode", "params": [], "body": "                                    {\n      return \"_\".hashCode();\n    }", "signature": "@Override public int hashCode()"}, {"syntax_pass": true, "original_string": "    @Override public boolean equals(Object o) {\n      return o instanceof WildcardPat;\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "equals", "params": [{"name": "o", "type": "Object"}], "body": "                                              {\n      return o instanceof WildcardPat;\n    }", "signature": "@Override public boolean equals(Object o)"}, {"syntax_pass": true, "original_string": "    public Pat accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Pat", "classes": []}, "name": "accept", "params": [{"name": "shuttle", "type": "Shuttle"}], "body": "                                       {\n      return shuttle.visit(this);\n    }", "signature": "public Pat accept(Shuttle shuttle)"}, {"syntax_pass": true, "original_string": "    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "accept", "params": [{"name": "visitor", "type": "Visitor"}], "body": "                                                  {\n      visitor.visit(this);\n    }", "signature": "@Override public void accept(Visitor visitor)"}, {"syntax_pass": true, "original_string": "    AstWriter unparse(AstWriter w, int left, int right) {\n      return w.append(\"_\");\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "AstWriter", "classes": []}, "name": "unparse", "params": [{"name": "w", "type": "AstWriter"}, {"name": "left", "type": "int"}, {"name": "right", "type": "int"}], "body": "                                                        {\n      return w.append(\"_\");\n    }", "signature": "AstWriter unparse(AstWriter w, int left, int right)"}]}, {"original_string": "  public static class InfixPat extends Pat {\n    public final Pat p0;\n    public final Pat p1;\n\n    InfixPat(Pos pos, Op op, Pat p0, Pat p1) {\n      super(pos, op);\n      this.p0 = requireNonNull(p0);\n      this.p1 = requireNonNull(p1);\n    }\n\n    public Pat accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }\n\n    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }\n\n    @Override public void forEachArg(ObjIntConsumer<Pat> action) {\n      action.accept(p0, 0);\n      action.accept(p1, 1);\n    }\n\n    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      return w.infix(left, p0, op, p1, right);\n    }\n\n    /** Creates a copy of this {@code InfixPat} with given contents\n     * and same operator,\n     * or {@code this} if the contents are the same. */\n    public InfixPat copy(Pat p0, Pat p1) {\n      return this.p0.equals(p0)\n          && this.p1.equals(p1)\n          ? this\n          : ast.infixPat(pos, op, p0, p1);\n    }\n  }", "definition": "  public static class InfixPat extends Pat", "class_docstring": " Pattern build from an infix operator applied to two patterns.", "name": "InfixPat", "super_interfaces": [], "superclasses": "Pat", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [{"attribute_expression": "public final Pat p0;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "Pat", "name": "p0", "syntax_pass": true}, {"attribute_expression": "public final Pat p1;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "Pat", "name": "p1", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    InfixPat(Pos pos, Op op, Pat p0, Pat p1) {\n      super(pos, op);\n      this.p0 = requireNonNull(p0);\n      this.p1 = requireNonNull(p1);\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "InfixPat", "params": [{"name": "pos", "type": "Pos"}, {"name": "op", "type": "Op"}, {"name": "p0", "type": "Pat"}, {"name": "p1", "type": "Pat"}], "body": "                                             {\n      super(pos, op);\n      this.p0 = requireNonNull(p0);\n      this.p1 = requireNonNull(p1);\n    }", "signature": "InfixPat(Pos pos, Op op, Pat p0, Pat p1)"}, {"syntax_pass": true, "original_string": "    public Pat accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Pat", "classes": []}, "name": "accept", "params": [{"name": "shuttle", "type": "Shuttle"}], "body": "                                       {\n      return shuttle.visit(this);\n    }", "signature": "public Pat accept(Shuttle shuttle)"}, {"syntax_pass": true, "original_string": "    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "accept", "params": [{"name": "visitor", "type": "Visitor"}], "body": "                                                  {\n      visitor.visit(this);\n    }", "signature": "@Override public void accept(Visitor visitor)"}, {"syntax_pass": true, "original_string": "    @Override public void forEachArg(ObjIntConsumer<Pat> action) {\n      action.accept(p0, 0);\n      action.accept(p1, 1);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "forEachArg", "params": [{"name": "action", "type": "ObjIntConsumer<Pat>"}], "body": "                                                                 {\n      action.accept(p0, 0);\n      action.accept(p1, 1);\n    }", "signature": "@Override public void forEachArg(ObjIntConsumer<Pat> action)"}, {"syntax_pass": true, "original_string": "    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      return w.infix(left, p0, op, p1, right);\n    }", "docstring": "", "attributes": {"modifiers": "@Override", "marker_annotations": ["@Override"], "non_marker_annotations": [], "comments": [], "return_type": "AstWriter", "classes": []}, "name": "unparse", "params": [{"name": "w", "type": "AstWriter"}, {"name": "left", "type": "int"}, {"name": "right", "type": "int"}], "body": "                                                                  {\n      return w.infix(left, p0, op, p1, right);\n    }", "signature": "@Override AstWriter unparse(AstWriter w, int left, int right)"}, {"syntax_pass": true, "original_string": "    public InfixPat copy(Pat p0, Pat p1) {\n      return this.p0.equals(p0)\n          && this.p1.equals(p1)\n          ? this\n          : ast.infixPat(pos, op, p0, p1);\n    }", "docstring": " Creates a copy of this {@code InfixPat} with given contents\nand same operator,\nor {@code this} if the contents are the same.", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "InfixPat", "classes": []}, "name": "copy", "params": [{"name": "p0", "type": "Pat"}, {"name": "p1", "type": "Pat"}], "body": "                                         {\n      return this.p0.equals(p0)\n          && this.p1.equals(p1)\n          ? this\n          : ast.infixPat(pos, op, p0, p1);\n    }", "signature": "public InfixPat copy(Pat p0, Pat p1)"}]}, {"original_string": "  public static class ConPat extends Pat {\n    public final Id tyCon;\n    public final Pat pat;\n\n    ConPat(Pos pos, Id tyCon, Pat pat) {\n      super(pos, Op.CON_PAT);\n      this.tyCon = requireNonNull(tyCon);\n      this.pat = requireNonNull(pat);\n    }\n\n    public Pat accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }\n\n    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }\n\n    @Override public void forEachArg(ObjIntConsumer<Pat> action) {\n      action.accept(pat, 0);\n    }\n\n    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      return w.infix(left, tyCon, op, pat, right);\n    }\n\n    /** Creates a copy of this {@code ConPat} with given contents,\n     * or {@code this} if the contents are the same. */\n    public ConPat copy(Id tyCon, Pat pat) {\n      return this.tyCon.equals(tyCon)\n          && this.pat.equals(pat)\n          ? this\n          : ast.conPat(pos, tyCon, pat);\n    }\n  }", "definition": "  public static class ConPat extends Pat", "class_docstring": " Type constructor pattern with an argument.\n\n<p>For example, in \"fun nvl NIL = 0 | OPTION x = x\",\n\"OPTION x\" is a type constructor pattern that binds \"x\";\nand \"NIL\" is a type constructor pattern whose {@link #pat} is null.\n\n@see Con0Pat", "name": "ConPat", "super_interfaces": [], "superclasses": "Pat", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [{"attribute_expression": "public final Id tyCon;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "Id", "name": "tyCon", "syntax_pass": true}, {"attribute_expression": "public final Pat pat;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "Pat", "name": "pat", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    ConPat(Pos pos, Id tyCon, Pat pat) {\n      super(pos, Op.CON_PAT);\n      this.tyCon = requireNonNull(tyCon);\n      this.pat = requireNonNull(pat);\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "ConPat", "params": [{"name": "pos", "type": "Pos"}, {"name": "tyCon", "type": "Id"}, {"name": "pat", "type": "Pat"}], "body": "                                       {\n      super(pos, Op.CON_PAT);\n      this.tyCon = requireNonNull(tyCon);\n      this.pat = requireNonNull(pat);\n    }", "signature": "ConPat(Pos pos, Id tyCon, Pat pat)"}, {"syntax_pass": true, "original_string": "    public Pat accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Pat", "classes": []}, "name": "accept", "params": [{"name": "shuttle", "type": "Shuttle"}], "body": "                                       {\n      return shuttle.visit(this);\n    }", "signature": "public Pat accept(Shuttle shuttle)"}, {"syntax_pass": true, "original_string": "    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "accept", "params": [{"name": "visitor", "type": "Visitor"}], "body": "                                                  {\n      visitor.visit(this);\n    }", "signature": "@Override public void accept(Visitor visitor)"}, {"syntax_pass": true, "original_string": "    @Override public void forEachArg(ObjIntConsumer<Pat> action) {\n      action.accept(pat, 0);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "forEachArg", "params": [{"name": "action", "type": "ObjIntConsumer<Pat>"}], "body": "                                                                 {\n      action.accept(pat, 0);\n    }", "signature": "@Override public void forEachArg(ObjIntConsumer<Pat> action)"}, {"syntax_pass": true, "original_string": "    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      return w.infix(left, tyCon, op, pat, right);\n    }", "docstring": "", "attributes": {"modifiers": "@Override", "marker_annotations": ["@Override"], "non_marker_annotations": [], "comments": [], "return_type": "AstWriter", "classes": []}, "name": "unparse", "params": [{"name": "w", "type": "AstWriter"}, {"name": "left", "type": "int"}, {"name": "right", "type": "int"}], "body": "                                                                  {\n      return w.infix(left, tyCon, op, pat, right);\n    }", "signature": "@Override AstWriter unparse(AstWriter w, int left, int right)"}, {"syntax_pass": true, "original_string": "    public ConPat copy(Id tyCon, Pat pat) {\n      return this.tyCon.equals(tyCon)\n          && this.pat.equals(pat)\n          ? this\n          : ast.conPat(pos, tyCon, pat);\n    }", "docstring": " Creates a copy of this {@code ConPat} with given contents,\nor {@code this} if the contents are the same.", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ConPat", "classes": []}, "name": "copy", "params": [{"name": "tyCon", "type": "Id"}, {"name": "pat", "type": "Pat"}], "body": "                                          {\n      return this.tyCon.equals(tyCon)\n          && this.pat.equals(pat)\n          ? this\n          : ast.conPat(pos, tyCon, pat);\n    }", "signature": "public ConPat copy(Id tyCon, Pat pat)"}]}, {"original_string": "  public static class AsPat extends Pat {\n    public final IdPat id;\n    public final Pat pat;\n\n    AsPat(Pos pos, IdPat id, Pat pat) {\n      super(pos, Op.AS_PAT);\n      this.id = requireNonNull(id);\n      this.pat = requireNonNull(pat);\n    }\n\n    public Pat accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }\n\n    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }\n\n    @Override public void forEachArg(ObjIntConsumer<Pat> action) {\n      action.accept(id, 0);\n      action.accept(pat, 1);\n    }\n\n    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      return w.infix(left, id, op, pat, right);\n    }\n\n    /** Creates a copy of this {@code AsPat} with given contents,\n     * or {@code this} if the contents are the same. */\n    public AsPat copy(IdPat id, Pat pat) {\n      return this.id.equals(id)\n          && this.pat.equals(pat)\n          ? this\n          : ast.asPat(pos, id, pat);\n    }\n  }", "definition": "  public static class AsPat extends Pat", "class_docstring": " Layered pattern.\n\n<p>For example, in \"val h as (i, j) = (1, 2)\",\nif the pattern matches, \"h\" is assigned the whole tuple,\nand \"i\" and \"j\" are assigned the left and right members of the tuple.", "name": "AsPat", "super_interfaces": [], "superclasses": "Pat", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [{"attribute_expression": "public final IdPat id;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "IdPat", "name": "id", "syntax_pass": true}, {"attribute_expression": "public final Pat pat;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "Pat", "name": "pat", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    AsPat(Pos pos, IdPat id, Pat pat) {\n      super(pos, Op.AS_PAT);\n      this.id = requireNonNull(id);\n      this.pat = requireNonNull(pat);\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "AsPat", "params": [{"name": "pos", "type": "Pos"}, {"name": "id", "type": "IdPat"}, {"name": "pat", "type": "Pat"}], "body": "                                      {\n      super(pos, Op.AS_PAT);\n      this.id = requireNonNull(id);\n      this.pat = requireNonNull(pat);\n    }", "signature": "AsPat(Pos pos, IdPat id, Pat pat)"}, {"syntax_pass": true, "original_string": "    public Pat accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Pat", "classes": []}, "name": "accept", "params": [{"name": "shuttle", "type": "Shuttle"}], "body": "                                       {\n      return shuttle.visit(this);\n    }", "signature": "public Pat accept(Shuttle shuttle)"}, {"syntax_pass": true, "original_string": "    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "accept", "params": [{"name": "visitor", "type": "Visitor"}], "body": "                                                  {\n      visitor.visit(this);\n    }", "signature": "@Override public void accept(Visitor visitor)"}, {"syntax_pass": true, "original_string": "    @Override public void forEachArg(ObjIntConsumer<Pat> action) {\n      action.accept(id, 0);\n      action.accept(pat, 1);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "forEachArg", "params": [{"name": "action", "type": "ObjIntConsumer<Pat>"}], "body": "                                                                 {\n      action.accept(id, 0);\n      action.accept(pat, 1);\n    }", "signature": "@Override public void forEachArg(ObjIntConsumer<Pat> action)"}, {"syntax_pass": true, "original_string": "    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      return w.infix(left, id, op, pat, right);\n    }", "docstring": "", "attributes": {"modifiers": "@Override", "marker_annotations": ["@Override"], "non_marker_annotations": [], "comments": [], "return_type": "AstWriter", "classes": []}, "name": "unparse", "params": [{"name": "w", "type": "AstWriter"}, {"name": "left", "type": "int"}, {"name": "right", "type": "int"}], "body": "                                                                  {\n      return w.infix(left, id, op, pat, right);\n    }", "signature": "@Override AstWriter unparse(AstWriter w, int left, int right)"}, {"syntax_pass": true, "original_string": "    public AsPat copy(IdPat id, Pat pat) {\n      return this.id.equals(id)\n          && this.pat.equals(pat)\n          ? this\n          : ast.asPat(pos, id, pat);\n    }", "docstring": " Creates a copy of this {@code AsPat} with given contents,\nor {@code this} if the contents are the same.", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "AsPat", "classes": []}, "name": "copy", "params": [{"name": "id", "type": "IdPat"}, {"name": "pat", "type": "Pat"}], "body": "                                         {\n      return this.id.equals(id)\n          && this.pat.equals(pat)\n          ? this\n          : ast.asPat(pos, id, pat);\n    }", "signature": "public AsPat copy(IdPat id, Pat pat)"}]}, {"original_string": "  public static class Con0Pat extends Pat {\n    public final Id tyCon;\n\n    Con0Pat(Pos pos, Id tyCon) {\n      super(pos, Op.CON0_PAT);\n      this.tyCon = requireNonNull(tyCon);\n    }\n\n    public Pat accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }\n\n    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }\n\n    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      return tyCon.unparse(w, left, right);\n    }\n\n    /** Creates a copy of this {@code Con0Pat} with given contents,\n     * or {@code this} if the contents are the same. */\n    public Con0Pat copy(Id tyCon) {\n      return this.tyCon.equals(tyCon)\n          ? this\n          : ast.con0Pat(pos, tyCon);\n    }\n  }", "definition": "  public static class Con0Pat extends Pat", "class_docstring": " Type constructor pattern with no argument.\n\n<p>For example, in \"fun nvl NIL = 0 | OPTION x = x\",\n\"NIL\" is a zero-arg type constructor pattern.\n\n@see ConPat", "name": "Con0Pat", "super_interfaces": [], "superclasses": "Pat", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [{"attribute_expression": "public final Id tyCon;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "Id", "name": "tyCon", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    Con0Pat(Pos pos, Id tyCon) {\n      super(pos, Op.CON0_PAT);\n      this.tyCon = requireNonNull(tyCon);\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "Con0Pat", "params": [{"name": "pos", "type": "Pos"}, {"name": "tyCon", "type": "Id"}], "body": "                               {\n      super(pos, Op.CON0_PAT);\n      this.tyCon = requireNonNull(tyCon);\n    }", "signature": "Con0Pat(Pos pos, Id tyCon)"}, {"syntax_pass": true, "original_string": "    public Pat accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Pat", "classes": []}, "name": "accept", "params": [{"name": "shuttle", "type": "Shuttle"}], "body": "                                       {\n      return shuttle.visit(this);\n    }", "signature": "public Pat accept(Shuttle shuttle)"}, {"syntax_pass": true, "original_string": "    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "accept", "params": [{"name": "visitor", "type": "Visitor"}], "body": "                                                  {\n      visitor.visit(this);\n    }", "signature": "@Override public void accept(Visitor visitor)"}, {"syntax_pass": true, "original_string": "    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      return tyCon.unparse(w, left, right);\n    }", "docstring": "", "attributes": {"modifiers": "@Override", "marker_annotations": ["@Override"], "non_marker_annotations": [], "comments": [], "return_type": "AstWriter", "classes": []}, "name": "unparse", "params": [{"name": "w", "type": "AstWriter"}, {"name": "left", "type": "int"}, {"name": "right", "type": "int"}], "body": "                                                                  {\n      return tyCon.unparse(w, left, right);\n    }", "signature": "@Override AstWriter unparse(AstWriter w, int left, int right)"}, {"syntax_pass": true, "original_string": "    public Con0Pat copy(Id tyCon) {\n      return this.tyCon.equals(tyCon)\n          ? this\n          : ast.con0Pat(pos, tyCon);\n    }", "docstring": " Creates a copy of this {@code Con0Pat} with given contents,\nor {@code this} if the contents are the same.", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Con0Pat", "classes": []}, "name": "copy", "params": [{"name": "tyCon", "type": "Id"}], "body": "                                  {\n      return this.tyCon.equals(tyCon)\n          ? this\n          : ast.con0Pat(pos, tyCon);\n    }", "signature": "public Con0Pat copy(Id tyCon)"}]}, {"original_string": "  public static class TuplePat extends Pat {\n    public final List<Pat> args;\n\n    TuplePat(Pos pos, ImmutableList<Pat> args) {\n      super(pos, Op.TUPLE_PAT);\n      this.args = requireNonNull(args);\n    }\n\n    public Pat accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }\n\n    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }\n\n    @Override public void forEachArg(ObjIntConsumer<Pat> action) {\n      forEachIndexed(args, action);\n    }\n\n    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      w.append(\"(\");\n      forEachArg((arg, i) -> w.append(i == 0 ? \"\" : \", \").append(arg, 0, 0));\n      return w.append(\")\");\n    }\n\n    /** Creates a copy of this {@code TuplePat} with given contents,\n     * or {@code this} if the contents are the same. */\n    public TuplePat copy(List<Pat> args) {\n      return this.args.equals(args)\n          ? this\n          : ast.tuplePat(pos, args);\n    }\n  }", "definition": "  public static class TuplePat extends Pat", "class_docstring": " Tuple pattern, the pattern analog of the {@link Tuple} expression.\n\n<p>For example, \"(x, y)\" in \"fun sum (x, y) = x + y\".", "name": "TuplePat", "super_interfaces": [], "superclasses": "Pat", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [{"attribute_expression": "public final List<Pat> args;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "List<Pat>", "name": "args", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    TuplePat(Pos pos, ImmutableList<Pat> args) {\n      super(pos, Op.TUPLE_PAT);\n      this.args = requireNonNull(args);\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "TuplePat", "params": [{"name": "pos", "type": "Pos"}, {"name": "args", "type": "ImmutableList<Pat>"}], "body": "                                               {\n      super(pos, Op.TUPLE_PAT);\n      this.args = requireNonNull(args);\n    }", "signature": "TuplePat(Pos pos, ImmutableList<Pat> args)"}, {"syntax_pass": true, "original_string": "    public Pat accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Pat", "classes": []}, "name": "accept", "params": [{"name": "shuttle", "type": "Shuttle"}], "body": "                                       {\n      return shuttle.visit(this);\n    }", "signature": "public Pat accept(Shuttle shuttle)"}, {"syntax_pass": true, "original_string": "    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "accept", "params": [{"name": "visitor", "type": "Visitor"}], "body": "                                                  {\n      visitor.visit(this);\n    }", "signature": "@Override public void accept(Visitor visitor)"}, {"syntax_pass": true, "original_string": "    @Override public void forEachArg(ObjIntConsumer<Pat> action) {\n      forEachIndexed(args, action);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "forEachArg", "params": [{"name": "action", "type": "ObjIntConsumer<Pat>"}], "body": "                                                                 {\n      forEachIndexed(args, action);\n    }", "signature": "@Override public void forEachArg(ObjIntConsumer<Pat> action)"}, {"syntax_pass": true, "original_string": "    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      w.append(\"(\");\n      forEachArg((arg, i) -> w.append(i == 0 ? \"\" : \", \").append(arg, 0, 0));\n      return w.append(\")\");\n    }", "docstring": "", "attributes": {"modifiers": "@Override", "marker_annotations": ["@Override"], "non_marker_annotations": [], "comments": [], "return_type": "AstWriter", "classes": []}, "name": "unparse", "params": [{"name": "w", "type": "AstWriter"}, {"name": "left", "type": "int"}, {"name": "right", "type": "int"}], "body": "                                                                  {\n      w.append(\"(\");\n      forEachArg((arg, i) -> w.append(i == 0 ? \"\" : \", \").append(arg, 0, 0));\n      return w.append(\")\");\n    }", "signature": "@Override AstWriter unparse(AstWriter w, int left, int right)"}, {"syntax_pass": true, "original_string": "    public TuplePat copy(List<Pat> args) {\n      return this.args.equals(args)\n          ? this\n          : ast.tuplePat(pos, args);\n    }", "docstring": " Creates a copy of this {@code TuplePat} with given contents,\nor {@code this} if the contents are the same.", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "TuplePat", "classes": []}, "name": "copy", "params": [{"name": "args", "type": "List<Pat>"}], "body": "                                         {\n      return this.args.equals(args)\n          ? this\n          : ast.tuplePat(pos, args);\n    }", "signature": "public TuplePat copy(List<Pat> args)"}]}, {"original_string": "  public static class ListPat extends Pat {\n    public final List<Pat> args;\n\n    ListPat(Pos pos, ImmutableList<Pat> args) {\n      super(pos, Op.LIST_PAT);\n      this.args = requireNonNull(args);\n    }\n\n    public Pat accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }\n\n    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }\n\n    @Override public void forEachArg(ObjIntConsumer<Pat> action) {\n      forEachIndexed(args, action);\n    }\n\n    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      w.append(\"[\");\n      forEachArg((arg, i) -> w.append(i == 0 ? \"\" : \", \").append(arg, 0, 0));\n      return w.append(\"]\");\n    }\n\n    /** Creates a copy of this {@code ListPat} with given contents,\n     * or {@code this} if the contents are the same. */\n    public ListPat copy(List<Pat> args) {\n      return this.args.equals(args)\n          ? this\n          : ast.listPat(pos, args);\n    }\n  }", "definition": "  public static class ListPat extends Pat", "class_docstring": " List pattern, the pattern analog of the {@link ListExp} expression.\n\n<p>For example, \"[x, y]\" in \"fun sum [x, y] = x + y\".", "name": "ListPat", "super_interfaces": [], "superclasses": "Pat", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [{"attribute_expression": "public final List<Pat> args;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "List<Pat>", "name": "args", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    ListPat(Pos pos, ImmutableList<Pat> args) {\n      super(pos, Op.LIST_PAT);\n      this.args = requireNonNull(args);\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "ListPat", "params": [{"name": "pos", "type": "Pos"}, {"name": "args", "type": "ImmutableList<Pat>"}], "body": "                                              {\n      super(pos, Op.LIST_PAT);\n      this.args = requireNonNull(args);\n    }", "signature": "ListPat(Pos pos, ImmutableList<Pat> args)"}, {"syntax_pass": true, "original_string": "    public Pat accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Pat", "classes": []}, "name": "accept", "params": [{"name": "shuttle", "type": "Shuttle"}], "body": "                                       {\n      return shuttle.visit(this);\n    }", "signature": "public Pat accept(Shuttle shuttle)"}, {"syntax_pass": true, "original_string": "    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "accept", "params": [{"name": "visitor", "type": "Visitor"}], "body": "                                                  {\n      visitor.visit(this);\n    }", "signature": "@Override public void accept(Visitor visitor)"}, {"syntax_pass": true, "original_string": "    @Override public void forEachArg(ObjIntConsumer<Pat> action) {\n      forEachIndexed(args, action);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "forEachArg", "params": [{"name": "action", "type": "ObjIntConsumer<Pat>"}], "body": "                                                                 {\n      forEachIndexed(args, action);\n    }", "signature": "@Override public void forEachArg(ObjIntConsumer<Pat> action)"}, {"syntax_pass": true, "original_string": "    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      w.append(\"[\");\n      forEachArg((arg, i) -> w.append(i == 0 ? \"\" : \", \").append(arg, 0, 0));\n      return w.append(\"]\");\n    }", "docstring": "", "attributes": {"modifiers": "@Override", "marker_annotations": ["@Override"], "non_marker_annotations": [], "comments": [], "return_type": "AstWriter", "classes": []}, "name": "unparse", "params": [{"name": "w", "type": "AstWriter"}, {"name": "left", "type": "int"}, {"name": "right", "type": "int"}], "body": "                                                                  {\n      w.append(\"[\");\n      forEachArg((arg, i) -> w.append(i == 0 ? \"\" : \", \").append(arg, 0, 0));\n      return w.append(\"]\");\n    }", "signature": "@Override AstWriter unparse(AstWriter w, int left, int right)"}, {"syntax_pass": true, "original_string": "    public ListPat copy(List<Pat> args) {\n      return this.args.equals(args)\n          ? this\n          : ast.listPat(pos, args);\n    }", "docstring": " Creates a copy of this {@code ListPat} with given contents,\nor {@code this} if the contents are the same.", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ListPat", "classes": []}, "name": "copy", "params": [{"name": "args", "type": "List<Pat>"}], "body": "                                        {\n      return this.args.equals(args)\n          ? this\n          : ast.listPat(pos, args);\n    }", "signature": "public ListPat copy(List<Pat> args)"}]}, {"original_string": "  public static class RecordPat extends Pat {\n    public final boolean ellipsis;\n    public final SortedMap<String, Pat> args;\n\n    RecordPat(Pos pos, boolean ellipsis, ImmutableSortedMap<String, Pat> args) {\n      super(pos, Op.RECORD_PAT);\n      this.ellipsis = ellipsis;\n      this.args = requireNonNull(args);\n      checkArgument(args.comparator() == ORDERING);\n    }\n\n    public Pat accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }\n\n    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }\n\n    @Override public void forEachArg(ObjIntConsumer<Pat> action) {\n      forEachIndexed(args.values(), action);\n    }\n\n    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      w.append(\"{\");\n      Ord.forEachIndexed(args, (i, k, v) -> // lint:skip\n          w.append(i > 0 ? \", \" : \"\").append(k).append(\" = \").append(v, 0, 0));\n      if (ellipsis) {\n        w.append(args.isEmpty() ? \"...\" : \", ...\");\n      }\n      return w.append(\"}\");\n    }\n\n    public RecordPat copy(boolean ellipsis, Map<String, ? extends Pat> args) {\n      return this.ellipsis == ellipsis\n          && this.args.equals(args)\n          ? this\n          : ast.recordPat(pos, ellipsis, args);\n    }\n  }", "definition": "  public static class RecordPat extends Pat", "class_docstring": " Record pattern.", "name": "RecordPat", "super_interfaces": [], "superclasses": "Pat", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [{"attribute_expression": "public final boolean ellipsis;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "boolean", "name": "ellipsis", "syntax_pass": true}, {"attribute_expression": "public final SortedMap<String, Pat> args;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "SortedMap<String, Pat>", "name": "args", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    RecordPat(Pos pos, boolean ellipsis, ImmutableSortedMap<String, Pat> args) {\n      super(pos, Op.RECORD_PAT);\n      this.ellipsis = ellipsis;\n      this.args = requireNonNull(args);\n      checkArgument(args.comparator() == ORDERING);\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "RecordPat", "params": [{"name": "pos", "type": "Pos"}, {"name": "ellipsis", "type": "boolean"}, {"name": "args", "type": "ImmutableSortedMap<String, Pat>"}], "body": "                                                                               {\n      super(pos, Op.RECORD_PAT);\n      this.ellipsis = ellipsis;\n      this.args = requireNonNull(args);\n      checkArgument(args.comparator() == ORDERING);\n    }", "signature": "RecordPat(Pos pos, boolean ellipsis, ImmutableSortedMap<String, Pat> args)"}, {"syntax_pass": true, "original_string": "    public Pat accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Pat", "classes": []}, "name": "accept", "params": [{"name": "shuttle", "type": "Shuttle"}], "body": "                                       {\n      return shuttle.visit(this);\n    }", "signature": "public Pat accept(Shuttle shuttle)"}, {"syntax_pass": true, "original_string": "    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "accept", "params": [{"name": "visitor", "type": "Visitor"}], "body": "                                                  {\n      visitor.visit(this);\n    }", "signature": "@Override public void accept(Visitor visitor)"}, {"syntax_pass": true, "original_string": "    @Override public void forEachArg(ObjIntConsumer<Pat> action) {\n      forEachIndexed(args.values(), action);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "forEachArg", "params": [{"name": "action", "type": "ObjIntConsumer<Pat>"}], "body": "                                                                 {\n      forEachIndexed(args.values(), action);\n    }", "signature": "@Override public void forEachArg(ObjIntConsumer<Pat> action)"}, {"syntax_pass": true, "original_string": "    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      w.append(\"{\");\n      Ord.forEachIndexed(args, (i, k, v) -> // lint:skip\n          w.append(i > 0 ? \", \" : \"\").append(k).append(\" = \").append(v, 0, 0));\n      if (ellipsis) {\n        w.append(args.isEmpty() ? \"...\" : \", ...\");\n      }\n      return w.append(\"}\");\n    }", "docstring": "", "attributes": {"modifiers": "@Override", "marker_annotations": ["@Override"], "non_marker_annotations": [], "comments": [], "return_type": "AstWriter", "classes": []}, "name": "unparse", "params": [{"name": "w", "type": "AstWriter"}, {"name": "left", "type": "int"}, {"name": "right", "type": "int"}], "body": "                                                                  {\n      w.append(\"{\");\n      Ord.forEachIndexed(args, (i, k, v) -> // lint:skip\n          w.append(i > 0 ? \", \" : \"\").append(k).append(\" = \").append(v, 0, 0));\n      if (ellipsis) {\n        w.append(args.isEmpty() ? \"...\" : \", ...\");\n      }\n      return w.append(\"}\");\n    }", "signature": "@Override AstWriter unparse(AstWriter w, int left, int right)"}, {"syntax_pass": true, "original_string": "    public RecordPat copy(boolean ellipsis, Map<String, ? extends Pat> args) {\n      return this.ellipsis == ellipsis\n          && this.args.equals(args)\n          ? this\n          : ast.recordPat(pos, ellipsis, args);\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "RecordPat", "classes": []}, "name": "copy", "params": [{"name": "ellipsis", "type": "boolean"}, {"name": "args", "type": "Map<String, ? extends Pat>"}], "body": "                                                                             {\n      return this.ellipsis == ellipsis\n          && this.args.equals(args)\n          ? this\n          : ast.recordPat(pos, ellipsis, args);\n    }", "signature": "public RecordPat copy(boolean ellipsis, Map<String, ? extends Pat> args)"}]}, {"original_string": "  public static class AnnotatedPat extends Pat {\n    public final Pat pat;\n    public final Type type;\n\n    AnnotatedPat(Pos pos, Pat pat, Type type) {\n      super(pos, Op.ANNOTATED_PAT);\n      this.pat = pat;\n      this.type = type;\n    }\n\n    public Pat accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }\n\n    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }\n\n    AstWriter unparse(AstWriter w, int left, int right) {\n      return w.infix(left, pat, op, type, right);\n    }\n\n    @Override public void forEachArg(ObjIntConsumer<Pat> action) {\n      action.accept(pat, 0);\n    }\n\n    /** Creates a copy of this {@code AnnotatedPat} with given contents,\n     * or {@code this} if the contents are the same. */\n    public AnnotatedPat copy(Pat pat, Type type) {\n      return this.pat.equals(pat)\n          && this.type.equals(type)\n          ? this\n          : ast.annotatedPat(pos, pat, type);\n    }\n  }", "definition": "  public static class AnnotatedPat extends Pat", "class_docstring": " Pattern that is a pattern annotated with a type.\n\n<p>For example, \"x : int\" in \"val x : int = 5\".", "name": "AnnotatedPat", "super_interfaces": [], "superclasses": "Pat", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [{"attribute_expression": "public final Pat pat;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "Pat", "name": "pat", "syntax_pass": true}, {"attribute_expression": "public final Type type;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "Type", "name": "type", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    AnnotatedPat(Pos pos, Pat pat, Type type) {\n      super(pos, Op.ANNOTATED_PAT);\n      this.pat = pat;\n      this.type = type;\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "AnnotatedPat", "params": [{"name": "pos", "type": "Pos"}, {"name": "pat", "type": "Pat"}, {"name": "type", "type": "Type"}], "body": "                                              {\n      super(pos, Op.ANNOTATED_PAT);\n      this.pat = pat;\n      this.type = type;\n    }", "signature": "AnnotatedPat(Pos pos, Pat pat, Type type)"}, {"syntax_pass": true, "original_string": "    public Pat accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Pat", "classes": []}, "name": "accept", "params": [{"name": "shuttle", "type": "Shuttle"}], "body": "                                       {\n      return shuttle.visit(this);\n    }", "signature": "public Pat accept(Shuttle shuttle)"}, {"syntax_pass": true, "original_string": "    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "accept", "params": [{"name": "visitor", "type": "Visitor"}], "body": "                                                  {\n      visitor.visit(this);\n    }", "signature": "@Override public void accept(Visitor visitor)"}, {"syntax_pass": true, "original_string": "    AstWriter unparse(AstWriter w, int left, int right) {\n      return w.infix(left, pat, op, type, right);\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "AstWriter", "classes": []}, "name": "unparse", "params": [{"name": "w", "type": "AstWriter"}, {"name": "left", "type": "int"}, {"name": "right", "type": "int"}], "body": "                                                        {\n      return w.infix(left, pat, op, type, right);\n    }", "signature": "AstWriter unparse(AstWriter w, int left, int right)"}, {"syntax_pass": true, "original_string": "    @Override public void forEachArg(ObjIntConsumer<Pat> action) {\n      action.accept(pat, 0);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "forEachArg", "params": [{"name": "action", "type": "ObjIntConsumer<Pat>"}], "body": "                                                                 {\n      action.accept(pat, 0);\n    }", "signature": "@Override public void forEachArg(ObjIntConsumer<Pat> action)"}, {"syntax_pass": true, "original_string": "    public AnnotatedPat copy(Pat pat, Type type) {\n      return this.pat.equals(pat)\n          && this.type.equals(type)\n          ? this\n          : ast.annotatedPat(pos, pat, type);\n    }", "docstring": " Creates a copy of this {@code AnnotatedPat} with given contents,\nor {@code this} if the contents are the same.", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "AnnotatedPat", "classes": []}, "name": "copy", "params": [{"name": "pat", "type": "Pat"}, {"name": "type", "type": "Type"}], "body": "                                                 {\n      return this.pat.equals(pat)\n          && this.type.equals(type)\n          ? this\n          : ast.annotatedPat(pos, pat, type);\n    }", "signature": "public AnnotatedPat copy(Pat pat, Type type)"}]}, {"original_string": "  public abstract static class Type extends AstNode {\n    /** Creates a type node. */\n    Type(Pos pos, Op op) {\n      super(pos, op);\n    }\n\n    @Override public abstract Type accept(Shuttle shuttle);\n  }", "definition": "  public abstract static class Type extends AstNode", "class_docstring": " Base class for parse tree nodes that represent types.", "name": "Type", "super_interfaces": [], "superclasses": "AstNode", "attributes": {"modifiers": "public abstract static", "marker_annotations": [], "non_marker_annotations": ["public", "abstract", "static"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    Type(Pos pos, Op op) {\n      super(pos, op);\n    }", "docstring": " Creates a type node.", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "Type", "params": [{"name": "pos", "type": "Pos"}, {"name": "op", "type": "Op"}], "body": "                         {\n      super(pos, op);\n    }", "signature": "Type(Pos pos, Op op)"}, {"syntax_pass": true, "original_string": "    @Override public abstract Type accept(Shuttle shuttle);", "docstring": "", "attributes": {"modifiers": "@Override public abstract", "marker_annotations": ["@Override"], "non_marker_annotations": ["public", "abstract"], "comments": [], "return_type": "Type", "classes": []}, "name": "accept", "params": [{"name": "shuttle", "type": "Shuttle"}], "body": "", "signature": "@Override public abstract Type accept(Shuttle shuttle)"}]}, {"original_string": "  public static class AnnotatedExp extends Exp {\n    public final Type type;\n    public final Exp exp;\n\n    /** Creates a type annotation. */\n    AnnotatedExp(Pos pos, Exp exp, Type type) {\n      super(pos, Op.ANNOTATED_EXP);\n      this.type = requireNonNull(type);\n      this.exp = requireNonNull(exp);\n    }\n\n    @Override public int hashCode() {\n      return Objects.hash(type, exp);\n    }\n\n    @Override public boolean equals(Object obj) {\n      return this == obj\n          || obj instanceof AnnotatedExp\n              && type.equals(((AnnotatedExp) obj).type)\n              && exp.equals(((AnnotatedExp) obj).exp);\n    }\n\n    public Exp accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }\n\n    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }\n\n    AstWriter unparse(AstWriter w, int left, int right) {\n      return w.infix(left, exp, op, type, right);\n    }\n  }", "definition": "  public static class AnnotatedExp extends Exp", "class_docstring": " Parse tree node of an expression annotated with a type.", "name": "AnnotatedExp", "super_interfaces": [], "superclasses": "Exp", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [{"attribute_expression": "public final Type type;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "Type", "name": "type", "syntax_pass": true}, {"attribute_expression": "public final Exp exp;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "Exp", "name": "exp", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    AnnotatedExp(Pos pos, Exp exp, Type type) {\n      super(pos, Op.ANNOTATED_EXP);\n      this.type = requireNonNull(type);\n      this.exp = requireNonNull(exp);\n    }", "docstring": " Creates a type annotation.", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "AnnotatedExp", "params": [{"name": "pos", "type": "Pos"}, {"name": "exp", "type": "Exp"}, {"name": "type", "type": "Type"}], "body": "                                              {\n      super(pos, Op.ANNOTATED_EXP);\n      this.type = requireNonNull(type);\n      this.exp = requireNonNull(exp);\n    }", "signature": "AnnotatedExp(Pos pos, Exp exp, Type type)"}, {"syntax_pass": true, "original_string": "    @Override public int hashCode() {\n      return Objects.hash(type, exp);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "hashCode", "params": [], "body": "                                    {\n      return Objects.hash(type, exp);\n    }", "signature": "@Override public int hashCode()"}, {"syntax_pass": true, "original_string": "    @Override public boolean equals(Object obj) {\n      return this == obj\n          || obj instanceof AnnotatedExp\n              && type.equals(((AnnotatedExp) obj).type)\n              && exp.equals(((AnnotatedExp) obj).exp);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "equals", "params": [{"name": "obj", "type": "Object"}], "body": "                                                {\n      return this == obj\n          || obj instanceof AnnotatedExp\n              && type.equals(((AnnotatedExp) obj).type)\n              && exp.equals(((AnnotatedExp) obj).exp);\n    }", "signature": "@Override public boolean equals(Object obj)"}, {"syntax_pass": true, "original_string": "    public Exp accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Exp", "classes": []}, "name": "accept", "params": [{"name": "shuttle", "type": "Shuttle"}], "body": "                                       {\n      return shuttle.visit(this);\n    }", "signature": "public Exp accept(Shuttle shuttle)"}, {"syntax_pass": true, "original_string": "    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "accept", "params": [{"name": "visitor", "type": "Visitor"}], "body": "                                                  {\n      visitor.visit(this);\n    }", "signature": "@Override public void accept(Visitor visitor)"}, {"syntax_pass": true, "original_string": "    AstWriter unparse(AstWriter w, int left, int right) {\n      return w.infix(left, exp, op, type, right);\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "AstWriter", "classes": []}, "name": "unparse", "params": [{"name": "w", "type": "AstWriter"}, {"name": "left", "type": "int"}, {"name": "right", "type": "int"}], "body": "                                                        {\n      return w.infix(left, exp, op, type, right);\n    }", "signature": "AstWriter unparse(AstWriter w, int left, int right)"}]}, {"original_string": "  public static class NamedType extends Type {\n    public final List<Type> types;\n    public final String name;\n\n    /** Creates a type. */\n    NamedType(Pos pos, ImmutableList<Type> types, String name) {\n      super(pos, Op.NAMED_TYPE);\n      this.types = requireNonNull(types);\n      this.name = requireNonNull(name);\n    }\n\n    @Override public int hashCode() {\n      return Objects.hash(types, name);\n    }\n\n    @Override public boolean equals(Object obj) {\n      return obj == this\n          || obj instanceof NamedType\n          && types.equals(((NamedType) obj).types)\n          && name.equals(((NamedType) obj).name);\n    }\n\n    public Type accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }\n\n    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }\n\n    AstWriter unparse(AstWriter w, int left, int right) {\n      switch (types.size()) {\n      case 0:\n        return w.id(name);\n      case 1:\n        return w.append(types.get(0), left, op.left)\n            .append(\" \").id(name);\n      default:\n        w.append(\"(\");\n        forEachIndexed(types, (type, i) ->\n            w.append(i == 0 ? \"\" : \", \").append(type, 0, 0));\n        return w.append(\") \")\n            .id(name);\n      }\n    }\n  }", "definition": "  public static class NamedType extends Type", "class_docstring": " Parse tree for a named type (e.g. \"int\" or \"(int, string) list\").", "name": "NamedType", "super_interfaces": [], "superclasses": "Type", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [{"attribute_expression": "public final List<Type> types;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "List<Type>", "name": "types", "syntax_pass": true}, {"attribute_expression": "public final String name;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "String", "name": "name", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    NamedType(Pos pos, ImmutableList<Type> types, String name) {\n      super(pos, Op.NAMED_TYPE);\n      this.types = requireNonNull(types);\n      this.name = requireNonNull(name);\n    }", "docstring": " Creates a type.", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "NamedType", "params": [{"name": "pos", "type": "Pos"}, {"name": "types", "type": "ImmutableList<Type>"}, {"name": "name", "type": "String"}], "body": "                                                               {\n      super(pos, Op.NAMED_TYPE);\n      this.types = requireNonNull(types);\n      this.name = requireNonNull(name);\n    }", "signature": "NamedType(Pos pos, ImmutableList<Type> types, String name)"}, {"syntax_pass": true, "original_string": "    @Override public int hashCode() {\n      return Objects.hash(types, name);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "hashCode", "params": [], "body": "                                    {\n      return Objects.hash(types, name);\n    }", "signature": "@Override public int hashCode()"}, {"syntax_pass": true, "original_string": "    @Override public boolean equals(Object obj) {\n      return obj == this\n          || obj instanceof NamedType\n          && types.equals(((NamedType) obj).types)\n          && name.equals(((NamedType) obj).name);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "equals", "params": [{"name": "obj", "type": "Object"}], "body": "                                                {\n      return obj == this\n          || obj instanceof NamedType\n          && types.equals(((NamedType) obj).types)\n          && name.equals(((NamedType) obj).name);\n    }", "signature": "@Override public boolean equals(Object obj)"}, {"syntax_pass": true, "original_string": "    public Type accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Type", "classes": []}, "name": "accept", "params": [{"name": "shuttle", "type": "Shuttle"}], "body": "                                        {\n      return shuttle.visit(this);\n    }", "signature": "public Type accept(Shuttle shuttle)"}, {"syntax_pass": true, "original_string": "    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "accept", "params": [{"name": "visitor", "type": "Visitor"}], "body": "                                                  {\n      visitor.visit(this);\n    }", "signature": "@Override public void accept(Visitor visitor)"}, {"syntax_pass": true, "original_string": "    AstWriter unparse(AstWriter w, int left, int right) {\n      switch (types.size()) {\n      case 0:\n        return w.id(name);\n      case 1:\n        return w.append(types.get(0), left, op.left)\n            .append(\" \").id(name);\n      default:\n        w.append(\"(\");\n        forEachIndexed(types, (type, i) ->\n            w.append(i == 0 ? \"\" : \", \").append(type, 0, 0));\n        return w.append(\") \")\n            .id(name);\n      }\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "AstWriter", "classes": []}, "name": "unparse", "params": [{"name": "w", "type": "AstWriter"}, {"name": "left", "type": "int"}, {"name": "right", "type": "int"}], "body": "                                                        {\n      switch (types.size()) {\n      case 0:\n        return w.id(name);\n      case 1:\n        return w.append(types.get(0), left, op.left)\n            .append(\" \").id(name);\n      default:\n        w.append(\"(\");\n        forEachIndexed(types, (type, i) ->\n            w.append(i == 0 ? \"\" : \", \").append(type, 0, 0));\n        return w.append(\") \")\n            .id(name);\n      }\n    }", "signature": "AstWriter unparse(AstWriter w, int left, int right)"}]}, {"original_string": "  public static class TyVar extends Type {\n    public final String name;\n\n    /** Creates a TyVar. */\n    TyVar(Pos pos, String name) {\n      super(pos, Op.TY_VAR);\n      this.name = requireNonNull(name);\n    }\n\n    @Override public int hashCode() {\n      return name.hashCode();\n    }\n\n    @Override public boolean equals(Object o) {\n      return o == this\n          || o instanceof TyVar\n          && this.name.equals(((TyVar) o).name);\n    }\n\n    public TyVar accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }\n\n    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }\n\n    AstWriter unparse(AstWriter w, int left, int right) {\n      return w.id(name);\n    }\n  }", "definition": "  public static class TyVar extends Type", "class_docstring": " Parse tree node of a type variable.", "name": "TyVar", "super_interfaces": [], "superclasses": "Type", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [{"attribute_expression": "public final String name;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "String", "name": "name", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    TyVar(Pos pos, String name) {\n      super(pos, Op.TY_VAR);\n      this.name = requireNonNull(name);\n    }", "docstring": " Creates a TyVar.", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "TyVar", "params": [{"name": "pos", "type": "Pos"}, {"name": "name", "type": "String"}], "body": "                                {\n      super(pos, Op.TY_VAR);\n      this.name = requireNonNull(name);\n    }", "signature": "TyVar(Pos pos, String name)"}, {"syntax_pass": true, "original_string": "    @Override public int hashCode() {\n      return name.hashCode();\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "hashCode", "params": [], "body": "                                    {\n      return name.hashCode();\n    }", "signature": "@Override public int hashCode()"}, {"syntax_pass": true, "original_string": "    @Override public boolean equals(Object o) {\n      return o == this\n          || o instanceof TyVar\n          && this.name.equals(((TyVar) o).name);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "equals", "params": [{"name": "o", "type": "Object"}], "body": "                                              {\n      return o == this\n          || o instanceof TyVar\n          && this.name.equals(((TyVar) o).name);\n    }", "signature": "@Override public boolean equals(Object o)"}, {"syntax_pass": true, "original_string": "    public TyVar accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "TyVar", "classes": []}, "name": "accept", "params": [{"name": "shuttle", "type": "Shuttle"}], "body": "                                         {\n      return shuttle.visit(this);\n    }", "signature": "public TyVar accept(Shuttle shuttle)"}, {"syntax_pass": true, "original_string": "    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "accept", "params": [{"name": "visitor", "type": "Visitor"}], "body": "                                                  {\n      visitor.visit(this);\n    }", "signature": "@Override public void accept(Visitor visitor)"}, {"syntax_pass": true, "original_string": "    AstWriter unparse(AstWriter w, int left, int right) {\n      return w.id(name);\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "AstWriter", "classes": []}, "name": "unparse", "params": [{"name": "w", "type": "AstWriter"}, {"name": "left", "type": "int"}, {"name": "right", "type": "int"}], "body": "                                                        {\n      return w.id(name);\n    }", "signature": "AstWriter unparse(AstWriter w, int left, int right)"}]}, {"original_string": "  public static class RecordType extends Type {\n    public final Map<String, Type> fieldTypes;\n\n    /** Creates a record type. */\n    RecordType(Pos pos, ImmutableMap<String, Type> fieldTypes) {\n      super(pos, Op.RECORD_TYPE);\n      this.fieldTypes = requireNonNull(fieldTypes);\n    }\n\n    @Override public int hashCode() {\n      return fieldTypes.hashCode();\n    }\n\n    @Override public boolean equals(Object o) {\n      return o == this\n          || o instanceof RecordType\n          && this.fieldTypes.equals(((RecordType) o).fieldTypes);\n    }\n\n    public RecordType accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }\n\n    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }\n\n    AstWriter unparse(AstWriter w, int left, int right) {\n      w.append(\"{\");\n      Ord.forEachIndexed(fieldTypes, (i, field, type) -> // lint:skip\n          w.append(i > 0 ? \", \" : \"\")\n              .id(field).append(\": \").append(type, 0, 0));\n      return w.append(\"}\");\n    }\n  }", "definition": "  public static class RecordType extends Type", "class_docstring": " Parse tree node of a record type.", "name": "RecordType", "super_interfaces": [], "superclasses": "Type", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [{"attribute_expression": "public final Map<String, Type> fieldTypes;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "Map<String, Type>", "name": "fieldTypes", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    RecordType(Pos pos, ImmutableMap<String, Type> fieldTypes) {\n      super(pos, Op.RECORD_TYPE);\n      this.fieldTypes = requireNonNull(fieldTypes);\n    }", "docstring": " Creates a record type.", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "RecordType", "params": [{"name": "pos", "type": "Pos"}, {"name": "fieldTypes", "type": "ImmutableMap<String, Type>"}], "body": "                                                               {\n      super(pos, Op.RECORD_TYPE);\n      this.fieldTypes = requireNonNull(fieldTypes);\n    }", "signature": "RecordType(Pos pos, ImmutableMap<String, Type> fieldTypes)"}, {"syntax_pass": true, "original_string": "    @Override public int hashCode() {\n      return fieldTypes.hashCode();\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "hashCode", "params": [], "body": "                                    {\n      return fieldTypes.hashCode();\n    }", "signature": "@Override public int hashCode()"}, {"syntax_pass": true, "original_string": "    @Override public boolean equals(Object o) {\n      return o == this\n          || o instanceof RecordType\n          && this.fieldTypes.equals(((RecordType) o).fieldTypes);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "equals", "params": [{"name": "o", "type": "Object"}], "body": "                                              {\n      return o == this\n          || o instanceof RecordType\n          && this.fieldTypes.equals(((RecordType) o).fieldTypes);\n    }", "signature": "@Override public boolean equals(Object o)"}, {"syntax_pass": true, "original_string": "    public RecordType accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "RecordType", "classes": []}, "name": "accept", "params": [{"name": "shuttle", "type": "Shuttle"}], "body": "                                              {\n      return shuttle.visit(this);\n    }", "signature": "public RecordType accept(Shuttle shuttle)"}, {"syntax_pass": true, "original_string": "    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "accept", "params": [{"name": "visitor", "type": "Visitor"}], "body": "                                                  {\n      visitor.visit(this);\n    }", "signature": "@Override public void accept(Visitor visitor)"}, {"syntax_pass": true, "original_string": "    AstWriter unparse(AstWriter w, int left, int right) {\n      w.append(\"{\");\n      Ord.forEachIndexed(fieldTypes, (i, field, type) -> // lint:skip\n          w.append(i > 0 ? \", \" : \"\")\n              .id(field).append(\": \").append(type, 0, 0));\n      return w.append(\"}\");\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "AstWriter", "classes": []}, "name": "unparse", "params": [{"name": "w", "type": "AstWriter"}, {"name": "left", "type": "int"}, {"name": "right", "type": "int"}], "body": "                                                        {\n      w.append(\"{\");\n      Ord.forEachIndexed(fieldTypes, (i, field, type) -> // lint:skip\n          w.append(i > 0 ? \", \" : \"\")\n              .id(field).append(\": \").append(type, 0, 0));\n      return w.append(\"}\");\n    }", "signature": "AstWriter unparse(AstWriter w, int left, int right)"}]}, {"original_string": "  public static class TupleType extends Type {\n    public final List<Type> types;\n\n    TupleType(Pos pos, ImmutableList<Type> types) {\n      super(pos, Op.TUPLE_TYPE);\n      this.types = requireNonNull(types);\n    }\n\n    public Type accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }\n\n    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }\n\n    AstWriter unparse(AstWriter w, int left, int right) {\n      // \"*\" is non-associative. Elevate both left and right precedence\n      // to force parentheses if the inner expression is also \"*\".\n      forEachIndexed(types, (arg, i) ->\n          w.append(i == 0 ? \"\" : \" * \")\n              .append(arg, op.left + 1, op.right + 1));\n      return w;\n    }\n  }", "definition": "  public static class TupleType extends Type", "class_docstring": " Tuple type.", "name": "TupleType", "super_interfaces": [], "superclasses": "Type", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [{"attribute_expression": "public final List<Type> types;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "List<Type>", "name": "types", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    TupleType(Pos pos, ImmutableList<Type> types) {\n      super(pos, Op.TUPLE_TYPE);\n      this.types = requireNonNull(types);\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "TupleType", "params": [{"name": "pos", "type": "Pos"}, {"name": "types", "type": "ImmutableList<Type>"}], "body": "                                                  {\n      super(pos, Op.TUPLE_TYPE);\n      this.types = requireNonNull(types);\n    }", "signature": "TupleType(Pos pos, ImmutableList<Type> types)"}, {"syntax_pass": true, "original_string": "    public Type accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Type", "classes": []}, "name": "accept", "params": [{"name": "shuttle", "type": "Shuttle"}], "body": "                                        {\n      return shuttle.visit(this);\n    }", "signature": "public Type accept(Shuttle shuttle)"}, {"syntax_pass": true, "original_string": "    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "accept", "params": [{"name": "visitor", "type": "Visitor"}], "body": "                                                  {\n      visitor.visit(this);\n    }", "signature": "@Override public void accept(Visitor visitor)"}, {"syntax_pass": true, "original_string": "    AstWriter unparse(AstWriter w, int left, int right) {\n      // \"*\" is non-associative. Elevate both left and right precedence\n      // to force parentheses if the inner expression is also \"*\".\n      forEachIndexed(types, (arg, i) ->\n          w.append(i == 0 ? \"\" : \" * \")\n              .append(arg, op.left + 1, op.right + 1));\n      return w;\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "AstWriter", "classes": []}, "name": "unparse", "params": [{"name": "w", "type": "AstWriter"}, {"name": "left", "type": "int"}, {"name": "right", "type": "int"}], "body": "                                                        {\n      // \"*\" is non-associative. Elevate both left and right precedence\n      // to force parentheses if the inner expression is also \"*\".\n      forEachIndexed(types, (arg, i) ->\n          w.append(i == 0 ? \"\" : \" * \")\n              .append(arg, op.left + 1, op.right + 1));\n      return w;\n    }", "signature": "AstWriter unparse(AstWriter w, int left, int right)"}]}, {"original_string": "  public static class CompositeType extends Type {\n    public final List<Type> types;\n\n    CompositeType(Pos pos, ImmutableList<Type> types) {\n      super(pos, Op.TUPLE_TYPE);\n      this.types = requireNonNull(types);\n    }\n\n    public Type accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }\n\n    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }\n\n    AstWriter unparse(AstWriter w, int left, int right) {\n      w.append(\"(\");\n      forEachIndexed(types, (arg, i) ->\n          w.append(i == 0 ? \"\" : \", \").append(arg, 0, 0));\n      return w.append(\")\");\n    }\n  }", "definition": "  public static class CompositeType extends Type", "class_docstring": " Not really a type, just a way for the parser to represent the type\narguments to a type constructor.\n\n<p>For example, in {@code datatype foo = Pair of (int, string) list},\n{@code (int, string)} is briefly represented as a composite type,\nthen {@code int} and {@code string} becomes the two type parameters to\nthe {@code list} {@link NamedType}.", "name": "CompositeType", "super_interfaces": [], "superclasses": "Type", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [{"attribute_expression": "public final List<Type> types;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "List<Type>", "name": "types", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    CompositeType(Pos pos, ImmutableList<Type> types) {\n      super(pos, Op.TUPLE_TYPE);\n      this.types = requireNonNull(types);\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "CompositeType", "params": [{"name": "pos", "type": "Pos"}, {"name": "types", "type": "ImmutableList<Type>"}], "body": "                                                      {\n      super(pos, Op.TUPLE_TYPE);\n      this.types = requireNonNull(types);\n    }", "signature": "CompositeType(Pos pos, ImmutableList<Type> types)"}, {"syntax_pass": true, "original_string": "    public Type accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Type", "classes": []}, "name": "accept", "params": [{"name": "shuttle", "type": "Shuttle"}], "body": "                                        {\n      return shuttle.visit(this);\n    }", "signature": "public Type accept(Shuttle shuttle)"}, {"syntax_pass": true, "original_string": "    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "accept", "params": [{"name": "visitor", "type": "Visitor"}], "body": "                                                  {\n      visitor.visit(this);\n    }", "signature": "@Override public void accept(Visitor visitor)"}, {"syntax_pass": true, "original_string": "    AstWriter unparse(AstWriter w, int left, int right) {\n      w.append(\"(\");\n      forEachIndexed(types, (arg, i) ->\n          w.append(i == 0 ? \"\" : \", \").append(arg, 0, 0));\n      return w.append(\")\");\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "AstWriter", "classes": []}, "name": "unparse", "params": [{"name": "w", "type": "AstWriter"}, {"name": "left", "type": "int"}, {"name": "right", "type": "int"}], "body": "                                                        {\n      w.append(\"(\");\n      forEachIndexed(types, (arg, i) ->\n          w.append(i == 0 ? \"\" : \", \").append(arg, 0, 0));\n      return w.append(\")\");\n    }", "signature": "AstWriter unparse(AstWriter w, int left, int right)"}]}, {"original_string": "  public static class FunctionType extends Type {\n    public final Type paramType;\n    public final Type resultType;\n\n    FunctionType(Pos pos, Type paramType, Type resultType) {\n      super(pos, Op.FUNCTION_TYPE);\n      this.paramType = requireNonNull(paramType);\n      this.resultType = requireNonNull(resultType);\n    }\n\n    public Type accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }\n\n    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }\n\n    AstWriter unparse(AstWriter w, int left, int right) {\n      return w.append(paramType, left, op.left)\n          .append(\" -> \")\n          .append(resultType, op.right, right);\n    }\n  }", "definition": "  public static class FunctionType extends Type", "class_docstring": " Function type.", "name": "FunctionType", "super_interfaces": [], "superclasses": "Type", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [{"attribute_expression": "public final Type paramType;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "Type", "name": "paramType", "syntax_pass": true}, {"attribute_expression": "public final Type resultType;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "Type", "name": "resultType", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    FunctionType(Pos pos, Type paramType, Type resultType) {\n      super(pos, Op.FUNCTION_TYPE);\n      this.paramType = requireNonNull(paramType);\n      this.resultType = requireNonNull(resultType);\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "FunctionType", "params": [{"name": "pos", "type": "Pos"}, {"name": "paramType", "type": "Type"}, {"name": "resultType", "type": "Type"}], "body": "                                                           {\n      super(pos, Op.FUNCTION_TYPE);\n      this.paramType = requireNonNull(paramType);\n      this.resultType = requireNonNull(resultType);\n    }", "signature": "FunctionType(Pos pos, Type paramType, Type resultType)"}, {"syntax_pass": true, "original_string": "    public Type accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Type", "classes": []}, "name": "accept", "params": [{"name": "shuttle", "type": "Shuttle"}], "body": "                                        {\n      return shuttle.visit(this);\n    }", "signature": "public Type accept(Shuttle shuttle)"}, {"syntax_pass": true, "original_string": "    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "accept", "params": [{"name": "visitor", "type": "Visitor"}], "body": "                                                  {\n      visitor.visit(this);\n    }", "signature": "@Override public void accept(Visitor visitor)"}, {"syntax_pass": true, "original_string": "    AstWriter unparse(AstWriter w, int left, int right) {\n      return w.append(paramType, left, op.left)\n          .append(\" -> \")\n          .append(resultType, op.right, right);\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "AstWriter", "classes": []}, "name": "unparse", "params": [{"name": "w", "type": "AstWriter"}, {"name": "left", "type": "int"}, {"name": "right", "type": "int"}], "body": "                                                        {\n      return w.append(paramType, left, op.left)\n          .append(\" -> \")\n          .append(resultType, op.right, right);\n    }", "signature": "AstWriter unparse(AstWriter w, int left, int right)"}]}, {"original_string": "  public abstract static class Exp extends AstNode {\n    Exp(Pos pos, Op op) {\n      super(pos, op);\n    }\n\n    public void forEachArg(ObjIntConsumer<Exp> action) {\n      // no args\n    }\n\n    @Override public abstract Exp accept(Shuttle shuttle);\n\n    /** Returns a list of all arguments. */\n    public final List<Exp> args() {\n      final ImmutableList.Builder<Exp> args = ImmutableList.builder();\n      forEachArg((exp, value) -> args.add(exp));\n      return args.build();\n    }\n  }", "definition": "  public abstract static class Exp extends AstNode", "class_docstring": " Base class of expression ASTs.", "name": "Exp", "super_interfaces": [], "superclasses": "AstNode", "attributes": {"modifiers": "public abstract static", "marker_annotations": [], "non_marker_annotations": ["public", "abstract", "static"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    Exp(Pos pos, Op op) {\n      super(pos, op);\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "Exp", "params": [{"name": "pos", "type": "Pos"}, {"name": "op", "type": "Op"}], "body": "                        {\n      super(pos, op);\n    }", "signature": "Exp(Pos pos, Op op)"}, {"syntax_pass": true, "original_string": "    public void forEachArg(ObjIntConsumer<Exp> action) {\n      // no args\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "forEachArg", "params": [{"name": "action", "type": "ObjIntConsumer<Exp>"}], "body": "                                                       {\n      // no args\n    }", "signature": "public void forEachArg(ObjIntConsumer<Exp> action)"}, {"syntax_pass": true, "original_string": "    @Override public abstract Exp accept(Shuttle shuttle);", "docstring": "", "attributes": {"modifiers": "@Override public abstract", "marker_annotations": ["@Override"], "non_marker_annotations": ["public", "abstract"], "comments": [], "return_type": "Exp", "classes": []}, "name": "accept", "params": [{"name": "shuttle", "type": "Shuttle"}], "body": "", "signature": "@Override public abstract Exp accept(Shuttle shuttle)"}, {"syntax_pass": true, "original_string": "    public final List<Exp> args() {\n      final ImmutableList.Builder<Exp> args = ImmutableList.builder();\n      forEachArg((exp, value) -> args.add(exp));\n      return args.build();\n    }", "docstring": " Returns a list of all arguments.", "attributes": {"modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "return_type": "List<Exp>", "classes": []}, "name": "args", "params": [], "body": "                                  {\n      final ImmutableList.Builder<Exp> args = ImmutableList.builder();\n      forEachArg((exp, value) -> args.add(exp));\n      return args.build();\n    }", "signature": "public final List<Exp> args()"}]}, {"original_string": "  public static class Id extends Exp {\n    public final String name;\n\n    /** Creates an Id. */\n    Id(Pos pos, String name) {\n      super(pos, Op.ID);\n      this.name = requireNonNull(name);\n    }\n\n    public Id accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }\n\n    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }\n\n    AstWriter unparse(AstWriter w, int left, int right) {\n      return w.id(name);\n    }\n  }", "definition": "  public static class Id extends Exp", "class_docstring": " Parse tree node of an identifier.", "name": "Id", "super_interfaces": [], "superclasses": "Exp", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [{"attribute_expression": "public final String name;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "String", "name": "name", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    Id(Pos pos, String name) {\n      super(pos, Op.ID);\n      this.name = requireNonNull(name);\n    }", "docstring": " Creates an Id.", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "Id", "params": [{"name": "pos", "type": "Pos"}, {"name": "name", "type": "String"}], "body": "                             {\n      super(pos, Op.ID);\n      this.name = requireNonNull(name);\n    }", "signature": "Id(Pos pos, String name)"}, {"syntax_pass": true, "original_string": "    public Id accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Id", "classes": []}, "name": "accept", "params": [{"name": "shuttle", "type": "Shuttle"}], "body": "                                      {\n      return shuttle.visit(this);\n    }", "signature": "public Id accept(Shuttle shuttle)"}, {"syntax_pass": true, "original_string": "    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "accept", "params": [{"name": "visitor", "type": "Visitor"}], "body": "                                                  {\n      visitor.visit(this);\n    }", "signature": "@Override public void accept(Visitor visitor)"}, {"syntax_pass": true, "original_string": "    AstWriter unparse(AstWriter w, int left, int right) {\n      return w.id(name);\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "AstWriter", "classes": []}, "name": "unparse", "params": [{"name": "w", "type": "AstWriter"}, {"name": "left", "type": "int"}, {"name": "right", "type": "int"}], "body": "                                                        {\n      return w.id(name);\n    }", "signature": "AstWriter unparse(AstWriter w, int left, int right)"}]}, {"original_string": "  public static class RecordSelector extends Exp {\n    public final String name;\n\n    /** Creates a record selector. */\n    RecordSelector(Pos pos, String name) {\n      super(pos, Op.RECORD_SELECTOR);\n      this.name = requireNonNull(name);\n      assert !name.startsWith(\"#\");\n    }\n\n    @Override public int hashCode() {\n      return name.hashCode();\n    }\n\n    @Override public boolean equals(Object o) {\n      return o == this\n          || o instanceof Id\n          && this.name.equals(((Id) o).name);\n    }\n\n    public Exp accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }\n\n    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }\n\n    AstWriter unparse(AstWriter w, int left, int right) {\n      return w.append(\"#\").append(name);\n    }\n  }", "definition": "  public static class RecordSelector extends Exp", "class_docstring": " Parse tree node of a record selector.", "name": "RecordSelector", "super_interfaces": [], "superclasses": "Exp", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [{"attribute_expression": "public final String name;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "String", "name": "name", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    RecordSelector(Pos pos, String name) {\n      super(pos, Op.RECORD_SELECTOR);\n      this.name = requireNonNull(name);\n      assert !name.startsWith(\"#\");\n    }", "docstring": " Creates a record selector.", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "RecordSelector", "params": [{"name": "pos", "type": "Pos"}, {"name": "name", "type": "String"}], "body": "                                         {\n      super(pos, Op.RECORD_SELECTOR);\n      this.name = requireNonNull(name);\n      assert !name.startsWith(\"#\");\n    }", "signature": "RecordSelector(Pos pos, String name)"}, {"syntax_pass": true, "original_string": "    @Override public int hashCode() {\n      return name.hashCode();\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "hashCode", "params": [], "body": "                                    {\n      return name.hashCode();\n    }", "signature": "@Override public int hashCode()"}, {"syntax_pass": true, "original_string": "    @Override public boolean equals(Object o) {\n      return o == this\n          || o instanceof Id\n          && this.name.equals(((Id) o).name);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "equals", "params": [{"name": "o", "type": "Object"}], "body": "                                              {\n      return o == this\n          || o instanceof Id\n          && this.name.equals(((Id) o).name);\n    }", "signature": "@Override public boolean equals(Object o)"}, {"syntax_pass": true, "original_string": "    public Exp accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Exp", "classes": []}, "name": "accept", "params": [{"name": "shuttle", "type": "Shuttle"}], "body": "                                       {\n      return shuttle.visit(this);\n    }", "signature": "public Exp accept(Shuttle shuttle)"}, {"syntax_pass": true, "original_string": "    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "accept", "params": [{"name": "visitor", "type": "Visitor"}], "body": "                                                  {\n      visitor.visit(this);\n    }", "signature": "@Override public void accept(Visitor visitor)"}, {"syntax_pass": true, "original_string": "    AstWriter unparse(AstWriter w, int left, int right) {\n      return w.append(\"#\").append(name);\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "AstWriter", "classes": []}, "name": "unparse", "params": [{"name": "w", "type": "AstWriter"}, {"name": "left", "type": "int"}, {"name": "right", "type": "int"}], "body": "                                                        {\n      return w.append(\"#\").append(name);\n    }", "signature": "AstWriter unparse(AstWriter w, int left, int right)"}]}, {"original_string": "  @SuppressWarnings(\"rawtypes\")\n  public static class Literal extends Exp {\n    public final Comparable value;\n\n    /** Creates a Literal. */\n    Literal(Pos pos, Op op, Comparable value) {\n      super(pos, op);\n      this.value = requireNonNull(value);\n    }\n\n    @Override public int hashCode() {\n      return value.hashCode();\n    }\n\n    @Override public boolean equals(Object o) {\n      return o == this\n          || o instanceof Literal\n          && this.value.equals(((Literal) o).value);\n    }\n\n    public Exp accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }\n\n    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }\n\n    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      return w.appendLiteral(value);\n    }\n  }", "definition": "  @SuppressWarnings(\"rawtypes\")\n  public static class Literal extends Exp", "class_docstring": " Parse tree node of a literal (constant).", "name": "Literal", "super_interfaces": [], "superclasses": "Exp", "attributes": {"modifiers": "@SuppressWarnings(\"rawtypes\")\n  public static", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings(\"rawtypes\")", "public", "static"], "comments": [], "fields": [{"attribute_expression": "public final Comparable value;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "Comparable", "name": "value", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    Literal(Pos pos, Op op, Comparable value) {\n      super(pos, op);\n      this.value = requireNonNull(value);\n    }", "docstring": " Creates a Literal.", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "Literal", "params": [{"name": "pos", "type": "Pos"}, {"name": "op", "type": "Op"}, {"name": "value", "type": "Comparable"}], "body": "                                              {\n      super(pos, op);\n      this.value = requireNonNull(value);\n    }", "signature": "Literal(Pos pos, Op op, Comparable value)"}, {"syntax_pass": true, "original_string": "    @Override public int hashCode() {\n      return value.hashCode();\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "hashCode", "params": [], "body": "                                    {\n      return value.hashCode();\n    }", "signature": "@Override public int hashCode()"}, {"syntax_pass": true, "original_string": "    @Override public boolean equals(Object o) {\n      return o == this\n          || o instanceof Literal\n          && this.value.equals(((Literal) o).value);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "equals", "params": [{"name": "o", "type": "Object"}], "body": "                                              {\n      return o == this\n          || o instanceof Literal\n          && this.value.equals(((Literal) o).value);\n    }", "signature": "@Override public boolean equals(Object o)"}, {"syntax_pass": true, "original_string": "    public Exp accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Exp", "classes": []}, "name": "accept", "params": [{"name": "shuttle", "type": "Shuttle"}], "body": "                                       {\n      return shuttle.visit(this);\n    }", "signature": "public Exp accept(Shuttle shuttle)"}, {"syntax_pass": true, "original_string": "    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "accept", "params": [{"name": "visitor", "type": "Visitor"}], "body": "                                                  {\n      visitor.visit(this);\n    }", "signature": "@Override public void accept(Visitor visitor)"}, {"syntax_pass": true, "original_string": "    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      return w.appendLiteral(value);\n    }", "docstring": "", "attributes": {"modifiers": "@Override", "marker_annotations": ["@Override"], "non_marker_annotations": [], "comments": [], "return_type": "AstWriter", "classes": []}, "name": "unparse", "params": [{"name": "w", "type": "AstWriter"}, {"name": "left", "type": "int"}, {"name": "right", "type": "int"}], "body": "                                                                  {\n      return w.appendLiteral(value);\n    }", "signature": "@Override AstWriter unparse(AstWriter w, int left, int right)"}]}, {"original_string": "  public abstract static class Decl extends AstNode {\n    Decl(Pos pos, Op op) {\n      super(pos, op);\n    }\n\n    @Override public abstract Decl accept(Shuttle shuttle);\n  }", "definition": "  public abstract static class Decl extends AstNode", "class_docstring": " Base class for declarations.", "name": "Decl", "super_interfaces": [], "superclasses": "AstNode", "attributes": {"modifiers": "public abstract static", "marker_annotations": [], "non_marker_annotations": ["public", "abstract", "static"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    Decl(Pos pos, Op op) {\n      super(pos, op);\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "Decl", "params": [{"name": "pos", "type": "Pos"}, {"name": "op", "type": "Op"}], "body": "                         {\n      super(pos, op);\n    }", "signature": "Decl(Pos pos, Op op)"}, {"syntax_pass": true, "original_string": "    @Override public abstract Decl accept(Shuttle shuttle);", "docstring": "", "attributes": {"modifiers": "@Override public abstract", "marker_annotations": ["@Override"], "non_marker_annotations": ["public", "abstract"], "comments": [], "return_type": "Decl", "classes": []}, "name": "accept", "params": [{"name": "shuttle", "type": "Shuttle"}], "body": "", "signature": "@Override public abstract Decl accept(Shuttle shuttle)"}]}, {"original_string": "  public static class DatatypeDecl extends Decl {\n    public final List<DatatypeBind> binds;\n\n    DatatypeDecl(Pos pos, ImmutableList<DatatypeBind> binds) {\n      super(pos, Op.DATATYPE_DECL);\n      this.binds = requireNonNull(binds);\n      checkArgument(!this.binds.isEmpty());\n    }\n\n    @Override public int hashCode() {\n      return Objects.hash(binds);\n    }\n\n    @Override public boolean equals(Object o) {\n      return o == this\n          || o instanceof DatatypeDecl\n          && binds.equals(((DatatypeDecl) o).binds);\n    }\n\n    public DatatypeDecl accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }\n\n    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }\n\n    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      return w.appendAll(binds, \"datatype \", \" and \", \"\");\n    }\n  }", "definition": "  public static class DatatypeDecl extends Decl", "class_docstring": " Parse tree node of a datatype declaration.", "name": "DatatypeDecl", "super_interfaces": [], "superclasses": "Decl", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [{"attribute_expression": "public final List<DatatypeBind> binds;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "List<DatatypeBind>", "name": "binds", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    DatatypeDecl(Pos pos, ImmutableList<DatatypeBind> binds) {\n      super(pos, Op.DATATYPE_DECL);\n      this.binds = requireNonNull(binds);\n      checkArgument(!this.binds.isEmpty());\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "DatatypeDecl", "params": [{"name": "pos", "type": "Pos"}, {"name": "binds", "type": "ImmutableList<DatatypeBind>"}], "body": "                                                             {\n      super(pos, Op.DATATYPE_DECL);\n      this.binds = requireNonNull(binds);\n      checkArgument(!this.binds.isEmpty());\n    }", "signature": "DatatypeDecl(Pos pos, ImmutableList<DatatypeBind> binds)"}, {"syntax_pass": true, "original_string": "    @Override public int hashCode() {\n      return Objects.hash(binds);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "hashCode", "params": [], "body": "                                    {\n      return Objects.hash(binds);\n    }", "signature": "@Override public int hashCode()"}, {"syntax_pass": true, "original_string": "    @Override public boolean equals(Object o) {\n      return o == this\n          || o instanceof DatatypeDecl\n          && binds.equals(((DatatypeDecl) o).binds);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "equals", "params": [{"name": "o", "type": "Object"}], "body": "                                              {\n      return o == this\n          || o instanceof DatatypeDecl\n          && binds.equals(((DatatypeDecl) o).binds);\n    }", "signature": "@Override public boolean equals(Object o)"}, {"syntax_pass": true, "original_string": "    public DatatypeDecl accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "DatatypeDecl", "classes": []}, "name": "accept", "params": [{"name": "shuttle", "type": "Shuttle"}], "body": "                                                {\n      return shuttle.visit(this);\n    }", "signature": "public DatatypeDecl accept(Shuttle shuttle)"}, {"syntax_pass": true, "original_string": "    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "accept", "params": [{"name": "visitor", "type": "Visitor"}], "body": "                                                  {\n      visitor.visit(this);\n    }", "signature": "@Override public void accept(Visitor visitor)"}, {"syntax_pass": true, "original_string": "    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      return w.appendAll(binds, \"datatype \", \" and \", \"\");\n    }", "docstring": "", "attributes": {"modifiers": "@Override", "marker_annotations": ["@Override"], "non_marker_annotations": [], "comments": [], "return_type": "AstWriter", "classes": []}, "name": "unparse", "params": [{"name": "w", "type": "AstWriter"}, {"name": "left", "type": "int"}, {"name": "right", "type": "int"}], "body": "                                                                  {\n      return w.appendAll(binds, \"datatype \", \" and \", \"\");\n    }", "signature": "@Override AstWriter unparse(AstWriter w, int left, int right)"}]}, {"original_string": "  public static class DatatypeBind extends AstNode {\n    public final List<TyVar> tyVars;\n    public final Id name;\n    public final List<TyCon> tyCons;\n\n    DatatypeBind(Pos pos, ImmutableList<TyVar> tyVars, Id name,\n        ImmutableList<TyCon> tyCons) {\n      super(pos, Op.DATATYPE_DECL);\n      this.tyVars = requireNonNull(tyVars);\n      this.name = requireNonNull(name);\n      this.tyCons = requireNonNull(tyCons);\n      checkArgument(!this.tyCons.isEmpty());\n    }\n\n    @Override public int hashCode() {\n      return Objects.hash(tyVars, tyCons);\n    }\n\n    @Override public boolean equals(Object o) {\n      return o == this\n          || o instanceof DatatypeBind\n          && name.equals(((DatatypeBind) o).name)\n          && tyVars.equals(((DatatypeBind) o).tyVars)\n          && tyCons.equals(((DatatypeBind) o).tyCons);\n    }\n\n    public DatatypeBind accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }\n\n    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }\n\n    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      switch (tyVars.size()) {\n      case 0:\n        break;\n      case 1:\n        w.append(tyVars.get(0), 0, 0).append(\" \");\n        break;\n      default:\n        w.appendAll(tyVars, \"(\", \", \", \") \");\n      }\n      return w.id(name.name)\n          .appendAll(tyCons, \" = \", \" | \", \"\");\n    }\n  }", "definition": "  public static class DatatypeBind extends AstNode", "class_docstring": " Parse tree node of a datatype binding.\n\n<p>Example: the datatype declaration\n{@code datatype 'a x = X1 of 'a | X2 and y = Y}\nconsists of type bindings {@code 'a x = X1 of 'a | X2} and\n{@code y = Y}.", "name": "DatatypeBind", "super_interfaces": [], "superclasses": "AstNode", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [{"attribute_expression": "public final List<TyVar> tyVars;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "List<TyVar>", "name": "tyVars", "syntax_pass": true}, {"attribute_expression": "public final Id name;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "Id", "name": "name", "syntax_pass": true}, {"attribute_expression": "public final List<TyCon> tyCons;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "List<TyCon>", "name": "tyCons", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    DatatypeBind(Pos pos, ImmutableList<TyVar> tyVars, Id name,\n        ImmutableList<TyCon> tyCons) {\n      super(pos, Op.DATATYPE_DECL);\n      this.tyVars = requireNonNull(tyVars);\n      this.name = requireNonNull(name);\n      this.tyCons = requireNonNull(tyCons);\n      checkArgument(!this.tyCons.isEmpty());\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "DatatypeBind", "params": [{"name": "pos", "type": "Pos"}, {"name": "tyVars", "type": "ImmutableList<TyVar>"}, {"name": "name", "type": "Id"}, {"name": "tyCons", "type": "ImmutableList<TyCon>"}], "body": "                                     {\n      super(pos, Op.DATATYPE_DECL);\n      this.tyVars = requireNonNull(tyVars);\n      this.name = requireNonNull(name);\n      this.tyCons = requireNonNull(tyCons);\n      checkArgument(!this.tyCons.isEmpty());\n    }", "signature": "DatatypeBind(Pos pos, ImmutableList<TyVar> tyVars, Id name,\n        ImmutableList<TyCon> tyCons)"}, {"syntax_pass": true, "original_string": "    @Override public int hashCode() {\n      return Objects.hash(tyVars, tyCons);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "hashCode", "params": [], "body": "                                    {\n      return Objects.hash(tyVars, tyCons);\n    }", "signature": "@Override public int hashCode()"}, {"syntax_pass": true, "original_string": "    @Override public boolean equals(Object o) {\n      return o == this\n          || o instanceof DatatypeBind\n          && name.equals(((DatatypeBind) o).name)\n          && tyVars.equals(((DatatypeBind) o).tyVars)\n          && tyCons.equals(((DatatypeBind) o).tyCons);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "equals", "params": [{"name": "o", "type": "Object"}], "body": "                                              {\n      return o == this\n          || o instanceof DatatypeBind\n          && name.equals(((DatatypeBind) o).name)\n          && tyVars.equals(((DatatypeBind) o).tyVars)\n          && tyCons.equals(((DatatypeBind) o).tyCons);\n    }", "signature": "@Override public boolean equals(Object o)"}, {"syntax_pass": true, "original_string": "    public DatatypeBind accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "DatatypeBind", "classes": []}, "name": "accept", "params": [{"name": "shuttle", "type": "Shuttle"}], "body": "                                                {\n      return shuttle.visit(this);\n    }", "signature": "public DatatypeBind accept(Shuttle shuttle)"}, {"syntax_pass": true, "original_string": "    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "accept", "params": [{"name": "visitor", "type": "Visitor"}], "body": "                                                  {\n      visitor.visit(this);\n    }", "signature": "@Override public void accept(Visitor visitor)"}, {"syntax_pass": true, "original_string": "    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      switch (tyVars.size()) {\n      case 0:\n        break;\n      case 1:\n        w.append(tyVars.get(0), 0, 0).append(\" \");\n        break;\n      default:\n        w.appendAll(tyVars, \"(\", \", \", \") \");\n      }\n      return w.id(name.name)\n          .appendAll(tyCons, \" = \", \" | \", \"\");\n    }", "docstring": "", "attributes": {"modifiers": "@Override", "marker_annotations": ["@Override"], "non_marker_annotations": [], "comments": [], "return_type": "AstWriter", "classes": []}, "name": "unparse", "params": [{"name": "w", "type": "AstWriter"}, {"name": "left", "type": "int"}, {"name": "right", "type": "int"}], "body": "                                                                  {\n      switch (tyVars.size()) {\n      case 0:\n        break;\n      case 1:\n        w.append(tyVars.get(0), 0, 0).append(\" \");\n        break;\n      default:\n        w.appendAll(tyVars, \"(\", \", \", \") \");\n      }\n      return w.id(name.name)\n          .appendAll(tyCons, \" = \", \" | \", \"\");\n    }", "signature": "@Override AstWriter unparse(AstWriter w, int left, int right)"}]}, {"original_string": "  public static class TyCon extends AstNode {\n    public final Id id;\n    public final @org.checkerframework.checker.nullness.qual.Nullable Type type;\n\n    TyCon(Pos pos, Id id, Type type) {\n      super(pos, Op.TY_CON);\n      this.id = requireNonNull(id);\n      this.type = type; // optional\n    }\n\n    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }\n\n    AstWriter unparse(AstWriter w, int left, int right) {\n      if (type != null) {\n        return w.append(id, left, op.left)\n            .append(\" of \")\n            .append(type, op.right, right);\n      } else {\n        return w.append(id, left, right);\n      }\n    }\n\n    public AstNode accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }\n  }", "definition": "  public static class TyCon extends AstNode", "class_docstring": " Type constructor.\n\n<p>For example, in the {@link DatatypeDecl datatype declaration}\n{@code datatype 'a option = NIL | SOME of 'a}, \"NIL\" and \"SOME of 'a\"\nare both type constructors.\n", "name": "TyCon", "super_interfaces": [], "superclasses": "AstNode", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [{"attribute_expression": "public final Id id;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "Id", "name": "id", "syntax_pass": true}, {"attribute_expression": "public final @org.checkerframework.checker.nullness.qual.Nullable Type type;", "docstring": "", "modifiers": "public final @org.checkerframework.checker.nullness.qual.Nullable", "marker_annotations": ["@org.checkerframework.checker.nullness.qual.Nullable"], "non_marker_annotations": ["public", "final"], "comments": [], "type": "Type", "name": "type", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    TyCon(Pos pos, Id id, Type type) {\n      super(pos, Op.TY_CON);\n      this.id = requireNonNull(id);\n      this.type = type; // optional\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "TyCon", "params": [{"name": "pos", "type": "Pos"}, {"name": "id", "type": "Id"}, {"name": "type", "type": "Type"}], "body": "                                     {\n      super(pos, Op.TY_CON);\n      this.id = requireNonNull(id);\n      this.type = type; // optional\n    }", "signature": "TyCon(Pos pos, Id id, Type type)"}, {"syntax_pass": true, "original_string": "    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "accept", "params": [{"name": "visitor", "type": "Visitor"}], "body": "                                                  {\n      visitor.visit(this);\n    }", "signature": "@Override public void accept(Visitor visitor)"}, {"syntax_pass": true, "original_string": "    AstWriter unparse(AstWriter w, int left, int right) {\n      if (type != null) {\n        return w.append(id, left, op.left)\n            .append(\" of \")\n            .append(type, op.right, right);\n      } else {\n        return w.append(id, left, right);\n      }\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "AstWriter", "classes": []}, "name": "unparse", "params": [{"name": "w", "type": "AstWriter"}, {"name": "left", "type": "int"}, {"name": "right", "type": "int"}], "body": "                                                        {\n      if (type != null) {\n        return w.append(id, left, op.left)\n            .append(\" of \")\n            .append(type, op.right, right);\n      } else {\n        return w.append(id, left, right);\n      }\n    }", "signature": "AstWriter unparse(AstWriter w, int left, int right)"}, {"syntax_pass": true, "original_string": "    public AstNode accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "AstNode", "classes": []}, "name": "accept", "params": [{"name": "shuttle", "type": "Shuttle"}], "body": "                                           {\n      return shuttle.visit(this);\n    }", "signature": "public AstNode accept(Shuttle shuttle)"}]}, {"original_string": "  public static class ValDecl extends Decl {\n    public final boolean rec;\n    public final List<ValBind> valBinds;\n\n    protected ValDecl(Pos pos, boolean rec, ImmutableList<ValBind> valBinds) {\n      super(pos, Op.VAL_DECL);\n      this.rec = rec;\n      this.valBinds = requireNonNull(valBinds);\n      checkArgument(!valBinds.isEmpty());\n    }\n\n    @Override public int hashCode() {\n      return Objects.hash(rec, valBinds);\n    }\n\n    @Override public boolean equals(Object o) {\n      return o == this\n          || o instanceof ValDecl\n          && this.rec == ((ValDecl) o).rec\n          && this.valBinds.equals(((ValDecl) o).valBinds);\n    }\n\n    public ValDecl accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }\n\n    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }\n\n    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      String sep = rec ? \"val rec \" : \"val \";\n      for (ValBind valBind : valBinds) {\n        w.append(sep);\n        sep = \" and \";\n        valBind.unparse(w, 0, right);\n      }\n      return w;\n    }\n\n    /** Creates a copy of this {@code ValDecl} with given contents,\n     * or {@code this} if the contents are the same. */\n    public ValDecl copy(Iterable<ValBind> valBinds) {\n      return Iterables.elementsEqual(this.valBinds, valBinds)\n          ? this\n          : ast.valDecl(pos, rec, valBinds);\n    }\n  }", "definition": "  public static class ValDecl extends Decl", "class_docstring": " Parse tree node of a value declaration.", "name": "ValDecl", "super_interfaces": [], "superclasses": "Decl", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [{"attribute_expression": "public final boolean rec;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "boolean", "name": "rec", "syntax_pass": true}, {"attribute_expression": "public final List<ValBind> valBinds;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "List<ValBind>", "name": "valBinds", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    protected ValDecl(Pos pos, boolean rec, ImmutableList<ValBind> valBinds) {\n      super(pos, Op.VAL_DECL);\n      this.rec = rec;\n      this.valBinds = requireNonNull(valBinds);\n      checkArgument(!valBinds.isEmpty());\n    }", "docstring": "", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "", "classes": []}, "name": "ValDecl", "params": [{"name": "pos", "type": "Pos"}, {"name": "rec", "type": "boolean"}, {"name": "valBinds", "type": "ImmutableList<ValBind>"}], "body": "                                                                             {\n      super(pos, Op.VAL_DECL);\n      this.rec = rec;\n      this.valBinds = requireNonNull(valBinds);\n      checkArgument(!valBinds.isEmpty());\n    }", "signature": "protected ValDecl(Pos pos, boolean rec, ImmutableList<ValBind> valBinds)"}, {"syntax_pass": true, "original_string": "    @Override public int hashCode() {\n      return Objects.hash(rec, valBinds);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "hashCode", "params": [], "body": "                                    {\n      return Objects.hash(rec, valBinds);\n    }", "signature": "@Override public int hashCode()"}, {"syntax_pass": true, "original_string": "    @Override public boolean equals(Object o) {\n      return o == this\n          || o instanceof ValDecl\n          && this.rec == ((ValDecl) o).rec\n          && this.valBinds.equals(((ValDecl) o).valBinds);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "equals", "params": [{"name": "o", "type": "Object"}], "body": "                                              {\n      return o == this\n          || o instanceof ValDecl\n          && this.rec == ((ValDecl) o).rec\n          && this.valBinds.equals(((ValDecl) o).valBinds);\n    }", "signature": "@Override public boolean equals(Object o)"}, {"syntax_pass": true, "original_string": "    public ValDecl accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ValDecl", "classes": []}, "name": "accept", "params": [{"name": "shuttle", "type": "Shuttle"}], "body": "                                           {\n      return shuttle.visit(this);\n    }", "signature": "public ValDecl accept(Shuttle shuttle)"}, {"syntax_pass": true, "original_string": "    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "accept", "params": [{"name": "visitor", "type": "Visitor"}], "body": "                                                  {\n      visitor.visit(this);\n    }", "signature": "@Override public void accept(Visitor visitor)"}, {"syntax_pass": true, "original_string": "    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      String sep = rec ? \"val rec \" : \"val \";\n      for (ValBind valBind : valBinds) {\n        w.append(sep);\n        sep = \" and \";\n        valBind.unparse(w, 0, right);\n      }\n      return w;\n    }", "docstring": "", "attributes": {"modifiers": "@Override", "marker_annotations": ["@Override"], "non_marker_annotations": [], "comments": [], "return_type": "AstWriter", "classes": []}, "name": "unparse", "params": [{"name": "w", "type": "AstWriter"}, {"name": "left", "type": "int"}, {"name": "right", "type": "int"}], "body": "                                                                  {\n      String sep = rec ? \"val rec \" : \"val \";\n      for (ValBind valBind : valBinds) {\n        w.append(sep);\n        sep = \" and \";\n        valBind.unparse(w, 0, right);\n      }\n      return w;\n    }", "signature": "@Override AstWriter unparse(AstWriter w, int left, int right)"}, {"syntax_pass": true, "original_string": "    public ValDecl copy(Iterable<ValBind> valBinds) {\n      return Iterables.elementsEqual(this.valBinds, valBinds)\n          ? this\n          : ast.valDecl(pos, rec, valBinds);\n    }", "docstring": " Creates a copy of this {@code ValDecl} with given contents,\nor {@code this} if the contents are the same.", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ValDecl", "classes": []}, "name": "copy", "params": [{"name": "valBinds", "type": "Iterable<ValBind>"}], "body": "                                                    {\n      return Iterables.elementsEqual(this.valBinds, valBinds)\n          ? this\n          : ast.valDecl(pos, rec, valBinds);\n    }", "signature": "public ValDecl copy(Iterable<ValBind> valBinds)"}]}, {"original_string": "  public static class FunDecl extends Decl {\n    public final List<FunBind> funBinds;\n\n    FunDecl(Pos pos, ImmutableList<FunBind> funBinds) {\n      super(pos, Op.FUN_DECL);\n      this.funBinds = requireNonNull(funBinds);\n      checkArgument(!funBinds.isEmpty());\n      // TODO: check that functions have the same name\n    }\n\n    @Override public int hashCode() {\n      return funBinds.hashCode();\n    }\n\n    @Override public boolean equals(Object o) {\n      return o == this\n          || o instanceof FunDecl\n          && this.funBinds.equals(((FunDecl) o).funBinds);\n    }\n\n    public Decl accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }\n\n    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }\n\n    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      return w.appendAll(funBinds, \"fun \", \" and \", \"\");\n    }\n  }", "definition": "  public static class FunDecl extends Decl", "class_docstring": " Parse tree node of a function declaration.", "name": "FunDecl", "super_interfaces": [], "superclasses": "Decl", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [{"attribute_expression": "public final List<FunBind> funBinds;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "List<FunBind>", "name": "funBinds", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    FunDecl(Pos pos, ImmutableList<FunBind> funBinds) {\n      super(pos, Op.FUN_DECL);\n      this.funBinds = requireNonNull(funBinds);\n      checkArgument(!funBinds.isEmpty());\n      // TODO: check that functions have the same name\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "FunDecl", "params": [{"name": "pos", "type": "Pos"}, {"name": "funBinds", "type": "ImmutableList<FunBind>"}], "body": "                                                      {\n      super(pos, Op.FUN_DECL);\n      this.funBinds = requireNonNull(funBinds);\n      checkArgument(!funBinds.isEmpty());\n      // TODO: check that functions have the same name\n    }", "signature": "FunDecl(Pos pos, ImmutableList<FunBind> funBinds)"}, {"syntax_pass": true, "original_string": "    @Override public int hashCode() {\n      return funBinds.hashCode();\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "hashCode", "params": [], "body": "                                    {\n      return funBinds.hashCode();\n    }", "signature": "@Override public int hashCode()"}, {"syntax_pass": true, "original_string": "    @Override public boolean equals(Object o) {\n      return o == this\n          || o instanceof FunDecl\n          && this.funBinds.equals(((FunDecl) o).funBinds);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "equals", "params": [{"name": "o", "type": "Object"}], "body": "                                              {\n      return o == this\n          || o instanceof FunDecl\n          && this.funBinds.equals(((FunDecl) o).funBinds);\n    }", "signature": "@Override public boolean equals(Object o)"}, {"syntax_pass": true, "original_string": "    public Decl accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Decl", "classes": []}, "name": "accept", "params": [{"name": "shuttle", "type": "Shuttle"}], "body": "                                        {\n      return shuttle.visit(this);\n    }", "signature": "public Decl accept(Shuttle shuttle)"}, {"syntax_pass": true, "original_string": "    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "accept", "params": [{"name": "visitor", "type": "Visitor"}], "body": "                                                  {\n      visitor.visit(this);\n    }", "signature": "@Override public void accept(Visitor visitor)"}, {"syntax_pass": true, "original_string": "    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      return w.appendAll(funBinds, \"fun \", \" and \", \"\");\n    }", "docstring": "", "attributes": {"modifiers": "@Override", "marker_annotations": ["@Override"], "non_marker_annotations": [], "comments": [], "return_type": "AstWriter", "classes": []}, "name": "unparse", "params": [{"name": "w", "type": "AstWriter"}, {"name": "left", "type": "int"}, {"name": "right", "type": "int"}], "body": "                                                                  {\n      return w.appendAll(funBinds, \"fun \", \" and \", \"\");\n    }", "signature": "@Override AstWriter unparse(AstWriter w, int left, int right)"}]}, {"original_string": "  public static class FunBind extends AstNode {\n    public final List<FunMatch> matchList;\n    public final String name;\n\n    FunBind(Pos pos, ImmutableList<FunMatch> matchList) {\n      super(pos, Op.FUN_BIND);\n      checkArgument(!matchList.isEmpty());\n      this.matchList = matchList;\n      // We assume that the function name is the same in all matches.\n      // We will check during validation.\n      this.name = matchList.get(0).name;\n    }\n\n    public FunBind accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }\n\n    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }\n\n    AstWriter unparse(AstWriter w, int left, int right) {\n      return w.appendAll(matchList, \" | \");\n    }\n  }", "definition": "  public static class FunBind extends AstNode", "class_docstring": " One of the branches (separated by 'and') in a 'fun' function\ndeclaration.", "name": "FunBind", "super_interfaces": [], "superclasses": "AstNode", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [{"attribute_expression": "public final List<FunMatch> matchList;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "List<FunMatch>", "name": "matchList", "syntax_pass": true}, {"attribute_expression": "public final String name;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "String", "name": "name", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    FunBind(Pos pos, ImmutableList<FunMatch> matchList) {\n      super(pos, Op.FUN_BIND);\n      checkArgument(!matchList.isEmpty());\n      this.matchList = matchList;\n      // We assume that the function name is the same in all matches.\n      // We will check during validation.\n      this.name = matchList.get(0).name;\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "FunBind", "params": [{"name": "pos", "type": "Pos"}, {"name": "matchList", "type": "ImmutableList<FunMatch>"}], "body": "                                                        {\n      super(pos, Op.FUN_BIND);\n      checkArgument(!matchList.isEmpty());\n      this.matchList = matchList;\n      // We assume that the function name is the same in all matches.\n      // We will check during validation.\n      this.name = matchList.get(0).name;\n    }", "signature": "FunBind(Pos pos, ImmutableList<FunMatch> matchList)"}, {"syntax_pass": true, "original_string": "    public FunBind accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "FunBind", "classes": []}, "name": "accept", "params": [{"name": "shuttle", "type": "Shuttle"}], "body": "                                           {\n      return shuttle.visit(this);\n    }", "signature": "public FunBind accept(Shuttle shuttle)"}, {"syntax_pass": true, "original_string": "    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "accept", "params": [{"name": "visitor", "type": "Visitor"}], "body": "                                                  {\n      visitor.visit(this);\n    }", "signature": "@Override public void accept(Visitor visitor)"}, {"syntax_pass": true, "original_string": "    AstWriter unparse(AstWriter w, int left, int right) {\n      return w.appendAll(matchList, \" | \");\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "AstWriter", "classes": []}, "name": "unparse", "params": [{"name": "w", "type": "AstWriter"}, {"name": "left", "type": "int"}, {"name": "right", "type": "int"}], "body": "                                                        {\n      return w.appendAll(matchList, \" | \");\n    }", "signature": "AstWriter unparse(AstWriter w, int left, int right)"}]}, {"original_string": "  public static class FunMatch extends AstNode {\n    public final String name;\n    public final List<Pat> patList;\n    public final @Nullable Type returnType;\n    public final Exp exp;\n\n    FunMatch(Pos pos, String name, ImmutableList<Pat> patList,\n        @Nullable Type returnType, Exp exp) {\n      super(pos, Op.FUN_MATCH);\n      this.name = name;\n      this.patList = patList;\n      this.returnType = returnType;\n      this.exp = exp;\n    }\n\n    public FunMatch accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }\n\n    AstWriter unparse(AstWriter w, int left, int right) {\n      w.id(name);\n      for (Pat pat : patList) {\n        w.append(\" \").append(pat, Op.APPLY.left, Op.APPLY.right);\n      }\n      return w.append(\" = \").append(exp, 0, right);\n    }\n\n    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }\n  }", "definition": "  public static class FunMatch extends AstNode", "class_docstring": " One of the branches (separated by '|') in a 'fun' function declaration.", "name": "FunMatch", "super_interfaces": [], "superclasses": "AstNode", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [{"attribute_expression": "public final String name;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "String", "name": "name", "syntax_pass": true}, {"attribute_expression": "public final List<Pat> patList;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "List<Pat>", "name": "patList", "syntax_pass": true}, {"attribute_expression": "public final @Nullable Type returnType;", "docstring": "", "modifiers": "public final @Nullable", "marker_annotations": ["@Nullable"], "non_marker_annotations": ["public", "final"], "comments": [], "type": "Type", "name": "returnType", "syntax_pass": true}, {"attribute_expression": "public final Exp exp;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "Exp", "name": "exp", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    FunMatch(Pos pos, String name, ImmutableList<Pat> patList,\n        @Nullable Type returnType, Exp exp) {\n      super(pos, Op.FUN_MATCH);\n      this.name = name;\n      this.patList = patList;\n      this.returnType = returnType;\n      this.exp = exp;\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "FunMatch", "params": [{"name": "pos", "type": "Pos"}, {"name": "name", "type": "String"}, {"name": "patList", "type": "ImmutableList<Pat>"}, {"name": "returnType", "type": "Type"}, {"name": "exp", "type": "Exp"}], "body": "                                            {\n      super(pos, Op.FUN_MATCH);\n      this.name = name;\n      this.patList = patList;\n      this.returnType = returnType;\n      this.exp = exp;\n    }", "signature": "FunMatch(Pos pos, String name, ImmutableList<Pat> patList,\n        @Nullable Type returnType, Exp exp)"}, {"syntax_pass": true, "original_string": "    public FunMatch accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "FunMatch", "classes": []}, "name": "accept", "params": [{"name": "shuttle", "type": "Shuttle"}], "body": "                                            {\n      return shuttle.visit(this);\n    }", "signature": "public FunMatch accept(Shuttle shuttle)"}, {"syntax_pass": true, "original_string": "    AstWriter unparse(AstWriter w, int left, int right) {\n      w.id(name);\n      for (Pat pat : patList) {\n        w.append(\" \").append(pat, Op.APPLY.left, Op.APPLY.right);\n      }\n      return w.append(\" = \").append(exp, 0, right);\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "AstWriter", "classes": []}, "name": "unparse", "params": [{"name": "w", "type": "AstWriter"}, {"name": "left", "type": "int"}, {"name": "right", "type": "int"}], "body": "                                                        {\n      w.id(name);\n      for (Pat pat : patList) {\n        w.append(\" \").append(pat, Op.APPLY.left, Op.APPLY.right);\n      }\n      return w.append(\" = \").append(exp, 0, right);\n    }", "signature": "AstWriter unparse(AstWriter w, int left, int right)"}, {"syntax_pass": true, "original_string": "    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "accept", "params": [{"name": "visitor", "type": "Visitor"}], "body": "                                                  {\n      visitor.visit(this);\n    }", "signature": "@Override public void accept(Visitor visitor)"}]}, {"original_string": "  public static class Tuple extends Exp {\n    public final List<Exp> args;\n\n    Tuple(Pos pos, Iterable<? extends Exp> args) {\n      super(pos, Op.TUPLE);\n      this.args = ImmutableList.copyOf(args);\n    }\n\n    @Override public void forEachArg(ObjIntConsumer<Exp> action) {\n      forEachIndexed(args, action);\n    }\n\n    public Exp accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }\n\n    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }\n\n    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      w.append(\"(\");\n      forEachArg((arg, i) -> w.append(i == 0 ? \"\" : \", \").append(arg, 0, 0));\n      return w.append(\")\");\n    }\n\n    public Tuple copy(List<Exp> args) {\n      return this.args.equals(args) ? this : new Tuple(pos, args);\n    }\n  }", "definition": "  public static class Tuple extends Exp", "class_docstring": " Tuple.", "name": "Tuple", "super_interfaces": [], "superclasses": "Exp", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [{"attribute_expression": "public final List<Exp> args;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "List<Exp>", "name": "args", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    Tuple(Pos pos, Iterable<? extends Exp> args) {\n      super(pos, Op.TUPLE);\n      this.args = ImmutableList.copyOf(args);\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "Tuple", "params": [{"name": "pos", "type": "Pos"}, {"name": "args", "type": "Iterable<? extends Exp>"}], "body": "                                                 {\n      super(pos, Op.TUPLE);\n      this.args = ImmutableList.copyOf(args);\n    }", "signature": "Tuple(Pos pos, Iterable<? extends Exp> args)"}, {"syntax_pass": true, "original_string": "    @Override public void forEachArg(ObjIntConsumer<Exp> action) {\n      forEachIndexed(args, action);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "forEachArg", "params": [{"name": "action", "type": "ObjIntConsumer<Exp>"}], "body": "                                                                 {\n      forEachIndexed(args, action);\n    }", "signature": "@Override public void forEachArg(ObjIntConsumer<Exp> action)"}, {"syntax_pass": true, "original_string": "    public Exp accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Exp", "classes": []}, "name": "accept", "params": [{"name": "shuttle", "type": "Shuttle"}], "body": "                                       {\n      return shuttle.visit(this);\n    }", "signature": "public Exp accept(Shuttle shuttle)"}, {"syntax_pass": true, "original_string": "    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "accept", "params": [{"name": "visitor", "type": "Visitor"}], "body": "                                                  {\n      visitor.visit(this);\n    }", "signature": "@Override public void accept(Visitor visitor)"}, {"syntax_pass": true, "original_string": "    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      w.append(\"(\");\n      forEachArg((arg, i) -> w.append(i == 0 ? \"\" : \", \").append(arg, 0, 0));\n      return w.append(\")\");\n    }", "docstring": "", "attributes": {"modifiers": "@Override", "marker_annotations": ["@Override"], "non_marker_annotations": [], "comments": [], "return_type": "AstWriter", "classes": []}, "name": "unparse", "params": [{"name": "w", "type": "AstWriter"}, {"name": "left", "type": "int"}, {"name": "right", "type": "int"}], "body": "                                                                  {\n      w.append(\"(\");\n      forEachArg((arg, i) -> w.append(i == 0 ? \"\" : \", \").append(arg, 0, 0));\n      return w.append(\")\");\n    }", "signature": "@Override AstWriter unparse(AstWriter w, int left, int right)"}, {"syntax_pass": true, "original_string": "    public Tuple copy(List<Exp> args) {\n      return this.args.equals(args) ? this : new Tuple(pos, args);\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Tuple", "classes": []}, "name": "copy", "params": [{"name": "args", "type": "List<Exp>"}], "body": "                                      {\n      return this.args.equals(args) ? this : new Tuple(pos, args);\n    }", "signature": "public Tuple copy(List<Exp> args)"}]}, {"original_string": "  public static class ListExp extends Exp {\n    public final List<Exp> args;\n\n    ListExp(Pos pos, Iterable<? extends Exp> args) {\n      super(pos, Op.LIST);\n      this.args = ImmutableList.copyOf(args);\n    }\n\n    @Override public void forEachArg(ObjIntConsumer<Exp> action) {\n      forEachIndexed(args, action);\n    }\n\n    public ListExp accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }\n\n    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }\n\n    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      w.append(\"[\");\n      forEachArg((arg, i) -> w.append(i == 0 ? \"\" : \", \").append(arg, 0, 0));\n      return w.append(\"]\");\n    }\n\n    public ListExp copy(List<Exp> args) {\n      return args.equals(this.args) ? this\n          : ast.list(pos, args);\n    }\n  }", "definition": "  public static class ListExp extends Exp", "class_docstring": " List expression.", "name": "ListExp", "super_interfaces": [], "superclasses": "Exp", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [{"attribute_expression": "public final List<Exp> args;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "List<Exp>", "name": "args", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    ListExp(Pos pos, Iterable<? extends Exp> args) {\n      super(pos, Op.LIST);\n      this.args = ImmutableList.copyOf(args);\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "ListExp", "params": [{"name": "pos", "type": "Pos"}, {"name": "args", "type": "Iterable<? extends Exp>"}], "body": "                                                   {\n      super(pos, Op.LIST);\n      this.args = ImmutableList.copyOf(args);\n    }", "signature": "ListExp(Pos pos, Iterable<? extends Exp> args)"}, {"syntax_pass": true, "original_string": "    @Override public void forEachArg(ObjIntConsumer<Exp> action) {\n      forEachIndexed(args, action);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "forEachArg", "params": [{"name": "action", "type": "ObjIntConsumer<Exp>"}], "body": "                                                                 {\n      forEachIndexed(args, action);\n    }", "signature": "@Override public void forEachArg(ObjIntConsumer<Exp> action)"}, {"syntax_pass": true, "original_string": "    public ListExp accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ListExp", "classes": []}, "name": "accept", "params": [{"name": "shuttle", "type": "Shuttle"}], "body": "                                           {\n      return shuttle.visit(this);\n    }", "signature": "public ListExp accept(Shuttle shuttle)"}, {"syntax_pass": true, "original_string": "    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "accept", "params": [{"name": "visitor", "type": "Visitor"}], "body": "                                                  {\n      visitor.visit(this);\n    }", "signature": "@Override public void accept(Visitor visitor)"}, {"syntax_pass": true, "original_string": "    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      w.append(\"[\");\n      forEachArg((arg, i) -> w.append(i == 0 ? \"\" : \", \").append(arg, 0, 0));\n      return w.append(\"]\");\n    }", "docstring": "", "attributes": {"modifiers": "@Override", "marker_annotations": ["@Override"], "non_marker_annotations": [], "comments": [], "return_type": "AstWriter", "classes": []}, "name": "unparse", "params": [{"name": "w", "type": "AstWriter"}, {"name": "left", "type": "int"}, {"name": "right", "type": "int"}], "body": "                                                                  {\n      w.append(\"[\");\n      forEachArg((arg, i) -> w.append(i == 0 ? \"\" : \", \").append(arg, 0, 0));\n      return w.append(\"]\");\n    }", "signature": "@Override AstWriter unparse(AstWriter w, int left, int right)"}, {"syntax_pass": true, "original_string": "    public ListExp copy(List<Exp> args) {\n      return args.equals(this.args) ? this\n          : ast.list(pos, args);\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ListExp", "classes": []}, "name": "copy", "params": [{"name": "args", "type": "List<Exp>"}], "body": "                                        {\n      return args.equals(this.args) ? this\n          : ast.list(pos, args);\n    }", "signature": "public ListExp copy(List<Exp> args)"}]}, {"original_string": "  public static class Record extends Exp {\n    public final SortedMap<String, Exp> args;\n\n    Record(Pos pos, ImmutableSortedMap<String, Exp> args) {\n      super(pos, Op.RECORD);\n      this.args = requireNonNull(args);\n      checkArgument(args.comparator() == ORDERING);\n    }\n\n    @Override public void forEachArg(ObjIntConsumer<Exp> action) {\n      forEachIndexed(args.values(), action);\n    }\n\n    public Exp accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }\n\n    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }\n\n    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      w.append(\"{\");\n      Ord.forEachIndexed(args, (i, k, v) -> // lint:skip\n          w.append(i > 0 ? \", \" : \"\").append(k).append(\" = \").append(v, 0, 0));\n      return w.append(\"}\");\n    }\n\n    public Record copy(Map<String, Ast.Exp> args) {\n      return args.equals(this.args) ? this : ast.record(pos, args);\n    }\n  }", "definition": "  public static class Record extends Exp", "class_docstring": " Record.", "name": "Record", "super_interfaces": [], "superclasses": "Exp", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [{"attribute_expression": "public final SortedMap<String, Exp> args;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "SortedMap<String, Exp>", "name": "args", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    Record(Pos pos, ImmutableSortedMap<String, Exp> args) {\n      super(pos, Op.RECORD);\n      this.args = requireNonNull(args);\n      checkArgument(args.comparator() == ORDERING);\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "Record", "params": [{"name": "pos", "type": "Pos"}, {"name": "args", "type": "ImmutableSortedMap<String, Exp>"}], "body": "                                                          {\n      super(pos, Op.RECORD);\n      this.args = requireNonNull(args);\n      checkArgument(args.comparator() == ORDERING);\n    }", "signature": "Record(Pos pos, ImmutableSortedMap<String, Exp> args)"}, {"syntax_pass": true, "original_string": "    @Override public void forEachArg(ObjIntConsumer<Exp> action) {\n      forEachIndexed(args.values(), action);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "forEachArg", "params": [{"name": "action", "type": "ObjIntConsumer<Exp>"}], "body": "                                                                 {\n      forEachIndexed(args.values(), action);\n    }", "signature": "@Override public void forEachArg(ObjIntConsumer<Exp> action)"}, {"syntax_pass": true, "original_string": "    public Exp accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Exp", "classes": []}, "name": "accept", "params": [{"name": "shuttle", "type": "Shuttle"}], "body": "                                       {\n      return shuttle.visit(this);\n    }", "signature": "public Exp accept(Shuttle shuttle)"}, {"syntax_pass": true, "original_string": "    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "accept", "params": [{"name": "visitor", "type": "Visitor"}], "body": "                                                  {\n      visitor.visit(this);\n    }", "signature": "@Override public void accept(Visitor visitor)"}, {"syntax_pass": true, "original_string": "    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      w.append(\"{\");\n      Ord.forEachIndexed(args, (i, k, v) -> // lint:skip\n          w.append(i > 0 ? \", \" : \"\").append(k).append(\" = \").append(v, 0, 0));\n      return w.append(\"}\");\n    }", "docstring": "", "attributes": {"modifiers": "@Override", "marker_annotations": ["@Override"], "non_marker_annotations": [], "comments": [], "return_type": "AstWriter", "classes": []}, "name": "unparse", "params": [{"name": "w", "type": "AstWriter"}, {"name": "left", "type": "int"}, {"name": "right", "type": "int"}], "body": "                                                                  {\n      w.append(\"{\");\n      Ord.forEachIndexed(args, (i, k, v) -> // lint:skip\n          w.append(i > 0 ? \", \" : \"\").append(k).append(\" = \").append(v, 0, 0));\n      return w.append(\"}\");\n    }", "signature": "@Override AstWriter unparse(AstWriter w, int left, int right)"}, {"syntax_pass": true, "original_string": "    public Record copy(Map<String, Ast.Exp> args) {\n      return args.equals(this.args) ? this : ast.record(pos, args);\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Record", "classes": []}, "name": "copy", "params": [{"name": "args", "type": "Map<String, Ast.Exp>"}], "body": "                                                  {\n      return args.equals(this.args) ? this : ast.record(pos, args);\n    }", "signature": "public Record copy(Map<String, Ast.Exp> args)"}]}, {"original_string": "  public static class InfixCall extends Exp {\n    public final Exp a0;\n    public final Exp a1;\n\n    InfixCall(Pos pos, Op op, Exp a0, Exp a1) {\n      super(pos, op);\n      this.a0 = requireNonNull(a0);\n      this.a1 = requireNonNull(a1);\n    }\n\n    @Override public void forEachArg(ObjIntConsumer<Exp> action) {\n      action.accept(a0, 0);\n      action.accept(a1, 1);\n    }\n\n    public Exp accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }\n\n    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }\n\n    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      return w.infix(left, a0, op, a1, right);\n    }\n\n    /** Creates a copy of this {@code InfixCall} with given contents,\n     * or {@code this} if the contents are the same. */\n    public InfixCall copy(Exp a0, Exp a1) {\n      return this.a0.equals(a0)\n          && this.a1.equals(a1)\n          ? this\n          : new InfixCall(pos, op, a0, a1);\n    }\n  }", "definition": "  public static class InfixCall extends Exp", "class_docstring": " Call to an infix operator.", "name": "InfixCall", "super_interfaces": [], "superclasses": "Exp", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [{"attribute_expression": "public final Exp a0;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "Exp", "name": "a0", "syntax_pass": true}, {"attribute_expression": "public final Exp a1;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "Exp", "name": "a1", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    InfixCall(Pos pos, Op op, Exp a0, Exp a1) {\n      super(pos, op);\n      this.a0 = requireNonNull(a0);\n      this.a1 = requireNonNull(a1);\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "InfixCall", "params": [{"name": "pos", "type": "Pos"}, {"name": "op", "type": "Op"}, {"name": "a0", "type": "Exp"}, {"name": "a1", "type": "Exp"}], "body": "                                              {\n      super(pos, op);\n      this.a0 = requireNonNull(a0);\n      this.a1 = requireNonNull(a1);\n    }", "signature": "InfixCall(Pos pos, Op op, Exp a0, Exp a1)"}, {"syntax_pass": true, "original_string": "    @Override public void forEachArg(ObjIntConsumer<Exp> action) {\n      action.accept(a0, 0);\n      action.accept(a1, 1);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "forEachArg", "params": [{"name": "action", "type": "ObjIntConsumer<Exp>"}], "body": "                                                                 {\n      action.accept(a0, 0);\n      action.accept(a1, 1);\n    }", "signature": "@Override public void forEachArg(ObjIntConsumer<Exp> action)"}, {"syntax_pass": true, "original_string": "    public Exp accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Exp", "classes": []}, "name": "accept", "params": [{"name": "shuttle", "type": "Shuttle"}], "body": "                                       {\n      return shuttle.visit(this);\n    }", "signature": "public Exp accept(Shuttle shuttle)"}, {"syntax_pass": true, "original_string": "    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "accept", "params": [{"name": "visitor", "type": "Visitor"}], "body": "                                                  {\n      visitor.visit(this);\n    }", "signature": "@Override public void accept(Visitor visitor)"}, {"syntax_pass": true, "original_string": "    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      return w.infix(left, a0, op, a1, right);\n    }", "docstring": "", "attributes": {"modifiers": "@Override", "marker_annotations": ["@Override"], "non_marker_annotations": [], "comments": [], "return_type": "AstWriter", "classes": []}, "name": "unparse", "params": [{"name": "w", "type": "AstWriter"}, {"name": "left", "type": "int"}, {"name": "right", "type": "int"}], "body": "                                                                  {\n      return w.infix(left, a0, op, a1, right);\n    }", "signature": "@Override AstWriter unparse(AstWriter w, int left, int right)"}, {"syntax_pass": true, "original_string": "    public InfixCall copy(Exp a0, Exp a1) {\n      return this.a0.equals(a0)\n          && this.a1.equals(a1)\n          ? this\n          : new InfixCall(pos, op, a0, a1);\n    }", "docstring": " Creates a copy of this {@code InfixCall} with given contents,\nor {@code this} if the contents are the same.", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "InfixCall", "classes": []}, "name": "copy", "params": [{"name": "a0", "type": "Exp"}, {"name": "a1", "type": "Exp"}], "body": "                                          {\n      return this.a0.equals(a0)\n          && this.a1.equals(a1)\n          ? this\n          : new InfixCall(pos, op, a0, a1);\n    }", "signature": "public InfixCall copy(Exp a0, Exp a1)"}]}, {"original_string": "  public static class PrefixCall extends Exp {\n    public final Exp a;\n\n    PrefixCall(Pos pos, Op op, Exp a) {\n      super(pos, op);\n      this.a = requireNonNull(a);\n    }\n\n    @Override public void forEachArg(ObjIntConsumer<Exp> action) {\n      action.accept(a, 0);\n    }\n\n    public Exp accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }\n\n    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }\n\n    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      return w.prefix(left, op, a, right);\n    }\n  }", "definition": "  public static class PrefixCall extends Exp", "class_docstring": " Call to a prefix operator.", "name": "PrefixCall", "super_interfaces": [], "superclasses": "Exp", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [{"attribute_expression": "public final Exp a;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "Exp", "name": "a", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    PrefixCall(Pos pos, Op op, Exp a) {\n      super(pos, op);\n      this.a = requireNonNull(a);\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "PrefixCall", "params": [{"name": "pos", "type": "Pos"}, {"name": "op", "type": "Op"}, {"name": "a", "type": "Exp"}], "body": "                                      {\n      super(pos, op);\n      this.a = requireNonNull(a);\n    }", "signature": "PrefixCall(Pos pos, Op op, Exp a)"}, {"syntax_pass": true, "original_string": "    @Override public void forEachArg(ObjIntConsumer<Exp> action) {\n      action.accept(a, 0);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "forEachArg", "params": [{"name": "action", "type": "ObjIntConsumer<Exp>"}], "body": "                                                                 {\n      action.accept(a, 0);\n    }", "signature": "@Override public void forEachArg(ObjIntConsumer<Exp> action)"}, {"syntax_pass": true, "original_string": "    public Exp accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Exp", "classes": []}, "name": "accept", "params": [{"name": "shuttle", "type": "Shuttle"}], "body": "                                       {\n      return shuttle.visit(this);\n    }", "signature": "public Exp accept(Shuttle shuttle)"}, {"syntax_pass": true, "original_string": "    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "accept", "params": [{"name": "visitor", "type": "Visitor"}], "body": "                                                  {\n      visitor.visit(this);\n    }", "signature": "@Override public void accept(Visitor visitor)"}, {"syntax_pass": true, "original_string": "    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      return w.prefix(left, op, a, right);\n    }", "docstring": "", "attributes": {"modifiers": "@Override", "marker_annotations": ["@Override"], "non_marker_annotations": [], "comments": [], "return_type": "AstWriter", "classes": []}, "name": "unparse", "params": [{"name": "w", "type": "AstWriter"}, {"name": "left", "type": "int"}, {"name": "right", "type": "int"}], "body": "                                                                  {\n      return w.prefix(left, op, a, right);\n    }", "signature": "@Override AstWriter unparse(AstWriter w, int left, int right)"}]}, {"original_string": "  public static class If extends Exp {\n    public final Exp condition;\n    public final Exp ifTrue;\n    public final Exp ifFalse;\n\n    public If(Pos pos, Exp condition, Exp ifTrue, Exp ifFalse) {\n      super(pos, Op.IF);\n      this.condition = requireNonNull(condition);\n      this.ifTrue = requireNonNull(ifTrue);\n      this.ifFalse = requireNonNull(ifFalse);\n    }\n\n    public Exp accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }\n\n    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }\n\n    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      return w.append(\"if \").append(condition, 0, 0)\n          .append(\" then \").append(ifTrue, 0, 0)\n          .append(\" else \").append(ifFalse, 0, right);\n    }\n\n    /** Creates a copy of this {@code If} with given contents,\n     * or {@code this} if the contents are the same. */\n    public If copy(Exp condition, Exp ifTrue, Exp ifFalse) {\n      return this.condition.equals(condition)\n          && this.ifTrue.equals(ifTrue)\n          && this.ifFalse.equals(ifFalse)\n          ? this\n          : new If(pos, condition, ifTrue, ifFalse);\n    }\n  }", "definition": "  public static class If extends Exp", "class_docstring": " \"If ... else\" expression.", "name": "If", "super_interfaces": [], "superclasses": "Exp", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [{"attribute_expression": "public final Exp condition;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "Exp", "name": "condition", "syntax_pass": true}, {"attribute_expression": "public final Exp ifTrue;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "Exp", "name": "ifTrue", "syntax_pass": true}, {"attribute_expression": "public final Exp ifFalse;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "Exp", "name": "ifFalse", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    public If(Pos pos, Exp condition, Exp ifTrue, Exp ifFalse) {\n      super(pos, Op.IF);\n      this.condition = requireNonNull(condition);\n      this.ifTrue = requireNonNull(ifTrue);\n      this.ifFalse = requireNonNull(ifFalse);\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "If", "params": [{"name": "pos", "type": "Pos"}, {"name": "condition", "type": "Exp"}, {"name": "ifTrue", "type": "Exp"}, {"name": "ifFalse", "type": "Exp"}], "body": "                                                               {\n      super(pos, Op.IF);\n      this.condition = requireNonNull(condition);\n      this.ifTrue = requireNonNull(ifTrue);\n      this.ifFalse = requireNonNull(ifFalse);\n    }", "signature": "public If(Pos pos, Exp condition, Exp ifTrue, Exp ifFalse)"}, {"syntax_pass": true, "original_string": "    public Exp accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Exp", "classes": []}, "name": "accept", "params": [{"name": "shuttle", "type": "Shuttle"}], "body": "                                       {\n      return shuttle.visit(this);\n    }", "signature": "public Exp accept(Shuttle shuttle)"}, {"syntax_pass": true, "original_string": "    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "accept", "params": [{"name": "visitor", "type": "Visitor"}], "body": "                                                  {\n      visitor.visit(this);\n    }", "signature": "@Override public void accept(Visitor visitor)"}, {"syntax_pass": true, "original_string": "    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      return w.append(\"if \").append(condition, 0, 0)\n          .append(\" then \").append(ifTrue, 0, 0)\n          .append(\" else \").append(ifFalse, 0, right);\n    }", "docstring": "", "attributes": {"modifiers": "@Override", "marker_annotations": ["@Override"], "non_marker_annotations": [], "comments": [], "return_type": "AstWriter", "classes": []}, "name": "unparse", "params": [{"name": "w", "type": "AstWriter"}, {"name": "left", "type": "int"}, {"name": "right", "type": "int"}], "body": "                                                                  {\n      return w.append(\"if \").append(condition, 0, 0)\n          .append(\" then \").append(ifTrue, 0, 0)\n          .append(\" else \").append(ifFalse, 0, right);\n    }", "signature": "@Override AstWriter unparse(AstWriter w, int left, int right)"}, {"syntax_pass": true, "original_string": "    public If copy(Exp condition, Exp ifTrue, Exp ifFalse) {\n      return this.condition.equals(condition)\n          && this.ifTrue.equals(ifTrue)\n          && this.ifFalse.equals(ifFalse)\n          ? this\n          : new If(pos, condition, ifTrue, ifFalse);\n    }", "docstring": " Creates a copy of this {@code If} with given contents,\nor {@code this} if the contents are the same.", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "If", "classes": []}, "name": "copy", "params": [{"name": "condition", "type": "Exp"}, {"name": "ifTrue", "type": "Exp"}, {"name": "ifFalse", "type": "Exp"}], "body": "                                                           {\n      return this.condition.equals(condition)\n          && this.ifTrue.equals(ifTrue)\n          && this.ifFalse.equals(ifFalse)\n          ? this\n          : new If(pos, condition, ifTrue, ifFalse);\n    }", "signature": "public If copy(Exp condition, Exp ifTrue, Exp ifFalse)"}]}, {"original_string": "  public static class Let extends Exp {\n    public final List<Decl> decls;\n    public final Exp exp;\n\n    Let(Pos pos, ImmutableList<Decl> decls, Exp exp) {\n      super(pos, Op.LET);\n      this.decls = requireNonNull(decls);\n      this.exp = requireNonNull(exp);\n    }\n\n    public Exp accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }\n\n    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }\n\n    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      return w.appendAll(decls, \"let \", \"; \", \" in \")\n          .append(exp, 0, 0).append(\" end\");\n    }\n\n    /** Creates a copy of this {@code LetExp} with given contents,\n     * or {@code this} if the contents are the same. */\n    public Let copy(Iterable<Decl> decls, Exp exp) {\n      return Iterables.elementsEqual(this.decls, decls)\n          && Objects.equals(this.exp, exp)\n          ? this\n          : ast.let(pos, decls, exp);\n    }\n  }", "definition": "  public static class Let extends Exp", "class_docstring": " \"Let\" expression.", "name": "Let", "super_interfaces": [], "superclasses": "Exp", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [{"attribute_expression": "public final List<Decl> decls;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "List<Decl>", "name": "decls", "syntax_pass": true}, {"attribute_expression": "public final Exp exp;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "Exp", "name": "exp", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    Let(Pos pos, ImmutableList<Decl> decls, Exp exp) {\n      super(pos, Op.LET);\n      this.decls = requireNonNull(decls);\n      this.exp = requireNonNull(exp);\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "Let", "params": [{"name": "pos", "type": "Pos"}, {"name": "decls", "type": "ImmutableList<Decl>"}, {"name": "exp", "type": "Exp"}], "body": "                                                     {\n      super(pos, Op.LET);\n      this.decls = requireNonNull(decls);\n      this.exp = requireNonNull(exp);\n    }", "signature": "Let(Pos pos, ImmutableList<Decl> decls, Exp exp)"}, {"syntax_pass": true, "original_string": "    public Exp accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Exp", "classes": []}, "name": "accept", "params": [{"name": "shuttle", "type": "Shuttle"}], "body": "                                       {\n      return shuttle.visit(this);\n    }", "signature": "public Exp accept(Shuttle shuttle)"}, {"syntax_pass": true, "original_string": "    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "accept", "params": [{"name": "visitor", "type": "Visitor"}], "body": "                                                  {\n      visitor.visit(this);\n    }", "signature": "@Override public void accept(Visitor visitor)"}, {"syntax_pass": true, "original_string": "    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      return w.appendAll(decls, \"let \", \"; \", \" in \")\n          .append(exp, 0, 0).append(\" end\");\n    }", "docstring": "", "attributes": {"modifiers": "@Override", "marker_annotations": ["@Override"], "non_marker_annotations": [], "comments": [], "return_type": "AstWriter", "classes": []}, "name": "unparse", "params": [{"name": "w", "type": "AstWriter"}, {"name": "left", "type": "int"}, {"name": "right", "type": "int"}], "body": "                                                                  {\n      return w.appendAll(decls, \"let \", \"; \", \" in \")\n          .append(exp, 0, 0).append(\" end\");\n    }", "signature": "@Override AstWriter unparse(AstWriter w, int left, int right)"}, {"syntax_pass": true, "original_string": "    public Let copy(Iterable<Decl> decls, Exp exp) {\n      return Iterables.elementsEqual(this.decls, decls)\n          && Objects.equals(this.exp, exp)\n          ? this\n          : ast.let(pos, decls, exp);\n    }", "docstring": " Creates a copy of this {@code LetExp} with given contents,\nor {@code this} if the contents are the same.", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Let", "classes": []}, "name": "copy", "params": [{"name": "decls", "type": "Iterable<Decl>"}, {"name": "exp", "type": "Exp"}], "body": "                                                   {\n      return Iterables.elementsEqual(this.decls, decls)\n          && Objects.equals(this.exp, exp)\n          ? this\n          : ast.let(pos, decls, exp);\n    }", "signature": "public Let copy(Iterable<Decl> decls, Exp exp)"}]}, {"original_string": "  public static class ValBind extends AstNode {\n    public final Pat pat;\n    public final Exp exp;\n\n    ValBind(Pos pos, Pat pat, Exp exp) {\n      super(pos, Op.VAL_BIND);\n      this.pat = pat;\n      this.exp = exp;\n    }\n\n    public AstNode accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }\n\n    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }\n\n    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      return w.append(pat, 0, 0).append(\" = \").append(exp, 0, right);\n    }\n\n    /** Creates a copy of this {@code ValBind} with given contents,\n     * or {@code this} if the contents are the same. */\n    public ValBind copy(Pat pat, Exp exp) {\n      return this.pat.equals(pat)\n          && this.exp.equals(exp)\n          ? this\n          : ast.valBind(pos, pat, exp);\n    }\n  }", "definition": "  public static class ValBind extends AstNode", "class_docstring": " Value bind.", "name": "ValBind", "super_interfaces": [], "superclasses": "AstNode", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [{"attribute_expression": "public final Pat pat;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "Pat", "name": "pat", "syntax_pass": true}, {"attribute_expression": "public final Exp exp;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "Exp", "name": "exp", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    ValBind(Pos pos, Pat pat, Exp exp) {\n      super(pos, Op.VAL_BIND);\n      this.pat = pat;\n      this.exp = exp;\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "ValBind", "params": [{"name": "pos", "type": "Pos"}, {"name": "pat", "type": "Pat"}, {"name": "exp", "type": "Exp"}], "body": "                                       {\n      super(pos, Op.VAL_BIND);\n      this.pat = pat;\n      this.exp = exp;\n    }", "signature": "ValBind(Pos pos, Pat pat, Exp exp)"}, {"syntax_pass": true, "original_string": "    public AstNode accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "AstNode", "classes": []}, "name": "accept", "params": [{"name": "shuttle", "type": "Shuttle"}], "body": "                                           {\n      return shuttle.visit(this);\n    }", "signature": "public AstNode accept(Shuttle shuttle)"}, {"syntax_pass": true, "original_string": "    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "accept", "params": [{"name": "visitor", "type": "Visitor"}], "body": "                                                  {\n      visitor.visit(this);\n    }", "signature": "@Override public void accept(Visitor visitor)"}, {"syntax_pass": true, "original_string": "    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      return w.append(pat, 0, 0).append(\" = \").append(exp, 0, right);\n    }", "docstring": "", "attributes": {"modifiers": "@Override", "marker_annotations": ["@Override"], "non_marker_annotations": [], "comments": [], "return_type": "AstWriter", "classes": []}, "name": "unparse", "params": [{"name": "w", "type": "AstWriter"}, {"name": "left", "type": "int"}, {"name": "right", "type": "int"}], "body": "                                                                  {\n      return w.append(pat, 0, 0).append(\" = \").append(exp, 0, right);\n    }", "signature": "@Override AstWriter unparse(AstWriter w, int left, int right)"}, {"syntax_pass": true, "original_string": "    public ValBind copy(Pat pat, Exp exp) {\n      return this.pat.equals(pat)\n          && this.exp.equals(exp)\n          ? this\n          : ast.valBind(pos, pat, exp);\n    }", "docstring": " Creates a copy of this {@code ValBind} with given contents,\nor {@code this} if the contents are the same.", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ValBind", "classes": []}, "name": "copy", "params": [{"name": "pat", "type": "Pat"}, {"name": "exp", "type": "Exp"}], "body": "                                          {\n      return this.pat.equals(pat)\n          && this.exp.equals(exp)\n          ? this\n          : ast.valBind(pos, pat, exp);\n    }", "signature": "public ValBind copy(Pat pat, Exp exp)"}]}, {"original_string": "  public static class Match extends AstNode {\n    public final Pat pat;\n    public final Exp exp;\n\n    Match(Pos pos, Pat pat, Exp exp) {\n      super(pos, Op.MATCH);\n      this.pat = pat;\n      this.exp = exp;\n    }\n\n    public Match accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }\n\n    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }\n\n    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      return w.append(pat, 0, 0).append(\" => \").append(exp, 0, right);\n    }\n\n    /** Creates a copy of this {@code Match} with given contents,\n     * or {@code this} if the contents are the same. */\n    public Match copy(Pat pat, Exp exp) {\n      return this.pat.equals(pat)\n          && this.exp.equals(exp)\n          ? this\n          : ast.match(pos, pat, exp);\n    }\n  }", "definition": "  public static class Match extends AstNode", "class_docstring": " Match.", "name": "Match", "super_interfaces": [], "superclasses": "AstNode", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [{"attribute_expression": "public final Pat pat;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "Pat", "name": "pat", "syntax_pass": true}, {"attribute_expression": "public final Exp exp;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "Exp", "name": "exp", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    Match(Pos pos, Pat pat, Exp exp) {\n      super(pos, Op.MATCH);\n      this.pat = pat;\n      this.exp = exp;\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "Match", "params": [{"name": "pos", "type": "Pos"}, {"name": "pat", "type": "Pat"}, {"name": "exp", "type": "Exp"}], "body": "                                     {\n      super(pos, Op.MATCH);\n      this.pat = pat;\n      this.exp = exp;\n    }", "signature": "Match(Pos pos, Pat pat, Exp exp)"}, {"syntax_pass": true, "original_string": "    public Match accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Match", "classes": []}, "name": "accept", "params": [{"name": "shuttle", "type": "Shuttle"}], "body": "                                         {\n      return shuttle.visit(this);\n    }", "signature": "public Match accept(Shuttle shuttle)"}, {"syntax_pass": true, "original_string": "    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "accept", "params": [{"name": "visitor", "type": "Visitor"}], "body": "                                                  {\n      visitor.visit(this);\n    }", "signature": "@Override public void accept(Visitor visitor)"}, {"syntax_pass": true, "original_string": "    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      return w.append(pat, 0, 0).append(\" => \").append(exp, 0, right);\n    }", "docstring": "", "attributes": {"modifiers": "@Override", "marker_annotations": ["@Override"], "non_marker_annotations": [], "comments": [], "return_type": "AstWriter", "classes": []}, "name": "unparse", "params": [{"name": "w", "type": "AstWriter"}, {"name": "left", "type": "int"}, {"name": "right", "type": "int"}], "body": "                                                                  {\n      return w.append(pat, 0, 0).append(\" => \").append(exp, 0, right);\n    }", "signature": "@Override AstWriter unparse(AstWriter w, int left, int right)"}, {"syntax_pass": true, "original_string": "    public Match copy(Pat pat, Exp exp) {\n      return this.pat.equals(pat)\n          && this.exp.equals(exp)\n          ? this\n          : ast.match(pos, pat, exp);\n    }", "docstring": " Creates a copy of this {@code Match} with given contents,\nor {@code this} if the contents are the same.", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Match", "classes": []}, "name": "copy", "params": [{"name": "pat", "type": "Pat"}, {"name": "exp", "type": "Exp"}], "body": "                                        {\n      return this.pat.equals(pat)\n          && this.exp.equals(exp)\n          ? this\n          : ast.match(pos, pat, exp);\n    }", "signature": "public Match copy(Pat pat, Exp exp)"}]}, {"original_string": "  public static class Fn extends Exp {\n    public final List<Match> matchList;\n\n    Fn(Pos pos, ImmutableList<Match> matchList) {\n      super(pos, Op.FN);\n      this.matchList = requireNonNull(matchList);\n      checkArgument(!matchList.isEmpty());\n    }\n\n    public Fn accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }\n\n    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }\n\n    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      return w.append(\"fn \").appendAll(matchList, 0, Op.BAR, right);\n    }\n\n    /** Creates a copy of this {@code Fn} with given contents,\n     * or this if the contents are the same. */\n    public Fn copy(List<Match> matchList) {\n      return this.matchList.equals(matchList)\n          ? this\n          : ast.fn(pos, matchList);\n    }\n  }", "definition": "  public static class Fn extends Exp", "class_docstring": " Lambda expression.", "name": "Fn", "super_interfaces": [], "superclasses": "Exp", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [{"attribute_expression": "public final List<Match> matchList;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "List<Match>", "name": "matchList", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    Fn(Pos pos, ImmutableList<Match> matchList) {\n      super(pos, Op.FN);\n      this.matchList = requireNonNull(matchList);\n      checkArgument(!matchList.isEmpty());\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "Fn", "params": [{"name": "pos", "type": "Pos"}, {"name": "matchList", "type": "ImmutableList<Match>"}], "body": "                                                {\n      super(pos, Op.FN);\n      this.matchList = requireNonNull(matchList);\n      checkArgument(!matchList.isEmpty());\n    }", "signature": "Fn(Pos pos, ImmutableList<Match> matchList)"}, {"syntax_pass": true, "original_string": "    public Fn accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Fn", "classes": []}, "name": "accept", "params": [{"name": "shuttle", "type": "Shuttle"}], "body": "                                      {\n      return shuttle.visit(this);\n    }", "signature": "public Fn accept(Shuttle shuttle)"}, {"syntax_pass": true, "original_string": "    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "accept", "params": [{"name": "visitor", "type": "Visitor"}], "body": "                                                  {\n      visitor.visit(this);\n    }", "signature": "@Override public void accept(Visitor visitor)"}, {"syntax_pass": true, "original_string": "    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      return w.append(\"fn \").appendAll(matchList, 0, Op.BAR, right);\n    }", "docstring": "", "attributes": {"modifiers": "@Override", "marker_annotations": ["@Override"], "non_marker_annotations": [], "comments": [], "return_type": "AstWriter", "classes": []}, "name": "unparse", "params": [{"name": "w", "type": "AstWriter"}, {"name": "left", "type": "int"}, {"name": "right", "type": "int"}], "body": "                                                                  {\n      return w.append(\"fn \").appendAll(matchList, 0, Op.BAR, right);\n    }", "signature": "@Override AstWriter unparse(AstWriter w, int left, int right)"}, {"syntax_pass": true, "original_string": "    public Fn copy(List<Match> matchList) {\n      return this.matchList.equals(matchList)\n          ? this\n          : ast.fn(pos, matchList);\n    }", "docstring": " Creates a copy of this {@code Fn} with given contents,\nor this if the contents are the same.", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Fn", "classes": []}, "name": "copy", "params": [{"name": "matchList", "type": "List<Match>"}], "body": "                                          {\n      return this.matchList.equals(matchList)\n          ? this\n          : ast.fn(pos, matchList);\n    }", "signature": "public Fn copy(List<Match> matchList)"}]}, {"original_string": "  public static class Case extends Exp {\n    public final Exp exp;\n    public final List<Match> matchList;\n\n    Case(Pos pos, Exp exp, ImmutableList<Match> matchList) {\n      super(pos, Op.CASE);\n      this.exp = exp;\n      this.matchList = matchList;\n    }\n\n    public Exp accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }\n\n    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }\n\n    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      return w.append(\"case \").append(exp, 0, 0).append(\" of \")\n          .appendAll(matchList, left, Op.BAR, right);\n    }\n\n    public Case copy(Exp exp, List<Match> matchList) {\n      return this.exp.equals(exp)\n          && this.matchList.equals(matchList)\n          ? this\n          : ast.caseOf(pos, exp, matchList);\n    }\n  }", "definition": "  public static class Case extends Exp", "class_docstring": " Case expression.", "name": "Case", "super_interfaces": [], "superclasses": "Exp", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [{"attribute_expression": "public final Exp exp;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "Exp", "name": "exp", "syntax_pass": true}, {"attribute_expression": "public final List<Match> matchList;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "List<Match>", "name": "matchList", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    Case(Pos pos, Exp exp, ImmutableList<Match> matchList) {\n      super(pos, Op.CASE);\n      this.exp = exp;\n      this.matchList = matchList;\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "Case", "params": [{"name": "pos", "type": "Pos"}, {"name": "exp", "type": "Exp"}, {"name": "matchList", "type": "ImmutableList<Match>"}], "body": "                                                           {\n      super(pos, Op.CASE);\n      this.exp = exp;\n      this.matchList = matchList;\n    }", "signature": "Case(Pos pos, Exp exp, ImmutableList<Match> matchList)"}, {"syntax_pass": true, "original_string": "    public Exp accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Exp", "classes": []}, "name": "accept", "params": [{"name": "shuttle", "type": "Shuttle"}], "body": "                                       {\n      return shuttle.visit(this);\n    }", "signature": "public Exp accept(Shuttle shuttle)"}, {"syntax_pass": true, "original_string": "    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "accept", "params": [{"name": "visitor", "type": "Visitor"}], "body": "                                                  {\n      visitor.visit(this);\n    }", "signature": "@Override public void accept(Visitor visitor)"}, {"syntax_pass": true, "original_string": "    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      return w.append(\"case \").append(exp, 0, 0).append(\" of \")\n          .appendAll(matchList, left, Op.BAR, right);\n    }", "docstring": "", "attributes": {"modifiers": "@Override", "marker_annotations": ["@Override"], "non_marker_annotations": [], "comments": [], "return_type": "AstWriter", "classes": []}, "name": "unparse", "params": [{"name": "w", "type": "AstWriter"}, {"name": "left", "type": "int"}, {"name": "right", "type": "int"}], "body": "                                                                  {\n      return w.append(\"case \").append(exp, 0, 0).append(\" of \")\n          .appendAll(matchList, left, Op.BAR, right);\n    }", "signature": "@Override AstWriter unparse(AstWriter w, int left, int right)"}, {"syntax_pass": true, "original_string": "    public Case copy(Exp exp, List<Match> matchList) {\n      return this.exp.equals(exp)\n          && this.matchList.equals(matchList)\n          ? this\n          : ast.caseOf(pos, exp, matchList);\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Case", "classes": []}, "name": "copy", "params": [{"name": "exp", "type": "Exp"}, {"name": "matchList", "type": "List<Match>"}], "body": "                                                     {\n      return this.exp.equals(exp)\n          && this.matchList.equals(matchList)\n          ? this\n          : ast.caseOf(pos, exp, matchList);\n    }", "signature": "public Case copy(Exp exp, List<Match> matchList)"}]}, {"original_string": "  public static class From extends Exp {\n    public final ImmutableList<FromStep> steps;\n    /** An implicit yield expression, if the last step is not a {@link Yield};\n     * null if the last step is a {@link Yield}. */\n    public final @Nullable Exp implicitYieldExp;\n\n    From(Pos pos, ImmutableList<FromStep> steps,\n        @Nullable Exp implicitYieldExp) {\n      super(pos, Op.FROM);\n      this.steps = requireNonNull(steps);\n      this.implicitYieldExp = implicitYieldExp;\n    }\n\n    static @Nullable Exp implicitYieldExp(Pos pos, List<FromStep> steps) {\n      if (!steps.isEmpty()) {\n        final FromStep lastStep = getLast(steps);\n        if (lastStep.op == Op.YIELD\n            || lastStep.op == Op.INTO) {\n          // No implicit yield is needed; the last step is an explicit yield\n          return null;\n        }\n      }\n      Set<Id> fields = ImmutableSet.of();\n      final Set<Id> nextFields = new HashSet<>();\n      for (FromStep step : steps) {\n        switch (step.op) {\n        case SCAN:\n          final Scan scan = (Scan) step;\n          nextFields.clear();\n          nextFields.addAll(fields);\n          scan.pat.visit(p -> {\n            if (p instanceof IdPat) {\n              nextFields.add(ast.id(Pos.ZERO, ((IdPat) p).name));\n            }\n          });\n          fields = ImmutableSet.copyOf(nextFields);\n          break;\n\n        case THROUGH:\n          final Through through = (Through) step;\n          nextFields.clear();\n          through.pat.visit(p -> {\n            if (p instanceof IdPat) {\n              nextFields.add(ast.id(Pos.ZERO, ((IdPat) p).name));\n            }\n          });\n          fields = ImmutableSet.copyOf(nextFields);\n          break;\n\n        case COMPUTE:\n        case GROUP:\n          final Group group = (Group) step;\n          final ImmutablePairList<Id, Exp> groupExps = group.groupExps;\n          final List<Aggregate> aggregates = group.aggregates;\n\n          // The type of\n          //   from e in emps group a = e1, b = e2 compute c = sum of e3\n          // is the same as the type of\n          //   {a = e1, b = e2, c = sum (map (fn e => e3) [])}\n          nextFields.clear();\n          nextFields.addAll(Pair.left(groupExps));\n          groupExps.forEach((id, exp) -> nextFields.add(id));\n          aggregates.forEach(aggregate -> nextFields.add(aggregate.id));\n          fields = nextFields;\n          break;\n\n        case YIELD:\n          final Yield yield = (Yield) step;\n          if (yield.exp instanceof Record) {\n            fields =\n                ((Record) yield.exp).args.keySet()\n                    .stream()\n                    .map(label -> ast.id(Pos.ZERO, label))\n                    .collect(Collectors.toSet());\n          }\n          break;\n        }\n      }\n\n      if (fields.size() == 1\n          && (steps.isEmpty()\n          || getLast(steps).op != Op.YIELD\n          || ((Yield) getLast(steps)).exp.op != Op.RECORD)) {\n        return Iterables.getOnlyElement(fields);\n      } else {\n        final SortedMap<String, Ast.Exp> map = mutableMap();\n        fields.forEach(field -> map.put(field.name, field));\n        return ast.record(pos, map);\n      }\n    }\n\n    public Exp accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }\n\n    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }\n\n    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      if (left > op.left || op.right < right) {\n        return w.append(\"(\").append(this, 0, 0).append(\")\");\n      } else {\n        w.append(\"from\");\n        forEachIndexed(steps, (step, i) -> {\n          if (step.op == Op.SCAN && i > 0) {\n            if (steps.get(i - 1).op == Op.SCAN) {\n              w.append(\",\");\n            } else {\n              w.append(\" join\");\n            }\n          }\n          step.unparse(w, 0, 0);\n        });\n        return w;\n      }\n    }\n\n    /** Creates a copy of this {@code From} with given contents,\n     * or {@code this} if the contents are the same. */\n    public From copy(List<FromStep> steps, @Nullable Exp implicitYieldExp) {\n      return this.steps.equals(steps)\n          ? this\n          : ast.from(pos, steps, implicitYieldExp);\n    }\n\n    /** Returns whether this {@code from} expression ends with a {@code compute}\n     * step. If so, it is a <em>monoid</em> comprehension, not a <em>monad</em>\n     * comprehension, and its type is a scalar value (or record), not a list. */\n    public boolean isCompute() {\n      return !steps.isEmpty()\n          && steps.get(steps.size() - 1).op == Op.COMPUTE;\n    }\n\n    /** Returns whether this {@code from} expression ends with as {@code into}\n     * step. If so, its type is a scalar value (or record), not a list. */\n    public boolean isInto() {\n      return !steps.isEmpty()\n          && steps.get(steps.size() - 1).op == Op.INTO;\n    }\n  }", "definition": "  public static class From extends Exp", "class_docstring": " From expression.", "name": "From", "super_interfaces": [], "superclasses": "Exp", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [{"attribute_expression": "public final ImmutableList<FromStep> steps;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "ImmutableList<FromStep>", "name": "steps", "syntax_pass": true}, {"attribute_expression": "public final @Nullable Exp implicitYieldExp;", "docstring": " An implicit yield expression, if the last step is not a {@link Yield};\nnull if the last step is a {@link Yield}.", "modifiers": "public final @Nullable", "marker_annotations": ["@Nullable"], "non_marker_annotations": ["public", "final"], "comments": [], "type": "Exp", "name": "implicitYieldExp", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    From(Pos pos, ImmutableList<FromStep> steps,\n        @Nullable Exp implicitYieldExp) {\n      super(pos, Op.FROM);\n      this.steps = requireNonNull(steps);\n      this.implicitYieldExp = implicitYieldExp;\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "From", "params": [{"name": "pos", "type": "Pos"}, {"name": "steps", "type": "ImmutableList<FromStep>"}, {"name": "implicitYieldExp", "type": "Exp"}], "body": "                                        {\n      super(pos, Op.FROM);\n      this.steps = requireNonNull(steps);\n      this.implicitYieldExp = implicitYieldExp;\n    }", "signature": "From(Pos pos, ImmutableList<FromStep> steps,\n        @Nullable Exp implicitYieldExp)"}, {"syntax_pass": true, "original_string": "    static @Nullable Exp implicitYieldExp(Pos pos, List<FromStep> steps) {\n      if (!steps.isEmpty()) {\n        final FromStep lastStep = getLast(steps);\n        if (lastStep.op == Op.YIELD\n            || lastStep.op == Op.INTO) {\n          // No implicit yield is needed; the last step is an explicit yield\n          return null;\n        }\n      }\n      Set<Id> fields = ImmutableSet.of();\n      final Set<Id> nextFields = new HashSet<>();\n      for (FromStep step : steps) {\n        switch (step.op) {\n        case SCAN:\n          final Scan scan = (Scan) step;\n          nextFields.clear();\n          nextFields.addAll(fields);\n          scan.pat.visit(p -> {\n            if (p instanceof IdPat) {\n              nextFields.add(ast.id(Pos.ZERO, ((IdPat) p).name));\n            }\n          });\n          fields = ImmutableSet.copyOf(nextFields);\n          break;\n\n        case THROUGH:\n          final Through through = (Through) step;\n          nextFields.clear();\n          through.pat.visit(p -> {\n            if (p instanceof IdPat) {\n              nextFields.add(ast.id(Pos.ZERO, ((IdPat) p).name));\n            }\n          });\n          fields = ImmutableSet.copyOf(nextFields);\n          break;\n\n        case COMPUTE:\n        case GROUP:\n          final Group group = (Group) step;\n          final ImmutablePairList<Id, Exp> groupExps = group.groupExps;\n          final List<Aggregate> aggregates = group.aggregates;\n\n          // The type of\n          //   from e in emps group a = e1, b = e2 compute c = sum of e3\n          // is the same as the type of\n          //   {a = e1, b = e2, c = sum (map (fn e => e3) [])}\n          nextFields.clear();\n          nextFields.addAll(Pair.left(groupExps));\n          groupExps.forEach((id, exp) -> nextFields.add(id));\n          aggregates.forEach(aggregate -> nextFields.add(aggregate.id));\n          fields = nextFields;\n          break;\n\n        case YIELD:\n          final Yield yield = (Yield) step;\n          if (yield.exp instanceof Record) {\n            fields =\n                ((Record) yield.exp).args.keySet()\n                    .stream()\n                    .map(label -> ast.id(Pos.ZERO, label))\n                    .collect(Collectors.toSet());\n          }\n          break;\n        }\n      }\n\n      if (fields.size() == 1\n          && (steps.isEmpty()\n          || getLast(steps).op != Op.YIELD\n          || ((Yield) getLast(steps)).exp.op != Op.RECORD)) {\n        return Iterables.getOnlyElement(fields);\n      } else {\n        final SortedMap<String, Ast.Exp> map = mutableMap();\n        fields.forEach(field -> map.put(field.name, field));\n        return ast.record(pos, map);\n      }\n    }", "docstring": "", "attributes": {"modifiers": "static @Nullable", "marker_annotations": ["@Nullable"], "non_marker_annotations": ["static"], "comments": [], "return_type": "Exp", "classes": []}, "name": "implicitYieldExp", "params": [{"name": "pos", "type": "Pos"}, {"name": "steps", "type": "List<FromStep>"}], "body": "                                                                         {\n      if (!steps.isEmpty()) {\n        final FromStep lastStep = getLast(steps);\n        if (lastStep.op == Op.YIELD\n            || lastStep.op == Op.INTO) {\n          // No implicit yield is needed; the last step is an explicit yield\n          return null;\n        }\n      }\n      Set<Id> fields = ImmutableSet.of();\n      final Set<Id> nextFields = new HashSet<>();\n      for (FromStep step : steps) {\n        switch (step.op) {\n        case SCAN:\n          final Scan scan = (Scan) step;\n          nextFields.clear();\n          nextFields.addAll(fields);\n          scan.pat.visit(p -> {\n            if (p instanceof IdPat) {\n              nextFields.add(ast.id(Pos.ZERO, ((IdPat) p).name));\n            }\n          });\n          fields = ImmutableSet.copyOf(nextFields);\n          break;\n\n        case THROUGH:\n          final Through through = (Through) step;\n          nextFields.clear();\n          through.pat.visit(p -> {\n            if (p instanceof IdPat) {\n              nextFields.add(ast.id(Pos.ZERO, ((IdPat) p).name));\n            }\n          });\n          fields = ImmutableSet.copyOf(nextFields);\n          break;\n\n        case COMPUTE:\n        case GROUP:\n          final Group group = (Group) step;\n          final ImmutablePairList<Id, Exp> groupExps = group.groupExps;\n          final List<Aggregate> aggregates = group.aggregates;\n\n          // The type of\n          //   from e in emps group a = e1, b = e2 compute c = sum of e3\n          // is the same as the type of\n          //   {a = e1, b = e2, c = sum (map (fn e => e3) [])}\n          nextFields.clear();\n          nextFields.addAll(Pair.left(groupExps));\n          groupExps.forEach((id, exp) -> nextFields.add(id));\n          aggregates.forEach(aggregate -> nextFields.add(aggregate.id));\n          fields = nextFields;\n          break;\n\n        case YIELD:\n          final Yield yield = (Yield) step;\n          if (yield.exp instanceof Record) {\n            fields =\n                ((Record) yield.exp).args.keySet()\n                    .stream()\n                    .map(label -> ast.id(Pos.ZERO, label))\n                    .collect(Collectors.toSet());\n          }\n          break;\n        }\n      }\n\n      if (fields.size() == 1\n          && (steps.isEmpty()\n          || getLast(steps).op != Op.YIELD\n          || ((Yield) getLast(steps)).exp.op != Op.RECORD)) {\n        return Iterables.getOnlyElement(fields);\n      } else {\n        final SortedMap<String, Ast.Exp> map = mutableMap();\n        fields.forEach(field -> map.put(field.name, field));\n        return ast.record(pos, map);\n      }\n    }", "signature": "static @Nullable Exp implicitYieldExp(Pos pos, List<FromStep> steps)"}, {"syntax_pass": true, "original_string": "    public Exp accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Exp", "classes": []}, "name": "accept", "params": [{"name": "shuttle", "type": "Shuttle"}], "body": "                                       {\n      return shuttle.visit(this);\n    }", "signature": "public Exp accept(Shuttle shuttle)"}, {"syntax_pass": true, "original_string": "    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "accept", "params": [{"name": "visitor", "type": "Visitor"}], "body": "                                                  {\n      visitor.visit(this);\n    }", "signature": "@Override public void accept(Visitor visitor)"}, {"syntax_pass": true, "original_string": "    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      if (left > op.left || op.right < right) {\n        return w.append(\"(\").append(this, 0, 0).append(\")\");\n      } else {\n        w.append(\"from\");\n        forEachIndexed(steps, (step, i) -> {\n          if (step.op == Op.SCAN && i > 0) {\n            if (steps.get(i - 1).op == Op.SCAN) {\n              w.append(\",\");\n            } else {\n              w.append(\" join\");\n            }\n          }\n          step.unparse(w, 0, 0);\n        });\n        return w;\n      }\n    }", "docstring": "", "attributes": {"modifiers": "@Override", "marker_annotations": ["@Override"], "non_marker_annotations": [], "comments": [], "return_type": "AstWriter", "classes": []}, "name": "unparse", "params": [{"name": "w", "type": "AstWriter"}, {"name": "left", "type": "int"}, {"name": "right", "type": "int"}], "body": "                                                                  {\n      if (left > op.left || op.right < right) {\n        return w.append(\"(\").append(this, 0, 0).append(\")\");\n      } else {\n        w.append(\"from\");\n        forEachIndexed(steps, (step, i) -> {\n          if (step.op == Op.SCAN && i > 0) {\n            if (steps.get(i - 1).op == Op.SCAN) {\n              w.append(\",\");\n            } else {\n              w.append(\" join\");\n            }\n          }\n          step.unparse(w, 0, 0);\n        });\n        return w;\n      }\n    }", "signature": "@Override AstWriter unparse(AstWriter w, int left, int right)"}, {"syntax_pass": true, "original_string": "    public From copy(List<FromStep> steps, @Nullable Exp implicitYieldExp) {\n      return this.steps.equals(steps)\n          ? this\n          : ast.from(pos, steps, implicitYieldExp);\n    }", "docstring": " Creates a copy of this {@code From} with given contents,\nor {@code this} if the contents are the same.", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "From", "classes": []}, "name": "copy", "params": [{"name": "steps", "type": "List<FromStep>"}, {"name": "implicitYieldExp", "type": "Exp"}], "body": "                                                                           {\n      return this.steps.equals(steps)\n          ? this\n          : ast.from(pos, steps, implicitYieldExp);\n    }", "signature": "public From copy(List<FromStep> steps, @Nullable Exp implicitYieldExp)"}, {"syntax_pass": true, "original_string": "    public boolean isCompute() {\n      return !steps.isEmpty()\n          && steps.get(steps.size() - 1).op == Op.COMPUTE;\n    }", "docstring": " Returns whether this {@code from} expression ends with a {@code compute}\nstep. If so, it is a <em>monoid</em> comprehension, not a <em>monad</em>\ncomprehension, and its type is a scalar value (or record), not a list.", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isCompute", "params": [], "body": "                               {\n      return !steps.isEmpty()\n          && steps.get(steps.size() - 1).op == Op.COMPUTE;\n    }", "signature": "public boolean isCompute()"}, {"syntax_pass": true, "original_string": "    public boolean isInto() {\n      return !steps.isEmpty()\n          && steps.get(steps.size() - 1).op == Op.INTO;\n    }", "docstring": " Returns whether this {@code from} expression ends with as {@code into}\nstep. If so, its type is a scalar value (or record), not a list.", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isInto", "params": [], "body": "                            {\n      return !steps.isEmpty()\n          && steps.get(steps.size() - 1).op == Op.INTO;\n    }", "signature": "public boolean isInto()"}]}, {"original_string": "  public abstract static class FromStep extends AstNode {\n    FromStep(Pos pos, Op op) {\n      super(pos, op);\n    }\n  }", "definition": "  public abstract static class FromStep extends AstNode", "class_docstring": " A step in a {@code from} expression - {@code where}, {@code group}\nor {@code order}.", "name": "FromStep", "super_interfaces": [], "superclasses": "AstNode", "attributes": {"modifiers": "public abstract static", "marker_annotations": [], "non_marker_annotations": ["public", "abstract", "static"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    FromStep(Pos pos, Op op) {\n      super(pos, op);\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "FromStep", "params": [{"name": "pos", "type": "Pos"}, {"name": "op", "type": "Op"}], "body": "                             {\n      super(pos, op);\n    }", "signature": "FromStep(Pos pos, Op op)"}]}, {"original_string": "  public static class Scan extends FromStep {\n    public final Pat pat;\n    public final @Nullable Exp exp;\n    public final @Nullable Exp condition;\n\n    Scan(Pos pos, Pat pat, @Nullable Exp exp, @Nullable Exp condition) {\n      super(pos, Op.SCAN);\n      this.pat = pat;\n      this.exp = exp;\n      this.condition = condition;\n    }\n\n    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      w.append(op.padded)\n          .append(pat, 0, 0);\n      if (exp != null) {\n        if (exp.op == Op.FROM_EQ) {\n          w.append(\" = \")\n              .append(((PrefixCall) this.exp).a, Op.EQ.right, 0);\n        } else {\n          w.append(\" in \")\n              .append(this.exp, Op.EQ.right, 0);\n        }\n      }\n      if (condition != null) {\n        w.append(\" on \")\n            .append(condition, 0, 0);\n      }\n      return w;\n    }\n\n    @Override public Scan accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }\n\n    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }\n\n    public Scan copy(Pat pat, @Nullable Exp exp, @Nullable Exp condition) {\n      return this.pat.equals(pat)\n          && Objects.equals(this.exp, exp)\n          && Objects.equals(this.condition, condition)\n          ? this\n          : new Scan(pos, pat, exp, condition);\n    }\n  }", "definition": "  public static class Scan extends FromStep", "class_docstring": " A scan (e.g. \"e in emps\", \"e\")\nor scan-and-join (e.g. \"left join d in depts on e.deptno = d.deptno\")\nin a {@code from} expression.", "name": "Scan", "super_interfaces": [], "superclasses": "FromStep", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [{"attribute_expression": "public final Pat pat;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "Pat", "name": "pat", "syntax_pass": true}, {"attribute_expression": "public final @Nullable Exp exp;", "docstring": "", "modifiers": "public final @Nullable", "marker_annotations": ["@Nullable"], "non_marker_annotations": ["public", "final"], "comments": [], "type": "Exp", "name": "exp", "syntax_pass": true}, {"attribute_expression": "public final @Nullable Exp condition;", "docstring": "", "modifiers": "public final @Nullable", "marker_annotations": ["@Nullable"], "non_marker_annotations": ["public", "final"], "comments": [], "type": "Exp", "name": "condition", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    Scan(Pos pos, Pat pat, @Nullable Exp exp, @Nullable Exp condition) {\n      super(pos, Op.SCAN);\n      this.pat = pat;\n      this.exp = exp;\n      this.condition = condition;\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "Scan", "params": [{"name": "pos", "type": "Pos"}, {"name": "pat", "type": "Pat"}, {"name": "exp", "type": "Exp"}, {"name": "condition", "type": "Exp"}], "body": "                                                                       {\n      super(pos, Op.SCAN);\n      this.pat = pat;\n      this.exp = exp;\n      this.condition = condition;\n    }", "signature": "Scan(Pos pos, Pat pat, @Nullable Exp exp, @Nullable Exp condition)"}, {"syntax_pass": true, "original_string": "    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      w.append(op.padded)\n          .append(pat, 0, 0);\n      if (exp != null) {\n        if (exp.op == Op.FROM_EQ) {\n          w.append(\" = \")\n              .append(((PrefixCall) this.exp).a, Op.EQ.right, 0);\n        } else {\n          w.append(\" in \")\n              .append(this.exp, Op.EQ.right, 0);\n        }\n      }\n      if (condition != null) {\n        w.append(\" on \")\n            .append(condition, 0, 0);\n      }\n      return w;\n    }", "docstring": "", "attributes": {"modifiers": "@Override", "marker_annotations": ["@Override"], "non_marker_annotations": [], "comments": [], "return_type": "AstWriter", "classes": []}, "name": "unparse", "params": [{"name": "w", "type": "AstWriter"}, {"name": "left", "type": "int"}, {"name": "right", "type": "int"}], "body": "                                                                  {\n      w.append(op.padded)\n          .append(pat, 0, 0);\n      if (exp != null) {\n        if (exp.op == Op.FROM_EQ) {\n          w.append(\" = \")\n              .append(((PrefixCall) this.exp).a, Op.EQ.right, 0);\n        } else {\n          w.append(\" in \")\n              .append(this.exp, Op.EQ.right, 0);\n        }\n      }\n      if (condition != null) {\n        w.append(\" on \")\n            .append(condition, 0, 0);\n      }\n      return w;\n    }", "signature": "@Override AstWriter unparse(AstWriter w, int left, int right)"}, {"syntax_pass": true, "original_string": "    @Override public Scan accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Scan", "classes": []}, "name": "accept", "params": [{"name": "shuttle", "type": "Shuttle"}], "body": "                                                  {\n      return shuttle.visit(this);\n    }", "signature": "@Override public Scan accept(Shuttle shuttle)"}, {"syntax_pass": true, "original_string": "    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "accept", "params": [{"name": "visitor", "type": "Visitor"}], "body": "                                                  {\n      visitor.visit(this);\n    }", "signature": "@Override public void accept(Visitor visitor)"}, {"syntax_pass": true, "original_string": "    public Scan copy(Pat pat, @Nullable Exp exp, @Nullable Exp condition) {\n      return this.pat.equals(pat)\n          && Objects.equals(this.exp, exp)\n          && Objects.equals(this.condition, condition)\n          ? this\n          : new Scan(pos, pat, exp, condition);\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Scan", "classes": []}, "name": "copy", "params": [{"name": "pat", "type": "Pat"}, {"name": "exp", "type": "Exp"}, {"name": "condition", "type": "Exp"}], "body": "                                                                          {\n      return this.pat.equals(pat)\n          && Objects.equals(this.exp, exp)\n          && Objects.equals(this.condition, condition)\n          ? this\n          : new Scan(pos, pat, exp, condition);\n    }", "signature": "public Scan copy(Pat pat, @Nullable Exp exp, @Nullable Exp condition)"}]}, {"original_string": "  public static class Where extends FromStep {\n    public final Exp exp;\n\n    Where(Pos pos, Exp exp) {\n      super(pos, Op.WHERE);\n      this.exp = exp;\n    }\n\n    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      return w.append(\" where \").append(exp, 0, 0);\n    }\n\n    @Override public AstNode accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }\n\n    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }\n\n    public Where copy(Exp exp) {\n      return this.exp.equals(exp) ? this : new Where(pos, exp);\n    }\n  }", "definition": "  public static class Where extends FromStep", "class_docstring": " A {@code where} clause in a {@code from} expression.", "name": "Where", "super_interfaces": [], "superclasses": "FromStep", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [{"attribute_expression": "public final Exp exp;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "Exp", "name": "exp", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    Where(Pos pos, Exp exp) {\n      super(pos, Op.WHERE);\n      this.exp = exp;\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "Where", "params": [{"name": "pos", "type": "Pos"}, {"name": "exp", "type": "Exp"}], "body": "                            {\n      super(pos, Op.WHERE);\n      this.exp = exp;\n    }", "signature": "Where(Pos pos, Exp exp)"}, {"syntax_pass": true, "original_string": "    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      return w.append(\" where \").append(exp, 0, 0);\n    }", "docstring": "", "attributes": {"modifiers": "@Override", "marker_annotations": ["@Override"], "non_marker_annotations": [], "comments": [], "return_type": "AstWriter", "classes": []}, "name": "unparse", "params": [{"name": "w", "type": "AstWriter"}, {"name": "left", "type": "int"}, {"name": "right", "type": "int"}], "body": "                                                                  {\n      return w.append(\" where \").append(exp, 0, 0);\n    }", "signature": "@Override AstWriter unparse(AstWriter w, int left, int right)"}, {"syntax_pass": true, "original_string": "    @Override public AstNode accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "AstNode", "classes": []}, "name": "accept", "params": [{"name": "shuttle", "type": "Shuttle"}], "body": "                                                     {\n      return shuttle.visit(this);\n    }", "signature": "@Override public AstNode accept(Shuttle shuttle)"}, {"syntax_pass": true, "original_string": "    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "accept", "params": [{"name": "visitor", "type": "Visitor"}], "body": "                                                  {\n      visitor.visit(this);\n    }", "signature": "@Override public void accept(Visitor visitor)"}, {"syntax_pass": true, "original_string": "    public Where copy(Exp exp) {\n      return this.exp.equals(exp) ? this : new Where(pos, exp);\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Where", "classes": []}, "name": "copy", "params": [{"name": "exp", "type": "Exp"}], "body": "                               {\n      return this.exp.equals(exp) ? this : new Where(pos, exp);\n    }", "signature": "public Where copy(Exp exp)"}]}, {"original_string": "  public static class Skip extends FromStep {\n    public final Exp exp;\n\n    Skip(Pos pos, Exp exp) {\n      super(pos, Op.SKIP);\n      this.exp = exp;\n    }\n\n    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      return w.append(\" skip \").append(exp, 0, 0);\n    }\n\n    @Override public AstNode accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }\n\n    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }\n\n    public Skip copy(Exp exp) {\n      return this.exp.equals(exp) ? this : new Skip(pos, exp);\n    }\n  }", "definition": "  public static class Skip extends FromStep", "class_docstring": " A {@code skip} clause in a {@code from} expression.", "name": "Skip", "super_interfaces": [], "superclasses": "FromStep", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [{"attribute_expression": "public final Exp exp;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "Exp", "name": "exp", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    Skip(Pos pos, Exp exp) {\n      super(pos, Op.SKIP);\n      this.exp = exp;\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "Skip", "params": [{"name": "pos", "type": "Pos"}, {"name": "exp", "type": "Exp"}], "body": "                           {\n      super(pos, Op.SKIP);\n      this.exp = exp;\n    }", "signature": "Skip(Pos pos, Exp exp)"}, {"syntax_pass": true, "original_string": "    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      return w.append(\" skip \").append(exp, 0, 0);\n    }", "docstring": "", "attributes": {"modifiers": "@Override", "marker_annotations": ["@Override"], "non_marker_annotations": [], "comments": [], "return_type": "AstWriter", "classes": []}, "name": "unparse", "params": [{"name": "w", "type": "AstWriter"}, {"name": "left", "type": "int"}, {"name": "right", "type": "int"}], "body": "                                                                  {\n      return w.append(\" skip \").append(exp, 0, 0);\n    }", "signature": "@Override AstWriter unparse(AstWriter w, int left, int right)"}, {"syntax_pass": true, "original_string": "    @Override public AstNode accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "AstNode", "classes": []}, "name": "accept", "params": [{"name": "shuttle", "type": "Shuttle"}], "body": "                                                     {\n      return shuttle.visit(this);\n    }", "signature": "@Override public AstNode accept(Shuttle shuttle)"}, {"syntax_pass": true, "original_string": "    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "accept", "params": [{"name": "visitor", "type": "Visitor"}], "body": "                                                  {\n      visitor.visit(this);\n    }", "signature": "@Override public void accept(Visitor visitor)"}, {"syntax_pass": true, "original_string": "    public Skip copy(Exp exp) {\n      return this.exp.equals(exp) ? this : new Skip(pos, exp);\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Skip", "classes": []}, "name": "copy", "params": [{"name": "exp", "type": "Exp"}], "body": "                              {\n      return this.exp.equals(exp) ? this : new Skip(pos, exp);\n    }", "signature": "public Skip copy(Exp exp)"}]}, {"original_string": "  public static class Take extends FromStep {\n    public final Exp exp;\n\n    Take(Pos pos, Exp exp) {\n      super(pos, Op.TAKE);\n      this.exp = exp;\n    }\n\n    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      return w.append(\" take \").append(exp, 0, 0);\n    }\n\n    @Override public AstNode accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }\n\n    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }\n\n    public Take copy(Exp exp) {\n      return this.exp.equals(exp) ? this : new Take(pos, exp);\n    }\n  }", "definition": "  public static class Take extends FromStep", "class_docstring": " A {@code take} clause in a {@code from} expression.", "name": "Take", "super_interfaces": [], "superclasses": "FromStep", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [{"attribute_expression": "public final Exp exp;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "Exp", "name": "exp", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    Take(Pos pos, Exp exp) {\n      super(pos, Op.TAKE);\n      this.exp = exp;\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "Take", "params": [{"name": "pos", "type": "Pos"}, {"name": "exp", "type": "Exp"}], "body": "                           {\n      super(pos, Op.TAKE);\n      this.exp = exp;\n    }", "signature": "Take(Pos pos, Exp exp)"}, {"syntax_pass": true, "original_string": "    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      return w.append(\" take \").append(exp, 0, 0);\n    }", "docstring": "", "attributes": {"modifiers": "@Override", "marker_annotations": ["@Override"], "non_marker_annotations": [], "comments": [], "return_type": "AstWriter", "classes": []}, "name": "unparse", "params": [{"name": "w", "type": "AstWriter"}, {"name": "left", "type": "int"}, {"name": "right", "type": "int"}], "body": "                                                                  {\n      return w.append(\" take \").append(exp, 0, 0);\n    }", "signature": "@Override AstWriter unparse(AstWriter w, int left, int right)"}, {"syntax_pass": true, "original_string": "    @Override public AstNode accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "AstNode", "classes": []}, "name": "accept", "params": [{"name": "shuttle", "type": "Shuttle"}], "body": "                                                     {\n      return shuttle.visit(this);\n    }", "signature": "@Override public AstNode accept(Shuttle shuttle)"}, {"syntax_pass": true, "original_string": "    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "accept", "params": [{"name": "visitor", "type": "Visitor"}], "body": "                                                  {\n      visitor.visit(this);\n    }", "signature": "@Override public void accept(Visitor visitor)"}, {"syntax_pass": true, "original_string": "    public Take copy(Exp exp) {\n      return this.exp.equals(exp) ? this : new Take(pos, exp);\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Take", "classes": []}, "name": "copy", "params": [{"name": "exp", "type": "Exp"}], "body": "                              {\n      return this.exp.equals(exp) ? this : new Take(pos, exp);\n    }", "signature": "public Take copy(Exp exp)"}]}, {"original_string": "  public static class Yield extends FromStep {\n    public final Exp exp;\n\n    Yield(Pos pos, Exp exp) {\n      super(pos, Op.YIELD);\n      this.exp = exp;\n    }\n\n    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      return w.append(\" yield \").append(exp, 0, 0);\n    }\n\n    @Override public AstNode accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }\n\n    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }\n\n    public Yield copy(Exp exp) {\n      return this.exp.equals(exp) ? this : new Yield(pos, exp);\n    }\n  }", "definition": "  public static class Yield extends FromStep", "class_docstring": " A {@code yield} clause in a {@code from} expression.", "name": "Yield", "super_interfaces": [], "superclasses": "FromStep", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [{"attribute_expression": "public final Exp exp;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "Exp", "name": "exp", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    Yield(Pos pos, Exp exp) {\n      super(pos, Op.YIELD);\n      this.exp = exp;\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "Yield", "params": [{"name": "pos", "type": "Pos"}, {"name": "exp", "type": "Exp"}], "body": "                            {\n      super(pos, Op.YIELD);\n      this.exp = exp;\n    }", "signature": "Yield(Pos pos, Exp exp)"}, {"syntax_pass": true, "original_string": "    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      return w.append(\" yield \").append(exp, 0, 0);\n    }", "docstring": "", "attributes": {"modifiers": "@Override", "marker_annotations": ["@Override"], "non_marker_annotations": [], "comments": [], "return_type": "AstWriter", "classes": []}, "name": "unparse", "params": [{"name": "w", "type": "AstWriter"}, {"name": "left", "type": "int"}, {"name": "right", "type": "int"}], "body": "                                                                  {\n      return w.append(\" yield \").append(exp, 0, 0);\n    }", "signature": "@Override AstWriter unparse(AstWriter w, int left, int right)"}, {"syntax_pass": true, "original_string": "    @Override public AstNode accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "AstNode", "classes": []}, "name": "accept", "params": [{"name": "shuttle", "type": "Shuttle"}], "body": "                                                     {\n      return shuttle.visit(this);\n    }", "signature": "@Override public AstNode accept(Shuttle shuttle)"}, {"syntax_pass": true, "original_string": "    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "accept", "params": [{"name": "visitor", "type": "Visitor"}], "body": "                                                  {\n      visitor.visit(this);\n    }", "signature": "@Override public void accept(Visitor visitor)"}, {"syntax_pass": true, "original_string": "    public Yield copy(Exp exp) {\n      return this.exp.equals(exp) ? this : new Yield(pos, exp);\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Yield", "classes": []}, "name": "copy", "params": [{"name": "exp", "type": "Exp"}], "body": "                               {\n      return this.exp.equals(exp) ? this : new Yield(pos, exp);\n    }", "signature": "public Yield copy(Exp exp)"}]}, {"original_string": "  public static class Into extends FromStep {\n    public final Exp exp;\n\n    Into(Pos pos, Exp exp) {\n      super(pos, Op.INTO);\n      this.exp = exp;\n    }\n\n    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      return w.append(\" into \").append(exp, 0, 0);\n    }\n\n    @Override public AstNode accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }\n\n    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }\n\n    public Into copy(Exp exp) {\n      return this.exp.equals(exp) ? this : new Into(pos, exp);\n    }\n  }", "definition": "  public static class Into extends FromStep", "class_docstring": " An {@code into} clause in a {@code from} expression.", "name": "Into", "super_interfaces": [], "superclasses": "FromStep", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [{"attribute_expression": "public final Exp exp;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "Exp", "name": "exp", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    Into(Pos pos, Exp exp) {\n      super(pos, Op.INTO);\n      this.exp = exp;\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "Into", "params": [{"name": "pos", "type": "Pos"}, {"name": "exp", "type": "Exp"}], "body": "                           {\n      super(pos, Op.INTO);\n      this.exp = exp;\n    }", "signature": "Into(Pos pos, Exp exp)"}, {"syntax_pass": true, "original_string": "    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      return w.append(\" into \").append(exp, 0, 0);\n    }", "docstring": "", "attributes": {"modifiers": "@Override", "marker_annotations": ["@Override"], "non_marker_annotations": [], "comments": [], "return_type": "AstWriter", "classes": []}, "name": "unparse", "params": [{"name": "w", "type": "AstWriter"}, {"name": "left", "type": "int"}, {"name": "right", "type": "int"}], "body": "                                                                  {\n      return w.append(\" into \").append(exp, 0, 0);\n    }", "signature": "@Override AstWriter unparse(AstWriter w, int left, int right)"}, {"syntax_pass": true, "original_string": "    @Override public AstNode accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "AstNode", "classes": []}, "name": "accept", "params": [{"name": "shuttle", "type": "Shuttle"}], "body": "                                                     {\n      return shuttle.visit(this);\n    }", "signature": "@Override public AstNode accept(Shuttle shuttle)"}, {"syntax_pass": true, "original_string": "    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "accept", "params": [{"name": "visitor", "type": "Visitor"}], "body": "                                                  {\n      visitor.visit(this);\n    }", "signature": "@Override public void accept(Visitor visitor)"}, {"syntax_pass": true, "original_string": "    public Into copy(Exp exp) {\n      return this.exp.equals(exp) ? this : new Into(pos, exp);\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Into", "classes": []}, "name": "copy", "params": [{"name": "exp", "type": "Exp"}], "body": "                              {\n      return this.exp.equals(exp) ? this : new Into(pos, exp);\n    }", "signature": "public Into copy(Exp exp)"}]}, {"original_string": "  public static class Through extends FromStep {\n    public final Pat pat;\n    public final Exp exp;\n\n    Through(Pos pos, Pat pat, Exp exp) {\n      super(pos, Op.THROUGH);\n      this.pat = pat;\n      this.exp = exp;\n    }\n\n    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      return w.append(\" through \").append(pat, 0, 0)\n          .append(\" in \").append(exp, 0, 0);\n    }\n\n    @Override public AstNode accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }\n\n    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }\n\n    public Through copy(Pat pat, Exp exp) {\n      return this.pat.equals(pat)\n          && this.exp.equals(exp)\n          ? this\n          : new Through(pos, pat, exp);\n    }\n  }", "definition": "  public static class Through extends FromStep", "class_docstring": " An {@code through} clause in a {@code from} expression.", "name": "Through", "super_interfaces": [], "superclasses": "FromStep", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [{"attribute_expression": "public final Pat pat;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "Pat", "name": "pat", "syntax_pass": true}, {"attribute_expression": "public final Exp exp;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "Exp", "name": "exp", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    Through(Pos pos, Pat pat, Exp exp) {\n      super(pos, Op.THROUGH);\n      this.pat = pat;\n      this.exp = exp;\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "Through", "params": [{"name": "pos", "type": "Pos"}, {"name": "pat", "type": "Pat"}, {"name": "exp", "type": "Exp"}], "body": "                                       {\n      super(pos, Op.THROUGH);\n      this.pat = pat;\n      this.exp = exp;\n    }", "signature": "Through(Pos pos, Pat pat, Exp exp)"}, {"syntax_pass": true, "original_string": "    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      return w.append(\" through \").append(pat, 0, 0)\n          .append(\" in \").append(exp, 0, 0);\n    }", "docstring": "", "attributes": {"modifiers": "@Override", "marker_annotations": ["@Override"], "non_marker_annotations": [], "comments": [], "return_type": "AstWriter", "classes": []}, "name": "unparse", "params": [{"name": "w", "type": "AstWriter"}, {"name": "left", "type": "int"}, {"name": "right", "type": "int"}], "body": "                                                                  {\n      return w.append(\" through \").append(pat, 0, 0)\n          .append(\" in \").append(exp, 0, 0);\n    }", "signature": "@Override AstWriter unparse(AstWriter w, int left, int right)"}, {"syntax_pass": true, "original_string": "    @Override public AstNode accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "AstNode", "classes": []}, "name": "accept", "params": [{"name": "shuttle", "type": "Shuttle"}], "body": "                                                     {\n      return shuttle.visit(this);\n    }", "signature": "@Override public AstNode accept(Shuttle shuttle)"}, {"syntax_pass": true, "original_string": "    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "accept", "params": [{"name": "visitor", "type": "Visitor"}], "body": "                                                  {\n      visitor.visit(this);\n    }", "signature": "@Override public void accept(Visitor visitor)"}, {"syntax_pass": true, "original_string": "    public Through copy(Pat pat, Exp exp) {\n      return this.pat.equals(pat)\n          && this.exp.equals(exp)\n          ? this\n          : new Through(pos, pat, exp);\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Through", "classes": []}, "name": "copy", "params": [{"name": "pat", "type": "Pat"}, {"name": "exp", "type": "Exp"}], "body": "                                          {\n      return this.pat.equals(pat)\n          && this.exp.equals(exp)\n          ? this\n          : new Through(pos, pat, exp);\n    }", "signature": "public Through copy(Pat pat, Exp exp)"}]}, {"original_string": "  public static class Order extends FromStep {\n    public final ImmutableList<OrderItem> orderItems;\n\n    Order(Pos pos, ImmutableList<OrderItem> orderItems) {\n      super(pos, Op.ORDER);\n      this.orderItems = requireNonNull(orderItems);\n    }\n\n    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      return w.append(\" order \").appendAll(orderItems, \", \");\n    }\n\n    @Override public AstNode accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }\n\n    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }\n\n    public Order copy(List<OrderItem> orderItems) {\n      return this.orderItems.equals(orderItems)\n          ? this\n          : new Order(pos, ImmutableList.copyOf(orderItems));\n    }\n  }", "definition": "  public static class Order extends FromStep", "class_docstring": " An {@code order} clause in a {@code from} expression.", "name": "Order", "super_interfaces": [], "superclasses": "FromStep", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [{"attribute_expression": "public final ImmutableList<OrderItem> orderItems;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "ImmutableList<OrderItem>", "name": "orderItems", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    Order(Pos pos, ImmutableList<OrderItem> orderItems) {\n      super(pos, Op.ORDER);\n      this.orderItems = requireNonNull(orderItems);\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "Order", "params": [{"name": "pos", "type": "Pos"}, {"name": "orderItems", "type": "ImmutableList<OrderItem>"}], "body": "                                                        {\n      super(pos, Op.ORDER);\n      this.orderItems = requireNonNull(orderItems);\n    }", "signature": "Order(Pos pos, ImmutableList<OrderItem> orderItems)"}, {"syntax_pass": true, "original_string": "    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      return w.append(\" order \").appendAll(orderItems, \", \");\n    }", "docstring": "", "attributes": {"modifiers": "@Override", "marker_annotations": ["@Override"], "non_marker_annotations": [], "comments": [], "return_type": "AstWriter", "classes": []}, "name": "unparse", "params": [{"name": "w", "type": "AstWriter"}, {"name": "left", "type": "int"}, {"name": "right", "type": "int"}], "body": "                                                                  {\n      return w.append(\" order \").appendAll(orderItems, \", \");\n    }", "signature": "@Override AstWriter unparse(AstWriter w, int left, int right)"}, {"syntax_pass": true, "original_string": "    @Override public AstNode accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "AstNode", "classes": []}, "name": "accept", "params": [{"name": "shuttle", "type": "Shuttle"}], "body": "                                                     {\n      return shuttle.visit(this);\n    }", "signature": "@Override public AstNode accept(Shuttle shuttle)"}, {"syntax_pass": true, "original_string": "    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "accept", "params": [{"name": "visitor", "type": "Visitor"}], "body": "                                                  {\n      visitor.visit(this);\n    }", "signature": "@Override public void accept(Visitor visitor)"}, {"syntax_pass": true, "original_string": "    public Order copy(List<OrderItem> orderItems) {\n      return this.orderItems.equals(orderItems)\n          ? this\n          : new Order(pos, ImmutableList.copyOf(orderItems));\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Order", "classes": []}, "name": "copy", "params": [{"name": "orderItems", "type": "List<OrderItem>"}], "body": "                                                  {\n      return this.orderItems.equals(orderItems)\n          ? this\n          : new Order(pos, ImmutableList.copyOf(orderItems));\n    }", "signature": "public Order copy(List<OrderItem> orderItems)"}]}, {"original_string": "  public static class OrderItem extends AstNode {\n    public final Exp exp;\n    public final Direction direction;\n\n    OrderItem(Pos pos, Exp exp, Direction direction) {\n      super(pos, Op.ORDER_ITEM);\n      this.exp = requireNonNull(exp);\n      this.direction = requireNonNull(direction);\n    }\n\n    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }\n\n    AstWriter unparse(AstWriter w, int left, int right) {\n      return w.append(exp, 0, 0)\n          .append(direction == Direction.DESC ? \" desc\" : \"\");\n    }\n\n    public AstNode accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }\n\n    public OrderItem copy(Exp exp, Direction direction) {\n      return this.exp.equals(exp)\n          && this.direction == direction\n          ? this\n          : new OrderItem(pos, exp, direction);\n    }\n  }", "definition": "  public static class OrderItem extends AstNode", "class_docstring": " An item in an {@code order} clause.", "name": "OrderItem", "super_interfaces": [], "superclasses": "AstNode", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [{"attribute_expression": "public final Exp exp;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "Exp", "name": "exp", "syntax_pass": true}, {"attribute_expression": "public final Direction direction;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "Direction", "name": "direction", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    OrderItem(Pos pos, Exp exp, Direction direction) {\n      super(pos, Op.ORDER_ITEM);\n      this.exp = requireNonNull(exp);\n      this.direction = requireNonNull(direction);\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "OrderItem", "params": [{"name": "pos", "type": "Pos"}, {"name": "exp", "type": "Exp"}, {"name": "direction", "type": "Direction"}], "body": "                                                     {\n      super(pos, Op.ORDER_ITEM);\n      this.exp = requireNonNull(exp);\n      this.direction = requireNonNull(direction);\n    }", "signature": "OrderItem(Pos pos, Exp exp, Direction direction)"}, {"syntax_pass": true, "original_string": "    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "accept", "params": [{"name": "visitor", "type": "Visitor"}], "body": "                                                  {\n      visitor.visit(this);\n    }", "signature": "@Override public void accept(Visitor visitor)"}, {"syntax_pass": true, "original_string": "    AstWriter unparse(AstWriter w, int left, int right) {\n      return w.append(exp, 0, 0)\n          .append(direction == Direction.DESC ? \" desc\" : \"\");\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "AstWriter", "classes": []}, "name": "unparse", "params": [{"name": "w", "type": "AstWriter"}, {"name": "left", "type": "int"}, {"name": "right", "type": "int"}], "body": "                                                        {\n      return w.append(exp, 0, 0)\n          .append(direction == Direction.DESC ? \" desc\" : \"\");\n    }", "signature": "AstWriter unparse(AstWriter w, int left, int right)"}, {"syntax_pass": true, "original_string": "    public AstNode accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "AstNode", "classes": []}, "name": "accept", "params": [{"name": "shuttle", "type": "Shuttle"}], "body": "                                           {\n      return shuttle.visit(this);\n    }", "signature": "public AstNode accept(Shuttle shuttle)"}, {"syntax_pass": true, "original_string": "    public OrderItem copy(Exp exp, Direction direction) {\n      return this.exp.equals(exp)\n          && this.direction == direction\n          ? this\n          : new OrderItem(pos, exp, direction);\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "OrderItem", "classes": []}, "name": "copy", "params": [{"name": "exp", "type": "Exp"}, {"name": "direction", "type": "Direction"}], "body": "                                                        {\n      return this.exp.equals(exp)\n          && this.direction == direction\n          ? this\n          : new OrderItem(pos, exp, direction);\n    }", "signature": "public OrderItem copy(Exp exp, Direction direction)"}]}, {"original_string": "  public static class Group extends FromStep {\n    public final ImmutablePairList<Id, Exp> groupExps;\n    public final ImmutableList<Aggregate> aggregates;\n\n    Group(Pos pos, Op op, ImmutablePairList<Id, Exp> groupExps,\n        ImmutableList<Aggregate> aggregates) {\n      super(pos, op);\n      this.groupExps = groupExps;\n      this.aggregates = aggregates;\n    }\n\n    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      if (op == Op.GROUP) {\n        w.append(\" group\");\n      }\n      forEachIndexed(groupExps, (i, id, exp) ->\n          w.append(i == 0 ? \" \" : \", \")\n              .append(id, 0, 0)\n              .append(\" = \")\n              .append(exp, 0, 0));\n      forEachIndexed(aggregates, (aggregate, i) ->\n          w.append(i == 0 ? \" compute \" : \", \")\n              .append(aggregate, 0, 0));\n      return w;\n    }\n\n    @Override public AstNode accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }\n\n    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }\n\n    public Group copy(PairList<Id, Exp> groupExps,\n        List<Aggregate> aggregates) {\n      checkArgument(op == Op.GROUP, \"use Compute.copy instead?\");\n      return this.groupExps.equals(groupExps)\n          && this.aggregates.equals(aggregates)\n          ? this\n          : ast.group(pos, groupExps, aggregates);\n    }\n  }", "definition": "  public static class Group extends FromStep", "class_docstring": " A {@code group} clause in a {@code from} expression.", "name": "Group", "super_interfaces": [], "superclasses": "FromStep", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [{"attribute_expression": "public final ImmutablePairList<Id, Exp> groupExps;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "ImmutablePairList<Id, Exp>", "name": "groupExps", "syntax_pass": true}, {"attribute_expression": "public final ImmutableList<Aggregate> aggregates;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "ImmutableList<Aggregate>", "name": "aggregates", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    Group(Pos pos, Op op, ImmutablePairList<Id, Exp> groupExps,\n        ImmutableList<Aggregate> aggregates) {\n      super(pos, op);\n      this.groupExps = groupExps;\n      this.aggregates = aggregates;\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "Group", "params": [{"name": "pos", "type": "Pos"}, {"name": "op", "type": "Op"}, {"name": "groupExps", "type": "ImmutablePairList<Id, Exp>"}, {"name": "aggregates", "type": "ImmutableList<Aggregate>"}], "body": "                                             {\n      super(pos, op);\n      this.groupExps = groupExps;\n      this.aggregates = aggregates;\n    }", "signature": "Group(Pos pos, Op op, ImmutablePairList<Id, Exp> groupExps,\n        ImmutableList<Aggregate> aggregates)"}, {"syntax_pass": true, "original_string": "    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      if (op == Op.GROUP) {\n        w.append(\" group\");\n      }\n      forEachIndexed(groupExps, (i, id, exp) ->\n          w.append(i == 0 ? \" \" : \", \")\n              .append(id, 0, 0)\n              .append(\" = \")\n              .append(exp, 0, 0));\n      forEachIndexed(aggregates, (aggregate, i) ->\n          w.append(i == 0 ? \" compute \" : \", \")\n              .append(aggregate, 0, 0));\n      return w;\n    }", "docstring": "", "attributes": {"modifiers": "@Override", "marker_annotations": ["@Override"], "non_marker_annotations": [], "comments": [], "return_type": "AstWriter", "classes": []}, "name": "unparse", "params": [{"name": "w", "type": "AstWriter"}, {"name": "left", "type": "int"}, {"name": "right", "type": "int"}], "body": "                                                                  {\n      if (op == Op.GROUP) {\n        w.append(\" group\");\n      }\n      forEachIndexed(groupExps, (i, id, exp) ->\n          w.append(i == 0 ? \" \" : \", \")\n              .append(id, 0, 0)\n              .append(\" = \")\n              .append(exp, 0, 0));\n      forEachIndexed(aggregates, (aggregate, i) ->\n          w.append(i == 0 ? \" compute \" : \", \")\n              .append(aggregate, 0, 0));\n      return w;\n    }", "signature": "@Override AstWriter unparse(AstWriter w, int left, int right)"}, {"syntax_pass": true, "original_string": "    @Override public AstNode accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "AstNode", "classes": []}, "name": "accept", "params": [{"name": "shuttle", "type": "Shuttle"}], "body": "                                                     {\n      return shuttle.visit(this);\n    }", "signature": "@Override public AstNode accept(Shuttle shuttle)"}, {"syntax_pass": true, "original_string": "    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "accept", "params": [{"name": "visitor", "type": "Visitor"}], "body": "                                                  {\n      visitor.visit(this);\n    }", "signature": "@Override public void accept(Visitor visitor)"}, {"syntax_pass": true, "original_string": "    public Group copy(PairList<Id, Exp> groupExps,\n        List<Aggregate> aggregates) {\n      checkArgument(op == Op.GROUP, \"use Compute.copy instead?\");\n      return this.groupExps.equals(groupExps)\n          && this.aggregates.equals(aggregates)\n          ? this\n          : ast.group(pos, groupExps, aggregates);\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Group", "classes": []}, "name": "copy", "params": [{"name": "groupExps", "type": "PairList<Id, Exp>"}, {"name": "aggregates", "type": "List<Aggregate>"}], "body": "                                    {\n      checkArgument(op == Op.GROUP, \"use Compute.copy instead?\");\n      return this.groupExps.equals(groupExps)\n          && this.aggregates.equals(aggregates)\n          ? this\n          : ast.group(pos, groupExps, aggregates);\n    }", "signature": "public Group copy(PairList<Id, Exp> groupExps,\n        List<Aggregate> aggregates)"}]}, {"original_string": "  public static class Compute extends Group {\n    Compute(Pos pos, ImmutableList<Aggregate> aggregates) {\n      super(pos, Op.COMPUTE, ImmutablePairList.of(), aggregates);\n    }\n\n    @Override public AstNode accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }\n\n    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }\n\n    public Compute copy(List<Aggregate> aggregates) {\n      return this.aggregates.equals(aggregates)\n          ? this\n          : ast.compute(pos, aggregates);\n    }\n  }", "definition": "  public static class Compute extends Group", "class_docstring": " A {@code compute} clause in a {@code from} expression.\n\n<p>Because {@code compute} and {@code group} are structurally similar, this\nis a  sub-class of {@link Group}, with an empty list of group keys. But\nremember that the type derivation rules are different.", "name": "Compute", "super_interfaces": [], "superclasses": "Group", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    Compute(Pos pos, ImmutableList<Aggregate> aggregates) {\n      super(pos, Op.COMPUTE, ImmutablePairList.of(), aggregates);\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "Compute", "params": [{"name": "pos", "type": "Pos"}, {"name": "aggregates", "type": "ImmutableList<Aggregate>"}], "body": "                                                          {\n      super(pos, Op.COMPUTE, ImmutablePairList.of(), aggregates);\n    }", "signature": "Compute(Pos pos, ImmutableList<Aggregate> aggregates)"}, {"syntax_pass": true, "original_string": "    @Override public AstNode accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "AstNode", "classes": []}, "name": "accept", "params": [{"name": "shuttle", "type": "Shuttle"}], "body": "                                                     {\n      return shuttle.visit(this);\n    }", "signature": "@Override public AstNode accept(Shuttle shuttle)"}, {"syntax_pass": true, "original_string": "    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "accept", "params": [{"name": "visitor", "type": "Visitor"}], "body": "                                                  {\n      visitor.visit(this);\n    }", "signature": "@Override public void accept(Visitor visitor)"}, {"syntax_pass": true, "original_string": "    public Compute copy(List<Aggregate> aggregates) {\n      return this.aggregates.equals(aggregates)\n          ? this\n          : ast.compute(pos, aggregates);\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Compute", "classes": []}, "name": "copy", "params": [{"name": "aggregates", "type": "List<Aggregate>"}], "body": "                                                    {\n      return this.aggregates.equals(aggregates)\n          ? this\n          : ast.compute(pos, aggregates);\n    }", "signature": "public Compute copy(List<Aggregate> aggregates)"}]}, {"original_string": "  public static class Apply extends Exp {\n    public final Exp fn;\n    public final Exp arg;\n\n    Apply(Pos pos, Exp fn, Exp arg) {\n      super(pos, Op.APPLY);\n      this.fn = fn;\n      this.arg = arg;\n    }\n\n    public Exp accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }\n\n    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }\n\n    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      return w.infix(left, fn, op, arg, right);\n    }\n\n    public Apply copy(Exp fn, Exp arg) {\n      return this.fn.equals(fn) && this.arg.equals(arg) ? this\n          : new Apply(pos, fn, arg);\n    }\n  }", "definition": "  public static class Apply extends Exp", "class_docstring": " Application of a function to its argument.", "name": "Apply", "super_interfaces": [], "superclasses": "Exp", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [{"attribute_expression": "public final Exp fn;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "Exp", "name": "fn", "syntax_pass": true}, {"attribute_expression": "public final Exp arg;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "Exp", "name": "arg", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    Apply(Pos pos, Exp fn, Exp arg) {\n      super(pos, Op.APPLY);\n      this.fn = fn;\n      this.arg = arg;\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "Apply", "params": [{"name": "pos", "type": "Pos"}, {"name": "fn", "type": "Exp"}, {"name": "arg", "type": "Exp"}], "body": "                                    {\n      super(pos, Op.APPLY);\n      this.fn = fn;\n      this.arg = arg;\n    }", "signature": "Apply(Pos pos, Exp fn, Exp arg)"}, {"syntax_pass": true, "original_string": "    public Exp accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Exp", "classes": []}, "name": "accept", "params": [{"name": "shuttle", "type": "Shuttle"}], "body": "                                       {\n      return shuttle.visit(this);\n    }", "signature": "public Exp accept(Shuttle shuttle)"}, {"syntax_pass": true, "original_string": "    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "accept", "params": [{"name": "visitor", "type": "Visitor"}], "body": "                                                  {\n      visitor.visit(this);\n    }", "signature": "@Override public void accept(Visitor visitor)"}, {"syntax_pass": true, "original_string": "    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      return w.infix(left, fn, op, arg, right);\n    }", "docstring": "", "attributes": {"modifiers": "@Override", "marker_annotations": ["@Override"], "non_marker_annotations": [], "comments": [], "return_type": "AstWriter", "classes": []}, "name": "unparse", "params": [{"name": "w", "type": "AstWriter"}, {"name": "left", "type": "int"}, {"name": "right", "type": "int"}], "body": "                                                                  {\n      return w.infix(left, fn, op, arg, right);\n    }", "signature": "@Override AstWriter unparse(AstWriter w, int left, int right)"}, {"syntax_pass": true, "original_string": "    public Apply copy(Exp fn, Exp arg) {\n      return this.fn.equals(fn) && this.arg.equals(arg) ? this\n          : new Apply(pos, fn, arg);\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Apply", "classes": []}, "name": "copy", "params": [{"name": "fn", "type": "Exp"}, {"name": "arg", "type": "Exp"}], "body": "                                       {\n      return this.fn.equals(fn) && this.arg.equals(arg) ? this\n          : new Apply(pos, fn, arg);\n    }", "signature": "public Apply copy(Exp fn, Exp arg)"}]}, {"original_string": "  public static class Aggregate extends AstNode {\n    public final Exp aggregate;\n    public final Exp argument;\n    public final Id id;\n\n    Aggregate(Pos pos, Exp aggregate, @Nullable Exp argument, Id id) {\n      super(pos, Op.AGGREGATE);\n      this.aggregate = requireNonNull(aggregate);\n      this.argument = argument;\n      this.id = requireNonNull(id);\n    }\n\n    AstWriter unparse(AstWriter w, int left, int right) {\n      w.id(id.name)\n          .append(\" = \")\n          .append(aggregate, 0, 0);\n      if (argument != null) {\n        w.append(\" of \")\n            .append(argument, 0, 0);\n      }\n      return w;\n    }\n\n    public AstNode accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }\n\n    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }\n\n    public Aggregate copy(Exp aggregate, Exp argument, Id id) {\n      return this.aggregate.equals(aggregate)\n          && Objects.equals(this.argument, argument)\n          && this.id.equals(id)\n          ? this\n          : ast.aggregate(pos, aggregate, argument, id);\n    }\n  }", "definition": "  public static class Aggregate extends AstNode", "class_docstring": " Call to an aggregate function in a {@code compute} clause.\n\n<p>For example, in {@code compute sumId = sum of #id e},\n{@code aggregate} is \"sum\", {@code argument} is \"#id e\",\nand {@code id} is \"sumId\".", "name": "Aggregate", "super_interfaces": [], "superclasses": "AstNode", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [{"attribute_expression": "public final Exp aggregate;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "Exp", "name": "aggregate", "syntax_pass": true}, {"attribute_expression": "public final Exp argument;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "Exp", "name": "argument", "syntax_pass": true}, {"attribute_expression": "public final Id id;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "Id", "name": "id", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    Aggregate(Pos pos, Exp aggregate, @Nullable Exp argument, Id id) {\n      super(pos, Op.AGGREGATE);\n      this.aggregate = requireNonNull(aggregate);\n      this.argument = argument;\n      this.id = requireNonNull(id);\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "Aggregate", "params": [{"name": "pos", "type": "Pos"}, {"name": "aggregate", "type": "Exp"}, {"name": "argument", "type": "Exp"}, {"name": "id", "type": "Id"}], "body": "                                                                     {\n      super(pos, Op.AGGREGATE);\n      this.aggregate = requireNonNull(aggregate);\n      this.argument = argument;\n      this.id = requireNonNull(id);\n    }", "signature": "Aggregate(Pos pos, Exp aggregate, @Nullable Exp argument, Id id)"}, {"syntax_pass": true, "original_string": "    AstWriter unparse(AstWriter w, int left, int right) {\n      w.id(id.name)\n          .append(\" = \")\n          .append(aggregate, 0, 0);\n      if (argument != null) {\n        w.append(\" of \")\n            .append(argument, 0, 0);\n      }\n      return w;\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "AstWriter", "classes": []}, "name": "unparse", "params": [{"name": "w", "type": "AstWriter"}, {"name": "left", "type": "int"}, {"name": "right", "type": "int"}], "body": "                                                        {\n      w.id(id.name)\n          .append(\" = \")\n          .append(aggregate, 0, 0);\n      if (argument != null) {\n        w.append(\" of \")\n            .append(argument, 0, 0);\n      }\n      return w;\n    }", "signature": "AstWriter unparse(AstWriter w, int left, int right)"}, {"syntax_pass": true, "original_string": "    public AstNode accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "AstNode", "classes": []}, "name": "accept", "params": [{"name": "shuttle", "type": "Shuttle"}], "body": "                                           {\n      return shuttle.visit(this);\n    }", "signature": "public AstNode accept(Shuttle shuttle)"}, {"syntax_pass": true, "original_string": "    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "accept", "params": [{"name": "visitor", "type": "Visitor"}], "body": "                                                  {\n      visitor.visit(this);\n    }", "signature": "@Override public void accept(Visitor visitor)"}, {"syntax_pass": true, "original_string": "    public Aggregate copy(Exp aggregate, Exp argument, Id id) {\n      return this.aggregate.equals(aggregate)\n          && Objects.equals(this.argument, argument)\n          && this.id.equals(id)\n          ? this\n          : ast.aggregate(pos, aggregate, argument, id);\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Aggregate", "classes": []}, "name": "copy", "params": [{"name": "aggregate", "type": "Exp"}, {"name": "argument", "type": "Exp"}, {"name": "id", "type": "Id"}], "body": "                                                              {\n      return this.aggregate.equals(aggregate)\n          && Objects.equals(this.argument, argument)\n          && this.id.equals(id)\n          ? this\n          : ast.aggregate(pos, aggregate, argument, id);\n    }", "signature": "public Aggregate copy(Exp aggregate, Exp argument, Id id)"}]}], "class_docstring": " Various sub-classes of AST nodes.", "original_string": "public class Ast {\n  private Ast() {}\n\n  /** Base class for a pattern.\n   *\n   * <p>For example, \"x\" in \"val x = 5\" is a {@link IdPat};\n   * the \"(x, y) in \"val (x, y) = makePair 1 2\" is a {@link TuplePat}. */\n  public abstract static class Pat extends AstNode {\n    Pat(Pos pos, Op op) {\n      super(pos, op);\n    }\n\n    public void forEachArg(ObjIntConsumer<Pat> action) {\n      // no args\n    }\n\n    @Override public abstract Pat accept(Shuttle shuttle);\n\n    public void visit(Consumer<Pat> consumer) {\n      consumer.accept(this);\n      forEachArg((arg, i) -> arg.visit(consumer));\n    }\n  }\n\n  /** Named pattern, the pattern analog of the {@link Id} expression.\n   *\n   * <p>For example, \"x\" in \"val x = 5\". */\n  public static class IdPat extends Pat {\n    public final String name;\n\n    IdPat(Pos pos, String name) {\n      super(pos, Op.ID_PAT);\n      this.name = name;\n    }\n\n    public Pat accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }\n\n    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }\n\n    AstWriter unparse(AstWriter w, int left, int right) {\n      return w.id(name);\n    }\n  }\n\n  /** Literal pattern, the pattern analog of the {@link Literal} expression.\n   *\n   * <p>For example, \"0\" in \"fun fact 0 = 1 | fact n = n * fact (n - 1)\".*/\n  @SuppressWarnings(\"rawtypes\")\n  public static class LiteralPat extends Pat {\n    public final Comparable value;\n\n    LiteralPat(Pos pos, Op op, Comparable value) {\n      super(pos, op);\n      this.value = requireNonNull(value);\n      checkArgument(op == Op.BOOL_LITERAL_PAT\n          || op == Op.CHAR_LITERAL_PAT\n          || op == Op.INT_LITERAL_PAT\n          || op == Op.REAL_LITERAL_PAT\n          || op == Op.STRING_LITERAL_PAT);\n    }\n\n    @Override public int hashCode() {\n      return value.hashCode();\n    }\n\n    @Override public boolean equals(Object o) {\n      return o == this\n          || o instanceof LiteralPat\n          && this.value.equals(((LiteralPat) o).value);\n    }\n\n    public Pat accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }\n\n    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }\n\n    AstWriter unparse(AstWriter w, int left, int right) {\n      return w.appendLiteral(value);\n    }\n  }\n\n  /** Wildcard pattern.\n   *\n   * <p>For example, \"{@code _}\" in \"{@code fn foo _ => 42}\". */\n  public static class WildcardPat extends Pat {\n    WildcardPat(Pos pos) {\n      super(pos, Op.WILDCARD_PAT);\n    }\n\n    @Override public int hashCode() {\n      return \"_\".hashCode();\n    }\n\n    @Override public boolean equals(Object o) {\n      return o instanceof WildcardPat;\n    }\n\n    public Pat accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }\n\n    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }\n\n    AstWriter unparse(AstWriter w, int left, int right) {\n      return w.append(\"_\");\n    }\n  }\n\n  /** Pattern build from an infix operator applied to two patterns. */\n  public static class InfixPat extends Pat {\n    public final Pat p0;\n    public final Pat p1;\n\n    InfixPat(Pos pos, Op op, Pat p0, Pat p1) {\n      super(pos, op);\n      this.p0 = requireNonNull(p0);\n      this.p1 = requireNonNull(p1);\n    }\n\n    public Pat accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }\n\n    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }\n\n    @Override public void forEachArg(ObjIntConsumer<Pat> action) {\n      action.accept(p0, 0);\n      action.accept(p1, 1);\n    }\n\n    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      return w.infix(left, p0, op, p1, right);\n    }\n\n    /** Creates a copy of this {@code InfixPat} with given contents\n     * and same operator,\n     * or {@code this} if the contents are the same. */\n    public InfixPat copy(Pat p0, Pat p1) {\n      return this.p0.equals(p0)\n          && this.p1.equals(p1)\n          ? this\n          : ast.infixPat(pos, op, p0, p1);\n    }\n  }\n\n  /** Type constructor pattern with an argument.\n   *\n   * <p>For example, in \"fun nvl NIL = 0 | OPTION x = x\",\n   * \"OPTION x\" is a type constructor pattern that binds \"x\";\n   * and \"NIL\" is a type constructor pattern whose {@link #pat} is null.\n   *\n   * @see Con0Pat */\n  public static class ConPat extends Pat {\n    public final Id tyCon;\n    public final Pat pat;\n\n    ConPat(Pos pos, Id tyCon, Pat pat) {\n      super(pos, Op.CON_PAT);\n      this.tyCon = requireNonNull(tyCon);\n      this.pat = requireNonNull(pat);\n    }\n\n    public Pat accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }\n\n    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }\n\n    @Override public void forEachArg(ObjIntConsumer<Pat> action) {\n      action.accept(pat, 0);\n    }\n\n    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      return w.infix(left, tyCon, op, pat, right);\n    }\n\n    /** Creates a copy of this {@code ConPat} with given contents,\n     * or {@code this} if the contents are the same. */\n    public ConPat copy(Id tyCon, Pat pat) {\n      return this.tyCon.equals(tyCon)\n          && this.pat.equals(pat)\n          ? this\n          : ast.conPat(pos, tyCon, pat);\n    }\n  }\n\n  /** Layered pattern.\n   *\n   * <p>For example, in \"val h as (i, j) = (1, 2)\",\n   * if the pattern matches, \"h\" is assigned the whole tuple,\n   * and \"i\" and \"j\" are assigned the left and right members of the tuple. */\n  public static class AsPat extends Pat {\n    public final IdPat id;\n    public final Pat pat;\n\n    AsPat(Pos pos, IdPat id, Pat pat) {\n      super(pos, Op.AS_PAT);\n      this.id = requireNonNull(id);\n      this.pat = requireNonNull(pat);\n    }\n\n    public Pat accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }\n\n    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }\n\n    @Override public void forEachArg(ObjIntConsumer<Pat> action) {\n      action.accept(id, 0);\n      action.accept(pat, 1);\n    }\n\n    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      return w.infix(left, id, op, pat, right);\n    }\n\n    /** Creates a copy of this {@code AsPat} with given contents,\n     * or {@code this} if the contents are the same. */\n    public AsPat copy(IdPat id, Pat pat) {\n      return this.id.equals(id)\n          && this.pat.equals(pat)\n          ? this\n          : ast.asPat(pos, id, pat);\n    }\n  }\n\n  /** Type constructor pattern with no argument.\n   *\n   * <p>For example, in \"fun nvl NIL = 0 | OPTION x = x\",\n   * \"NIL\" is a zero-arg type constructor pattern.\n   *\n   * @see ConPat */\n  public static class Con0Pat extends Pat {\n    public final Id tyCon;\n\n    Con0Pat(Pos pos, Id tyCon) {\n      super(pos, Op.CON0_PAT);\n      this.tyCon = requireNonNull(tyCon);\n    }\n\n    public Pat accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }\n\n    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }\n\n    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      return tyCon.unparse(w, left, right);\n    }\n\n    /** Creates a copy of this {@code Con0Pat} with given contents,\n     * or {@code this} if the contents are the same. */\n    public Con0Pat copy(Id tyCon) {\n      return this.tyCon.equals(tyCon)\n          ? this\n          : ast.con0Pat(pos, tyCon);\n    }\n  }\n\n  /** Tuple pattern, the pattern analog of the {@link Tuple} expression.\n   *\n   * <p>For example, \"(x, y)\" in \"fun sum (x, y) = x + y\". */\n  public static class TuplePat extends Pat {\n    public final List<Pat> args;\n\n    TuplePat(Pos pos, ImmutableList<Pat> args) {\n      super(pos, Op.TUPLE_PAT);\n      this.args = requireNonNull(args);\n    }\n\n    public Pat accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }\n\n    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }\n\n    @Override public void forEachArg(ObjIntConsumer<Pat> action) {\n      forEachIndexed(args, action);\n    }\n\n    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      w.append(\"(\");\n      forEachArg((arg, i) -> w.append(i == 0 ? \"\" : \", \").append(arg, 0, 0));\n      return w.append(\")\");\n    }\n\n    /** Creates a copy of this {@code TuplePat} with given contents,\n     * or {@code this} if the contents are the same. */\n    public TuplePat copy(List<Pat> args) {\n      return this.args.equals(args)\n          ? this\n          : ast.tuplePat(pos, args);\n    }\n  }\n\n  /** List pattern, the pattern analog of the {@link ListExp} expression.\n   *\n   * <p>For example, \"[x, y]\" in \"fun sum [x, y] = x + y\". */\n  public static class ListPat extends Pat {\n    public final List<Pat> args;\n\n    ListPat(Pos pos, ImmutableList<Pat> args) {\n      super(pos, Op.LIST_PAT);\n      this.args = requireNonNull(args);\n    }\n\n    public Pat accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }\n\n    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }\n\n    @Override public void forEachArg(ObjIntConsumer<Pat> action) {\n      forEachIndexed(args, action);\n    }\n\n    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      w.append(\"[\");\n      forEachArg((arg, i) -> w.append(i == 0 ? \"\" : \", \").append(arg, 0, 0));\n      return w.append(\"]\");\n    }\n\n    /** Creates a copy of this {@code ListPat} with given contents,\n     * or {@code this} if the contents are the same. */\n    public ListPat copy(List<Pat> args) {\n      return this.args.equals(args)\n          ? this\n          : ast.listPat(pos, args);\n    }\n  }\n\n  /** Record pattern. */\n  public static class RecordPat extends Pat {\n    public final boolean ellipsis;\n    public final SortedMap<String, Pat> args;\n\n    RecordPat(Pos pos, boolean ellipsis, ImmutableSortedMap<String, Pat> args) {\n      super(pos, Op.RECORD_PAT);\n      this.ellipsis = ellipsis;\n      this.args = requireNonNull(args);\n      checkArgument(args.comparator() == ORDERING);\n    }\n\n    public Pat accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }\n\n    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }\n\n    @Override public void forEachArg(ObjIntConsumer<Pat> action) {\n      forEachIndexed(args.values(), action);\n    }\n\n    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      w.append(\"{\");\n      Ord.forEachIndexed(args, (i, k, v) -> // lint:skip\n          w.append(i > 0 ? \", \" : \"\").append(k).append(\" = \").append(v, 0, 0));\n      if (ellipsis) {\n        w.append(args.isEmpty() ? \"...\" : \", ...\");\n      }\n      return w.append(\"}\");\n    }\n\n    public RecordPat copy(boolean ellipsis, Map<String, ? extends Pat> args) {\n      return this.ellipsis == ellipsis\n          && this.args.equals(args)\n          ? this\n          : ast.recordPat(pos, ellipsis, args);\n    }\n  }\n\n  /** Pattern that is a pattern annotated with a type.\n   *\n   * <p>For example, \"x : int\" in \"val x : int = 5\". */\n  public static class AnnotatedPat extends Pat {\n    public final Pat pat;\n    public final Type type;\n\n    AnnotatedPat(Pos pos, Pat pat, Type type) {\n      super(pos, Op.ANNOTATED_PAT);\n      this.pat = pat;\n      this.type = type;\n    }\n\n    public Pat accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }\n\n    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }\n\n    AstWriter unparse(AstWriter w, int left, int right) {\n      return w.infix(left, pat, op, type, right);\n    }\n\n    @Override public void forEachArg(ObjIntConsumer<Pat> action) {\n      action.accept(pat, 0);\n    }\n\n    /** Creates a copy of this {@code AnnotatedPat} with given contents,\n     * or {@code this} if the contents are the same. */\n    public AnnotatedPat copy(Pat pat, Type type) {\n      return this.pat.equals(pat)\n          && this.type.equals(type)\n          ? this\n          : ast.annotatedPat(pos, pat, type);\n    }\n  }\n\n  /** Base class for parse tree nodes that represent types. */\n  public abstract static class Type extends AstNode {\n    /** Creates a type node. */\n    Type(Pos pos, Op op) {\n      super(pos, op);\n    }\n\n    @Override public abstract Type accept(Shuttle shuttle);\n  }\n\n  /** Parse tree node of an expression annotated with a type. */\n  public static class AnnotatedExp extends Exp {\n    public final Type type;\n    public final Exp exp;\n\n    /** Creates a type annotation. */\n    AnnotatedExp(Pos pos, Exp exp, Type type) {\n      super(pos, Op.ANNOTATED_EXP);\n      this.type = requireNonNull(type);\n      this.exp = requireNonNull(exp);\n    }\n\n    @Override public int hashCode() {\n      return Objects.hash(type, exp);\n    }\n\n    @Override public boolean equals(Object obj) {\n      return this == obj\n          || obj instanceof AnnotatedExp\n              && type.equals(((AnnotatedExp) obj).type)\n              && exp.equals(((AnnotatedExp) obj).exp);\n    }\n\n    public Exp accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }\n\n    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }\n\n    AstWriter unparse(AstWriter w, int left, int right) {\n      return w.infix(left, exp, op, type, right);\n    }\n  }\n\n  /** Parse tree for a named type (e.g. \"int\" or \"(int, string) list\"). */\n  public static class NamedType extends Type {\n    public final List<Type> types;\n    public final String name;\n\n    /** Creates a type. */\n    NamedType(Pos pos, ImmutableList<Type> types, String name) {\n      super(pos, Op.NAMED_TYPE);\n      this.types = requireNonNull(types);\n      this.name = requireNonNull(name);\n    }\n\n    @Override public int hashCode() {\n      return Objects.hash(types, name);\n    }\n\n    @Override public boolean equals(Object obj) {\n      return obj == this\n          || obj instanceof NamedType\n          && types.equals(((NamedType) obj).types)\n          && name.equals(((NamedType) obj).name);\n    }\n\n    public Type accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }\n\n    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }\n\n    AstWriter unparse(AstWriter w, int left, int right) {\n      switch (types.size()) {\n      case 0:\n        return w.id(name);\n      case 1:\n        return w.append(types.get(0), left, op.left)\n            .append(\" \").id(name);\n      default:\n        w.append(\"(\");\n        forEachIndexed(types, (type, i) ->\n            w.append(i == 0 ? \"\" : \", \").append(type, 0, 0));\n        return w.append(\") \")\n            .id(name);\n      }\n    }\n  }\n\n  /** Parse tree node of a type variable. */\n  public static class TyVar extends Type {\n    public final String name;\n\n    /** Creates a TyVar. */\n    TyVar(Pos pos, String name) {\n      super(pos, Op.TY_VAR);\n      this.name = requireNonNull(name);\n    }\n\n    @Override public int hashCode() {\n      return name.hashCode();\n    }\n\n    @Override public boolean equals(Object o) {\n      return o == this\n          || o instanceof TyVar\n          && this.name.equals(((TyVar) o).name);\n    }\n\n    public TyVar accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }\n\n    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }\n\n    AstWriter unparse(AstWriter w, int left, int right) {\n      return w.id(name);\n    }\n  }\n\n  /** Parse tree node of a record type. */\n  public static class RecordType extends Type {\n    public final Map<String, Type> fieldTypes;\n\n    /** Creates a record type. */\n    RecordType(Pos pos, ImmutableMap<String, Type> fieldTypes) {\n      super(pos, Op.RECORD_TYPE);\n      this.fieldTypes = requireNonNull(fieldTypes);\n    }\n\n    @Override public int hashCode() {\n      return fieldTypes.hashCode();\n    }\n\n    @Override public boolean equals(Object o) {\n      return o == this\n          || o instanceof RecordType\n          && this.fieldTypes.equals(((RecordType) o).fieldTypes);\n    }\n\n    public RecordType accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }\n\n    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }\n\n    AstWriter unparse(AstWriter w, int left, int right) {\n      w.append(\"{\");\n      Ord.forEachIndexed(fieldTypes, (i, field, type) -> // lint:skip\n          w.append(i > 0 ? \", \" : \"\")\n              .id(field).append(\": \").append(type, 0, 0));\n      return w.append(\"}\");\n    }\n  }\n\n  /** Tuple type. */\n  public static class TupleType extends Type {\n    public final List<Type> types;\n\n    TupleType(Pos pos, ImmutableList<Type> types) {\n      super(pos, Op.TUPLE_TYPE);\n      this.types = requireNonNull(types);\n    }\n\n    public Type accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }\n\n    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }\n\n    AstWriter unparse(AstWriter w, int left, int right) {\n      // \"*\" is non-associative. Elevate both left and right precedence\n      // to force parentheses if the inner expression is also \"*\".\n      forEachIndexed(types, (arg, i) ->\n          w.append(i == 0 ? \"\" : \" * \")\n              .append(arg, op.left + 1, op.right + 1));\n      return w;\n    }\n  }\n\n  /** Not really a type, just a way for the parser to represent the type\n   * arguments to a type constructor.\n   *\n   * <p>For example, in {@code datatype foo = Pair of (int, string) list},\n   * {@code (int, string)} is briefly represented as a composite type,\n   * then {@code int} and {@code string} becomes the two type parameters to\n   * the {@code list} {@link NamedType}. */\n  public static class CompositeType extends Type {\n    public final List<Type> types;\n\n    CompositeType(Pos pos, ImmutableList<Type> types) {\n      super(pos, Op.TUPLE_TYPE);\n      this.types = requireNonNull(types);\n    }\n\n    public Type accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }\n\n    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }\n\n    AstWriter unparse(AstWriter w, int left, int right) {\n      w.append(\"(\");\n      forEachIndexed(types, (arg, i) ->\n          w.append(i == 0 ? \"\" : \", \").append(arg, 0, 0));\n      return w.append(\")\");\n    }\n  }\n\n  /** Function type. */\n  public static class FunctionType extends Type {\n    public final Type paramType;\n    public final Type resultType;\n\n    FunctionType(Pos pos, Type paramType, Type resultType) {\n      super(pos, Op.FUNCTION_TYPE);\n      this.paramType = requireNonNull(paramType);\n      this.resultType = requireNonNull(resultType);\n    }\n\n    public Type accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }\n\n    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }\n\n    AstWriter unparse(AstWriter w, int left, int right) {\n      return w.append(paramType, left, op.left)\n          .append(\" -> \")\n          .append(resultType, op.right, right);\n    }\n  }\n\n  /** Base class of expression ASTs. */\n  public abstract static class Exp extends AstNode {\n    Exp(Pos pos, Op op) {\n      super(pos, op);\n    }\n\n    public void forEachArg(ObjIntConsumer<Exp> action) {\n      // no args\n    }\n\n    @Override public abstract Exp accept(Shuttle shuttle);\n\n    /** Returns a list of all arguments. */\n    public final List<Exp> args() {\n      final ImmutableList.Builder<Exp> args = ImmutableList.builder();\n      forEachArg((exp, value) -> args.add(exp));\n      return args.build();\n    }\n  }\n\n  /** Parse tree node of an identifier. */\n  public static class Id extends Exp {\n    public final String name;\n\n    /** Creates an Id. */\n    Id(Pos pos, String name) {\n      super(pos, Op.ID);\n      this.name = requireNonNull(name);\n    }\n\n    public Id accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }\n\n    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }\n\n    AstWriter unparse(AstWriter w, int left, int right) {\n      return w.id(name);\n    }\n  }\n\n  /** Parse tree node of a record selector. */\n  public static class RecordSelector extends Exp {\n    public final String name;\n\n    /** Creates a record selector. */\n    RecordSelector(Pos pos, String name) {\n      super(pos, Op.RECORD_SELECTOR);\n      this.name = requireNonNull(name);\n      assert !name.startsWith(\"#\");\n    }\n\n    @Override public int hashCode() {\n      return name.hashCode();\n    }\n\n    @Override public boolean equals(Object o) {\n      return o == this\n          || o instanceof Id\n          && this.name.equals(((Id) o).name);\n    }\n\n    public Exp accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }\n\n    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }\n\n    AstWriter unparse(AstWriter w, int left, int right) {\n      return w.append(\"#\").append(name);\n    }\n  }\n\n  /** Parse tree node of a literal (constant). */\n  @SuppressWarnings(\"rawtypes\")\n  public static class Literal extends Exp {\n    public final Comparable value;\n\n    /** Creates a Literal. */\n    Literal(Pos pos, Op op, Comparable value) {\n      super(pos, op);\n      this.value = requireNonNull(value);\n    }\n\n    @Override public int hashCode() {\n      return value.hashCode();\n    }\n\n    @Override public boolean equals(Object o) {\n      return o == this\n          || o instanceof Literal\n          && this.value.equals(((Literal) o).value);\n    }\n\n    public Exp accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }\n\n    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }\n\n    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      return w.appendLiteral(value);\n    }\n  }\n\n  /** Base class for declarations. */\n  public abstract static class Decl extends AstNode {\n    Decl(Pos pos, Op op) {\n      super(pos, op);\n    }\n\n    @Override public abstract Decl accept(Shuttle shuttle);\n  }\n\n  /** Parse tree node of a datatype declaration. */\n  public static class DatatypeDecl extends Decl {\n    public final List<DatatypeBind> binds;\n\n    DatatypeDecl(Pos pos, ImmutableList<DatatypeBind> binds) {\n      super(pos, Op.DATATYPE_DECL);\n      this.binds = requireNonNull(binds);\n      checkArgument(!this.binds.isEmpty());\n    }\n\n    @Override public int hashCode() {\n      return Objects.hash(binds);\n    }\n\n    @Override public boolean equals(Object o) {\n      return o == this\n          || o instanceof DatatypeDecl\n          && binds.equals(((DatatypeDecl) o).binds);\n    }\n\n    public DatatypeDecl accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }\n\n    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }\n\n    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      return w.appendAll(binds, \"datatype \", \" and \", \"\");\n    }\n  }\n\n  /** Parse tree node of a datatype binding.\n   *\n   * <p>Example: the datatype declaration\n   * {@code datatype 'a x = X1 of 'a | X2 and y = Y}\n   * consists of type bindings {@code 'a x = X1 of 'a | X2} and\n   * {@code y = Y}. */\n  public static class DatatypeBind extends AstNode {\n    public final List<TyVar> tyVars;\n    public final Id name;\n    public final List<TyCon> tyCons;\n\n    DatatypeBind(Pos pos, ImmutableList<TyVar> tyVars, Id name,\n        ImmutableList<TyCon> tyCons) {\n      super(pos, Op.DATATYPE_DECL);\n      this.tyVars = requireNonNull(tyVars);\n      this.name = requireNonNull(name);\n      this.tyCons = requireNonNull(tyCons);\n      checkArgument(!this.tyCons.isEmpty());\n    }\n\n    @Override public int hashCode() {\n      return Objects.hash(tyVars, tyCons);\n    }\n\n    @Override public boolean equals(Object o) {\n      return o == this\n          || o instanceof DatatypeBind\n          && name.equals(((DatatypeBind) o).name)\n          && tyVars.equals(((DatatypeBind) o).tyVars)\n          && tyCons.equals(((DatatypeBind) o).tyCons);\n    }\n\n    public DatatypeBind accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }\n\n    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }\n\n    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      switch (tyVars.size()) {\n      case 0:\n        break;\n      case 1:\n        w.append(tyVars.get(0), 0, 0).append(\" \");\n        break;\n      default:\n        w.appendAll(tyVars, \"(\", \", \", \") \");\n      }\n      return w.id(name.name)\n          .appendAll(tyCons, \" = \", \" | \", \"\");\n    }\n  }\n\n  /** Type constructor.\n   *\n   * <p>For example, in the {@link DatatypeDecl datatype declaration}\n   * {@code datatype 'a option = NIL | SOME of 'a}, \"NIL\" and \"SOME of 'a\"\n   * are both type constructors.\n   */\n  public static class TyCon extends AstNode {\n    public final Id id;\n    public final @org.checkerframework.checker.nullness.qual.Nullable Type type;\n\n    TyCon(Pos pos, Id id, Type type) {\n      super(pos, Op.TY_CON);\n      this.id = requireNonNull(id);\n      this.type = type; // optional\n    }\n\n    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }\n\n    AstWriter unparse(AstWriter w, int left, int right) {\n      if (type != null) {\n        return w.append(id, left, op.left)\n            .append(\" of \")\n            .append(type, op.right, right);\n      } else {\n        return w.append(id, left, right);\n      }\n    }\n\n    public AstNode accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }\n  }\n\n  /** Parse tree node of a value declaration. */\n  public static class ValDecl extends Decl {\n    public final boolean rec;\n    public final List<ValBind> valBinds;\n\n    protected ValDecl(Pos pos, boolean rec, ImmutableList<ValBind> valBinds) {\n      super(pos, Op.VAL_DECL);\n      this.rec = rec;\n      this.valBinds = requireNonNull(valBinds);\n      checkArgument(!valBinds.isEmpty());\n    }\n\n    @Override public int hashCode() {\n      return Objects.hash(rec, valBinds);\n    }\n\n    @Override public boolean equals(Object o) {\n      return o == this\n          || o instanceof ValDecl\n          && this.rec == ((ValDecl) o).rec\n          && this.valBinds.equals(((ValDecl) o).valBinds);\n    }\n\n    public ValDecl accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }\n\n    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }\n\n    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      String sep = rec ? \"val rec \" : \"val \";\n      for (ValBind valBind : valBinds) {\n        w.append(sep);\n        sep = \" and \";\n        valBind.unparse(w, 0, right);\n      }\n      return w;\n    }\n\n    /** Creates a copy of this {@code ValDecl} with given contents,\n     * or {@code this} if the contents are the same. */\n    public ValDecl copy(Iterable<ValBind> valBinds) {\n      return Iterables.elementsEqual(this.valBinds, valBinds)\n          ? this\n          : ast.valDecl(pos, rec, valBinds);\n    }\n  }\n\n  /** Parse tree node of a function declaration. */\n  public static class FunDecl extends Decl {\n    public final List<FunBind> funBinds;\n\n    FunDecl(Pos pos, ImmutableList<FunBind> funBinds) {\n      super(pos, Op.FUN_DECL);\n      this.funBinds = requireNonNull(funBinds);\n      checkArgument(!funBinds.isEmpty());\n      // TODO: check that functions have the same name\n    }\n\n    @Override public int hashCode() {\n      return funBinds.hashCode();\n    }\n\n    @Override public boolean equals(Object o) {\n      return o == this\n          || o instanceof FunDecl\n          && this.funBinds.equals(((FunDecl) o).funBinds);\n    }\n\n    public Decl accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }\n\n    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }\n\n    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      return w.appendAll(funBinds, \"fun \", \" and \", \"\");\n    }\n  }\n\n  /** One of the branches (separated by 'and') in a 'fun' function\n   * declaration. */\n  public static class FunBind extends AstNode {\n    public final List<FunMatch> matchList;\n    public final String name;\n\n    FunBind(Pos pos, ImmutableList<FunMatch> matchList) {\n      super(pos, Op.FUN_BIND);\n      checkArgument(!matchList.isEmpty());\n      this.matchList = matchList;\n      // We assume that the function name is the same in all matches.\n      // We will check during validation.\n      this.name = matchList.get(0).name;\n    }\n\n    public FunBind accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }\n\n    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }\n\n    AstWriter unparse(AstWriter w, int left, int right) {\n      return w.appendAll(matchList, \" | \");\n    }\n  }\n\n  /** One of the branches (separated by '|') in a 'fun' function declaration. */\n  public static class FunMatch extends AstNode {\n    public final String name;\n    public final List<Pat> patList;\n    public final @Nullable Type returnType;\n    public final Exp exp;\n\n    FunMatch(Pos pos, String name, ImmutableList<Pat> patList,\n        @Nullable Type returnType, Exp exp) {\n      super(pos, Op.FUN_MATCH);\n      this.name = name;\n      this.patList = patList;\n      this.returnType = returnType;\n      this.exp = exp;\n    }\n\n    public FunMatch accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }\n\n    AstWriter unparse(AstWriter w, int left, int right) {\n      w.id(name);\n      for (Pat pat : patList) {\n        w.append(\" \").append(pat, Op.APPLY.left, Op.APPLY.right);\n      }\n      return w.append(\" = \").append(exp, 0, right);\n    }\n\n    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }\n  }\n\n  /** Tuple. */\n  public static class Tuple extends Exp {\n    public final List<Exp> args;\n\n    Tuple(Pos pos, Iterable<? extends Exp> args) {\n      super(pos, Op.TUPLE);\n      this.args = ImmutableList.copyOf(args);\n    }\n\n    @Override public void forEachArg(ObjIntConsumer<Exp> action) {\n      forEachIndexed(args, action);\n    }\n\n    public Exp accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }\n\n    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }\n\n    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      w.append(\"(\");\n      forEachArg((arg, i) -> w.append(i == 0 ? \"\" : \", \").append(arg, 0, 0));\n      return w.append(\")\");\n    }\n\n    public Tuple copy(List<Exp> args) {\n      return this.args.equals(args) ? this : new Tuple(pos, args);\n    }\n  }\n\n  /** List expression. */\n  public static class ListExp extends Exp {\n    public final List<Exp> args;\n\n    ListExp(Pos pos, Iterable<? extends Exp> args) {\n      super(pos, Op.LIST);\n      this.args = ImmutableList.copyOf(args);\n    }\n\n    @Override public void forEachArg(ObjIntConsumer<Exp> action) {\n      forEachIndexed(args, action);\n    }\n\n    public ListExp accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }\n\n    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }\n\n    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      w.append(\"[\");\n      forEachArg((arg, i) -> w.append(i == 0 ? \"\" : \", \").append(arg, 0, 0));\n      return w.append(\"]\");\n    }\n\n    public ListExp copy(List<Exp> args) {\n      return args.equals(this.args) ? this\n          : ast.list(pos, args);\n    }\n  }\n\n  /** Record. */\n  public static class Record extends Exp {\n    public final SortedMap<String, Exp> args;\n\n    Record(Pos pos, ImmutableSortedMap<String, Exp> args) {\n      super(pos, Op.RECORD);\n      this.args = requireNonNull(args);\n      checkArgument(args.comparator() == ORDERING);\n    }\n\n    @Override public void forEachArg(ObjIntConsumer<Exp> action) {\n      forEachIndexed(args.values(), action);\n    }\n\n    public Exp accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }\n\n    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }\n\n    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      w.append(\"{\");\n      Ord.forEachIndexed(args, (i, k, v) -> // lint:skip\n          w.append(i > 0 ? \", \" : \"\").append(k).append(\" = \").append(v, 0, 0));\n      return w.append(\"}\");\n    }\n\n    public Record copy(Map<String, Ast.Exp> args) {\n      return args.equals(this.args) ? this : ast.record(pos, args);\n    }\n  }\n\n  /** Call to an infix operator. */\n  public static class InfixCall extends Exp {\n    public final Exp a0;\n    public final Exp a1;\n\n    InfixCall(Pos pos, Op op, Exp a0, Exp a1) {\n      super(pos, op);\n      this.a0 = requireNonNull(a0);\n      this.a1 = requireNonNull(a1);\n    }\n\n    @Override public void forEachArg(ObjIntConsumer<Exp> action) {\n      action.accept(a0, 0);\n      action.accept(a1, 1);\n    }\n\n    public Exp accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }\n\n    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }\n\n    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      return w.infix(left, a0, op, a1, right);\n    }\n\n    /** Creates a copy of this {@code InfixCall} with given contents,\n     * or {@code this} if the contents are the same. */\n    public InfixCall copy(Exp a0, Exp a1) {\n      return this.a0.equals(a0)\n          && this.a1.equals(a1)\n          ? this\n          : new InfixCall(pos, op, a0, a1);\n    }\n  }\n\n  /** Call to a prefix operator. */\n  public static class PrefixCall extends Exp {\n    public final Exp a;\n\n    PrefixCall(Pos pos, Op op, Exp a) {\n      super(pos, op);\n      this.a = requireNonNull(a);\n    }\n\n    @Override public void forEachArg(ObjIntConsumer<Exp> action) {\n      action.accept(a, 0);\n    }\n\n    public Exp accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }\n\n    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }\n\n    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      return w.prefix(left, op, a, right);\n    }\n  }\n\n  /** \"If ... else\" expression. */\n  public static class If extends Exp {\n    public final Exp condition;\n    public final Exp ifTrue;\n    public final Exp ifFalse;\n\n    public If(Pos pos, Exp condition, Exp ifTrue, Exp ifFalse) {\n      super(pos, Op.IF);\n      this.condition = requireNonNull(condition);\n      this.ifTrue = requireNonNull(ifTrue);\n      this.ifFalse = requireNonNull(ifFalse);\n    }\n\n    public Exp accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }\n\n    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }\n\n    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      return w.append(\"if \").append(condition, 0, 0)\n          .append(\" then \").append(ifTrue, 0, 0)\n          .append(\" else \").append(ifFalse, 0, right);\n    }\n\n    /** Creates a copy of this {@code If} with given contents,\n     * or {@code this} if the contents are the same. */\n    public If copy(Exp condition, Exp ifTrue, Exp ifFalse) {\n      return this.condition.equals(condition)\n          && this.ifTrue.equals(ifTrue)\n          && this.ifFalse.equals(ifFalse)\n          ? this\n          : new If(pos, condition, ifTrue, ifFalse);\n    }\n  }\n\n  /** \"Let\" expression. */\n  public static class Let extends Exp {\n    public final List<Decl> decls;\n    public final Exp exp;\n\n    Let(Pos pos, ImmutableList<Decl> decls, Exp exp) {\n      super(pos, Op.LET);\n      this.decls = requireNonNull(decls);\n      this.exp = requireNonNull(exp);\n    }\n\n    public Exp accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }\n\n    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }\n\n    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      return w.appendAll(decls, \"let \", \"; \", \" in \")\n          .append(exp, 0, 0).append(\" end\");\n    }\n\n    /** Creates a copy of this {@code LetExp} with given contents,\n     * or {@code this} if the contents are the same. */\n    public Let copy(Iterable<Decl> decls, Exp exp) {\n      return Iterables.elementsEqual(this.decls, decls)\n          && Objects.equals(this.exp, exp)\n          ? this\n          : ast.let(pos, decls, exp);\n    }\n  }\n\n  /** Value bind. */\n  public static class ValBind extends AstNode {\n    public final Pat pat;\n    public final Exp exp;\n\n    ValBind(Pos pos, Pat pat, Exp exp) {\n      super(pos, Op.VAL_BIND);\n      this.pat = pat;\n      this.exp = exp;\n    }\n\n    public AstNode accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }\n\n    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }\n\n    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      return w.append(pat, 0, 0).append(\" = \").append(exp, 0, right);\n    }\n\n    /** Creates a copy of this {@code ValBind} with given contents,\n     * or {@code this} if the contents are the same. */\n    public ValBind copy(Pat pat, Exp exp) {\n      return this.pat.equals(pat)\n          && this.exp.equals(exp)\n          ? this\n          : ast.valBind(pos, pat, exp);\n    }\n  }\n\n  /** Match. */\n  public static class Match extends AstNode {\n    public final Pat pat;\n    public final Exp exp;\n\n    Match(Pos pos, Pat pat, Exp exp) {\n      super(pos, Op.MATCH);\n      this.pat = pat;\n      this.exp = exp;\n    }\n\n    public Match accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }\n\n    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }\n\n    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      return w.append(pat, 0, 0).append(\" => \").append(exp, 0, right);\n    }\n\n    /** Creates a copy of this {@code Match} with given contents,\n     * or {@code this} if the contents are the same. */\n    public Match copy(Pat pat, Exp exp) {\n      return this.pat.equals(pat)\n          && this.exp.equals(exp)\n          ? this\n          : ast.match(pos, pat, exp);\n    }\n  }\n\n  /** Lambda expression. */\n  public static class Fn extends Exp {\n    public final List<Match> matchList;\n\n    Fn(Pos pos, ImmutableList<Match> matchList) {\n      super(pos, Op.FN);\n      this.matchList = requireNonNull(matchList);\n      checkArgument(!matchList.isEmpty());\n    }\n\n    public Fn accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }\n\n    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }\n\n    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      return w.append(\"fn \").appendAll(matchList, 0, Op.BAR, right);\n    }\n\n    /** Creates a copy of this {@code Fn} with given contents,\n     * or this if the contents are the same. */\n    public Fn copy(List<Match> matchList) {\n      return this.matchList.equals(matchList)\n          ? this\n          : ast.fn(pos, matchList);\n    }\n  }\n\n  /** Case expression. */\n  public static class Case extends Exp {\n    public final Exp exp;\n    public final List<Match> matchList;\n\n    Case(Pos pos, Exp exp, ImmutableList<Match> matchList) {\n      super(pos, Op.CASE);\n      this.exp = exp;\n      this.matchList = matchList;\n    }\n\n    public Exp accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }\n\n    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }\n\n    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      return w.append(\"case \").append(exp, 0, 0).append(\" of \")\n          .appendAll(matchList, left, Op.BAR, right);\n    }\n\n    public Case copy(Exp exp, List<Match> matchList) {\n      return this.exp.equals(exp)\n          && this.matchList.equals(matchList)\n          ? this\n          : ast.caseOf(pos, exp, matchList);\n    }\n  }\n\n  /** From expression. */\n  public static class From extends Exp {\n    public final ImmutableList<FromStep> steps;\n    /** An implicit yield expression, if the last step is not a {@link Yield};\n     * null if the last step is a {@link Yield}. */\n    public final @Nullable Exp implicitYieldExp;\n\n    From(Pos pos, ImmutableList<FromStep> steps,\n        @Nullable Exp implicitYieldExp) {\n      super(pos, Op.FROM);\n      this.steps = requireNonNull(steps);\n      this.implicitYieldExp = implicitYieldExp;\n    }\n\n    static @Nullable Exp implicitYieldExp(Pos pos, List<FromStep> steps) {\n      if (!steps.isEmpty()) {\n        final FromStep lastStep = getLast(steps);\n        if (lastStep.op == Op.YIELD\n            || lastStep.op == Op.INTO) {\n          // No implicit yield is needed; the last step is an explicit yield\n          return null;\n        }\n      }\n      Set<Id> fields = ImmutableSet.of();\n      final Set<Id> nextFields = new HashSet<>();\n      for (FromStep step : steps) {\n        switch (step.op) {\n        case SCAN:\n          final Scan scan = (Scan) step;\n          nextFields.clear();\n          nextFields.addAll(fields);\n          scan.pat.visit(p -> {\n            if (p instanceof IdPat) {\n              nextFields.add(ast.id(Pos.ZERO, ((IdPat) p).name));\n            }\n          });\n          fields = ImmutableSet.copyOf(nextFields);\n          break;\n\n        case THROUGH:\n          final Through through = (Through) step;\n          nextFields.clear();\n          through.pat.visit(p -> {\n            if (p instanceof IdPat) {\n              nextFields.add(ast.id(Pos.ZERO, ((IdPat) p).name));\n            }\n          });\n          fields = ImmutableSet.copyOf(nextFields);\n          break;\n\n        case COMPUTE:\n        case GROUP:\n          final Group group = (Group) step;\n          final ImmutablePairList<Id, Exp> groupExps = group.groupExps;\n          final List<Aggregate> aggregates = group.aggregates;\n\n          // The type of\n          //   from e in emps group a = e1, b = e2 compute c = sum of e3\n          // is the same as the type of\n          //   {a = e1, b = e2, c = sum (map (fn e => e3) [])}\n          nextFields.clear();\n          nextFields.addAll(Pair.left(groupExps));\n          groupExps.forEach((id, exp) -> nextFields.add(id));\n          aggregates.forEach(aggregate -> nextFields.add(aggregate.id));\n          fields = nextFields;\n          break;\n\n        case YIELD:\n          final Yield yield = (Yield) step;\n          if (yield.exp instanceof Record) {\n            fields =\n                ((Record) yield.exp).args.keySet()\n                    .stream()\n                    .map(label -> ast.id(Pos.ZERO, label))\n                    .collect(Collectors.toSet());\n          }\n          break;\n        }\n      }\n\n      if (fields.size() == 1\n          && (steps.isEmpty()\n          || getLast(steps).op != Op.YIELD\n          || ((Yield) getLast(steps)).exp.op != Op.RECORD)) {\n        return Iterables.getOnlyElement(fields);\n      } else {\n        final SortedMap<String, Ast.Exp> map = mutableMap();\n        fields.forEach(field -> map.put(field.name, field));\n        return ast.record(pos, map);\n      }\n    }\n\n    public Exp accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }\n\n    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }\n\n    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      if (left > op.left || op.right < right) {\n        return w.append(\"(\").append(this, 0, 0).append(\")\");\n      } else {\n        w.append(\"from\");\n        forEachIndexed(steps, (step, i) -> {\n          if (step.op == Op.SCAN && i > 0) {\n            if (steps.get(i - 1).op == Op.SCAN) {\n              w.append(\",\");\n            } else {\n              w.append(\" join\");\n            }\n          }\n          step.unparse(w, 0, 0);\n        });\n        return w;\n      }\n    }\n\n    /** Creates a copy of this {@code From} with given contents,\n     * or {@code this} if the contents are the same. */\n    public From copy(List<FromStep> steps, @Nullable Exp implicitYieldExp) {\n      return this.steps.equals(steps)\n          ? this\n          : ast.from(pos, steps, implicitYieldExp);\n    }\n\n    /** Returns whether this {@code from} expression ends with a {@code compute}\n     * step. If so, it is a <em>monoid</em> comprehension, not a <em>monad</em>\n     * comprehension, and its type is a scalar value (or record), not a list. */\n    public boolean isCompute() {\n      return !steps.isEmpty()\n          && steps.get(steps.size() - 1).op == Op.COMPUTE;\n    }\n\n    /** Returns whether this {@code from} expression ends with as {@code into}\n     * step. If so, its type is a scalar value (or record), not a list. */\n    public boolean isInto() {\n      return !steps.isEmpty()\n          && steps.get(steps.size() - 1).op == Op.INTO;\n    }\n  }\n\n  /** A step in a {@code from} expression - {@code where}, {@code group}\n   * or {@code order}. */\n  public abstract static class FromStep extends AstNode {\n    FromStep(Pos pos, Op op) {\n      super(pos, op);\n    }\n  }\n\n  /** A scan (e.g. \"e in emps\", \"e\")\n   * or scan-and-join (e.g. \"left join d in depts on e.deptno = d.deptno\")\n   * in a {@code from} expression. */\n  public static class Scan extends FromStep {\n    public final Pat pat;\n    public final @Nullable Exp exp;\n    public final @Nullable Exp condition;\n\n    Scan(Pos pos, Pat pat, @Nullable Exp exp, @Nullable Exp condition) {\n      super(pos, Op.SCAN);\n      this.pat = pat;\n      this.exp = exp;\n      this.condition = condition;\n    }\n\n    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      w.append(op.padded)\n          .append(pat, 0, 0);\n      if (exp != null) {\n        if (exp.op == Op.FROM_EQ) {\n          w.append(\" = \")\n              .append(((PrefixCall) this.exp).a, Op.EQ.right, 0);\n        } else {\n          w.append(\" in \")\n              .append(this.exp, Op.EQ.right, 0);\n        }\n      }\n      if (condition != null) {\n        w.append(\" on \")\n            .append(condition, 0, 0);\n      }\n      return w;\n    }\n\n    @Override public Scan accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }\n\n    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }\n\n    public Scan copy(Pat pat, @Nullable Exp exp, @Nullable Exp condition) {\n      return this.pat.equals(pat)\n          && Objects.equals(this.exp, exp)\n          && Objects.equals(this.condition, condition)\n          ? this\n          : new Scan(pos, pat, exp, condition);\n    }\n  }\n\n  /** A {@code where} clause in a {@code from} expression. */\n  public static class Where extends FromStep {\n    public final Exp exp;\n\n    Where(Pos pos, Exp exp) {\n      super(pos, Op.WHERE);\n      this.exp = exp;\n    }\n\n    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      return w.append(\" where \").append(exp, 0, 0);\n    }\n\n    @Override public AstNode accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }\n\n    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }\n\n    public Where copy(Exp exp) {\n      return this.exp.equals(exp) ? this : new Where(pos, exp);\n    }\n  }\n\n  /** A {@code skip} clause in a {@code from} expression. */\n  public static class Skip extends FromStep {\n    public final Exp exp;\n\n    Skip(Pos pos, Exp exp) {\n      super(pos, Op.SKIP);\n      this.exp = exp;\n    }\n\n    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      return w.append(\" skip \").append(exp, 0, 0);\n    }\n\n    @Override public AstNode accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }\n\n    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }\n\n    public Skip copy(Exp exp) {\n      return this.exp.equals(exp) ? this : new Skip(pos, exp);\n    }\n  }\n\n  /** A {@code take} clause in a {@code from} expression. */\n  public static class Take extends FromStep {\n    public final Exp exp;\n\n    Take(Pos pos, Exp exp) {\n      super(pos, Op.TAKE);\n      this.exp = exp;\n    }\n\n    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      return w.append(\" take \").append(exp, 0, 0);\n    }\n\n    @Override public AstNode accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }\n\n    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }\n\n    public Take copy(Exp exp) {\n      return this.exp.equals(exp) ? this : new Take(pos, exp);\n    }\n  }\n\n  /** A {@code yield} clause in a {@code from} expression. */\n  public static class Yield extends FromStep {\n    public final Exp exp;\n\n    Yield(Pos pos, Exp exp) {\n      super(pos, Op.YIELD);\n      this.exp = exp;\n    }\n\n    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      return w.append(\" yield \").append(exp, 0, 0);\n    }\n\n    @Override public AstNode accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }\n\n    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }\n\n    public Yield copy(Exp exp) {\n      return this.exp.equals(exp) ? this : new Yield(pos, exp);\n    }\n  }\n\n  /** An {@code into} clause in a {@code from} expression. */\n  public static class Into extends FromStep {\n    public final Exp exp;\n\n    Into(Pos pos, Exp exp) {\n      super(pos, Op.INTO);\n      this.exp = exp;\n    }\n\n    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      return w.append(\" into \").append(exp, 0, 0);\n    }\n\n    @Override public AstNode accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }\n\n    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }\n\n    public Into copy(Exp exp) {\n      return this.exp.equals(exp) ? this : new Into(pos, exp);\n    }\n  }\n\n  /** An {@code through} clause in a {@code from} expression. */\n  public static class Through extends FromStep {\n    public final Pat pat;\n    public final Exp exp;\n\n    Through(Pos pos, Pat pat, Exp exp) {\n      super(pos, Op.THROUGH);\n      this.pat = pat;\n      this.exp = exp;\n    }\n\n    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      return w.append(\" through \").append(pat, 0, 0)\n          .append(\" in \").append(exp, 0, 0);\n    }\n\n    @Override public AstNode accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }\n\n    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }\n\n    public Through copy(Pat pat, Exp exp) {\n      return this.pat.equals(pat)\n          && this.exp.equals(exp)\n          ? this\n          : new Through(pos, pat, exp);\n    }\n  }\n\n  /** An {@code order} clause in a {@code from} expression. */\n  public static class Order extends FromStep {\n    public final ImmutableList<OrderItem> orderItems;\n\n    Order(Pos pos, ImmutableList<OrderItem> orderItems) {\n      super(pos, Op.ORDER);\n      this.orderItems = requireNonNull(orderItems);\n    }\n\n    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      return w.append(\" order \").appendAll(orderItems, \", \");\n    }\n\n    @Override public AstNode accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }\n\n    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }\n\n    public Order copy(List<OrderItem> orderItems) {\n      return this.orderItems.equals(orderItems)\n          ? this\n          : new Order(pos, ImmutableList.copyOf(orderItems));\n    }\n  }\n\n  /** An item in an {@code order} clause. */\n  public static class OrderItem extends AstNode {\n    public final Exp exp;\n    public final Direction direction;\n\n    OrderItem(Pos pos, Exp exp, Direction direction) {\n      super(pos, Op.ORDER_ITEM);\n      this.exp = requireNonNull(exp);\n      this.direction = requireNonNull(direction);\n    }\n\n    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }\n\n    AstWriter unparse(AstWriter w, int left, int right) {\n      return w.append(exp, 0, 0)\n          .append(direction == Direction.DESC ? \" desc\" : \"\");\n    }\n\n    public AstNode accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }\n\n    public OrderItem copy(Exp exp, Direction direction) {\n      return this.exp.equals(exp)\n          && this.direction == direction\n          ? this\n          : new OrderItem(pos, exp, direction);\n    }\n  }\n\n  /** Sort order. */\n  public enum Direction {\n    ASC,\n    DESC\n  }\n\n  /** A {@code group} clause in a {@code from} expression. */\n  public static class Group extends FromStep {\n    public final ImmutablePairList<Id, Exp> groupExps;\n    public final ImmutableList<Aggregate> aggregates;\n\n    Group(Pos pos, Op op, ImmutablePairList<Id, Exp> groupExps,\n        ImmutableList<Aggregate> aggregates) {\n      super(pos, op);\n      this.groupExps = groupExps;\n      this.aggregates = aggregates;\n    }\n\n    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      if (op == Op.GROUP) {\n        w.append(\" group\");\n      }\n      forEachIndexed(groupExps, (i, id, exp) ->\n          w.append(i == 0 ? \" \" : \", \")\n              .append(id, 0, 0)\n              .append(\" = \")\n              .append(exp, 0, 0));\n      forEachIndexed(aggregates, (aggregate, i) ->\n          w.append(i == 0 ? \" compute \" : \", \")\n              .append(aggregate, 0, 0));\n      return w;\n    }\n\n    @Override public AstNode accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }\n\n    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }\n\n    public Group copy(PairList<Id, Exp> groupExps,\n        List<Aggregate> aggregates) {\n      checkArgument(op == Op.GROUP, \"use Compute.copy instead?\");\n      return this.groupExps.equals(groupExps)\n          && this.aggregates.equals(aggregates)\n          ? this\n          : ast.group(pos, groupExps, aggregates);\n    }\n  }\n\n  /** A {@code compute} clause in a {@code from} expression.\n   *\n   * <p>Because {@code compute} and {@code group} are structurally similar, this\n   * is a  sub-class of {@link Group}, with an empty list of group keys. But\n   * remember that the type derivation rules are different. */\n  public static class Compute extends Group {\n    Compute(Pos pos, ImmutableList<Aggregate> aggregates) {\n      super(pos, Op.COMPUTE, ImmutablePairList.of(), aggregates);\n    }\n\n    @Override public AstNode accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }\n\n    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }\n\n    public Compute copy(List<Aggregate> aggregates) {\n      return this.aggregates.equals(aggregates)\n          ? this\n          : ast.compute(pos, aggregates);\n    }\n  }\n\n  /** Application of a function to its argument. */\n  public static class Apply extends Exp {\n    public final Exp fn;\n    public final Exp arg;\n\n    Apply(Pos pos, Exp fn, Exp arg) {\n      super(pos, Op.APPLY);\n      this.fn = fn;\n      this.arg = arg;\n    }\n\n    public Exp accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }\n\n    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }\n\n    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      return w.infix(left, fn, op, arg, right);\n    }\n\n    public Apply copy(Exp fn, Exp arg) {\n      return this.fn.equals(fn) && this.arg.equals(arg) ? this\n          : new Apply(pos, fn, arg);\n    }\n  }\n\n  /** Call to an aggregate function in a {@code compute} clause.\n   *\n   * <p>For example, in {@code compute sumId = sum of #id e},\n   * {@code aggregate} is \"sum\", {@code argument} is \"#id e\",\n   * and {@code id} is \"sumId\". */\n  public static class Aggregate extends AstNode {\n    public final Exp aggregate;\n    public final Exp argument;\n    public final Id id;\n\n    Aggregate(Pos pos, Exp aggregate, @Nullable Exp argument, Id id) {\n      super(pos, Op.AGGREGATE);\n      this.aggregate = requireNonNull(aggregate);\n      this.argument = argument;\n      this.id = requireNonNull(id);\n    }\n\n    AstWriter unparse(AstWriter w, int left, int right) {\n      w.id(id.name)\n          .append(\" = \")\n          .append(aggregate, 0, 0);\n      if (argument != null) {\n        w.append(\" of \")\n            .append(argument, 0, 0);\n      }\n      return w;\n    }\n\n    public AstNode accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }\n\n    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }\n\n    public Aggregate copy(Exp aggregate, Exp argument, Id id) {\n      return this.aggregate.equals(aggregate)\n          && Objects.equals(this.argument, argument)\n          && this.id.equals(id)\n          ? this\n          : ast.aggregate(pos, aggregate, argument, id);\n    }\n  }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/main/java/net/hydromatic/morel/ast/Core.java.Core", "name": "Core", "file_path": "src/main/java/net/hydromatic/morel/ast/Core.java", "superclasses": "", "methods": ["[]Core()"], "method_uris": ["src/main/java/net/hydromatic/morel/ast/Core.java.Core.[]Core()"], "overrides": null, "attributes": [{"original_string": "  abstract static class BaseNode extends AstNode {\n    BaseNode(Pos pos, Op op) {\n      super(pos, op);\n    }\n\n    @Override public AstNode accept(Shuttle shuttle) {\n      throw new UnsupportedOperationException(getClass() + \" cannot accept \"\n          + shuttle.getClass());\n    }\n\n    @Override public void accept(Visitor visitor) {\n      throw new UnsupportedOperationException(getClass() + \" cannot accept \"\n          + visitor.getClass());\n    }\n  }", "definition": "  abstract static class BaseNode extends AstNode", "class_docstring": " Abstract base class of Core nodes.", "name": "BaseNode", "super_interfaces": [], "superclasses": "AstNode", "attributes": {"modifiers": "abstract static", "marker_annotations": [], "non_marker_annotations": ["abstract", "static"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    BaseNode(Pos pos, Op op) {\n      super(pos, op);\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "BaseNode", "params": [{"name": "pos", "type": "Pos"}, {"name": "op", "type": "Op"}], "body": "                             {\n      super(pos, op);\n    }", "signature": "BaseNode(Pos pos, Op op)"}, {"syntax_pass": true, "original_string": "    @Override public AstNode accept(Shuttle shuttle) {\n      throw new UnsupportedOperationException(getClass() + \" cannot accept \"\n          + shuttle.getClass());\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "AstNode", "classes": []}, "name": "accept", "params": [{"name": "shuttle", "type": "Shuttle"}], "body": "                                                     {\n      throw new UnsupportedOperationException(getClass() + \" cannot accept \"\n          + shuttle.getClass());\n    }", "signature": "@Override public AstNode accept(Shuttle shuttle)"}, {"syntax_pass": true, "original_string": "    @Override public void accept(Visitor visitor) {\n      throw new UnsupportedOperationException(getClass() + \" cannot accept \"\n          + visitor.getClass());\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "accept", "params": [{"name": "visitor", "type": "Visitor"}], "body": "                                                  {\n      throw new UnsupportedOperationException(getClass() + \" cannot accept \"\n          + visitor.getClass());\n    }", "signature": "@Override public void accept(Visitor visitor)"}]}, {"original_string": "  public abstract static class Pat extends BaseNode {\n    public final Type type;\n\n    Pat(Op op, Type type) {\n      super(Pos.ZERO, op);\n      this.type = requireNonNull(type);\n    }\n\n    /** Returns the type. */\n    public Type type() {\n      return type;\n    }\n\n    @Override public abstract Pat accept(Shuttle shuttle);\n  }", "definition": "  public abstract static class Pat extends BaseNode", "class_docstring": " Base class for a pattern.\n\n<p>For example, \"x\" in \"val x = 5\" is a {@link IdPat};\nthe \"(x, y) in \"val (x, y) = makePair 1 2\" is a {@link TuplePat}.", "name": "Pat", "super_interfaces": [], "superclasses": "BaseNode", "attributes": {"modifiers": "public abstract static", "marker_annotations": [], "non_marker_annotations": ["public", "abstract", "static"], "comments": [], "fields": [{"attribute_expression": "public final Type type;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "Type", "name": "type", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    Pat(Op op, Type type) {\n      super(Pos.ZERO, op);\n      this.type = requireNonNull(type);\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "Pat", "params": [{"name": "op", "type": "Op"}, {"name": "type", "type": "Type"}], "body": "                          {\n      super(Pos.ZERO, op);\n      this.type = requireNonNull(type);\n    }", "signature": "Pat(Op op, Type type)"}, {"syntax_pass": true, "original_string": "    public Type type() {\n      return type;\n    }", "docstring": " Returns the type.", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Type", "classes": []}, "name": "type", "params": [], "body": "                       {\n      return type;\n    }", "signature": "public Type type()"}, {"syntax_pass": true, "original_string": "    @Override public abstract Pat accept(Shuttle shuttle);", "docstring": "", "attributes": {"modifiers": "@Override public abstract", "marker_annotations": ["@Override"], "non_marker_annotations": ["public", "abstract"], "comments": [], "return_type": "Pat", "classes": []}, "name": "accept", "params": [{"name": "shuttle", "type": "Shuttle"}], "body": "", "signature": "@Override public abstract Pat accept(Shuttle shuttle)"}]}, {"original_string": "  public abstract static class NamedPat extends Pat\n      implements Comparable<NamedPat> {\n    /** Ordering that compares named patterns by their names, then by their\n     * ordinal. */\n    public static final Ordering<NamedPat> ORDERING =\n        Ordering.from(NamedPat::compare);\n\n    public final String name;\n    public final int i;\n\n    NamedPat(Op op, Type type, String name, int i) {\n      super(op, type);\n      this.name = requireNonNull(name, \"name\");\n      this.i = i;\n      checkArgument(!name.isEmpty(), \"empty name\");\n    }\n\n    /** {@inheritDoc}\n     *\n     * <p>Collate first on name, then on ordinal. */\n    @Override public int compareTo(NamedPat o) {\n      return compare(this, o);\n    }\n\n    /** Helper for {@link #ORDERING}. */\n    static int compare(NamedPat o1, NamedPat o2) {\n      int c = RecordType.compareNames(o1.name, o2.name);\n      if (c != 0) {\n        return c;\n      }\n      return Integer.compare(o1.i, o2.i);\n    }\n\n    public abstract NamedPat withType(Type type);\n\n    @Override public abstract NamedPat accept(Shuttle shuttle);\n  }", "definition": "  public abstract static class NamedPat extends Pat\n      implements Comparable<NamedPat>", "class_docstring": " Base class for named patterns ({@link IdPat} and {@link AsPat}).\n\n<p>Implements {@link Comparable} so that names are sorted correctly\nfor record fields (see {@link RecordType#ORDERING}).\n\n<p>A {@link Core.ValDecl} must be one of these.", "name": "NamedPat", "super_interfaces": ["Comparable<NamedPat>"], "superclasses": "Pat", "attributes": {"modifiers": "public abstract static", "marker_annotations": [], "non_marker_annotations": ["public", "abstract", "static"], "comments": [], "fields": [{"attribute_expression": "public static final Ordering<NamedPat> ORDERING =\n        Ordering.from(NamedPat::compare);", "docstring": " Ordering that compares named patterns by their names, then by their\nordinal.", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "Ordering<NamedPat>", "name": "ORDERING =\n        Ordering.from(NamedPat::compare)", "syntax_pass": true}, {"attribute_expression": "public final String name;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "String", "name": "name", "syntax_pass": true}, {"attribute_expression": "public final int i;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "int", "name": "i", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    NamedPat(Op op, Type type, String name, int i) {\n      super(op, type);\n      this.name = requireNonNull(name, \"name\");\n      this.i = i;\n      checkArgument(!name.isEmpty(), \"empty name\");\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "NamedPat", "params": [{"name": "op", "type": "Op"}, {"name": "type", "type": "Type"}, {"name": "name", "type": "String"}, {"name": "i", "type": "int"}], "body": "                                                   {\n      super(op, type);\n      this.name = requireNonNull(name, \"name\");\n      this.i = i;\n      checkArgument(!name.isEmpty(), \"empty name\");\n    }", "signature": "NamedPat(Op op, Type type, String name, int i)"}, {"syntax_pass": true, "original_string": "    @Override public int compareTo(NamedPat o) {\n      return compare(this, o);\n    }", "docstring": " {@inheritDoc}\n\n<p>Collate first on name, then on ordinal.", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "compareTo", "params": [{"name": "o", "type": "NamedPat"}], "body": "                                               {\n      return compare(this, o);\n    }", "signature": "@Override public int compareTo(NamedPat o)"}, {"syntax_pass": true, "original_string": "    static int compare(NamedPat o1, NamedPat o2) {\n      int c = RecordType.compareNames(o1.name, o2.name);\n      if (c != 0) {\n        return c;\n      }\n      return Integer.compare(o1.i, o2.i);\n    }", "docstring": " Helper for {@link #ORDERING}.", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "int", "classes": []}, "name": "compare", "params": [{"name": "o1", "type": "NamedPat"}, {"name": "o2", "type": "NamedPat"}], "body": "                                                 {\n      int c = RecordType.compareNames(o1.name, o2.name);\n      if (c != 0) {\n        return c;\n      }\n      return Integer.compare(o1.i, o2.i);\n    }", "signature": "static int compare(NamedPat o1, NamedPat o2)"}, {"syntax_pass": true, "original_string": "    public abstract NamedPat withType(Type type);", "docstring": "", "attributes": {"modifiers": "public abstract", "marker_annotations": [], "non_marker_annotations": ["public", "abstract"], "comments": [], "return_type": "NamedPat", "classes": []}, "name": "withType", "params": [{"name": "type", "type": "Type"}], "body": "", "signature": "public abstract NamedPat withType(Type type)"}, {"syntax_pass": true, "original_string": "    @Override public abstract NamedPat accept(Shuttle shuttle);", "docstring": "", "attributes": {"modifiers": "@Override public abstract", "marker_annotations": ["@Override"], "non_marker_annotations": ["public", "abstract"], "comments": [], "return_type": "NamedPat", "classes": []}, "name": "accept", "params": [{"name": "shuttle", "type": "Shuttle"}], "body": "", "signature": "@Override public abstract NamedPat accept(Shuttle shuttle)"}]}, {"original_string": "  public static class IdPat extends NamedPat {\n    IdPat(Type type, String name, int i) {\n      super(Op.ID_PAT, type, name, i);\n    }\n\n    @Override public int hashCode() {\n      return name.hashCode() + i;\n    }\n\n    @Override public boolean equals(Object obj) {\n      return obj == this\n          || obj instanceof IdPat\n          && ((IdPat) obj).name.equals(name)\n          && ((IdPat) obj).i == i;\n    }\n\n    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      return w.id(name, i);\n    }\n\n    @Override public IdPat accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }\n\n    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }\n\n    @Override public IdPat withType(Type type) {\n      return type == this.type ? this : new IdPat(type, name, i);\n    }\n  }", "definition": "  public static class IdPat extends NamedPat", "class_docstring": " Named pattern.\n\n@see Ast.Id", "name": "IdPat", "super_interfaces": [], "superclasses": "NamedPat", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    IdPat(Type type, String name, int i) {\n      super(Op.ID_PAT, type, name, i);\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "IdPat", "params": [{"name": "type", "type": "Type"}, {"name": "name", "type": "String"}, {"name": "i", "type": "int"}], "body": "                                         {\n      super(Op.ID_PAT, type, name, i);\n    }", "signature": "IdPat(Type type, String name, int i)"}, {"syntax_pass": true, "original_string": "    @Override public int hashCode() {\n      return name.hashCode() + i;\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "hashCode", "params": [], "body": "                                    {\n      return name.hashCode() + i;\n    }", "signature": "@Override public int hashCode()"}, {"syntax_pass": true, "original_string": "    @Override public boolean equals(Object obj) {\n      return obj == this\n          || obj instanceof IdPat\n          && ((IdPat) obj).name.equals(name)\n          && ((IdPat) obj).i == i;\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "equals", "params": [{"name": "obj", "type": "Object"}], "body": "                                                {\n      return obj == this\n          || obj instanceof IdPat\n          && ((IdPat) obj).name.equals(name)\n          && ((IdPat) obj).i == i;\n    }", "signature": "@Override public boolean equals(Object obj)"}, {"syntax_pass": true, "original_string": "    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      return w.id(name, i);\n    }", "docstring": "", "attributes": {"modifiers": "@Override", "marker_annotations": ["@Override"], "non_marker_annotations": [], "comments": [], "return_type": "AstWriter", "classes": []}, "name": "unparse", "params": [{"name": "w", "type": "AstWriter"}, {"name": "left", "type": "int"}, {"name": "right", "type": "int"}], "body": "                                                                  {\n      return w.id(name, i);\n    }", "signature": "@Override AstWriter unparse(AstWriter w, int left, int right)"}, {"syntax_pass": true, "original_string": "    @Override public IdPat accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "IdPat", "classes": []}, "name": "accept", "params": [{"name": "shuttle", "type": "Shuttle"}], "body": "                                                   {\n      return shuttle.visit(this);\n    }", "signature": "@Override public IdPat accept(Shuttle shuttle)"}, {"syntax_pass": true, "original_string": "    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "accept", "params": [{"name": "visitor", "type": "Visitor"}], "body": "                                                  {\n      visitor.visit(this);\n    }", "signature": "@Override public void accept(Visitor visitor)"}, {"syntax_pass": true, "original_string": "    @Override public IdPat withType(Type type) {\n      return type == this.type ? this : new IdPat(type, name, i);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "IdPat", "classes": []}, "name": "withType", "params": [{"name": "type", "type": "Type"}], "body": "                                               {\n      return type == this.type ? this : new IdPat(type, name, i);\n    }", "signature": "@Override public IdPat withType(Type type)"}]}, {"original_string": "  @SuppressWarnings(\"rawtypes\")\n  public static class LiteralPat extends Pat {\n    public final Comparable value;\n\n    LiteralPat(Op op, Type type, Comparable value) {\n      super(op, type);\n      this.value = requireNonNull(value);\n      checkArgument(op == Op.BOOL_LITERAL_PAT\n          || op == Op.CHAR_LITERAL_PAT\n          || op == Op.INT_LITERAL_PAT\n          || op == Op.REAL_LITERAL_PAT\n          || op == Op.STRING_LITERAL_PAT);\n    }\n\n    @Override public int hashCode() {\n      return value.hashCode();\n    }\n\n    @Override public boolean equals(Object o) {\n      return o == this\n          || o instanceof LiteralPat\n          && this.value.equals(((LiteralPat) o).value);\n    }\n\n    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      return w.appendLiteral(value);\n    }\n\n    @Override public Pat accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }\n\n    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }\n  }", "definition": "  @SuppressWarnings(\"rawtypes\")\n  public static class LiteralPat extends Pat", "class_docstring": " Literal pattern, the pattern analog of the {@link Literal} expression.\n\n<p>For example, \"0\" in \"fun fact 0 = 1 | fact n = n * fact (n - 1)\".", "name": "LiteralPat", "super_interfaces": [], "superclasses": "Pat", "attributes": {"modifiers": "@SuppressWarnings(\"rawtypes\")\n  public static", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings(\"rawtypes\")", "public", "static"], "comments": [], "fields": [{"attribute_expression": "public final Comparable value;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "Comparable", "name": "value", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    LiteralPat(Op op, Type type, Comparable value) {\n      super(op, type);\n      this.value = requireNonNull(value);\n      checkArgument(op == Op.BOOL_LITERAL_PAT\n          || op == Op.CHAR_LITERAL_PAT\n          || op == Op.INT_LITERAL_PAT\n          || op == Op.REAL_LITERAL_PAT\n          || op == Op.STRING_LITERAL_PAT);\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "LiteralPat", "params": [{"name": "op", "type": "Op"}, {"name": "type", "type": "Type"}, {"name": "value", "type": "Comparable"}], "body": "                                                   {\n      super(op, type);\n      this.value = requireNonNull(value);\n      checkArgument(op == Op.BOOL_LITERAL_PAT\n          || op == Op.CHAR_LITERAL_PAT\n          || op == Op.INT_LITERAL_PAT\n          || op == Op.REAL_LITERAL_PAT\n          || op == Op.STRING_LITERAL_PAT);\n    }", "signature": "LiteralPat(Op op, Type type, Comparable value)"}, {"syntax_pass": true, "original_string": "    @Override public int hashCode() {\n      return value.hashCode();\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "hashCode", "params": [], "body": "                                    {\n      return value.hashCode();\n    }", "signature": "@Override public int hashCode()"}, {"syntax_pass": true, "original_string": "    @Override public boolean equals(Object o) {\n      return o == this\n          || o instanceof LiteralPat\n          && this.value.equals(((LiteralPat) o).value);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "equals", "params": [{"name": "o", "type": "Object"}], "body": "                                              {\n      return o == this\n          || o instanceof LiteralPat\n          && this.value.equals(((LiteralPat) o).value);\n    }", "signature": "@Override public boolean equals(Object o)"}, {"syntax_pass": true, "original_string": "    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      return w.appendLiteral(value);\n    }", "docstring": "", "attributes": {"modifiers": "@Override", "marker_annotations": ["@Override"], "non_marker_annotations": [], "comments": [], "return_type": "AstWriter", "classes": []}, "name": "unparse", "params": [{"name": "w", "type": "AstWriter"}, {"name": "left", "type": "int"}, {"name": "right", "type": "int"}], "body": "                                                                  {\n      return w.appendLiteral(value);\n    }", "signature": "@Override AstWriter unparse(AstWriter w, int left, int right)"}, {"syntax_pass": true, "original_string": "    @Override public Pat accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Pat", "classes": []}, "name": "accept", "params": [{"name": "shuttle", "type": "Shuttle"}], "body": "                                                 {\n      return shuttle.visit(this);\n    }", "signature": "@Override public Pat accept(Shuttle shuttle)"}, {"syntax_pass": true, "original_string": "    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "accept", "params": [{"name": "visitor", "type": "Visitor"}], "body": "                                                  {\n      visitor.visit(this);\n    }", "signature": "@Override public void accept(Visitor visitor)"}]}, {"original_string": "  public static class WildcardPat extends Pat {\n    WildcardPat(Type type) {\n      super(Op.WILDCARD_PAT, type);\n    }\n\n    @Override public int hashCode() {\n      return \"_\".hashCode();\n    }\n\n    @Override public boolean equals(Object o) {\n      return o instanceof WildcardPat;\n    }\n\n    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      return w.append(\"_\");\n    }\n\n    @Override public Pat accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }\n\n    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }\n  }", "definition": "  public static class WildcardPat extends Pat", "class_docstring": " Wildcard pattern.\n\n<p>For example, \"{@code _}\" in \"{@code fn foo _ => 42}\".", "name": "WildcardPat", "super_interfaces": [], "superclasses": "Pat", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    WildcardPat(Type type) {\n      super(Op.WILDCARD_PAT, type);\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "WildcardPat", "params": [{"name": "type", "type": "Type"}], "body": "                           {\n      super(Op.WILDCARD_PAT, type);\n    }", "signature": "WildcardPat(Type type)"}, {"syntax_pass": true, "original_string": "    @Override public int hashCode() {\n      return \"_\".hashCode();\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "hashCode", "params": [], "body": "                                    {\n      return \"_\".hashCode();\n    }", "signature": "@Override public int hashCode()"}, {"syntax_pass": true, "original_string": "    @Override public boolean equals(Object o) {\n      return o instanceof WildcardPat;\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "equals", "params": [{"name": "o", "type": "Object"}], "body": "                                              {\n      return o instanceof WildcardPat;\n    }", "signature": "@Override public boolean equals(Object o)"}, {"syntax_pass": true, "original_string": "    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      return w.append(\"_\");\n    }", "docstring": "", "attributes": {"modifiers": "@Override", "marker_annotations": ["@Override"], "non_marker_annotations": [], "comments": [], "return_type": "AstWriter", "classes": []}, "name": "unparse", "params": [{"name": "w", "type": "AstWriter"}, {"name": "left", "type": "int"}, {"name": "right", "type": "int"}], "body": "                                                                  {\n      return w.append(\"_\");\n    }", "signature": "@Override AstWriter unparse(AstWriter w, int left, int right)"}, {"syntax_pass": true, "original_string": "    @Override public Pat accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Pat", "classes": []}, "name": "accept", "params": [{"name": "shuttle", "type": "Shuttle"}], "body": "                                                 {\n      return shuttle.visit(this);\n    }", "signature": "@Override public Pat accept(Shuttle shuttle)"}, {"syntax_pass": true, "original_string": "    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "accept", "params": [{"name": "visitor", "type": "Visitor"}], "body": "                                                  {\n      visitor.visit(this);\n    }", "signature": "@Override public void accept(Visitor visitor)"}]}, {"original_string": "  public static class AsPat extends NamedPat {\n    public final Pat pat;\n\n    protected AsPat(Type type, String name, int i, Pat pat) {\n      super(Op.AS_PAT, type, name, i);\n      this.pat = requireNonNull(pat);\n    }\n\n    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      return w.id(name).append(\" as \").append(pat, 0, 0);\n    }\n\n    @Override public AsPat withType(Type type) {\n      return type == this.type ? this : new AsPat(type, name, i, pat);\n    }\n\n    @Override public AsPat accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }\n\n    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }\n\n    /** Creates a copy of this {@code AsPat} with given contents,\n     * or {@code this} if the contents are the same. */\n    public Core.AsPat copy(String name, int i, Core.Pat pat) {\n      return this.name.equals(name)\n          && this.i == i\n          && this.pat.equals(pat)\n          ? this\n          : new AsPat(type, name, i, pat);\n    }\n  }", "definition": "  public static class AsPat extends NamedPat", "class_docstring": " Layered pattern.", "name": "AsPat", "super_interfaces": [], "superclasses": "NamedPat", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [{"attribute_expression": "public final Pat pat;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "Pat", "name": "pat", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    protected AsPat(Type type, String name, int i, Pat pat) {\n      super(Op.AS_PAT, type, name, i);\n      this.pat = requireNonNull(pat);\n    }", "docstring": "", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "", "classes": []}, "name": "AsPat", "params": [{"name": "type", "type": "Type"}, {"name": "name", "type": "String"}, {"name": "i", "type": "int"}, {"name": "pat", "type": "Pat"}], "body": "                                                            {\n      super(Op.AS_PAT, type, name, i);\n      this.pat = requireNonNull(pat);\n    }", "signature": "protected AsPat(Type type, String name, int i, Pat pat)"}, {"syntax_pass": true, "original_string": "    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      return w.id(name).append(\" as \").append(pat, 0, 0);\n    }", "docstring": "", "attributes": {"modifiers": "@Override", "marker_annotations": ["@Override"], "non_marker_annotations": [], "comments": [], "return_type": "AstWriter", "classes": []}, "name": "unparse", "params": [{"name": "w", "type": "AstWriter"}, {"name": "left", "type": "int"}, {"name": "right", "type": "int"}], "body": "                                                                  {\n      return w.id(name).append(\" as \").append(pat, 0, 0);\n    }", "signature": "@Override AstWriter unparse(AstWriter w, int left, int right)"}, {"syntax_pass": true, "original_string": "    @Override public AsPat withType(Type type) {\n      return type == this.type ? this : new AsPat(type, name, i, pat);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "AsPat", "classes": []}, "name": "withType", "params": [{"name": "type", "type": "Type"}], "body": "                                               {\n      return type == this.type ? this : new AsPat(type, name, i, pat);\n    }", "signature": "@Override public AsPat withType(Type type)"}, {"syntax_pass": true, "original_string": "    @Override public AsPat accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "AsPat", "classes": []}, "name": "accept", "params": [{"name": "shuttle", "type": "Shuttle"}], "body": "                                                   {\n      return shuttle.visit(this);\n    }", "signature": "@Override public AsPat accept(Shuttle shuttle)"}, {"syntax_pass": true, "original_string": "    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "accept", "params": [{"name": "visitor", "type": "Visitor"}], "body": "                                                  {\n      visitor.visit(this);\n    }", "signature": "@Override public void accept(Visitor visitor)"}, {"syntax_pass": true, "original_string": "    public Core.AsPat copy(String name, int i, Core.Pat pat) {\n      return this.name.equals(name)\n          && this.i == i\n          && this.pat.equals(pat)\n          ? this\n          : new AsPat(type, name, i, pat);\n    }", "docstring": " Creates a copy of this {@code AsPat} with given contents,\nor {@code this} if the contents are the same.", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Core.AsPat", "classes": []}, "name": "copy", "params": [{"name": "name", "type": "String"}, {"name": "i", "type": "int"}, {"name": "pat", "type": "Core.Pat"}], "body": "                                                             {\n      return this.name.equals(name)\n          && this.i == i\n          && this.pat.equals(pat)\n          ? this\n          : new AsPat(type, name, i, pat);\n    }", "signature": "public Core.AsPat copy(String name, int i, Core.Pat pat)"}]}, {"original_string": "  public static class ConPat extends Pat {\n    public final String tyCon;\n    public final Pat pat;\n\n    /** Mostly-private constructor.\n     *\n     * <p>Exposed so that \"op ::\" (cons) can supply a different {@link Op}\n     * value. The \"list\" datatype is not represented the same as other\n     * datatypes, and the separate \"op\" value allows us to deconstruct it in a\n     * different way. */\n    protected ConPat(Op op, Type type, String tyCon, Pat pat) {\n      super(op, type);\n      this.tyCon = requireNonNull(tyCon);\n      this.pat = requireNonNull(pat);\n      checkArgument(op == Op.CON_PAT || op == Op.CONS_PAT);\n    }\n\n    ConPat(Type type, String tyCon, Pat pat) {\n      this(Op.CON_PAT, type, tyCon, pat);\n    }\n\n    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      return w.id(tyCon).append(\"(\").append(pat, 0, 0).append(\")\");\n    }\n\n    @Override public Pat accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }\n\n    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }\n\n    /** Creates a copy of this {@code ConPat} with given contents,\n     * or {@code this} if the contents are the same. */\n    public Core.ConPat copy(String tyCon, Core.Pat pat) {\n      return this.tyCon.equals(tyCon)\n          && this.pat.equals(pat)\n          ? this\n          : new ConPat(op, type, tyCon, pat);\n    }\n  }", "definition": "  public static class ConPat extends Pat", "class_docstring": " Type constructor pattern with an argument.\n\n<p>For example, in \"fun nvl NIL = 0 | OPTION x = x\",\n\"OPTION x\" is a type constructor pattern that binds \"x\";\nand \"NIL\" is a type constructor pattern whose {@link #pat} is null.\n\n@see Con0Pat", "name": "ConPat", "super_interfaces": [], "superclasses": "Pat", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [{"attribute_expression": "public final String tyCon;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "String", "name": "tyCon", "syntax_pass": true}, {"attribute_expression": "public final Pat pat;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "Pat", "name": "pat", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    protected ConPat(Op op, Type type, String tyCon, Pat pat) {\n      super(op, type);\n      this.tyCon = requireNonNull(tyCon);\n      this.pat = requireNonNull(pat);\n      checkArgument(op == Op.CON_PAT || op == Op.CONS_PAT);\n    }", "docstring": " Mostly-private constructor.\n\n<p>Exposed so that \"op ::\" (cons) can supply a different {@link Op}\nvalue. The \"list\" datatype is not represented the same as other\ndatatypes, and the separate \"op\" value allows us to deconstruct it in a\ndifferent way.", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "", "classes": []}, "name": "ConPat", "params": [{"name": "op", "type": "Op"}, {"name": "type", "type": "Type"}, {"name": "tyCon", "type": "String"}, {"name": "pat", "type": "Pat"}], "body": "                                                              {\n      super(op, type);\n      this.tyCon = requireNonNull(tyCon);\n      this.pat = requireNonNull(pat);\n      checkArgument(op == Op.CON_PAT || op == Op.CONS_PAT);\n    }", "signature": "protected ConPat(Op op, Type type, String tyCon, Pat pat)"}, {"syntax_pass": true, "original_string": "    ConPat(Type type, String tyCon, Pat pat) {\n      this(Op.CON_PAT, type, tyCon, pat);\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "ConPat", "params": [{"name": "type", "type": "Type"}, {"name": "tyCon", "type": "String"}, {"name": "pat", "type": "Pat"}], "body": "                                             {\n      this(Op.CON_PAT, type, tyCon, pat);\n    }", "signature": "ConPat(Type type, String tyCon, Pat pat)"}, {"syntax_pass": true, "original_string": "    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      return w.id(tyCon).append(\"(\").append(pat, 0, 0).append(\")\");\n    }", "docstring": "", "attributes": {"modifiers": "@Override", "marker_annotations": ["@Override"], "non_marker_annotations": [], "comments": [], "return_type": "AstWriter", "classes": []}, "name": "unparse", "params": [{"name": "w", "type": "AstWriter"}, {"name": "left", "type": "int"}, {"name": "right", "type": "int"}], "body": "                                                                  {\n      return w.id(tyCon).append(\"(\").append(pat, 0, 0).append(\")\");\n    }", "signature": "@Override AstWriter unparse(AstWriter w, int left, int right)"}, {"syntax_pass": true, "original_string": "    @Override public Pat accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Pat", "classes": []}, "name": "accept", "params": [{"name": "shuttle", "type": "Shuttle"}], "body": "                                                 {\n      return shuttle.visit(this);\n    }", "signature": "@Override public Pat accept(Shuttle shuttle)"}, {"syntax_pass": true, "original_string": "    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "accept", "params": [{"name": "visitor", "type": "Visitor"}], "body": "                                                  {\n      visitor.visit(this);\n    }", "signature": "@Override public void accept(Visitor visitor)"}, {"syntax_pass": true, "original_string": "    public Core.ConPat copy(String tyCon, Core.Pat pat) {\n      return this.tyCon.equals(tyCon)\n          && this.pat.equals(pat)\n          ? this\n          : new ConPat(op, type, tyCon, pat);\n    }", "docstring": " Creates a copy of this {@code ConPat} with given contents,\nor {@code this} if the contents are the same.", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Core.ConPat", "classes": []}, "name": "copy", "params": [{"name": "tyCon", "type": "String"}, {"name": "pat", "type": "Core.Pat"}], "body": "                                                        {\n      return this.tyCon.equals(tyCon)\n          && this.pat.equals(pat)\n          ? this\n          : new ConPat(op, type, tyCon, pat);\n    }", "signature": "public Core.ConPat copy(String tyCon, Core.Pat pat)"}]}, {"original_string": "  public static class Con0Pat extends Pat {\n    public final String tyCon;\n\n    Con0Pat(DataType type, String tyCon) {\n      super(Op.CON0_PAT, type);\n      this.tyCon = requireNonNull(tyCon);\n    }\n\n    @Override public DataType type() {\n      return (DataType) type;\n    }\n\n    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      return w.id(tyCon);\n    }\n\n    @Override public Pat accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }\n\n    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }\n  }", "definition": "  public static class Con0Pat extends Pat", "class_docstring": " Type constructor pattern with no argument.\n\n<p>For example, in \"fun nvl NIL = 0 | OPTION x = x\",\n\"NIL\" is a zero-arg type constructor pattern.\n\n@see ConPat", "name": "Con0Pat", "super_interfaces": [], "superclasses": "Pat", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [{"attribute_expression": "public final String tyCon;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "String", "name": "tyCon", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    Con0Pat(DataType type, String tyCon) {\n      super(Op.CON0_PAT, type);\n      this.tyCon = requireNonNull(tyCon);\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "Con0Pat", "params": [{"name": "type", "type": "DataType"}, {"name": "tyCon", "type": "String"}], "body": "                                         {\n      super(Op.CON0_PAT, type);\n      this.tyCon = requireNonNull(tyCon);\n    }", "signature": "Con0Pat(DataType type, String tyCon)"}, {"syntax_pass": true, "original_string": "    @Override public DataType type() {\n      return (DataType) type;\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "DataType", "classes": []}, "name": "type", "params": [], "body": "                                     {\n      return (DataType) type;\n    }", "signature": "@Override public DataType type()"}, {"syntax_pass": true, "original_string": "    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      return w.id(tyCon);\n    }", "docstring": "", "attributes": {"modifiers": "@Override", "marker_annotations": ["@Override"], "non_marker_annotations": [], "comments": [], "return_type": "AstWriter", "classes": []}, "name": "unparse", "params": [{"name": "w", "type": "AstWriter"}, {"name": "left", "type": "int"}, {"name": "right", "type": "int"}], "body": "                                                                  {\n      return w.id(tyCon);\n    }", "signature": "@Override AstWriter unparse(AstWriter w, int left, int right)"}, {"syntax_pass": true, "original_string": "    @Override public Pat accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Pat", "classes": []}, "name": "accept", "params": [{"name": "shuttle", "type": "Shuttle"}], "body": "                                                 {\n      return shuttle.visit(this);\n    }", "signature": "@Override public Pat accept(Shuttle shuttle)"}, {"syntax_pass": true, "original_string": "    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "accept", "params": [{"name": "visitor", "type": "Visitor"}], "body": "                                                  {\n      visitor.visit(this);\n    }", "signature": "@Override public void accept(Visitor visitor)"}]}, {"original_string": "  public static class TuplePat extends Pat {\n    public final List<Pat> args;\n\n    /** Creates a TuplePat.\n     *\n     * <p>Type is {@link PrimitiveType#UNIT} if {@code args} is empty,\n     * otherwise a {@link TupleType}. */\n    TuplePat(RecordLikeType type, ImmutableList<Pat> args) {\n      super(Op.TUPLE_PAT, type);\n      this.args = requireNonNull(args);\n      checkArgument(args.size() == type.argNameTypes().size());\n      checkArgument(args.isEmpty()\n          ? type == PrimitiveType.UNIT\n          : type instanceof TupleType);\n    }\n\n    @Override public RecordLikeType type() {\n      return (RecordLikeType) type;\n    }\n\n    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      w.append(\"(\");\n      forEachIndexed(args, (arg, i) ->\n          w.append(i == 0 ? \"\" : \", \").append(arg, 0, 0));\n      return w.append(\")\");\n    }\n\n    @Override public Pat accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }\n\n    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }\n\n    public TuplePat copy(TypeSystem typeSystem, List<Pat> args) {\n      return args.equals(this.args) ? this\n          : core.tuplePat(typeSystem, args);\n    }\n\n    /** Returns the names of all components that are named. */\n    public List<String> fieldNames() {\n      final ImmutableList.Builder<String> names = ImmutableList.builder();\n      for (Pat arg : args) {\n        if (arg instanceof NamedPat) {\n          names.add(((NamedPat) arg).name);\n        }\n      }\n      return names.build();\n    }\n  }", "definition": "  public static class TuplePat extends Pat", "class_docstring": " Tuple pattern, the pattern analog of the {@link Tuple} expression.\n\n<p>For example, \"(x, y)\" in \"fun sum (x, y) = x + y\".", "name": "TuplePat", "super_interfaces": [], "superclasses": "Pat", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [{"attribute_expression": "public final List<Pat> args;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "List<Pat>", "name": "args", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    TuplePat(RecordLikeType type, ImmutableList<Pat> args) {\n      super(Op.TUPLE_PAT, type);\n      this.args = requireNonNull(args);\n      checkArgument(args.size() == type.argNameTypes().size());\n      checkArgument(args.isEmpty()\n          ? type == PrimitiveType.UNIT\n          : type instanceof TupleType);\n    }", "docstring": " Creates a TuplePat.\n\n<p>Type is {@link PrimitiveType#UNIT} if {@code args} is empty,\notherwise a {@link TupleType}.", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "TuplePat", "params": [{"name": "type", "type": "RecordLikeType"}, {"name": "args", "type": "ImmutableList<Pat>"}], "body": "                                                           {\n      super(Op.TUPLE_PAT, type);\n      this.args = requireNonNull(args);\n      checkArgument(args.size() == type.argNameTypes().size());\n      checkArgument(args.isEmpty()\n          ? type == PrimitiveType.UNIT\n          : type instanceof TupleType);\n    }", "signature": "TuplePat(RecordLikeType type, ImmutableList<Pat> args)"}, {"syntax_pass": true, "original_string": "    @Override public RecordLikeType type() {\n      return (RecordLikeType) type;\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "RecordLikeType", "classes": []}, "name": "type", "params": [], "body": "                                           {\n      return (RecordLikeType) type;\n    }", "signature": "@Override public RecordLikeType type()"}, {"syntax_pass": true, "original_string": "    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      w.append(\"(\");\n      forEachIndexed(args, (arg, i) ->\n          w.append(i == 0 ? \"\" : \", \").append(arg, 0, 0));\n      return w.append(\")\");\n    }", "docstring": "", "attributes": {"modifiers": "@Override", "marker_annotations": ["@Override"], "non_marker_annotations": [], "comments": [], "return_type": "AstWriter", "classes": []}, "name": "unparse", "params": [{"name": "w", "type": "AstWriter"}, {"name": "left", "type": "int"}, {"name": "right", "type": "int"}], "body": "                                                                  {\n      w.append(\"(\");\n      forEachIndexed(args, (arg, i) ->\n          w.append(i == 0 ? \"\" : \", \").append(arg, 0, 0));\n      return w.append(\")\");\n    }", "signature": "@Override AstWriter unparse(AstWriter w, int left, int right)"}, {"syntax_pass": true, "original_string": "    @Override public Pat accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Pat", "classes": []}, "name": "accept", "params": [{"name": "shuttle", "type": "Shuttle"}], "body": "                                                 {\n      return shuttle.visit(this);\n    }", "signature": "@Override public Pat accept(Shuttle shuttle)"}, {"syntax_pass": true, "original_string": "    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "accept", "params": [{"name": "visitor", "type": "Visitor"}], "body": "                                                  {\n      visitor.visit(this);\n    }", "signature": "@Override public void accept(Visitor visitor)"}, {"syntax_pass": true, "original_string": "    public TuplePat copy(TypeSystem typeSystem, List<Pat> args) {\n      return args.equals(this.args) ? this\n          : core.tuplePat(typeSystem, args);\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "TuplePat", "classes": []}, "name": "copy", "params": [{"name": "typeSystem", "type": "TypeSystem"}, {"name": "args", "type": "List<Pat>"}], "body": "                                                                {\n      return args.equals(this.args) ? this\n          : core.tuplePat(typeSystem, args);\n    }", "signature": "public TuplePat copy(TypeSystem typeSystem, List<Pat> args)"}, {"syntax_pass": true, "original_string": "    public List<String> fieldNames() {\n      final ImmutableList.Builder<String> names = ImmutableList.builder();\n      for (Pat arg : args) {\n        if (arg instanceof NamedPat) {\n          names.add(((NamedPat) arg).name);\n        }\n      }\n      return names.build();\n    }", "docstring": " Returns the names of all components that are named.", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "List<String>", "classes": []}, "name": "fieldNames", "params": [], "body": "                                     {\n      final ImmutableList.Builder<String> names = ImmutableList.builder();\n      for (Pat arg : args) {\n        if (arg instanceof NamedPat) {\n          names.add(((NamedPat) arg).name);\n        }\n      }\n      return names.build();\n    }", "signature": "public List<String> fieldNames()"}]}, {"original_string": "  public static class ListPat extends Pat {\n    public final List<Pat> args;\n\n    ListPat(Type type, ImmutableList<Pat> args) {\n      super(Op.LIST_PAT, type);\n      this.args = requireNonNull(args);\n    }\n\n    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      w.append(\"[\");\n      forEachIndexed(args, (arg, i) ->\n          w.append(i == 0 ? \"\" : \", \").append(arg, 0, 0));\n      return w.append(\"]\");\n    }\n\n    @Override public Pat accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }\n\n    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }\n\n    public ListPat copy(TypeSystem typeSystem, List<Pat> args) {\n      return args.equals(this.args) ? this\n          : core.listPat(typeSystem, args);\n    }\n  }", "definition": "  public static class ListPat extends Pat", "class_docstring": " List pattern.\n\n<p>For example, \"[x, y]\" in \"fun sum [x, y] = x + y\".", "name": "ListPat", "super_interfaces": [], "superclasses": "Pat", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [{"attribute_expression": "public final List<Pat> args;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "List<Pat>", "name": "args", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    ListPat(Type type, ImmutableList<Pat> args) {\n      super(Op.LIST_PAT, type);\n      this.args = requireNonNull(args);\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "ListPat", "params": [{"name": "type", "type": "Type"}, {"name": "args", "type": "ImmutableList<Pat>"}], "body": "                                                {\n      super(Op.LIST_PAT, type);\n      this.args = requireNonNull(args);\n    }", "signature": "ListPat(Type type, ImmutableList<Pat> args)"}, {"syntax_pass": true, "original_string": "    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      w.append(\"[\");\n      forEachIndexed(args, (arg, i) ->\n          w.append(i == 0 ? \"\" : \", \").append(arg, 0, 0));\n      return w.append(\"]\");\n    }", "docstring": "", "attributes": {"modifiers": "@Override", "marker_annotations": ["@Override"], "non_marker_annotations": [], "comments": [], "return_type": "AstWriter", "classes": []}, "name": "unparse", "params": [{"name": "w", "type": "AstWriter"}, {"name": "left", "type": "int"}, {"name": "right", "type": "int"}], "body": "                                                                  {\n      w.append(\"[\");\n      forEachIndexed(args, (arg, i) ->\n          w.append(i == 0 ? \"\" : \", \").append(arg, 0, 0));\n      return w.append(\"]\");\n    }", "signature": "@Override AstWriter unparse(AstWriter w, int left, int right)"}, {"syntax_pass": true, "original_string": "    @Override public Pat accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Pat", "classes": []}, "name": "accept", "params": [{"name": "shuttle", "type": "Shuttle"}], "body": "                                                 {\n      return shuttle.visit(this);\n    }", "signature": "@Override public Pat accept(Shuttle shuttle)"}, {"syntax_pass": true, "original_string": "    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "accept", "params": [{"name": "visitor", "type": "Visitor"}], "body": "                                                  {\n      visitor.visit(this);\n    }", "signature": "@Override public void accept(Visitor visitor)"}, {"syntax_pass": true, "original_string": "    public ListPat copy(TypeSystem typeSystem, List<Pat> args) {\n      return args.equals(this.args) ? this\n          : core.listPat(typeSystem, args);\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ListPat", "classes": []}, "name": "copy", "params": [{"name": "typeSystem", "type": "TypeSystem"}, {"name": "args", "type": "List<Pat>"}], "body": "                                                               {\n      return args.equals(this.args) ? this\n          : core.listPat(typeSystem, args);\n    }", "signature": "public ListPat copy(TypeSystem typeSystem, List<Pat> args)"}]}, {"original_string": "  public static class RecordPat extends Pat {\n    public final List<Pat> args;\n\n    RecordPat(RecordType type, ImmutableList<Pat> args) {\n      super(Op.RECORD_PAT, type);\n      this.args = requireNonNull(args);\n      checkArgument(args.size() == type.argNameTypes.size());\n    }\n\n    @Override public RecordType type() {\n      return (RecordType) type;\n    }\n\n    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      w.append(\"{\");\n      forEachIndexed(type().argNameTypes.keySet(), args,\n          (i, name, arg) ->\n              w.append(i > 0 ? \", \" : \"\").append(name)\n                  .append(\" = \").append(arg, 0, 0));\n      return w.append(\"}\");\n    }\n\n    @Override public Pat accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }\n\n    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }\n\n    public Pat copy(TypeSystem typeSystem, Set<String> argNames,\n        List<Pat> args) {\n      return args.equals(this.args) ? this\n          : core.recordPat(typeSystem, argNames, args);\n    }\n  }", "definition": "  public static class RecordPat extends Pat", "class_docstring": " Record pattern.", "name": "RecordPat", "super_interfaces": [], "superclasses": "Pat", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [{"attribute_expression": "public final List<Pat> args;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "List<Pat>", "name": "args", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    RecordPat(RecordType type, ImmutableList<Pat> args) {\n      super(Op.RECORD_PAT, type);\n      this.args = requireNonNull(args);\n      checkArgument(args.size() == type.argNameTypes.size());\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "RecordPat", "params": [{"name": "type", "type": "RecordType"}, {"name": "args", "type": "ImmutableList<Pat>"}], "body": "                                                        {\n      super(Op.RECORD_PAT, type);\n      this.args = requireNonNull(args);\n      checkArgument(args.size() == type.argNameTypes.size());\n    }", "signature": "RecordPat(RecordType type, ImmutableList<Pat> args)"}, {"syntax_pass": true, "original_string": "    @Override public RecordType type() {\n      return (RecordType) type;\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "RecordType", "classes": []}, "name": "type", "params": [], "body": "                                       {\n      return (RecordType) type;\n    }", "signature": "@Override public RecordType type()"}, {"syntax_pass": true, "original_string": "    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      w.append(\"{\");\n      forEachIndexed(type().argNameTypes.keySet(), args,\n          (i, name, arg) ->\n              w.append(i > 0 ? \", \" : \"\").append(name)\n                  .append(\" = \").append(arg, 0, 0));\n      return w.append(\"}\");\n    }", "docstring": "", "attributes": {"modifiers": "@Override", "marker_annotations": ["@Override"], "non_marker_annotations": [], "comments": [], "return_type": "AstWriter", "classes": []}, "name": "unparse", "params": [{"name": "w", "type": "AstWriter"}, {"name": "left", "type": "int"}, {"name": "right", "type": "int"}], "body": "                                                                  {\n      w.append(\"{\");\n      forEachIndexed(type().argNameTypes.keySet(), args,\n          (i, name, arg) ->\n              w.append(i > 0 ? \", \" : \"\").append(name)\n                  .append(\" = \").append(arg, 0, 0));\n      return w.append(\"}\");\n    }", "signature": "@Override AstWriter unparse(AstWriter w, int left, int right)"}, {"syntax_pass": true, "original_string": "    @Override public Pat accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Pat", "classes": []}, "name": "accept", "params": [{"name": "shuttle", "type": "Shuttle"}], "body": "                                                 {\n      return shuttle.visit(this);\n    }", "signature": "@Override public Pat accept(Shuttle shuttle)"}, {"syntax_pass": true, "original_string": "    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "accept", "params": [{"name": "visitor", "type": "Visitor"}], "body": "                                                  {\n      visitor.visit(this);\n    }", "signature": "@Override public void accept(Visitor visitor)"}, {"syntax_pass": true, "original_string": "    public Pat copy(TypeSystem typeSystem, Set<String> argNames,\n        List<Pat> args) {\n      return args.equals(this.args) ? this\n          : core.recordPat(typeSystem, argNames, args);\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Pat", "classes": []}, "name": "copy", "params": [{"name": "typeSystem", "type": "TypeSystem"}, {"name": "argNames", "type": "Set<String>"}, {"name": "args", "type": "List<Pat>"}], "body": "                        {\n      return args.equals(this.args) ? this\n          : core.recordPat(typeSystem, argNames, args);\n    }", "signature": "public Pat copy(TypeSystem typeSystem, Set<String> argNames,\n        List<Pat> args)"}]}, {"original_string": "  public abstract static class Exp extends BaseNode {\n    public final Type type;\n\n    Exp(Pos pos, Op op, Type type) {\n      super(pos, op);\n      this.type = requireNonNull(type);\n    }\n\n    public void forEachArg(ObjIntConsumer<Exp> action) {\n      // no args\n    }\n\n    /** Returns the {@code i}<sup>th</sup> argument. */\n    public Exp arg(int i) {\n      throw new UnsupportedOperationException();\n    }\n\n    /** Returns the type. */\n    public Type type() {\n      return type;\n    }\n\n    @Override public abstract Exp accept(Shuttle shuttle);\n\n    /** Returns whether this expression is a constant.\n     *\n     * <p>Examples include literals {@code 1}, {@code true},\n     * constructors applied to constants,\n     * records and tuples whose arguments are constant.\n     */\n    public boolean isConstant() {\n      return false;\n    }\n\n    /** Returns whether this expression is a call to the given built-in. */\n    public boolean isCallTo(BuiltIn builtIn) {\n      return false;\n    }\n  }", "definition": "  public abstract static class Exp extends BaseNode", "class_docstring": " Base class of core expressions.", "name": "Exp", "super_interfaces": [], "superclasses": "BaseNode", "attributes": {"modifiers": "public abstract static", "marker_annotations": [], "non_marker_annotations": ["public", "abstract", "static"], "comments": [], "fields": [{"attribute_expression": "public final Type type;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "Type", "name": "type", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    Exp(Pos pos, Op op, Type type) {\n      super(pos, op);\n      this.type = requireNonNull(type);\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "Exp", "params": [{"name": "pos", "type": "Pos"}, {"name": "op", "type": "Op"}, {"name": "type", "type": "Type"}], "body": "                                   {\n      super(pos, op);\n      this.type = requireNonNull(type);\n    }", "signature": "Exp(Pos pos, Op op, Type type)"}, {"syntax_pass": true, "original_string": "    public void forEachArg(ObjIntConsumer<Exp> action) {\n      // no args\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "forEachArg", "params": [{"name": "action", "type": "ObjIntConsumer<Exp>"}], "body": "                                                       {\n      // no args\n    }", "signature": "public void forEachArg(ObjIntConsumer<Exp> action)"}, {"syntax_pass": true, "original_string": "    public Exp arg(int i) {\n      throw new UnsupportedOperationException();\n    }", "docstring": " Returns the {@code i}<sup>th</sup> argument.", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Exp", "classes": []}, "name": "arg", "params": [{"name": "i", "type": "int"}], "body": "                          {\n      throw new UnsupportedOperationException();\n    }", "signature": "public Exp arg(int i)"}, {"syntax_pass": true, "original_string": "    public Type type() {\n      return type;\n    }", "docstring": " Returns the type.", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Type", "classes": []}, "name": "type", "params": [], "body": "                       {\n      return type;\n    }", "signature": "public Type type()"}, {"syntax_pass": true, "original_string": "    @Override public abstract Exp accept(Shuttle shuttle);", "docstring": "", "attributes": {"modifiers": "@Override public abstract", "marker_annotations": ["@Override"], "non_marker_annotations": ["public", "abstract"], "comments": [], "return_type": "Exp", "classes": []}, "name": "accept", "params": [{"name": "shuttle", "type": "Shuttle"}], "body": "", "signature": "@Override public abstract Exp accept(Shuttle shuttle)"}, {"syntax_pass": true, "original_string": "    public boolean isConstant() {\n      return false;\n    }", "docstring": " Returns whether this expression is a constant.\n\n<p>Examples include literals {@code 1}, {@code true},\nconstructors applied to constants,\nrecords and tuples whose arguments are constant.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isConstant", "params": [], "body": "                                {\n      return false;\n    }", "signature": "public boolean isConstant()"}, {"syntax_pass": true, "original_string": "    public boolean isCallTo(BuiltIn builtIn) {\n      return false;\n    }", "docstring": " Returns whether this expression is a call to the given built-in.", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isCallTo", "params": [{"name": "builtIn", "type": "BuiltIn"}], "body": "                                             {\n      return false;\n    }", "signature": "public boolean isCallTo(BuiltIn builtIn)"}]}, {"original_string": "  public static class Id extends Exp implements Comparable<Id> {\n    public final NamedPat idPat;\n\n    /** Creates an Id. */\n    Id(NamedPat idPat) {\n      super(Pos.ZERO, Op.ID, idPat.type);\n      this.idPat = requireNonNull(idPat);\n    }\n\n    @Override public int compareTo(Id o) {\n      return idPat.compareTo(o.idPat);\n    }\n\n    @Override public int hashCode() {\n      return idPat.hashCode();\n    }\n\n    @Override public boolean equals(Object o) {\n      return o == this\n          || o instanceof Id\n          && this.idPat.equals(((Id) o).idPat);\n    }\n\n    @Override public Exp accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }\n\n    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }\n\n    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      return w.id(idPat.name, idPat.i);\n    }\n  }", "definition": "  public static class Id extends Exp implements Comparable<Id>", "class_docstring": " Reference to a variable.\n\n<p>While {@link Ast.Id} is widely used, and means an occurrence of a name\nin the parse tree, {@code Id} is much narrower: it means a reference to a\nvalue. What would be an {@code Id} in Ast is often a {@link String} in\nCore; for example, compare {@link Ast.Con0Pat#tyCon}\nwith {@link Con0Pat#tyCon}.", "name": "Id", "super_interfaces": ["Comparable<Id>"], "superclasses": "Exp", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [{"attribute_expression": "public final NamedPat idPat;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "NamedPat", "name": "idPat", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    Id(NamedPat idPat) {\n      super(Pos.ZERO, Op.ID, idPat.type);\n      this.idPat = requireNonNull(idPat);\n    }", "docstring": " Creates an Id.", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "Id", "params": [{"name": "idPat", "type": "NamedPat"}], "body": "                       {\n      super(Pos.ZERO, Op.ID, idPat.type);\n      this.idPat = requireNonNull(idPat);\n    }", "signature": "Id(NamedPat idPat)"}, {"syntax_pass": true, "original_string": "    @Override public int compareTo(Id o) {\n      return idPat.compareTo(o.idPat);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "compareTo", "params": [{"name": "o", "type": "Id"}], "body": "                                         {\n      return idPat.compareTo(o.idPat);\n    }", "signature": "@Override public int compareTo(Id o)"}, {"syntax_pass": true, "original_string": "    @Override public int hashCode() {\n      return idPat.hashCode();\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "hashCode", "params": [], "body": "                                    {\n      return idPat.hashCode();\n    }", "signature": "@Override public int hashCode()"}, {"syntax_pass": true, "original_string": "    @Override public boolean equals(Object o) {\n      return o == this\n          || o instanceof Id\n          && this.idPat.equals(((Id) o).idPat);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "equals", "params": [{"name": "o", "type": "Object"}], "body": "                                              {\n      return o == this\n          || o instanceof Id\n          && this.idPat.equals(((Id) o).idPat);\n    }", "signature": "@Override public boolean equals(Object o)"}, {"syntax_pass": true, "original_string": "    @Override public Exp accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Exp", "classes": []}, "name": "accept", "params": [{"name": "shuttle", "type": "Shuttle"}], "body": "                                                 {\n      return shuttle.visit(this);\n    }", "signature": "@Override public Exp accept(Shuttle shuttle)"}, {"syntax_pass": true, "original_string": "    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "accept", "params": [{"name": "visitor", "type": "Visitor"}], "body": "                                                  {\n      visitor.visit(this);\n    }", "signature": "@Override public void accept(Visitor visitor)"}, {"syntax_pass": true, "original_string": "    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      return w.id(idPat.name, idPat.i);\n    }", "docstring": "", "attributes": {"modifiers": "@Override", "marker_annotations": ["@Override"], "non_marker_annotations": [], "comments": [], "return_type": "AstWriter", "classes": []}, "name": "unparse", "params": [{"name": "w", "type": "AstWriter"}, {"name": "left", "type": "int"}, {"name": "right", "type": "int"}], "body": "                                                                  {\n      return w.id(idPat.name, idPat.i);\n    }", "signature": "@Override AstWriter unparse(AstWriter w, int left, int right)"}]}, {"original_string": "  public static class RecordSelector extends Exp {\n    /** The ordinal of the field in the record or tuple that is to be\n     * accessed. */\n    public final int slot;\n\n    /** Creates a record selector. */\n    RecordSelector(FnType fnType, int slot) {\n      super(Pos.ZERO, Op.RECORD_SELECTOR, fnType);\n      this.slot = slot;\n    }\n\n    @Override public int hashCode() {\n      return slot + 2237;\n    }\n\n    @Override public boolean equals(Object o) {\n      return o == this\n          || o instanceof RecordSelector\n          && this.slot == ((RecordSelector) o).slot\n          && this.type.equals(((RecordSelector) o).type);\n    }\n\n    public String fieldName() {\n      final RecordLikeType recordType = (RecordLikeType) type().paramType;\n      return Iterables.get(recordType.argNameTypes().keySet(), slot);\n    }\n\n    @Override public FnType type() {\n      return (FnType) type;\n    }\n\n    @Override public RecordSelector accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }\n\n    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }\n\n    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      return w.append(\"#\").append(fieldName());\n    }\n  }", "definition": "  public static class RecordSelector extends Exp", "class_docstring": " Record selector function.", "name": "RecordSelector", "super_interfaces": [], "superclasses": "Exp", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [{"attribute_expression": "public final int slot;", "docstring": " The ordinal of the field in the record or tuple that is to be\naccessed.", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "int", "name": "slot", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    RecordSelector(FnType fnType, int slot) {\n      super(Pos.ZERO, Op.RECORD_SELECTOR, fnType);\n      this.slot = slot;\n    }", "docstring": " Creates a record selector.", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "RecordSelector", "params": [{"name": "fnType", "type": "FnType"}, {"name": "slot", "type": "int"}], "body": "                                            {\n      super(Pos.ZERO, Op.RECORD_SELECTOR, fnType);\n      this.slot = slot;\n    }", "signature": "RecordSelector(FnType fnType, int slot)"}, {"syntax_pass": true, "original_string": "    @Override public int hashCode() {\n      return slot + 2237;\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "hashCode", "params": [], "body": "                                    {\n      return slot + 2237;\n    }", "signature": "@Override public int hashCode()"}, {"syntax_pass": true, "original_string": "    @Override public boolean equals(Object o) {\n      return o == this\n          || o instanceof RecordSelector\n          && this.slot == ((RecordSelector) o).slot\n          && this.type.equals(((RecordSelector) o).type);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "equals", "params": [{"name": "o", "type": "Object"}], "body": "                                              {\n      return o == this\n          || o instanceof RecordSelector\n          && this.slot == ((RecordSelector) o).slot\n          && this.type.equals(((RecordSelector) o).type);\n    }", "signature": "@Override public boolean equals(Object o)"}, {"syntax_pass": true, "original_string": "    public String fieldName() {\n      final RecordLikeType recordType = (RecordLikeType) type().paramType;\n      return Iterables.get(recordType.argNameTypes().keySet(), slot);\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "fieldName", "params": [], "body": "                              {\n      final RecordLikeType recordType = (RecordLikeType) type().paramType;\n      return Iterables.get(recordType.argNameTypes().keySet(), slot);\n    }", "signature": "public String fieldName()"}, {"syntax_pass": true, "original_string": "    @Override public FnType type() {\n      return (FnType) type;\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "FnType", "classes": []}, "name": "type", "params": [], "body": "                                   {\n      return (FnType) type;\n    }", "signature": "@Override public FnType type()"}, {"syntax_pass": true, "original_string": "    @Override public RecordSelector accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "RecordSelector", "classes": []}, "name": "accept", "params": [{"name": "shuttle", "type": "Shuttle"}], "body": "                                                            {\n      return shuttle.visit(this);\n    }", "signature": "@Override public RecordSelector accept(Shuttle shuttle)"}, {"syntax_pass": true, "original_string": "    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "accept", "params": [{"name": "visitor", "type": "Visitor"}], "body": "                                                  {\n      visitor.visit(this);\n    }", "signature": "@Override public void accept(Visitor visitor)"}, {"syntax_pass": true, "original_string": "    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      return w.append(\"#\").append(fieldName());\n    }", "docstring": "", "attributes": {"modifiers": "@Override", "marker_annotations": ["@Override"], "non_marker_annotations": [], "comments": [], "return_type": "AstWriter", "classes": []}, "name": "unparse", "params": [{"name": "w", "type": "AstWriter"}, {"name": "left", "type": "int"}, {"name": "right", "type": "int"}], "body": "                                                                  {\n      return w.append(\"#\").append(fieldName());\n    }", "signature": "@Override AstWriter unparse(AstWriter w, int left, int right)"}]}, {"original_string": "  @SuppressWarnings(\"rawtypes\")\n  public static class Literal extends Exp {\n    public final Comparable value;\n\n    /** Creates a Literal. */\n    Literal(Op op, Type type, Comparable value) {\n      super(Pos.ZERO, op, type);\n      this.value = requireNonNull(value);\n    }\n\n    static Comparable wrap(Exp exp, Object value) {\n      return new Wrapper(exp, value);\n    }\n\n    /** Returns the value of this literal as a given class,\n     * or throws {@link ClassCastException}. If the class is not\n     * {@link Comparable}, the value will be in a wrapper. */\n    public <C> C unwrap(Class<C> clazz) {\n      Object v;\n      if (value instanceof Wrapper\n          && ((Wrapper) value).o instanceof TypedValue) {\n        return ((TypedValue) ((Wrapper) value).o).valueAs(clazz);\n      }\n      if (clazz.isInstance(value) && clazz != Object.class) {\n        v = value;\n      } else if (Number.class.isAssignableFrom(clazz)\n          && value instanceof Number) {\n        Number number = (Number) value;\n        if (clazz == Double.class) {\n          v = number.doubleValue();\n        } else if (clazz == Float.class) {\n          v = number.floatValue();\n        } else if (clazz == Long.class) {\n          v = number.longValue();\n        } else if (clazz == Integer.class) {\n          v = number.intValue();\n        } else if (clazz == Short.class) {\n          v = number.shortValue();\n        } else if (clazz == Byte.class) {\n          v = number.byteValue();\n        } else if (clazz == BigInteger.class\n            && number instanceof BigDecimal) {\n          v = ((BigDecimal) number).toBigIntegerExact();\n        } else {\n          v = value;\n        }\n      } else {\n        v = ((Wrapper) value).o;\n      }\n      return clazz.cast(v);\n    }\n\n    @Override public int hashCode() {\n      return value.hashCode();\n    }\n\n    @Override public boolean equals(Object o) {\n      return o == this\n          || o instanceof Literal\n          && value.equals(((Literal) o).value);\n    }\n\n    @Override public Exp accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }\n\n    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }\n\n    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      switch (op) {\n      case VALUE_LITERAL:\n        // Generate the original expression from which this value was derived.\n        return ((Wrapper) value).exp.unparse(w, left, right);\n      case INTERNAL_LITERAL:\n        // Print the value as if it were a string.\n        return w.appendLiteral(((Wrapper) value).o.toString());\n      }\n      return w.appendLiteral(value);\n    }\n\n    @Override public boolean isConstant() {\n      return true;\n    }\n  }", "definition": "  @SuppressWarnings(\"rawtypes\")\n  public static class Literal extends Exp", "class_docstring": " Code of a literal (constant).", "name": "Literal", "super_interfaces": [], "superclasses": "Exp", "attributes": {"modifiers": "@SuppressWarnings(\"rawtypes\")\n  public static", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings(\"rawtypes\")", "public", "static"], "comments": [], "fields": [{"attribute_expression": "public final Comparable value;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "Comparable", "name": "value", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    Literal(Op op, Type type, Comparable value) {\n      super(Pos.ZERO, op, type);\n      this.value = requireNonNull(value);\n    }", "docstring": " Creates a Literal.", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "Literal", "params": [{"name": "op", "type": "Op"}, {"name": "type", "type": "Type"}, {"name": "value", "type": "Comparable"}], "body": "                                                {\n      super(Pos.ZERO, op, type);\n      this.value = requireNonNull(value);\n    }", "signature": "Literal(Op op, Type type, Comparable value)"}, {"syntax_pass": true, "original_string": "    static Comparable wrap(Exp exp, Object value) {\n      return new Wrapper(exp, value);\n    }", "docstring": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "Comparable", "classes": []}, "name": "wrap", "params": [{"name": "exp", "type": "Exp"}, {"name": "value", "type": "Object"}], "body": "                                                  {\n      return new Wrapper(exp, value);\n    }", "signature": "static Comparable wrap(Exp exp, Object value)"}, {"syntax_pass": true, "original_string": "    public <C> C unwrap(Class<C> clazz) {\n      Object v;\n      if (value instanceof Wrapper\n          && ((Wrapper) value).o instanceof TypedValue) {\n        return ((TypedValue) ((Wrapper) value).o).valueAs(clazz);\n      }\n      if (clazz.isInstance(value) && clazz != Object.class) {\n        v = value;\n      } else if (Number.class.isAssignableFrom(clazz)\n          && value instanceof Number) {\n        Number number = (Number) value;\n        if (clazz == Double.class) {\n          v = number.doubleValue();\n        } else if (clazz == Float.class) {\n          v = number.floatValue();\n        } else if (clazz == Long.class) {\n          v = number.longValue();\n        } else if (clazz == Integer.class) {\n          v = number.intValue();\n        } else if (clazz == Short.class) {\n          v = number.shortValue();\n        } else if (clazz == Byte.class) {\n          v = number.byteValue();\n        } else if (clazz == BigInteger.class\n            && number instanceof BigDecimal) {\n          v = ((BigDecimal) number).toBigIntegerExact();\n        } else {\n          v = value;\n        }\n      } else {\n        v = ((Wrapper) value).o;\n      }\n      return clazz.cast(v);\n    }", "docstring": " Returns the value of this literal as a given class,\nor throws {@link ClassCastException}. If the class is not\n{@link Comparable}, the value will be in a wrapper.", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "C", "classes": []}, "name": "unwrap", "params": [{"name": "clazz", "type": "Class<C>"}], "body": "                                        {\n      Object v;\n      if (value instanceof Wrapper\n          && ((Wrapper) value).o instanceof TypedValue) {\n        return ((TypedValue) ((Wrapper) value).o).valueAs(clazz);\n      }\n      if (clazz.isInstance(value) && clazz != Object.class) {\n        v = value;\n      } else if (Number.class.isAssignableFrom(clazz)\n          && value instanceof Number) {\n        Number number = (Number) value;\n        if (clazz == Double.class) {\n          v = number.doubleValue();\n        } else if (clazz == Float.class) {\n          v = number.floatValue();\n        } else if (clazz == Long.class) {\n          v = number.longValue();\n        } else if (clazz == Integer.class) {\n          v = number.intValue();\n        } else if (clazz == Short.class) {\n          v = number.shortValue();\n        } else if (clazz == Byte.class) {\n          v = number.byteValue();\n        } else if (clazz == BigInteger.class\n            && number instanceof BigDecimal) {\n          v = ((BigDecimal) number).toBigIntegerExact();\n        } else {\n          v = value;\n        }\n      } else {\n        v = ((Wrapper) value).o;\n      }\n      return clazz.cast(v);\n    }", "signature": "public <C> C unwrap(Class<C> clazz)"}, {"syntax_pass": true, "original_string": "    @Override public int hashCode() {\n      return value.hashCode();\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "hashCode", "params": [], "body": "                                    {\n      return value.hashCode();\n    }", "signature": "@Override public int hashCode()"}, {"syntax_pass": true, "original_string": "    @Override public boolean equals(Object o) {\n      return o == this\n          || o instanceof Literal\n          && value.equals(((Literal) o).value);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "equals", "params": [{"name": "o", "type": "Object"}], "body": "                                              {\n      return o == this\n          || o instanceof Literal\n          && value.equals(((Literal) o).value);\n    }", "signature": "@Override public boolean equals(Object o)"}, {"syntax_pass": true, "original_string": "    @Override public Exp accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Exp", "classes": []}, "name": "accept", "params": [{"name": "shuttle", "type": "Shuttle"}], "body": "                                                 {\n      return shuttle.visit(this);\n    }", "signature": "@Override public Exp accept(Shuttle shuttle)"}, {"syntax_pass": true, "original_string": "    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "accept", "params": [{"name": "visitor", "type": "Visitor"}], "body": "                                                  {\n      visitor.visit(this);\n    }", "signature": "@Override public void accept(Visitor visitor)"}, {"syntax_pass": true, "original_string": "    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      switch (op) {\n      case VALUE_LITERAL:\n        // Generate the original expression from which this value was derived.\n        return ((Wrapper) value).exp.unparse(w, left, right);\n      case INTERNAL_LITERAL:\n        // Print the value as if it were a string.\n        return w.appendLiteral(((Wrapper) value).o.toString());\n      }\n      return w.appendLiteral(value);\n    }", "docstring": "", "attributes": {"modifiers": "@Override", "marker_annotations": ["@Override"], "non_marker_annotations": [], "comments": [], "return_type": "AstWriter", "classes": []}, "name": "unparse", "params": [{"name": "w", "type": "AstWriter"}, {"name": "left", "type": "int"}, {"name": "right", "type": "int"}], "body": "                                                                  {\n      switch (op) {\n      case VALUE_LITERAL:\n        // Generate the original expression from which this value was derived.\n        return ((Wrapper) value).exp.unparse(w, left, right);\n      case INTERNAL_LITERAL:\n        // Print the value as if it were a string.\n        return w.appendLiteral(((Wrapper) value).o.toString());\n      }\n      return w.appendLiteral(value);\n    }", "signature": "@Override AstWriter unparse(AstWriter w, int left, int right)"}, {"syntax_pass": true, "original_string": "    @Override public boolean isConstant() {\n      return true;\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isConstant", "params": [], "body": "                                          {\n      return true;\n    }", "signature": "@Override public boolean isConstant()"}]}, {"original_string": "  public abstract static class Decl extends BaseNode {\n    Decl(Pos pos, Op op) {\n      super(pos, op);\n    }\n\n    @Override public abstract Decl accept(Shuttle shuttle);\n  }", "definition": "  public abstract static class Decl extends BaseNode", "class_docstring": " Base class for declarations.", "name": "Decl", "super_interfaces": [], "superclasses": "BaseNode", "attributes": {"modifiers": "public abstract static", "marker_annotations": [], "non_marker_annotations": ["public", "abstract", "static"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    Decl(Pos pos, Op op) {\n      super(pos, op);\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "Decl", "params": [{"name": "pos", "type": "Pos"}, {"name": "op", "type": "Op"}], "body": "                         {\n      super(pos, op);\n    }", "signature": "Decl(Pos pos, Op op)"}, {"syntax_pass": true, "original_string": "    @Override public abstract Decl accept(Shuttle shuttle);", "docstring": "", "attributes": {"modifiers": "@Override public abstract", "marker_annotations": ["@Override"], "non_marker_annotations": ["public", "abstract"], "comments": [], "return_type": "Decl", "classes": []}, "name": "accept", "params": [{"name": "shuttle", "type": "Shuttle"}], "body": "", "signature": "@Override public abstract Decl accept(Shuttle shuttle)"}]}, {"original_string": "  public static class DatatypeDecl extends Decl {\n    public final List<DataType> dataTypes;\n\n    DatatypeDecl(ImmutableList<DataType> dataTypes) {\n      super(Pos.ZERO, Op.DATATYPE_DECL);\n      this.dataTypes = requireNonNull(dataTypes);\n      checkArgument(!this.dataTypes.isEmpty());\n    }\n\n    @Override public int hashCode() {\n      return Objects.hash(dataTypes);\n    }\n\n    @Override public boolean equals(Object o) {\n      return o == this\n          || o instanceof DatatypeDecl\n          && dataTypes.equals(((DatatypeDecl) o).dataTypes);\n    }\n\n    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      forEachIndexed(dataTypes, (dataType, i) ->\n          w.append(i == 0 ? \"datatype \" : \" and \").append(dataType.toString()));\n      return w;\n    }\n\n    @Override public DatatypeDecl accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }\n\n    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }\n  }", "definition": "  public static class DatatypeDecl extends Decl", "class_docstring": " Datatype declaration.", "name": "DatatypeDecl", "super_interfaces": [], "superclasses": "Decl", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [{"attribute_expression": "public final List<DataType> dataTypes;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "List<DataType>", "name": "dataTypes", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    DatatypeDecl(ImmutableList<DataType> dataTypes) {\n      super(Pos.ZERO, Op.DATATYPE_DECL);\n      this.dataTypes = requireNonNull(dataTypes);\n      checkArgument(!this.dataTypes.isEmpty());\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "DatatypeDecl", "params": [{"name": "dataTypes", "type": "ImmutableList<DataType>"}], "body": "                                                    {\n      super(Pos.ZERO, Op.DATATYPE_DECL);\n      this.dataTypes = requireNonNull(dataTypes);\n      checkArgument(!this.dataTypes.isEmpty());\n    }", "signature": "DatatypeDecl(ImmutableList<DataType> dataTypes)"}, {"syntax_pass": true, "original_string": "    @Override public int hashCode() {\n      return Objects.hash(dataTypes);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "hashCode", "params": [], "body": "                                    {\n      return Objects.hash(dataTypes);\n    }", "signature": "@Override public int hashCode()"}, {"syntax_pass": true, "original_string": "    @Override public boolean equals(Object o) {\n      return o == this\n          || o instanceof DatatypeDecl\n          && dataTypes.equals(((DatatypeDecl) o).dataTypes);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "equals", "params": [{"name": "o", "type": "Object"}], "body": "                                              {\n      return o == this\n          || o instanceof DatatypeDecl\n          && dataTypes.equals(((DatatypeDecl) o).dataTypes);\n    }", "signature": "@Override public boolean equals(Object o)"}, {"syntax_pass": true, "original_string": "    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      forEachIndexed(dataTypes, (dataType, i) ->\n          w.append(i == 0 ? \"datatype \" : \" and \").append(dataType.toString()));\n      return w;\n    }", "docstring": "", "attributes": {"modifiers": "@Override", "marker_annotations": ["@Override"], "non_marker_annotations": [], "comments": [], "return_type": "AstWriter", "classes": []}, "name": "unparse", "params": [{"name": "w", "type": "AstWriter"}, {"name": "left", "type": "int"}, {"name": "right", "type": "int"}], "body": "                                                                  {\n      forEachIndexed(dataTypes, (dataType, i) ->\n          w.append(i == 0 ? \"datatype \" : \" and \").append(dataType.toString()));\n      return w;\n    }", "signature": "@Override AstWriter unparse(AstWriter w, int left, int right)"}, {"syntax_pass": true, "original_string": "    @Override public DatatypeDecl accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "DatatypeDecl", "classes": []}, "name": "accept", "params": [{"name": "shuttle", "type": "Shuttle"}], "body": "                                                          {\n      return shuttle.visit(this);\n    }", "signature": "@Override public DatatypeDecl accept(Shuttle shuttle)"}, {"syntax_pass": true, "original_string": "    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "accept", "params": [{"name": "visitor", "type": "Visitor"}], "body": "                                                  {\n      visitor.visit(this);\n    }", "signature": "@Override public void accept(Visitor visitor)"}]}, {"original_string": "  public abstract static class ValDecl extends Decl {\n    ValDecl(Pos pos, Op op) {\n      super(pos, op);\n    }\n\n    @Override public abstract ValDecl accept(Shuttle shuttle);\n\n    public abstract void forEachBinding(BindingConsumer consumer);\n  }", "definition": "  public abstract static class ValDecl extends Decl", "class_docstring": " Abstract (recursive or non-recursive) value declaration.", "name": "ValDecl", "super_interfaces": [], "superclasses": "Decl", "attributes": {"modifiers": "public abstract static", "marker_annotations": [], "non_marker_annotations": ["public", "abstract", "static"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    ValDecl(Pos pos, Op op) {\n      super(pos, op);\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "ValDecl", "params": [{"name": "pos", "type": "Pos"}, {"name": "op", "type": "Op"}], "body": "                            {\n      super(pos, op);\n    }", "signature": "ValDecl(Pos pos, Op op)"}, {"syntax_pass": true, "original_string": "    @Override public abstract ValDecl accept(Shuttle shuttle);", "docstring": "", "attributes": {"modifiers": "@Override public abstract", "marker_annotations": ["@Override"], "non_marker_annotations": ["public", "abstract"], "comments": [], "return_type": "ValDecl", "classes": []}, "name": "accept", "params": [{"name": "shuttle", "type": "Shuttle"}], "body": "", "signature": "@Override public abstract ValDecl accept(Shuttle shuttle)"}, {"syntax_pass": true, "original_string": "    public abstract void forEachBinding(BindingConsumer consumer);", "docstring": "", "attributes": {"modifiers": "public abstract", "marker_annotations": [], "non_marker_annotations": ["public", "abstract"], "comments": [], "return_type": "void", "classes": []}, "name": "forEachBinding", "params": [{"name": "consumer", "type": "BindingConsumer"}], "body": "", "signature": "public abstract void forEachBinding(BindingConsumer consumer)"}]}, {"original_string": "  public static class NonRecValDecl extends ValDecl {\n    public final NamedPat pat;\n    public final Exp exp;\n\n    NonRecValDecl(NamedPat pat, Exp exp, Pos pos) {\n      super(pos, Op.VAL_DECL);\n      this.pat = pat;\n      this.exp = exp;\n    }\n\n    @Override public int hashCode() {\n      return Objects.hash(pat, exp);\n    }\n\n    @Override public boolean equals(Object o) {\n      return o == this\n          || o instanceof NonRecValDecl\n          && pat.equals(((NonRecValDecl) o).pat)\n          && exp.equals(((NonRecValDecl) o).exp);\n    }\n\n    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      return w.append(\"val \")\n          .append(pat, 0, 0).append(\" = \").append(exp, 0, right);\n    }\n\n    @Override public NonRecValDecl accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }\n\n    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }\n\n    public NonRecValDecl copy(NamedPat pat, Exp exp) {\n      return pat == this.pat && exp == this.exp ? this\n          : core.nonRecValDecl(pos, pat, exp);\n    }\n\n    @Override public void forEachBinding(BindingConsumer consumer) {\n      consumer.accept(pat, exp, pos);\n    }\n  }", "definition": "  public static class NonRecValDecl extends ValDecl", "class_docstring": " Non-recursive value declaration.\n\n@see RecValDecl#list", "name": "NonRecValDecl", "super_interfaces": [], "superclasses": "ValDecl", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [{"attribute_expression": "public final NamedPat pat;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "NamedPat", "name": "pat", "syntax_pass": true}, {"attribute_expression": "public final Exp exp;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "Exp", "name": "exp", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    NonRecValDecl(NamedPat pat, Exp exp, Pos pos) {\n      super(pos, Op.VAL_DECL);\n      this.pat = pat;\n      this.exp = exp;\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "NonRecValDecl", "params": [{"name": "pat", "type": "NamedPat"}, {"name": "exp", "type": "Exp"}, {"name": "pos", "type": "Pos"}], "body": "                                                  {\n      super(pos, Op.VAL_DECL);\n      this.pat = pat;\n      this.exp = exp;\n    }", "signature": "NonRecValDecl(NamedPat pat, Exp exp, Pos pos)"}, {"syntax_pass": true, "original_string": "    @Override public int hashCode() {\n      return Objects.hash(pat, exp);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "hashCode", "params": [], "body": "                                    {\n      return Objects.hash(pat, exp);\n    }", "signature": "@Override public int hashCode()"}, {"syntax_pass": true, "original_string": "    @Override public boolean equals(Object o) {\n      return o == this\n          || o instanceof NonRecValDecl\n          && pat.equals(((NonRecValDecl) o).pat)\n          && exp.equals(((NonRecValDecl) o).exp);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "equals", "params": [{"name": "o", "type": "Object"}], "body": "                                              {\n      return o == this\n          || o instanceof NonRecValDecl\n          && pat.equals(((NonRecValDecl) o).pat)\n          && exp.equals(((NonRecValDecl) o).exp);\n    }", "signature": "@Override public boolean equals(Object o)"}, {"syntax_pass": true, "original_string": "    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      return w.append(\"val \")\n          .append(pat, 0, 0).append(\" = \").append(exp, 0, right);\n    }", "docstring": "", "attributes": {"modifiers": "@Override", "marker_annotations": ["@Override"], "non_marker_annotations": [], "comments": [], "return_type": "AstWriter", "classes": []}, "name": "unparse", "params": [{"name": "w", "type": "AstWriter"}, {"name": "left", "type": "int"}, {"name": "right", "type": "int"}], "body": "                                                                  {\n      return w.append(\"val \")\n          .append(pat, 0, 0).append(\" = \").append(exp, 0, right);\n    }", "signature": "@Override AstWriter unparse(AstWriter w, int left, int right)"}, {"syntax_pass": true, "original_string": "    @Override public NonRecValDecl accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "NonRecValDecl", "classes": []}, "name": "accept", "params": [{"name": "shuttle", "type": "Shuttle"}], "body": "                                                           {\n      return shuttle.visit(this);\n    }", "signature": "@Override public NonRecValDecl accept(Shuttle shuttle)"}, {"syntax_pass": true, "original_string": "    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "accept", "params": [{"name": "visitor", "type": "Visitor"}], "body": "                                                  {\n      visitor.visit(this);\n    }", "signature": "@Override public void accept(Visitor visitor)"}, {"syntax_pass": true, "original_string": "    public NonRecValDecl copy(NamedPat pat, Exp exp) {\n      return pat == this.pat && exp == this.exp ? this\n          : core.nonRecValDecl(pos, pat, exp);\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "NonRecValDecl", "classes": []}, "name": "copy", "params": [{"name": "pat", "type": "NamedPat"}, {"name": "exp", "type": "Exp"}], "body": "                                                     {\n      return pat == this.pat && exp == this.exp ? this\n          : core.nonRecValDecl(pos, pat, exp);\n    }", "signature": "public NonRecValDecl copy(NamedPat pat, Exp exp)"}, {"syntax_pass": true, "original_string": "    @Override public void forEachBinding(BindingConsumer consumer) {\n      consumer.accept(pat, exp, pos);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "forEachBinding", "params": [{"name": "consumer", "type": "BindingConsumer"}], "body": "                                                                   {\n      consumer.accept(pat, exp, pos);\n    }", "signature": "@Override public void forEachBinding(BindingConsumer consumer)"}]}, {"original_string": "  public static class RecValDecl extends ValDecl {\n    public final ImmutableList<NonRecValDecl> list;\n\n    RecValDecl(ImmutableList<NonRecValDecl> list) {\n      super(Pos.ZERO, Op.REC_VAL_DECL);\n      this.list = requireNonNull(list);\n    }\n\n    @Override public int hashCode() {\n      return list.hashCode();\n    }\n\n    @Override public boolean equals(Object o) {\n      return o == this\n          || o instanceof RecValDecl\n          && list.equals(((RecValDecl) o).list);\n    }\n\n    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      w.append(\"val rec \");\n      forEachIndexed(list, (decl, i) ->\n          w.append(i == 0 ? \"\" : \" and \").append(decl.pat, 0, 0)\n              .append(\" = \").append(decl.exp, 0, right));\n      return w;\n    }\n\n    @Override public RecValDecl accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }\n\n    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }\n\n    @Override public void forEachBinding(BindingConsumer consumer) {\n      list.forEach(b -> b.forEachBinding(consumer));\n    }\n\n    public RecValDecl copy(List<NonRecValDecl> list) {\n      return list.equals(this.list) ? this\n          : core.recValDecl(list);\n    }\n  }", "definition": "  public static class RecValDecl extends ValDecl", "class_docstring": " Recursive value declaration.", "name": "RecValDecl", "super_interfaces": [], "superclasses": "ValDecl", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [{"attribute_expression": "public final ImmutableList<NonRecValDecl> list;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "ImmutableList<NonRecValDecl>", "name": "list", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    RecValDecl(ImmutableList<NonRecValDecl> list) {\n      super(Pos.ZERO, Op.REC_VAL_DECL);\n      this.list = requireNonNull(list);\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "RecValDecl", "params": [{"name": "list", "type": "ImmutableList<NonRecValDecl>"}], "body": "                                                  {\n      super(Pos.ZERO, Op.REC_VAL_DECL);\n      this.list = requireNonNull(list);\n    }", "signature": "RecValDecl(ImmutableList<NonRecValDecl> list)"}, {"syntax_pass": true, "original_string": "    @Override public int hashCode() {\n      return list.hashCode();\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "hashCode", "params": [], "body": "                                    {\n      return list.hashCode();\n    }", "signature": "@Override public int hashCode()"}, {"syntax_pass": true, "original_string": "    @Override public boolean equals(Object o) {\n      return o == this\n          || o instanceof RecValDecl\n          && list.equals(((RecValDecl) o).list);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "equals", "params": [{"name": "o", "type": "Object"}], "body": "                                              {\n      return o == this\n          || o instanceof RecValDecl\n          && list.equals(((RecValDecl) o).list);\n    }", "signature": "@Override public boolean equals(Object o)"}, {"syntax_pass": true, "original_string": "    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      w.append(\"val rec \");\n      forEachIndexed(list, (decl, i) ->\n          w.append(i == 0 ? \"\" : \" and \").append(decl.pat, 0, 0)\n              .append(\" = \").append(decl.exp, 0, right));\n      return w;\n    }", "docstring": "", "attributes": {"modifiers": "@Override", "marker_annotations": ["@Override"], "non_marker_annotations": [], "comments": [], "return_type": "AstWriter", "classes": []}, "name": "unparse", "params": [{"name": "w", "type": "AstWriter"}, {"name": "left", "type": "int"}, {"name": "right", "type": "int"}], "body": "                                                                  {\n      w.append(\"val rec \");\n      forEachIndexed(list, (decl, i) ->\n          w.append(i == 0 ? \"\" : \" and \").append(decl.pat, 0, 0)\n              .append(\" = \").append(decl.exp, 0, right));\n      return w;\n    }", "signature": "@Override AstWriter unparse(AstWriter w, int left, int right)"}, {"syntax_pass": true, "original_string": "    @Override public RecValDecl accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "RecValDecl", "classes": []}, "name": "accept", "params": [{"name": "shuttle", "type": "Shuttle"}], "body": "                                                        {\n      return shuttle.visit(this);\n    }", "signature": "@Override public RecValDecl accept(Shuttle shuttle)"}, {"syntax_pass": true, "original_string": "    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "accept", "params": [{"name": "visitor", "type": "Visitor"}], "body": "                                                  {\n      visitor.visit(this);\n    }", "signature": "@Override public void accept(Visitor visitor)"}, {"syntax_pass": true, "original_string": "    @Override public void forEachBinding(BindingConsumer consumer) {\n      list.forEach(b -> b.forEachBinding(consumer));\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "forEachBinding", "params": [{"name": "consumer", "type": "BindingConsumer"}], "body": "                                                                   {\n      list.forEach(b -> b.forEachBinding(consumer));\n    }", "signature": "@Override public void forEachBinding(BindingConsumer consumer)"}, {"syntax_pass": true, "original_string": "    public RecValDecl copy(List<NonRecValDecl> list) {\n      return list.equals(this.list) ? this\n          : core.recValDecl(list);\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "RecValDecl", "classes": []}, "name": "copy", "params": [{"name": "list", "type": "List<NonRecValDecl>"}], "body": "                                                     {\n      return list.equals(this.list) ? this\n          : core.recValDecl(list);\n    }", "signature": "public RecValDecl copy(List<NonRecValDecl> list)"}]}, {"original_string": "  public static class Tuple extends Exp {\n    public final List<Exp> args;\n\n    Tuple(RecordLikeType type, ImmutableList<Exp> args) {\n      super(Pos.ZERO, Op.TUPLE, type);\n      this.args = ImmutableList.copyOf(args);\n    }\n\n    @Override public boolean equals(Object o) {\n      return this == o\n          || o instanceof Tuple\n          && args.equals(((Tuple) o).args)\n          && type.equals(((Tuple) o).type);\n    }\n\n    @Override public int hashCode() {\n      return Objects.hash(args, type);\n    }\n\n    @Override public RecordLikeType type() {\n      return (RecordLikeType) type;\n    }\n\n    @Override public void forEachArg(ObjIntConsumer<Exp> action) {\n      forEachIndexed(args, action);\n    }\n\n    @Override public Exp arg(int i) {\n      return args.get(i);\n    }\n\n    @Override public Exp accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }\n\n    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }\n\n    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      if (type instanceof RecordType) {\n        w.append(\"{\");\n        forEach((i, name, exp) ->\n            w.append(i > 0 ? \", \" : \"\").append(name).append(\" = \")\n                .append(exp, 0, 0));\n        return w.append(\"}\");\n      } else {\n        w.append(\"(\");\n        forEach((i, name, arg) ->\n            w.append(i == 0 ? \"\" : \", \").append(arg, 0, 0));\n        return w.append(\")\");\n      }\n    }\n\n    /** Calls a consumer with the name, expression and ordinal of each field\n     * of this tuple. */\n    public void forEach(PairList.IndexedBiConsumer<String, Exp> consumer) {\n      final ImmutableSortedSet<String> nameSet =\n          (ImmutableSortedSet<String>) type().argNameTypes().keySet();\n      final List<String> names = nameSet.asList();\n      forEachIndexed(names, args, consumer::accept);\n    }\n\n    public Tuple copy(TypeSystem typeSystem, List<Exp> args) {\n      return args.equals(this.args) ? this\n          : core.tuple(typeSystem, type(), args);\n    }\n\n    @Override public boolean isConstant() {\n      return args.stream().allMatch(Exp::isConstant);\n    }\n  }", "definition": "  public static class Tuple extends Exp", "class_docstring": " TODO: remove, replace with a call to the constructor of the n-tuple type?", "name": "Tuple", "super_interfaces": [], "superclasses": "Exp", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [{"attribute_expression": "public final List<Exp> args;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "List<Exp>", "name": "args", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    Tuple(RecordLikeType type, ImmutableList<Exp> args) {\n      super(Pos.ZERO, Op.TUPLE, type);\n      this.args = ImmutableList.copyOf(args);\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "Tuple", "params": [{"name": "type", "type": "RecordLikeType"}, {"name": "args", "type": "ImmutableList<Exp>"}], "body": "                                                        {\n      super(Pos.ZERO, Op.TUPLE, type);\n      this.args = ImmutableList.copyOf(args);\n    }", "signature": "Tuple(RecordLikeType type, ImmutableList<Exp> args)"}, {"syntax_pass": true, "original_string": "    @Override public boolean equals(Object o) {\n      return this == o\n          || o instanceof Tuple\n          && args.equals(((Tuple) o).args)\n          && type.equals(((Tuple) o).type);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "equals", "params": [{"name": "o", "type": "Object"}], "body": "                                              {\n      return this == o\n          || o instanceof Tuple\n          && args.equals(((Tuple) o).args)\n          && type.equals(((Tuple) o).type);\n    }", "signature": "@Override public boolean equals(Object o)"}, {"syntax_pass": true, "original_string": "    @Override public int hashCode() {\n      return Objects.hash(args, type);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "hashCode", "params": [], "body": "                                    {\n      return Objects.hash(args, type);\n    }", "signature": "@Override public int hashCode()"}, {"syntax_pass": true, "original_string": "    @Override public RecordLikeType type() {\n      return (RecordLikeType) type;\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "RecordLikeType", "classes": []}, "name": "type", "params": [], "body": "                                           {\n      return (RecordLikeType) type;\n    }", "signature": "@Override public RecordLikeType type()"}, {"syntax_pass": true, "original_string": "    @Override public void forEachArg(ObjIntConsumer<Exp> action) {\n      forEachIndexed(args, action);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "forEachArg", "params": [{"name": "action", "type": "ObjIntConsumer<Exp>"}], "body": "                                                                 {\n      forEachIndexed(args, action);\n    }", "signature": "@Override public void forEachArg(ObjIntConsumer<Exp> action)"}, {"syntax_pass": true, "original_string": "    @Override public Exp arg(int i) {\n      return args.get(i);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Exp", "classes": []}, "name": "arg", "params": [{"name": "i", "type": "int"}], "body": "                                    {\n      return args.get(i);\n    }", "signature": "@Override public Exp arg(int i)"}, {"syntax_pass": true, "original_string": "    @Override public Exp accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Exp", "classes": []}, "name": "accept", "params": [{"name": "shuttle", "type": "Shuttle"}], "body": "                                                 {\n      return shuttle.visit(this);\n    }", "signature": "@Override public Exp accept(Shuttle shuttle)"}, {"syntax_pass": true, "original_string": "    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "accept", "params": [{"name": "visitor", "type": "Visitor"}], "body": "                                                  {\n      visitor.visit(this);\n    }", "signature": "@Override public void accept(Visitor visitor)"}, {"syntax_pass": true, "original_string": "    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      if (type instanceof RecordType) {\n        w.append(\"{\");\n        forEach((i, name, exp) ->\n            w.append(i > 0 ? \", \" : \"\").append(name).append(\" = \")\n                .append(exp, 0, 0));\n        return w.append(\"}\");\n      } else {\n        w.append(\"(\");\n        forEach((i, name, arg) ->\n            w.append(i == 0 ? \"\" : \", \").append(arg, 0, 0));\n        return w.append(\")\");\n      }\n    }", "docstring": "", "attributes": {"modifiers": "@Override", "marker_annotations": ["@Override"], "non_marker_annotations": [], "comments": [], "return_type": "AstWriter", "classes": []}, "name": "unparse", "params": [{"name": "w", "type": "AstWriter"}, {"name": "left", "type": "int"}, {"name": "right", "type": "int"}], "body": "                                                                  {\n      if (type instanceof RecordType) {\n        w.append(\"{\");\n        forEach((i, name, exp) ->\n            w.append(i > 0 ? \", \" : \"\").append(name).append(\" = \")\n                .append(exp, 0, 0));\n        return w.append(\"}\");\n      } else {\n        w.append(\"(\");\n        forEach((i, name, arg) ->\n            w.append(i == 0 ? \"\" : \", \").append(arg, 0, 0));\n        return w.append(\")\");\n      }\n    }", "signature": "@Override AstWriter unparse(AstWriter w, int left, int right)"}, {"syntax_pass": true, "original_string": "    public void forEach(PairList.IndexedBiConsumer<String, Exp> consumer) {\n      final ImmutableSortedSet<String> nameSet =\n          (ImmutableSortedSet<String>) type().argNameTypes().keySet();\n      final List<String> names = nameSet.asList();\n      forEachIndexed(names, args, consumer::accept);\n    }", "docstring": " Calls a consumer with the name, expression and ordinal of each field\nof this tuple.", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "forEach", "params": [{"name": "consumer", "type": "PairList.IndexedBiConsumer<String, Exp>"}], "body": "                                                                          {\n      final ImmutableSortedSet<String> nameSet =\n          (ImmutableSortedSet<String>) type().argNameTypes().keySet();\n      final List<String> names = nameSet.asList();\n      forEachIndexed(names, args, consumer::accept);\n    }", "signature": "public void forEach(PairList.IndexedBiConsumer<String, Exp> consumer)"}, {"syntax_pass": true, "original_string": "    public Tuple copy(TypeSystem typeSystem, List<Exp> args) {\n      return args.equals(this.args) ? this\n          : core.tuple(typeSystem, type(), args);\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Tuple", "classes": []}, "name": "copy", "params": [{"name": "typeSystem", "type": "TypeSystem"}, {"name": "args", "type": "List<Exp>"}], "body": "                                                             {\n      return args.equals(this.args) ? this\n          : core.tuple(typeSystem, type(), args);\n    }", "signature": "public Tuple copy(TypeSystem typeSystem, List<Exp> args)"}, {"syntax_pass": true, "original_string": "    @Override public boolean isConstant() {\n      return args.stream().allMatch(Exp::isConstant);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isConstant", "params": [], "body": "                                          {\n      return args.stream().allMatch(Exp::isConstant);\n    }", "signature": "@Override public boolean isConstant()"}]}, {"original_string": "  public static class Let extends Exp {\n    public final ValDecl decl;\n    public final Exp exp;\n\n    Let(ValDecl decl, Exp exp) {\n      super(Pos.ZERO, Op.LET, exp.type);\n      this.decl = requireNonNull(decl);\n      this.exp = requireNonNull(exp);\n    }\n\n    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      return w.append(\"let \").append(decl, 0, 0)\n          .append(\" in \").append(exp, 0, 0)\n          .append(\" end\");\n    }\n\n    @Override public Exp accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }\n\n    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }\n\n    public Exp copy(ValDecl decl, Exp exp) {\n      return decl == this.decl && exp == this.exp ? this\n          : core.let(decl, exp);\n    }\n  }", "definition": "  public static class Let extends Exp", "class_docstring": " \"Let\" expression.", "name": "Let", "super_interfaces": [], "superclasses": "Exp", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [{"attribute_expression": "public final ValDecl decl;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "ValDecl", "name": "decl", "syntax_pass": true}, {"attribute_expression": "public final Exp exp;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "Exp", "name": "exp", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    Let(ValDecl decl, Exp exp) {\n      super(Pos.ZERO, Op.LET, exp.type);\n      this.decl = requireNonNull(decl);\n      this.exp = requireNonNull(exp);\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "Let", "params": [{"name": "decl", "type": "ValDecl"}, {"name": "exp", "type": "Exp"}], "body": "                               {\n      super(Pos.ZERO, Op.LET, exp.type);\n      this.decl = requireNonNull(decl);\n      this.exp = requireNonNull(exp);\n    }", "signature": "Let(ValDecl decl, Exp exp)"}, {"syntax_pass": true, "original_string": "    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      return w.append(\"let \").append(decl, 0, 0)\n          .append(\" in \").append(exp, 0, 0)\n          .append(\" end\");\n    }", "docstring": "", "attributes": {"modifiers": "@Override", "marker_annotations": ["@Override"], "non_marker_annotations": [], "comments": [], "return_type": "AstWriter", "classes": []}, "name": "unparse", "params": [{"name": "w", "type": "AstWriter"}, {"name": "left", "type": "int"}, {"name": "right", "type": "int"}], "body": "                                                                  {\n      return w.append(\"let \").append(decl, 0, 0)\n          .append(\" in \").append(exp, 0, 0)\n          .append(\" end\");\n    }", "signature": "@Override AstWriter unparse(AstWriter w, int left, int right)"}, {"syntax_pass": true, "original_string": "    @Override public Exp accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Exp", "classes": []}, "name": "accept", "params": [{"name": "shuttle", "type": "Shuttle"}], "body": "                                                 {\n      return shuttle.visit(this);\n    }", "signature": "@Override public Exp accept(Shuttle shuttle)"}, {"syntax_pass": true, "original_string": "    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "accept", "params": [{"name": "visitor", "type": "Visitor"}], "body": "                                                  {\n      visitor.visit(this);\n    }", "signature": "@Override public void accept(Visitor visitor)"}, {"syntax_pass": true, "original_string": "    public Exp copy(ValDecl decl, Exp exp) {\n      return decl == this.decl && exp == this.exp ? this\n          : core.let(decl, exp);\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Exp", "classes": []}, "name": "copy", "params": [{"name": "decl", "type": "ValDecl"}, {"name": "exp", "type": "Exp"}], "body": "                                           {\n      return decl == this.decl && exp == this.exp ? this\n          : core.let(decl, exp);\n    }", "signature": "public Exp copy(ValDecl decl, Exp exp)"}]}, {"original_string": "  public static class Local extends Exp {\n    public final DataType dataType;\n    public final Exp exp;\n\n    Local(DataType dataType, Exp exp) {\n      super(Pos.ZERO, Op.LOCAL, exp.type);\n      this.dataType = requireNonNull(dataType);\n      this.exp = requireNonNull(exp);\n    }\n\n    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      return w.append(\"local datatype \").append(dataType.toString())\n          .append(\" in \").append(exp, 0, 0)\n          .append(\" end\");\n    }\n\n    @Override public Exp accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }\n\n    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }\n\n    public Exp copy(DataType dataType, Exp exp) {\n      return dataType == this.dataType && exp == this.exp ? this\n          : core.local(dataType, exp);\n    }\n  }", "definition": "  public static class Local extends Exp", "class_docstring": " \"Local\" expression.", "name": "Local", "super_interfaces": [], "superclasses": "Exp", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [{"attribute_expression": "public final DataType dataType;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "DataType", "name": "dataType", "syntax_pass": true}, {"attribute_expression": "public final Exp exp;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "Exp", "name": "exp", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    Local(DataType dataType, Exp exp) {\n      super(Pos.ZERO, Op.LOCAL, exp.type);\n      this.dataType = requireNonNull(dataType);\n      this.exp = requireNonNull(exp);\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "Local", "params": [{"name": "dataType", "type": "DataType"}, {"name": "exp", "type": "Exp"}], "body": "                                      {\n      super(Pos.ZERO, Op.LOCAL, exp.type);\n      this.dataType = requireNonNull(dataType);\n      this.exp = requireNonNull(exp);\n    }", "signature": "Local(DataType dataType, Exp exp)"}, {"syntax_pass": true, "original_string": "    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      return w.append(\"local datatype \").append(dataType.toString())\n          .append(\" in \").append(exp, 0, 0)\n          .append(\" end\");\n    }", "docstring": "", "attributes": {"modifiers": "@Override", "marker_annotations": ["@Override"], "non_marker_annotations": [], "comments": [], "return_type": "AstWriter", "classes": []}, "name": "unparse", "params": [{"name": "w", "type": "AstWriter"}, {"name": "left", "type": "int"}, {"name": "right", "type": "int"}], "body": "                                                                  {\n      return w.append(\"local datatype \").append(dataType.toString())\n          .append(\" in \").append(exp, 0, 0)\n          .append(\" end\");\n    }", "signature": "@Override AstWriter unparse(AstWriter w, int left, int right)"}, {"syntax_pass": true, "original_string": "    @Override public Exp accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Exp", "classes": []}, "name": "accept", "params": [{"name": "shuttle", "type": "Shuttle"}], "body": "                                                 {\n      return shuttle.visit(this);\n    }", "signature": "@Override public Exp accept(Shuttle shuttle)"}, {"syntax_pass": true, "original_string": "    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "accept", "params": [{"name": "visitor", "type": "Visitor"}], "body": "                                                  {\n      visitor.visit(this);\n    }", "signature": "@Override public void accept(Visitor visitor)"}, {"syntax_pass": true, "original_string": "    public Exp copy(DataType dataType, Exp exp) {\n      return dataType == this.dataType && exp == this.exp ? this\n          : core.local(dataType, exp);\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Exp", "classes": []}, "name": "copy", "params": [{"name": "dataType", "type": "DataType"}, {"name": "exp", "type": "Exp"}], "body": "                                                {\n      return dataType == this.dataType && exp == this.exp ? this\n          : core.local(dataType, exp);\n    }", "signature": "public Exp copy(DataType dataType, Exp exp)"}]}, {"original_string": "  public static class Match extends BaseNode {\n    public final Pat pat;\n    public final Exp exp;\n\n    Match(Pos pos, Pat pat, Exp exp) {\n      super(pos, Op.MATCH);\n      this.pat = pat;\n      this.exp = exp;\n    }\n\n    @Override public Match accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }\n\n    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }\n\n    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      return w.append(pat, 0, 0).append(\" => \").append(exp, 0, right);\n    }\n\n    public Match copy(Pat pat, Exp exp) {\n      return pat == this.pat && exp == this.exp ? this\n          : core.match(pos, pat, exp);\n    }\n  }", "definition": "  public static class Match extends BaseNode", "class_docstring": " Match.\n\n<p>In AST, there are several places that can deconstruct values via\npatterns: {@link Ast.FunDecl fun}, {@link Ast.Fn fn}, {@link Ast.Let let},\n{@link Ast.Case case}. But in Core, there is only {@code Match}, and\n{@code Match} only occurs within {@link Ast.Case case}. This makes the Core\nlanguage a little more verbose than AST but a lot more uniform.", "name": "Match", "super_interfaces": [], "superclasses": "BaseNode", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [{"attribute_expression": "public final Pat pat;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "Pat", "name": "pat", "syntax_pass": true}, {"attribute_expression": "public final Exp exp;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "Exp", "name": "exp", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    Match(Pos pos, Pat pat, Exp exp) {\n      super(pos, Op.MATCH);\n      this.pat = pat;\n      this.exp = exp;\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "Match", "params": [{"name": "pos", "type": "Pos"}, {"name": "pat", "type": "Pat"}, {"name": "exp", "type": "Exp"}], "body": "                                     {\n      super(pos, Op.MATCH);\n      this.pat = pat;\n      this.exp = exp;\n    }", "signature": "Match(Pos pos, Pat pat, Exp exp)"}, {"syntax_pass": true, "original_string": "    @Override public Match accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Match", "classes": []}, "name": "accept", "params": [{"name": "shuttle", "type": "Shuttle"}], "body": "                                                   {\n      return shuttle.visit(this);\n    }", "signature": "@Override public Match accept(Shuttle shuttle)"}, {"syntax_pass": true, "original_string": "    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "accept", "params": [{"name": "visitor", "type": "Visitor"}], "body": "                                                  {\n      visitor.visit(this);\n    }", "signature": "@Override public void accept(Visitor visitor)"}, {"syntax_pass": true, "original_string": "    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      return w.append(pat, 0, 0).append(\" => \").append(exp, 0, right);\n    }", "docstring": "", "attributes": {"modifiers": "@Override", "marker_annotations": ["@Override"], "non_marker_annotations": [], "comments": [], "return_type": "AstWriter", "classes": []}, "name": "unparse", "params": [{"name": "w", "type": "AstWriter"}, {"name": "left", "type": "int"}, {"name": "right", "type": "int"}], "body": "                                                                  {\n      return w.append(pat, 0, 0).append(\" => \").append(exp, 0, right);\n    }", "signature": "@Override AstWriter unparse(AstWriter w, int left, int right)"}, {"syntax_pass": true, "original_string": "    public Match copy(Pat pat, Exp exp) {\n      return pat == this.pat && exp == this.exp ? this\n          : core.match(pos, pat, exp);\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Match", "classes": []}, "name": "copy", "params": [{"name": "pat", "type": "Pat"}, {"name": "exp", "type": "Exp"}], "body": "                                        {\n      return pat == this.pat && exp == this.exp ? this\n          : core.match(pos, pat, exp);\n    }", "signature": "public Match copy(Pat pat, Exp exp)"}]}, {"original_string": "  public static class Fn extends Exp {\n    public final IdPat idPat;\n    public final Exp exp;\n\n    Fn(FnType type, IdPat idPat, Exp exp) {\n      super(Pos.ZERO, Op.FN, type);\n      this.idPat = requireNonNull(idPat);\n      this.exp = requireNonNull(exp);\n    }\n\n    @Override public FnType type() {\n      return (FnType) type;\n    }\n\n    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      return w.append(\"fn \")\n          .append(idPat, 0, 0).append(\" => \").append(exp, 0, right);\n    }\n\n    @Override public Exp accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }\n\n    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }\n\n    public Fn copy(IdPat idPat, Exp exp) {\n      return idPat == this.idPat && exp == this.exp ? this\n          : core.fn(type(), idPat, exp);\n    }\n  }", "definition": "  public static class Fn extends Exp", "class_docstring": " Lambda expression.", "name": "Fn", "super_interfaces": [], "superclasses": "Exp", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [{"attribute_expression": "public final IdPat idPat;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "IdPat", "name": "idPat", "syntax_pass": true}, {"attribute_expression": "public final Exp exp;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "Exp", "name": "exp", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    Fn(FnType type, IdPat idPat, Exp exp) {\n      super(Pos.ZERO, Op.FN, type);\n      this.idPat = requireNonNull(idPat);\n      this.exp = requireNonNull(exp);\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "Fn", "params": [{"name": "type", "type": "FnType"}, {"name": "idPat", "type": "IdPat"}, {"name": "exp", "type": "Exp"}], "body": "                                          {\n      super(Pos.ZERO, Op.FN, type);\n      this.idPat = requireNonNull(idPat);\n      this.exp = requireNonNull(exp);\n    }", "signature": "Fn(FnType type, IdPat idPat, Exp exp)"}, {"syntax_pass": true, "original_string": "    @Override public FnType type() {\n      return (FnType) type;\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "FnType", "classes": []}, "name": "type", "params": [], "body": "                                   {\n      return (FnType) type;\n    }", "signature": "@Override public FnType type()"}, {"syntax_pass": true, "original_string": "    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      return w.append(\"fn \")\n          .append(idPat, 0, 0).append(\" => \").append(exp, 0, right);\n    }", "docstring": "", "attributes": {"modifiers": "@Override", "marker_annotations": ["@Override"], "non_marker_annotations": [], "comments": [], "return_type": "AstWriter", "classes": []}, "name": "unparse", "params": [{"name": "w", "type": "AstWriter"}, {"name": "left", "type": "int"}, {"name": "right", "type": "int"}], "body": "                                                                  {\n      return w.append(\"fn \")\n          .append(idPat, 0, 0).append(\" => \").append(exp, 0, right);\n    }", "signature": "@Override AstWriter unparse(AstWriter w, int left, int right)"}, {"syntax_pass": true, "original_string": "    @Override public Exp accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Exp", "classes": []}, "name": "accept", "params": [{"name": "shuttle", "type": "Shuttle"}], "body": "                                                 {\n      return shuttle.visit(this);\n    }", "signature": "@Override public Exp accept(Shuttle shuttle)"}, {"syntax_pass": true, "original_string": "    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "accept", "params": [{"name": "visitor", "type": "Visitor"}], "body": "                                                  {\n      visitor.visit(this);\n    }", "signature": "@Override public void accept(Visitor visitor)"}, {"syntax_pass": true, "original_string": "    public Fn copy(IdPat idPat, Exp exp) {\n      return idPat == this.idPat && exp == this.exp ? this\n          : core.fn(type(), idPat, exp);\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Fn", "classes": []}, "name": "copy", "params": [{"name": "idPat", "type": "IdPat"}, {"name": "exp", "type": "Exp"}], "body": "                                         {\n      return idPat == this.idPat && exp == this.exp ? this\n          : core.fn(type(), idPat, exp);\n    }", "signature": "public Fn copy(IdPat idPat, Exp exp)"}]}, {"original_string": "  public static class Case extends Exp {\n    public final Exp exp;\n    public final List<Match> matchList;\n\n    Case(Pos pos, Type type, Exp exp, ImmutableList<Match> matchList) {\n      super(pos, Op.CASE, type);\n      this.exp = exp;\n      this.matchList = matchList;\n    }\n\n    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      return w.append(\"case \").append(exp, 0, 0).append(\" of \")\n          .appendAll(matchList, left, Op.BAR, right);\n    }\n\n    @Override public Exp accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }\n\n    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }\n\n    public Case copy(Exp exp, List<Match> matchList) {\n      return exp == this.exp && matchList.equals(this.matchList) ? this\n          : core.caseOf(pos, type, exp, matchList);\n    }\n  }", "definition": "  public static class Case extends Exp", "class_docstring": " Case expression.\n\n<p>Also implements {@link Ast.If}.", "name": "Case", "super_interfaces": [], "superclasses": "Exp", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [{"attribute_expression": "public final Exp exp;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "Exp", "name": "exp", "syntax_pass": true}, {"attribute_expression": "public final List<Match> matchList;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "List<Match>", "name": "matchList", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    Case(Pos pos, Type type, Exp exp, ImmutableList<Match> matchList) {\n      super(pos, Op.CASE, type);\n      this.exp = exp;\n      this.matchList = matchList;\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "Case", "params": [{"name": "pos", "type": "Pos"}, {"name": "type", "type": "Type"}, {"name": "exp", "type": "Exp"}, {"name": "matchList", "type": "ImmutableList<Match>"}], "body": "                                                                      {\n      super(pos, Op.CASE, type);\n      this.exp = exp;\n      this.matchList = matchList;\n    }", "signature": "Case(Pos pos, Type type, Exp exp, ImmutableList<Match> matchList)"}, {"syntax_pass": true, "original_string": "    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      return w.append(\"case \").append(exp, 0, 0).append(\" of \")\n          .appendAll(matchList, left, Op.BAR, right);\n    }", "docstring": "", "attributes": {"modifiers": "@Override", "marker_annotations": ["@Override"], "non_marker_annotations": [], "comments": [], "return_type": "AstWriter", "classes": []}, "name": "unparse", "params": [{"name": "w", "type": "AstWriter"}, {"name": "left", "type": "int"}, {"name": "right", "type": "int"}], "body": "                                                                  {\n      return w.append(\"case \").append(exp, 0, 0).append(\" of \")\n          .appendAll(matchList, left, Op.BAR, right);\n    }", "signature": "@Override AstWriter unparse(AstWriter w, int left, int right)"}, {"syntax_pass": true, "original_string": "    @Override public Exp accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Exp", "classes": []}, "name": "accept", "params": [{"name": "shuttle", "type": "Shuttle"}], "body": "                                                 {\n      return shuttle.visit(this);\n    }", "signature": "@Override public Exp accept(Shuttle shuttle)"}, {"syntax_pass": true, "original_string": "    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "accept", "params": [{"name": "visitor", "type": "Visitor"}], "body": "                                                  {\n      visitor.visit(this);\n    }", "signature": "@Override public void accept(Visitor visitor)"}, {"syntax_pass": true, "original_string": "    public Case copy(Exp exp, List<Match> matchList) {\n      return exp == this.exp && matchList.equals(this.matchList) ? this\n          : core.caseOf(pos, type, exp, matchList);\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Case", "classes": []}, "name": "copy", "params": [{"name": "exp", "type": "Exp"}, {"name": "matchList", "type": "List<Match>"}], "body": "                                                     {\n      return exp == this.exp && matchList.equals(this.matchList) ? this\n          : core.caseOf(pos, type, exp, matchList);\n    }", "signature": "public Case copy(Exp exp, List<Match> matchList)"}]}, {"original_string": "  public static class From extends Exp {\n    public final ImmutableList<FromStep> steps;\n\n    From(ListType type, ImmutableList<FromStep> steps) {\n      super(Pos.ZERO, Op.FROM, type);\n      this.steps = requireNonNull(steps);\n    }\n\n    @Override public boolean equals(Object o) {\n      return this == o\n          || o instanceof From\n          && steps.equals(((From) o).steps);\n    }\n\n    @Override public int hashCode() {\n      return steps.hashCode();\n    }\n\n    @Override public ListType type() {\n      return (ListType) type;\n    }\n\n    @Override public Exp accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }\n\n    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }\n\n    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      if (left > op.left || op.right < right) {\n        return w.append(\"(\").append(this, 0, 0).append(\")\");\n      } else {\n        w.append(\"from\");\n        forEachIndexed(steps, (step, i) -> step.unparse(w, this, i, 0, 0));\n        return w;\n      }\n    }\n\n    /** Copies this {@code From} with a new set of steps.\n     *\n     * <p>Returns this {@code From} if the steps are the same.\n     * If {@code env} is not null, performs additional checking. */\n    public Exp copy(TypeSystem typeSystem, @Nullable Environment env,\n        List<FromStep> steps) {\n      return steps.equals(this.steps)\n          ? this\n          : core.fromBuilder(typeSystem, env).addAll(steps).build();\n    }\n  }", "definition": "  public static class From extends Exp", "class_docstring": " From expression.", "name": "From", "super_interfaces": [], "superclasses": "Exp", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [{"attribute_expression": "public final ImmutableList<FromStep> steps;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "ImmutableList<FromStep>", "name": "steps", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    From(ListType type, ImmutableList<FromStep> steps) {\n      super(Pos.ZERO, Op.FROM, type);\n      this.steps = requireNonNull(steps);\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "From", "params": [{"name": "type", "type": "ListType"}, {"name": "steps", "type": "ImmutableList<FromStep>"}], "body": "                                                       {\n      super(Pos.ZERO, Op.FROM, type);\n      this.steps = requireNonNull(steps);\n    }", "signature": "From(ListType type, ImmutableList<FromStep> steps)"}, {"syntax_pass": true, "original_string": "    @Override public boolean equals(Object o) {\n      return this == o\n          || o instanceof From\n          && steps.equals(((From) o).steps);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "equals", "params": [{"name": "o", "type": "Object"}], "body": "                                              {\n      return this == o\n          || o instanceof From\n          && steps.equals(((From) o).steps);\n    }", "signature": "@Override public boolean equals(Object o)"}, {"syntax_pass": true, "original_string": "    @Override public int hashCode() {\n      return steps.hashCode();\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "hashCode", "params": [], "body": "                                    {\n      return steps.hashCode();\n    }", "signature": "@Override public int hashCode()"}, {"syntax_pass": true, "original_string": "    @Override public ListType type() {\n      return (ListType) type;\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "ListType", "classes": []}, "name": "type", "params": [], "body": "                                     {\n      return (ListType) type;\n    }", "signature": "@Override public ListType type()"}, {"syntax_pass": true, "original_string": "    @Override public Exp accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Exp", "classes": []}, "name": "accept", "params": [{"name": "shuttle", "type": "Shuttle"}], "body": "                                                 {\n      return shuttle.visit(this);\n    }", "signature": "@Override public Exp accept(Shuttle shuttle)"}, {"syntax_pass": true, "original_string": "    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "accept", "params": [{"name": "visitor", "type": "Visitor"}], "body": "                                                  {\n      visitor.visit(this);\n    }", "signature": "@Override public void accept(Visitor visitor)"}, {"syntax_pass": true, "original_string": "    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      if (left > op.left || op.right < right) {\n        return w.append(\"(\").append(this, 0, 0).append(\")\");\n      } else {\n        w.append(\"from\");\n        forEachIndexed(steps, (step, i) -> step.unparse(w, this, i, 0, 0));\n        return w;\n      }\n    }", "docstring": "", "attributes": {"modifiers": "@Override", "marker_annotations": ["@Override"], "non_marker_annotations": [], "comments": [], "return_type": "AstWriter", "classes": []}, "name": "unparse", "params": [{"name": "w", "type": "AstWriter"}, {"name": "left", "type": "int"}, {"name": "right", "type": "int"}], "body": "                                                                  {\n      if (left > op.left || op.right < right) {\n        return w.append(\"(\").append(this, 0, 0).append(\")\");\n      } else {\n        w.append(\"from\");\n        forEachIndexed(steps, (step, i) -> step.unparse(w, this, i, 0, 0));\n        return w;\n      }\n    }", "signature": "@Override AstWriter unparse(AstWriter w, int left, int right)"}, {"syntax_pass": true, "original_string": "    public Exp copy(TypeSystem typeSystem, @Nullable Environment env,\n        List<FromStep> steps) {\n      return steps.equals(this.steps)\n          ? this\n          : core.fromBuilder(typeSystem, env).addAll(steps).build();\n    }", "docstring": " Copies this {@code From} with a new set of steps.\n\n<p>Returns this {@code From} if the steps are the same.\nIf {@code env} is not null, performs additional checking.", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Exp", "classes": []}, "name": "copy", "params": [{"name": "typeSystem", "type": "TypeSystem"}, {"name": "env", "type": "Environment"}, {"name": "steps", "type": "List<FromStep>"}], "body": "                              {\n      return steps.equals(this.steps)\n          ? this\n          : core.fromBuilder(typeSystem, env).addAll(steps).build();\n    }", "signature": "public Exp copy(TypeSystem typeSystem, @Nullable Environment env,\n        List<FromStep> steps)"}]}, {"original_string": "  public abstract static class FromStep extends BaseNode {\n    public final ImmutableList<Binding> bindings;\n\n    FromStep(Op op, ImmutableList<Binding> bindings) {\n      super(Pos.ZERO, op);\n      this.bindings = bindings;\n    }\n\n    @Override final AstWriter unparse(AstWriter w, int left, int right) {\n      return unparse(w, null, -1, left, right);\n    }\n\n    protected abstract AstWriter unparse(AstWriter w, From from, int ordinal,\n        int left, int right);\n\n    @Override public abstract FromStep accept(Shuttle shuttle);\n  }", "definition": "  public abstract static class FromStep extends BaseNode", "class_docstring": " A step in a {@code from} expression - {@code where}, {@code group}\nor {@code order}.", "name": "FromStep", "super_interfaces": [], "superclasses": "BaseNode", "attributes": {"modifiers": "public abstract static", "marker_annotations": [], "non_marker_annotations": ["public", "abstract", "static"], "comments": [], "fields": [{"attribute_expression": "public final ImmutableList<Binding> bindings;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "ImmutableList<Binding>", "name": "bindings", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    FromStep(Op op, ImmutableList<Binding> bindings) {\n      super(Pos.ZERO, op);\n      this.bindings = bindings;\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "FromStep", "params": [{"name": "op", "type": "Op"}, {"name": "bindings", "type": "ImmutableList<Binding>"}], "body": "                                                     {\n      super(Pos.ZERO, op);\n      this.bindings = bindings;\n    }", "signature": "FromStep(Op op, ImmutableList<Binding> bindings)"}, {"syntax_pass": true, "original_string": "    @Override final AstWriter unparse(AstWriter w, int left, int right) {\n      return unparse(w, null, -1, left, right);\n    }", "docstring": "", "attributes": {"modifiers": "@Override final", "marker_annotations": ["@Override"], "non_marker_annotations": ["final"], "comments": [], "return_type": "AstWriter", "classes": []}, "name": "unparse", "params": [{"name": "w", "type": "AstWriter"}, {"name": "left", "type": "int"}, {"name": "right", "type": "int"}], "body": "                                                                        {\n      return unparse(w, null, -1, left, right);\n    }", "signature": "@Override final AstWriter unparse(AstWriter w, int left, int right)"}, {"syntax_pass": true, "original_string": "    protected abstract AstWriter unparse(AstWriter w, From from, int ordinal,\n        int left, int right);", "docstring": "", "attributes": {"modifiers": "protected abstract", "marker_annotations": [], "non_marker_annotations": ["protected", "abstract"], "comments": [], "return_type": "AstWriter", "classes": []}, "name": "unparse", "params": [{"name": "w", "type": "AstWriter"}, {"name": "from", "type": "From"}, {"name": "ordinal", "type": "int"}, {"name": "left", "type": "int"}, {"name": "right", "type": "int"}], "body": "", "signature": "protected abstract AstWriter unparse(AstWriter w, From from, int ordinal,\n        int left, int right)"}, {"syntax_pass": true, "original_string": "    @Override public abstract FromStep accept(Shuttle shuttle);", "docstring": "", "attributes": {"modifiers": "@Override public abstract", "marker_annotations": ["@Override"], "non_marker_annotations": ["public", "abstract"], "comments": [], "return_type": "FromStep", "classes": []}, "name": "accept", "params": [{"name": "shuttle", "type": "Shuttle"}], "body": "", "signature": "@Override public abstract FromStep accept(Shuttle shuttle)"}]}, {"original_string": "  public static class Scan extends FromStep {\n    public final Pat pat;\n    public final Exp exp;\n    public final Exp condition;\n\n    Scan(ImmutableList<Binding> bindings, Pat pat, Exp exp,\n        Exp condition) {\n      super(Op.SCAN, bindings);\n      this.pat = requireNonNull(pat, \"pat\");\n      this.exp = requireNonNull(exp, \"exp\");\n      this.condition = requireNonNull(condition, \"condition\");\n      if (!(exp.type instanceof ListType)) {\n        throw new IllegalArgumentException(\"scan expression must be list: \"\n            + exp.type);\n      }\n      final ListType listType = (ListType) exp.type;\n      if (!canAssign(listType.elementType, pat.type)) {\n        throw new IllegalArgumentException(exp.type + \" + \" + pat.type);\n      }\n    }\n\n    /** Returns whether you can assign a value of {@code fromType} to a variable\n     * of type {@code toType}. */\n    private static boolean canAssign(Type fromType, Type toType) {\n      return fromType.equals(toType)\n          || toType.isProgressive();\n    }\n\n    @Override public Scan accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }\n\n    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }\n\n    @Override protected AstWriter unparse(AstWriter w, From from, int ordinal,\n        int left, int right) {\n      w.append(ordinal == 0 ? \" \" : \" join \")\n          // for these purposes 'in' has same precedence as '='\n          .append(pat, 0, Op.EQ.left);\n      if (Extents.isInfinite(exp)) {\n        // Print \"from x : int\" rather \"from x in extent 'int'\"\n        w.append(\" : \")\n            .append(((ListType) exp.type).elementType.moniker());\n      } else {\n        w.append(\" in \")\n            .append(exp, Op.EQ.right, 0);\n      }\n      if (!isLiteralTrue()) {\n        w.append(\"on\").append(condition, 0, 0);\n      }\n      return w;\n    }\n\n    private boolean isLiteralTrue() {\n      return condition.op == Op.BOOL_LITERAL\n          && ((Literal) condition).unwrap(Boolean.class);\n    }\n\n    public Scan copy(List<Binding> bindings, Pat pat, Exp exp, Exp condition) {\n      return pat == this.pat\n          && exp == this.exp\n          && condition == this.condition\n          && bindings.equals(this.bindings)\n          ? this\n          : core.scan(bindings, pat, exp, condition);\n    }\n  }", "definition": "  public static class Scan extends FromStep", "class_docstring": " A {@code join} or {@code v in listExpr} or {@code v = expr} clause in a\n {@code from} expression.", "name": "Scan", "super_interfaces": [], "superclasses": "FromStep", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [{"attribute_expression": "public final Pat pat;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "Pat", "name": "pat", "syntax_pass": true}, {"attribute_expression": "public final Exp exp;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "Exp", "name": "exp", "syntax_pass": true}, {"attribute_expression": "public final Exp condition;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "Exp", "name": "condition", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    Scan(ImmutableList<Binding> bindings, Pat pat, Exp exp,\n        Exp condition) {\n      super(Op.SCAN, bindings);\n      this.pat = requireNonNull(pat, \"pat\");\n      this.exp = requireNonNull(exp, \"exp\");\n      this.condition = requireNonNull(condition, \"condition\");\n      if (!(exp.type instanceof ListType)) {\n        throw new IllegalArgumentException(\"scan expression must be list: \"\n            + exp.type);\n      }\n      final ListType listType = (ListType) exp.type;\n      if (!canAssign(listType.elementType, pat.type)) {\n        throw new IllegalArgumentException(exp.type + \" + \" + pat.type);\n      }\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "Scan", "params": [{"name": "bindings", "type": "ImmutableList<Binding>"}, {"name": "pat", "type": "Pat"}, {"name": "exp", "type": "Exp"}, {"name": "condition", "type": "Exp"}], "body": "                       {\n      super(Op.SCAN, bindings);\n      this.pat = requireNonNull(pat, \"pat\");\n      this.exp = requireNonNull(exp, \"exp\");\n      this.condition = requireNonNull(condition, \"condition\");\n      if (!(exp.type instanceof ListType)) {\n        throw new IllegalArgumentException(\"scan expression must be list: \"\n            + exp.type);\n      }\n      final ListType listType = (ListType) exp.type;\n      if (!canAssign(listType.elementType, pat.type)) {\n        throw new IllegalArgumentException(exp.type + \" + \" + pat.type);\n      }\n    }", "signature": "Scan(ImmutableList<Binding> bindings, Pat pat, Exp exp,\n        Exp condition)"}, {"syntax_pass": true, "original_string": "    private static boolean canAssign(Type fromType, Type toType) {\n      return fromType.equals(toType)\n          || toType.isProgressive();\n    }", "docstring": " Returns whether you can assign a value of {@code fromType} to a variable\nof type {@code toType}.", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "boolean", "classes": []}, "name": "canAssign", "params": [{"name": "fromType", "type": "Type"}, {"name": "toType", "type": "Type"}], "body": "                                                                 {\n      return fromType.equals(toType)\n          || toType.isProgressive();\n    }", "signature": "private static boolean canAssign(Type fromType, Type toType)"}, {"syntax_pass": true, "original_string": "    @Override public Scan accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Scan", "classes": []}, "name": "accept", "params": [{"name": "shuttle", "type": "Shuttle"}], "body": "                                                  {\n      return shuttle.visit(this);\n    }", "signature": "@Override public Scan accept(Shuttle shuttle)"}, {"syntax_pass": true, "original_string": "    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "accept", "params": [{"name": "visitor", "type": "Visitor"}], "body": "                                                  {\n      visitor.visit(this);\n    }", "signature": "@Override public void accept(Visitor visitor)"}, {"syntax_pass": true, "original_string": "    @Override protected AstWriter unparse(AstWriter w, From from, int ordinal,\n        int left, int right) {\n      w.append(ordinal == 0 ? \" \" : \" join \")\n          // for these purposes 'in' has same precedence as '='\n          .append(pat, 0, Op.EQ.left);\n      if (Extents.isInfinite(exp)) {\n        // Print \"from x : int\" rather \"from x in extent 'int'\"\n        w.append(\" : \")\n            .append(((ListType) exp.type).elementType.moniker());\n      } else {\n        w.append(\" in \")\n            .append(exp, Op.EQ.right, 0);\n      }\n      if (!isLiteralTrue()) {\n        w.append(\"on\").append(condition, 0, 0);\n      }\n      return w;\n    }", "docstring": "", "attributes": {"modifiers": "@Override protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "AstWriter", "classes": []}, "name": "unparse", "params": [{"name": "w", "type": "AstWriter"}, {"name": "from", "type": "From"}, {"name": "ordinal", "type": "int"}, {"name": "left", "type": "int"}, {"name": "right", "type": "int"}], "body": "                             {\n      w.append(ordinal == 0 ? \" \" : \" join \")\n          // for these purposes 'in' has same precedence as '='\n          .append(pat, 0, Op.EQ.left);\n      if (Extents.isInfinite(exp)) {\n        // Print \"from x : int\" rather \"from x in extent 'int'\"\n        w.append(\" : \")\n            .append(((ListType) exp.type).elementType.moniker());\n      } else {\n        w.append(\" in \")\n            .append(exp, Op.EQ.right, 0);\n      }\n      if (!isLiteralTrue()) {\n        w.append(\"on\").append(condition, 0, 0);\n      }\n      return w;\n    }", "signature": "@Override protected AstWriter unparse(AstWriter w, From from, int ordinal,\n        int left, int right)"}, {"syntax_pass": true, "original_string": "    private boolean isLiteralTrue() {\n      return condition.op == Op.BOOL_LITERAL\n          && ((Literal) condition).unwrap(Boolean.class);\n    }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isLiteralTrue", "params": [], "body": "                                    {\n      return condition.op == Op.BOOL_LITERAL\n          && ((Literal) condition).unwrap(Boolean.class);\n    }", "signature": "private boolean isLiteralTrue()"}, {"syntax_pass": true, "original_string": "    public Scan copy(List<Binding> bindings, Pat pat, Exp exp, Exp condition) {\n      return pat == this.pat\n          && exp == this.exp\n          && condition == this.condition\n          && bindings.equals(this.bindings)\n          ? this\n          : core.scan(bindings, pat, exp, condition);\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Scan", "classes": []}, "name": "copy", "params": [{"name": "bindings", "type": "List<Binding>"}, {"name": "pat", "type": "Pat"}, {"name": "exp", "type": "Exp"}, {"name": "condition", "type": "Exp"}], "body": "                                                                              {\n      return pat == this.pat\n          && exp == this.exp\n          && condition == this.condition\n          && bindings.equals(this.bindings)\n          ? this\n          : core.scan(bindings, pat, exp, condition);\n    }", "signature": "public Scan copy(List<Binding> bindings, Pat pat, Exp exp, Exp condition)"}]}, {"original_string": "  public static class Where extends FromStep {\n    public final Exp exp;\n\n    Where(ImmutableList<Binding> bindings, Exp exp) {\n      super(Op.WHERE, bindings);\n      this.exp = requireNonNull(exp, \"exp\");\n    }\n\n    @Override public Where accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }\n\n    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }\n\n    @Override protected AstWriter unparse(AstWriter w, From from, int ordinal,\n        int left, int right) {\n      return w.append(\" where \").append(exp, 0, 0);\n    }\n\n    public Where copy(Exp exp, List<Binding> bindings) {\n      return exp == this.exp\n          && bindings.equals(this.bindings)\n          ? this\n          : core.where(bindings, exp);\n    }\n  }", "definition": "  public static class Where extends FromStep", "class_docstring": " A {@code where} clause in a {@code from} expression.", "name": "Where", "super_interfaces": [], "superclasses": "FromStep", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [{"attribute_expression": "public final Exp exp;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "Exp", "name": "exp", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    Where(ImmutableList<Binding> bindings, Exp exp) {\n      super(Op.WHERE, bindings);\n      this.exp = requireNonNull(exp, \"exp\");\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "Where", "params": [{"name": "bindings", "type": "ImmutableList<Binding>"}, {"name": "exp", "type": "Exp"}], "body": "                                                    {\n      super(Op.WHERE, bindings);\n      this.exp = requireNonNull(exp, \"exp\");\n    }", "signature": "Where(ImmutableList<Binding> bindings, Exp exp)"}, {"syntax_pass": true, "original_string": "    @Override public Where accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Where", "classes": []}, "name": "accept", "params": [{"name": "shuttle", "type": "Shuttle"}], "body": "                                                   {\n      return shuttle.visit(this);\n    }", "signature": "@Override public Where accept(Shuttle shuttle)"}, {"syntax_pass": true, "original_string": "    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "accept", "params": [{"name": "visitor", "type": "Visitor"}], "body": "                                                  {\n      visitor.visit(this);\n    }", "signature": "@Override public void accept(Visitor visitor)"}, {"syntax_pass": true, "original_string": "    @Override protected AstWriter unparse(AstWriter w, From from, int ordinal,\n        int left, int right) {\n      return w.append(\" where \").append(exp, 0, 0);\n    }", "docstring": "", "attributes": {"modifiers": "@Override protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "AstWriter", "classes": []}, "name": "unparse", "params": [{"name": "w", "type": "AstWriter"}, {"name": "from", "type": "From"}, {"name": "ordinal", "type": "int"}, {"name": "left", "type": "int"}, {"name": "right", "type": "int"}], "body": "                             {\n      return w.append(\" where \").append(exp, 0, 0);\n    }", "signature": "@Override protected AstWriter unparse(AstWriter w, From from, int ordinal,\n        int left, int right)"}, {"syntax_pass": true, "original_string": "    public Where copy(Exp exp, List<Binding> bindings) {\n      return exp == this.exp\n          && bindings.equals(this.bindings)\n          ? this\n          : core.where(bindings, exp);\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Where", "classes": []}, "name": "copy", "params": [{"name": "exp", "type": "Exp"}, {"name": "bindings", "type": "List<Binding>"}], "body": "                                                       {\n      return exp == this.exp\n          && bindings.equals(this.bindings)\n          ? this\n          : core.where(bindings, exp);\n    }", "signature": "public Where copy(Exp exp, List<Binding> bindings)"}]}, {"original_string": "  public static class Skip extends FromStep {\n    public final Exp exp;\n\n    Skip(ImmutableList<Binding> bindings, Exp exp) {\n      super(Op.SKIP, bindings);\n      this.exp = requireNonNull(exp, \"exp\");\n    }\n\n    @Override public Skip accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }\n\n    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }\n\n    @Override protected AstWriter unparse(AstWriter w, From from, int ordinal,\n        int left, int right) {\n      return w.append(\" skip \").append(exp, 0, 0);\n    }\n\n    public Skip copy(Exp exp, List<Binding> bindings) {\n      return exp == this.exp\n          && bindings.equals(this.bindings)\n          ? this\n          : core.skip(bindings, exp);\n    }\n  }", "definition": "  public static class Skip extends FromStep", "class_docstring": " A {@code skip} clause in a {@code from} expression.", "name": "Skip", "super_interfaces": [], "superclasses": "FromStep", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [{"attribute_expression": "public final Exp exp;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "Exp", "name": "exp", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    Skip(ImmutableList<Binding> bindings, Exp exp) {\n      super(Op.SKIP, bindings);\n      this.exp = requireNonNull(exp, \"exp\");\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "Skip", "params": [{"name": "bindings", "type": "ImmutableList<Binding>"}, {"name": "exp", "type": "Exp"}], "body": "                                                   {\n      super(Op.SKIP, bindings);\n      this.exp = requireNonNull(exp, \"exp\");\n    }", "signature": "Skip(ImmutableList<Binding> bindings, Exp exp)"}, {"syntax_pass": true, "original_string": "    @Override public Skip accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Skip", "classes": []}, "name": "accept", "params": [{"name": "shuttle", "type": "Shuttle"}], "body": "                                                  {\n      return shuttle.visit(this);\n    }", "signature": "@Override public Skip accept(Shuttle shuttle)"}, {"syntax_pass": true, "original_string": "    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "accept", "params": [{"name": "visitor", "type": "Visitor"}], "body": "                                                  {\n      visitor.visit(this);\n    }", "signature": "@Override public void accept(Visitor visitor)"}, {"syntax_pass": true, "original_string": "    @Override protected AstWriter unparse(AstWriter w, From from, int ordinal,\n        int left, int right) {\n      return w.append(\" skip \").append(exp, 0, 0);\n    }", "docstring": "", "attributes": {"modifiers": "@Override protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "AstWriter", "classes": []}, "name": "unparse", "params": [{"name": "w", "type": "AstWriter"}, {"name": "from", "type": "From"}, {"name": "ordinal", "type": "int"}, {"name": "left", "type": "int"}, {"name": "right", "type": "int"}], "body": "                             {\n      return w.append(\" skip \").append(exp, 0, 0);\n    }", "signature": "@Override protected AstWriter unparse(AstWriter w, From from, int ordinal,\n        int left, int right)"}, {"syntax_pass": true, "original_string": "    public Skip copy(Exp exp, List<Binding> bindings) {\n      return exp == this.exp\n          && bindings.equals(this.bindings)\n          ? this\n          : core.skip(bindings, exp);\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Skip", "classes": []}, "name": "copy", "params": [{"name": "exp", "type": "Exp"}, {"name": "bindings", "type": "List<Binding>"}], "body": "                                                      {\n      return exp == this.exp\n          && bindings.equals(this.bindings)\n          ? this\n          : core.skip(bindings, exp);\n    }", "signature": "public Skip copy(Exp exp, List<Binding> bindings)"}]}, {"original_string": "  public static class Take extends FromStep {\n    public final Exp exp;\n\n    Take(ImmutableList<Binding> bindings, Exp exp) {\n      super(Op.TAKE, bindings);\n      this.exp = requireNonNull(exp, \"exp\");\n    }\n\n    @Override public Take accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }\n\n    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }\n\n    @Override protected AstWriter unparse(AstWriter w, From from, int ordinal,\n        int left, int right) {\n      return w.append(\" take \").append(exp, 0, 0);\n    }\n\n    public Take copy(Exp exp, List<Binding> bindings) {\n      return exp == this.exp\n          && bindings.equals(this.bindings)\n          ? this\n          : core.take(bindings, exp);\n    }\n  }", "definition": "  public static class Take extends FromStep", "class_docstring": " A {@code take} clause in a {@code from} expression.", "name": "Take", "super_interfaces": [], "superclasses": "FromStep", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [{"attribute_expression": "public final Exp exp;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "Exp", "name": "exp", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    Take(ImmutableList<Binding> bindings, Exp exp) {\n      super(Op.TAKE, bindings);\n      this.exp = requireNonNull(exp, \"exp\");\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "Take", "params": [{"name": "bindings", "type": "ImmutableList<Binding>"}, {"name": "exp", "type": "Exp"}], "body": "                                                   {\n      super(Op.TAKE, bindings);\n      this.exp = requireNonNull(exp, \"exp\");\n    }", "signature": "Take(ImmutableList<Binding> bindings, Exp exp)"}, {"syntax_pass": true, "original_string": "    @Override public Take accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Take", "classes": []}, "name": "accept", "params": [{"name": "shuttle", "type": "Shuttle"}], "body": "                                                  {\n      return shuttle.visit(this);\n    }", "signature": "@Override public Take accept(Shuttle shuttle)"}, {"syntax_pass": true, "original_string": "    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "accept", "params": [{"name": "visitor", "type": "Visitor"}], "body": "                                                  {\n      visitor.visit(this);\n    }", "signature": "@Override public void accept(Visitor visitor)"}, {"syntax_pass": true, "original_string": "    @Override protected AstWriter unparse(AstWriter w, From from, int ordinal,\n        int left, int right) {\n      return w.append(\" take \").append(exp, 0, 0);\n    }", "docstring": "", "attributes": {"modifiers": "@Override protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "AstWriter", "classes": []}, "name": "unparse", "params": [{"name": "w", "type": "AstWriter"}, {"name": "from", "type": "From"}, {"name": "ordinal", "type": "int"}, {"name": "left", "type": "int"}, {"name": "right", "type": "int"}], "body": "                             {\n      return w.append(\" take \").append(exp, 0, 0);\n    }", "signature": "@Override protected AstWriter unparse(AstWriter w, From from, int ordinal,\n        int left, int right)"}, {"syntax_pass": true, "original_string": "    public Take copy(Exp exp, List<Binding> bindings) {\n      return exp == this.exp\n          && bindings.equals(this.bindings)\n          ? this\n          : core.take(bindings, exp);\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Take", "classes": []}, "name": "copy", "params": [{"name": "exp", "type": "Exp"}, {"name": "bindings", "type": "List<Binding>"}], "body": "                                                      {\n      return exp == this.exp\n          && bindings.equals(this.bindings)\n          ? this\n          : core.take(bindings, exp);\n    }", "signature": "public Take copy(Exp exp, List<Binding> bindings)"}]}, {"original_string": "  public static class Order extends FromStep {\n    public final ImmutableList<OrderItem> orderItems;\n\n    Order(ImmutableList<Binding> bindings,\n        ImmutableList<OrderItem> orderItems) {\n      super(Op.ORDER, bindings);\n      this.orderItems = requireNonNull(orderItems);\n    }\n\n    @Override public Order accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }\n\n    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }\n\n    @Override protected AstWriter unparse(AstWriter w, From from, int ordinal,\n        int left, int right) {\n      return w.append(\" order \").appendAll(orderItems, \", \");\n    }\n\n    public Order copy(List<Binding> bindings,\n        List<OrderItem> orderItems) {\n      return bindings.equals(this.bindings)\n          && orderItems.equals(this.orderItems)\n          ? this\n          : core.order(bindings, orderItems);\n    }\n  }", "definition": "  public static class Order extends FromStep", "class_docstring": " An {@code order} clause in a {@code from} expression.", "name": "Order", "super_interfaces": [], "superclasses": "FromStep", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [{"attribute_expression": "public final ImmutableList<OrderItem> orderItems;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "ImmutableList<OrderItem>", "name": "orderItems", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    Order(ImmutableList<Binding> bindings,\n        ImmutableList<OrderItem> orderItems) {\n      super(Op.ORDER, bindings);\n      this.orderItems = requireNonNull(orderItems);\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "Order", "params": [{"name": "bindings", "type": "ImmutableList<Binding>"}, {"name": "orderItems", "type": "ImmutableList<OrderItem>"}], "body": "                                             {\n      super(Op.ORDER, bindings);\n      this.orderItems = requireNonNull(orderItems);\n    }", "signature": "Order(ImmutableList<Binding> bindings,\n        ImmutableList<OrderItem> orderItems)"}, {"syntax_pass": true, "original_string": "    @Override public Order accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Order", "classes": []}, "name": "accept", "params": [{"name": "shuttle", "type": "Shuttle"}], "body": "                                                   {\n      return shuttle.visit(this);\n    }", "signature": "@Override public Order accept(Shuttle shuttle)"}, {"syntax_pass": true, "original_string": "    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "accept", "params": [{"name": "visitor", "type": "Visitor"}], "body": "                                                  {\n      visitor.visit(this);\n    }", "signature": "@Override public void accept(Visitor visitor)"}, {"syntax_pass": true, "original_string": "    @Override protected AstWriter unparse(AstWriter w, From from, int ordinal,\n        int left, int right) {\n      return w.append(\" order \").appendAll(orderItems, \", \");\n    }", "docstring": "", "attributes": {"modifiers": "@Override protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "AstWriter", "classes": []}, "name": "unparse", "params": [{"name": "w", "type": "AstWriter"}, {"name": "from", "type": "From"}, {"name": "ordinal", "type": "int"}, {"name": "left", "type": "int"}, {"name": "right", "type": "int"}], "body": "                             {\n      return w.append(\" order \").appendAll(orderItems, \", \");\n    }", "signature": "@Override protected AstWriter unparse(AstWriter w, From from, int ordinal,\n        int left, int right)"}, {"syntax_pass": true, "original_string": "    public Order copy(List<Binding> bindings,\n        List<OrderItem> orderItems) {\n      return bindings.equals(this.bindings)\n          && orderItems.equals(this.orderItems)\n          ? this\n          : core.order(bindings, orderItems);\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Order", "classes": []}, "name": "copy", "params": [{"name": "bindings", "type": "List<Binding>"}, {"name": "orderItems", "type": "List<OrderItem>"}], "body": "                                    {\n      return bindings.equals(this.bindings)\n          && orderItems.equals(this.orderItems)\n          ? this\n          : core.order(bindings, orderItems);\n    }", "signature": "public Order copy(List<Binding> bindings,\n        List<OrderItem> orderItems)"}]}, {"original_string": "  public static class OrderItem extends BaseNode {\n    public final Exp exp;\n    public final Ast.Direction direction;\n\n    OrderItem(Exp exp, Ast.Direction direction) {\n      super(Pos.ZERO, Op.ORDER_ITEM);\n      this.exp = requireNonNull(exp);\n      this.direction = requireNonNull(direction);\n    }\n\n    @Override public AstNode accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }\n\n    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }\n\n    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      return w.append(exp, 0, 0)\n          .append(direction == Ast.Direction.DESC ? \" desc\" : \"\");\n    }\n\n    public OrderItem copy(Exp exp, Ast.Direction direction) {\n      return exp == this.exp && direction == this.direction ? this\n          : core.orderItem(exp, direction);\n    }\n  }", "definition": "  public static class OrderItem extends BaseNode", "class_docstring": " An item in an {@code order} clause.", "name": "OrderItem", "super_interfaces": [], "superclasses": "BaseNode", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [{"attribute_expression": "public final Exp exp;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "Exp", "name": "exp", "syntax_pass": true}, {"attribute_expression": "public final Ast.Direction direction;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "Ast.Direction", "name": "direction", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    OrderItem(Exp exp, Ast.Direction direction) {\n      super(Pos.ZERO, Op.ORDER_ITEM);\n      this.exp = requireNonNull(exp);\n      this.direction = requireNonNull(direction);\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "OrderItem", "params": [{"name": "exp", "type": "Exp"}, {"name": "direction", "type": "Ast.Direction"}], "body": "                                                {\n      super(Pos.ZERO, Op.ORDER_ITEM);\n      this.exp = requireNonNull(exp);\n      this.direction = requireNonNull(direction);\n    }", "signature": "OrderItem(Exp exp, Ast.Direction direction)"}, {"syntax_pass": true, "original_string": "    @Override public AstNode accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "AstNode", "classes": []}, "name": "accept", "params": [{"name": "shuttle", "type": "Shuttle"}], "body": "                                                     {\n      return shuttle.visit(this);\n    }", "signature": "@Override public AstNode accept(Shuttle shuttle)"}, {"syntax_pass": true, "original_string": "    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "accept", "params": [{"name": "visitor", "type": "Visitor"}], "body": "                                                  {\n      visitor.visit(this);\n    }", "signature": "@Override public void accept(Visitor visitor)"}, {"syntax_pass": true, "original_string": "    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      return w.append(exp, 0, 0)\n          .append(direction == Ast.Direction.DESC ? \" desc\" : \"\");\n    }", "docstring": "", "attributes": {"modifiers": "@Override", "marker_annotations": ["@Override"], "non_marker_annotations": [], "comments": [], "return_type": "AstWriter", "classes": []}, "name": "unparse", "params": [{"name": "w", "type": "AstWriter"}, {"name": "left", "type": "int"}, {"name": "right", "type": "int"}], "body": "                                                                  {\n      return w.append(exp, 0, 0)\n          .append(direction == Ast.Direction.DESC ? \" desc\" : \"\");\n    }", "signature": "@Override AstWriter unparse(AstWriter w, int left, int right)"}, {"syntax_pass": true, "original_string": "    public OrderItem copy(Exp exp, Ast.Direction direction) {\n      return exp == this.exp && direction == this.direction ? this\n          : core.orderItem(exp, direction);\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "OrderItem", "classes": []}, "name": "copy", "params": [{"name": "exp", "type": "Exp"}, {"name": "direction", "type": "Ast.Direction"}], "body": "                                                            {\n      return exp == this.exp && direction == this.direction ? this\n          : core.orderItem(exp, direction);\n    }", "signature": "public OrderItem copy(Exp exp, Ast.Direction direction)"}]}, {"original_string": "  public static class Group extends FromStep {\n    public final SortedMap<Core.IdPat, Exp> groupExps;\n    public final SortedMap<Core.IdPat, Aggregate> aggregates;\n\n    Group(ImmutableList<Binding> bindings,\n        ImmutableSortedMap<Core.IdPat, Exp> groupExps,\n        ImmutableSortedMap<Core.IdPat, Aggregate> aggregates) {\n      super(Op.GROUP, bindings);\n      this.groupExps = groupExps;\n      this.aggregates = aggregates;\n    }\n\n    @Override public Group accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }\n\n    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }\n\n    @Override protected AstWriter unparse(AstWriter w, From from, int ordinal,\n        int left, int right) {\n      w.append(\" group\");\n      Pair.forEachIndexed(groupExps, (i, id, exp) -> // lint:skip\n          w.append(i == 0 ? \" \" : \", \")\n              .append(id, 0, 0).append(\" = \").append(exp, 0, 0));\n      Pair.forEachIndexed(aggregates, (i, name, aggregate) -> // lint:skip\n          w.append(i == 0 ? \" compute \" : \", \")\n              .append(name, 0, 0).append(\" = \").append(aggregate, 0, 0));\n      return w;\n    }\n\n    public Group copy(SortedMap<Core.IdPat, Exp> groupExps,\n        SortedMap<Core.IdPat, Aggregate> aggregates) {\n      return groupExps.equals(this.groupExps)\n          && aggregates.equals(this.aggregates)\n          ? this\n          : core.group(groupExps, aggregates);\n    }\n  }", "definition": "  public static class Group extends FromStep", "class_docstring": " A {@code group} clause in a {@code from} expression.", "name": "Group", "super_interfaces": [], "superclasses": "FromStep", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [{"attribute_expression": "public final SortedMap<Core.IdPat, Exp> groupExps;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "SortedMap<Core.IdPat, Exp>", "name": "groupExps", "syntax_pass": true}, {"attribute_expression": "public final SortedMap<Core.IdPat, Aggregate> aggregates;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "SortedMap<Core.IdPat, Aggregate>", "name": "aggregates", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    Group(ImmutableList<Binding> bindings,\n        ImmutableSortedMap<Core.IdPat, Exp> groupExps,\n        ImmutableSortedMap<Core.IdPat, Aggregate> aggregates) {\n      super(Op.GROUP, bindings);\n      this.groupExps = groupExps;\n      this.aggregates = aggregates;\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "Group", "params": [{"name": "bindings", "type": "ImmutableList<Binding>"}, {"name": "groupExps", "type": "ImmutableSortedMap<Core.IdPat, Exp>"}, {"name": "aggregates", "type": "ImmutableSortedMap<Core.IdPat, Aggregate>"}], "body": "                                                              {\n      super(Op.GROUP, bindings);\n      this.groupExps = groupExps;\n      this.aggregates = aggregates;\n    }", "signature": "Group(ImmutableList<Binding> bindings,\n        ImmutableSortedMap<Core.IdPat, Exp> groupExps,\n        ImmutableSortedMap<Core.IdPat, Aggregate> aggregates)"}, {"syntax_pass": true, "original_string": "    @Override public Group accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Group", "classes": []}, "name": "accept", "params": [{"name": "shuttle", "type": "Shuttle"}], "body": "                                                   {\n      return shuttle.visit(this);\n    }", "signature": "@Override public Group accept(Shuttle shuttle)"}, {"syntax_pass": true, "original_string": "    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "accept", "params": [{"name": "visitor", "type": "Visitor"}], "body": "                                                  {\n      visitor.visit(this);\n    }", "signature": "@Override public void accept(Visitor visitor)"}, {"syntax_pass": true, "original_string": "    @Override protected AstWriter unparse(AstWriter w, From from, int ordinal,\n        int left, int right) {\n      w.append(\" group\");\n      Pair.forEachIndexed(groupExps, (i, id, exp) -> // lint:skip\n          w.append(i == 0 ? \" \" : \", \")\n              .append(id, 0, 0).append(\" = \").append(exp, 0, 0));\n      Pair.forEachIndexed(aggregates, (i, name, aggregate) -> // lint:skip\n          w.append(i == 0 ? \" compute \" : \", \")\n              .append(name, 0, 0).append(\" = \").append(aggregate, 0, 0));\n      return w;\n    }", "docstring": "", "attributes": {"modifiers": "@Override protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "AstWriter", "classes": []}, "name": "unparse", "params": [{"name": "w", "type": "AstWriter"}, {"name": "from", "type": "From"}, {"name": "ordinal", "type": "int"}, {"name": "left", "type": "int"}, {"name": "right", "type": "int"}], "body": "                             {\n      w.append(\" group\");\n      Pair.forEachIndexed(groupExps, (i, id, exp) -> // lint:skip\n          w.append(i == 0 ? \" \" : \", \")\n              .append(id, 0, 0).append(\" = \").append(exp, 0, 0));\n      Pair.forEachIndexed(aggregates, (i, name, aggregate) -> // lint:skip\n          w.append(i == 0 ? \" compute \" : \", \")\n              .append(name, 0, 0).append(\" = \").append(aggregate, 0, 0));\n      return w;\n    }", "signature": "@Override protected AstWriter unparse(AstWriter w, From from, int ordinal,\n        int left, int right)"}, {"syntax_pass": true, "original_string": "    public Group copy(SortedMap<Core.IdPat, Exp> groupExps,\n        SortedMap<Core.IdPat, Aggregate> aggregates) {\n      return groupExps.equals(this.groupExps)\n          && aggregates.equals(this.aggregates)\n          ? this\n          : core.group(groupExps, aggregates);\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Group", "classes": []}, "name": "copy", "params": [{"name": "groupExps", "type": "SortedMap<Core.IdPat, Exp>"}, {"name": "aggregates", "type": "SortedMap<Core.IdPat, Aggregate>"}], "body": "                                                     {\n      return groupExps.equals(this.groupExps)\n          && aggregates.equals(this.aggregates)\n          ? this\n          : core.group(groupExps, aggregates);\n    }", "signature": "public Group copy(SortedMap<Core.IdPat, Exp> groupExps,\n        SortedMap<Core.IdPat, Aggregate> aggregates)"}]}, {"original_string": "  public static class Yield extends FromStep {\n    public final Exp exp;\n\n    Yield(ImmutableList<Binding> bindings, Exp exp) {\n      super(Op.YIELD, bindings);\n      this.exp = exp;\n    }\n\n    @Override protected AstWriter unparse(AstWriter w, From from, int ordinal,\n        int left, int right) {\n      return w.append(\" yield \").append(exp, 0, 0);\n    }\n\n    @Override public Yield accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }\n\n    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }\n\n    public Yield copy(List<Binding> bindings, Exp exp) {\n      return bindings.equals(this.bindings)\n          && exp == this.exp\n          ? this\n          : core.yield_(bindings, exp);\n    }\n  }", "definition": "  public static class Yield extends FromStep", "class_docstring": " Step that computes an expression.", "name": "Yield", "super_interfaces": [], "superclasses": "FromStep", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [{"attribute_expression": "public final Exp exp;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "Exp", "name": "exp", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    Yield(ImmutableList<Binding> bindings, Exp exp) {\n      super(Op.YIELD, bindings);\n      this.exp = exp;\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "Yield", "params": [{"name": "bindings", "type": "ImmutableList<Binding>"}, {"name": "exp", "type": "Exp"}], "body": "                                                    {\n      super(Op.YIELD, bindings);\n      this.exp = exp;\n    }", "signature": "Yield(ImmutableList<Binding> bindings, Exp exp)"}, {"syntax_pass": true, "original_string": "    @Override protected AstWriter unparse(AstWriter w, From from, int ordinal,\n        int left, int right) {\n      return w.append(\" yield \").append(exp, 0, 0);\n    }", "docstring": "", "attributes": {"modifiers": "@Override protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "AstWriter", "classes": []}, "name": "unparse", "params": [{"name": "w", "type": "AstWriter"}, {"name": "from", "type": "From"}, {"name": "ordinal", "type": "int"}, {"name": "left", "type": "int"}, {"name": "right", "type": "int"}], "body": "                             {\n      return w.append(\" yield \").append(exp, 0, 0);\n    }", "signature": "@Override protected AstWriter unparse(AstWriter w, From from, int ordinal,\n        int left, int right)"}, {"syntax_pass": true, "original_string": "    @Override public Yield accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Yield", "classes": []}, "name": "accept", "params": [{"name": "shuttle", "type": "Shuttle"}], "body": "                                                   {\n      return shuttle.visit(this);\n    }", "signature": "@Override public Yield accept(Shuttle shuttle)"}, {"syntax_pass": true, "original_string": "    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "accept", "params": [{"name": "visitor", "type": "Visitor"}], "body": "                                                  {\n      visitor.visit(this);\n    }", "signature": "@Override public void accept(Visitor visitor)"}, {"syntax_pass": true, "original_string": "    public Yield copy(List<Binding> bindings, Exp exp) {\n      return bindings.equals(this.bindings)\n          && exp == this.exp\n          ? this\n          : core.yield_(bindings, exp);\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Yield", "classes": []}, "name": "copy", "params": [{"name": "bindings", "type": "List<Binding>"}, {"name": "exp", "type": "Exp"}], "body": "                                                       {\n      return bindings.equals(this.bindings)\n          && exp == this.exp\n          ? this\n          : core.yield_(bindings, exp);\n    }", "signature": "public Yield copy(List<Binding> bindings, Exp exp)"}]}, {"original_string": "  public static class Apply extends Exp {\n    public final Exp fn;\n    public final Exp arg;\n\n    Apply(Pos pos, Type type, Exp fn, Exp arg) {\n      super(pos, Op.APPLY, type);\n      this.fn = fn;\n      this.arg = arg;\n    }\n\n    /** Returns the argument list (assuming that the arguments are a tuple\n     * or record).\n     *\n     * @throws ClassCastException if argument is not a tuple */\n    public List<Exp> args() {\n      return ((Tuple) arg).args;\n    }\n\n    @Override public Exp arg(int i) {\n      // Throws if the argument is not a tuple.\n      return arg.arg(i);\n    }\n\n    @Override public Exp accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }\n\n    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }\n\n    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      switch (fn.op) {\n      case FN_LITERAL:\n        final BuiltIn builtIn = ((Literal) fn).unwrap(BuiltIn.class);\n\n        // Because the Core language is narrower than AST, a few AST expression\n        // types do not exist in Core and are translated to function\n        // applications. Here we convert them back to original syntax.\n        switch (builtIn) {\n        case Z_LIST:\n          w.append(\"[\");\n          arg.forEachArg((arg, i) -> w.append(i == 0 ? \"\" : \", \").append(arg, 0, 0));\n          return w.append(\"]\");\n        }\n\n        // Convert built-ins to infix operators.\n        final Op op = Resolver.BUILT_IN_OP_MAP.get(builtIn);\n        if (op != null) {\n          return w.infix(left, args().get(0), op, args().get(1), right);\n        }\n      }\n      return w.infix(left, fn, op, arg, right);\n    }\n\n    public Apply copy(Exp fn, Exp arg) {\n      return fn == this.fn && arg == this.arg ? this\n          : core.apply(pos, type, fn, arg);\n    }\n\n    @Override public boolean isConstant() {\n      // A list of constants is constant\n      return isCallTo(BuiltIn.Z_LIST)\n          && args().stream().allMatch(Exp::isConstant);\n    }\n\n    @Override public boolean isCallTo(BuiltIn builtIn) {\n      return fn.op == Op.FN_LITERAL\n          && ((Literal) fn).unwrap(BuiltIn.class) == builtIn;\n    }\n  }", "definition": "  public static class Apply extends Exp", "class_docstring": " Application of a function to its argument.", "name": "Apply", "super_interfaces": [], "superclasses": "Exp", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [{"attribute_expression": "public final Exp fn;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "Exp", "name": "fn", "syntax_pass": true}, {"attribute_expression": "public final Exp arg;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "Exp", "name": "arg", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    Apply(Pos pos, Type type, Exp fn, Exp arg) {\n      super(pos, Op.APPLY, type);\n      this.fn = fn;\n      this.arg = arg;\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "Apply", "params": [{"name": "pos", "type": "Pos"}, {"name": "type", "type": "Type"}, {"name": "fn", "type": "Exp"}, {"name": "arg", "type": "Exp"}], "body": "                                               {\n      super(pos, Op.APPLY, type);\n      this.fn = fn;\n      this.arg = arg;\n    }", "signature": "Apply(Pos pos, Type type, Exp fn, Exp arg)"}, {"syntax_pass": true, "original_string": "    public List<Exp> args() {\n      return ((Tuple) arg).args;\n    }", "docstring": " Returns the argument list (assuming that the arguments are a tuple\nor record).\n\n@throws ClassCastException if argument is not a tuple", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "List<Exp>", "classes": []}, "name": "args", "params": [], "body": "                            {\n      return ((Tuple) arg).args;\n    }", "signature": "public List<Exp> args()"}, {"syntax_pass": true, "original_string": "    @Override public Exp arg(int i) {\n      // Throws if the argument is not a tuple.\n      return arg.arg(i);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Exp", "classes": []}, "name": "arg", "params": [{"name": "i", "type": "int"}], "body": "                                    {\n      // Throws if the argument is not a tuple.\n      return arg.arg(i);\n    }", "signature": "@Override public Exp arg(int i)"}, {"syntax_pass": true, "original_string": "    @Override public Exp accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Exp", "classes": []}, "name": "accept", "params": [{"name": "shuttle", "type": "Shuttle"}], "body": "                                                 {\n      return shuttle.visit(this);\n    }", "signature": "@Override public Exp accept(Shuttle shuttle)"}, {"syntax_pass": true, "original_string": "    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "accept", "params": [{"name": "visitor", "type": "Visitor"}], "body": "                                                  {\n      visitor.visit(this);\n    }", "signature": "@Override public void accept(Visitor visitor)"}, {"syntax_pass": true, "original_string": "    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      switch (fn.op) {\n      case FN_LITERAL:\n        final BuiltIn builtIn = ((Literal) fn).unwrap(BuiltIn.class);\n\n        // Because the Core language is narrower than AST, a few AST expression\n        // types do not exist in Core and are translated to function\n        // applications. Here we convert them back to original syntax.\n        switch (builtIn) {\n        case Z_LIST:\n          w.append(\"[\");\n          arg.forEachArg((arg, i) -> w.append(i == 0 ? \"\" : \", \").append(arg, 0, 0));\n          return w.append(\"]\");\n        }\n\n        // Convert built-ins to infix operators.\n        final Op op = Resolver.BUILT_IN_OP_MAP.get(builtIn);\n        if (op != null) {\n          return w.infix(left, args().get(0), op, args().get(1), right);\n        }\n      }\n      return w.infix(left, fn, op, arg, right);\n    }", "docstring": "", "attributes": {"modifiers": "@Override", "marker_annotations": ["@Override"], "non_marker_annotations": [], "comments": [], "return_type": "AstWriter", "classes": []}, "name": "unparse", "params": [{"name": "w", "type": "AstWriter"}, {"name": "left", "type": "int"}, {"name": "right", "type": "int"}], "body": "                                                                  {\n      switch (fn.op) {\n      case FN_LITERAL:\n        final BuiltIn builtIn = ((Literal) fn).unwrap(BuiltIn.class);\n\n        // Because the Core language is narrower than AST, a few AST expression\n        // types do not exist in Core and are translated to function\n        // applications. Here we convert them back to original syntax.\n        switch (builtIn) {\n        case Z_LIST:\n          w.append(\"[\");\n          arg.forEachArg((arg, i) -> w.append(i == 0 ? \"\" : \", \").append(arg, 0, 0));\n          return w.append(\"]\");\n        }\n\n        // Convert built-ins to infix operators.\n        final Op op = Resolver.BUILT_IN_OP_MAP.get(builtIn);\n        if (op != null) {\n          return w.infix(left, args().get(0), op, args().get(1), right);\n        }\n      }\n      return w.infix(left, fn, op, arg, right);\n    }", "signature": "@Override AstWriter unparse(AstWriter w, int left, int right)"}, {"syntax_pass": true, "original_string": "    public Apply copy(Exp fn, Exp arg) {\n      return fn == this.fn && arg == this.arg ? this\n          : core.apply(pos, type, fn, arg);\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Apply", "classes": []}, "name": "copy", "params": [{"name": "fn", "type": "Exp"}, {"name": "arg", "type": "Exp"}], "body": "                                       {\n      return fn == this.fn && arg == this.arg ? this\n          : core.apply(pos, type, fn, arg);\n    }", "signature": "public Apply copy(Exp fn, Exp arg)"}, {"syntax_pass": true, "original_string": "    @Override public boolean isConstant() {\n      // A list of constants is constant\n      return isCallTo(BuiltIn.Z_LIST)\n          && args().stream().allMatch(Exp::isConstant);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isConstant", "params": [], "body": "                                          {\n      // A list of constants is constant\n      return isCallTo(BuiltIn.Z_LIST)\n          && args().stream().allMatch(Exp::isConstant);\n    }", "signature": "@Override public boolean isConstant()"}, {"syntax_pass": true, "original_string": "    @Override public boolean isCallTo(BuiltIn builtIn) {\n      return fn.op == Op.FN_LITERAL\n          && ((Literal) fn).unwrap(BuiltIn.class) == builtIn;\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isCallTo", "params": [{"name": "builtIn", "type": "BuiltIn"}], "body": "                                                       {\n      return fn.op == Op.FN_LITERAL\n          && ((Literal) fn).unwrap(BuiltIn.class) == builtIn;\n    }", "signature": "@Override public boolean isCallTo(BuiltIn builtIn)"}]}, {"original_string": "  public static class Aggregate extends BaseNode {\n    public final Type type;\n    public final Exp aggregate;\n    public final @Nullable Exp argument;\n\n    Aggregate(Type type, Exp aggregate, @Nullable Exp argument) {\n      super(Pos.ZERO, Op.AGGREGATE);\n      this.type = type;\n      this.aggregate = requireNonNull(aggregate);\n      this.argument = argument;\n    }\n\n    @Override public Aggregate accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }\n\n    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }\n\n    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      w.append(aggregate, 0, 0);\n      if (argument != null) {\n        w.append(\" of \")\n            .append(argument, 0, 0);\n      }\n      return w;\n    }\n\n    public Aggregate copy(Type type, Exp aggregate, @Nullable Exp argument) {\n      return aggregate == this.aggregate && argument == this.argument\n          ? this\n          : core.aggregate(type, aggregate, argument);\n    }\n  }", "definition": "  public static class Aggregate extends BaseNode", "class_docstring": " Call to an aggregate function in a {@code compute} clause.\n\n<p>For example, in {@code compute sumId = sum of #id e},\n{@code aggregate} is \"sum\", {@code argument} is \"#id e\".", "name": "Aggregate", "super_interfaces": [], "superclasses": "BaseNode", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [{"attribute_expression": "public final Type type;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "Type", "name": "type", "syntax_pass": true}, {"attribute_expression": "public final Exp aggregate;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "Exp", "name": "aggregate", "syntax_pass": true}, {"attribute_expression": "public final @Nullable Exp argument;", "docstring": "", "modifiers": "public final @Nullable", "marker_annotations": ["@Nullable"], "non_marker_annotations": ["public", "final"], "comments": [], "type": "Exp", "name": "argument", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    Aggregate(Type type, Exp aggregate, @Nullable Exp argument) {\n      super(Pos.ZERO, Op.AGGREGATE);\n      this.type = type;\n      this.aggregate = requireNonNull(aggregate);\n      this.argument = argument;\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "Aggregate", "params": [{"name": "type", "type": "Type"}, {"name": "aggregate", "type": "Exp"}, {"name": "argument", "type": "Exp"}], "body": "                                                                {\n      super(Pos.ZERO, Op.AGGREGATE);\n      this.type = type;\n      this.aggregate = requireNonNull(aggregate);\n      this.argument = argument;\n    }", "signature": "Aggregate(Type type, Exp aggregate, @Nullable Exp argument)"}, {"syntax_pass": true, "original_string": "    @Override public Aggregate accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Aggregate", "classes": []}, "name": "accept", "params": [{"name": "shuttle", "type": "Shuttle"}], "body": "                                                       {\n      return shuttle.visit(this);\n    }", "signature": "@Override public Aggregate accept(Shuttle shuttle)"}, {"syntax_pass": true, "original_string": "    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "accept", "params": [{"name": "visitor", "type": "Visitor"}], "body": "                                                  {\n      visitor.visit(this);\n    }", "signature": "@Override public void accept(Visitor visitor)"}, {"syntax_pass": true, "original_string": "    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      w.append(aggregate, 0, 0);\n      if (argument != null) {\n        w.append(\" of \")\n            .append(argument, 0, 0);\n      }\n      return w;\n    }", "docstring": "", "attributes": {"modifiers": "@Override", "marker_annotations": ["@Override"], "non_marker_annotations": [], "comments": [], "return_type": "AstWriter", "classes": []}, "name": "unparse", "params": [{"name": "w", "type": "AstWriter"}, {"name": "left", "type": "int"}, {"name": "right", "type": "int"}], "body": "                                                                  {\n      w.append(aggregate, 0, 0);\n      if (argument != null) {\n        w.append(\" of \")\n            .append(argument, 0, 0);\n      }\n      return w;\n    }", "signature": "@Override AstWriter unparse(AstWriter w, int left, int right)"}, {"syntax_pass": true, "original_string": "    public Aggregate copy(Type type, Exp aggregate, @Nullable Exp argument) {\n      return aggregate == this.aggregate && argument == this.argument\n          ? this\n          : core.aggregate(type, aggregate, argument);\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Aggregate", "classes": []}, "name": "copy", "params": [{"name": "type", "type": "Type"}, {"name": "aggregate", "type": "Exp"}, {"name": "argument", "type": "Exp"}], "body": "                                                                            {\n      return aggregate == this.aggregate && argument == this.argument\n          ? this\n          : core.aggregate(type, aggregate, argument);\n    }", "signature": "public Aggregate copy(Type type, Exp aggregate, @Nullable Exp argument)"}]}, {"original_string": "  static class Wrapper implements Comparable<Wrapper> {\n    private final Exp exp;\n    private final Object o;\n\n    private Wrapper(Exp exp, Object o) {\n      this.exp = exp;\n      this.o = o;\n      assert isValidValue(exp, o) : o;\n    }\n\n    private static boolean isValidValue(Exp exp, Object o) {\n      if (o instanceof Code) {\n        return false;\n      }\n      if (o instanceof Closure) {\n        return false;\n      }\n      if (o instanceof Id) {\n        final String name = ((Id) exp).idPat.name;\n        return !(\"true\".equals(name) || \"false\".equals(name));\n      }\n      return true;\n    }\n\n    @Override public int compareTo(Wrapper o) {\n      return Integer.compare(this.o.hashCode(), o.o.hashCode());\n    }\n\n    @Override public String toString() {\n      return o.toString();\n    }\n\n    @Override public int hashCode() {\n      return o.hashCode();\n    }\n\n    @Override public boolean equals(Object obj) {\n      return this == obj\n          || obj instanceof Wrapper\n          && this.o.equals(((Wrapper) obj).o);\n    }\n\n    /** Returns the value. */\n    <T> T unwrap(Class<T> valueClass) {\n      return valueClass.cast(o);\n    }\n  }", "definition": "  static class Wrapper implements Comparable<Wrapper>", "class_docstring": " Wraps a value as a Comparable, and stores the global expression from which\nthe value was derived. That global expression will be used if the value is\nconverted by to Morel code.", "name": "Wrapper", "super_interfaces": ["Comparable<Wrapper>"], "superclasses": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "fields": [{"attribute_expression": "private final Exp exp;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Exp", "name": "exp", "syntax_pass": true}, {"attribute_expression": "private final Object o;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Object", "name": "o", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    private Wrapper(Exp exp, Object o) {\n      this.exp = exp;\n      this.o = o;\n      assert isValidValue(exp, o) : o;\n    }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "", "classes": []}, "name": "Wrapper", "params": [{"name": "exp", "type": "Exp"}, {"name": "o", "type": "Object"}], "body": "                                       {\n      this.exp = exp;\n      this.o = o;\n      assert isValidValue(exp, o) : o;\n    }", "signature": "private Wrapper(Exp exp, Object o)"}, {"syntax_pass": true, "original_string": "    private static boolean isValidValue(Exp exp, Object o) {\n      if (o instanceof Code) {\n        return false;\n      }\n      if (o instanceof Closure) {\n        return false;\n      }\n      if (o instanceof Id) {\n        final String name = ((Id) exp).idPat.name;\n        return !(\"true\".equals(name) || \"false\".equals(name));\n      }\n      return true;\n    }", "docstring": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isValidValue", "params": [{"name": "exp", "type": "Exp"}, {"name": "o", "type": "Object"}], "body": "                                                           {\n      if (o instanceof Code) {\n        return false;\n      }\n      if (o instanceof Closure) {\n        return false;\n      }\n      if (o instanceof Id) {\n        final String name = ((Id) exp).idPat.name;\n        return !(\"true\".equals(name) || \"false\".equals(name));\n      }\n      return true;\n    }", "signature": "private static boolean isValidValue(Exp exp, Object o)"}, {"syntax_pass": true, "original_string": "    @Override public int compareTo(Wrapper o) {\n      return Integer.compare(this.o.hashCode(), o.o.hashCode());\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "compareTo", "params": [{"name": "o", "type": "Wrapper"}], "body": "                                              {\n      return Integer.compare(this.o.hashCode(), o.o.hashCode());\n    }", "signature": "@Override public int compareTo(Wrapper o)"}, {"syntax_pass": true, "original_string": "    @Override public String toString() {\n      return o.toString();\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "toString", "params": [], "body": "                                       {\n      return o.toString();\n    }", "signature": "@Override public String toString()"}, {"syntax_pass": true, "original_string": "    @Override public int hashCode() {\n      return o.hashCode();\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "hashCode", "params": [], "body": "                                    {\n      return o.hashCode();\n    }", "signature": "@Override public int hashCode()"}, {"syntax_pass": true, "original_string": "    @Override public boolean equals(Object obj) {\n      return this == obj\n          || obj instanceof Wrapper\n          && this.o.equals(((Wrapper) obj).o);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "equals", "params": [{"name": "obj", "type": "Object"}], "body": "                                                {\n      return this == obj\n          || obj instanceof Wrapper\n          && this.o.equals(((Wrapper) obj).o);\n    }", "signature": "@Override public boolean equals(Object obj)"}, {"syntax_pass": true, "original_string": "    <T> T unwrap(Class<T> valueClass) {\n      return valueClass.cast(o);\n    }", "docstring": " Returns the value.", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "T", "classes": []}, "name": "unwrap", "params": [{"name": "valueClass", "type": "Class<T>"}], "body": "                                      {\n      return valueClass.cast(o);\n    }", "signature": "<T> T unwrap(Class<T> valueClass)"}]}], "class_docstring": " TODO: remove 'parse tree for...' from all the comments below", "original_string": "@SuppressWarnings(\"StaticPseudoFunctionalStyleMethod\")\npublic class Core {\n  private Core() {}\n\n  /** Abstract base class of Core nodes. */\n  abstract static class BaseNode extends AstNode {\n    BaseNode(Pos pos, Op op) {\n      super(pos, op);\n    }\n\n    @Override public AstNode accept(Shuttle shuttle) {\n      throw new UnsupportedOperationException(getClass() + \" cannot accept \"\n          + shuttle.getClass());\n    }\n\n    @Override public void accept(Visitor visitor) {\n      throw new UnsupportedOperationException(getClass() + \" cannot accept \"\n          + visitor.getClass());\n    }\n  }\n\n  /** Base class for a pattern.\n   *\n   * <p>For example, \"x\" in \"val x = 5\" is a {@link IdPat};\n   * the \"(x, y) in \"val (x, y) = makePair 1 2\" is a {@link TuplePat}. */\n  public abstract static class Pat extends BaseNode {\n    public final Type type;\n\n    Pat(Op op, Type type) {\n      super(Pos.ZERO, op);\n      this.type = requireNonNull(type);\n    }\n\n    /** Returns the type. */\n    public Type type() {\n      return type;\n    }\n\n    @Override public abstract Pat accept(Shuttle shuttle);\n  }\n\n  /** Base class for named patterns ({@link IdPat} and {@link AsPat}).\n   *\n   * <p>Implements {@link Comparable} so that names are sorted correctly\n   * for record fields (see {@link RecordType#ORDERING}).\n   *\n   * <p>A {@link Core.ValDecl} must be one of these. */\n  public abstract static class NamedPat extends Pat\n      implements Comparable<NamedPat> {\n    /** Ordering that compares named patterns by their names, then by their\n     * ordinal. */\n    public static final Ordering<NamedPat> ORDERING =\n        Ordering.from(NamedPat::compare);\n\n    public final String name;\n    public final int i;\n\n    NamedPat(Op op, Type type, String name, int i) {\n      super(op, type);\n      this.name = requireNonNull(name, \"name\");\n      this.i = i;\n      checkArgument(!name.isEmpty(), \"empty name\");\n    }\n\n    /** {@inheritDoc}\n     *\n     * <p>Collate first on name, then on ordinal. */\n    @Override public int compareTo(NamedPat o) {\n      return compare(this, o);\n    }\n\n    /** Helper for {@link #ORDERING}. */\n    static int compare(NamedPat o1, NamedPat o2) {\n      int c = RecordType.compareNames(o1.name, o2.name);\n      if (c != 0) {\n        return c;\n      }\n      return Integer.compare(o1.i, o2.i);\n    }\n\n    public abstract NamedPat withType(Type type);\n\n    @Override public abstract NamedPat accept(Shuttle shuttle);\n  }\n\n  /** Named pattern.\n   *\n   * @see Ast.Id */\n  public static class IdPat extends NamedPat {\n    IdPat(Type type, String name, int i) {\n      super(Op.ID_PAT, type, name, i);\n    }\n\n    @Override public int hashCode() {\n      return name.hashCode() + i;\n    }\n\n    @Override public boolean equals(Object obj) {\n      return obj == this\n          || obj instanceof IdPat\n          && ((IdPat) obj).name.equals(name)\n          && ((IdPat) obj).i == i;\n    }\n\n    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      return w.id(name, i);\n    }\n\n    @Override public IdPat accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }\n\n    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }\n\n    @Override public IdPat withType(Type type) {\n      return type == this.type ? this : new IdPat(type, name, i);\n    }\n  }\n\n  /** Literal pattern, the pattern analog of the {@link Literal} expression.\n   *\n   * <p>For example, \"0\" in \"fun fact 0 = 1 | fact n = n * fact (n - 1)\".*/\n  @SuppressWarnings(\"rawtypes\")\n  public static class LiteralPat extends Pat {\n    public final Comparable value;\n\n    LiteralPat(Op op, Type type, Comparable value) {\n      super(op, type);\n      this.value = requireNonNull(value);\n      checkArgument(op == Op.BOOL_LITERAL_PAT\n          || op == Op.CHAR_LITERAL_PAT\n          || op == Op.INT_LITERAL_PAT\n          || op == Op.REAL_LITERAL_PAT\n          || op == Op.STRING_LITERAL_PAT);\n    }\n\n    @Override public int hashCode() {\n      return value.hashCode();\n    }\n\n    @Override public boolean equals(Object o) {\n      return o == this\n          || o instanceof LiteralPat\n          && this.value.equals(((LiteralPat) o).value);\n    }\n\n    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      return w.appendLiteral(value);\n    }\n\n    @Override public Pat accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }\n\n    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }\n  }\n\n  /** Wildcard pattern.\n   *\n   * <p>For example, \"{@code _}\" in \"{@code fn foo _ => 42}\". */\n  public static class WildcardPat extends Pat {\n    WildcardPat(Type type) {\n      super(Op.WILDCARD_PAT, type);\n    }\n\n    @Override public int hashCode() {\n      return \"_\".hashCode();\n    }\n\n    @Override public boolean equals(Object o) {\n      return o instanceof WildcardPat;\n    }\n\n    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      return w.append(\"_\");\n    }\n\n    @Override public Pat accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }\n\n    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }\n  }\n\n  /** Layered pattern. */\n  public static class AsPat extends NamedPat {\n    public final Pat pat;\n\n    protected AsPat(Type type, String name, int i, Pat pat) {\n      super(Op.AS_PAT, type, name, i);\n      this.pat = requireNonNull(pat);\n    }\n\n    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      return w.id(name).append(\" as \").append(pat, 0, 0);\n    }\n\n    @Override public AsPat withType(Type type) {\n      return type == this.type ? this : new AsPat(type, name, i, pat);\n    }\n\n    @Override public AsPat accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }\n\n    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }\n\n    /** Creates a copy of this {@code AsPat} with given contents,\n     * or {@code this} if the contents are the same. */\n    public Core.AsPat copy(String name, int i, Core.Pat pat) {\n      return this.name.equals(name)\n          && this.i == i\n          && this.pat.equals(pat)\n          ? this\n          : new AsPat(type, name, i, pat);\n    }\n  }\n\n  /** Type constructor pattern with an argument.\n   *\n   * <p>For example, in \"fun nvl NIL = 0 | OPTION x = x\",\n   * \"OPTION x\" is a type constructor pattern that binds \"x\";\n   * and \"NIL\" is a type constructor pattern whose {@link #pat} is null.\n   *\n   * @see Con0Pat */\n  public static class ConPat extends Pat {\n    public final String tyCon;\n    public final Pat pat;\n\n    /** Mostly-private constructor.\n     *\n     * <p>Exposed so that \"op ::\" (cons) can supply a different {@link Op}\n     * value. The \"list\" datatype is not represented the same as other\n     * datatypes, and the separate \"op\" value allows us to deconstruct it in a\n     * different way. */\n    protected ConPat(Op op, Type type, String tyCon, Pat pat) {\n      super(op, type);\n      this.tyCon = requireNonNull(tyCon);\n      this.pat = requireNonNull(pat);\n      checkArgument(op == Op.CON_PAT || op == Op.CONS_PAT);\n    }\n\n    ConPat(Type type, String tyCon, Pat pat) {\n      this(Op.CON_PAT, type, tyCon, pat);\n    }\n\n    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      return w.id(tyCon).append(\"(\").append(pat, 0, 0).append(\")\");\n    }\n\n    @Override public Pat accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }\n\n    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }\n\n    /** Creates a copy of this {@code ConPat} with given contents,\n     * or {@code this} if the contents are the same. */\n    public Core.ConPat copy(String tyCon, Core.Pat pat) {\n      return this.tyCon.equals(tyCon)\n          && this.pat.equals(pat)\n          ? this\n          : new ConPat(op, type, tyCon, pat);\n    }\n  }\n\n  /** Type constructor pattern with no argument.\n   *\n   * <p>For example, in \"fun nvl NIL = 0 | OPTION x = x\",\n   * \"NIL\" is a zero-arg type constructor pattern.\n   *\n   * @see ConPat */\n  public static class Con0Pat extends Pat {\n    public final String tyCon;\n\n    Con0Pat(DataType type, String tyCon) {\n      super(Op.CON0_PAT, type);\n      this.tyCon = requireNonNull(tyCon);\n    }\n\n    @Override public DataType type() {\n      return (DataType) type;\n    }\n\n    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      return w.id(tyCon);\n    }\n\n    @Override public Pat accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }\n\n    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }\n  }\n\n  /** Tuple pattern, the pattern analog of the {@link Tuple} expression.\n   *\n   * <p>For example, \"(x, y)\" in \"fun sum (x, y) = x + y\". */\n  public static class TuplePat extends Pat {\n    public final List<Pat> args;\n\n    /** Creates a TuplePat.\n     *\n     * <p>Type is {@link PrimitiveType#UNIT} if {@code args} is empty,\n     * otherwise a {@link TupleType}. */\n    TuplePat(RecordLikeType type, ImmutableList<Pat> args) {\n      super(Op.TUPLE_PAT, type);\n      this.args = requireNonNull(args);\n      checkArgument(args.size() == type.argNameTypes().size());\n      checkArgument(args.isEmpty()\n          ? type == PrimitiveType.UNIT\n          : type instanceof TupleType);\n    }\n\n    @Override public RecordLikeType type() {\n      return (RecordLikeType) type;\n    }\n\n    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      w.append(\"(\");\n      forEachIndexed(args, (arg, i) ->\n          w.append(i == 0 ? \"\" : \", \").append(arg, 0, 0));\n      return w.append(\")\");\n    }\n\n    @Override public Pat accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }\n\n    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }\n\n    public TuplePat copy(TypeSystem typeSystem, List<Pat> args) {\n      return args.equals(this.args) ? this\n          : core.tuplePat(typeSystem, args);\n    }\n\n    /** Returns the names of all components that are named. */\n    public List<String> fieldNames() {\n      final ImmutableList.Builder<String> names = ImmutableList.builder();\n      for (Pat arg : args) {\n        if (arg instanceof NamedPat) {\n          names.add(((NamedPat) arg).name);\n        }\n      }\n      return names.build();\n    }\n  }\n\n  /** List pattern.\n   *\n   * <p>For example, \"[x, y]\" in \"fun sum [x, y] = x + y\". */\n  public static class ListPat extends Pat {\n    public final List<Pat> args;\n\n    ListPat(Type type, ImmutableList<Pat> args) {\n      super(Op.LIST_PAT, type);\n      this.args = requireNonNull(args);\n    }\n\n    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      w.append(\"[\");\n      forEachIndexed(args, (arg, i) ->\n          w.append(i == 0 ? \"\" : \", \").append(arg, 0, 0));\n      return w.append(\"]\");\n    }\n\n    @Override public Pat accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }\n\n    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }\n\n    public ListPat copy(TypeSystem typeSystem, List<Pat> args) {\n      return args.equals(this.args) ? this\n          : core.listPat(typeSystem, args);\n    }\n  }\n\n  /** Record pattern. */\n  public static class RecordPat extends Pat {\n    public final List<Pat> args;\n\n    RecordPat(RecordType type, ImmutableList<Pat> args) {\n      super(Op.RECORD_PAT, type);\n      this.args = requireNonNull(args);\n      checkArgument(args.size() == type.argNameTypes.size());\n    }\n\n    @Override public RecordType type() {\n      return (RecordType) type;\n    }\n\n    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      w.append(\"{\");\n      forEachIndexed(type().argNameTypes.keySet(), args,\n          (i, name, arg) ->\n              w.append(i > 0 ? \", \" : \"\").append(name)\n                  .append(\" = \").append(arg, 0, 0));\n      return w.append(\"}\");\n    }\n\n    @Override public Pat accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }\n\n    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }\n\n    public Pat copy(TypeSystem typeSystem, Set<String> argNames,\n        List<Pat> args) {\n      return args.equals(this.args) ? this\n          : core.recordPat(typeSystem, argNames, args);\n    }\n  }\n\n  /** Base class of core expressions. */\n  public abstract static class Exp extends BaseNode {\n    public final Type type;\n\n    Exp(Pos pos, Op op, Type type) {\n      super(pos, op);\n      this.type = requireNonNull(type);\n    }\n\n    public void forEachArg(ObjIntConsumer<Exp> action) {\n      // no args\n    }\n\n    /** Returns the {@code i}<sup>th</sup> argument. */\n    public Exp arg(int i) {\n      throw new UnsupportedOperationException();\n    }\n\n    /** Returns the type. */\n    public Type type() {\n      return type;\n    }\n\n    @Override public abstract Exp accept(Shuttle shuttle);\n\n    /** Returns whether this expression is a constant.\n     *\n     * <p>Examples include literals {@code 1}, {@code true},\n     * constructors applied to constants,\n     * records and tuples whose arguments are constant.\n     */\n    public boolean isConstant() {\n      return false;\n    }\n\n    /** Returns whether this expression is a call to the given built-in. */\n    public boolean isCallTo(BuiltIn builtIn) {\n      return false;\n    }\n  }\n\n  /** Reference to a variable.\n   *\n   * <p>While {@link Ast.Id} is widely used, and means an occurrence of a name\n   * in the parse tree, {@code Id} is much narrower: it means a reference to a\n   * value. What would be an {@code Id} in Ast is often a {@link String} in\n   * Core; for example, compare {@link Ast.Con0Pat#tyCon}\n   * with {@link Con0Pat#tyCon}. */\n  public static class Id extends Exp implements Comparable<Id> {\n    public final NamedPat idPat;\n\n    /** Creates an Id. */\n    Id(NamedPat idPat) {\n      super(Pos.ZERO, Op.ID, idPat.type);\n      this.idPat = requireNonNull(idPat);\n    }\n\n    @Override public int compareTo(Id o) {\n      return idPat.compareTo(o.idPat);\n    }\n\n    @Override public int hashCode() {\n      return idPat.hashCode();\n    }\n\n    @Override public boolean equals(Object o) {\n      return o == this\n          || o instanceof Id\n          && this.idPat.equals(((Id) o).idPat);\n    }\n\n    @Override public Exp accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }\n\n    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }\n\n    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      return w.id(idPat.name, idPat.i);\n    }\n  }\n\n  /** Record selector function. */\n  public static class RecordSelector extends Exp {\n    /** The ordinal of the field in the record or tuple that is to be\n     * accessed. */\n    public final int slot;\n\n    /** Creates a record selector. */\n    RecordSelector(FnType fnType, int slot) {\n      super(Pos.ZERO, Op.RECORD_SELECTOR, fnType);\n      this.slot = slot;\n    }\n\n    @Override public int hashCode() {\n      return slot + 2237;\n    }\n\n    @Override public boolean equals(Object o) {\n      return o == this\n          || o instanceof RecordSelector\n          && this.slot == ((RecordSelector) o).slot\n          && this.type.equals(((RecordSelector) o).type);\n    }\n\n    public String fieldName() {\n      final RecordLikeType recordType = (RecordLikeType) type().paramType;\n      return Iterables.get(recordType.argNameTypes().keySet(), slot);\n    }\n\n    @Override public FnType type() {\n      return (FnType) type;\n    }\n\n    @Override public RecordSelector accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }\n\n    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }\n\n    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      return w.append(\"#\").append(fieldName());\n    }\n  }\n\n  /** Code of a literal (constant). */\n  @SuppressWarnings(\"rawtypes\")\n  public static class Literal extends Exp {\n    public final Comparable value;\n\n    /** Creates a Literal. */\n    Literal(Op op, Type type, Comparable value) {\n      super(Pos.ZERO, op, type);\n      this.value = requireNonNull(value);\n    }\n\n    static Comparable wrap(Exp exp, Object value) {\n      return new Wrapper(exp, value);\n    }\n\n    /** Returns the value of this literal as a given class,\n     * or throws {@link ClassCastException}. If the class is not\n     * {@link Comparable}, the value will be in a wrapper. */\n    public <C> C unwrap(Class<C> clazz) {\n      Object v;\n      if (value instanceof Wrapper\n          && ((Wrapper) value).o instanceof TypedValue) {\n        return ((TypedValue) ((Wrapper) value).o).valueAs(clazz);\n      }\n      if (clazz.isInstance(value) && clazz != Object.class) {\n        v = value;\n      } else if (Number.class.isAssignableFrom(clazz)\n          && value instanceof Number) {\n        Number number = (Number) value;\n        if (clazz == Double.class) {\n          v = number.doubleValue();\n        } else if (clazz == Float.class) {\n          v = number.floatValue();\n        } else if (clazz == Long.class) {\n          v = number.longValue();\n        } else if (clazz == Integer.class) {\n          v = number.intValue();\n        } else if (clazz == Short.class) {\n          v = number.shortValue();\n        } else if (clazz == Byte.class) {\n          v = number.byteValue();\n        } else if (clazz == BigInteger.class\n            && number instanceof BigDecimal) {\n          v = ((BigDecimal) number).toBigIntegerExact();\n        } else {\n          v = value;\n        }\n      } else {\n        v = ((Wrapper) value).o;\n      }\n      return clazz.cast(v);\n    }\n\n    @Override public int hashCode() {\n      return value.hashCode();\n    }\n\n    @Override public boolean equals(Object o) {\n      return o == this\n          || o instanceof Literal\n          && value.equals(((Literal) o).value);\n    }\n\n    @Override public Exp accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }\n\n    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }\n\n    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      switch (op) {\n      case VALUE_LITERAL:\n        // Generate the original expression from which this value was derived.\n        return ((Wrapper) value).exp.unparse(w, left, right);\n      case INTERNAL_LITERAL:\n        // Print the value as if it were a string.\n        return w.appendLiteral(((Wrapper) value).o.toString());\n      }\n      return w.appendLiteral(value);\n    }\n\n    @Override public boolean isConstant() {\n      return true;\n    }\n  }\n\n  /** Base class for declarations. */\n  public abstract static class Decl extends BaseNode {\n    Decl(Pos pos, Op op) {\n      super(pos, op);\n    }\n\n    @Override public abstract Decl accept(Shuttle shuttle);\n  }\n\n  /** Datatype declaration. */\n  public static class DatatypeDecl extends Decl {\n    public final List<DataType> dataTypes;\n\n    DatatypeDecl(ImmutableList<DataType> dataTypes) {\n      super(Pos.ZERO, Op.DATATYPE_DECL);\n      this.dataTypes = requireNonNull(dataTypes);\n      checkArgument(!this.dataTypes.isEmpty());\n    }\n\n    @Override public int hashCode() {\n      return Objects.hash(dataTypes);\n    }\n\n    @Override public boolean equals(Object o) {\n      return o == this\n          || o instanceof DatatypeDecl\n          && dataTypes.equals(((DatatypeDecl) o).dataTypes);\n    }\n\n    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      forEachIndexed(dataTypes, (dataType, i) ->\n          w.append(i == 0 ? \"datatype \" : \" and \").append(dataType.toString()));\n      return w;\n    }\n\n    @Override public DatatypeDecl accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }\n\n    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }\n  }\n\n  /** Abstract (recursive or non-recursive) value declaration. */\n  public abstract static class ValDecl extends Decl {\n    ValDecl(Pos pos, Op op) {\n      super(pos, op);\n    }\n\n    @Override public abstract ValDecl accept(Shuttle shuttle);\n\n    public abstract void forEachBinding(BindingConsumer consumer);\n  }\n\n  /** Consumer of bindings. */\n  @FunctionalInterface\n  public interface BindingConsumer {\n    void accept(NamedPat namedPat, Exp exp, Pos pos);\n  }\n\n  /** Non-recursive value declaration.\n   *\n   * @see RecValDecl#list */\n  public static class NonRecValDecl extends ValDecl {\n    public final NamedPat pat;\n    public final Exp exp;\n\n    NonRecValDecl(NamedPat pat, Exp exp, Pos pos) {\n      super(pos, Op.VAL_DECL);\n      this.pat = pat;\n      this.exp = exp;\n    }\n\n    @Override public int hashCode() {\n      return Objects.hash(pat, exp);\n    }\n\n    @Override public boolean equals(Object o) {\n      return o == this\n          || o instanceof NonRecValDecl\n          && pat.equals(((NonRecValDecl) o).pat)\n          && exp.equals(((NonRecValDecl) o).exp);\n    }\n\n    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      return w.append(\"val \")\n          .append(pat, 0, 0).append(\" = \").append(exp, 0, right);\n    }\n\n    @Override public NonRecValDecl accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }\n\n    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }\n\n    public NonRecValDecl copy(NamedPat pat, Exp exp) {\n      return pat == this.pat && exp == this.exp ? this\n          : core.nonRecValDecl(pos, pat, exp);\n    }\n\n    @Override public void forEachBinding(BindingConsumer consumer) {\n      consumer.accept(pat, exp, pos);\n    }\n  }\n\n  /** Recursive value declaration. */\n  public static class RecValDecl extends ValDecl {\n    public final ImmutableList<NonRecValDecl> list;\n\n    RecValDecl(ImmutableList<NonRecValDecl> list) {\n      super(Pos.ZERO, Op.REC_VAL_DECL);\n      this.list = requireNonNull(list);\n    }\n\n    @Override public int hashCode() {\n      return list.hashCode();\n    }\n\n    @Override public boolean equals(Object o) {\n      return o == this\n          || o instanceof RecValDecl\n          && list.equals(((RecValDecl) o).list);\n    }\n\n    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      w.append(\"val rec \");\n      forEachIndexed(list, (decl, i) ->\n          w.append(i == 0 ? \"\" : \" and \").append(decl.pat, 0, 0)\n              .append(\" = \").append(decl.exp, 0, right));\n      return w;\n    }\n\n    @Override public RecValDecl accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }\n\n    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }\n\n    @Override public void forEachBinding(BindingConsumer consumer) {\n      list.forEach(b -> b.forEachBinding(consumer));\n    }\n\n    public RecValDecl copy(List<NonRecValDecl> list) {\n      return list.equals(this.list) ? this\n          : core.recValDecl(list);\n    }\n  }\n\n  /** Tuple expression. Also implements record expression. */\n  // TODO: remove, replace with a call to the constructor of the n-tuple type?\n  public static class Tuple extends Exp {\n    public final List<Exp> args;\n\n    Tuple(RecordLikeType type, ImmutableList<Exp> args) {\n      super(Pos.ZERO, Op.TUPLE, type);\n      this.args = ImmutableList.copyOf(args);\n    }\n\n    @Override public boolean equals(Object o) {\n      return this == o\n          || o instanceof Tuple\n          && args.equals(((Tuple) o).args)\n          && type.equals(((Tuple) o).type);\n    }\n\n    @Override public int hashCode() {\n      return Objects.hash(args, type);\n    }\n\n    @Override public RecordLikeType type() {\n      return (RecordLikeType) type;\n    }\n\n    @Override public void forEachArg(ObjIntConsumer<Exp> action) {\n      forEachIndexed(args, action);\n    }\n\n    @Override public Exp arg(int i) {\n      return args.get(i);\n    }\n\n    @Override public Exp accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }\n\n    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }\n\n    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      if (type instanceof RecordType) {\n        w.append(\"{\");\n        forEach((i, name, exp) ->\n            w.append(i > 0 ? \", \" : \"\").append(name).append(\" = \")\n                .append(exp, 0, 0));\n        return w.append(\"}\");\n      } else {\n        w.append(\"(\");\n        forEach((i, name, arg) ->\n            w.append(i == 0 ? \"\" : \", \").append(arg, 0, 0));\n        return w.append(\")\");\n      }\n    }\n\n    /** Calls a consumer with the name, expression and ordinal of each field\n     * of this tuple. */\n    public void forEach(PairList.IndexedBiConsumer<String, Exp> consumer) {\n      final ImmutableSortedSet<String> nameSet =\n          (ImmutableSortedSet<String>) type().argNameTypes().keySet();\n      final List<String> names = nameSet.asList();\n      forEachIndexed(names, args, consumer::accept);\n    }\n\n    public Tuple copy(TypeSystem typeSystem, List<Exp> args) {\n      return args.equals(this.args) ? this\n          : core.tuple(typeSystem, type(), args);\n    }\n\n    @Override public boolean isConstant() {\n      return args.stream().allMatch(Exp::isConstant);\n    }\n  }\n\n  /** \"Let\" expression. */\n  public static class Let extends Exp {\n    public final ValDecl decl;\n    public final Exp exp;\n\n    Let(ValDecl decl, Exp exp) {\n      super(Pos.ZERO, Op.LET, exp.type);\n      this.decl = requireNonNull(decl);\n      this.exp = requireNonNull(exp);\n    }\n\n    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      return w.append(\"let \").append(decl, 0, 0)\n          .append(\" in \").append(exp, 0, 0)\n          .append(\" end\");\n    }\n\n    @Override public Exp accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }\n\n    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }\n\n    public Exp copy(ValDecl decl, Exp exp) {\n      return decl == this.decl && exp == this.exp ? this\n          : core.let(decl, exp);\n    }\n  }\n\n  /** \"Local\" expression. */\n  public static class Local extends Exp {\n    public final DataType dataType;\n    public final Exp exp;\n\n    Local(DataType dataType, Exp exp) {\n      super(Pos.ZERO, Op.LOCAL, exp.type);\n      this.dataType = requireNonNull(dataType);\n      this.exp = requireNonNull(exp);\n    }\n\n    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      return w.append(\"local datatype \").append(dataType.toString())\n          .append(\" in \").append(exp, 0, 0)\n          .append(\" end\");\n    }\n\n    @Override public Exp accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }\n\n    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }\n\n    public Exp copy(DataType dataType, Exp exp) {\n      return dataType == this.dataType && exp == this.exp ? this\n          : core.local(dataType, exp);\n    }\n  }\n\n  /** Match.\n   *\n   * <p>In AST, there are several places that can deconstruct values via\n   * patterns: {@link Ast.FunDecl fun}, {@link Ast.Fn fn}, {@link Ast.Let let},\n   * {@link Ast.Case case}. But in Core, there is only {@code Match}, and\n   * {@code Match} only occurs within {@link Ast.Case case}. This makes the Core\n   * language a little more verbose than AST but a lot more uniform. */\n  public static class Match extends BaseNode {\n    public final Pat pat;\n    public final Exp exp;\n\n    Match(Pos pos, Pat pat, Exp exp) {\n      super(pos, Op.MATCH);\n      this.pat = pat;\n      this.exp = exp;\n    }\n\n    @Override public Match accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }\n\n    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }\n\n    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      return w.append(pat, 0, 0).append(\" => \").append(exp, 0, right);\n    }\n\n    public Match copy(Pat pat, Exp exp) {\n      return pat == this.pat && exp == this.exp ? this\n          : core.match(pos, pat, exp);\n    }\n  }\n\n  /** Lambda expression. */\n  public static class Fn extends Exp {\n    public final IdPat idPat;\n    public final Exp exp;\n\n    Fn(FnType type, IdPat idPat, Exp exp) {\n      super(Pos.ZERO, Op.FN, type);\n      this.idPat = requireNonNull(idPat);\n      this.exp = requireNonNull(exp);\n    }\n\n    @Override public FnType type() {\n      return (FnType) type;\n    }\n\n    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      return w.append(\"fn \")\n          .append(idPat, 0, 0).append(\" => \").append(exp, 0, right);\n    }\n\n    @Override public Exp accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }\n\n    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }\n\n    public Fn copy(IdPat idPat, Exp exp) {\n      return idPat == this.idPat && exp == this.exp ? this\n          : core.fn(type(), idPat, exp);\n    }\n  }\n\n  /** Case expression.\n   *\n   * <p>Also implements {@link Ast.If}. */\n  public static class Case extends Exp {\n    public final Exp exp;\n    public final List<Match> matchList;\n\n    Case(Pos pos, Type type, Exp exp, ImmutableList<Match> matchList) {\n      super(pos, Op.CASE, type);\n      this.exp = exp;\n      this.matchList = matchList;\n    }\n\n    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      return w.append(\"case \").append(exp, 0, 0).append(\" of \")\n          .appendAll(matchList, left, Op.BAR, right);\n    }\n\n    @Override public Exp accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }\n\n    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }\n\n    public Case copy(Exp exp, List<Match> matchList) {\n      return exp == this.exp && matchList.equals(this.matchList) ? this\n          : core.caseOf(pos, type, exp, matchList);\n    }\n  }\n\n  /** From expression. */\n  public static class From extends Exp {\n    public final ImmutableList<FromStep> steps;\n\n    From(ListType type, ImmutableList<FromStep> steps) {\n      super(Pos.ZERO, Op.FROM, type);\n      this.steps = requireNonNull(steps);\n    }\n\n    @Override public boolean equals(Object o) {\n      return this == o\n          || o instanceof From\n          && steps.equals(((From) o).steps);\n    }\n\n    @Override public int hashCode() {\n      return steps.hashCode();\n    }\n\n    @Override public ListType type() {\n      return (ListType) type;\n    }\n\n    @Override public Exp accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }\n\n    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }\n\n    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      if (left > op.left || op.right < right) {\n        return w.append(\"(\").append(this, 0, 0).append(\")\");\n      } else {\n        w.append(\"from\");\n        forEachIndexed(steps, (step, i) -> step.unparse(w, this, i, 0, 0));\n        return w;\n      }\n    }\n\n    /** Copies this {@code From} with a new set of steps.\n     *\n     * <p>Returns this {@code From} if the steps are the same.\n     * If {@code env} is not null, performs additional checking. */\n    public Exp copy(TypeSystem typeSystem, @Nullable Environment env,\n        List<FromStep> steps) {\n      return steps.equals(this.steps)\n          ? this\n          : core.fromBuilder(typeSystem, env).addAll(steps).build();\n    }\n  }\n\n  /** A step in a {@code from} expression - {@code where}, {@code group}\n   * or {@code order}. */\n  public abstract static class FromStep extends BaseNode {\n    public final ImmutableList<Binding> bindings;\n\n    FromStep(Op op, ImmutableList<Binding> bindings) {\n      super(Pos.ZERO, op);\n      this.bindings = bindings;\n    }\n\n    @Override final AstWriter unparse(AstWriter w, int left, int right) {\n      return unparse(w, null, -1, left, right);\n    }\n\n    protected abstract AstWriter unparse(AstWriter w, From from, int ordinal,\n        int left, int right);\n\n    @Override public abstract FromStep accept(Shuttle shuttle);\n  }\n\n  /** A {@code join} or {@code v in listExpr} or {@code v = expr} clause in a\n   *  {@code from} expression. */\n  public static class Scan extends FromStep {\n    public final Pat pat;\n    public final Exp exp;\n    public final Exp condition;\n\n    Scan(ImmutableList<Binding> bindings, Pat pat, Exp exp,\n        Exp condition) {\n      super(Op.SCAN, bindings);\n      this.pat = requireNonNull(pat, \"pat\");\n      this.exp = requireNonNull(exp, \"exp\");\n      this.condition = requireNonNull(condition, \"condition\");\n      if (!(exp.type instanceof ListType)) {\n        throw new IllegalArgumentException(\"scan expression must be list: \"\n            + exp.type);\n      }\n      final ListType listType = (ListType) exp.type;\n      if (!canAssign(listType.elementType, pat.type)) {\n        throw new IllegalArgumentException(exp.type + \" + \" + pat.type);\n      }\n    }\n\n    /** Returns whether you can assign a value of {@code fromType} to a variable\n     * of type {@code toType}. */\n    private static boolean canAssign(Type fromType, Type toType) {\n      return fromType.equals(toType)\n          || toType.isProgressive();\n    }\n\n    @Override public Scan accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }\n\n    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }\n\n    @Override protected AstWriter unparse(AstWriter w, From from, int ordinal,\n        int left, int right) {\n      w.append(ordinal == 0 ? \" \" : \" join \")\n          // for these purposes 'in' has same precedence as '='\n          .append(pat, 0, Op.EQ.left);\n      if (Extents.isInfinite(exp)) {\n        // Print \"from x : int\" rather \"from x in extent 'int'\"\n        w.append(\" : \")\n            .append(((ListType) exp.type).elementType.moniker());\n      } else {\n        w.append(\" in \")\n            .append(exp, Op.EQ.right, 0);\n      }\n      if (!isLiteralTrue()) {\n        w.append(\"on\").append(condition, 0, 0);\n      }\n      return w;\n    }\n\n    private boolean isLiteralTrue() {\n      return condition.op == Op.BOOL_LITERAL\n          && ((Literal) condition).unwrap(Boolean.class);\n    }\n\n    public Scan copy(List<Binding> bindings, Pat pat, Exp exp, Exp condition) {\n      return pat == this.pat\n          && exp == this.exp\n          && condition == this.condition\n          && bindings.equals(this.bindings)\n          ? this\n          : core.scan(bindings, pat, exp, condition);\n    }\n  }\n\n  /** A {@code where} clause in a {@code from} expression. */\n  public static class Where extends FromStep {\n    public final Exp exp;\n\n    Where(ImmutableList<Binding> bindings, Exp exp) {\n      super(Op.WHERE, bindings);\n      this.exp = requireNonNull(exp, \"exp\");\n    }\n\n    @Override public Where accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }\n\n    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }\n\n    @Override protected AstWriter unparse(AstWriter w, From from, int ordinal,\n        int left, int right) {\n      return w.append(\" where \").append(exp, 0, 0);\n    }\n\n    public Where copy(Exp exp, List<Binding> bindings) {\n      return exp == this.exp\n          && bindings.equals(this.bindings)\n          ? this\n          : core.where(bindings, exp);\n    }\n  }\n\n  /** A {@code skip} clause in a {@code from} expression. */\n  public static class Skip extends FromStep {\n    public final Exp exp;\n\n    Skip(ImmutableList<Binding> bindings, Exp exp) {\n      super(Op.SKIP, bindings);\n      this.exp = requireNonNull(exp, \"exp\");\n    }\n\n    @Override public Skip accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }\n\n    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }\n\n    @Override protected AstWriter unparse(AstWriter w, From from, int ordinal,\n        int left, int right) {\n      return w.append(\" skip \").append(exp, 0, 0);\n    }\n\n    public Skip copy(Exp exp, List<Binding> bindings) {\n      return exp == this.exp\n          && bindings.equals(this.bindings)\n          ? this\n          : core.skip(bindings, exp);\n    }\n  }\n\n  /** A {@code take} clause in a {@code from} expression. */\n  public static class Take extends FromStep {\n    public final Exp exp;\n\n    Take(ImmutableList<Binding> bindings, Exp exp) {\n      super(Op.TAKE, bindings);\n      this.exp = requireNonNull(exp, \"exp\");\n    }\n\n    @Override public Take accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }\n\n    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }\n\n    @Override protected AstWriter unparse(AstWriter w, From from, int ordinal,\n        int left, int right) {\n      return w.append(\" take \").append(exp, 0, 0);\n    }\n\n    public Take copy(Exp exp, List<Binding> bindings) {\n      return exp == this.exp\n          && bindings.equals(this.bindings)\n          ? this\n          : core.take(bindings, exp);\n    }\n  }\n\n  /** An {@code order} clause in a {@code from} expression. */\n  public static class Order extends FromStep {\n    public final ImmutableList<OrderItem> orderItems;\n\n    Order(ImmutableList<Binding> bindings,\n        ImmutableList<OrderItem> orderItems) {\n      super(Op.ORDER, bindings);\n      this.orderItems = requireNonNull(orderItems);\n    }\n\n    @Override public Order accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }\n\n    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }\n\n    @Override protected AstWriter unparse(AstWriter w, From from, int ordinal,\n        int left, int right) {\n      return w.append(\" order \").appendAll(orderItems, \", \");\n    }\n\n    public Order copy(List<Binding> bindings,\n        List<OrderItem> orderItems) {\n      return bindings.equals(this.bindings)\n          && orderItems.equals(this.orderItems)\n          ? this\n          : core.order(bindings, orderItems);\n    }\n  }\n\n  /** An item in an {@code order} clause. */\n  public static class OrderItem extends BaseNode {\n    public final Exp exp;\n    public final Ast.Direction direction;\n\n    OrderItem(Exp exp, Ast.Direction direction) {\n      super(Pos.ZERO, Op.ORDER_ITEM);\n      this.exp = requireNonNull(exp);\n      this.direction = requireNonNull(direction);\n    }\n\n    @Override public AstNode accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }\n\n    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }\n\n    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      return w.append(exp, 0, 0)\n          .append(direction == Ast.Direction.DESC ? \" desc\" : \"\");\n    }\n\n    public OrderItem copy(Exp exp, Ast.Direction direction) {\n      return exp == this.exp && direction == this.direction ? this\n          : core.orderItem(exp, direction);\n    }\n  }\n\n  /** A {@code group} clause in a {@code from} expression. */\n  public static class Group extends FromStep {\n    public final SortedMap<Core.IdPat, Exp> groupExps;\n    public final SortedMap<Core.IdPat, Aggregate> aggregates;\n\n    Group(ImmutableList<Binding> bindings,\n        ImmutableSortedMap<Core.IdPat, Exp> groupExps,\n        ImmutableSortedMap<Core.IdPat, Aggregate> aggregates) {\n      super(Op.GROUP, bindings);\n      this.groupExps = groupExps;\n      this.aggregates = aggregates;\n    }\n\n    @Override public Group accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }\n\n    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }\n\n    @Override protected AstWriter unparse(AstWriter w, From from, int ordinal,\n        int left, int right) {\n      w.append(\" group\");\n      Pair.forEachIndexed(groupExps, (i, id, exp) -> // lint:skip\n          w.append(i == 0 ? \" \" : \", \")\n              .append(id, 0, 0).append(\" = \").append(exp, 0, 0));\n      Pair.forEachIndexed(aggregates, (i, name, aggregate) -> // lint:skip\n          w.append(i == 0 ? \" compute \" : \", \")\n              .append(name, 0, 0).append(\" = \").append(aggregate, 0, 0));\n      return w;\n    }\n\n    public Group copy(SortedMap<Core.IdPat, Exp> groupExps,\n        SortedMap<Core.IdPat, Aggregate> aggregates) {\n      return groupExps.equals(this.groupExps)\n          && aggregates.equals(this.aggregates)\n          ? this\n          : core.group(groupExps, aggregates);\n    }\n  }\n\n  /** Step that computes an expression. */\n  public static class Yield extends FromStep {\n    public final Exp exp;\n\n    Yield(ImmutableList<Binding> bindings, Exp exp) {\n      super(Op.YIELD, bindings);\n      this.exp = exp;\n    }\n\n    @Override protected AstWriter unparse(AstWriter w, From from, int ordinal,\n        int left, int right) {\n      return w.append(\" yield \").append(exp, 0, 0);\n    }\n\n    @Override public Yield accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }\n\n    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }\n\n    public Yield copy(List<Binding> bindings, Exp exp) {\n      return bindings.equals(this.bindings)\n          && exp == this.exp\n          ? this\n          : core.yield_(bindings, exp);\n    }\n  }\n\n  /** Application of a function to its argument. */\n  public static class Apply extends Exp {\n    public final Exp fn;\n    public final Exp arg;\n\n    Apply(Pos pos, Type type, Exp fn, Exp arg) {\n      super(pos, Op.APPLY, type);\n      this.fn = fn;\n      this.arg = arg;\n    }\n\n    /** Returns the argument list (assuming that the arguments are a tuple\n     * or record).\n     *\n     * @throws ClassCastException if argument is not a tuple */\n    public List<Exp> args() {\n      return ((Tuple) arg).args;\n    }\n\n    @Override public Exp arg(int i) {\n      // Throws if the argument is not a tuple.\n      return arg.arg(i);\n    }\n\n    @Override public Exp accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }\n\n    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }\n\n    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      switch (fn.op) {\n      case FN_LITERAL:\n        final BuiltIn builtIn = ((Literal) fn).unwrap(BuiltIn.class);\n\n        // Because the Core language is narrower than AST, a few AST expression\n        // types do not exist in Core and are translated to function\n        // applications. Here we convert them back to original syntax.\n        switch (builtIn) {\n        case Z_LIST:\n          w.append(\"[\");\n          arg.forEachArg((arg, i) -> w.append(i == 0 ? \"\" : \", \").append(arg, 0, 0));\n          return w.append(\"]\");\n        }\n\n        // Convert built-ins to infix operators.\n        final Op op = Resolver.BUILT_IN_OP_MAP.get(builtIn);\n        if (op != null) {\n          return w.infix(left, args().get(0), op, args().get(1), right);\n        }\n      }\n      return w.infix(left, fn, op, arg, right);\n    }\n\n    public Apply copy(Exp fn, Exp arg) {\n      return fn == this.fn && arg == this.arg ? this\n          : core.apply(pos, type, fn, arg);\n    }\n\n    @Override public boolean isConstant() {\n      // A list of constants is constant\n      return isCallTo(BuiltIn.Z_LIST)\n          && args().stream().allMatch(Exp::isConstant);\n    }\n\n    @Override public boolean isCallTo(BuiltIn builtIn) {\n      return fn.op == Op.FN_LITERAL\n          && ((Literal) fn).unwrap(BuiltIn.class) == builtIn;\n    }\n  }\n\n  /** Call to an aggregate function in a {@code compute} clause.\n   *\n   * <p>For example, in {@code compute sumId = sum of #id e},\n   * {@code aggregate} is \"sum\", {@code argument} is \"#id e\". */\n  public static class Aggregate extends BaseNode {\n    public final Type type;\n    public final Exp aggregate;\n    public final @Nullable Exp argument;\n\n    Aggregate(Type type, Exp aggregate, @Nullable Exp argument) {\n      super(Pos.ZERO, Op.AGGREGATE);\n      this.type = type;\n      this.aggregate = requireNonNull(aggregate);\n      this.argument = argument;\n    }\n\n    @Override public Aggregate accept(Shuttle shuttle) {\n      return shuttle.visit(this);\n    }\n\n    @Override public void accept(Visitor visitor) {\n      visitor.visit(this);\n    }\n\n    @Override AstWriter unparse(AstWriter w, int left, int right) {\n      w.append(aggregate, 0, 0);\n      if (argument != null) {\n        w.append(\" of \")\n            .append(argument, 0, 0);\n      }\n      return w;\n    }\n\n    public Aggregate copy(Type type, Exp aggregate, @Nullable Exp argument) {\n      return aggregate == this.aggregate && argument == this.argument\n          ? this\n          : core.aggregate(type, aggregate, argument);\n    }\n  }\n\n  /** Wraps a value as a Comparable, and stores the global expression from which\n   * the value was derived. That global expression will be used if the value is\n   * converted by to Morel code. */\n  static class Wrapper implements Comparable<Wrapper> {\n    private final Exp exp;\n    private final Object o;\n\n    private Wrapper(Exp exp, Object o) {\n      this.exp = exp;\n      this.o = o;\n      assert isValidValue(exp, o) : o;\n    }\n\n    private static boolean isValidValue(Exp exp, Object o) {\n      if (o instanceof Code) {\n        return false;\n      }\n      if (o instanceof Closure) {\n        return false;\n      }\n      if (o instanceof Id) {\n        final String name = ((Id) exp).idPat.name;\n        return !(\"true\".equals(name) || \"false\".equals(name));\n      }\n      return true;\n    }\n\n    @Override public int compareTo(Wrapper o) {\n      return Integer.compare(this.o.hashCode(), o.o.hashCode());\n    }\n\n    @Override public String toString() {\n      return o.toString();\n    }\n\n    @Override public int hashCode() {\n      return o.hashCode();\n    }\n\n    @Override public boolean equals(Object obj) {\n      return this == obj\n          || obj instanceof Wrapper\n          && this.o.equals(((Wrapper) obj).o);\n    }\n\n    /** Returns the value. */\n    <T> T unwrap(Class<T> valueClass) {\n      return valueClass.cast(o);\n    }\n  }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor", "name": "Visitor", "file_path": "src/main/java/net/hydromatic/morel/ast/Visitor.java", "superclasses": "", "methods": ["[void]accept(E)", "[void]visit(Ast.Literal)", "[void]visit(Ast.Id)", "[void]visit(Ast.AnnotatedExp)", "[void]visit(Ast.If)", "[void]visit(Ast.Let)", "[void]visit(Ast.Case)", "[void]visit(Ast.InfixCall)", "[void]visit(Ast.PrefixCall)", "[void]visit(Ast.IdPat)", "[void]visit(Ast.LiteralPat)", "[void]visit(Ast.WildcardPat)", "[void]visit(Ast.InfixPat)", "[void]visit(Ast.TuplePat)", "[void]visit(Ast.ListPat)", "[void]visit(Ast.RecordPat)", "[void]visit(Ast.AnnotatedPat)", "[void]visit(Ast.AsPat)", "[void]visit(Ast.ConPat)", "[void]visit(Ast.Con0Pat)", "[void]visit(Ast.Tuple)", "[void]visit(Ast.ListExp)", "[void]visit(Ast.Record)", "[void]visit(Ast.Fn)", "[void]visit(Ast.Apply)", "[void]visit(Ast.RecordSelector)", "[void]visit(Ast.Match)", "[void]visit(Ast.NamedType)", "[void]visit(Ast.TyVar)", "[void]visit(Ast.FunDecl)", "[void]visit(Ast.FunBind)", "[void]visit(Ast.FunMatch)", "[void]visit(Ast.ValDecl)", "[void]visit(Ast.ValBind)", "[void]visit(Ast.From)", "[void]visit(Ast.Scan)", "[void]visit(Ast.Order)", "[void]visit(Ast.OrderItem)", "[void]visit(Ast.Where)", "[void]visit(Ast.Skip)", "[void]visit(Ast.Take)", "[void]visit(Ast.Yield)", "[void]visit(Ast.Into)", "[void]visit(Ast.Through)", "[void]visit(Ast.Compute)", "[void]visit(Ast.Group)", "[void]visit(Ast.Aggregate)", "[void]visit(Ast.DatatypeDecl)", "[void]visit(Ast.DatatypeBind)", "[void]visit(Ast.TyCon)", "[void]visit(Ast.RecordType)", "[void]visit(Ast.TupleType)", "[void]visit(Ast.FunctionType)", "[void]visit(Ast.CompositeType)", "[void]visit(Core.Literal)", "[void]visit(Core.Id)", "[void]visit(Core.Let)", "[void]visit(Core.Local)", "[void]visit(Core.Case)", "[void]visit(Core.Apply)", "[void]visit(Core.RecordSelector)", "[void]visit(Core.Tuple)", "[void]visit(Core.DatatypeDecl)", "[void]visit(Core.Fn)", "[void]visit(Core.Match)", "[void]visit(Core.From)", "[void]visit(Core.Scan)", "[void]visit(Core.Where)", "[void]visit(Core.Skip)", "[void]visit(Core.Take)", "[void]visit(Core.NonRecValDecl)", "[void]visit(Core.RecValDecl)", "[void]visit(Core.Group)", "[void]visit(Core.Aggregate)", "[void]visit(Core.Order)", "[void]visit(Core.OrderItem)", "[void]visit(Core.Yield)", "[void]visit(Core.TuplePat)", "[void]visit(Core.RecordPat)", "[void]visit(Core.ListPat)", "[void]visit(Core.ConPat)", "[void]visit(Core.Con0Pat)", "[void]visit(Core.IdPat)", "[void]visit(Core.AsPat)", "[void]visit(Core.LiteralPat)", "[void]visit(Core.WildcardPat)"], "method_uris": ["src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]accept(E)", "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]visit(Ast.Literal)", "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]visit(Ast.Id)", "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]visit(Ast.AnnotatedExp)", "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]visit(Ast.If)", "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]visit(Ast.Let)", "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]visit(Ast.Case)", "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]visit(Ast.InfixCall)", "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]visit(Ast.PrefixCall)", "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]visit(Ast.IdPat)", "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]visit(Ast.LiteralPat)", "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]visit(Ast.WildcardPat)", "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]visit(Ast.InfixPat)", "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]visit(Ast.TuplePat)", "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]visit(Ast.ListPat)", "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]visit(Ast.RecordPat)", "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]visit(Ast.AnnotatedPat)", "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]visit(Ast.AsPat)", "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]visit(Ast.ConPat)", "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]visit(Ast.Con0Pat)", "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]visit(Ast.Tuple)", "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]visit(Ast.ListExp)", "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]visit(Ast.Record)", "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]visit(Ast.Fn)", "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]visit(Ast.Apply)", "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]visit(Ast.RecordSelector)", "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]visit(Ast.Match)", "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]visit(Ast.NamedType)", "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]visit(Ast.TyVar)", "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]visit(Ast.FunDecl)", "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]visit(Ast.FunBind)", "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]visit(Ast.FunMatch)", "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]visit(Ast.ValDecl)", "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]visit(Ast.ValBind)", "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]visit(Ast.From)", "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]visit(Ast.Scan)", "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]visit(Ast.Order)", "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]visit(Ast.OrderItem)", "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]visit(Ast.Where)", "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]visit(Ast.Skip)", "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]visit(Ast.Take)", "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]visit(Ast.Yield)", "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]visit(Ast.Into)", "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]visit(Ast.Through)", "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]visit(Ast.Compute)", "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]visit(Ast.Group)", "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]visit(Ast.Aggregate)", "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]visit(Ast.DatatypeDecl)", "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]visit(Ast.DatatypeBind)", "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]visit(Ast.TyCon)", "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]visit(Ast.RecordType)", "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]visit(Ast.TupleType)", "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]visit(Ast.FunctionType)", "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]visit(Ast.CompositeType)", "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]visit(Core.Literal)", "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]visit(Core.Id)", "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]visit(Core.Let)", "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]visit(Core.Local)", "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]visit(Core.Case)", "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]visit(Core.Apply)", "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]visit(Core.RecordSelector)", "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]visit(Core.Tuple)", "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]visit(Core.DatatypeDecl)", "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]visit(Core.Fn)", "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]visit(Core.Match)", "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]visit(Core.From)", "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]visit(Core.Scan)", "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]visit(Core.Where)", "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]visit(Core.Skip)", "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]visit(Core.Take)", "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]visit(Core.NonRecValDecl)", "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]visit(Core.RecValDecl)", "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]visit(Core.Group)", "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]visit(Core.Aggregate)", "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]visit(Core.Order)", "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]visit(Core.OrderItem)", "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]visit(Core.Yield)", "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]visit(Core.TuplePat)", "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]visit(Core.RecordPat)", "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]visit(Core.ListPat)", "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]visit(Core.ConPat)", "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]visit(Core.Con0Pat)", "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]visit(Core.IdPat)", "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]visit(Core.AsPat)", "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]visit(Core.LiteralPat)", "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]visit(Core.WildcardPat)"], "overrides": null, "attributes": [], "class_docstring": " Visits syntax trees.", "original_string": "public class Visitor {\n\n  /** For use as a method reference. */\n  protected <E extends AstNode> void accept(E e) {\n    e.accept(this);\n  }\n\n  // expressions\n\n  protected void visit(Ast.Literal literal) {\n  }\n\n  protected void visit(Ast.Id id) {\n  }\n\n  protected void visit(Ast.AnnotatedExp annotatedExp) {\n    annotatedExp.exp.accept(this);\n    annotatedExp.type.accept(this);\n  }\n\n  protected void visit(Ast.If anIf) {\n    anIf.condition.accept(this);\n    anIf.ifTrue.accept(this);\n    anIf.ifFalse.accept(this);\n  }\n\n  protected void visit(Ast.Let let) {\n    let.decls.forEach(this::accept);\n    let.exp.accept(this);\n  }\n\n  protected void visit(Ast.Case kase) {\n    kase.exp.accept(this);\n    kase.matchList.forEach(this::accept);\n  }\n\n  // calls\n\n  protected void visit(Ast.InfixCall infixCall) {\n    infixCall.a0.accept(this);\n    infixCall.a1.accept(this);\n  }\n\n  protected void visit(Ast.PrefixCall prefixCall) {\n    prefixCall.a.accept(this);\n  }\n\n  // patterns\n\n  protected void visit(Ast.IdPat idPat) {\n  }\n\n  protected void visit(Ast.LiteralPat literalPat) {\n  }\n\n  protected void visit(Ast.WildcardPat wildcardPat) {\n  }\n\n  protected void visit(Ast.InfixPat infixPat) {\n    infixPat.p0.accept(this);\n    infixPat.p1.accept(this);\n  }\n\n  protected void visit(Ast.TuplePat tuplePat) {\n    tuplePat.args.forEach(this::accept);\n  }\n\n  protected void visit(Ast.ListPat listPat) {\n    listPat.args.forEach(this::accept);\n  }\n\n  protected void visit(Ast.RecordPat recordPat) {\n    recordPat.args.values().forEach(this::accept);\n  }\n\n  protected void visit(Ast.AnnotatedPat annotatedPat) {\n    annotatedPat.pat.accept(this);\n    annotatedPat.type.accept(this);\n  }\n\n  protected void visit(Ast.AsPat asPat) {\n    asPat.id.accept(this);\n    asPat.pat.accept(this);\n  }\n\n  protected void visit(Ast.ConPat conPat) {\n    conPat.tyCon.accept(this);\n    conPat.pat.accept(this);\n  }\n\n  protected void visit(Ast.Con0Pat con0Pat) {\n    con0Pat.tyCon.accept(this);\n  }\n\n  // value constructors\n\n  protected void visit(Ast.Tuple tuple) {\n    tuple.args.forEach(this::accept);\n  }\n\n  protected void visit(Ast.ListExp list) {\n    list.args.forEach(this::accept);\n  }\n\n  protected void visit(Ast.Record record) {\n    record.args.values().forEach(this::accept);\n  }\n\n  // functions and matches\n\n  protected void visit(Ast.Fn fn) {\n    fn.matchList.forEach(this::accept);\n  }\n\n  protected void visit(Ast.Apply apply) {\n    apply.fn.accept(this);\n    apply.arg.accept(this);\n  }\n\n  protected void visit(Ast.RecordSelector recordSelector) {\n  }\n\n  protected void visit(Ast.Match match) {\n    match.pat.accept(this);\n    match.exp.accept(this);\n  }\n\n  // types\n\n  protected void visit(Ast.NamedType namedType) {\n    namedType.types.forEach(this::accept);\n  }\n\n  protected void visit(Ast.TyVar tyVar) {\n  }\n\n  // declarations\n\n  protected void visit(Ast.FunDecl funDecl) {\n    funDecl.funBinds.forEach(this::accept);\n  }\n\n  protected void visit(Ast.FunBind funBind) {\n    funBind.matchList.forEach(this::accept);\n  }\n\n  protected void visit(Ast.FunMatch funMatch) {\n    funMatch.patList.forEach(this::accept);\n    funMatch.exp.accept(this);\n  }\n\n  protected void visit(Ast.ValDecl valDecl) {\n    valDecl.valBinds.forEach(this::accept);\n  }\n\n  protected void visit(Ast.ValBind valBind) {\n    valBind.pat.accept(this);\n    valBind.exp.accept(this);\n  }\n\n  protected void visit(Ast.From from) {\n    from.steps.forEach(this::accept);\n    if (from.implicitYieldExp != null) {\n      from.implicitYieldExp.accept(this);\n    }\n  }\n\n  protected void visit(Ast.Scan scan) {\n    scan.pat.accept(this);\n    if (scan.exp != null) {\n      scan.exp.accept(this);\n    }\n    if (scan.condition != null) {\n      scan.condition.accept(this);\n    }\n  }\n\n  protected void visit(Ast.Order order) {\n    order.orderItems.forEach(this::accept);\n  }\n\n  protected void visit(Ast.OrderItem orderItem) {\n    orderItem.exp.accept(this);\n  }\n\n  protected void visit(Ast.Where where) {\n    where.exp.accept(this);\n  }\n\n  protected void visit(Ast.Skip skip) {\n    skip.exp.accept(this);\n  }\n\n  protected void visit(Ast.Take take) {\n    take.exp.accept(this);\n  }\n\n  protected void visit(Ast.Yield yield) {\n    yield.exp.accept(this);\n  }\n\n  protected void visit(Ast.Into into) {\n    into.exp.accept(this);\n  }\n\n  protected void visit(Ast.Through through) {\n    through.pat.accept(this);\n    through.exp.accept(this);\n  }\n\n  protected void visit(Ast.Compute compute) {\n    compute.aggregates.forEach(this::accept);\n  }\n\n  protected void visit(Ast.Group group) {\n    group.groupExps.forEach((id, exp) -> {\n      id.accept(this);\n      exp.accept(this);\n    });\n    group.aggregates.forEach(this::accept);\n  }\n\n  protected void visit(Ast.Aggregate aggregate) {\n    aggregate.aggregate.accept(this);\n    if (aggregate.argument != null) {\n      aggregate.argument.accept(this);\n    }\n    aggregate.id.accept(this);\n  }\n\n  protected void visit(Ast.DatatypeDecl datatypeDecl) {\n    datatypeDecl.binds.forEach(this::accept);\n  }\n\n  protected void visit(Ast.DatatypeBind datatypeBind) {\n    datatypeBind.tyVars.forEach(this::accept);\n    datatypeBind.tyCons.forEach(this::accept);\n  }\n\n  protected void visit(Ast.TyCon tyCon) {\n    if (tyCon.type != null) {\n      tyCon.type.accept(this);\n    }\n    tyCon.id.accept(this);\n  }\n\n  protected void visit(Ast.RecordType recordType) {\n    recordType.fieldTypes.values().forEach(this::accept);\n  }\n\n  protected void visit(Ast.TupleType tupleType) {\n    tupleType.types.forEach(this::accept);\n  }\n\n  protected void visit(Ast.FunctionType functionType) {\n    functionType.paramType.accept(this);\n    functionType.resultType.accept(this);\n  }\n\n  protected void visit(Ast.CompositeType compositeType) {\n    compositeType.types.forEach(this::accept);\n  }\n\n  // core expressions\n\n  protected void visit(Core.Literal literal) {\n  }\n\n  protected void visit(Core.Id id) {\n  }\n\n  protected void visit(Core.Let let) {\n    let.decl.accept(this);\n    let.exp.accept(this);\n  }\n\n  protected void visit(Core.Local local) {\n    local.exp.accept(this);\n  }\n\n  protected void visit(Core.Case kase) {\n    kase.exp.accept(this);\n    kase.matchList.forEach(this::accept);\n  }\n\n  protected void visit(Core.Apply apply) {\n    apply.fn.accept(this);\n    apply.arg.accept(this);\n  }\n\n  protected void visit(Core.RecordSelector recordSelector) {\n  }\n\n  protected void visit(Core.Tuple tuple) {\n    tuple.args.forEach(this::accept);\n  }\n\n  protected void visit(Core.DatatypeDecl datatypeDecl) {\n  }\n\n  protected void visit(Core.Fn fn) {\n    fn.idPat.accept(this);\n    fn.exp.accept(this);\n  }\n\n  protected void visit(Core.Match match) {\n    match.pat.accept(this);\n    match.exp.accept(this);\n  }\n\n  protected void visit(Core.From from) {\n    from.steps.forEach(step -> step.accept(this));\n  }\n\n  protected void visit(Core.Scan scan) {\n    scan.pat.accept(this);\n    scan.exp.accept(this);\n    if (scan.condition != null) {\n      scan.condition.accept(this);\n    }\n  }\n\n  protected void visit(Core.Where where) {\n    where.exp.accept(this);\n  }\n\n  protected void visit(Core.Skip skip) {\n    skip.exp.accept(this);\n  }\n\n  protected void visit(Core.Take take) {\n    take.exp.accept(this);\n  }\n\n  protected void visit(Core.NonRecValDecl valDecl) {\n    valDecl.pat.accept(this);\n    valDecl.exp.accept(this);\n  }\n\n  protected void visit(Core.RecValDecl recValDecl) {\n    recValDecl.list.forEach(this::accept);\n  }\n\n  protected void visit(Core.Group group) {\n    group.groupExps.values().forEach(this::accept);\n    group.aggregates.values().forEach(this::accept);\n  }\n\n  protected void visit(Core.Aggregate aggregate) {\n    aggregate.aggregate.accept(this);\n    if (aggregate.argument != null) {\n      aggregate.argument.accept(this);\n    }\n  }\n\n  protected void visit(Core.Order order) {\n    order.orderItems.forEach(this::accept);\n  }\n\n  protected void visit(Core.OrderItem orderItem) {\n    orderItem.exp.accept(this);\n  }\n\n  protected void visit(Core.Yield yield) {\n    yield.exp.accept(this);\n  }\n\n  protected void visit(Core.TuplePat tuplePat) {\n    tuplePat.args.forEach(this::accept);\n  }\n\n  protected void visit(Core.RecordPat recordPat) {\n    recordPat.args.forEach(this::accept);\n  }\n\n  protected void visit(Core.ListPat listPat) {\n    listPat.args.forEach(this::accept);\n  }\n\n  protected void visit(Core.ConPat conPat) {\n    conPat.pat.accept(this);\n  }\n\n  protected void visit(Core.Con0Pat con0Pat) {\n  }\n\n  protected void visit(Core.IdPat idPat) {\n  }\n\n  protected void visit(Core.AsPat asPat) {\n    asPat.pat.accept(this);\n  }\n\n  protected void visit(Core.LiteralPat idPat) {\n  }\n\n  protected void visit(Core.WildcardPat wildcardPat) {\n  }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/main/java/net/hydromatic/morel/eval/Closure.java.Closure", "name": "Closure", "file_path": "src/main/java/net/hydromatic/morel/eval/Closure.java", "superclasses": "", "methods": ["[]Closure(EvalEnv,ImmutablePairList<Core.Pat, Code>,Pos)", "[String]toString()", "[int]compareTo(Closure)", "[EvalEnv]bind(Object)", "[EvalEnv]evalBind(EvalEnv)", "[Object]bindEval(Object)", "[Object]apply(EvalEnv,Object)", "[Describer]describe(Describer)", "[boolean]bindRecurse(Core.Pat,Object,BiConsumer<Core.NamedPat, Object>)"], "method_uris": ["src/main/java/net/hydromatic/morel/eval/Closure.java.Closure.[]Closure(EvalEnv,ImmutablePairList<Core.Pat, Code>,Pos)", "src/main/java/net/hydromatic/morel/eval/Closure.java.Closure.[String]toString()", "src/main/java/net/hydromatic/morel/eval/Closure.java.Closure.[int]compareTo(Closure)", "src/main/java/net/hydromatic/morel/eval/Closure.java.Closure.[EvalEnv]bind(Object)", "src/main/java/net/hydromatic/morel/eval/Closure.java.Closure.[EvalEnv]evalBind(EvalEnv)", "src/main/java/net/hydromatic/morel/eval/Closure.java.Closure.[Object]bindEval(Object)", "src/main/java/net/hydromatic/morel/eval/Closure.java.Closure.[Object]apply(EvalEnv,Object)", "src/main/java/net/hydromatic/morel/eval/Closure.java.Closure.[Describer]describe(Describer)", "src/main/java/net/hydromatic/morel/eval/Closure.java.Closure.[boolean]bindRecurse(Core.Pat,Object,BiConsumer<Core.NamedPat, Object>)"], "overrides": null, "attributes": [{"original_string": "  private static class EvalEnvHolder\n      implements BiConsumer<Core.NamedPat, Object> {\n    EvalEnv env;\n\n    EvalEnvHolder(EvalEnv env) {\n      this.env = env;\n    }\n\n    @Override public void accept(Core.NamedPat namedPat, Object o) {\n      env = env.bind(namedPat.name, o);\n    }\n  }", "definition": "  private static class EvalEnvHolder\n      implements BiConsumer<Core.NamedPat, Object>", "class_docstring": " Callback for {@link #bindRecurse(Core.Pat, Object, BiConsumer)} that\nmodifies an environment.", "name": "EvalEnvHolder", "super_interfaces": ["BiConsumer<Core.NamedPat, Object>"], "superclasses": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "fields": [{"attribute_expression": "EvalEnv env;", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "EvalEnv", "name": "env", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    EvalEnvHolder(EvalEnv env) {\n      this.env = env;\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "EvalEnvHolder", "params": [{"name": "env", "type": "EvalEnv"}], "body": "                               {\n      this.env = env;\n    }", "signature": "EvalEnvHolder(EvalEnv env)"}, {"syntax_pass": true, "original_string": "    @Override public void accept(Core.NamedPat namedPat, Object o) {\n      env = env.bind(namedPat.name, o);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "accept", "params": [{"name": "namedPat", "type": "Core.NamedPat"}, {"name": "o", "type": "Object"}], "body": "                                                                   {\n      env = env.bind(namedPat.name, o);\n    }", "signature": "@Override public void accept(Core.NamedPat namedPat, Object o)"}]}], "class_docstring": " Value that is sufficient for a function to bind its argument\nand evaluate its body.", "original_string": "public class Closure implements Comparable<Closure>, Applicable {\n  /** Environment for evaluation. Contains the variables \"captured\" from the\n   * environment when the closure was created. */\n  private final EvalEnv evalEnv;\n\n  /** A list of (pattern, code) pairs. During bind, the value being bound is\n   * matched against each pattern. When a match is found, the code for that\n   * pattern is used to evaluate.\n   *\n   * <p>For example, when applying\n   * {@code fn x => case x of 0 => \"yes\" | _ => \"no\"}\n   * to the value {@code 1}, the first pattern ({@code 0} fails) but the second\n   * pattern ({@code _}) succeeds, and therefore we evaluate the second\n   * code {@code \"no\"}. */\n  private final ImmutablePairList<Core.Pat, Code> patCodes;\n  private final Pos pos;\n\n  /** Not a public API. */\n  public Closure(EvalEnv evalEnv,\n      ImmutablePairList<Core.Pat, Code> patCodes, Pos pos) {\n    this.evalEnv = requireNonNull(evalEnv).fix();\n    this.patCodes = requireNonNull(patCodes);\n    this.pos = pos;\n  }\n\n  @Override public String toString() {\n    return \"Closure(evalEnv = \" + evalEnv + \", patCodes = \" + patCodes + \")\";\n  }\n\n  public int compareTo(Closure o) {\n    return 0;\n  }\n\n  /** Binds an argument value to create a new environment for a closure.\n   *\n   * <p>When calling a simple function such as {@code (fn x => x + 1) 2},\n   * the binder sets just contains one variable, {@code x}, and the\n   * new environment contains {@code x = 1}.  If the function's\n   * parameter is a match, more variables might be bound. For example,\n   * when you invoke {@code (fn (x, y) => x + y) (3, 4)}, the binder\n   * sets {@code x} to 3 and {@code y} to 4. */\n  EvalEnv bind(Object argValue) {\n    final EvalEnvHolder envRef = new EvalEnvHolder(evalEnv);\n    for (Core.Pat pat : patCodes.leftList()) {\n      if (bindRecurse(pat, argValue, envRef)) {\n        return envRef.env;\n      }\n    }\n    throw new AssertionError(\"no match\");\n  }\n\n  /** Similar to {@link #bind}, but evaluates an expression first. */\n  EvalEnv evalBind(EvalEnv env) {\n    final EvalEnvHolder envRef = new EvalEnvHolder(env);\n    for (Map.Entry<Core.Pat, Code> patCode : patCodes) {\n      final Object argValue = patCode.getValue().eval(env);\n      final Core.Pat pat = patCode.getKey();\n      if (bindRecurse(pat, argValue, envRef)) {\n        return envRef.env;\n      }\n    }\n    throw new AssertionError(\"no match\");\n  }\n\n  /** Similar to {@link #bind}, but also evaluates. */\n  Object bindEval(Object argValue) {\n    final EvalEnvHolder envRef = new EvalEnvHolder(evalEnv);\n    for (Map.Entry<Core.Pat, Code> patCode : patCodes) {\n      final Core.Pat pat = patCode.getKey();\n      if (bindRecurse(pat, argValue, envRef)) {\n        final Code code = patCode.getValue();\n        return code.eval(envRef.env);\n      }\n    }\n    throw new Codes.MorelRuntimeException(Codes.BuiltInExn.BIND, pos);\n  }\n\n  @Override public Object apply(EvalEnv env, Object argValue) {\n    return bindEval(argValue);\n  }\n\n  @Override public Describer describe(Describer describer) {\n    return describer.start(\"closure\", d -> {});\n  }\n\n  /** Attempts to bind a value to a pattern. Returns whether it has succeeded in\n   * matching the whole pattern.\n   *\n   * <p>Each time it matches a name, calls a consumer. It's possible that the\n   * consumer is called a few times even if the whole pattern ultimately fails\n   * to match. */\n  public static boolean bindRecurse(Core.Pat pat, Object argValue,\n      BiConsumer<Core.NamedPat, Object> envRef) {\n    final List<Object> listValue;\n    final Core.LiteralPat literalPat;\n    switch (pat.op) {\n    case ID_PAT:\n      final Core.IdPat idPat = (Core.IdPat) pat;\n      envRef.accept(idPat, argValue);\n      return true;\n\n    case WILDCARD_PAT:\n      return true;\n\n    case AS_PAT:\n      final Core.AsPat asPat = (Core.AsPat) pat;\n      envRef.accept(asPat, argValue);\n      return bindRecurse(asPat.pat, argValue, envRef);\n\n    case BOOL_LITERAL_PAT:\n    case CHAR_LITERAL_PAT:\n    case STRING_LITERAL_PAT:\n      literalPat = (Core.LiteralPat) pat;\n      return literalPat.value.equals(argValue);\n\n    case INT_LITERAL_PAT:\n      literalPat = (Core.LiteralPat) pat;\n      return ((BigDecimal) literalPat.value).intValue() == (Integer) argValue;\n\n    case REAL_LITERAL_PAT:\n      literalPat = (Core.LiteralPat) pat;\n      return ((BigDecimal) literalPat.value).doubleValue() == (Double) argValue;\n\n    case TUPLE_PAT:\n      final Core.TuplePat tuplePat = (Core.TuplePat) pat;\n      listValue = (List) argValue;\n      return allMatch(tuplePat.args, listValue,\n          (pat1, value) -> bindRecurse(pat1, value, envRef));\n\n    case RECORD_PAT:\n      final Core.RecordPat recordPat = (Core.RecordPat) pat;\n      listValue = (List) argValue;\n      return allMatch(recordPat.args, listValue,\n          (pat1, value) -> bindRecurse(pat1, value, envRef));\n\n    case LIST_PAT:\n      final Core.ListPat listPat = (Core.ListPat) pat;\n      listValue = (List) argValue;\n      if (listValue.size() != listPat.args.size()) {\n        return false;\n      }\n      return allMatch(listPat.args, listValue,\n          (pat1, value) -> bindRecurse(pat1, value, envRef));\n\n    case CONS_PAT:\n      final Core.ConPat consPat = (Core.ConPat) pat;\n      @SuppressWarnings(\"unchecked\") final List<Object> consValue =\n          (List) argValue;\n      if (consValue.isEmpty()) {\n        return false;\n      }\n      final Object head = consValue.get(0);\n      final List<Object> tail = skip(consValue);\n      List<Core.Pat> patArgs = ((Core.TuplePat) consPat.pat).args;\n      return bindRecurse(patArgs.get(0), head, envRef)\n          && bindRecurse(patArgs.get(1), tail, envRef);\n\n    case CON0_PAT:\n      final Core.Con0Pat con0Pat = (Core.Con0Pat) pat;\n      final List con0Value = (List) argValue;\n      return con0Value.get(0).equals(con0Pat.tyCon);\n\n    case CON_PAT:\n      final Core.ConPat conPat = (Core.ConPat) pat;\n      final List conValue = (List) argValue;\n      return conValue.get(0).equals(conPat.tyCon)\n          && bindRecurse(conPat.pat, conValue.get(1), envRef);\n\n    default:\n      throw new AssertionError(\"cannot compile \" + pat.op + \": \" + pat);\n    }\n  }\n\n  /** Callback for {@link #bindRecurse(Core.Pat, Object, BiConsumer)} that\n   * modifies an environment. */\n  private static class EvalEnvHolder\n      implements BiConsumer<Core.NamedPat, Object> {\n    EvalEnv env;\n\n    EvalEnvHolder(EvalEnv env) {\n      this.env = env;\n    }\n\n    @Override public void accept(Core.NamedPat namedPat, Object o) {\n      env = env.bind(namedPat.name, o);\n    }\n  }\n}", "super_interfaces": ["Comparable<Closure>", "Applicable"], "fields": [{"attribute_expression": "private final EvalEnv evalEnv;", "docstring": " Environment for evaluation. Contains the variables \"captured\" from the\nenvironment when the closure was created.", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "EvalEnv", "name": "evalEnv", "syntax_pass": true}, {"attribute_expression": "private final ImmutablePairList<Core.Pat, Code> patCodes;", "docstring": " A list of (pattern, code) pairs. During bind, the value being bound is\nmatched against each pattern. When a match is found, the code for that\npattern is used to evaluate.\n\n<p>For example, when applying\n{@code fn x => case x of 0 => \"yes\" | _ => \"no\"}\nto the value {@code 1}, the first pattern ({@code 0} fails) but the second\npattern ({@code _}) succeeds, and therefore we evaluate the second\ncode {@code \"no\"}.", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "ImmutablePairList<Core.Pat, Code>", "name": "patCodes", "syntax_pass": true}, {"attribute_expression": "private final Pos pos;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Pos", "name": "pos", "syntax_pass": true}]}, {"uris": "src/main/java/net/hydromatic/morel/eval/Unit.java.Unit", "name": "Unit", "file_path": "src/main/java/net/hydromatic/morel/eval/Unit.java", "superclasses": "AbstractList", "methods": ["[]Unit()", "[String]toString()", "[Object]get(int)", "[int]size()", "[int]compareTo(Unit)"], "method_uris": ["src/main/java/net/hydromatic/morel/eval/Unit.java.Unit.[]Unit()", "src/main/java/net/hydromatic/morel/eval/Unit.java.Unit.[String]toString()", "src/main/java/net/hydromatic/morel/eval/Unit.java.Unit.[Object]get(int)", "src/main/java/net/hydromatic/morel/eval/Unit.java.Unit.[int]size()", "src/main/java/net/hydromatic/morel/eval/Unit.java.Unit.[int]compareTo(Unit)"], "overrides": null, "attributes": [], "class_docstring": " A placeholder value for the \"unit\" type.\n\n<p>We sometimes use it as a dummy value when we need to add a variable (and\nits type) to the compilation environment but we don't have a value (because\nit's not a runtime environment).", "original_string": "public class Unit extends AbstractList implements Comparable<Unit> {\n  public static final Unit INSTANCE = new Unit();\n\n  private Unit() {}\n\n  @Override public String toString() {\n    return \"()\";\n  }\n\n  public Object get(int index) {\n    throw new IndexOutOfBoundsException();\n  }\n\n  public int size() {\n    return 0;\n  }\n\n  public int compareTo(Unit o) {\n    return 0;\n  }\n}", "super_interfaces": ["Comparable<Unit>"], "fields": [{"attribute_expression": "public static final Unit INSTANCE = new Unit();", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "Unit", "name": "INSTANCE = new Unit()", "syntax_pass": true}]}, {"uris": "src/main/java/net/hydromatic/morel/eval/DescriberImpl.java.DescriberImpl", "name": "DescriberImpl", "file_path": "src/main/java/net/hydromatic/morel/eval/DescriberImpl.java", "superclasses": "", "methods": ["[String]toString()", "[Describer]start(String,Consumer<Detail>)"], "method_uris": ["src/main/java/net/hydromatic/morel/eval/DescriberImpl.java.DescriberImpl.[String]toString()", "src/main/java/net/hydromatic/morel/eval/DescriberImpl.java.DescriberImpl.[Describer]start(String,Consumer<Detail>)"], "overrides": null, "attributes": [{"original_string": "  private class DetailImpl implements Detail {\n    final int start = buf.length();\n\n    @Override public Detail arg(String name, Object value) {\n      buf.append(buf.length() == start ? \"(\" : \", \")\n          .append(name)\n          .append(name.equals(\"\") ? \"\" : \" \")\n          .append(value);\n      return this;\n    }\n\n    @Override public Detail arg(String name, Describable describable) {\n      buf.append(buf.length() == start ? \"(\" : \", \")\n          .append(name)\n          .append(name.equals(\"\") ? \"\" : \" \");\n      describable.describe(DescriberImpl.this);\n      return this;\n    }\n\n    void end() {\n      if (buf.length() > start) {\n        buf.append(')');\n      }\n    }\n  }", "definition": "  private class DetailImpl implements Detail", "class_docstring": " Implementation of\n{@link Detail}.", "name": "DetailImpl", "super_interfaces": ["Detail"], "superclasses": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "fields": [{"attribute_expression": "final int start = buf.length();", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "int", "name": "start = buf.length()", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @Override public Detail arg(String name, Object value) {\n      buf.append(buf.length() == start ? \"(\" : \", \")\n          .append(name)\n          .append(name.equals(\"\") ? \"\" : \" \")\n          .append(value);\n      return this;\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Detail", "classes": []}, "name": "arg", "params": [{"name": "name", "type": "String"}, {"name": "value", "type": "Object"}], "body": "                                                           {\n      buf.append(buf.length() == start ? \"(\" : \", \")\n          .append(name)\n          .append(name.equals(\"\") ? \"\" : \" \")\n          .append(value);\n      return this;\n    }", "signature": "@Override public Detail arg(String name, Object value)"}, {"syntax_pass": true, "original_string": "    @Override public Detail arg(String name, Describable describable) {\n      buf.append(buf.length() == start ? \"(\" : \", \")\n          .append(name)\n          .append(name.equals(\"\") ? \"\" : \" \");\n      describable.describe(DescriberImpl.this);\n      return this;\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Detail", "classes": []}, "name": "arg", "params": [{"name": "name", "type": "String"}, {"name": "describable", "type": "Describable"}], "body": "                                                                      {\n      buf.append(buf.length() == start ? \"(\" : \", \")\n          .append(name)\n          .append(name.equals(\"\") ? \"\" : \" \");\n      describable.describe(DescriberImpl.this);\n      return this;\n    }", "signature": "@Override public Detail arg(String name, Describable describable)"}, {"syntax_pass": true, "original_string": "    void end() {\n      if (buf.length() > start) {\n        buf.append(')');\n      }\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "name": "end", "params": [], "body": "               {\n      if (buf.length() > start) {\n        buf.append(')');\n      }\n    }", "signature": "void end()"}]}], "class_docstring": " Implementation of {@link net.hydromatic.morel.eval.Code .Describer}.", "original_string": "class DescriberImpl implements Describer {\n  final StringBuilder buf = new StringBuilder();\n\n  @Override public String toString() {\n    return buf.toString();\n  }\n\n  @Override public Describer start(String name,\n      Consumer<Detail> consumer) {\n    buf.append(name);\n    final DetailImpl detail = new DetailImpl();\n    consumer.accept(detail);\n    detail.end();\n    return this;\n  }\n\n  /** Implementation of\n   * {@link Detail}. */\n  private class DetailImpl implements Detail {\n    final int start = buf.length();\n\n    @Override public Detail arg(String name, Object value) {\n      buf.append(buf.length() == start ? \"(\" : \", \")\n          .append(name)\n          .append(name.equals(\"\") ? \"\" : \" \")\n          .append(value);\n      return this;\n    }\n\n    @Override public Detail arg(String name, Describable describable) {\n      buf.append(buf.length() == start ? \"(\" : \", \")\n          .append(name)\n          .append(name.equals(\"\") ? \"\" : \" \");\n      describable.describe(DescriberImpl.this);\n      return this;\n    }\n\n    void end() {\n      if (buf.length() > start) {\n        buf.append(')');\n      }\n    }\n  }\n}", "super_interfaces": ["Describer"], "fields": [{"attribute_expression": "final StringBuilder buf = new StringBuilder();", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "StringBuilder", "name": "buf = new StringBuilder()", "syntax_pass": true}]}, {"uris": "src/main/java/net/hydromatic/morel/eval/Session.java.Session", "name": "Session", "file_path": "src/main/java/net/hydromatic/morel/eval/Session.java", "superclasses": "", "methods": ["[]Session(Map<Prop, Object>)", "[void]withShell(Shell,Consumer<String>,Consumer<Session>)", "[void]withoutHandlingExceptions(Consumer<Session>)", "[void]use(String,boolean,Pos)", "[void]handle(MorelException,StringBuilder)"], "method_uris": ["src/main/java/net/hydromatic/morel/eval/Session.java.Session.[]Session(Map<Prop, Object>)", "src/main/java/net/hydromatic/morel/eval/Session.java.Session.[void]withShell(Shell,Consumer<String>,Consumer<Session>)", "src/main/java/net/hydromatic/morel/eval/Session.java.Session.[void]withoutHandlingExceptions(Consumer<Session>)", "src/main/java/net/hydromatic/morel/eval/Session.java.Session.[void]use(String,boolean,Pos)", "src/main/java/net/hydromatic/morel/eval/Session.java.Session.[void]handle(MorelException,StringBuilder)"], "overrides": null, "attributes": [], "class_docstring": " Session environment.\n\n<p>Accessible from {@link EvalEnv#getOpt(String)} via the hidden \"$session\"\nvariable.", "original_string": "public class Session {\n  /** The plan of the previous command. */\n  public Code code;\n  /** The output lines of the previous command. */\n  public List<String> out;\n  /** Property values. */\n  public final Map<Prop, Object> map;\n\n  /** File system.\n   *\n   * <p>Wrapped in a Supplier to avoid the cost of initializing it (scanning\n   * a directory) for every session. */\n  public final Supplier<File> file;\n\n  /** Implementation of \"use\". */\n  private Shell shell = Shells.INSTANCE;\n\n  /** Creates a Session.\n   *\n   * <p>The {@code map} parameter, that becomes the property map, is used as is,\n   * not copied. It may be immutable if the session is for a narrow, internal\n   * use. Otherwise, it should probably be a {@link LinkedHashMap} to provide\n   * deterministic iteration order.\n   *\n   * @param map Map that contains property values */\n  public Session(Map<Prop, Object> map) {\n    this.map = map;\n    this.file =\n        Suppliers.memoize(() ->\n            Files.create(Prop.DIRECTORY.fileValue(this.map)));\n  }\n\n  /** Calls some code with a new value of {@link Shell}. */\n  public void withShell(Shell shell, Consumer<String> outLines,\n      Consumer<Session> consumer) {\n    final Shell prevShell = this.shell;\n    try {\n      this.shell = requireNonNull(shell, \"shell\");\n      consumer.accept(this);\n    } catch (RuntimeException e) {\n      final StringBuilder buf = new StringBuilder();\n      prevShell.handle(e, buf);\n      outLines.accept(buf.toString());\n    } finally {\n      this.shell = prevShell;\n    }\n  }\n\n  /** Calls some code with a {@link Shell} that does not handle errors. */\n  public void withoutHandlingExceptions(Consumer<Session> consumer) {\n    final Shell prevShell = this.shell;\n    try {\n      this.shell = Shells.BARF;\n      consumer.accept(this);\n    } finally {\n      this.shell = prevShell;\n    }\n  }\n\n  public void use(String fileName, boolean silent, Pos pos) {\n    shell.use(fileName, silent, pos);\n  }\n\n  public void handle(MorelException e, StringBuilder buf) {\n    shell.handle((RuntimeException) e, buf);\n  }\n\n  /** Callback to implement \"use\" command. */\n  public interface Shell {\n    void use(String fileName, boolean silent, Pos pos);\n\n    /** Handles an exception. Particular implementations may re-throw the\n     * exception, or may format the exception to a buffer that will be added to\n     * the output. Typically, a root shell will handle the exception, and\n     * sub-shells will re-throw. */\n    void handle(RuntimeException e, StringBuilder buf);\n  }\n\n  /** Various implementations of {@link Shell}. */\n  private enum Shells implements Shell {\n    /** Default instance of Shell. */\n    INSTANCE {\n      @Override public void handle(RuntimeException e, StringBuilder buf) {\n        if (e instanceof Codes.MorelRuntimeException) {\n          ((Codes.MorelRuntimeException) e).describeTo(buf);\n        } else if (e instanceof CompileException) {\n          buf.append(e.getMessage());\n        } else {\n          buf.append(e);\n        }\n      }\n    },\n\n    /** Instance of Shell that does not handle exceptions. */\n    BARF {\n      @Override public void handle(RuntimeException e, StringBuilder buf) {\n        throw e;\n      }\n    };\n\n    @Override public void use(String fileName, boolean silent, Pos pos) {\n      throw new UnsupportedOperationException();\n    }\n  }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "public Code code;", "docstring": " The plan of the previous command.", "modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "type": "Code", "name": "code", "syntax_pass": true}, {"attribute_expression": "public List<String> out;", "docstring": " The output lines of the previous command.", "modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "type": "List<String>", "name": "out", "syntax_pass": true}, {"attribute_expression": "public final Map<Prop, Object> map;", "docstring": " Property values.", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "Map<Prop, Object>", "name": "map", "syntax_pass": true}, {"attribute_expression": "public final Supplier<File> file;", "docstring": " File system.\n\n<p>Wrapped in a Supplier to avoid the cost of initializing it (scanning\na directory) for every session.", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "Supplier<File>", "name": "file", "syntax_pass": true}, {"attribute_expression": "private Shell shell = Shells.INSTANCE;", "docstring": " Implementation of \"use\".", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Shell", "name": "shell = Shells.INSTANCE", "syntax_pass": true}]}, {"uris": "src/main/java/net/hydromatic/morel/eval/EvalEnvs.java.EvalEnvs", "name": "EvalEnvs", "file_path": "src/main/java/net/hydromatic/morel/eval/EvalEnvs.java", "superclasses": "", "methods": ["[EvalEnv]copyOf(Map<String, Object>)", "[]EvalEnvs()"], "method_uris": ["src/main/java/net/hydromatic/morel/eval/EvalEnvs.java.EvalEnvs.[EvalEnv]copyOf(Map<String, Object>)", "src/main/java/net/hydromatic/morel/eval/EvalEnvs.java.EvalEnvs.[]EvalEnvs()"], "overrides": null, "attributes": [{"original_string": "  static class SubEvalEnv implements EvalEnv {\n    protected final EvalEnv parentEnv;\n    protected final String name;\n    protected Object value;\n\n    SubEvalEnv(EvalEnv parentEnv, String name, Object value) {\n      this.parentEnv = parentEnv;\n      this.name = name;\n      this.value = value;\n    }\n\n    public void visit(BiConsumer<String, Object> consumer) {\n      consumer.accept(name, value);\n      parentEnv.visit(consumer);\n    }\n\n    public Object getOpt(String name) {\n      for (SubEvalEnv e = this;;) {\n        if (name.equals(e.name)) {\n          return e.value;\n        }\n        if (e.parentEnv instanceof SubEvalEnv) {\n          e = (SubEvalEnv) e.parentEnv;\n        } else {\n          return e.parentEnv.getOpt(name);\n        }\n      }\n    }\n  }", "definition": "  static class SubEvalEnv implements EvalEnv", "class_docstring": " Evaluation environment that inherits from a parent environment and adds\none binding.", "name": "SubEvalEnv", "super_interfaces": ["EvalEnv"], "superclasses": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "fields": [{"attribute_expression": "protected final EvalEnv parentEnv;", "docstring": "", "modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "type": "EvalEnv", "name": "parentEnv", "syntax_pass": true}, {"attribute_expression": "protected final String name;", "docstring": "", "modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "type": "String", "name": "name", "syntax_pass": true}, {"attribute_expression": "protected Object value;", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "Object", "name": "value", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    SubEvalEnv(EvalEnv parentEnv, String name, Object value) {\n      this.parentEnv = parentEnv;\n      this.name = name;\n      this.value = value;\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "SubEvalEnv", "params": [{"name": "parentEnv", "type": "EvalEnv"}, {"name": "name", "type": "String"}, {"name": "value", "type": "Object"}], "body": "                                                             {\n      this.parentEnv = parentEnv;\n      this.name = name;\n      this.value = value;\n    }", "signature": "SubEvalEnv(EvalEnv parentEnv, String name, Object value)"}, {"syntax_pass": true, "original_string": "    public void visit(BiConsumer<String, Object> consumer) {\n      consumer.accept(name, value);\n      parentEnv.visit(consumer);\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "visit", "params": [{"name": "consumer", "type": "BiConsumer<String, Object>"}], "body": "                                                           {\n      consumer.accept(name, value);\n      parentEnv.visit(consumer);\n    }", "signature": "public void visit(BiConsumer<String, Object> consumer)"}, {"syntax_pass": true, "original_string": "    public Object getOpt(String name) {\n      for (SubEvalEnv e = this;;) {\n        if (name.equals(e.name)) {\n          return e.value;\n        }\n        if (e.parentEnv instanceof SubEvalEnv) {\n          e = (SubEvalEnv) e.parentEnv;\n        } else {\n          return e.parentEnv.getOpt(name);\n        }\n      }\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Object", "classes": []}, "name": "getOpt", "params": [{"name": "name", "type": "String"}], "body": "                                      {\n      for (SubEvalEnv e = this;;) {\n        if (name.equals(e.name)) {\n          return e.value;\n        }\n        if (e.parentEnv instanceof SubEvalEnv) {\n          e = (SubEvalEnv) e.parentEnv;\n        } else {\n          return e.parentEnv.getOpt(name);\n        }\n      }\n    }", "signature": "public Object getOpt(String name)"}]}, {"original_string": "  static class MutableSubEvalEnv extends SubEvalEnv implements MutableEvalEnv {\n    MutableSubEvalEnv(EvalEnv parentEnv, String name) {\n      super(parentEnv, name, null);\n    }\n\n    public void set(Object value) {\n      this.value = value;\n    }\n\n    @Override public EvalEnv fix() {\n      return new SubEvalEnv(parentEnv, name, value);\n    }\n  }", "definition": "  static class MutableSubEvalEnv extends SubEvalEnv implements MutableEvalEnv", "class_docstring": " Similar to {@link SubEvalEnv} but mutable.", "name": "MutableSubEvalEnv", "super_interfaces": ["MutableEvalEnv"], "superclasses": "SubEvalEnv", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    MutableSubEvalEnv(EvalEnv parentEnv, String name) {\n      super(parentEnv, name, null);\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "MutableSubEvalEnv", "params": [{"name": "parentEnv", "type": "EvalEnv"}, {"name": "name", "type": "String"}], "body": "                                                      {\n      super(parentEnv, name, null);\n    }", "signature": "MutableSubEvalEnv(EvalEnv parentEnv, String name)"}, {"syntax_pass": true, "original_string": "    public void set(Object value) {\n      this.value = value;\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "set", "params": [{"name": "value", "type": "Object"}], "body": "                                  {\n      this.value = value;\n    }", "signature": "public void set(Object value)"}, {"syntax_pass": true, "original_string": "    @Override public EvalEnv fix() {\n      return new SubEvalEnv(parentEnv, name, value);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "EvalEnv", "classes": []}, "name": "fix", "params": [], "body": "                                   {\n      return new SubEvalEnv(parentEnv, name, value);\n    }", "signature": "@Override public EvalEnv fix()"}]}, {"original_string": "  static class ArraySubEvalEnv implements EvalEnv {\n    protected final EvalEnv parentEnv;\n    protected final ImmutableList<String> names;\n    protected Object[] values;\n\n    ArraySubEvalEnv(EvalEnv parentEnv, ImmutableList<String> names,\n        @Nullable Object[] values) {\n      this.parentEnv = requireNonNull(parentEnv);\n      this.names = requireNonNull(names);\n      this.values = values; // may be null\n    }\n\n    public void visit(BiConsumer<String, Object> consumer) {\n      for (int i = 0; i < names.size(); i++) {\n        consumer.accept(names.get(i), values[i]);\n      }\n      parentEnv.visit(consumer);\n    }\n\n    public Object getOpt(String name) {\n      final int i = names.indexOf(name);\n      if (i >= 0) {\n        return values[i];\n      }\n      return parentEnv.getOpt(name);\n    }\n  }", "definition": "  static class ArraySubEvalEnv implements EvalEnv", "class_docstring": " Similar to {@link MutableEvalEnv} but binds several names.", "name": "ArraySubEvalEnv", "super_interfaces": ["EvalEnv"], "superclasses": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "fields": [{"attribute_expression": "protected final EvalEnv parentEnv;", "docstring": "", "modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "type": "EvalEnv", "name": "parentEnv", "syntax_pass": true}, {"attribute_expression": "protected final ImmutableList<String> names;", "docstring": "", "modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "type": "ImmutableList<String>", "name": "names", "syntax_pass": true}, {"attribute_expression": "protected Object[] values;", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "Object[]", "name": "values", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    ArraySubEvalEnv(EvalEnv parentEnv, ImmutableList<String> names,\n        @Nullable Object[] values) {\n      this.parentEnv = requireNonNull(parentEnv);\n      this.names = requireNonNull(names);\n      this.values = values; // may be null\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "ArraySubEvalEnv", "params": [{"name": "parentEnv", "type": "EvalEnv"}, {"name": "names", "type": "ImmutableList<String>"}, {"name": "values", "type": "Object[]"}], "body": "                                   {\n      this.parentEnv = requireNonNull(parentEnv);\n      this.names = requireNonNull(names);\n      this.values = values; // may be null\n    }", "signature": "ArraySubEvalEnv(EvalEnv parentEnv, ImmutableList<String> names,\n        @Nullable Object[] values)"}, {"syntax_pass": true, "original_string": "    public void visit(BiConsumer<String, Object> consumer) {\n      for (int i = 0; i < names.size(); i++) {\n        consumer.accept(names.get(i), values[i]);\n      }\n      parentEnv.visit(consumer);\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "visit", "params": [{"name": "consumer", "type": "BiConsumer<String, Object>"}], "body": "                                                           {\n      for (int i = 0; i < names.size(); i++) {\n        consumer.accept(names.get(i), values[i]);\n      }\n      parentEnv.visit(consumer);\n    }", "signature": "public void visit(BiConsumer<String, Object> consumer)"}, {"syntax_pass": true, "original_string": "    public Object getOpt(String name) {\n      final int i = names.indexOf(name);\n      if (i >= 0) {\n        return values[i];\n      }\n      return parentEnv.getOpt(name);\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Object", "classes": []}, "name": "getOpt", "params": [{"name": "name", "type": "String"}], "body": "                                      {\n      final int i = names.indexOf(name);\n      if (i >= 0) {\n        return values[i];\n      }\n      return parentEnv.getOpt(name);\n    }", "signature": "public Object getOpt(String name)"}]}, {"original_string": "  static class MutableArraySubEvalEnv extends ArraySubEvalEnv\n      implements MutableEvalEnv {\n    MutableArraySubEvalEnv(EvalEnv parentEnv, List<String> names) {\n      super(parentEnv, ImmutableList.copyOf(names), null);\n    }\n\n    public void set(Object value) {\n      values = (Object[]) value;\n      assert values.length == names.size();\n    }\n\n    @Override public ArraySubEvalEnv fix() {\n      return new ArraySubEvalEnv(parentEnv, names, values.clone());\n    }\n  }", "definition": "  static class MutableArraySubEvalEnv extends ArraySubEvalEnv\n      implements MutableEvalEnv", "class_docstring": " Similar to {@link MutableEvalEnv} but binds several names;\nextends {@link ArraySubEvalEnv} adding mutability.", "name": "MutableArraySubEvalEnv", "super_interfaces": ["MutableEvalEnv"], "superclasses": "ArraySubEvalEnv", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    MutableArraySubEvalEnv(EvalEnv parentEnv, List<String> names) {\n      super(parentEnv, ImmutableList.copyOf(names), null);\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "MutableArraySubEvalEnv", "params": [{"name": "parentEnv", "type": "EvalEnv"}, {"name": "names", "type": "List<String>"}], "body": "                                                                  {\n      super(parentEnv, ImmutableList.copyOf(names), null);\n    }", "signature": "MutableArraySubEvalEnv(EvalEnv parentEnv, List<String> names)"}, {"syntax_pass": true, "original_string": "    public void set(Object value) {\n      values = (Object[]) value;\n      assert values.length == names.size();\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "set", "params": [{"name": "value", "type": "Object"}], "body": "                                  {\n      values = (Object[]) value;\n      assert values.length == names.size();\n    }", "signature": "public void set(Object value)"}, {"syntax_pass": true, "original_string": "    @Override public ArraySubEvalEnv fix() {\n      return new ArraySubEvalEnv(parentEnv, names, values.clone());\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "ArraySubEvalEnv", "classes": []}, "name": "fix", "params": [], "body": "                                           {\n      return new ArraySubEvalEnv(parentEnv, names, values.clone());\n    }", "signature": "@Override public ArraySubEvalEnv fix()"}]}, {"original_string": "  static class PatSubEvalEnv extends ArraySubEvalEnv {\n    protected final Core.Pat pat;\n\n    PatSubEvalEnv(EvalEnv parentEnv, Core.Pat pat, ImmutableList<String> names,\n        Object[] values) {\n      super(parentEnv, ImmutableList.copyOf(names), values);\n      this.pat = requireNonNull(pat);\n      assert !(pat instanceof Core.IdPat);\n    }\n  }", "definition": "  static class PatSubEvalEnv extends ArraySubEvalEnv", "class_docstring": " Immutable copy of {@link MutablePatSubEvalEnv}.", "name": "PatSubEvalEnv", "super_interfaces": [], "superclasses": "ArraySubEvalEnv", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "fields": [{"attribute_expression": "protected final Core.Pat pat;", "docstring": "", "modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "type": "Core.Pat", "name": "pat", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    PatSubEvalEnv(EvalEnv parentEnv, Core.Pat pat, ImmutableList<String> names,\n        Object[] values) {\n      super(parentEnv, ImmutableList.copyOf(names), values);\n      this.pat = requireNonNull(pat);\n      assert !(pat instanceof Core.IdPat);\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "PatSubEvalEnv", "params": [{"name": "parentEnv", "type": "EvalEnv"}, {"name": "pat", "type": "Core.Pat"}, {"name": "names", "type": "ImmutableList<String>"}, {"name": "values", "type": "Object[]"}], "body": "                         {\n      super(parentEnv, ImmutableList.copyOf(names), values);\n      this.pat = requireNonNull(pat);\n      assert !(pat instanceof Core.IdPat);\n    }", "signature": "PatSubEvalEnv(EvalEnv parentEnv, Core.Pat pat, ImmutableList<String> names,\n        Object[] values)"}]}, {"original_string": "  static class MutablePatSubEvalEnv extends PatSubEvalEnv\n      implements MutableEvalEnv {\n    private int slot;\n\n    MutablePatSubEvalEnv(EvalEnv parentEnv, Core.Pat pat, List<String> names) {\n      super(parentEnv, pat, ImmutableList.copyOf(names),\n          new Object[names.size()]);\n    }\n\n    @Override public EvalEnv fix() {\n      return new PatSubEvalEnv(parentEnv, pat, names, values.clone());\n    }\n\n    @Override public void set(Object value) {\n      if (!setOpt(value)) {\n        // If this error happens, perhaps your code should be calling \"setOpt\"\n        // and handling a false result appropriately.\n        throw new AssertionError(\"bind failed\");\n      }\n    }\n\n    @Override public boolean setOpt(Object value) {\n      slot = 0;\n      return bindRecurse(pat, value);\n    }\n\n    boolean bindRecurse(Core.Pat pat, Object argValue) {\n      final List<Object> listValue;\n      final Core.LiteralPat literalPat;\n      switch (pat.op) {\n      case ID_PAT:\n        this.values[slot++] = argValue;\n        return true;\n\n      case AS_PAT:\n        final Core.AsPat asPat = (Core.AsPat) pat;\n        final int oldSlot = slot++;\n        if (bindRecurse(asPat.pat, argValue)) {\n          this.values[oldSlot] = argValue;\n          return true;\n        } else {\n          return false;\n        }\n\n      case WILDCARD_PAT:\n        return true;\n\n      case BOOL_LITERAL_PAT:\n      case CHAR_LITERAL_PAT:\n      case STRING_LITERAL_PAT:\n        literalPat = (Core.LiteralPat) pat;\n        return literalPat.value.equals(argValue);\n\n      case INT_LITERAL_PAT:\n        literalPat = (Core.LiteralPat) pat;\n        return ((BigDecimal) literalPat.value).intValue() == (Integer) argValue;\n\n      case REAL_LITERAL_PAT:\n        literalPat = (Core.LiteralPat) pat;\n        return ((BigDecimal) literalPat.value).doubleValue() == (Double) argValue;\n\n      case TUPLE_PAT:\n        final Core.TuplePat tuplePat = (Core.TuplePat) pat;\n        listValue = (List) argValue;\n        return allMatch(tuplePat.args, listValue, this::bindRecurse);\n\n      case RECORD_PAT:\n        final Core.RecordPat recordPat = (Core.RecordPat) pat;\n        listValue = (List) argValue;\n        for (Pair<Core.Pat, Object> pair\n            : zip(recordPat.args, listValue)) {\n          if (!bindRecurse(pair.left, pair.right)) {\n            return false;\n          }\n        }\n        return true;\n\n      case LIST_PAT:\n        final Core.ListPat listPat = (Core.ListPat) pat;\n        listValue = (List) argValue;\n        if (listValue.size() != listPat.args.size()) {\n          return false;\n        }\n        for (Pair<Core.Pat, Object> pair : zip(listPat.args, listValue)) {\n          if (!bindRecurse(pair.left, pair.right)) {\n            return false;\n          }\n        }\n        return true;\n\n      case CONS_PAT:\n        final Core.ConPat infixPat = (Core.ConPat) pat;\n        @SuppressWarnings(\"unchecked\") final List<Object> consValue =\n            (List) argValue;\n        if (consValue.isEmpty()) {\n          return false;\n        }\n        final Object head = consValue.get(0);\n        final List<Object> tail = skip(consValue);\n        List<Core.Pat> patArgs = ((Core.TuplePat) infixPat.pat).args;\n        return bindRecurse(patArgs.get(0), head)\n            && bindRecurse(patArgs.get(1), tail);\n\n      case CON0_PAT:\n        final Core.Con0Pat con0Pat = (Core.Con0Pat) pat;\n        final List con0Value = (List) argValue;\n        return con0Value.get(0).equals(con0Pat.tyCon);\n\n      case CON_PAT:\n        final Core.ConPat conPat = (Core.ConPat) pat;\n        final List conValue = (List) argValue;\n        return conValue.get(0).equals(conPat.tyCon)\n            && bindRecurse(conPat.pat, conValue.get(1));\n\n      default:\n        throw new AssertionError(\"cannot compile \" + pat.op + \": \" + pat);\n      }\n    }\n  }", "definition": "  static class MutablePatSubEvalEnv extends PatSubEvalEnv\n      implements MutableEvalEnv", "class_docstring": " Evaluation environment that binds several slots based on a pattern.", "name": "MutablePatSubEvalEnv", "super_interfaces": ["MutableEvalEnv"], "superclasses": "PatSubEvalEnv", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "fields": [{"attribute_expression": "private int slot;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "int", "name": "slot", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    MutablePatSubEvalEnv(EvalEnv parentEnv, Core.Pat pat, List<String> names) {\n      super(parentEnv, pat, ImmutableList.copyOf(names),\n          new Object[names.size()]);\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "MutablePatSubEvalEnv", "params": [{"name": "parentEnv", "type": "EvalEnv"}, {"name": "pat", "type": "Core.Pat"}, {"name": "names", "type": "List<String>"}], "body": "                                                                              {\n      super(parentEnv, pat, ImmutableList.copyOf(names),\n          new Object[names.size()]);\n    }", "signature": "MutablePatSubEvalEnv(EvalEnv parentEnv, Core.Pat pat, List<String> names)"}, {"syntax_pass": true, "original_string": "    @Override public EvalEnv fix() {\n      return new PatSubEvalEnv(parentEnv, pat, names, values.clone());\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "EvalEnv", "classes": []}, "name": "fix", "params": [], "body": "                                   {\n      return new PatSubEvalEnv(parentEnv, pat, names, values.clone());\n    }", "signature": "@Override public EvalEnv fix()"}, {"syntax_pass": true, "original_string": "    @Override public void set(Object value) {\n      if (!setOpt(value)) {\n        // If this error happens, perhaps your code should be calling \"setOpt\"\n        // and handling a false result appropriately.\n        throw new AssertionError(\"bind failed\");\n      }\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "set", "params": [{"name": "value", "type": "Object"}], "body": "                                            {\n      if (!setOpt(value)) {\n        // If this error happens, perhaps your code should be calling \"setOpt\"\n        // and handling a false result appropriately.\n        throw new AssertionError(\"bind failed\");\n      }\n    }", "signature": "@Override public void set(Object value)"}, {"syntax_pass": true, "original_string": "    @Override public boolean setOpt(Object value) {\n      slot = 0;\n      return bindRecurse(pat, value);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "setOpt", "params": [{"name": "value", "type": "Object"}], "body": "                                                  {\n      slot = 0;\n      return bindRecurse(pat, value);\n    }", "signature": "@Override public boolean setOpt(Object value)"}, {"syntax_pass": true, "original_string": "    boolean bindRecurse(Core.Pat pat, Object argValue) {\n      final List<Object> listValue;\n      final Core.LiteralPat literalPat;\n      switch (pat.op) {\n      case ID_PAT:\n        this.values[slot++] = argValue;\n        return true;\n\n      case AS_PAT:\n        final Core.AsPat asPat = (Core.AsPat) pat;\n        final int oldSlot = slot++;\n        if (bindRecurse(asPat.pat, argValue)) {\n          this.values[oldSlot] = argValue;\n          return true;\n        } else {\n          return false;\n        }\n\n      case WILDCARD_PAT:\n        return true;\n\n      case BOOL_LITERAL_PAT:\n      case CHAR_LITERAL_PAT:\n      case STRING_LITERAL_PAT:\n        literalPat = (Core.LiteralPat) pat;\n        return literalPat.value.equals(argValue);\n\n      case INT_LITERAL_PAT:\n        literalPat = (Core.LiteralPat) pat;\n        return ((BigDecimal) literalPat.value).intValue() == (Integer) argValue;\n\n      case REAL_LITERAL_PAT:\n        literalPat = (Core.LiteralPat) pat;\n        return ((BigDecimal) literalPat.value).doubleValue() == (Double) argValue;\n\n      case TUPLE_PAT:\n        final Core.TuplePat tuplePat = (Core.TuplePat) pat;\n        listValue = (List) argValue;\n        return allMatch(tuplePat.args, listValue, this::bindRecurse);\n\n      case RECORD_PAT:\n        final Core.RecordPat recordPat = (Core.RecordPat) pat;\n        listValue = (List) argValue;\n        for (Pair<Core.Pat, Object> pair\n            : zip(recordPat.args, listValue)) {\n          if (!bindRecurse(pair.left, pair.right)) {\n            return false;\n          }\n        }\n        return true;\n\n      case LIST_PAT:\n        final Core.ListPat listPat = (Core.ListPat) pat;\n        listValue = (List) argValue;\n        if (listValue.size() != listPat.args.size()) {\n          return false;\n        }\n        for (Pair<Core.Pat, Object> pair : zip(listPat.args, listValue)) {\n          if (!bindRecurse(pair.left, pair.right)) {\n            return false;\n          }\n        }\n        return true;\n\n      case CONS_PAT:\n        final Core.ConPat infixPat = (Core.ConPat) pat;\n        @SuppressWarnings(\"unchecked\") final List<Object> consValue =\n            (List) argValue;\n        if (consValue.isEmpty()) {\n          return false;\n        }\n        final Object head = consValue.get(0);\n        final List<Object> tail = skip(consValue);\n        List<Core.Pat> patArgs = ((Core.TuplePat) infixPat.pat).args;\n        return bindRecurse(patArgs.get(0), head)\n            && bindRecurse(patArgs.get(1), tail);\n\n      case CON0_PAT:\n        final Core.Con0Pat con0Pat = (Core.Con0Pat) pat;\n        final List con0Value = (List) argValue;\n        return con0Value.get(0).equals(con0Pat.tyCon);\n\n      case CON_PAT:\n        final Core.ConPat conPat = (Core.ConPat) pat;\n        final List conValue = (List) argValue;\n        return conValue.get(0).equals(conPat.tyCon)\n            && bindRecurse(conPat.pat, conValue.get(1));\n\n      default:\n        throw new AssertionError(\"cannot compile \" + pat.op + \": \" + pat);\n      }\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "boolean", "classes": []}, "name": "bindRecurse", "params": [{"name": "pat", "type": "Core.Pat"}, {"name": "argValue", "type": "Object"}], "body": "                                                       {\n      final List<Object> listValue;\n      final Core.LiteralPat literalPat;\n      switch (pat.op) {\n      case ID_PAT:\n        this.values[slot++] = argValue;\n        return true;\n\n      case AS_PAT:\n        final Core.AsPat asPat = (Core.AsPat) pat;\n        final int oldSlot = slot++;\n        if (bindRecurse(asPat.pat, argValue)) {\n          this.values[oldSlot] = argValue;\n          return true;\n        } else {\n          return false;\n        }\n\n      case WILDCARD_PAT:\n        return true;\n\n      case BOOL_LITERAL_PAT:\n      case CHAR_LITERAL_PAT:\n      case STRING_LITERAL_PAT:\n        literalPat = (Core.LiteralPat) pat;\n        return literalPat.value.equals(argValue);\n\n      case INT_LITERAL_PAT:\n        literalPat = (Core.LiteralPat) pat;\n        return ((BigDecimal) literalPat.value).intValue() == (Integer) argValue;\n\n      case REAL_LITERAL_PAT:\n        literalPat = (Core.LiteralPat) pat;\n        return ((BigDecimal) literalPat.value).doubleValue() == (Double) argValue;\n\n      case TUPLE_PAT:\n        final Core.TuplePat tuplePat = (Core.TuplePat) pat;\n        listValue = (List) argValue;\n        return allMatch(tuplePat.args, listValue, this::bindRecurse);\n\n      case RECORD_PAT:\n        final Core.RecordPat recordPat = (Core.RecordPat) pat;\n        listValue = (List) argValue;\n        for (Pair<Core.Pat, Object> pair\n            : zip(recordPat.args, listValue)) {\n          if (!bindRecurse(pair.left, pair.right)) {\n            return false;\n          }\n        }\n        return true;\n\n      case LIST_PAT:\n        final Core.ListPat listPat = (Core.ListPat) pat;\n        listValue = (List) argValue;\n        if (listValue.size() != listPat.args.size()) {\n          return false;\n        }\n        for (Pair<Core.Pat, Object> pair : zip(listPat.args, listValue)) {\n          if (!bindRecurse(pair.left, pair.right)) {\n            return false;\n          }\n        }\n        return true;\n\n      case CONS_PAT:\n        final Core.ConPat infixPat = (Core.ConPat) pat;\n        @SuppressWarnings(\"unchecked\") final List<Object> consValue =\n            (List) argValue;\n        if (consValue.isEmpty()) {\n          return false;\n        }\n        final Object head = consValue.get(0);\n        final List<Object> tail = skip(consValue);\n        List<Core.Pat> patArgs = ((Core.TuplePat) infixPat.pat).args;\n        return bindRecurse(patArgs.get(0), head)\n            && bindRecurse(patArgs.get(1), tail);\n\n      case CON0_PAT:\n        final Core.Con0Pat con0Pat = (Core.Con0Pat) pat;\n        final List con0Value = (List) argValue;\n        return con0Value.get(0).equals(con0Pat.tyCon);\n\n      case CON_PAT:\n        final Core.ConPat conPat = (Core.ConPat) pat;\n        final List conValue = (List) argValue;\n        return conValue.get(0).equals(conPat.tyCon)\n            && bindRecurse(conPat.pat, conValue.get(1));\n\n      default:\n        throw new AssertionError(\"cannot compile \" + pat.op + \": \" + pat);\n      }\n    }", "signature": "boolean bindRecurse(Core.Pat pat, Object argValue)"}]}, {"original_string": "  static class MapEvalEnv implements EvalEnv {\n    final Map<String, Object> valueMap;\n\n    MapEvalEnv(Map<String, Object> valueMap) {\n      this.valueMap = ImmutableMap.copyOf(valueMap);\n    }\n\n    public Object getOpt(String name) {\n      return valueMap.get(name);\n    }\n\n    public void visit(BiConsumer<String, Object> consumer) {\n      valueMap.forEach(consumer);\n    }\n  }", "definition": "  static class MapEvalEnv implements EvalEnv", "class_docstring": " Evaluation environment that reads from a map.", "name": "MapEvalEnv", "super_interfaces": ["EvalEnv"], "superclasses": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "fields": [{"attribute_expression": "final Map<String, Object> valueMap;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "Map<String, Object>", "name": "valueMap", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    MapEvalEnv(Map<String, Object> valueMap) {\n      this.valueMap = ImmutableMap.copyOf(valueMap);\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "MapEvalEnv", "params": [{"name": "valueMap", "type": "Map<String, Object>"}], "body": "                                             {\n      this.valueMap = ImmutableMap.copyOf(valueMap);\n    }", "signature": "MapEvalEnv(Map<String, Object> valueMap)"}, {"syntax_pass": true, "original_string": "    public Object getOpt(String name) {\n      return valueMap.get(name);\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Object", "classes": []}, "name": "getOpt", "params": [{"name": "name", "type": "String"}], "body": "                                      {\n      return valueMap.get(name);\n    }", "signature": "public Object getOpt(String name)"}, {"syntax_pass": true, "original_string": "    public void visit(BiConsumer<String, Object> consumer) {\n      valueMap.forEach(consumer);\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "visit", "params": [{"name": "consumer", "type": "BiConsumer<String, Object>"}], "body": "                                                           {\n      valueMap.forEach(consumer);\n    }", "signature": "public void visit(BiConsumer<String, Object> consumer)"}]}], "class_docstring": " Helpers for {@link EvalEnv}.", "original_string": "public class EvalEnvs {\n  /** Creates an evaluation environment with the given (name, value) map. */\n  public static EvalEnv copyOf(Map<String, Object> valueMap) {\n    return new MapEvalEnv(valueMap);\n  }\n\n  private EvalEnvs() {}\n\n  /** Evaluation environment that inherits from a parent environment and adds\n   * one binding. */\n  static class SubEvalEnv implements EvalEnv {\n    protected final EvalEnv parentEnv;\n    protected final String name;\n    protected Object value;\n\n    SubEvalEnv(EvalEnv parentEnv, String name, Object value) {\n      this.parentEnv = parentEnv;\n      this.name = name;\n      this.value = value;\n    }\n\n    public void visit(BiConsumer<String, Object> consumer) {\n      consumer.accept(name, value);\n      parentEnv.visit(consumer);\n    }\n\n    public Object getOpt(String name) {\n      for (SubEvalEnv e = this;;) {\n        if (name.equals(e.name)) {\n          return e.value;\n        }\n        if (e.parentEnv instanceof SubEvalEnv) {\n          e = (SubEvalEnv) e.parentEnv;\n        } else {\n          return e.parentEnv.getOpt(name);\n        }\n      }\n    }\n  }\n\n  /** Similar to {@link SubEvalEnv} but mutable. */\n  static class MutableSubEvalEnv extends SubEvalEnv implements MutableEvalEnv {\n    MutableSubEvalEnv(EvalEnv parentEnv, String name) {\n      super(parentEnv, name, null);\n    }\n\n    public void set(Object value) {\n      this.value = value;\n    }\n\n    @Override public EvalEnv fix() {\n      return new SubEvalEnv(parentEnv, name, value);\n    }\n  }\n\n  /** Similar to {@link MutableEvalEnv} but binds several names. */\n  static class ArraySubEvalEnv implements EvalEnv {\n    protected final EvalEnv parentEnv;\n    protected final ImmutableList<String> names;\n    protected Object[] values;\n\n    ArraySubEvalEnv(EvalEnv parentEnv, ImmutableList<String> names,\n        @Nullable Object[] values) {\n      this.parentEnv = requireNonNull(parentEnv);\n      this.names = requireNonNull(names);\n      this.values = values; // may be null\n    }\n\n    public void visit(BiConsumer<String, Object> consumer) {\n      for (int i = 0; i < names.size(); i++) {\n        consumer.accept(names.get(i), values[i]);\n      }\n      parentEnv.visit(consumer);\n    }\n\n    public Object getOpt(String name) {\n      final int i = names.indexOf(name);\n      if (i >= 0) {\n        return values[i];\n      }\n      return parentEnv.getOpt(name);\n    }\n  }\n\n  /** Similar to {@link MutableEvalEnv} but binds several names;\n   * extends {@link ArraySubEvalEnv} adding mutability. */\n  static class MutableArraySubEvalEnv extends ArraySubEvalEnv\n      implements MutableEvalEnv {\n    MutableArraySubEvalEnv(EvalEnv parentEnv, List<String> names) {\n      super(parentEnv, ImmutableList.copyOf(names), null);\n    }\n\n    public void set(Object value) {\n      values = (Object[]) value;\n      assert values.length == names.size();\n    }\n\n    @Override public ArraySubEvalEnv fix() {\n      return new ArraySubEvalEnv(parentEnv, names, values.clone());\n    }\n  }\n\n  /** Immutable copy of {@link MutablePatSubEvalEnv}. */\n  static class PatSubEvalEnv extends ArraySubEvalEnv {\n    protected final Core.Pat pat;\n\n    PatSubEvalEnv(EvalEnv parentEnv, Core.Pat pat, ImmutableList<String> names,\n        Object[] values) {\n      super(parentEnv, ImmutableList.copyOf(names), values);\n      this.pat = requireNonNull(pat);\n      assert !(pat instanceof Core.IdPat);\n    }\n  }\n\n  /** Evaluation environment that binds several slots based on a pattern. */\n  static class MutablePatSubEvalEnv extends PatSubEvalEnv\n      implements MutableEvalEnv {\n    private int slot;\n\n    MutablePatSubEvalEnv(EvalEnv parentEnv, Core.Pat pat, List<String> names) {\n      super(parentEnv, pat, ImmutableList.copyOf(names),\n          new Object[names.size()]);\n    }\n\n    @Override public EvalEnv fix() {\n      return new PatSubEvalEnv(parentEnv, pat, names, values.clone());\n    }\n\n    @Override public void set(Object value) {\n      if (!setOpt(value)) {\n        // If this error happens, perhaps your code should be calling \"setOpt\"\n        // and handling a false result appropriately.\n        throw new AssertionError(\"bind failed\");\n      }\n    }\n\n    @Override public boolean setOpt(Object value) {\n      slot = 0;\n      return bindRecurse(pat, value);\n    }\n\n    boolean bindRecurse(Core.Pat pat, Object argValue) {\n      final List<Object> listValue;\n      final Core.LiteralPat literalPat;\n      switch (pat.op) {\n      case ID_PAT:\n        this.values[slot++] = argValue;\n        return true;\n\n      case AS_PAT:\n        final Core.AsPat asPat = (Core.AsPat) pat;\n        final int oldSlot = slot++;\n        if (bindRecurse(asPat.pat, argValue)) {\n          this.values[oldSlot] = argValue;\n          return true;\n        } else {\n          return false;\n        }\n\n      case WILDCARD_PAT:\n        return true;\n\n      case BOOL_LITERAL_PAT:\n      case CHAR_LITERAL_PAT:\n      case STRING_LITERAL_PAT:\n        literalPat = (Core.LiteralPat) pat;\n        return literalPat.value.equals(argValue);\n\n      case INT_LITERAL_PAT:\n        literalPat = (Core.LiteralPat) pat;\n        return ((BigDecimal) literalPat.value).intValue() == (Integer) argValue;\n\n      case REAL_LITERAL_PAT:\n        literalPat = (Core.LiteralPat) pat;\n        return ((BigDecimal) literalPat.value).doubleValue() == (Double) argValue;\n\n      case TUPLE_PAT:\n        final Core.TuplePat tuplePat = (Core.TuplePat) pat;\n        listValue = (List) argValue;\n        return allMatch(tuplePat.args, listValue, this::bindRecurse);\n\n      case RECORD_PAT:\n        final Core.RecordPat recordPat = (Core.RecordPat) pat;\n        listValue = (List) argValue;\n        for (Pair<Core.Pat, Object> pair\n            : zip(recordPat.args, listValue)) {\n          if (!bindRecurse(pair.left, pair.right)) {\n            return false;\n          }\n        }\n        return true;\n\n      case LIST_PAT:\n        final Core.ListPat listPat = (Core.ListPat) pat;\n        listValue = (List) argValue;\n        if (listValue.size() != listPat.args.size()) {\n          return false;\n        }\n        for (Pair<Core.Pat, Object> pair : zip(listPat.args, listValue)) {\n          if (!bindRecurse(pair.left, pair.right)) {\n            return false;\n          }\n        }\n        return true;\n\n      case CONS_PAT:\n        final Core.ConPat infixPat = (Core.ConPat) pat;\n        @SuppressWarnings(\"unchecked\") final List<Object> consValue =\n            (List) argValue;\n        if (consValue.isEmpty()) {\n          return false;\n        }\n        final Object head = consValue.get(0);\n        final List<Object> tail = skip(consValue);\n        List<Core.Pat> patArgs = ((Core.TuplePat) infixPat.pat).args;\n        return bindRecurse(patArgs.get(0), head)\n            && bindRecurse(patArgs.get(1), tail);\n\n      case CON0_PAT:\n        final Core.Con0Pat con0Pat = (Core.Con0Pat) pat;\n        final List con0Value = (List) argValue;\n        return con0Value.get(0).equals(con0Pat.tyCon);\n\n      case CON_PAT:\n        final Core.ConPat conPat = (Core.ConPat) pat;\n        final List conValue = (List) argValue;\n        return conValue.get(0).equals(conPat.tyCon)\n            && bindRecurse(conPat.pat, conValue.get(1));\n\n      default:\n        throw new AssertionError(\"cannot compile \" + pat.op + \": \" + pat);\n      }\n    }\n  }\n\n  /** Evaluation environment that reads from a map. */\n  static class MapEvalEnv implements EvalEnv {\n    final Map<String, Object> valueMap;\n\n    MapEvalEnv(Map<String, Object> valueMap) {\n      this.valueMap = ImmutableMap.copyOf(valueMap);\n    }\n\n    public Object getOpt(String name) {\n      return valueMap.get(name);\n    }\n\n    public void visit(BiConsumer<String, Object> consumer) {\n      valueMap.forEach(consumer);\n    }\n  }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/main/java/net/hydromatic/morel/eval/Files.java.Files", "name": "Files", "file_path": "src/main/java/net/hydromatic/morel/eval/Files.java", "superclasses": "", "methods": ["[]Files()", "[File]create(java.io.File)", "[UnknownFile]createUnknown(Directory,java.io.File)", "[String]removeSuffix(String,String)", "[PairList<String, Type.Key>]deduceFieldsCsv(BufferedReader)", "[Function<String, Object>]parser(Type.Key)", "[Object]unquoteString(String)"], "method_uris": ["src/main/java/net/hydromatic/morel/eval/Files.java.Files.[]Files()", "src/main/java/net/hydromatic/morel/eval/Files.java.Files.[File]create(java.io.File)", "src/main/java/net/hydromatic/morel/eval/Files.java.Files.[UnknownFile]createUnknown(Directory,java.io.File)", "src/main/java/net/hydromatic/morel/eval/Files.java.Files.[String]removeSuffix(String,String)", "src/main/java/net/hydromatic/morel/eval/Files.java.Files.[PairList<String, Type.Key>]deduceFieldsCsv(BufferedReader)", "src/main/java/net/hydromatic/morel/eval/Files.java.Files.[Function<String, Object>]parser(Type.Key)", "src/main/java/net/hydromatic/morel/eval/Files.java.Files.[Object]unquoteString(String)"], "overrides": null, "attributes": [{"original_string": "  abstract static class AbstractFile implements File {\n    final java.io.File ioFile;\n    final String baseName;\n    final FileType fileType;\n\n    /** Creates an AbstractFile. */\n    AbstractFile(java.io.File ioFile, FileType fileType) {\n      this.ioFile = requireNonNull(ioFile, \"file\");\n      this.baseName = removeSuffix(ioFile.getName(), fileType.suffix);\n      this.fileType = requireNonNull(fileType, \"fileType\");\n    }\n\n    @Override public String toString() {\n      return baseName;\n    }\n  }", "definition": "  abstract static class AbstractFile implements File", "class_docstring": " Abstract implementation of File.", "name": "AbstractFile", "super_interfaces": ["File"], "superclasses": "", "attributes": {"modifiers": "abstract static", "marker_annotations": [], "non_marker_annotations": ["abstract", "static"], "comments": [], "fields": [{"attribute_expression": "final java.io.File ioFile;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "java.io.File", "name": "ioFile", "syntax_pass": true}, {"attribute_expression": "final String baseName;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "String", "name": "baseName", "syntax_pass": true}, {"attribute_expression": "final FileType fileType;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "FileType", "name": "fileType", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    AbstractFile(java.io.File ioFile, FileType fileType) {\n      this.ioFile = requireNonNull(ioFile, \"file\");\n      this.baseName = removeSuffix(ioFile.getName(), fileType.suffix);\n      this.fileType = requireNonNull(fileType, \"fileType\");\n    }", "docstring": " Creates an AbstractFile.", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "AbstractFile", "params": [{"name": "ioFile", "type": "java.io.File"}, {"name": "fileType", "type": "FileType"}], "body": "                                                         {\n      this.ioFile = requireNonNull(ioFile, \"file\");\n      this.baseName = removeSuffix(ioFile.getName(), fileType.suffix);\n      this.fileType = requireNonNull(fileType, \"fileType\");\n    }", "signature": "AbstractFile(java.io.File ioFile, FileType fileType)"}, {"syntax_pass": true, "original_string": "    @Override public String toString() {\n      return baseName;\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "toString", "params": [], "body": "                                       {\n      return baseName;\n    }", "signature": "@Override public String toString()"}]}, {"original_string": "  private static class Directory extends AbstractList<File> implements File {\n    final java.io.File ioFile;\n    final SortedMap<String, File> entries; // mutable\n\n    Directory(java.io.File file) {\n      this.ioFile = file;\n\n      entries = new TreeMap<>(RecordType.ORDERING);\n      for (java.io.File subFile\n          : Util.first(ioFile.listFiles(), new java.io.File[0])) {\n        UnknownFile f = createUnknown(this, subFile);\n        entries.put(f.baseName, f);\n      }\n    }\n\n    @Override public Type.Key typeKey() {\n      return Keys.progressiveRecord(\n          Maps.transformValues(entries, TypedValue::typeKey));\n    }\n\n    @Override public File discoverField(TypeSystem typeSystem,\n        String fieldName) {\n      final File file = entries.get(fieldName);\n      if (file != null) {\n        File file2 = file.expand();\n        if (file2 != file) {\n          typeSystem.expandCount.incrementAndGet();\n        }\n      }\n      return this;\n    }\n\n    @Override public File get(int index) {\n      return Iterables.get(entries.values(), index);\n    }\n\n    @Override public int size() {\n      return entries.size();\n    }\n\n    @Override public <V> V valueAs(Class<V> clazz) {\n      if (clazz.isInstance(this)) {\n        return clazz.cast(this);\n      }\n      throw new IllegalArgumentException(\"not a \" + clazz);\n    }\n\n    @Override public <V> V fieldValueAs(String fieldName, Class<V> clazz) {\n      return clazz.cast(entries.get(fieldName));\n    }\n\n    @Override public <V> V fieldValueAs(int fieldIndex, Class<V> clazz) {\n      return clazz.cast(Iterables.get(entries.values(), fieldIndex));\n    }\n  }", "definition": "  private static class Directory extends AbstractList<File> implements File", "class_docstring": " File that is a directory.", "name": "Directory", "super_interfaces": ["File"], "superclasses": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "fields": [{"attribute_expression": "final java.io.File ioFile;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "java.io.File", "name": "ioFile", "syntax_pass": true}, {"attribute_expression": "final SortedMap<String, File> entries;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "SortedMap<String, File>", "name": "entries", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    Directory(java.io.File file) {\n      this.ioFile = file;\n\n      entries = new TreeMap<>(RecordType.ORDERING);\n      for (java.io.File subFile\n          : Util.first(ioFile.listFiles(), new java.io.File[0])) {\n        UnknownFile f = createUnknown(this, subFile);\n        entries.put(f.baseName, f);\n      }\n    }", "docstring": " mutable", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "Directory", "params": [{"name": "file", "type": "java.io.File"}], "body": "                                 {\n      this.ioFile = file;\n\n      entries = new TreeMap<>(RecordType.ORDERING);\n      for (java.io.File subFile\n          : Util.first(ioFile.listFiles(), new java.io.File[0])) {\n        UnknownFile f = createUnknown(this, subFile);\n        entries.put(f.baseName, f);\n      }\n    }", "signature": "Directory(java.io.File file)"}, {"syntax_pass": true, "original_string": "    @Override public Type.Key typeKey() {\n      return Keys.progressiveRecord(\n          Maps.transformValues(entries, TypedValue::typeKey));\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Type.Key", "classes": []}, "name": "typeKey", "params": [], "body": "                                        {\n      return Keys.progressiveRecord(\n          Maps.transformValues(entries, TypedValue::typeKey));\n    }", "signature": "@Override public Type.Key typeKey()"}, {"syntax_pass": true, "original_string": "    @Override public File discoverField(TypeSystem typeSystem,\n        String fieldName) {\n      final File file = entries.get(fieldName);\n      if (file != null) {\n        File file2 = file.expand();\n        if (file2 != file) {\n          typeSystem.expandCount.incrementAndGet();\n        }\n      }\n      return this;\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "File", "classes": []}, "name": "discoverField", "params": [{"name": "typeSystem", "type": "TypeSystem"}, {"name": "fieldName", "type": "String"}], "body": "                          {\n      final File file = entries.get(fieldName);\n      if (file != null) {\n        File file2 = file.expand();\n        if (file2 != file) {\n          typeSystem.expandCount.incrementAndGet();\n        }\n      }\n      return this;\n    }", "signature": "@Override public File discoverField(TypeSystem typeSystem,\n        String fieldName)"}, {"syntax_pass": true, "original_string": "    @Override public File get(int index) {\n      return Iterables.get(entries.values(), index);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "File", "classes": []}, "name": "get", "params": [{"name": "index", "type": "int"}], "body": "                                         {\n      return Iterables.get(entries.values(), index);\n    }", "signature": "@Override public File get(int index)"}, {"syntax_pass": true, "original_string": "    @Override public int size() {\n      return entries.size();\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "size", "params": [], "body": "                                {\n      return entries.size();\n    }", "signature": "@Override public int size()"}, {"syntax_pass": true, "original_string": "    @Override public <V> V valueAs(Class<V> clazz) {\n      if (clazz.isInstance(this)) {\n        return clazz.cast(this);\n      }\n      throw new IllegalArgumentException(\"not a \" + clazz);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "V", "classes": []}, "name": "valueAs", "params": [{"name": "clazz", "type": "Class<V>"}], "body": "                                                   {\n      if (clazz.isInstance(this)) {\n        return clazz.cast(this);\n      }\n      throw new IllegalArgumentException(\"not a \" + clazz);\n    }", "signature": "@Override public <V> V valueAs(Class<V> clazz)"}, {"syntax_pass": true, "original_string": "    @Override public <V> V fieldValueAs(String fieldName, Class<V> clazz) {\n      return clazz.cast(entries.get(fieldName));\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "V", "classes": []}, "name": "fieldValueAs", "params": [{"name": "fieldName", "type": "String"}, {"name": "clazz", "type": "Class<V>"}], "body": "                                                                          {\n      return clazz.cast(entries.get(fieldName));\n    }", "signature": "@Override public <V> V fieldValueAs(String fieldName, Class<V> clazz)"}, {"syntax_pass": true, "original_string": "    @Override public <V> V fieldValueAs(int fieldIndex, Class<V> clazz) {\n      return clazz.cast(Iterables.get(entries.values(), fieldIndex));\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "V", "classes": []}, "name": "fieldValueAs", "params": [{"name": "fieldIndex", "type": "int"}, {"name": "clazz", "type": "Class<V>"}], "body": "                                                                        {\n      return clazz.cast(Iterables.get(entries.values(), fieldIndex));\n    }", "signature": "@Override public <V> V fieldValueAs(int fieldIndex, Class<V> clazz)"}]}, {"original_string": "  private static class DataFile extends AbstractFile {\n    final Type.Key typeKey;\n    final PairList<Integer, Function<String, Object>> parsers;\n\n    DataFile(java.io.File file, FileType fileType, Type.Key typeKey,\n        PairList<Integer, Function<String, Object>> parsers) {\n      super(file, fileType);\n      this.typeKey = requireNonNull(typeKey, \"typeKey\");\n      this.parsers = parsers.immutable();\n    }\n\n    @Override public <V> V valueAs(Class<V> clazz) {\n      try (BufferedReader r = fileType.open(ioFile)) {\n        String firstLine = r.readLine();\n        if (firstLine == null) {\n          return null;\n        }\n        final Object[] values = new Object[parsers.size()];\n        final List<List<Object>> list = new ArrayList<>();\n        for (;;) {\n          String line = r.readLine();\n          if (line == null) {\n            return clazz.cast(list);\n          }\n          String[] fields = line.split(\",\");\n          parsers.forEachIndexed((i, j, parser) ->\n              values[j] = parser.apply(fields[i]));\n          list.add(ImmutableList.copyOf(values));\n        }\n      } catch (IOException e) {\n        // ignore\n        return null;\n      }\n    }\n\n    @Override public Type.Key typeKey() {\n      return typeKey;\n    }\n  }", "definition": "  private static class DataFile extends AbstractFile", "class_docstring": " File that is not a directory, and can be parsed into a set of records.", "name": "DataFile", "super_interfaces": [], "superclasses": "AbstractFile", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "fields": [{"attribute_expression": "final Type.Key typeKey;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "Type.Key", "name": "typeKey", "syntax_pass": true}, {"attribute_expression": "final PairList<Integer, Function<String, Object>> parsers;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "PairList<Integer, Function<String, Object>>", "name": "parsers", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    DataFile(java.io.File file, FileType fileType, Type.Key typeKey,\n        PairList<Integer, Function<String, Object>> parsers) {\n      super(file, fileType);\n      this.typeKey = requireNonNull(typeKey, \"typeKey\");\n      this.parsers = parsers.immutable();\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "DataFile", "params": [{"name": "file", "type": "java.io.File"}, {"name": "fileType", "type": "FileType"}, {"name": "typeKey", "type": "Type.Key"}, {"name": "parsers", "type": "PairList<Integer, Function<String, Object>>"}], "body": "                                                             {\n      super(file, fileType);\n      this.typeKey = requireNonNull(typeKey, \"typeKey\");\n      this.parsers = parsers.immutable();\n    }", "signature": "DataFile(java.io.File file, FileType fileType, Type.Key typeKey,\n        PairList<Integer, Function<String, Object>> parsers)"}, {"syntax_pass": true, "original_string": "    @Override public <V> V valueAs(Class<V> clazz) {\n      try (BufferedReader r = fileType.open(ioFile)) {\n        String firstLine = r.readLine();\n        if (firstLine == null) {\n          return null;\n        }\n        final Object[] values = new Object[parsers.size()];\n        final List<List<Object>> list = new ArrayList<>();\n        for (;;) {\n          String line = r.readLine();\n          if (line == null) {\n            return clazz.cast(list);\n          }\n          String[] fields = line.split(\",\");\n          parsers.forEachIndexed((i, j, parser) ->\n              values[j] = parser.apply(fields[i]));\n          list.add(ImmutableList.copyOf(values));\n        }\n      } catch (IOException e) {\n        // ignore\n        return null;\n      }\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "V", "classes": []}, "name": "valueAs", "params": [{"name": "clazz", "type": "Class<V>"}], "body": "                                                   {\n      try (BufferedReader r = fileType.open(ioFile)) {\n        String firstLine = r.readLine();\n        if (firstLine == null) {\n          return null;\n        }\n        final Object[] values = new Object[parsers.size()];\n        final List<List<Object>> list = new ArrayList<>();\n        for (;;) {\n          String line = r.readLine();\n          if (line == null) {\n            return clazz.cast(list);\n          }\n          String[] fields = line.split(\",\");\n          parsers.forEachIndexed((i, j, parser) ->\n              values[j] = parser.apply(fields[i]));\n          list.add(ImmutableList.copyOf(values));\n        }\n      } catch (IOException e) {\n        // ignore\n        return null;\n      }\n    }", "signature": "@Override public <V> V valueAs(Class<V> clazz)"}, {"syntax_pass": true, "original_string": "    @Override public Type.Key typeKey() {\n      return typeKey;\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Type.Key", "classes": []}, "name": "typeKey", "params": [], "body": "                                        {\n      return typeKey;\n    }", "signature": "@Override public Type.Key typeKey()"}]}, {"original_string": "  private static class UnknownFile extends AbstractFile {\n    /** Key for the type \"{...}\", the progressive record with no\n     * (as yet known) fields. */\n    static final Type.Key PROGRESSIVE_UNIT =\n        Keys.progressiveRecord(ImmutableSortedMap.of());\n\n    /** Key for the type \"{...} list\", the list of progressive records with no\n     * (as yet known) fields. */\n    static final Type.Key PROGRESSIVE_UNIT_LIST =\n        Keys.list(PROGRESSIVE_UNIT);\n\n    protected UnknownFile(java.io.File file, FileType fileType) {\n      super(file, fileType);\n    }\n\n    @Override public <V> V valueAs(Class<V> clazz) {\n      if (clazz.isAssignableFrom(ImmutableList.class)) {\n        return clazz.cast(ImmutableList.of());\n      }\n      throw new IllegalArgumentException(\"not a \" + clazz);\n    }\n\n    @Override public Type.Key typeKey() {\n      return fileType.list ? PROGRESSIVE_UNIT_LIST : PROGRESSIVE_UNIT;\n    }\n\n    @Override public File expand() {\n      switch (fileType) {\n      case DIRECTORY:\n        return new Directory(ioFile);\n\n      case FILE:\n        return this;\n\n      default:\n        try (BufferedReader r = fileType.open(ioFile)) {\n          final PairList<String, Type.Key> nameTypes = fileType.deduceFields(r);\n          final ImmutableSortedMap<String, Type.Key> sortedNameTypes =\n              ImmutableSortedMap.<String, Type.Key>orderedBy(RecordType.ORDERING)\n                  .putAll(nameTypes)\n                  .build();\n          final PairList<Integer, Function<String, Object>> fieldParsers =\n              PairList.of();\n          nameTypes.forEach((name, typeKey) -> {\n            final int j = sortedNameTypes.keySet().asList().indexOf(name);\n            fieldParsers.add(j, parser(typeKey));\n          });\n\n          final Type.Key listType = Keys.list(Keys.record(sortedNameTypes));\n          return new DataFile(ioFile, fileType, listType, fieldParsers);\n        } catch (IOException e) {\n          // ignore, and skip file\n          return this;\n        }\n      }\n    }\n\n    @Override public File discoverField(TypeSystem typeSystem,\n        String fieldName) {\n      final File file = expand();\n      if (file == this) {\n        return this;\n      }\n      typeSystem.expandCount.incrementAndGet();\n      return file.discoverField(typeSystem, fieldName);\n    }\n  }", "definition": "  private static class UnknownFile extends AbstractFile", "class_docstring": " File that we have not yet categorized. We don't know whether it is a\ndirectory.\n\n<p>Its type is an empty record type (because we don't know the files in the\ndirectory, or the fields of the data file).", "name": "UnknownFile", "super_interfaces": [], "superclasses": "AbstractFile", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "fields": [{"attribute_expression": "static final Type.Key PROGRESSIVE_UNIT =\n        Keys.progressiveRecord(ImmutableSortedMap.of());", "docstring": " Key for the type \"{...}\", the progressive record with no\n(as yet known) fields.", "modifiers": "static final", "marker_annotations": [], "non_marker_annotations": ["static", "final"], "comments": [], "type": "Type.Key", "name": "PROGRESSIVE_UNIT =\n        Keys.progressiveRecord(ImmutableSortedMap.of())", "syntax_pass": true}, {"attribute_expression": "static final Type.Key PROGRESSIVE_UNIT_LIST =\n        Keys.list(PROGRESSIVE_UNIT);", "docstring": " Key for the type \"{...} list\", the list of progressive records with no\n(as yet known) fields.", "modifiers": "static final", "marker_annotations": [], "non_marker_annotations": ["static", "final"], "comments": [], "type": "Type.Key", "name": "PROGRESSIVE_UNIT_LIST =\n        Keys.list(PROGRESSIVE_UNIT)", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    protected UnknownFile(java.io.File file, FileType fileType) {\n      super(file, fileType);\n    }", "docstring": "", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "", "classes": []}, "name": "UnknownFile", "params": [{"name": "file", "type": "java.io.File"}, {"name": "fileType", "type": "FileType"}], "body": "                                                                {\n      super(file, fileType);\n    }", "signature": "protected UnknownFile(java.io.File file, FileType fileType)"}, {"syntax_pass": true, "original_string": "    @Override public <V> V valueAs(Class<V> clazz) {\n      if (clazz.isAssignableFrom(ImmutableList.class)) {\n        return clazz.cast(ImmutableList.of());\n      }\n      throw new IllegalArgumentException(\"not a \" + clazz);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "V", "classes": []}, "name": "valueAs", "params": [{"name": "clazz", "type": "Class<V>"}], "body": "                                                   {\n      if (clazz.isAssignableFrom(ImmutableList.class)) {\n        return clazz.cast(ImmutableList.of());\n      }\n      throw new IllegalArgumentException(\"not a \" + clazz);\n    }", "signature": "@Override public <V> V valueAs(Class<V> clazz)"}, {"syntax_pass": true, "original_string": "    @Override public Type.Key typeKey() {\n      return fileType.list ? PROGRESSIVE_UNIT_LIST : PROGRESSIVE_UNIT;\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Type.Key", "classes": []}, "name": "typeKey", "params": [], "body": "                                        {\n      return fileType.list ? PROGRESSIVE_UNIT_LIST : PROGRESSIVE_UNIT;\n    }", "signature": "@Override public Type.Key typeKey()"}, {"syntax_pass": true, "original_string": "    @Override public File expand() {\n      switch (fileType) {\n      case DIRECTORY:\n        return new Directory(ioFile);\n\n      case FILE:\n        return this;\n\n      default:\n        try (BufferedReader r = fileType.open(ioFile)) {\n          final PairList<String, Type.Key> nameTypes = fileType.deduceFields(r);\n          final ImmutableSortedMap<String, Type.Key> sortedNameTypes =\n              ImmutableSortedMap.<String, Type.Key>orderedBy(RecordType.ORDERING)\n                  .putAll(nameTypes)\n                  .build();\n          final PairList<Integer, Function<String, Object>> fieldParsers =\n              PairList.of();\n          nameTypes.forEach((name, typeKey) -> {\n            final int j = sortedNameTypes.keySet().asList().indexOf(name);\n            fieldParsers.add(j, parser(typeKey));\n          });\n\n          final Type.Key listType = Keys.list(Keys.record(sortedNameTypes));\n          return new DataFile(ioFile, fileType, listType, fieldParsers);\n        } catch (IOException e) {\n          // ignore, and skip file\n          return this;\n        }\n      }\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "File", "classes": []}, "name": "expand", "params": [], "body": "                                   {\n      switch (fileType) {\n      case DIRECTORY:\n        return new Directory(ioFile);\n\n      case FILE:\n        return this;\n\n      default:\n        try (BufferedReader r = fileType.open(ioFile)) {\n          final PairList<String, Type.Key> nameTypes = fileType.deduceFields(r);\n          final ImmutableSortedMap<String, Type.Key> sortedNameTypes =\n              ImmutableSortedMap.<String, Type.Key>orderedBy(RecordType.ORDERING)\n                  .putAll(nameTypes)\n                  .build();\n          final PairList<Integer, Function<String, Object>> fieldParsers =\n              PairList.of();\n          nameTypes.forEach((name, typeKey) -> {\n            final int j = sortedNameTypes.keySet().asList().indexOf(name);\n            fieldParsers.add(j, parser(typeKey));\n          });\n\n          final Type.Key listType = Keys.list(Keys.record(sortedNameTypes));\n          return new DataFile(ioFile, fileType, listType, fieldParsers);\n        } catch (IOException e) {\n          // ignore, and skip file\n          return this;\n        }\n      }\n    }", "signature": "@Override public File expand()"}, {"syntax_pass": true, "original_string": "    @Override public File discoverField(TypeSystem typeSystem,\n        String fieldName) {\n      final File file = expand();\n      if (file == this) {\n        return this;\n      }\n      typeSystem.expandCount.incrementAndGet();\n      return file.discoverField(typeSystem, fieldName);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "File", "classes": []}, "name": "discoverField", "params": [{"name": "typeSystem", "type": "TypeSystem"}, {"name": "fieldName", "type": "String"}], "body": "                          {\n      final File file = expand();\n      if (file == this) {\n        return this;\n      }\n      typeSystem.expandCount.incrementAndGet();\n      return file.discoverField(typeSystem, fieldName);\n    }", "signature": "@Override public File discoverField(TypeSystem typeSystem,\n        String fieldName)"}]}, {"original_string": "  private static class UnknownChildFile extends UnknownFile {\n    private final Directory directory;\n\n    protected UnknownChildFile(Directory directory, java.io.File file,\n        FileType fileType) {\n      super(file, fileType);\n      this.directory = requireNonNull(directory, \"directory\");\n    }\n\n    @Override public File expand() {\n      final File file = super.expand();\n      if (file != this) {\n        directory.entries.put(baseName, file);\n      }\n      return file;\n    }\n  }", "definition": "  private static class UnknownChildFile extends UnknownFile", "class_docstring": "", "name": "UnknownChildFile", "super_interfaces": [], "superclasses": "UnknownFile", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "fields": [{"attribute_expression": "private final Directory directory;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Directory", "name": "directory", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    protected UnknownChildFile(Directory directory, java.io.File file,\n        FileType fileType) {\n      super(file, fileType);\n      this.directory = requireNonNull(directory, \"directory\");\n    }", "docstring": "", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "", "classes": []}, "name": "UnknownChildFile", "params": [{"name": "directory", "type": "Directory"}, {"name": "file", "type": "java.io.File"}, {"name": "fileType", "type": "FileType"}], "body": "                           {\n      super(file, fileType);\n      this.directory = requireNonNull(directory, \"directory\");\n    }", "signature": "protected UnknownChildFile(Directory directory, java.io.File file,\n        FileType fileType)"}, {"syntax_pass": true, "original_string": "    @Override public File expand() {\n      final File file = super.expand();\n      if (file != this) {\n        directory.entries.put(baseName, file);\n      }\n      return file;\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "File", "classes": []}, "name": "expand", "params": [], "body": "                                   {\n      final File file = super.expand();\n      if (file != this) {\n        directory.entries.put(baseName, file);\n      }\n      return file;\n    }", "signature": "@Override public File expand()"}]}], "class_docstring": " Implementations of {@link File}.", "original_string": "public class Files {\n  private Files() {\n  }\n\n  /** Creates a file (or directory).\n   * Never returns null. */\n  public static File create(java.io.File ioFile) {\n    return createUnknown(null, ioFile).expand();\n  }\n\n  static UnknownFile createUnknown(@Nullable Directory directory,\n      java.io.File ioFile) {\n    FileType fileType;\n    if (ioFile.isDirectory()) {\n      fileType = FileType.DIRECTORY;\n    } else {\n      fileType = FileType.FILE;\n      for (FileType fileType2 : FileType.INSTANCES) {\n        if (ioFile.getName().endsWith(fileType2.suffix)) {\n          fileType = fileType2;\n          break;\n        }\n      }\n    }\n    if (directory != null) {\n      return new UnknownChildFile(directory, ioFile, fileType);\n    } else {\n      return new UnknownFile(ioFile, fileType);\n    }\n  }\n\n  /** Returns a string without its suffix; for example,\n   * {@code removeSuffix(\"x.txt\", \".txt\")} returns {@code \"x\"}. */\n  private static String removeSuffix(String s, String suffix) {\n    if (!s.endsWith(suffix)) {\n      return s;\n    }\n    return s.substring(0, s.length() - suffix.length());\n  }\n\n  private static PairList<String, Type.Key> deduceFieldsCsv(BufferedReader r)\n      throws IOException {\n    String firstLine = r.readLine();\n    if (firstLine == null) {\n      // File is empty. There will be no fields, and row type will be unit.\n      return ImmutablePairList.of();\n    }\n\n    final PairList<String, Type.Key> nameTypes = PairList.of();\n    for (String field : firstLine.split(\",\")) {\n      final String[] split = field.split(\":\");\n      final String subFieldName = split[0];\n      final String subFieldType =\n          split.length > 1 ? split[1] : \"string\";\n      Type.Key subType;\n      switch (subFieldType) {\n      case \"bool\":\n        subType = PrimitiveType.BOOL.key();\n        break;\n      case \"decimal\":\n      case \"double\":\n        subType = PrimitiveType.REAL.key();\n        break;\n      case \"int\":\n        subType = PrimitiveType.INT.key();\n        break;\n      default:\n        subType = PrimitiveType.STRING.key();\n        break;\n      }\n      nameTypes.add(subFieldName, subType);\n    }\n    return nameTypes;\n  }\n\n  /** Creates a function that converts a string field value to the desired\n   * type. */\n  static Function<String, Object> parser(Type.Key type) {\n    switch (type.op) {\n    case DATA_TYPE:\n      switch (type.toString()) {\n      case \"int\":\n        return s -> s.equals(\"NULL\") ? 0 : Integer.parseInt(s);\n      case \"real\":\n        return s -> s.equals(\"NULL\") ? 0f : Float.parseFloat(s);\n      case \"string\":\n        return Files::unquoteString;\n      default:\n        throw new IllegalArgumentException(\"unknown type \" + type);\n      }\n    default:\n      throw new IllegalArgumentException(\"unknown type \" + type);\n    }\n  }\n\n  /** Converts \"abc\" to \"abc\" and \"'abc, def'\" to \"abc, def\". */\n  static Object unquoteString(String s) {\n    if (s.startsWith(\"'\")) {\n      return s.substring(1, s.length() - 1);\n    }\n    return s;\n  }\n\n  /** Abstract implementation of File. */\n  abstract static class AbstractFile implements File {\n    final java.io.File ioFile;\n    final String baseName;\n    final FileType fileType;\n\n    /** Creates an AbstractFile. */\n    AbstractFile(java.io.File ioFile, FileType fileType) {\n      this.ioFile = requireNonNull(ioFile, \"file\");\n      this.baseName = removeSuffix(ioFile.getName(), fileType.suffix);\n      this.fileType = requireNonNull(fileType, \"fileType\");\n    }\n\n    @Override public String toString() {\n      return baseName;\n    }\n  }\n\n  /** File that is a directory. */\n  private static class Directory extends AbstractList<File> implements File {\n    final java.io.File ioFile;\n    final SortedMap<String, File> entries; // mutable\n\n    Directory(java.io.File file) {\n      this.ioFile = file;\n\n      entries = new TreeMap<>(RecordType.ORDERING);\n      for (java.io.File subFile\n          : Util.first(ioFile.listFiles(), new java.io.File[0])) {\n        UnknownFile f = createUnknown(this, subFile);\n        entries.put(f.baseName, f);\n      }\n    }\n\n    @Override public Type.Key typeKey() {\n      return Keys.progressiveRecord(\n          Maps.transformValues(entries, TypedValue::typeKey));\n    }\n\n    @Override public File discoverField(TypeSystem typeSystem,\n        String fieldName) {\n      final File file = entries.get(fieldName);\n      if (file != null) {\n        File file2 = file.expand();\n        if (file2 != file) {\n          typeSystem.expandCount.incrementAndGet();\n        }\n      }\n      return this;\n    }\n\n    @Override public File get(int index) {\n      return Iterables.get(entries.values(), index);\n    }\n\n    @Override public int size() {\n      return entries.size();\n    }\n\n    @Override public <V> V valueAs(Class<V> clazz) {\n      if (clazz.isInstance(this)) {\n        return clazz.cast(this);\n      }\n      throw new IllegalArgumentException(\"not a \" + clazz);\n    }\n\n    @Override public <V> V fieldValueAs(String fieldName, Class<V> clazz) {\n      return clazz.cast(entries.get(fieldName));\n    }\n\n    @Override public <V> V fieldValueAs(int fieldIndex, Class<V> clazz) {\n      return clazz.cast(Iterables.get(entries.values(), fieldIndex));\n    }\n  }\n\n  /** File that is not a directory, and can be parsed into a set of records. */\n  private static class DataFile extends AbstractFile {\n    final Type.Key typeKey;\n    final PairList<Integer, Function<String, Object>> parsers;\n\n    DataFile(java.io.File file, FileType fileType, Type.Key typeKey,\n        PairList<Integer, Function<String, Object>> parsers) {\n      super(file, fileType);\n      this.typeKey = requireNonNull(typeKey, \"typeKey\");\n      this.parsers = parsers.immutable();\n    }\n\n    @Override public <V> V valueAs(Class<V> clazz) {\n      try (BufferedReader r = fileType.open(ioFile)) {\n        String firstLine = r.readLine();\n        if (firstLine == null) {\n          return null;\n        }\n        final Object[] values = new Object[parsers.size()];\n        final List<List<Object>> list = new ArrayList<>();\n        for (;;) {\n          String line = r.readLine();\n          if (line == null) {\n            return clazz.cast(list);\n          }\n          String[] fields = line.split(\",\");\n          parsers.forEachIndexed((i, j, parser) ->\n              values[j] = parser.apply(fields[i]));\n          list.add(ImmutableList.copyOf(values));\n        }\n      } catch (IOException e) {\n        // ignore\n        return null;\n      }\n    }\n\n    @Override public Type.Key typeKey() {\n      return typeKey;\n    }\n  }\n\n  /** File that we have not yet categorized. We don't know whether it is a\n   * directory.\n   *\n   * <p>Its type is an empty record type (because we don't know the files in the\n   * directory, or the fields of the data file). */\n  private static class UnknownFile extends AbstractFile {\n    /** Key for the type \"{...}\", the progressive record with no\n     * (as yet known) fields. */\n    static final Type.Key PROGRESSIVE_UNIT =\n        Keys.progressiveRecord(ImmutableSortedMap.of());\n\n    /** Key for the type \"{...} list\", the list of progressive records with no\n     * (as yet known) fields. */\n    static final Type.Key PROGRESSIVE_UNIT_LIST =\n        Keys.list(PROGRESSIVE_UNIT);\n\n    protected UnknownFile(java.io.File file, FileType fileType) {\n      super(file, fileType);\n    }\n\n    @Override public <V> V valueAs(Class<V> clazz) {\n      if (clazz.isAssignableFrom(ImmutableList.class)) {\n        return clazz.cast(ImmutableList.of());\n      }\n      throw new IllegalArgumentException(\"not a \" + clazz);\n    }\n\n    @Override public Type.Key typeKey() {\n      return fileType.list ? PROGRESSIVE_UNIT_LIST : PROGRESSIVE_UNIT;\n    }\n\n    @Override public File expand() {\n      switch (fileType) {\n      case DIRECTORY:\n        return new Directory(ioFile);\n\n      case FILE:\n        return this;\n\n      default:\n        try (BufferedReader r = fileType.open(ioFile)) {\n          final PairList<String, Type.Key> nameTypes = fileType.deduceFields(r);\n          final ImmutableSortedMap<String, Type.Key> sortedNameTypes =\n              ImmutableSortedMap.<String, Type.Key>orderedBy(RecordType.ORDERING)\n                  .putAll(nameTypes)\n                  .build();\n          final PairList<Integer, Function<String, Object>> fieldParsers =\n              PairList.of();\n          nameTypes.forEach((name, typeKey) -> {\n            final int j = sortedNameTypes.keySet().asList().indexOf(name);\n            fieldParsers.add(j, parser(typeKey));\n          });\n\n          final Type.Key listType = Keys.list(Keys.record(sortedNameTypes));\n          return new DataFile(ioFile, fileType, listType, fieldParsers);\n        } catch (IOException e) {\n          // ignore, and skip file\n          return this;\n        }\n      }\n    }\n\n    @Override public File discoverField(TypeSystem typeSystem,\n        String fieldName) {\n      final File file = expand();\n      if (file == this) {\n        return this;\n      }\n      typeSystem.expandCount.incrementAndGet();\n      return file.discoverField(typeSystem, fieldName);\n    }\n  }\n\n  private static class UnknownChildFile extends UnknownFile {\n    private final Directory directory;\n\n    protected UnknownChildFile(Directory directory, java.io.File file,\n        FileType fileType) {\n      super(file, fileType);\n      this.directory = requireNonNull(directory, \"directory\");\n    }\n\n    @Override public File expand() {\n      final File file = super.expand();\n      if (file != this) {\n        directory.entries.put(baseName, file);\n      }\n      return file;\n    }\n  }\n\n  /** Describes a type of file that can be read by this reader.\n   * Each file has a way to deduce the schema (set of field names and types)\n   * and to parse the file into a set of records. */\n  enum FileType {\n    DIRECTORY(\"\", false),\n    FILE(\"\", false),\n    CSV(\".csv\", true),\n    CSV_GZ(\".csv.gz\", true);\n\n    /** The non-trivial file types. */\n    static final List<FileType> INSTANCES =\n        Arrays.stream(values())\n            .filter(f -> !f.suffix.isEmpty())\n            .collect(ImmutableList.toImmutableList());\n\n    final String suffix;\n\n    /** Whether this file is a list of records. */\n    final boolean list;\n\n    FileType(String suffix, boolean list) {\n      this.suffix = suffix;\n      this.list = list;\n    }\n\n    BufferedReader open(java.io.File file) throws IOException {\n      switch (this) {\n      case CSV:\n        return Util.reader(file);\n      case CSV_GZ:\n        return Util.reader(new GZIPInputStream(newInputStream(file.toPath())));\n      default:\n        throw new IllegalArgumentException(\"cannot open file \" + file\n            + \" of type \" + this);\n      }\n    }\n\n    PairList<String, Type.Key> deduceFields(BufferedReader r)\n        throws IOException {\n      return deduceFieldsCsv(r);\n    }\n  }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/main/java/net/hydromatic/morel/compile/Relationalizer.java.Relationalizer", "name": "Relationalizer", "file_path": "src/main/java/net/hydromatic/morel/compile/Relationalizer.java", "superclasses": "EnvShuttle", "methods": ["[]Relationalizer(TypeSystem,Environment)", "[Relationalizer]of(TypeSystem,Environment)", "[Relationalizer]push(Environment)", "[Core.Exp]visit(Core.Apply)", "[Core.From]toFrom(Core.Exp)", "[Core.Exp]visit(Core.From)"], "method_uris": ["src/main/java/net/hydromatic/morel/compile/Relationalizer.java.Relationalizer.[]Relationalizer(TypeSystem,Environment)", "src/main/java/net/hydromatic/morel/compile/Relationalizer.java.Relationalizer.[Relationalizer]of(TypeSystem,Environment)", "src/main/java/net/hydromatic/morel/compile/Relationalizer.java.Relationalizer.[Relationalizer]push(Environment)", "src/main/java/net/hydromatic/morel/compile/Relationalizer.java.Relationalizer.[Core.Exp]visit(Core.Apply)", "src/main/java/net/hydromatic/morel/compile/Relationalizer.java.Relationalizer.[Core.From]toFrom(Core.Exp)", "src/main/java/net/hydromatic/morel/compile/Relationalizer.java.Relationalizer.[Core.Exp]visit(Core.From)"], "overrides": null, "attributes": [], "class_docstring": "\nShuttle that converts calls to {@link BuiltIn#LIST_FILTER}\nand {@link BuiltIn#LIST_MAP} into {@link Core.From} expressions.\n", "original_string": "public class Relationalizer extends EnvShuttle {\n  /** Private constructor. */\n  private Relationalizer(TypeSystem typeSystem, Environment env) {\n    super(typeSystem, env);\n  }\n\n  /** Creates a Relationalizer. */\n  public static Relationalizer of(TypeSystem typeSystem, Environment env) {\n    return new Relationalizer(typeSystem, env);\n  }\n\n  @Override protected Relationalizer push(Environment env) {\n    return new Relationalizer(typeSystem, env);\n  }\n\n  @Override protected Core.Exp visit(Core.Apply apply) {\n    switch (apply.fn.op) {\n    case APPLY:\n      final Core.Apply apply2 = (Core.Apply) apply.fn;\n      switch (apply2.fn.op) {\n      case FN_LITERAL:\n        final Core.Literal literal = (Core.Literal) apply2.fn;\n        if (literal.value == BuiltIn.LIST_MAP) {\n          // List.map f list\n          //  =>\n          // from e in list yield (f e)\n          final Core.Exp f = apply2.arg;\n          final FnType fnType = (FnType) f.type;\n          final Core.From from = toFrom(apply.arg);\n          // TODO: if the last step is a non-record yield, there is no\n          // \"defaultYieldExp\", and therefore we cannot add another yield\n          // step. We will have to inline the yield expression as a let.\n          final Core.Yield yieldStep = core.yield_(typeSystem,\n              core.apply(apply.pos, fnType.resultType, f,\n                  core.implicitYieldExp(typeSystem, from.steps)));\n          return core.from(typeSystem, append(from.steps, yieldStep));\n        }\n        if (literal.value == BuiltIn.LIST_FILTER) {\n          // List.filter f list\n          //  =>\n          // from e in list where (f e)\n          final Core.Exp f = apply2.arg;\n          final FnType fnType = (FnType) f.type;\n          final Core.From from = toFrom(apply.arg);\n          final Core.Where whereStep =\n              core.where(core.lastBindings(from.steps),\n                  core.apply(apply.pos, fnType.resultType, f,\n                      core.implicitYieldExp(typeSystem, from.steps)));\n          return core.from(typeSystem, append(from.steps, whereStep));\n        }\n      }\n    }\n    return super.visit(apply);\n  }\n\n  private Core.From toFrom(Core.Exp exp) {\n    if (exp instanceof Core.From) {\n      return (Core.From) exp;\n    } else {\n      final ListType listType = (ListType) exp.type;\n      final String name = typeSystem.nameGenerator.get();\n      final Core.IdPat id =\n          core.idPat(listType.elementType, name, typeSystem.nameGenerator);\n      final List<Binding> bindings = new ArrayList<>();\n      Compiles.acceptBinding(typeSystem, id, bindings);\n      final Core.Scan scan =\n          core.scan(bindings, id, exp, core.boolLiteral(true));\n      return core.from(typeSystem, ImmutableList.of(scan));\n    }\n  }\n\n  @Override protected Core.Exp visit(Core.From from) {\n    final Core.From from2 = (Core.From) super.visit(from);\n    if (!from2.steps.isEmpty()) {\n      final Core.FromStep step = from2.steps.get(0);\n      if (step instanceof Core.Scan\n          && ((Core.Scan) step).exp.op == Op.FROM\n          && ((Core.Scan) step).pat.op == Op.ID_PAT) {\n        final Core.From from3 = (Core.From) ((Core.Scan) step).exp;\n        final Core.IdPat idPat3 = (Core.IdPat) ((Core.Scan) step).pat;\n        final List<Core.FromStep> steps = new ArrayList<>(from3.steps);\n        final Core.Exp exp;\n        if (steps.isEmpty()) {\n          exp = core.unitLiteral();\n        } else if (getLast(steps) instanceof Core.Yield) {\n          exp = ((Core.Yield) steps.remove(steps.size() - 1)).exp;\n        } else {\n          exp = core.implicitYieldExp(typeSystem, from3.steps);\n        }\n        RecordLikeType recordType =\n            typeSystem.recordType(RecordType.map(idPat3.name, exp.type));\n        steps.add(\n            core.yield_(step.bindings, core.tuple(recordType, exp)));\n        steps.addAll(skip(from2.steps));\n        return core.from(typeSystem, steps);\n      }\n    }\n    return from2;\n  }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/main/java/net/hydromatic/morel/compile/NameGenerator.java.NameGenerator", "name": "NameGenerator", "file_path": "src/main/java/net/hydromatic/morel/compile/NameGenerator.java", "superclasses": "", "methods": ["[String]get()", "[int]inc(String)"], "method_uris": ["src/main/java/net/hydromatic/morel/compile/NameGenerator.java.NameGenerator.[String]get()", "src/main/java/net/hydromatic/morel/compile/NameGenerator.java.NameGenerator.[int]inc(String)"], "overrides": null, "attributes": [], "class_docstring": "\nGenerates unique names.\n\n<p>Also keeps track of how many times each given name has been used in this\nprogram, so that a new occurrence of a name can be given a fresh ordinal.\n", "original_string": "public class NameGenerator {\n  private int id = 0;\n  private final Map<String, AtomicInteger> nameCounts = new HashMap<>();\n\n  /** Generates a name that is unique in this program. */\n  public String get() {\n    return \"v\" + id++;\n  }\n\n  /** Returns the number of times that \"name\" has been used for a variable. */\n  public int inc(String name) {\n    return nameCounts.computeIfAbsent(name, n -> new AtomicInteger(0))\n        .getAndIncrement();\n  }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private int id = 0;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "int", "name": "id = 0", "syntax_pass": true}, {"attribute_expression": "private final Map<String, AtomicInteger> nameCounts = new HashMap<>();", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Map<String, AtomicInteger>", "name": "nameCounts = new HashMap<>()", "syntax_pass": true}]}, {"uris": "src/main/java/net/hydromatic/morel/compile/CalciteCompiler.java.CalciteCompiler", "name": "CalciteCompiler", "file_path": "src/main/java/net/hydromatic/morel/compile/CalciteCompiler.java", "superclasses": "Compiler", "methods": ["[]CalciteCompiler(TypeSystem,Calcite)", "[RelNode]toRel(Environment,Core.Exp)", "[RelNode]toRel2(RelContext,Core.Exp)", "[boolean]toRel3(RelContext,Core.Exp,boolean)", "[Code]toRel4(Environment,Code,Type)", "[CalciteFunctions.Context]createContext(Environment)", "[Code]compileArg(Context,Core.Exp)", "[Code]finishCompileLet(Context,List<Code>,Code,Type)", "[RelCode]compileApply(Context,Core.Apply)", "[Type]removeTypeVars(Type)", "[Code]finishCompileApply(Context,Code,Code,Type)", "[Code]finishCompileApply(Context,Applicable,Code,Type)", "[void]harmonizeRowTypes(RelBuilder,int)", "[Code]compileFrom(Context,Core.From)", "[RelContext]yield_(RelContext,Core.Yield)", "[RelContext]yield_(RelContext,List<Binding>,Core.Exp)", "[RexNode]translate(RelContext,Core.Exp)", "[RexNode]maybeNot(RelContext,RexNode,boolean)", "[Set<String>]getRelationalVariables(Environment,Set<String>,AstNode)", "[RexNode]morelScalar(RelContext,Core.Exp)", "[RexNode]morelApply(RelContext,Type,Type,RexNode,RexNode)", "[Core.Tuple]toRecord(RelContext,Core.Id)", "[List<RexNode>]translateList(RelContext,List<Core.Exp>)", "[RelContext]join(RelContext,int,Core.Scan)", "[JoinRelType]joinRelType(Op)", "[RelContext]where(RelContext,Core.Where)", "[RelContext]skip(RelContext,Core.Skip)", "[RelContext]take(RelContext,Core.Take)", "[RelContext]order(RelContext,Core.Order)", "[RelContext]group(RelContext,Core.Group)", "[RelContext]getRelContext(RelContext,Environment,List<String>)", "[SqlAggFunction]aggOp(Core.Exp)", "[EvalEnv]evalEnvOf(Environment)"], "method_uris": ["src/main/java/net/hydromatic/morel/compile/CalciteCompiler.java.CalciteCompiler.[]CalciteCompiler(TypeSystem,Calcite)", "src/main/java/net/hydromatic/morel/compile/CalciteCompiler.java.CalciteCompiler.[RelNode]toRel(Environment,Core.Exp)", "src/main/java/net/hydromatic/morel/compile/CalciteCompiler.java.CalciteCompiler.[RelNode]toRel2(RelContext,Core.Exp)", "src/main/java/net/hydromatic/morel/compile/CalciteCompiler.java.CalciteCompiler.[boolean]toRel3(RelContext,Core.Exp,boolean)", "src/main/java/net/hydromatic/morel/compile/CalciteCompiler.java.CalciteCompiler.[Code]toRel4(Environment,Code,Type)", "src/main/java/net/hydromatic/morel/compile/CalciteCompiler.java.CalciteCompiler.[CalciteFunctions.Context]createContext(Environment)", "src/main/java/net/hydromatic/morel/compile/CalciteCompiler.java.CalciteCompiler.[Code]compileArg(Context,Core.Exp)", "src/main/java/net/hydromatic/morel/compile/CalciteCompiler.java.CalciteCompiler.[Code]finishCompileLet(Context,List<Code>,Code,Type)", "src/main/java/net/hydromatic/morel/compile/CalciteCompiler.java.CalciteCompiler.[RelCode]compileApply(Context,Core.Apply)", "src/main/java/net/hydromatic/morel/compile/CalciteCompiler.java.CalciteCompiler.[Type]removeTypeVars(Type)", "src/main/java/net/hydromatic/morel/compile/CalciteCompiler.java.CalciteCompiler.[Code]finishCompileApply(Context,Code,Code,Type)", "src/main/java/net/hydromatic/morel/compile/CalciteCompiler.java.CalciteCompiler.[Code]finishCompileApply(Context,Applicable,Code,Type)", "src/main/java/net/hydromatic/morel/compile/CalciteCompiler.java.CalciteCompiler.[void]harmonizeRowTypes(RelBuilder,int)", "src/main/java/net/hydromatic/morel/compile/CalciteCompiler.java.CalciteCompiler.[Code]compileFrom(Context,Core.From)", "src/main/java/net/hydromatic/morel/compile/CalciteCompiler.java.CalciteCompiler.[RelContext]yield_(RelContext,Core.Yield)", "src/main/java/net/hydromatic/morel/compile/CalciteCompiler.java.CalciteCompiler.[RelContext]yield_(RelContext,List<Binding>,Core.Exp)", "src/main/java/net/hydromatic/morel/compile/CalciteCompiler.java.CalciteCompiler.[RexNode]translate(RelContext,Core.Exp)", "src/main/java/net/hydromatic/morel/compile/CalciteCompiler.java.CalciteCompiler.[RexNode]maybeNot(RelContext,RexNode,boolean)", "src/main/java/net/hydromatic/morel/compile/CalciteCompiler.java.CalciteCompiler.[Set<String>]getRelationalVariables(Environment,Set<String>,AstNode)", "src/main/java/net/hydromatic/morel/compile/CalciteCompiler.java.CalciteCompiler.[RexNode]morelScalar(RelContext,Core.Exp)", "src/main/java/net/hydromatic/morel/compile/CalciteCompiler.java.CalciteCompiler.[RexNode]morelApply(RelContext,Type,Type,RexNode,RexNode)", "src/main/java/net/hydromatic/morel/compile/CalciteCompiler.java.CalciteCompiler.[Core.Tuple]toRecord(RelContext,Core.Id)", "src/main/java/net/hydromatic/morel/compile/CalciteCompiler.java.CalciteCompiler.[List<RexNode>]translateList(RelContext,List<Core.Exp>)", "src/main/java/net/hydromatic/morel/compile/CalciteCompiler.java.CalciteCompiler.[RelContext]join(RelContext,int,Core.Scan)", "src/main/java/net/hydromatic/morel/compile/CalciteCompiler.java.CalciteCompiler.[JoinRelType]joinRelType(Op)", "src/main/java/net/hydromatic/morel/compile/CalciteCompiler.java.CalciteCompiler.[RelContext]where(RelContext,Core.Where)", "src/main/java/net/hydromatic/morel/compile/CalciteCompiler.java.CalciteCompiler.[RelContext]skip(RelContext,Core.Skip)", "src/main/java/net/hydromatic/morel/compile/CalciteCompiler.java.CalciteCompiler.[RelContext]take(RelContext,Core.Take)", "src/main/java/net/hydromatic/morel/compile/CalciteCompiler.java.CalciteCompiler.[RelContext]order(RelContext,Core.Order)", "src/main/java/net/hydromatic/morel/compile/CalciteCompiler.java.CalciteCompiler.[RelContext]group(RelContext,Core.Group)", "src/main/java/net/hydromatic/morel/compile/CalciteCompiler.java.CalciteCompiler.[RelContext]getRelContext(RelContext,Environment,List<String>)", "src/main/java/net/hydromatic/morel/compile/CalciteCompiler.java.CalciteCompiler.[SqlAggFunction]aggOp(Core.Exp)", "src/main/java/net/hydromatic/morel/compile/CalciteCompiler.java.CalciteCompiler.[EvalEnv]evalEnvOf(Environment)"], "overrides": null, "attributes": [{"original_string": "  static class RelContext extends Context {\n    final @Nullable RelContext parent;\n    final RelBuilder relBuilder;\n    final ImmutableSortedMap<String, VarData> map;\n    final int inputCount;\n    final List<CorrelationId> varList = new ArrayList<>();\n    private final RelNode top;\n\n    RelContext(Environment env, RelContext parent, RelBuilder relBuilder,\n        ImmutableSortedMap<String, VarData> map, int inputCount) {\n      super(env);\n      this.parent = parent;\n      this.relBuilder = relBuilder;\n      this.map = map;\n      this.inputCount = inputCount;\n      this.top = top(relBuilder);\n    }\n\n    private static @Nullable RelNode top(RelBuilder relBuilder) {\n      return relBuilder.size() == 0 ? null\n          : relBuilder.peek();\n    }\n\n    @Override RelContext bindAll(Iterable<Binding> bindings) {\n      final Environment env2 = env.bindAll(bindings);\n      return env2 == env ? this\n          : new RelContext(env2, this, relBuilder, map, inputCount);\n    }\n\n    /** Creates a correlation variable with which to reference the current row\n     * of a relation in an enclosing loop. */\n    public @Nullable RexNode var(String name) {\n      final VarData fn = map.get(name);\n      if (fn != null) {\n        return fn.apply(relBuilder);\n      }\n      for (RelContext p = parent; p != null; p = p.parent) {\n        if (p.map.containsKey(name)) {\n          final RelOptCluster cluster = p.top.getCluster();\n          final RexCorrelVariable correlVariable = (RexCorrelVariable)\n              cluster.getRexBuilder().makeCorrel(p.top.getRowType(),\n                  cluster.createCorrel());\n          p.varList.add(correlVariable.id);\n          return correlVariable;\n        }\n      }\n      return null; // TODO: throw; make this non-nullable\n    }\n  }", "definition": "  static class RelContext extends Context", "class_docstring": " Translation context.", "name": "RelContext", "super_interfaces": [], "superclasses": "Context", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "fields": [{"attribute_expression": "final @Nullable RelContext parent;", "docstring": "", "modifiers": "final @Nullable", "marker_annotations": ["@Nullable"], "non_marker_annotations": ["final"], "comments": [], "type": "RelContext", "name": "parent", "syntax_pass": true}, {"attribute_expression": "final RelBuilder relBuilder;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "RelBuilder", "name": "relBuilder", "syntax_pass": true}, {"attribute_expression": "final ImmutableSortedMap<String, VarData> map;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "ImmutableSortedMap<String, VarData>", "name": "map", "syntax_pass": true}, {"attribute_expression": "final int inputCount;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "int", "name": "inputCount", "syntax_pass": true}, {"attribute_expression": "final List<CorrelationId> varList = new ArrayList<>();", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "List<CorrelationId>", "name": "varList = new ArrayList<>()", "syntax_pass": true}, {"attribute_expression": "private final RelNode top;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "RelNode", "name": "top", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    RelContext(Environment env, RelContext parent, RelBuilder relBuilder,\n        ImmutableSortedMap<String, VarData> map, int inputCount) {\n      super(env);\n      this.parent = parent;\n      this.relBuilder = relBuilder;\n      this.map = map;\n      this.inputCount = inputCount;\n      this.top = top(relBuilder);\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "RelContext", "params": [{"name": "env", "type": "Environment"}, {"name": "parent", "type": "RelContext"}, {"name": "relBuilder", "type": "RelBuilder"}, {"name": "map", "type": "ImmutableSortedMap<String, VarData>"}, {"name": "inputCount", "type": "int"}], "body": "                                                                 {\n      super(env);\n      this.parent = parent;\n      this.relBuilder = relBuilder;\n      this.map = map;\n      this.inputCount = inputCount;\n      this.top = top(relBuilder);\n    }", "signature": "RelContext(Environment env, RelContext parent, RelBuilder relBuilder,\n        ImmutableSortedMap<String, VarData> map, int inputCount)"}, {"syntax_pass": true, "original_string": "    private static @Nullable RelNode top(RelBuilder relBuilder) {\n      return relBuilder.size() == 0 ? null\n          : relBuilder.peek();\n    }", "docstring": "", "attributes": {"modifiers": "private static @Nullable", "marker_annotations": ["@Nullable"], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "RelNode", "classes": []}, "name": "top", "params": [{"name": "relBuilder", "type": "RelBuilder"}], "body": "                                                                {\n      return relBuilder.size() == 0 ? null\n          : relBuilder.peek();\n    }", "signature": "private static @Nullable RelNode top(RelBuilder relBuilder)"}, {"syntax_pass": true, "original_string": "    @Override RelContext bindAll(Iterable<Binding> bindings) {\n      final Environment env2 = env.bindAll(bindings);\n      return env2 == env ? this\n          : new RelContext(env2, this, relBuilder, map, inputCount);\n    }", "docstring": "", "attributes": {"modifiers": "@Override", "marker_annotations": ["@Override"], "non_marker_annotations": [], "comments": [], "return_type": "RelContext", "classes": []}, "name": "bindAll", "params": [{"name": "bindings", "type": "Iterable<Binding>"}], "body": "                                                             {\n      final Environment env2 = env.bindAll(bindings);\n      return env2 == env ? this\n          : new RelContext(env2, this, relBuilder, map, inputCount);\n    }", "signature": "@Override RelContext bindAll(Iterable<Binding> bindings)"}, {"syntax_pass": true, "original_string": "    public @Nullable RexNode var(String name) {\n      final VarData fn = map.get(name);\n      if (fn != null) {\n        return fn.apply(relBuilder);\n      }\n      for (RelContext p = parent; p != null; p = p.parent) {\n        if (p.map.containsKey(name)) {\n          final RelOptCluster cluster = p.top.getCluster();\n          final RexCorrelVariable correlVariable = (RexCorrelVariable)\n              cluster.getRexBuilder().makeCorrel(p.top.getRowType(),\n                  cluster.createCorrel());\n          p.varList.add(correlVariable.id);\n          return correlVariable;\n        }\n      }\n      return null; // TODO: throw; make this non-nullable\n    }", "docstring": " Creates a correlation variable with which to reference the current row\nof a relation in an enclosing loop.", "attributes": {"modifiers": "public @Nullable", "marker_annotations": ["@Nullable"], "non_marker_annotations": ["public"], "comments": [], "return_type": "RexNode", "classes": []}, "name": "var", "params": [{"name": "name", "type": "String"}], "body": "                                              {\n      final VarData fn = map.get(name);\n      if (fn != null) {\n        return fn.apply(relBuilder);\n      }\n      for (RelContext p = parent; p != null; p = p.parent) {\n        if (p.map.containsKey(name)) {\n          final RelOptCluster cluster = p.top.getCluster();\n          final RexCorrelVariable correlVariable = (RexCorrelVariable)\n              cluster.getRexBuilder().makeCorrel(p.top.getRowType(),\n                  cluster.createCorrel());\n          p.varList.add(correlVariable.id);\n          return correlVariable;\n        }\n      }\n      return null; // TODO: throw; make this non-nullable\n    }", "signature": "public @Nullable RexNode var(String name)"}]}, {"original_string": "  private static class VarData {\n    final Type type;\n    final int offset;\n    final RelDataType rowType;\n\n    VarData(Type type, int offset, RelDataType rowType) {\n      this.type = type;\n      this.offset = offset;\n      this.rowType = rowType;\n    }\n\n    RexNode apply(RelBuilder relBuilder) {\n      if (type instanceof RecordType) {\n        return relBuilder.getRexBuilder().makeRangeReference(rowType,\n            offset, false);\n      } else {\n        return relBuilder.field(offset);\n      }\n    }\n  }", "definition": "  private static class VarData", "class_docstring": " How a Morel variable maps onto the columns returned from a Join.", "name": "VarData", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "fields": [{"attribute_expression": "final Type type;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "Type", "name": "type", "syntax_pass": true}, {"attribute_expression": "final int offset;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "int", "name": "offset", "syntax_pass": true}, {"attribute_expression": "final RelDataType rowType;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "RelDataType", "name": "rowType", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    VarData(Type type, int offset, RelDataType rowType) {\n      this.type = type;\n      this.offset = offset;\n      this.rowType = rowType;\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "VarData", "params": [{"name": "type", "type": "Type"}, {"name": "offset", "type": "int"}, {"name": "rowType", "type": "RelDataType"}], "body": "                                                        {\n      this.type = type;\n      this.offset = offset;\n      this.rowType = rowType;\n    }", "signature": "VarData(Type type, int offset, RelDataType rowType)"}, {"syntax_pass": true, "original_string": "    RexNode apply(RelBuilder relBuilder) {\n      if (type instanceof RecordType) {\n        return relBuilder.getRexBuilder().makeRangeReference(rowType,\n            offset, false);\n      } else {\n        return relBuilder.field(offset);\n      }\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "RexNode", "classes": []}, "name": "apply", "params": [{"name": "relBuilder", "type": "RelBuilder"}], "body": "                                         {\n      if (type instanceof RecordType) {\n        return relBuilder.getRexBuilder().makeRangeReference(rowType,\n            offset, false);\n      } else {\n        return relBuilder.field(offset);\n      }\n    }", "signature": "RexNode apply(RelBuilder relBuilder)"}]}], "class_docstring": " Compiles an expression to code that can be evaluated.", "original_string": "public class CalciteCompiler extends Compiler {\n  /** Morel prefix and suffix operators and their exact equivalents in Calcite. */\n  static final Map<BuiltIn, SqlOperator> UNARY_OPERATORS =\n      ImmutableMap.<BuiltIn, SqlOperator>builder()\n          .put(BuiltIn.NOT, SqlStdOperatorTable.NOT)\n          .put(BuiltIn.LIST_NULL, SqlStdOperatorTable.EXISTS)\n          .put(BuiltIn.RELATIONAL_EXISTS, SqlStdOperatorTable.EXISTS)\n          .put(BuiltIn.RELATIONAL_NOT_EXISTS, SqlStdOperatorTable.EXISTS)\n          .put(BuiltIn.RELATIONAL_ONLY, SqlStdOperatorTable.SCALAR_QUERY)\n          .build();\n\n  /** Morel infix operators and their exact equivalents in Calcite. */\n  static final Map<BuiltIn, SqlOperator> BINARY_OPERATORS =\n      ImmutableMap.<BuiltIn, SqlOperator>builder()\n          .put(BuiltIn.OP_EQ, SqlStdOperatorTable.EQUALS)\n          .put(BuiltIn.OP_NE, SqlStdOperatorTable.NOT_EQUALS)\n          .put(BuiltIn.OP_LT, SqlStdOperatorTable.LESS_THAN)\n          .put(BuiltIn.OP_LE, SqlStdOperatorTable.LESS_THAN_OR_EQUAL)\n          .put(BuiltIn.OP_GT, SqlStdOperatorTable.GREATER_THAN)\n          .put(BuiltIn.OP_GE, SqlStdOperatorTable.GREATER_THAN_OR_EQUAL)\n          .put(BuiltIn.OP_NEGATE, SqlStdOperatorTable.UNARY_MINUS)\n          .put(BuiltIn.OP_ELEM, SqlStdOperatorTable.IN)\n          .put(BuiltIn.OP_NOT_ELEM, SqlStdOperatorTable.NOT_IN)\n          .put(BuiltIn.Z_NEGATE_INT, SqlStdOperatorTable.UNARY_MINUS)\n          .put(BuiltIn.Z_NEGATE_REAL, SqlStdOperatorTable.UNARY_MINUS)\n          .put(BuiltIn.OP_PLUS, SqlStdOperatorTable.PLUS)\n          .put(BuiltIn.Z_PLUS_INT, SqlStdOperatorTable.PLUS)\n          .put(BuiltIn.Z_PLUS_REAL, SqlStdOperatorTable.PLUS)\n          .put(BuiltIn.OP_MINUS, SqlStdOperatorTable.MINUS)\n          .put(BuiltIn.Z_MINUS_INT, SqlStdOperatorTable.MINUS)\n          .put(BuiltIn.Z_MINUS_REAL, SqlStdOperatorTable.MINUS)\n          .put(BuiltIn.OP_TIMES, SqlStdOperatorTable.MULTIPLY)\n          .put(BuiltIn.Z_TIMES_INT, SqlStdOperatorTable.MULTIPLY)\n          .put(BuiltIn.Z_TIMES_REAL, SqlStdOperatorTable.MULTIPLY)\n          .put(BuiltIn.OP_DIVIDE, SqlStdOperatorTable.DIVIDE)\n          .put(BuiltIn.Z_DIVIDE_INT, SqlStdOperatorTable.DIVIDE)\n          .put(BuiltIn.Z_DIVIDE_REAL, SqlStdOperatorTable.DIVIDE)\n          .put(BuiltIn.OP_DIV, SqlStdOperatorTable.DIVIDE)\n          .put(BuiltIn.OP_MOD, SqlStdOperatorTable.MOD)\n          .put(BuiltIn.Z_ANDALSO, SqlStdOperatorTable.AND)\n          .put(BuiltIn.Z_ORELSE, SqlStdOperatorTable.OR)\n          .build();\n\n  final Calcite calcite;\n\n  public CalciteCompiler(TypeSystem typeSystem, Calcite calcite) {\n    super(typeSystem);\n    this.calcite = requireNonNull(calcite, \"calcite\");\n  }\n\n  public @Nullable RelNode toRel(Environment env, Core.Exp expression) {\n    return toRel2(\n        new RelContext(env, null, calcite.relBuilder(),\n            ImmutableSortedMap.of(), 0),\n        expression);\n  }\n\n  private RelNode toRel2(RelContext cx, Core.Exp expression) {\n    if (toRel3(cx, expression, false)) {\n      return cx.relBuilder.build();\n    } else {\n      return null;\n    }\n  }\n\n  boolean toRel3(RelContext cx, Core.Exp expression, boolean aggressive) {\n    final Code code = compile(cx, expression);\n    return code instanceof RelCode\n        && ((RelCode) code).toRel(cx, aggressive);\n  }\n\n  Code toRel4(Environment env, Code code, Type type) {\n    if (!(code instanceof RelCode)) {\n      return code;\n    }\n    RelContext rx =\n        new RelContext(env, null, calcite.relBuilder(),\n            ImmutableSortedMap.of(), 0);\n    if (((RelCode) code).toRel(rx, false)) {\n      return calcite.code(rx.env, rx.relBuilder.build(), type);\n    }\n    return code;\n  }\n\n  @Override protected CalciteFunctions.Context createContext(\n      Environment env) {\n    final Session dummySession = new Session(ImmutableMap.of());\n    return new CalciteFunctions.Context(dummySession, env, typeSystem,\n        calcite.dataContext.getTypeFactory());\n  }\n\n  @Override public Code compileArg(Context cx, Core.Exp expression) {\n    Code code = super.compileArg(cx, expression);\n    if (code instanceof RelCode && !(cx instanceof RelContext)) {\n      final RelBuilder relBuilder = calcite.relBuilder();\n      final RelContext rx =\n          new RelContext(cx.env, null, relBuilder, ImmutableSortedMap.of(), 0);\n      if (toRel3(rx, expression, false)) {\n        return calcite.code(rx.env, rx.relBuilder.build(), expression.type);\n      }\n    }\n    return code;\n  }\n\n  @Override protected Code finishCompileLet(Context cx, List<Code> matchCodes_,\n      Code resultCode_, Type resultType) {\n    final Code resultCode = toRel4(cx.env, resultCode_, resultType);\n    final List<Code> matchCodes = ImmutableList.copyOf(matchCodes_);\n    final Code code =\n        super.finishCompileLet(cx, matchCodes, resultCode, resultType);\n    return new RelCode() {\n      @Override public boolean toRel(RelContext cx, boolean aggressive) {\n        return false;\n      }\n\n      @Override public Object eval(EvalEnv evalEnv) {\n        return code.eval(evalEnv);\n      }\n\n      @Override public Describer describe(Describer describer) {\n        return describer.start(\"let\", d -> {\n          forEachIndexed(matchCodes, (matchCode, i) ->\n              d.arg(\"matchCode\" + i, matchCode));\n          d.arg(\"resultCode\", resultCode);\n        });\n      }\n    };\n  }\n\n  @Override protected RelCode compileApply(Context cx, Core.Apply apply) {\n    final Code code = super.compileApply(cx, apply);\n    return new RelCode() {\n      @Override public Describer describe(Describer describer) {\n        return code.describe(describer);\n      }\n\n      @Override public Object eval(EvalEnv env) {\n        return code.eval(env);\n      }\n\n      @Override public boolean toRel(RelContext cx, boolean aggressive) {\n        if (!(apply.type instanceof ListType)) {\n          return false;\n        }\n        switch (apply.fn.op) {\n        case RECORD_SELECTOR:\n          if (apply.arg instanceof Core.Id) {\n            // Something like '#emp scott', 'scott' is a foreign value\n            final Object o = code.eval(evalEnvOf(cx.env));\n            if (o instanceof RelList) {\n              cx.relBuilder.push(((RelList) o).rel);\n              return true;\n            }\n          }\n          break;\n\n        case FN_LITERAL:\n          final BuiltIn builtIn =\n              ((Core.Literal) apply.fn).unwrap(BuiltIn.class);\n          switch (builtIn) {\n          case Z_LIST:\n            final List<Core.Exp> args = apply.args();\n            if (args.isEmpty()) {\n              final RelDataType calciteType =\n                  Converters.toCalciteType(removeTypeVars(apply.type),\n                      cx.relBuilder.getTypeFactory());\n              cx.relBuilder.values(calciteType.getComponentType());\n            } else {\n              for (Core.Exp arg : args) {\n                cx.relBuilder.values(new String[]{\"T\"}, true);\n                yield_(cx, ImmutableList.of(), arg);\n              }\n              cx.relBuilder.union(true, args.size());\n            }\n            return true;\n\n          case OP_UNION:\n          case OP_EXCEPT:\n          case OP_INTERSECT:\n            // For example, '[1, 2, 3] union (from scott.dept yield deptno)'\n            final Core.Tuple tuple = (Core.Tuple) apply.arg;\n            for (Core.Exp arg : tuple.args) {\n              if (!CalciteCompiler.this.toRel3(cx, arg, false)) {\n                return false;\n              }\n            }\n            harmonizeRowTypes(cx.relBuilder, tuple.args.size());\n            switch (builtIn) {\n            case OP_UNION:\n              cx.relBuilder.union(true, tuple.args.size());\n              return true;\n            case OP_EXCEPT:\n              cx.relBuilder.minus(false, tuple.args.size());\n              return true;\n            case OP_INTERSECT:\n              cx.relBuilder.intersect(false, tuple.args.size());\n              return true;\n            default:\n              throw new AssertionError(builtIn);\n            }\n          }\n        }\n        final RelDataTypeFactory typeFactory = cx.relBuilder.getTypeFactory();\n        final RelDataType calciteType =\n            Converters.toCalciteType(apply.type, typeFactory);\n        final RelDataType rowType = calciteType.getComponentType();\n        if (rowType == null) {\n          return false;\n        }\n        if (!aggressive) {\n          return false;\n        }\n        final JsonBuilder jsonBuilder = new JsonBuilder();\n        final RelJson relJson = RelJson.create().withJsonBuilder(jsonBuilder);\n        final String jsonRowType =\n            jsonBuilder.toJsonString(relJson.toJson(rowType));\n        final String morelCode = apply.toString();\n        ThreadLocals.let(CalciteFunctions.THREAD_ENV,\n            new CalciteFunctions.Context(new Session(ImmutableMap.of()), cx.env,\n                typeSystem, cx.relBuilder.getTypeFactory()), () ->\n            cx.relBuilder.functionScan(CalciteFunctions.TABLE_OPERATOR, 0,\n                cx.relBuilder.literal(morelCode),\n                cx.relBuilder.literal(jsonRowType)));\n        return true;\n      }\n    };\n  }\n\n  /** Converts each type variable in a type to a dummy record type,\n   * {@code {b: bool}}. */\n  private Type removeTypeVars(Type type) {\n    return type.copy(typeSystem,\n        t -> t instanceof TypeVar\n            ? typeSystem.recordType(RecordType.map(\"b\", PrimitiveType.BOOL))\n            : t);\n  }\n\n  @Override protected Code finishCompileApply(Context cx, Code fnCode,\n      Code argCode, Type argType) {\n    if (argCode instanceof RelCode && cx instanceof RelContext) {\n      final RelContext rx = (RelContext) cx;\n      if (((RelCode) argCode).toRel(rx, false)) {\n        final Code argCode2 =\n            calcite.code(rx.env, rx.relBuilder.build(), argType);\n        return finishCompileApply(cx, fnCode, argCode2, argType);\n      }\n    }\n    return super.finishCompileApply(cx, fnCode, argCode, argType);\n  }\n\n  @Override protected Code finishCompileApply(Context cx, Applicable fnValue,\n      Code argCode, Type argType) {\n    if (argCode instanceof RelCode && cx instanceof RelContext) {\n      final RelContext rx = (RelContext) cx;\n      if (((RelCode) argCode).toRel(rx, false)) {\n        final Code argCode2 =\n            calcite.code(rx.env, rx.relBuilder.build(), argType);\n        return finishCompileApply(cx, fnValue, argCode2, argType);\n      }\n    }\n    return super.finishCompileApply(cx, fnValue, argCode, argType);\n  }\n\n  private static void harmonizeRowTypes(RelBuilder relBuilder, int inputCount) {\n    final List<RelNode> inputs = new ArrayList<>();\n    for (int i = 0; i < inputCount; i++) {\n      inputs.add(relBuilder.build());\n    }\n    final RelDataType rowType = relBuilder.getTypeFactory()\n        .leastRestrictive(transform(inputs, RelNode::getRowType));\n    for (RelNode input : Lists.reverse(inputs)) {\n      relBuilder.push(input)\n          .convert(rowType, false);\n    }\n  }\n\n  @Override protected Code compileFrom(Context cx, Core.From from) {\n    final Code code = super.compileFrom(cx, from);\n    return new RelCode() {\n      @Override public Describer describe(Describer describer) {\n        return code.describe(describer);\n      }\n\n      @Override public Object eval(EvalEnv env) {\n        return code.eval(env);\n      }\n\n      @Override public boolean toRel(RelContext cx, boolean aggressive) {\n        if (from.steps.isEmpty()\n            || !(from.steps.get(0) instanceof Core.Scan)) {\n          // One row, zero columns\n          cx.relBuilder.values(ImmutableList.of(ImmutableList.of()),\n              cx.relBuilder.getTypeFactory().builder().build());\n        }\n        cx =\n            new RelContext(cx.env, cx, cx.relBuilder,\n                ImmutableSortedMap.of(), 1);\n        for (Ord<Core.FromStep> fromStep : Ord.zip(from.steps)) {\n          cx = step(cx, fromStep.i, fromStep.e);\n          if (cx == null) {\n            return false;\n          }\n        }\n        if (from.steps.isEmpty()\n            || getLast(from.steps).op != Op.YIELD) {\n          final Core.Exp implicitYieldExp =\n              core.implicitYieldExp(typeSystem, from.steps);\n          cx = yield_(cx, ImmutableList.of(), implicitYieldExp);\n        }\n        return true;\n      }\n\n      private RelContext step(RelContext cx, int i, Core.FromStep fromStep) {\n        switch (fromStep.op) {\n        case SCAN:\n          return join(cx, i, (Core.Scan) fromStep);\n        case WHERE:\n          return where(cx, (Core.Where) fromStep);\n        case SKIP:\n          return skip(cx, (Core.Skip) fromStep);\n        case TAKE:\n          return take(cx, (Core.Take) fromStep);\n        case ORDER:\n          return order(cx, (Core.Order) fromStep);\n        case GROUP:\n          return group(cx, (Core.Group) fromStep);\n        case YIELD:\n          return yield_(cx, (Core.Yield) fromStep);\n        default:\n          throw new AssertionError(fromStep);\n        }\n      }\n    };\n  }\n\n  private RelContext yield_(RelContext cx, Core.Yield yield) {\n    return yield_(cx, yield.bindings, yield.exp);\n  }\n\n  private RelContext yield_(RelContext cx, List<Binding> bindings,\n      Core.Exp exp) {\n    final Core.Tuple tuple;\n    switch (exp.op) {\n    case ID:\n      final Core.Id id = (Core.Id) exp;\n      tuple = toRecord(cx, id);\n      if (tuple != null) {\n        return yield_(cx, bindings, tuple);\n      }\n      break;\n\n    case TUPLE:\n      tuple = (Core.Tuple) exp;\n      final List<String> names =\n          ImmutableList.copyOf(tuple.type().argNameTypes().keySet());\n      cx.relBuilder.project(transform(tuple.args, e -> translate(cx, e)),\n          names);\n      return getRelContext(cx, cx.env.bindAll(bindings), names);\n    }\n    RexNode rex = translate(cx, exp);\n    cx.relBuilder.project(rex);\n    return cx;\n  }\n\n  private RexNode translate(RelContext cx, Core.Exp exp) {\n    final Core.Tuple record;\n    final RelDataTypeFactory.Builder builder;\n    final List<RexNode> operands;\n    switch (exp.op) {\n    case BOOL_LITERAL:\n    case CHAR_LITERAL:\n    case INT_LITERAL:\n    case REAL_LITERAL:\n    case STRING_LITERAL:\n    case UNIT_LITERAL:\n      final Core.Literal literal = (Core.Literal) exp;\n      switch (exp.op) {\n      case CHAR_LITERAL:\n        // convert from Character to singleton String\n        return cx.relBuilder.literal(literal.value + \"\");\n      case UNIT_LITERAL:\n        return cx.relBuilder.call(SqlStdOperatorTable.ROW);\n      default:\n        return cx.relBuilder.literal(literal.value);\n      }\n\n    case ID:\n      // In 'from e in emps yield e', 'e' expands to a record,\n      // '{e.deptno, e.ename}'\n      final Core.Id id = (Core.Id) exp;\n      final Binding binding = cx.env.getOpt(id.idPat);\n      if (binding != null && binding.value != Unit.INSTANCE) {\n        final Core.Literal coreLiteral =\n            core.literal((PrimitiveType) binding.id.type, binding.value);\n        return translate(cx, coreLiteral);\n      }\n      record = toRecord(cx, id);\n      if (record != null) {\n        return translate(cx, record);\n      }\n      if (cx.map.containsKey(id.idPat.name)) {\n        // Not a record, so must be a scalar. It is represented in Calcite\n        // as a record with one field.\n        final VarData fn = requireNonNull(cx.map.get(id.idPat.name));\n        return fn.apply(cx.relBuilder);\n      }\n      break;\n\n    case APPLY:\n      final Core.Apply apply = (Core.Apply) exp;\n      switch (apply.fn.op) {\n      case FN_LITERAL:\n        BuiltIn op = ((Core.Literal) apply.fn).unwrap(BuiltIn.class);\n\n        // Is it a unary operator with a Calcite equivalent? E.g. not => NOT\n        final SqlOperator unaryOp = UNARY_OPERATORS.get(op);\n        if (unaryOp != null) {\n          switch (op) {\n          case LIST_NULL:\n          case RELATIONAL_EXISTS:\n          case RELATIONAL_NOT_EXISTS:\n          case RELATIONAL_ONLY:\n            final RelNode r = toRel2(cx, apply.arg);\n            if (r != null) {\n              switch (op) {\n              case LIST_NULL:\n              case RELATIONAL_NOT_EXISTS:\n                return cx.relBuilder.not(RexSubQuery.exists(r));\n              case RELATIONAL_EXISTS:\n                return RexSubQuery.exists(r);\n              case RELATIONAL_ONLY:\n                return RexSubQuery.scalar(r);\n              default:\n                throw new AssertionError(\"unknown \" + op);\n              }\n            }\n          }\n          return cx.relBuilder.call(unaryOp, translate(cx, apply.arg));\n        }\n\n        // Is it a binary operator with a Calcite equivalent? E.g. + => PLUS\n        final SqlOperator binaryOp = BINARY_OPERATORS.get(op);\n        if (binaryOp != null) {\n          assert apply.arg.op == Op.TUPLE;\n          switch (op) {\n          case OP_ELEM:\n          case OP_NOT_ELEM:\n            final RelNode r = toRel2(cx, apply.args().get(1));\n            if (r != null) {\n              final RexNode e = translate(cx, apply.args().get(0));\n              final RexSubQuery in = RexSubQuery.in(r, ImmutableList.of(e));\n              return maybeNot(cx, in, op == BuiltIn.OP_NOT_ELEM);\n            }\n          }\n          return cx.relBuilder.call(binaryOp, translateList(cx, apply.args()));\n        }\n      }\n      if (apply.fn instanceof Core.RecordSelector\n          && apply.arg instanceof Core.Id) {\n        // Something like '#deptno e'\n        final Core.NamedPat idPat = ((Core.Id) apply.arg).idPat;\n        final @Nullable RexNode range = cx.var(idPat.name);\n        if (range != null) {\n          final Core.RecordSelector selector = (Core.RecordSelector) apply.fn;\n          return cx.relBuilder.field(range, selector.fieldName());\n        }\n      }\n      final Set<String> vars =\n          getRelationalVariables(cx.env, cx.map.keySet(), apply);\n      if (vars.isEmpty()) {\n        return morelScalar(cx, apply);\n      }\n      final RexNode fnRex = translate(cx, apply.fn);\n      final RexNode argRex = translate(cx, apply.arg);\n      return morelApply(cx, apply.type, apply.arg.type, fnRex, argRex);\n\n    case FROM:\n      final Core.From from = (Core.From) exp;\n      final RelNode r = toRel2(cx, from);\n      if (r != null && 1 != 2) {\n        // TODO: add RexSubQuery.array and RexSubQuery.multiset methods\n        return cx.relBuilder.call(SqlStdOperatorTable.ARRAY_QUERY,\n            RexSubQuery.scalar(r));\n      }\n      break;\n\n    case TUPLE:\n      final Core.Tuple tuple = (Core.Tuple) exp;\n      builder = cx.relBuilder.getTypeFactory().builder();\n      operands = new ArrayList<>();\n      forEachIndexed(tuple.args, (arg, i) -> {\n        final RexNode e = translate(cx, arg);\n        operands.add(e);\n        builder.add(Integer.toString(i), e.getType());\n      });\n      return cx.relBuilder.getRexBuilder().makeCall(builder.build(),\n          SqlStdOperatorTable.ROW, operands);\n    }\n\n    // Translate as a call to a scalar function\n    return morelScalar(cx, exp);\n  }\n\n  private RexNode maybeNot(RelContext cx, RexNode e, boolean not) {\n    return not ? cx.relBuilder.not(e) : e;\n  }\n\n  private Set<String> getRelationalVariables(Environment env,\n      Set<String> nameSet, AstNode node) {\n    final Set<String> varNames = new LinkedHashSet<>();\n    node.accept(new Visitor() {\n      @Override protected void visit(Core.Id id) {\n        if (nameSet.contains(id.idPat.name)) {\n          varNames.add(id.idPat.name);\n        }\n      }\n    });\n    return varNames;\n  }\n\n  private RexNode morelScalar(RelContext cx, Core.Exp exp) {\n    final RelDataTypeFactory typeFactory = cx.relBuilder.getTypeFactory();\n    final RelDataType calciteType =\n        Converters.toCalciteType(exp.type, typeFactory);\n    final JsonBuilder jsonBuilder = new JsonBuilder();\n    final RelJson relJson = RelJson.create().withJsonBuilder(jsonBuilder);\n    final String jsonType =\n        jsonBuilder.toJsonString(relJson.toJson(calciteType));\n    final String morelCode = exp.toString();\n    return cx.relBuilder.getRexBuilder().makeCall(calciteType,\n        CalciteFunctions.SCALAR_OPERATOR,\n        Arrays.asList(cx.relBuilder.literal(morelCode),\n            cx.relBuilder.literal(jsonType)));\n  }\n\n  private RexNode morelApply(RelContext cx, Type type, Type argType, RexNode fn,\n      RexNode arg) {\n    final RelDataTypeFactory typeFactory = cx.relBuilder.getTypeFactory();\n    final RelDataType calciteType =\n        Converters.toCalciteType(type, typeFactory);\n    final String morelArgType = argType.toString();\n    return cx.relBuilder.getRexBuilder().makeCall(calciteType,\n        CalciteFunctions.APPLY_OPERATOR,\n        Arrays.asList(cx.relBuilder.literal(morelArgType), fn, arg));\n  }\n\n  private Core.Tuple toRecord(RelContext cx, Core.Id id) {\n    final Binding binding = cx.env.getOpt(id.idPat);\n    checkNotNull(binding, \"not found\", id);\n    final Type type = binding.id.type;\n    if (type instanceof RecordType) {\n      final RecordType recordType = (RecordType) type;\n      final List<Core.Exp> args = new ArrayList<>();\n      recordType.argNameTypes.forEach((field, fieldType) ->\n          args.add(\n              core.apply(Pos.ZERO, fieldType,\n                  core.recordSelector(typeSystem, recordType, field),\n                  id)));\n      return core.tuple(recordType, args);\n    }\n    return null;\n  }\n\n  private List<RexNode> translateList(RelContext cx, List<Core.Exp> exps) {\n    return transformEager(exps, exp -> translate(cx, exp));\n  }\n\n  private RelContext join(RelContext cx, int i, Core.Scan scan) {\n    if (!toRel3(cx, scan.exp, true)) {\n      return null;\n    }\n\n    final SortedMap<String, VarData> varOffsets = new TreeMap<>(cx.map);\n    int offset = 0;\n    for (VarData varData : cx.map.values()) {\n      offset += varData.rowType.getFieldCount();\n    }\n    final Core.Pat pat = scan.pat;\n    final RelNode r = cx.relBuilder.peek();\n    if (pat instanceof Core.IdPat) {\n      final Core.IdPat idPat = (Core.IdPat) pat;\n      cx.relBuilder.as(idPat.name);\n      varOffsets.put(idPat.name, new VarData(pat.type, offset, r.getRowType()));\n    }\n    cx =\n        new RelContext(cx.env.bindAll(scan.bindings), cx, cx.relBuilder,\n            ImmutableSortedMap.copyOfSorted(varOffsets), cx.inputCount + 1);\n\n    if (i > 0) {\n      final JoinRelType joinRelType = joinRelType(scan.op);\n      cx.relBuilder.join(joinRelType, translate(cx, scan.condition));\n    }\n    return cx;\n  }\n\n  private static JoinRelType joinRelType(Op op) {\n    switch (op) {\n    case SCAN:\n      return JoinRelType.INNER;\n    default:\n      throw new AssertionError(op);\n    }\n  }\n\n  private RelContext where(RelContext cx, Core.Where where) {\n    cx.relBuilder.filter(cx.varList, translate(cx, where.exp));\n    return cx;\n  }\n\n  private RelContext skip(RelContext cx, Core.Skip skip) {\n    if (skip.exp.op != Op.INT_LITERAL) {\n      throw new AssertionError(\"skip requires literal: \" + skip.exp);\n    }\n    int offset = ((Core.Literal) skip.exp).unwrap(Integer.class);\n    int fetch = -1; // per Calcite: \"negative means no limit\"\n    cx.relBuilder.limit(offset, fetch);\n    return cx;\n  }\n\n  private RelContext take(RelContext cx, Core.Take take) {\n    if (take.exp.op != Op.INT_LITERAL) {\n      throw new AssertionError(\"take requires literal: \" + take.exp);\n    }\n    int offset = 0;\n    int fetch = ((Core.Literal) take.exp).unwrap(Integer.class);\n    cx.relBuilder.limit(offset, fetch);\n    return cx;\n  }\n\n  private RelContext order(RelContext cx, Core.Order order) {\n    final List<RexNode> exps = new ArrayList<>();\n    order.orderItems.forEach(i -> {\n      RexNode exp = translate(cx, i.exp);\n      if (i.direction == Ast.Direction.DESC) {\n        exp = cx.relBuilder.desc(exp);\n      }\n      exps.add(exp);\n    });\n    cx.relBuilder.sort(exps);\n    return cx;\n  }\n\n  private RelContext group(RelContext cx, Core.Group group) {\n    final List<Binding> bindings = new ArrayList<>();\n    final List<RexNode> nodes = new ArrayList<>();\n    final List<String> names = new ArrayList<>();\n    group.groupExps.forEach((idPat, exp) -> {\n      bindings.add(Binding.of(idPat));\n      nodes.add(translate(cx, exp));\n      names.add(idPat.name);\n    });\n    final RelBuilder.GroupKey groupKey = cx.relBuilder.groupKey(nodes);\n    final List<RelBuilder.AggCall> aggregateCalls = new ArrayList<>();\n    group.aggregates.forEach((idPat, aggregate) -> {\n      bindings.add(Binding.of(idPat));\n      final SqlAggFunction op = aggOp(aggregate.aggregate);\n      final ImmutableList.Builder<RexNode> args = ImmutableList.builder();\n      if (aggregate.argument != null) {\n        args.add(translate(cx, aggregate.argument));\n      }\n      aggregateCalls.add(\n          cx.relBuilder.aggregateCall(op, args.build()).as(idPat.name));\n      names.add(idPat.name);\n    });\n\n    // Create an Aggregate operator.\n    cx.relBuilder.aggregate(groupKey, aggregateCalls);\n    return getRelContext(cx, cx.env.bindAll(bindings), names);\n  }\n\n  private static RelContext getRelContext(RelContext cx, Environment env,\n      List<String> names) {\n    // Permute the fields so that they are sorted by name, per Morel records.\n    final List<String> sortedNames =\n        Ordering.natural().immutableSortedCopy(names);\n    cx.relBuilder.rename(names)\n        .project(cx.relBuilder.fields(sortedNames));\n    final RelDataType rowType = cx.relBuilder.peek().getRowType();\n    final SortedMap<String, VarData> map = new TreeMap<>();\n    sortedNames.forEach(name ->\n        map.put(name,\n            new VarData(PrimitiveType.UNIT, map.size(), rowType)));\n\n    // Return a context containing a variable for each output field.\n    return new RelContext(env, cx, cx.relBuilder,\n        ImmutableSortedMap.copyOfSorted(map), 1);\n  }\n\n  /** Returns the Calcite operator corresponding to a Morel built-in aggregate\n   * function.\n   *\n   * <p>Future work: rather than resolving by name, look up aggregate function\n   * in environment, and compare with standard implementation of \"sum\" etc.;\n   * support aggregate functions defined by expressions (e.g. lambdas). */\n  @NonNull private SqlAggFunction aggOp(Core.Exp aggregate) {\n    if (aggregate instanceof Core.Literal) {\n      switch (((Core.Literal) aggregate).unwrap(BuiltIn.class)) {\n      case RELATIONAL_SUM:\n      case Z_SUM_INT:\n      case Z_SUM_REAL:\n        return SqlStdOperatorTable.SUM;\n      case RELATIONAL_COUNT:\n        return SqlStdOperatorTable.COUNT;\n      case RELATIONAL_MIN:\n        return SqlStdOperatorTable.MIN;\n      case RELATIONAL_MAX:\n        return SqlStdOperatorTable.MAX;\n      }\n    }\n    throw new AssertionError(\"unknown aggregate function: \" + aggregate);\n  }\n\n  private static EvalEnv evalEnvOf(Environment env) {\n    final Map<String, Object> map = new LinkedHashMap<>();\n    env.forEachValue(map::put);\n    EMPTY_ENV.visit(map::putIfAbsent);\n    return EvalEnvs.copyOf(map);\n  }\n\n  /** Translation context. */\n  static class RelContext extends Context {\n    final @Nullable RelContext parent;\n    final RelBuilder relBuilder;\n    final ImmutableSortedMap<String, VarData> map;\n    final int inputCount;\n    final List<CorrelationId> varList = new ArrayList<>();\n    private final RelNode top;\n\n    RelContext(Environment env, RelContext parent, RelBuilder relBuilder,\n        ImmutableSortedMap<String, VarData> map, int inputCount) {\n      super(env);\n      this.parent = parent;\n      this.relBuilder = relBuilder;\n      this.map = map;\n      this.inputCount = inputCount;\n      this.top = top(relBuilder);\n    }\n\n    private static @Nullable RelNode top(RelBuilder relBuilder) {\n      return relBuilder.size() == 0 ? null\n          : relBuilder.peek();\n    }\n\n    @Override RelContext bindAll(Iterable<Binding> bindings) {\n      final Environment env2 = env.bindAll(bindings);\n      return env2 == env ? this\n          : new RelContext(env2, this, relBuilder, map, inputCount);\n    }\n\n    /** Creates a correlation variable with which to reference the current row\n     * of a relation in an enclosing loop. */\n    public @Nullable RexNode var(String name) {\n      final VarData fn = map.get(name);\n      if (fn != null) {\n        return fn.apply(relBuilder);\n      }\n      for (RelContext p = parent; p != null; p = p.parent) {\n        if (p.map.containsKey(name)) {\n          final RelOptCluster cluster = p.top.getCluster();\n          final RexCorrelVariable correlVariable = (RexCorrelVariable)\n              cluster.getRexBuilder().makeCorrel(p.top.getRowType(),\n                  cluster.createCorrel());\n          p.varList.add(correlVariable.id);\n          return correlVariable;\n        }\n      }\n      return null; // TODO: throw; make this non-nullable\n    }\n  }\n\n  /** Extension to {@link Code} that can also provide a translation to\n   * relational algebra. */\n  interface RelCode extends Code {\n    boolean toRel(RelContext cx, boolean aggressive);\n\n    static RelCode of(Code code, Predicate<RelContext> c) {\n      return new RelCode() {\n        @Override public Describer describe(Describer describer) {\n          return code.describe(describer);\n        }\n\n        @Override public Object eval(EvalEnv env) {\n          return code.eval(env);\n        }\n\n        @Override public boolean toRel(RelContext cx, boolean aggressive) {\n          return c.test(cx);\n        }\n      };\n    }\n  }\n\n  /** How a Morel variable maps onto the columns returned from a Join. */\n  private static class VarData {\n    final Type type;\n    final int offset;\n    final RelDataType rowType;\n\n    VarData(Type type, int offset, RelDataType rowType) {\n      this.type = type;\n      this.offset = offset;\n      this.rowType = rowType;\n    }\n\n    RexNode apply(RelBuilder relBuilder) {\n      if (type instanceof RecordType) {\n        return relBuilder.getRexBuilder().makeRangeReference(rowType,\n            offset, false);\n      } else {\n        return relBuilder.field(offset);\n      }\n    }\n  }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "static final Map<BuiltIn, SqlOperator> UNARY_OPERATORS =\n      ImmutableMap.<BuiltIn, SqlOperator>builder()\n          .put(BuiltIn.NOT, SqlStdOperatorTable.NOT)\n          .put(BuiltIn.LIST_NULL, SqlStdOperatorTable.EXISTS)\n          .put(BuiltIn.RELATIONAL_EXISTS, SqlStdOperatorTable.EXISTS)\n          .put(BuiltIn.RELATIONAL_NOT_EXISTS, SqlStdOperatorTable.EXISTS)\n          .put(BuiltIn.RELATIONAL_ONLY, SqlStdOperatorTable.SCALAR_QUERY)\n          .build();", "docstring": " Morel prefix and suffix operators and their exact equivalents in Calcite.", "modifiers": "static final", "marker_annotations": [], "non_marker_annotations": ["static", "final"], "comments": [], "type": "Map<BuiltIn, SqlOperator>", "name": "UNARY_OPERATORS =\n      ImmutableMap.<BuiltIn, SqlOperator>builder()\n          .put(BuiltIn.NOT, SqlStdOperatorTable.NOT)\n          .put(BuiltIn.LIST_NULL, SqlStdOperatorTable.EXISTS)\n          .put(BuiltIn.RELATIONAL_EXISTS, SqlStdOperatorTable.EXISTS)\n          .put(BuiltIn.RELATIONAL_NOT_EXISTS, SqlStdOperatorTable.EXISTS)\n          .put(BuiltIn.RELATIONAL_ONLY, SqlStdOperatorTable.SCALAR_QUERY)\n          .build()", "syntax_pass": true}, {"attribute_expression": "static final Map<BuiltIn, SqlOperator> BINARY_OPERATORS =\n      ImmutableMap.<BuiltIn, SqlOperator>builder()\n          .put(BuiltIn.OP_EQ, SqlStdOperatorTable.EQUALS)\n          .put(BuiltIn.OP_NE, SqlStdOperatorTable.NOT_EQUALS)\n          .put(BuiltIn.OP_LT, SqlStdOperatorTable.LESS_THAN)\n          .put(BuiltIn.OP_LE, SqlStdOperatorTable.LESS_THAN_OR_EQUAL)\n          .put(BuiltIn.OP_GT, SqlStdOperatorTable.GREATER_THAN)\n          .put(BuiltIn.OP_GE, SqlStdOperatorTable.GREATER_THAN_OR_EQUAL)\n          .put(BuiltIn.OP_NEGATE, SqlStdOperatorTable.UNARY_MINUS)\n          .put(BuiltIn.OP_ELEM, SqlStdOperatorTable.IN)\n          .put(BuiltIn.OP_NOT_ELEM, SqlStdOperatorTable.NOT_IN)\n          .put(BuiltIn.Z_NEGATE_INT, SqlStdOperatorTable.UNARY_MINUS)\n          .put(BuiltIn.Z_NEGATE_REAL, SqlStdOperatorTable.UNARY_MINUS)\n          .put(BuiltIn.OP_PLUS, SqlStdOperatorTable.PLUS)\n          .put(BuiltIn.Z_PLUS_INT, SqlStdOperatorTable.PLUS)\n          .put(BuiltIn.Z_PLUS_REAL, SqlStdOperatorTable.PLUS)\n          .put(BuiltIn.OP_MINUS, SqlStdOperatorTable.MINUS)\n          .put(BuiltIn.Z_MINUS_INT, SqlStdOperatorTable.MINUS)\n          .put(BuiltIn.Z_MINUS_REAL, SqlStdOperatorTable.MINUS)\n          .put(BuiltIn.OP_TIMES, SqlStdOperatorTable.MULTIPLY)\n          .put(BuiltIn.Z_TIMES_INT, SqlStdOperatorTable.MULTIPLY)\n          .put(BuiltIn.Z_TIMES_REAL, SqlStdOperatorTable.MULTIPLY)\n          .put(BuiltIn.OP_DIVIDE, SqlStdOperatorTable.DIVIDE)\n          .put(BuiltIn.Z_DIVIDE_INT, SqlStdOperatorTable.DIVIDE)\n          .put(BuiltIn.Z_DIVIDE_REAL, SqlStdOperatorTable.DIVIDE)\n          .put(BuiltIn.OP_DIV, SqlStdOperatorTable.DIVIDE)\n          .put(BuiltIn.OP_MOD, SqlStdOperatorTable.MOD)\n          .put(BuiltIn.Z_ANDALSO, SqlStdOperatorTable.AND)\n          .put(BuiltIn.Z_ORELSE, SqlStdOperatorTable.OR)\n          .build();", "docstring": " Morel infix operators and their exact equivalents in Calcite.", "modifiers": "static final", "marker_annotations": [], "non_marker_annotations": ["static", "final"], "comments": [], "type": "Map<BuiltIn, SqlOperator>", "name": "BINARY_OPERATORS =\n      ImmutableMap.<BuiltIn, SqlOperator>builder()\n          .put(BuiltIn.OP_EQ, SqlStdOperatorTable.EQUALS)\n          .put(BuiltIn.OP_NE, SqlStdOperatorTable.NOT_EQUALS)\n          .put(BuiltIn.OP_LT, SqlStdOperatorTable.LESS_THAN)\n          .put(BuiltIn.OP_LE, SqlStdOperatorTable.LESS_THAN_OR_EQUAL)\n          .put(BuiltIn.OP_GT, SqlStdOperatorTable.GREATER_THAN)\n          .put(BuiltIn.OP_GE, SqlStdOperatorTable.GREATER_THAN_OR_EQUAL)\n          .put(BuiltIn.OP_NEGATE, SqlStdOperatorTable.UNARY_MINUS)\n          .put(BuiltIn.OP_ELEM, SqlStdOperatorTable.IN)\n          .put(BuiltIn.OP_NOT_ELEM, SqlStdOperatorTable.NOT_IN)\n          .put(BuiltIn.Z_NEGATE_INT, SqlStdOperatorTable.UNARY_MINUS)\n          .put(BuiltIn.Z_NEGATE_REAL, SqlStdOperatorTable.UNARY_MINUS)\n          .put(BuiltIn.OP_PLUS, SqlStdOperatorTable.PLUS)\n          .put(BuiltIn.Z_PLUS_INT, SqlStdOperatorTable.PLUS)\n          .put(BuiltIn.Z_PLUS_REAL, SqlStdOperatorTable.PLUS)\n          .put(BuiltIn.OP_MINUS, SqlStdOperatorTable.MINUS)\n          .put(BuiltIn.Z_MINUS_INT, SqlStdOperatorTable.MINUS)\n          .put(BuiltIn.Z_MINUS_REAL, SqlStdOperatorTable.MINUS)\n          .put(BuiltIn.OP_TIMES, SqlStdOperatorTable.MULTIPLY)\n          .put(BuiltIn.Z_TIMES_INT, SqlStdOperatorTable.MULTIPLY)\n          .put(BuiltIn.Z_TIMES_REAL, SqlStdOperatorTable.MULTIPLY)\n          .put(BuiltIn.OP_DIVIDE, SqlStdOperatorTable.DIVIDE)\n          .put(BuiltIn.Z_DIVIDE_INT, SqlStdOperatorTable.DIVIDE)\n          .put(BuiltIn.Z_DIVIDE_REAL, SqlStdOperatorTable.DIVIDE)\n          .put(BuiltIn.OP_DIV, SqlStdOperatorTable.DIVIDE)\n          .put(BuiltIn.OP_MOD, SqlStdOperatorTable.MOD)\n          .put(BuiltIn.Z_ANDALSO, SqlStdOperatorTable.AND)\n          .put(BuiltIn.Z_ORELSE, SqlStdOperatorTable.OR)\n          .build()", "syntax_pass": true}, {"attribute_expression": "final Calcite calcite;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "Calcite", "name": "calcite", "syntax_pass": true}]}, {"uris": "src/main/java/net/hydromatic/morel/compile/Inliner.java.Inliner", "name": "Inliner", "file_path": "src/main/java/net/hydromatic/morel/compile/Inliner.java", "superclasses": "EnvShuttle", "methods": ["[]Inliner(TypeSystem,Environment,Analyzer.Analysis)", "[Inliner]of(TypeSystem,Environment,Analyzer.@Nullable Analysis)", "[Inliner]push(Environment)", "[Core.Exp]visit(Core.Id)", "[Core.Exp]visit(Core.Apply)", "[Core.Exp]visit(Core.Case)", "[Map<Core.Id, Core.Id>]getSub(Core.Exp,Core.Match)", "[Core.Exp]visit(Core.Let)"], "method_uris": ["src/main/java/net/hydromatic/morel/compile/Inliner.java.Inliner.[]Inliner(TypeSystem,Environment,Analyzer.Analysis)", "src/main/java/net/hydromatic/morel/compile/Inliner.java.Inliner.[Inliner]of(TypeSystem,Environment,Analyzer.@Nullable Analysis)", "src/main/java/net/hydromatic/morel/compile/Inliner.java.Inliner.[Inliner]push(Environment)", "src/main/java/net/hydromatic/morel/compile/Inliner.java.Inliner.[Core.Exp]visit(Core.Id)", "src/main/java/net/hydromatic/morel/compile/Inliner.java.Inliner.[Core.Exp]visit(Core.Apply)", "src/main/java/net/hydromatic/morel/compile/Inliner.java.Inliner.[Core.Exp]visit(Core.Case)", "src/main/java/net/hydromatic/morel/compile/Inliner.java.Inliner.[Map<Core.Id, Core.Id>]getSub(Core.Exp,Core.Match)", "src/main/java/net/hydromatic/morel/compile/Inliner.java.Inliner.[Core.Exp]visit(Core.Let)"], "overrides": null, "attributes": [], "class_docstring": "\nShuttle that inlines constant values.\n", "original_string": "public class Inliner extends EnvShuttle {\n  private final Analyzer.@Nullable Analysis analysis;\n\n  /** Private constructor. */\n  private Inliner(TypeSystem typeSystem, Environment env,\n      Analyzer.Analysis analysis) {\n    super(typeSystem, env);\n    this.analysis = analysis;\n  }\n\n  /** Creates an Inliner.\n   *\n   * <p>If {@code analysis} is null, no variables are inlined. */\n  public static Inliner of(TypeSystem typeSystem, Environment env,\n      Analyzer.@Nullable Analysis analysis) {\n    return new Inliner(typeSystem, env, analysis);\n  }\n\n  @Override protected Inliner push(Environment env) {\n    return new Inliner(typeSystem, env, analysis);\n  }\n\n  @Override protected Core.Exp visit(Core.Id id) {\n    final Binding binding = env.getOpt(id.idPat);\n    if (binding != null\n        && !binding.parameter) {\n      if (binding.exp != null) {\n        final Analyzer.Use use =\n            analysis == null ? Analyzer.Use.MULTI_UNSAFE\n                : requireNonNull(analysis.map.get(id.idPat));\n        switch (use) {\n        case ATOMIC:\n        case ONCE_SAFE:\n          return binding.exp.accept(this);\n        }\n      }\n      Object v = binding.value;\n      if (v instanceof Macro) {\n        final Macro macro = (Macro) binding.value;\n        final Core.Exp x =\n            macro.expand(typeSystem, env, ((FnType) id.type).paramType);\n        if (x instanceof Core.Literal) {\n          return x;\n        }\n      }\n      if (v != Unit.INSTANCE) {\n        switch (id.type.op()) {\n        case ID:\n          assert id.type instanceof PrimitiveType;\n          return core.literal((PrimitiveType) id.type, v);\n\n        case FUNCTION_TYPE:\n          assert v instanceof Applicable || v instanceof Macro : v;\n          final BuiltIn builtIn = Codes.BUILT_IN_MAP.get(v);\n          if (builtIn != null) {\n            return core.functionLiteral(typeSystem, builtIn);\n          }\n          // Applicable (including Closure) that does not map to a BuiltIn\n          // is not considered 'constant', mainly because it creates messy plans\n          break;\n\n        default:\n          if (v instanceof Code) {\n            v = ((Code) v).eval(Compiler.EMPTY_ENV);\n            if (v == null) {\n              // Cannot inline SYS_FILE; it requires a session.\n              break;\n            }\n          }\n          return core.valueLiteral(id, v);\n        }\n      }\n    }\n    return super.visit(id);\n  }\n\n  @Override protected Core.Exp visit(Core.Apply apply) {\n    final Core.Apply apply2 = (Core.Apply) super.visit(apply);\n    if (apply2.fn.op == Op.RECORD_SELECTOR\n        && apply2.arg.op == Op.VALUE_LITERAL) {\n      final Core.RecordSelector selector = (Core.RecordSelector) apply2.fn;\n      @SuppressWarnings(\"rawtypes\")\n      final List list = ((Core.Literal) apply2.arg).unwrap(List.class);\n      final Object o = list.get(selector.slot);\n      if (o instanceof Applicable || o instanceof Macro) {\n        // E.g. apply is '#filter List', o is Codes.LIST_FILTER,\n        // builtIn is BuiltIn.LIST_FILTER.\n        final BuiltIn builtIn = Codes.BUILT_IN_MAP.get(o);\n        if (builtIn != null) {\n          return core.functionLiteral(typeSystem, builtIn);\n        }\n      }\n      return core.valueLiteral(apply2, o);\n    }\n    if (apply2.fn.op == Op.FN) {\n      // Beta-reduction:\n      //   (fn x => E) A\n      // becomes\n      //   let x = A in E end\n      final Core.Fn fn = (Core.Fn) apply2.fn;\n      return core.let(\n          core.nonRecValDecl(apply2.pos, fn.idPat, apply2.arg), fn.exp);\n    }\n    return apply2;\n  }\n\n  @Override protected Core.Exp visit(Core.Case caseOf) {\n    final Core.Exp exp = caseOf.exp.accept(this);\n    final List<Core.Match> matchList = visitList(caseOf.matchList);\n    if (matchList.size() == 1) {\n      final Map<Core.Id, Core.Id> substitution =\n          getSub(exp, matchList.get(0));\n      if (substitution != null) {\n        return Replacer.substitute(typeSystem, substitution,\n            matchList.get(0).exp);\n      }\n    }\n    return caseOf.copy(exp, matchList);\n  }\n\n  private @Nullable Map<Core.Id, Core.Id> getSub(Core.Exp exp,\n      Core.Match match) {\n    if (exp.op == Op.ID && match.pat.op == Op.ID_PAT) {\n      return ImmutableMap.of(core.id((Core.IdPat) match.pat), (Core.Id) exp);\n    }\n    if (exp.op == Op.TUPLE && match.pat.op == Op.TUPLE_PAT) {\n      final Core.Tuple tuple = (Core.Tuple) exp;\n      final Core.TuplePat tuplePat = (Core.TuplePat) match.pat;\n      if (tuple.args.stream().allMatch(arg -> arg.op == Op.ID)\n          && tuplePat.args.stream().allMatch(arg -> arg.op == Op.ID_PAT)) {\n        final ImmutableMap.Builder<Core.Id, Core.Id> builder =\n            ImmutableMap.builder();\n        forEach(tuple.args, tuplePat.args, (arg, pat) ->\n            builder.put(core.id((Core.IdPat) pat), (Core.Id) arg));\n        return builder.build();\n      }\n    }\n    return null;\n  }\n\n  @Override protected Core.Exp visit(Core.Let let) {\n    final Analyzer.Use use =\n        analysis == null\n            ? Analyzer.Use.MULTI_UNSAFE\n            : let.decl instanceof Core.NonRecValDecl\n                ? requireNonNull(\n                    analysis.map.get(((Core.NonRecValDecl) let.decl).pat))\n                : Analyzer.Use.MULTI_UNSAFE;\n    switch (use) {\n    case DEAD:\n      // This declaration has no uses; remove it\n      return let.exp;\n\n    case ATOMIC:\n    case ONCE_SAFE:\n      // This declaration has one use; remove the declaration, and replace its\n      // use inside the expression.\n      final List<Binding> bindings = new ArrayList<>();\n      Compiles.bindPattern(typeSystem, bindings, let.decl);\n      return let.exp.accept(bind(bindings));\n    }\n    return super.visit(let);\n  }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private final Analyzer.@Nullable Analysis analysis;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Analyzer.@Nullable Analysis", "name": "analysis", "syntax_pass": true}]}, {"uris": "src/main/java/net/hydromatic/morel/compile/PatternCoverageChecker.java.PatternCoverageChecker", "name": "PatternCoverageChecker", "file_path": "src/main/java/net/hydromatic/morel/compile/PatternCoverageChecker.java", "superclasses": "", "methods": ["[]PatternCoverageChecker(TypeSystem)", "[boolean]isCoveredBy(TypeSystem,List<Core.Pat>,Core.Pat)", "[boolean]isExhaustive(TypeSystem,List<Core.Pat>)", "[Sat.Term]toTerm(Core.Pat)", "[void]toTerm(Core.Pat,Path,List<Sat.Term>)", "[Core.Pat]listToCons(Core.ListPat)", "[Core.Pat]listToConsRecurse(DataType,List<Core.Pat>)", "[void]addConsTerms(Path,List<Sat.Term>,Core.TuplePat)", "[Sat.Variable]typeConstructorTerm(Path,String)", "[boolean]isCoveredBy(Core.Pat,List<Core.Pat>)"], "method_uris": ["src/main/java/net/hydromatic/morel/compile/PatternCoverageChecker.java.PatternCoverageChecker.[]PatternCoverageChecker(TypeSystem)", "src/main/java/net/hydromatic/morel/compile/PatternCoverageChecker.java.PatternCoverageChecker.[boolean]isCoveredBy(TypeSystem,List<Core.Pat>,Core.Pat)", "src/main/java/net/hydromatic/morel/compile/PatternCoverageChecker.java.PatternCoverageChecker.[boolean]isExhaustive(TypeSystem,List<Core.Pat>)", "src/main/java/net/hydromatic/morel/compile/PatternCoverageChecker.java.PatternCoverageChecker.[Sat.Term]toTerm(Core.Pat)", "src/main/java/net/hydromatic/morel/compile/PatternCoverageChecker.java.PatternCoverageChecker.[void]toTerm(Core.Pat,Path,List<Sat.Term>)", "src/main/java/net/hydromatic/morel/compile/PatternCoverageChecker.java.PatternCoverageChecker.[Core.Pat]listToCons(Core.ListPat)", "src/main/java/net/hydromatic/morel/compile/PatternCoverageChecker.java.PatternCoverageChecker.[Core.Pat]listToConsRecurse(DataType,List<Core.Pat>)", "src/main/java/net/hydromatic/morel/compile/PatternCoverageChecker.java.PatternCoverageChecker.[void]addConsTerms(Path,List<Sat.Term>,Core.TuplePat)", "src/main/java/net/hydromatic/morel/compile/PatternCoverageChecker.java.PatternCoverageChecker.[Sat.Variable]typeConstructorTerm(Path,String)", "src/main/java/net/hydromatic/morel/compile/PatternCoverageChecker.java.PatternCoverageChecker.[boolean]isCoveredBy(Core.Pat,List<Core.Pat>)"], "overrides": null, "attributes": [{"original_string": "  private static class ElideList<E> extends AbstractList<E> {\n    private final List<E> list;\n    private final int elide;\n\n    ElideList(List<E> list, int elide) {\n      this.list = requireNonNull(list, \"list\");\n      this.elide = elide;\n    }\n\n    @Override public E get(int index) {\n      return list.get(index < elide ? index : index + 1);\n    }\n\n    @Override public int size() {\n      return list.size() - 1;\n    }\n  }", "definition": "  private static class ElideList<E> extends AbstractList<E>", "class_docstring": " List that removes one particular element from a backing list.\n\n@param <E> element type", "name": "ElideList", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "fields": [{"attribute_expression": "private final List<E> list;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "List<E>", "name": "list", "syntax_pass": true}, {"attribute_expression": "private final int elide;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "int", "name": "elide", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    ElideList(List<E> list, int elide) {\n      this.list = requireNonNull(list, \"list\");\n      this.elide = elide;\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "ElideList", "params": [{"name": "list", "type": "List<E>"}, {"name": "elide", "type": "int"}], "body": "                                       {\n      this.list = requireNonNull(list, \"list\");\n      this.elide = elide;\n    }", "signature": "ElideList(List<E> list, int elide)"}, {"syntax_pass": true, "original_string": "    @Override public E get(int index) {\n      return list.get(index < elide ? index : index + 1);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "E", "classes": []}, "name": "get", "params": [{"name": "index", "type": "int"}], "body": "                                      {\n      return list.get(index < elide ? index : index + 1);\n    }", "signature": "@Override public E get(int index)"}, {"syntax_pass": true, "original_string": "    @Override public int size() {\n      return list.size() - 1;\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "size", "params": [], "body": "                                {\n      return list.size() - 1;\n    }", "signature": "@Override public int size()"}]}, {"original_string": "  private abstract static class Path {\n    /** Root path. */\n    static final Path ROOT = new Path() {\n      @Override protected void path(StringBuilder b) {\n      }\n    };\n\n    @Override public String toString() {\n      return toVar(\"\");\n    }\n\n    /** Creates a sub-path. */\n    Path sub(int i) {\n      return new SubPath(this, i);\n    }\n\n    /** Converts this to a variable.\n     *\n     * <p>{@code ROOT.sub(2).sub(1).toVar(\"x\")}\n     * will return \"2.1.x\". */\n    String toVar(String name) {\n      final StringBuilder builder = new StringBuilder();\n      path(builder);\n      builder.append(name);\n      return builder.toString();\n    }\n\n    protected abstract void path(StringBuilder b);\n  }", "definition": "  private abstract static class Path", "class_docstring": " Identifies a point in a nested pattern.\n\n<p>Paths are basically immutable lists of integers, built by appending\none element at a time.", "name": "Path", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "private abstract static", "marker_annotations": [], "non_marker_annotations": ["private", "abstract", "static"], "comments": [], "fields": [{"attribute_expression": "static final Path ROOT = new Path() {\n      @Override protected void path(StringBuilder b) {\n      }\n    };", "docstring": " Root path.", "modifiers": "static final", "marker_annotations": [], "non_marker_annotations": ["static", "final"], "comments": [], "type": "Path", "name": "ROOT = new Path() {\n      @Override protected void path(StringBuilder b) {\n      }\n    }", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @Override public String toString() {\n      return toVar(\"\");\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "toString", "params": [], "body": "                                       {\n      return toVar(\"\");\n    }", "signature": "@Override public String toString()"}, {"syntax_pass": true, "original_string": "    Path sub(int i) {\n      return new SubPath(this, i);\n    }", "docstring": " Creates a sub-path.", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "Path", "classes": []}, "name": "sub", "params": [{"name": "i", "type": "int"}], "body": "                    {\n      return new SubPath(this, i);\n    }", "signature": "Path sub(int i)"}, {"syntax_pass": true, "original_string": "    String toVar(String name) {\n      final StringBuilder builder = new StringBuilder();\n      path(builder);\n      builder.append(name);\n      return builder.toString();\n    }", "docstring": " Converts this to a variable.\n\n<p>{@code ROOT.sub(2).sub(1).toVar(\"x\")}\nwill return \"2.1.x\".", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "String", "classes": []}, "name": "toVar", "params": [{"name": "name", "type": "String"}], "body": "                              {\n      final StringBuilder builder = new StringBuilder();\n      path(builder);\n      builder.append(name);\n      return builder.toString();\n    }", "signature": "String toVar(String name)"}, {"syntax_pass": true, "original_string": "    protected abstract void path(StringBuilder b);", "docstring": "", "attributes": {"modifiers": "protected abstract", "marker_annotations": [], "non_marker_annotations": ["protected", "abstract"], "comments": [], "return_type": "void", "classes": []}, "name": "path", "params": [{"name": "b", "type": "StringBuilder"}], "body": "", "signature": "protected abstract void path(StringBuilder b)"}]}, {"original_string": "  private static class SubPath extends Path {\n    final Path parent;\n    final int ordinal;\n\n    SubPath(Path parent, int ordinal) {\n      this.parent = parent;\n      this.ordinal = ordinal;\n    }\n\n    @Override protected void path(StringBuilder b) {\n      parent.path(b);\n      b.append(ordinal).append('.');\n    }\n  }", "definition": "  private static class SubPath extends Path", "class_docstring": " Path that is a child of a given parent path.\nThe {@code ordinal} makes it unique within its parent.\nFor tuple and record patterns, {@code ordinal} is the field ordinal.", "name": "SubPath", "super_interfaces": [], "superclasses": "Path", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "fields": [{"attribute_expression": "final Path parent;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "Path", "name": "parent", "syntax_pass": true}, {"attribute_expression": "final int ordinal;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "int", "name": "ordinal", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    SubPath(Path parent, int ordinal) {\n      this.parent = parent;\n      this.ordinal = ordinal;\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "SubPath", "params": [{"name": "parent", "type": "Path"}, {"name": "ordinal", "type": "int"}], "body": "                                      {\n      this.parent = parent;\n      this.ordinal = ordinal;\n    }", "signature": "SubPath(Path parent, int ordinal)"}, {"syntax_pass": true, "original_string": "    @Override protected void path(StringBuilder b) {\n      parent.path(b);\n      b.append(ordinal).append('.');\n    }", "docstring": "", "attributes": {"modifiers": "@Override protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "name": "path", "params": [{"name": "b", "type": "StringBuilder"}], "body": "                                                   {\n      parent.path(b);\n      b.append(ordinal).append('.');\n    }", "signature": "@Override protected void path(StringBuilder b)"}]}, {"original_string": "  private static class DataTypeSlot {\n    final DataType dataType;\n    final ImmutableMap<String, Sat.Variable> constructorMap;\n\n    DataTypeSlot(DataType dataType, Path path, Sat sat) {\n      this.dataType = dataType;\n      final ImmutableMap.Builder<String, Sat.Variable> b =\n          ImmutableMap.builder();\n      dataType.typeConstructors.forEach((name, type) ->\n          b.put(name, sat.variable(path.toVar(name))));\n      this.constructorMap = b.build();\n    }\n  }", "definition": "  private static class DataTypeSlot", "class_docstring": " Payload of a {@code Sat.Variable} that is an algebraic type.\nThere are sub-variables representing whether the tag holds\neach of its allowed values (each of which is a constructor).", "name": "DataTypeSlot", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "fields": [{"attribute_expression": "final DataType dataType;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "DataType", "name": "dataType", "syntax_pass": true}, {"attribute_expression": "final ImmutableMap<String, Sat.Variable> constructorMap;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "ImmutableMap<String, Sat.Variable>", "name": "constructorMap", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    DataTypeSlot(DataType dataType, Path path, Sat sat) {\n      this.dataType = dataType;\n      final ImmutableMap.Builder<String, Sat.Variable> b =\n          ImmutableMap.builder();\n      dataType.typeConstructors.forEach((name, type) ->\n          b.put(name, sat.variable(path.toVar(name))));\n      this.constructorMap = b.build();\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "DataTypeSlot", "params": [{"name": "dataType", "type": "DataType"}, {"name": "path", "type": "Path"}, {"name": "sat", "type": "Sat"}], "body": "                                                        {\n      this.dataType = dataType;\n      final ImmutableMap.Builder<String, Sat.Variable> b =\n          ImmutableMap.builder();\n      dataType.typeConstructors.forEach((name, type) ->\n          b.put(name, sat.variable(path.toVar(name))));\n      this.constructorMap = b.build();\n    }", "signature": "DataTypeSlot(DataType dataType, Path path, Sat sat)"}]}], "class_docstring": " Checks whether patterns are exhaustive and/or redundant.\n\n<p>The algorithm converts a list of patterns into a boolean formula\nwith several variables, then checks whether the formula is satisfiable\n(that is, whether there is a combination of assignments of boolean values\nto the variables such that the formula evaluates to true).", "original_string": "class PatternCoverageChecker {\n  final TypeSystem typeSystem;\n  final Sat sat = new Sat();\n  final Map<Path, DataTypeSlot> pathSlots = new HashMap<>();\n\n  /** Creates a PatternCoverageChecker. */\n  private PatternCoverageChecker(TypeSystem typeSystem) {\n    this.typeSystem = requireNonNull(typeSystem, \"typeSystem\");\n  }\n\n  /** Returns whether every possible value that could be matched by\n   * pattern {@code pat} would already have been matched by one or more of\n   * {@code prevPatList}.\n   *\n   * <p>For example, the pattern \"(1, b: bool)\" is covered by \"[(1, true),\n   * (_, false)]\" but not by \"[(1, true)]\" or \"[(_, false)]\". */\n  static boolean isCoveredBy(TypeSystem typeSystem, List<Core.Pat> prevPatList,\n      Core.Pat pat) {\n    if (prevPatList.isEmpty()) {\n      return false; // shortcut\n    }\n    // p isCoveredBy [p0 ... pN ]\n    //   iff\n    // (f ^ ~f0 ^ ... ^ ~fN) is not satisfiable\n    //   where f is the formula for p\n    //   and f0 is the formula for p0, etc.\n    return new PatternCoverageChecker(typeSystem).isCoveredBy(pat, prevPatList);\n  }\n\n  /** Returns whether a list of patterns covers every possible value.\n   * If so, any pattern added to this list would be redundant. */\n  @SuppressWarnings(\"StaticPseudoFunctionalStyleMethod\")\n  static boolean isExhaustive(TypeSystem typeSystem, List<Core.Pat> patList) {\n    if (patList.isEmpty()) {\n      return false; // shortcut\n    }\n    if (Iterables.any(patList, p ->\n        p.op == Op.WILDCARD_PAT || p.op == Op.ID_PAT)) {\n      return true; // shortcut\n    }\n    final Core.WildcardPat wildcardPat =\n        core.wildcardPat(patList.get(0).type);\n    return isCoveredBy(typeSystem, patList, wildcardPat);\n  }\n\n  /** Converts a pattern to a logical term. */\n  private Sat.Term toTerm(Core.Pat pat) {\n    final List<Sat.Term> terms = new ArrayList<>();\n    toTerm(pat, Path.ROOT, terms);\n    return terms.size() == 1 ? terms.get(0) : sat.and(terms);\n  }\n\n  private void toTerm(Core.Pat pat, Path path, List<Sat.Term> terms) {\n    switch (pat.op) {\n    case WILDCARD_PAT:\n    case ID_PAT:\n      return; // no constraints to add\n\n    case AS_PAT:\n      toTerm(((Core.AsPat) pat).pat, path, terms);\n      return;\n\n    case BOOL_LITERAL_PAT:\n      // Transform false to FALSE and true to TRUE, constructor of the\n      // internal $bool datatype:\n      //   datatype $bool = FALSE | TRUE\n      // Knowing there are only two values allows us to\n      final DataType boolDataType =\n          (DataType) typeSystem.lookupInternal(\"$bool\");\n      final Core.LiteralPat literalPat0 = (Core.LiteralPat) pat;\n      final Boolean value = (Boolean) literalPat0.value;\n      toTerm(core.con0Pat(boolDataType, value ? \"TRUE\" : \"FALSE\"), path, terms);\n      return;\n\n    case CHAR_LITERAL_PAT:\n    case INT_LITERAL_PAT:\n    case REAL_LITERAL_PAT:\n    case STRING_LITERAL_PAT:\n      final Core.LiteralPat literalPat = (Core.LiteralPat) pat;\n      terms.add(sat.variable(path.toVar(literalPat.value.toString())));\n      return;\n\n    case CON0_PAT:\n      final Core.Con0Pat con0Pat = (Core.Con0Pat) pat;\n      terms.add(typeConstructorTerm(path, con0Pat.tyCon));\n      return;\n\n    case CON_PAT:\n      final Core.ConPat conPat = (Core.ConPat) pat;\n      terms.add(typeConstructorTerm(path, conPat.tyCon));\n      final int j =\n          ImmutableList.copyOf(\n              ((DataType) conPat.type).typeConstructors.keySet())\n              .indexOf(conPat.tyCon);\n      if (j < 0) {\n        throw new AssertionError(\"type constructor not found: \" + conPat);\n      }\n      toTerm(conPat.pat, path.sub(j), terms);\n      return;\n\n    case CONS_PAT:\n      final Core.ConPat consPat = (Core.ConPat) pat;\n      addConsTerms(path, terms, (Core.TuplePat) consPat.pat);\n      return;\n\n    case TUPLE_PAT:\n      final Core.TuplePat tuplePat = (Core.TuplePat) pat;\n      forEachIndexed(tuplePat.args, (pat2, i) ->\n          toTerm(pat2, path.sub(i), terms));\n      return;\n\n    case RECORD_PAT:\n      final Core.RecordPat recordPat = (Core.RecordPat) pat;\n      forEachIndexed(recordPat.args, (pat2, i) ->\n          toTerm(pat2, path.sub(i), terms));\n      return;\n\n    case LIST_PAT:\n      // For list\n      //   [a, b, c]\n      // built terms as if they had written\n      //   CONS (a, CONS (b, CONS (c, NIL))\n      // namely\n      //   var(tag.0=CONS)\n      //   ^ var(tag.0.1=CONS)\n      //   ^ var(tag.0.1.1=CONS)\n      //   ^ var(tag.0.1.1.1=NIL\n      toTerm(listToCons((Core.ListPat) pat), path, terms);\n      return;\n\n    default:\n      throw new AssertionError(pat.op);\n    }\n  }\n\n  /** Converts a list pattern into a pattern made up of the {@code CONS} and\n   * {@code NIL} constructors of the built-in {@code datatype list}.\n   *\n   * <p>For example, converts:\n   * \"[]\" to \"NIL\",\n   * \"[x]\" to \"CONS (x, NIL)\",\n   * \"[x, y]\" to \"CONS (x, CONS (y, NIL))\",\n   * etc. */\n  private Core.Pat listToCons(Core.ListPat listPat) {\n    final Type listType = typeSystem.lookupInternal(\"$list\");\n    final DataType listDataType = (DataType) ((ForallType) listType).type;\n    return listToConsRecurse(listDataType, listPat.args);\n  }\n\n  private Core.Pat listToConsRecurse(DataType listDataType,\n      List<Core.Pat> args) {\n    if (args.isEmpty()) {\n      return core.con0Pat(listDataType, \"NIL\");\n    } else {\n      return core.consPat(listDataType, \"CONS\",\n          core.tuplePat(typeSystem,\n              ImmutableList.of(args.get(0),\n                  listToConsRecurse(listDataType, skip(args)))));\n    }\n  }\n\n  private void addConsTerms(Path path, List<Sat.Term> terms,\n      Core.TuplePat tuplePat) {\n    terms.add(typeConstructorTerm(path, \"CONS\"));\n    toTerm(tuplePat, path, terms);\n  }\n\n  private Sat.Variable typeConstructorTerm(Path path, String con) {\n    final Pair<DataType, Type.Key> pair = typeSystem.lookupTyCon(con);\n    final DataType dataType = pair.left;\n    DataTypeSlot slot =\n        pathSlots.computeIfAbsent(path,\n            p -> new DataTypeSlot(dataType, p, sat));\n    return slot.constructorMap.get(con);\n  }\n\n  /** Returns whether a pattern is covered by a list of patterns.\n   *\n   * <p>A pattern {@code pat} is said to be <dfn>covered by</dfn> a list of\n   * patterns {@code patList} if any possible value would be caught by one of\n   * the patterns in {@code patList} before reaching {@code pat}. Thus\n   * {@code pat} is said to be <dfn>redundant</dfn> in that context, and could\n   * be removed without affecting behavior. */\n  public boolean isCoveredBy(Core.Pat pat, List<Core.Pat> patList) {\n    final List<Sat.Term> terms = new ArrayList<>();\n    patList.forEach(p -> terms.add(toTerm(p)));\n    final Sat.Term term = toTerm(pat);\n\n    final List<Sat.Term> terms1 = new ArrayList<>();\n    terms1.add(term);\n    terms.forEach(t -> terms1.add(sat.not(t)));\n\n    // Add constraints for tags, which are mutually exclusive.\n    // For example, for a type with constructors A, B, C\n    //   (tag=A or tag=B or tag=C)\n    // because at least one tag must be present, and\n    //   (not (tag=A or tag=B)\n    //   or not (tag=B or tag=C)\n    //   or not (tag=C or tag=A))\n    // because at most one tag must be present.\n    pathSlots.values().forEach(slot -> {\n      final List<Sat.Term> terms2 =\n          new ArrayList<>(slot.constructorMap.values());\n      terms1.add(sat.or(terms2));\n\n      final List<Sat.Term> terms3 = new ArrayList<>();\n      for (int i = 0; i < terms2.size(); i++) {\n        terms3.add(sat.not(sat.or(new ElideList<>(terms2, i))));\n      }\n      terms1.add(sat.or(terms3));\n    });\n    final Sat.Term formula = sat.and(terms1);\n    final Map<Sat.Variable, Boolean> solve = sat.solve(formula);\n    return solve == null;\n  }\n\n  /** List that removes one particular element from a backing list.\n   *\n   * @param <E> element type */\n  private static class ElideList<E> extends AbstractList<E> {\n    private final List<E> list;\n    private final int elide;\n\n    ElideList(List<E> list, int elide) {\n      this.list = requireNonNull(list, \"list\");\n      this.elide = elide;\n    }\n\n    @Override public E get(int index) {\n      return list.get(index < elide ? index : index + 1);\n    }\n\n    @Override public int size() {\n      return list.size() - 1;\n    }\n  }\n\n  /** Identifies a point in a nested pattern.\n   *\n   * <p>Paths are basically immutable lists of integers, built by appending\n   * one element at a time. */\n  private abstract static class Path {\n    /** Root path. */\n    static final Path ROOT = new Path() {\n      @Override protected void path(StringBuilder b) {\n      }\n    };\n\n    @Override public String toString() {\n      return toVar(\"\");\n    }\n\n    /** Creates a sub-path. */\n    Path sub(int i) {\n      return new SubPath(this, i);\n    }\n\n    /** Converts this to a variable.\n     *\n     * <p>{@code ROOT.sub(2).sub(1).toVar(\"x\")}\n     * will return \"2.1.x\". */\n    String toVar(String name) {\n      final StringBuilder builder = new StringBuilder();\n      path(builder);\n      builder.append(name);\n      return builder.toString();\n    }\n\n    protected abstract void path(StringBuilder b);\n  }\n\n  /** Path that is a child of a given parent path.\n   * The {@code ordinal} makes it unique within its parent.\n   * For tuple and record patterns, {@code ordinal} is the field ordinal. */\n  private static class SubPath extends Path {\n    final Path parent;\n    final int ordinal;\n\n    SubPath(Path parent, int ordinal) {\n      this.parent = parent;\n      this.ordinal = ordinal;\n    }\n\n    @Override protected void path(StringBuilder b) {\n      parent.path(b);\n      b.append(ordinal).append('.');\n    }\n  }\n\n  /** Payload of a {@code Sat.Variable} that is an algebraic type.\n   * There are sub-variables representing whether the tag holds\n   * each of its allowed values (each of which is a constructor). */\n  private static class DataTypeSlot {\n    final DataType dataType;\n    final ImmutableMap<String, Sat.Variable> constructorMap;\n\n    DataTypeSlot(DataType dataType, Path path, Sat sat) {\n      this.dataType = dataType;\n      final ImmutableMap.Builder<String, Sat.Variable> b =\n          ImmutableMap.builder();\n      dataType.typeConstructors.forEach((name, type) ->\n          b.put(name, sat.variable(path.toVar(name))));\n      this.constructorMap = b.build();\n    }\n  }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "final TypeSystem typeSystem;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "TypeSystem", "name": "typeSystem", "syntax_pass": true}, {"attribute_expression": "final Sat sat = new Sat();", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "Sat", "name": "sat = new Sat()", "syntax_pass": true}, {"attribute_expression": "final Map<Path, DataTypeSlot> pathSlots = new HashMap<>();", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "Map<Path, DataTypeSlot>", "name": "pathSlots = new HashMap<>()", "syntax_pass": true}]}, {"uris": "src/main/java/net/hydromatic/morel/compile/SuchThatShuttle.java.SuchThatShuttle", "name": "SuchThatShuttle", "file_path": "src/main/java/net/hydromatic/morel/compile/SuchThatShuttle.java", "superclasses": "Shuttle", "methods": ["[]SuchThatShuttle(TypeSystem,Environment)", "[boolean]containsUnbounded(Core.Decl)", "[Core.Exp]visit(Core.From)"], "method_uris": ["src/main/java/net/hydromatic/morel/compile/SuchThatShuttle.java.SuchThatShuttle.[]SuchThatShuttle(TypeSystem,Environment)", "src/main/java/net/hydromatic/morel/compile/SuchThatShuttle.java.SuchThatShuttle.[boolean]containsUnbounded(Core.Decl)", "src/main/java/net/hydromatic/morel/compile/SuchThatShuttle.java.SuchThatShuttle.[Core.Exp]visit(Core.From)"], "overrides": null, "attributes": [{"original_string": "  static class FromVisitor {\n    final TypeSystem typeSystem;\n    final FromBuilder fromBuilder;\n    final List<Core.Exp> satisfiedFilters = new ArrayList<>();\n\n    FromVisitor(TypeSystem typeSystem, @Nullable Environment env) {\n      this.typeSystem = typeSystem;\n      this.fromBuilder = core.fromBuilder(typeSystem, env);\n    }\n\n    Core.From visit(Core.From from) {\n      final List<Core.FromStep> steps = from.steps;\n      final DeferredStepList deferredScans =\n          DeferredStepList.create(typeSystem, steps);\n\n      Environment env = Environments.empty();\n      final PairList<Core.IdPat, Core.Exp> idPats = PairList.of();\n      for (int i = 0; i < steps.size(); i++) {\n        final Core.FromStep step = steps.get(i);\n        switch (step.op) {\n        case SCAN:\n          final Core.Scan scan = (Core.Scan) step;\n          if (Extents.isInfinite(scan.exp)) {\n            final int idPatCount = idPats.size();\n            final Core.Exp rewritten = rewrite1(scan, skip(steps, i), idPats);\n\n            // Create a scan for any new variables introduced by rewrite.\n            idPats.forEachIndexed((j, pat, extent) -> {\n              if (j >= idPatCount) {\n                fromBuilder.scan(pat, extent);\n              }\n            });\n            deferredScans.scan(env, scan.pat, rewritten, scan.condition);\n          } else {\n            deferredScans.scan(env, scan.pat, scan.exp);\n          }\n          break;\n\n        case YIELD:\n          final Core.Yield yield = (Core.Yield) step;\n          killTemporaryScans(idPats);\n          deferredScans.flush(fromBuilder);\n          fromBuilder.yield_(false, yield.bindings, yield.exp);\n          break;\n\n        case WHERE:\n          final Core.Where where = (Core.Where) step;\n          Core.Exp condition =\n              core.subTrue(typeSystem, where.exp, satisfiedFilters);\n          deferredScans.where(env, condition);\n          break;\n\n        case GROUP:\n          final Core.Group group = (Core.Group) step;\n          killTemporaryScans(idPats);\n          deferredScans.flush(fromBuilder);\n          fromBuilder.group(group.groupExps, group.aggregates);\n          break;\n\n        case ORDER:\n          final Core.Order order = (Core.Order) step;\n          killTemporaryScans(idPats);\n          deferredScans.flush(fromBuilder);\n          fromBuilder.order(order.orderItems);\n          break;\n\n        default:\n          throw new AssertionError(step.op);\n        }\n        env = Environments.empty().bindAll(step.bindings);\n      }\n      deferredScans.flush(fromBuilder);\n      killTemporaryScans(idPats);\n      return fromBuilder.build();\n    }\n\n    private void killTemporaryScans(PairList<Core.IdPat, Core.Exp> idPats) {\n      if (idPats.isEmpty()) {\n        return;\n      }\n      final PairList<String, Core.Id> nameExps = PairList.of();\n      for (Binding b : fromBuilder.bindings()) {\n        Core.IdPat id = (Core.IdPat) b.id;\n        if (!idPats.leftList().contains(id)) {\n          nameExps.add(id.name, core.id(id));\n        }\n      }\n      if (nameExps.size() == 1) {\n        fromBuilder.yield_(false, null, nameExps.get(0).getValue());\n      } else {\n        fromBuilder.yield_(false, null, core.record(typeSystem, nameExps));\n      }\n      idPats.clear();\n    }\n\n    /** Rewrites an unbounded scan to a {@code from} expression,\n     * using predicates in later steps to determine the ranges of variables. */\n    private Core.From rewrite1(Core.Scan scan,\n        List<? extends Core.FromStep> laterSteps,\n        PairList<Core.IdPat, Core.Exp> idPats) {\n      final Extents.Analysis analysis =\n          Extents.create(typeSystem, scan.pat, ImmutableSortedMap.of(),\n              laterSteps, idPats);\n      satisfiedFilters.addAll(analysis.satisfiedFilters);\n      final FromBuilder fromBuilder = core.fromBuilder(typeSystem);\n      fromBuilder.scan(scan.pat, analysis.extentExp);\n      return fromBuilder.build();\n    }\n  }", "definition": "  static class FromVisitor", "class_docstring": " Workspace for converting unbounded variables in a particular\n{@link Core.From} to bounded scans.", "name": "FromVisitor", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "fields": [{"attribute_expression": "final TypeSystem typeSystem;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "TypeSystem", "name": "typeSystem", "syntax_pass": true}, {"attribute_expression": "final FromBuilder fromBuilder;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "FromBuilder", "name": "fromBuilder", "syntax_pass": true}, {"attribute_expression": "final List<Core.Exp> satisfiedFilters = new ArrayList<>();", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "List<Core.Exp>", "name": "satisfiedFilters = new ArrayList<>()", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    FromVisitor(TypeSystem typeSystem, @Nullable Environment env) {\n      this.typeSystem = typeSystem;\n      this.fromBuilder = core.fromBuilder(typeSystem, env);\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "FromVisitor", "params": [{"name": "typeSystem", "type": "TypeSystem"}, {"name": "env", "type": "Environment"}], "body": "                                                                  {\n      this.typeSystem = typeSystem;\n      this.fromBuilder = core.fromBuilder(typeSystem, env);\n    }", "signature": "FromVisitor(TypeSystem typeSystem, @Nullable Environment env)"}, {"syntax_pass": true, "original_string": "    Core.From visit(Core.From from) {\n      final List<Core.FromStep> steps = from.steps;\n      final DeferredStepList deferredScans =\n          DeferredStepList.create(typeSystem, steps);\n\n      Environment env = Environments.empty();\n      final PairList<Core.IdPat, Core.Exp> idPats = PairList.of();\n      for (int i = 0; i < steps.size(); i++) {\n        final Core.FromStep step = steps.get(i);\n        switch (step.op) {\n        case SCAN:\n          final Core.Scan scan = (Core.Scan) step;\n          if (Extents.isInfinite(scan.exp)) {\n            final int idPatCount = idPats.size();\n            final Core.Exp rewritten = rewrite1(scan, skip(steps, i), idPats);\n\n            // Create a scan for any new variables introduced by rewrite.\n            idPats.forEachIndexed((j, pat, extent) -> {\n              if (j >= idPatCount) {\n                fromBuilder.scan(pat, extent);\n              }\n            });\n            deferredScans.scan(env, scan.pat, rewritten, scan.condition);\n          } else {\n            deferredScans.scan(env, scan.pat, scan.exp);\n          }\n          break;\n\n        case YIELD:\n          final Core.Yield yield = (Core.Yield) step;\n          killTemporaryScans(idPats);\n          deferredScans.flush(fromBuilder);\n          fromBuilder.yield_(false, yield.bindings, yield.exp);\n          break;\n\n        case WHERE:\n          final Core.Where where = (Core.Where) step;\n          Core.Exp condition =\n              core.subTrue(typeSystem, where.exp, satisfiedFilters);\n          deferredScans.where(env, condition);\n          break;\n\n        case GROUP:\n          final Core.Group group = (Core.Group) step;\n          killTemporaryScans(idPats);\n          deferredScans.flush(fromBuilder);\n          fromBuilder.group(group.groupExps, group.aggregates);\n          break;\n\n        case ORDER:\n          final Core.Order order = (Core.Order) step;\n          killTemporaryScans(idPats);\n          deferredScans.flush(fromBuilder);\n          fromBuilder.order(order.orderItems);\n          break;\n\n        default:\n          throw new AssertionError(step.op);\n        }\n        env = Environments.empty().bindAll(step.bindings);\n      }\n      deferredScans.flush(fromBuilder);\n      killTemporaryScans(idPats);\n      return fromBuilder.build();\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "Core.From", "classes": []}, "name": "visit", "params": [{"name": "from", "type": "Core.From"}], "body": "                                    {\n      final List<Core.FromStep> steps = from.steps;\n      final DeferredStepList deferredScans =\n          DeferredStepList.create(typeSystem, steps);\n\n      Environment env = Environments.empty();\n      final PairList<Core.IdPat, Core.Exp> idPats = PairList.of();\n      for (int i = 0; i < steps.size(); i++) {\n        final Core.FromStep step = steps.get(i);\n        switch (step.op) {\n        case SCAN:\n          final Core.Scan scan = (Core.Scan) step;\n          if (Extents.isInfinite(scan.exp)) {\n            final int idPatCount = idPats.size();\n            final Core.Exp rewritten = rewrite1(scan, skip(steps, i), idPats);\n\n            // Create a scan for any new variables introduced by rewrite.\n            idPats.forEachIndexed((j, pat, extent) -> {\n              if (j >= idPatCount) {\n                fromBuilder.scan(pat, extent);\n              }\n            });\n            deferredScans.scan(env, scan.pat, rewritten, scan.condition);\n          } else {\n            deferredScans.scan(env, scan.pat, scan.exp);\n          }\n          break;\n\n        case YIELD:\n          final Core.Yield yield = (Core.Yield) step;\n          killTemporaryScans(idPats);\n          deferredScans.flush(fromBuilder);\n          fromBuilder.yield_(false, yield.bindings, yield.exp);\n          break;\n\n        case WHERE:\n          final Core.Where where = (Core.Where) step;\n          Core.Exp condition =\n              core.subTrue(typeSystem, where.exp, satisfiedFilters);\n          deferredScans.where(env, condition);\n          break;\n\n        case GROUP:\n          final Core.Group group = (Core.Group) step;\n          killTemporaryScans(idPats);\n          deferredScans.flush(fromBuilder);\n          fromBuilder.group(group.groupExps, group.aggregates);\n          break;\n\n        case ORDER:\n          final Core.Order order = (Core.Order) step;\n          killTemporaryScans(idPats);\n          deferredScans.flush(fromBuilder);\n          fromBuilder.order(order.orderItems);\n          break;\n\n        default:\n          throw new AssertionError(step.op);\n        }\n        env = Environments.empty().bindAll(step.bindings);\n      }\n      deferredScans.flush(fromBuilder);\n      killTemporaryScans(idPats);\n      return fromBuilder.build();\n    }", "signature": "Core.From visit(Core.From from)"}, {"syntax_pass": true, "original_string": "    private void killTemporaryScans(PairList<Core.IdPat, Core.Exp> idPats) {\n      if (idPats.isEmpty()) {\n        return;\n      }\n      final PairList<String, Core.Id> nameExps = PairList.of();\n      for (Binding b : fromBuilder.bindings()) {\n        Core.IdPat id = (Core.IdPat) b.id;\n        if (!idPats.leftList().contains(id)) {\n          nameExps.add(id.name, core.id(id));\n        }\n      }\n      if (nameExps.size() == 1) {\n        fromBuilder.yield_(false, null, nameExps.get(0).getValue());\n      } else {\n        fromBuilder.yield_(false, null, core.record(typeSystem, nameExps));\n      }\n      idPats.clear();\n    }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "name": "killTemporaryScans", "params": [{"name": "idPats", "type": "PairList<Core.IdPat, Core.Exp>"}], "body": "                                                                           {\n      if (idPats.isEmpty()) {\n        return;\n      }\n      final PairList<String, Core.Id> nameExps = PairList.of();\n      for (Binding b : fromBuilder.bindings()) {\n        Core.IdPat id = (Core.IdPat) b.id;\n        if (!idPats.leftList().contains(id)) {\n          nameExps.add(id.name, core.id(id));\n        }\n      }\n      if (nameExps.size() == 1) {\n        fromBuilder.yield_(false, null, nameExps.get(0).getValue());\n      } else {\n        fromBuilder.yield_(false, null, core.record(typeSystem, nameExps));\n      }\n      idPats.clear();\n    }", "signature": "private void killTemporaryScans(PairList<Core.IdPat, Core.Exp> idPats)"}, {"syntax_pass": true, "original_string": "    private Core.From rewrite1(Core.Scan scan,\n        List<? extends Core.FromStep> laterSteps,\n        PairList<Core.IdPat, Core.Exp> idPats) {\n      final Extents.Analysis analysis =\n          Extents.create(typeSystem, scan.pat, ImmutableSortedMap.of(),\n              laterSteps, idPats);\n      satisfiedFilters.addAll(analysis.satisfiedFilters);\n      final FromBuilder fromBuilder = core.fromBuilder(typeSystem);\n      fromBuilder.scan(scan.pat, analysis.extentExp);\n      return fromBuilder.build();\n    }", "docstring": " Rewrites an unbounded scan to a {@code from} expression,\nusing predicates in later steps to determine the ranges of variables.", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "Core.From", "classes": []}, "name": "rewrite1", "params": [{"name": "scan", "type": "Core.Scan"}, {"name": "laterSteps", "type": "List<? extends Core.FromStep>"}, {"name": "idPats", "type": "PairList<Core.IdPat, Core.Exp>"}], "body": "                                               {\n      final Extents.Analysis analysis =\n          Extents.create(typeSystem, scan.pat, ImmutableSortedMap.of(),\n              laterSteps, idPats);\n      satisfiedFilters.addAll(analysis.satisfiedFilters);\n      final FromBuilder fromBuilder = core.fromBuilder(typeSystem);\n      fromBuilder.scan(scan.pat, analysis.extentExp);\n      return fromBuilder.build();\n    }", "signature": "private Core.From rewrite1(Core.Scan scan,\n        List<? extends Core.FromStep> laterSteps,\n        PairList<Core.IdPat, Core.Exp> idPats)"}]}, {"original_string": "  static class DeferredStepList {\n    final PairList<Set<Core.Pat>, Consumer<FromBuilder>> steps = PairList.of();\n    final FreeFinder freeFinder;\n    final List<Core.NamedPat> refs;\n\n    DeferredStepList(FreeFinder freeFinder, List<Core.NamedPat> refs) {\n      this.freeFinder = freeFinder;\n      this.refs = refs;\n    }\n\n    static DeferredStepList create(TypeSystem typeSystem,\n        List<Core.FromStep> steps) {\n      final ImmutableSet<Core.Pat> forwardRefs =\n          steps.stream()\n              .filter(step -> step instanceof Core.Scan)\n              .map(step -> ((Core.Scan) step).pat)\n              .collect(toImmutableSet());\n      final List<Core.NamedPat> refs = new ArrayList<>();\n      final Consumer<Core.NamedPat> consumer = p -> {\n        if (forwardRefs.contains(p)) {\n          refs.add(p);\n        }\n      };\n      final FreeFinder freeFinder =\n          new FreeFinder(typeSystem, Environments.empty(),\n              new ArrayDeque<>(), consumer);\n      return new DeferredStepList(freeFinder, refs);\n    }\n\n    void scan(Environment env, Core.Pat pat, Core.Exp exp, Core.Exp condition) {\n      final Set<Core.Pat> unresolvedRefs = unresolvedRefs(env, exp);\n      steps.add(unresolvedRefs, fromBuilder -> {\n        fromBuilder.scan(pat, exp, condition);\n        resolve(pat);\n      });\n    }\n\n    void scan(Environment env, Core.Pat pat, Core.Exp exp) {\n      final Set<Core.Pat> unresolvedRefs = unresolvedRefs(env, exp);\n      steps.add(unresolvedRefs, fromBuilder -> {\n        fromBuilder.scan(pat, exp);\n        resolve(pat);\n      });\n    }\n\n    void where(Environment env, Core.Exp condition) {\n      final Set<Core.Pat> unresolvedRefs = unresolvedRefs(env, condition);\n      steps.add(unresolvedRefs,\n          fromBuilder -> fromBuilder.where(condition));\n    }\n\n    private Set<Core.Pat> unresolvedRefs(Environment env, Core.Exp exp) {\n      refs.clear();\n      exp.accept(freeFinder.push(env));\n      return new LinkedHashSet<>(refs);\n    }\n\n    /** Marks that a pattern has now been defined.\n     *\n     * <p>After this method, it is possible that some steps might have no\n     * unresolved references. Those steps are now ready to add to the\n     * builder. */\n    void resolve(Core.Pat pat) {\n      steps.forEach((unresolvedRefs, consumer) -> unresolvedRefs.remove(pat));\n    }\n\n    void flush(FromBuilder fromBuilder) {\n      // Are there any scans that had forward references previously but\n      // whose references are now all satisfied? Add them to the builder.\n      for (;;) {\n        int j = steps.firstMatch((unresolvedRefs, consumer) ->\n            unresolvedRefs.isEmpty());\n        if (j < 0) {\n          break;\n        }\n        final Map.Entry<Set<Core.Pat>, Consumer<FromBuilder>> step =\n            steps.remove(j);\n        step.getValue().accept(fromBuilder);\n      }\n    }\n  }", "definition": "  static class DeferredStepList", "class_docstring": " Maintains a list of steps that have not been applied yet.\n\n<p>Holds the state necessary for a classic topological sort algorithm:\nFor each node, keep the list of unresolved forward references.\nAfter each reference is resolved, remove it from each node's list.\nOutput each node as its unresolved list becomes empty.\nThe topological sort is stable.\n", "name": "DeferredStepList", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "fields": [{"attribute_expression": "final PairList<Set<Core.Pat>, Consumer<FromBuilder>> steps = PairList.of();", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "PairList<Set<Core.Pat>, Consumer<FromBuilder>>", "name": "steps = PairList.of()", "syntax_pass": true}, {"attribute_expression": "final FreeFinder freeFinder;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "FreeFinder", "name": "freeFinder", "syntax_pass": true}, {"attribute_expression": "final List<Core.NamedPat> refs;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "List<Core.NamedPat>", "name": "refs", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    DeferredStepList(FreeFinder freeFinder, List<Core.NamedPat> refs) {\n      this.freeFinder = freeFinder;\n      this.refs = refs;\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "DeferredStepList", "params": [{"name": "freeFinder", "type": "FreeFinder"}, {"name": "refs", "type": "List<Core.NamedPat>"}], "body": "                                                                      {\n      this.freeFinder = freeFinder;\n      this.refs = refs;\n    }", "signature": "DeferredStepList(FreeFinder freeFinder, List<Core.NamedPat> refs)"}, {"syntax_pass": true, "original_string": "    static DeferredStepList create(TypeSystem typeSystem,\n        List<Core.FromStep> steps) {\n      final ImmutableSet<Core.Pat> forwardRefs =\n          steps.stream()\n              .filter(step -> step instanceof Core.Scan)\n              .map(step -> ((Core.Scan) step).pat)\n              .collect(toImmutableSet());\n      final List<Core.NamedPat> refs = new ArrayList<>();\n      final Consumer<Core.NamedPat> consumer = p -> {\n        if (forwardRefs.contains(p)) {\n          refs.add(p);\n        }\n      };\n      final FreeFinder freeFinder =\n          new FreeFinder(typeSystem, Environments.empty(),\n              new ArrayDeque<>(), consumer);\n      return new DeferredStepList(freeFinder, refs);\n    }", "docstring": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "DeferredStepList", "classes": []}, "name": "create", "params": [{"name": "typeSystem", "type": "TypeSystem"}, {"name": "steps", "type": "List<Core.FromStep>"}], "body": "                                   {\n      final ImmutableSet<Core.Pat> forwardRefs =\n          steps.stream()\n              .filter(step -> step instanceof Core.Scan)\n              .map(step -> ((Core.Scan) step).pat)\n              .collect(toImmutableSet());\n      final List<Core.NamedPat> refs = new ArrayList<>();\n      final Consumer<Core.NamedPat> consumer = p -> {\n        if (forwardRefs.contains(p)) {\n          refs.add(p);\n        }\n      };\n      final FreeFinder freeFinder =\n          new FreeFinder(typeSystem, Environments.empty(),\n              new ArrayDeque<>(), consumer);\n      return new DeferredStepList(freeFinder, refs);\n    }", "signature": "static DeferredStepList create(TypeSystem typeSystem,\n        List<Core.FromStep> steps)"}, {"syntax_pass": true, "original_string": "    void scan(Environment env, Core.Pat pat, Core.Exp exp, Core.Exp condition) {\n      final Set<Core.Pat> unresolvedRefs = unresolvedRefs(env, exp);\n      steps.add(unresolvedRefs, fromBuilder -> {\n        fromBuilder.scan(pat, exp, condition);\n        resolve(pat);\n      });\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "name": "scan", "params": [{"name": "env", "type": "Environment"}, {"name": "pat", "type": "Core.Pat"}, {"name": "exp", "type": "Core.Exp"}, {"name": "condition", "type": "Core.Exp"}], "body": "                                                                               {\n      final Set<Core.Pat> unresolvedRefs = unresolvedRefs(env, exp);\n      steps.add(unresolvedRefs, fromBuilder -> {\n        fromBuilder.scan(pat, exp, condition);\n        resolve(pat);\n      });\n    }", "signature": "void scan(Environment env, Core.Pat pat, Core.Exp exp, Core.Exp condition)"}, {"syntax_pass": true, "original_string": "    void scan(Environment env, Core.Pat pat, Core.Exp exp) {\n      final Set<Core.Pat> unresolvedRefs = unresolvedRefs(env, exp);\n      steps.add(unresolvedRefs, fromBuilder -> {\n        fromBuilder.scan(pat, exp);\n        resolve(pat);\n      });\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "name": "scan", "params": [{"name": "env", "type": "Environment"}, {"name": "pat", "type": "Core.Pat"}, {"name": "exp", "type": "Core.Exp"}], "body": "                                                           {\n      final Set<Core.Pat> unresolvedRefs = unresolvedRefs(env, exp);\n      steps.add(unresolvedRefs, fromBuilder -> {\n        fromBuilder.scan(pat, exp);\n        resolve(pat);\n      });\n    }", "signature": "void scan(Environment env, Core.Pat pat, Core.Exp exp)"}, {"syntax_pass": true, "original_string": "    void where(Environment env, Core.Exp condition) {\n      final Set<Core.Pat> unresolvedRefs = unresolvedRefs(env, condition);\n      steps.add(unresolvedRefs,\n          fromBuilder -> fromBuilder.where(condition));\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "name": "where", "params": [{"name": "env", "type": "Environment"}, {"name": "condition", "type": "Core.Exp"}], "body": "                                                    {\n      final Set<Core.Pat> unresolvedRefs = unresolvedRefs(env, condition);\n      steps.add(unresolvedRefs,\n          fromBuilder -> fromBuilder.where(condition));\n    }", "signature": "void where(Environment env, Core.Exp condition)"}, {"syntax_pass": true, "original_string": "    private Set<Core.Pat> unresolvedRefs(Environment env, Core.Exp exp) {\n      refs.clear();\n      exp.accept(freeFinder.push(env));\n      return new LinkedHashSet<>(refs);\n    }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "Set<Core.Pat>", "classes": []}, "name": "unresolvedRefs", "params": [{"name": "env", "type": "Environment"}, {"name": "exp", "type": "Core.Exp"}], "body": "                                                                        {\n      refs.clear();\n      exp.accept(freeFinder.push(env));\n      return new LinkedHashSet<>(refs);\n    }", "signature": "private Set<Core.Pat> unresolvedRefs(Environment env, Core.Exp exp)"}, {"syntax_pass": true, "original_string": "    void resolve(Core.Pat pat) {\n      steps.forEach((unresolvedRefs, consumer) -> unresolvedRefs.remove(pat));\n    }", "docstring": " Marks that a pattern has now been defined.\n\n<p>After this method, it is possible that some steps might have no\nunresolved references. Those steps are now ready to add to the\nbuilder.", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "name": "resolve", "params": [{"name": "pat", "type": "Core.Pat"}], "body": "                               {\n      steps.forEach((unresolvedRefs, consumer) -> unresolvedRefs.remove(pat));\n    }", "signature": "void resolve(Core.Pat pat)"}, {"syntax_pass": true, "original_string": "    void flush(FromBuilder fromBuilder) {\n      // Are there any scans that had forward references previously but\n      // whose references are now all satisfied? Add them to the builder.\n      for (;;) {\n        int j = steps.firstMatch((unresolvedRefs, consumer) ->\n            unresolvedRefs.isEmpty());\n        if (j < 0) {\n          break;\n        }\n        final Map.Entry<Set<Core.Pat>, Consumer<FromBuilder>> step =\n            steps.remove(j);\n        step.getValue().accept(fromBuilder);\n      }\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "name": "flush", "params": [{"name": "fromBuilder", "type": "FromBuilder"}], "body": "                                        {\n      // Are there any scans that had forward references previously but\n      // whose references are now all satisfied? Add them to the builder.\n      for (;;) {\n        int j = steps.firstMatch((unresolvedRefs, consumer) ->\n            unresolvedRefs.isEmpty());\n        if (j < 0) {\n          break;\n        }\n        final Map.Entry<Set<Core.Pat>, Consumer<FromBuilder>> step =\n            steps.remove(j);\n        step.getValue().accept(fromBuilder);\n      }\n    }", "signature": "void flush(FromBuilder fromBuilder)"}]}, {"original_string": "  private static class FreeFinder extends EnvVisitor {\n    final Consumer<Core.NamedPat> consumer;\n\n    FreeFinder(TypeSystem typeSystem, Environment env,\n        Deque<FromContext> fromStack, Consumer<Core.NamedPat> consumer) {\n      super(typeSystem, env, fromStack);\n      this.consumer = consumer;\n    }\n\n    @Override protected EnvVisitor push(Environment env) {\n      return new FreeFinder(typeSystem, env, fromStack, consumer);\n    }\n\n    @Override protected void visit(Core.Id id) {\n      if (env.getOpt(id.idPat) == null) {\n        consumer.accept(id.idPat);\n      }\n    }\n  }", "definition": "  private static class FreeFinder extends EnvVisitor", "class_docstring": " Finds free variables in an expression.", "name": "FreeFinder", "super_interfaces": [], "superclasses": "EnvVisitor", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "fields": [{"attribute_expression": "final Consumer<Core.NamedPat> consumer;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "Consumer<Core.NamedPat>", "name": "consumer", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    FreeFinder(TypeSystem typeSystem, Environment env,\n        Deque<FromContext> fromStack, Consumer<Core.NamedPat> consumer) {\n      super(typeSystem, env, fromStack);\n      this.consumer = consumer;\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "FreeFinder", "params": [{"name": "typeSystem", "type": "TypeSystem"}, {"name": "env", "type": "Environment"}, {"name": "fromStack", "type": "Deque<FromContext>"}, {"name": "consumer", "type": "Consumer<Core.NamedPat>"}], "body": "                                                                        {\n      super(typeSystem, env, fromStack);\n      this.consumer = consumer;\n    }", "signature": "FreeFinder(TypeSystem typeSystem, Environment env,\n        Deque<FromContext> fromStack, Consumer<Core.NamedPat> consumer)"}, {"syntax_pass": true, "original_string": "    @Override protected EnvVisitor push(Environment env) {\n      return new FreeFinder(typeSystem, env, fromStack, consumer);\n    }", "docstring": "", "attributes": {"modifiers": "@Override protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "EnvVisitor", "classes": []}, "name": "push", "params": [{"name": "env", "type": "Environment"}], "body": "                                                         {\n      return new FreeFinder(typeSystem, env, fromStack, consumer);\n    }", "signature": "@Override protected EnvVisitor push(Environment env)"}, {"syntax_pass": true, "original_string": "    @Override protected void visit(Core.Id id) {\n      if (env.getOpt(id.idPat) == null) {\n        consumer.accept(id.idPat);\n      }\n    }", "docstring": "", "attributes": {"modifiers": "@Override protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "name": "visit", "params": [{"name": "id", "type": "Core.Id"}], "body": "                                               {\n      if (env.getOpt(id.idPat) == null) {\n        consumer.accept(id.idPat);\n      }\n    }", "signature": "@Override protected void visit(Core.Id id)"}]}], "class_docstring": "\nConverts unbounded variables to bounded variables.\n\n<p>For example, converts\n\n<blockquote><pre>{@code\nfrom e\n  where e elem #dept scott\n}</pre></blockquote>\n\n<p>to\n\n<blockquote><pre>{@code\nfrom e in #dept scott\n}</pre></blockquote>\n", "original_string": "class SuchThatShuttle extends Shuttle {\n  final @Nullable Environment env;\n\n  SuchThatShuttle(TypeSystem typeSystem, @Nullable Environment env) {\n    super(typeSystem);\n    this.env = env;\n  }\n\n  static boolean containsUnbounded(Core.Decl decl) {\n    final Holder<Boolean> found = Holder.of(false);\n    decl.accept(new Visitor() {\n      @Override protected void visit(Core.Scan scan) {\n        super.visit(scan);\n        if (Extents.isInfinite(scan.exp)) {\n          found.set(true);\n        }\n      }\n    });\n    return found.get();\n  }\n\n  @Override protected Core.Exp visit(Core.From from) {\n    final Core.From from2 = new FromVisitor(typeSystem, env).visit(from);\n    return from2.equals(from) ? from : from2;\n  }\n\n  /** Workspace for converting unbounded variables in a particular\n   * {@link Core.From} to bounded scans. */\n  static class FromVisitor {\n    final TypeSystem typeSystem;\n    final FromBuilder fromBuilder;\n    final List<Core.Exp> satisfiedFilters = new ArrayList<>();\n\n    FromVisitor(TypeSystem typeSystem, @Nullable Environment env) {\n      this.typeSystem = typeSystem;\n      this.fromBuilder = core.fromBuilder(typeSystem, env);\n    }\n\n    Core.From visit(Core.From from) {\n      final List<Core.FromStep> steps = from.steps;\n      final DeferredStepList deferredScans =\n          DeferredStepList.create(typeSystem, steps);\n\n      Environment env = Environments.empty();\n      final PairList<Core.IdPat, Core.Exp> idPats = PairList.of();\n      for (int i = 0; i < steps.size(); i++) {\n        final Core.FromStep step = steps.get(i);\n        switch (step.op) {\n        case SCAN:\n          final Core.Scan scan = (Core.Scan) step;\n          if (Extents.isInfinite(scan.exp)) {\n            final int idPatCount = idPats.size();\n            final Core.Exp rewritten = rewrite1(scan, skip(steps, i), idPats);\n\n            // Create a scan for any new variables introduced by rewrite.\n            idPats.forEachIndexed((j, pat, extent) -> {\n              if (j >= idPatCount) {\n                fromBuilder.scan(pat, extent);\n              }\n            });\n            deferredScans.scan(env, scan.pat, rewritten, scan.condition);\n          } else {\n            deferredScans.scan(env, scan.pat, scan.exp);\n          }\n          break;\n\n        case YIELD:\n          final Core.Yield yield = (Core.Yield) step;\n          killTemporaryScans(idPats);\n          deferredScans.flush(fromBuilder);\n          fromBuilder.yield_(false, yield.bindings, yield.exp);\n          break;\n\n        case WHERE:\n          final Core.Where where = (Core.Where) step;\n          Core.Exp condition =\n              core.subTrue(typeSystem, where.exp, satisfiedFilters);\n          deferredScans.where(env, condition);\n          break;\n\n        case GROUP:\n          final Core.Group group = (Core.Group) step;\n          killTemporaryScans(idPats);\n          deferredScans.flush(fromBuilder);\n          fromBuilder.group(group.groupExps, group.aggregates);\n          break;\n\n        case ORDER:\n          final Core.Order order = (Core.Order) step;\n          killTemporaryScans(idPats);\n          deferredScans.flush(fromBuilder);\n          fromBuilder.order(order.orderItems);\n          break;\n\n        default:\n          throw new AssertionError(step.op);\n        }\n        env = Environments.empty().bindAll(step.bindings);\n      }\n      deferredScans.flush(fromBuilder);\n      killTemporaryScans(idPats);\n      return fromBuilder.build();\n    }\n\n    private void killTemporaryScans(PairList<Core.IdPat, Core.Exp> idPats) {\n      if (idPats.isEmpty()) {\n        return;\n      }\n      final PairList<String, Core.Id> nameExps = PairList.of();\n      for (Binding b : fromBuilder.bindings()) {\n        Core.IdPat id = (Core.IdPat) b.id;\n        if (!idPats.leftList().contains(id)) {\n          nameExps.add(id.name, core.id(id));\n        }\n      }\n      if (nameExps.size() == 1) {\n        fromBuilder.yield_(false, null, nameExps.get(0).getValue());\n      } else {\n        fromBuilder.yield_(false, null, core.record(typeSystem, nameExps));\n      }\n      idPats.clear();\n    }\n\n    /** Rewrites an unbounded scan to a {@code from} expression,\n     * using predicates in later steps to determine the ranges of variables. */\n    private Core.From rewrite1(Core.Scan scan,\n        List<? extends Core.FromStep> laterSteps,\n        PairList<Core.IdPat, Core.Exp> idPats) {\n      final Extents.Analysis analysis =\n          Extents.create(typeSystem, scan.pat, ImmutableSortedMap.of(),\n              laterSteps, idPats);\n      satisfiedFilters.addAll(analysis.satisfiedFilters);\n      final FromBuilder fromBuilder = core.fromBuilder(typeSystem);\n      fromBuilder.scan(scan.pat, analysis.extentExp);\n      return fromBuilder.build();\n    }\n  }\n\n  /** Maintains a list of steps that have not been applied yet.\n   *\n   * <p>Holds the state necessary for a classic topological sort algorithm:\n   * For each node, keep the list of unresolved forward references.\n   * After each reference is resolved, remove it from each node's list.\n   * Output each node as its unresolved list becomes empty.\n   * The topological sort is stable.\n   */\n  static class DeferredStepList {\n    final PairList<Set<Core.Pat>, Consumer<FromBuilder>> steps = PairList.of();\n    final FreeFinder freeFinder;\n    final List<Core.NamedPat> refs;\n\n    DeferredStepList(FreeFinder freeFinder, List<Core.NamedPat> refs) {\n      this.freeFinder = freeFinder;\n      this.refs = refs;\n    }\n\n    static DeferredStepList create(TypeSystem typeSystem,\n        List<Core.FromStep> steps) {\n      final ImmutableSet<Core.Pat> forwardRefs =\n          steps.stream()\n              .filter(step -> step instanceof Core.Scan)\n              .map(step -> ((Core.Scan) step).pat)\n              .collect(toImmutableSet());\n      final List<Core.NamedPat> refs = new ArrayList<>();\n      final Consumer<Core.NamedPat> consumer = p -> {\n        if (forwardRefs.contains(p)) {\n          refs.add(p);\n        }\n      };\n      final FreeFinder freeFinder =\n          new FreeFinder(typeSystem, Environments.empty(),\n              new ArrayDeque<>(), consumer);\n      return new DeferredStepList(freeFinder, refs);\n    }\n\n    void scan(Environment env, Core.Pat pat, Core.Exp exp, Core.Exp condition) {\n      final Set<Core.Pat> unresolvedRefs = unresolvedRefs(env, exp);\n      steps.add(unresolvedRefs, fromBuilder -> {\n        fromBuilder.scan(pat, exp, condition);\n        resolve(pat);\n      });\n    }\n\n    void scan(Environment env, Core.Pat pat, Core.Exp exp) {\n      final Set<Core.Pat> unresolvedRefs = unresolvedRefs(env, exp);\n      steps.add(unresolvedRefs, fromBuilder -> {\n        fromBuilder.scan(pat, exp);\n        resolve(pat);\n      });\n    }\n\n    void where(Environment env, Core.Exp condition) {\n      final Set<Core.Pat> unresolvedRefs = unresolvedRefs(env, condition);\n      steps.add(unresolvedRefs,\n          fromBuilder -> fromBuilder.where(condition));\n    }\n\n    private Set<Core.Pat> unresolvedRefs(Environment env, Core.Exp exp) {\n      refs.clear();\n      exp.accept(freeFinder.push(env));\n      return new LinkedHashSet<>(refs);\n    }\n\n    /** Marks that a pattern has now been defined.\n     *\n     * <p>After this method, it is possible that some steps might have no\n     * unresolved references. Those steps are now ready to add to the\n     * builder. */\n    void resolve(Core.Pat pat) {\n      steps.forEach((unresolvedRefs, consumer) -> unresolvedRefs.remove(pat));\n    }\n\n    void flush(FromBuilder fromBuilder) {\n      // Are there any scans that had forward references previously but\n      // whose references are now all satisfied? Add them to the builder.\n      for (;;) {\n        int j = steps.firstMatch((unresolvedRefs, consumer) ->\n            unresolvedRefs.isEmpty());\n        if (j < 0) {\n          break;\n        }\n        final Map.Entry<Set<Core.Pat>, Consumer<FromBuilder>> step =\n            steps.remove(j);\n        step.getValue().accept(fromBuilder);\n      }\n    }\n  }\n\n  /** Finds free variables in an expression. */\n  private static class FreeFinder extends EnvVisitor {\n    final Consumer<Core.NamedPat> consumer;\n\n    FreeFinder(TypeSystem typeSystem, Environment env,\n        Deque<FromContext> fromStack, Consumer<Core.NamedPat> consumer) {\n      super(typeSystem, env, fromStack);\n      this.consumer = consumer;\n    }\n\n    @Override protected EnvVisitor push(Environment env) {\n      return new FreeFinder(typeSystem, env, fromStack, consumer);\n    }\n\n    @Override protected void visit(Core.Id id) {\n      if (env.getOpt(id.idPat) == null) {\n        consumer.accept(id.idPat);\n      }\n    }\n  }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "final @Nullable Environment env;", "docstring": "", "modifiers": "final @Nullable", "marker_annotations": ["@Nullable"], "non_marker_annotations": ["final"], "comments": [], "type": "Environment", "name": "env", "syntax_pass": true}]}, {"uris": "src/main/java/net/hydromatic/morel/compile/Pretty.java.Pretty", "name": "Pretty", "file_path": "src/main/java/net/hydromatic/morel/compile/Pretty.java", "superclasses": "", "methods": ["[]Pretty(TypeSystem,int,int,int,int)", "[StringBuilder]pretty(StringBuilder,Type,Object)", "[StringBuilder]pretty1(StringBuilder,int,int[],int,Type,Object,int,int)", "[void]indent(StringBuilder,int)", "[StringBuilder]pretty2(StringBuilder,int,int[],int,Type,Object,int,int)", "[StringBuilder]prettyType(StringBuilder,int,int[],int,Type,TypeVal,int,int)", "[List<Object>]toList(Object)", "[Type]unqualified(Type)", "[StringBuilder]printList(StringBuilder,int,int[],int,Type,List<Object>)"], "method_uris": ["src/main/java/net/hydromatic/morel/compile/Pretty.java.Pretty.[]Pretty(TypeSystem,int,int,int,int)", "src/main/java/net/hydromatic/morel/compile/Pretty.java.Pretty.[StringBuilder]pretty(StringBuilder,Type,Object)", "src/main/java/net/hydromatic/morel/compile/Pretty.java.Pretty.[StringBuilder]pretty1(StringBuilder,int,int[],int,Type,Object,int,int)", "src/main/java/net/hydromatic/morel/compile/Pretty.java.Pretty.[void]indent(StringBuilder,int)", "src/main/java/net/hydromatic/morel/compile/Pretty.java.Pretty.[StringBuilder]pretty2(StringBuilder,int,int[],int,Type,Object,int,int)", "src/main/java/net/hydromatic/morel/compile/Pretty.java.Pretty.[StringBuilder]prettyType(StringBuilder,int,int[],int,Type,TypeVal,int,int)", "src/main/java/net/hydromatic/morel/compile/Pretty.java.Pretty.[List<Object>]toList(Object)", "src/main/java/net/hydromatic/morel/compile/Pretty.java.Pretty.[Type]unqualified(Type)", "src/main/java/net/hydromatic/morel/compile/Pretty.java.Pretty.[StringBuilder]printList(StringBuilder,int,int[],int,Type,List<Object>)"], "overrides": null, "attributes": [{"original_string": "  static class TypedVal {\n    final String name;\n    final Object o;\n    final Type type;\n\n    TypedVal(String name, Object o, Type type) {\n      this.name = name;\n      this.o = o;\n      this.type = type;\n    }\n  }", "definition": "  static class TypedVal", "class_docstring": " Wrapper that indicates that a value should be printed\n\"val name = value : type\".", "name": "TypedVal", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "fields": [{"attribute_expression": "final String name;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "String", "name": "name", "syntax_pass": true}, {"attribute_expression": "final Object o;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "Object", "name": "o", "syntax_pass": true}, {"attribute_expression": "final Type type;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "Type", "name": "type", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    TypedVal(String name, Object o, Type type) {\n      this.name = name;\n      this.o = o;\n      this.type = type;\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "TypedVal", "params": [{"name": "name", "type": "String"}, {"name": "o", "type": "Object"}, {"name": "type", "type": "Type"}], "body": "                                               {\n      this.name = name;\n      this.o = o;\n      this.type = type;\n    }", "signature": "TypedVal(String name, Object o, Type type)"}]}, {"original_string": "  private static class NamedVal {\n    final String name;\n    final Object o;\n\n    NamedVal(String name, Object o) {\n      this.name = name;\n      this.o = o;\n    }\n  }", "definition": "  private static class NamedVal", "class_docstring": " Wrapper that indicates that a value should be printed \"name = value\".", "name": "NamedVal", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "fields": [{"attribute_expression": "final String name;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "String", "name": "name", "syntax_pass": true}, {"attribute_expression": "final Object o;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "Object", "name": "o", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    NamedVal(String name, Object o) {\n      this.name = name;\n      this.o = o;\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "NamedVal", "params": [{"name": "name", "type": "String"}, {"name": "o", "type": "Object"}], "body": "                                    {\n      this.name = name;\n      this.o = o;\n    }", "signature": "NamedVal(String name, Object o)"}]}, {"original_string": "  private static class LabelVal {\n    final String label;\n    final Type type;\n\n    LabelVal(String label, Type type) {\n      this.label = label;\n      this.type = type;\n    }\n  }", "definition": "  private static class LabelVal", "class_docstring": " Wrapper that indicates that a value should be printed \"label:type\".", "name": "LabelVal", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "fields": [{"attribute_expression": "final String label;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "String", "name": "label", "syntax_pass": true}, {"attribute_expression": "final Type type;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "Type", "name": "type", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    LabelVal(String label, Type type) {\n      this.label = label;\n      this.type = type;\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "LabelVal", "params": [{"name": "label", "type": "String"}, {"name": "type", "type": "Type"}], "body": "                                      {\n      this.label = label;\n      this.type = type;\n    }", "signature": "LabelVal(String label, Type type)"}]}, {"original_string": "  private static class TypeVal {\n    final String prefix;\n    final Type type;\n\n    TypeVal(String prefix, Type type) {\n      this.prefix = prefix;\n      this.type = type;\n    }\n  }", "definition": "  private static class TypeVal", "class_docstring": " Wrapper around a type value.", "name": "TypeVal", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "fields": [{"attribute_expression": "final String prefix;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "String", "name": "prefix", "syntax_pass": true}, {"attribute_expression": "final Type type;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "Type", "name": "type", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    TypeVal(String prefix, Type type) {\n      this.prefix = prefix;\n      this.type = type;\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "TypeVal", "params": [{"name": "prefix", "type": "String"}, {"name": "type", "type": "Type"}], "body": "                                      {\n      this.prefix = prefix;\n      this.type = type;\n    }", "signature": "TypeVal(String prefix, Type type)"}]}], "class_docstring": " Prints values.", "original_string": "class Pretty {\n\n  private final TypeSystem typeSystem;\n  private final int lineWidth;\n  private final int printLength;\n  private final int printDepth;\n  private final int stringDepth;\n\n  Pretty(TypeSystem typeSystem, int lineWidth, int printLength, int printDepth,\n      int stringDepth) {\n    this.typeSystem = requireNonNull(typeSystem);\n    this.lineWidth = lineWidth;\n    this.printLength = printLength;\n    this.printDepth = printDepth;\n    this.stringDepth = stringDepth;\n  }\n\n  /** Prints a value to a buffer. */\n  StringBuilder pretty(@NonNull StringBuilder buf,\n      @NonNull Type type, @NonNull Object value) {\n    int lineEnd = lineWidth < 0 ? -1 : (buf.length() + lineWidth);\n    return pretty1(buf, 0, new int[] {lineEnd}, 0, type, value, 0, 0);\n  }\n\n  /** Prints a value to a buffer. If the first attempt goes beyond\n   * {@code lineEnd}, back-tracks, adds a newline and indent, and\n   * tries again one time. */\n  private StringBuilder pretty1(@NonNull StringBuilder buf, int indent,\n      int[] lineEnd, int depth, @NonNull Type type, @NonNull Object value,\n      int leftPrec, int rightPrec) {\n    final int start = buf.length();\n    final int end = lineEnd[0];\n    pretty2(buf, indent, lineEnd, depth, type, value, leftPrec, rightPrec);\n    if (end >= 0 && buf.length() > end) {\n      // Reset to start, remove trailing whitespace, add newline\n      buf.setLength(start);\n      while (buf.length() > 0\n          && (buf.charAt(buf.length() - 1) == ' '\n              || buf.charAt(buf.length() - 1) == '\\n')) {\n        buf.setLength(buf.length() - 1);\n      }\n      if (buf.length() > 0) {\n        buf.append(\"\\n\");\n      }\n\n      lineEnd[0] = lineWidth < 0 ? -1 : (buf.length() + lineWidth);\n      indent(buf, indent);\n      pretty2(buf, indent, lineEnd, depth, type, value, leftPrec, rightPrec);\n    }\n    return buf;\n  }\n\n  private static void indent(@NonNull StringBuilder buf, int indent) {\n    for (int i = 0; i < indent; i++) {\n      buf.append(' ');\n    }\n  }\n\n  private StringBuilder pretty2(@NonNull StringBuilder buf,\n      int indent, int[] lineEnd, int depth, @NonNull Type type,\n      @NonNull Object value, int leftPrec, int rightPrec) {\n    if (value instanceof TypedVal) {\n      final TypedVal typedVal = (TypedVal) value;\n      final StringBuilder buf2 = new StringBuilder(\"val \");\n      appendId(buf2, typedVal.name)\n          .append(\" = \");\n      pretty1(buf, indent, lineEnd, depth, PrimitiveType.BOOL,\n          buf2.toString(), 0, 0);\n      pretty1(buf, indent + 2, lineEnd, depth + 1, typedVal.type, typedVal.o,\n          0, 0);\n      buf.append(' ');\n      pretty1(buf, indent + 2, lineEnd, depth, PrimitiveType.BOOL,\n          new TypeVal(\": \", unqualified(typedVal.type)), 0, 0);\n      return buf;\n    }\n\n    if (value instanceof NamedVal) {\n      final NamedVal namedVal = (NamedVal) value;\n      appendId(buf, namedVal.name)\n          .append('=');\n      pretty1(buf, indent, lineEnd, depth, type, namedVal.o, 0, 0);\n      return buf;\n    }\n\n    if (value instanceof LabelVal) {\n      final LabelVal labelVal = (LabelVal) value;\n      final String prefix =\n          appendId(new StringBuilder(), labelVal.label)\n              .append(':')\n              .toString();\n      pretty1(buf, indent, lineEnd, depth, type,\n          new TypeVal(prefix, labelVal.type), 0, 0);\n      return buf;\n    }\n\n    if (value instanceof TypeVal) {\n      return prettyType(buf, indent, lineEnd, depth, type, (TypeVal) value,\n          leftPrec, rightPrec);\n    }\n\n    if (printDepth >= 0 && depth > printDepth) {\n      buf.append('#');\n      return buf;\n    }\n    final List<Object> list;\n    final int start;\n    String s;\n    switch (type.op()) {\n    case ID:\n      switch ((PrimitiveType) type) {\n      case UNIT:\n        return buf.append(\"()\");\n      case CHAR:\n        s = ((Character) value).toString();\n        return buf.append('#')\n            .append('\"')\n            .append(s.replace(\"\\\\\", \"\\\\\\\\\").replace(\"\\\"\", \"\\\\\\\"\"))\n            .append('\"');\n      case STRING:\n        s = (String) value;\n        if (stringDepth >= 0 && s.length() > stringDepth) {\n          s = s.substring(0, stringDepth) + \"#\";\n        }\n        return buf.append('\"')\n            .append(s.replace(\"\\\\\", \"\\\\\\\\\").replace(\"\\\"\", \"\\\\\\\"\"))\n            .append('\"');\n      case INT:\n        int i = (Integer) value;\n        if (i < 0) {\n          if (i == Integer.MIN_VALUE) {\n            return buf.append(\"~2147483648\");\n          }\n          buf.append('~');\n          i = -i;\n        }\n        return buf.append(i);\n      case REAL:\n        return Codes.appendFloat(buf, (Float) value);\n      default:\n        return buf.append(value);\n      }\n\n    case FUNCTION_TYPE:\n      return buf.append(\"fn\");\n\n    case LIST:\n      final ListType listType = (ListType) type;\n      list = toList(value);\n      if (list instanceof RelList) {\n        // Do not attempt to print the elements of a foreign list. It might be\n        // huge.\n        return buf.append(\"<relation>\");\n      }\n      if (value instanceof TypedValue) {\n        // A TypedValue is probably a field in a record that represents a\n        // database catalog or a directory of CSV files. If the user wishes to\n        // see the contents of each file they should use a query.\n        return buf.append(\"<relation>\");\n      }\n      return printList(buf, indent, lineEnd, depth, listType.elementType, list);\n\n    case RECORD_TYPE:\n      final RecordType recordType = (RecordType) type;\n      list = toList(value);\n      buf.append(\"{\");\n      start = buf.length();\n      forEachIndexed(list, recordType.argNameTypes.entrySet(),\n          (ordinal, o, nameType) -> {\n            if (buf.length() > start) {\n              buf.append(\",\");\n            }\n            pretty1(buf, indent + 1, lineEnd, depth + 1, nameType.getValue(),\n                new NamedVal(nameType.getKey(), o), 0, 0);\n          });\n      return buf.append(\"}\");\n\n    case TUPLE_TYPE:\n      final TupleType tupleType = (TupleType) type;\n      list = toList(value);\n      buf.append(\"(\");\n      start = buf.length();\n      forEachIndexed(list, tupleType.argTypes,\n          (ordinal, o, elementType) -> {\n            if (buf.length() > start) {\n              buf.append(\",\");\n            }\n            pretty1(buf, indent + 1, lineEnd, depth + 1, elementType, o, 0, 0);\n          });\n      return buf.append(\")\");\n\n    case FORALL_TYPE:\n      return pretty2(buf, indent, lineEnd, depth + 1, ((ForallType) type).type,\n          value, 0, 0);\n\n    case DATA_TYPE:\n      final DataType dataType = (DataType) type;\n      list = toList(value);\n      if (dataType.name.equals(\"vector\")) {\n        final Type argType = Iterables.getOnlyElement(dataType.arguments);\n        return printList(buf.append('#'), indent, lineEnd, depth, argType,\n            list);\n      }\n      final String tyConName = (String) list.get(0);\n      buf.append(tyConName);\n      final Type typeConArgType =\n          dataType.typeConstructors(typeSystem).get(tyConName);\n      requireNonNull(typeConArgType);\n      if (list.size() == 2) {\n        final Object arg = list.get(1);\n        buf.append(' ');\n        final boolean needParentheses =\n            typeConArgType.op() == Op.DATA_TYPE && arg instanceof List;\n        if (needParentheses) {\n          buf.append('(');\n        }\n        pretty2(buf, indent, lineEnd, depth + 1, typeConArgType, arg, 0, 0);\n        if (needParentheses) {\n          buf.append(')');\n        }\n      }\n      return buf;\n\n    default:\n      return buf.append(value);\n    }\n  }\n\n  private StringBuilder prettyType(StringBuilder buf, int indent, int[] lineEnd,\n      int depth, Type type, TypeVal typeVal, int leftPrec, int rightPrec) {\n    buf.append(typeVal.prefix);\n    final int indent2 = indent + typeVal.prefix.length();\n    final int start;\n    switch (typeVal.type.op()) {\n    case DATA_TYPE:\n    case ID:\n    case TY_VAR:\n      return pretty1(buf, indent2, lineEnd, depth, type,\n          typeVal.type.moniker(), 0, 0);\n\n    case LIST:\n      if (leftPrec > Op.LIST.left\n          || rightPrec > Op.LIST.right) {\n        pretty1(buf, indent2, lineEnd, depth, type, \"(\", 0, 0);\n        pretty1(buf, indent2, lineEnd, depth, type, typeVal, 0, 0);\n        pretty1(buf, indent2, lineEnd, depth, type, \")\", 0, 0);\n        return buf;\n      }\n      final ListType listType = (ListType) typeVal.type;\n      pretty1(buf, indent2, lineEnd, depth, type,\n          new TypeVal(\"\", listType.elementType), leftPrec, Op.LIST.left);\n      return buf.append(\" list\");\n\n    case TUPLE_TYPE:\n      if (leftPrec > Op.TUPLE_TYPE.left\n          || rightPrec > Op.TUPLE_TYPE.right) {\n        pretty1(buf, indent2, lineEnd, depth, type, \"(\", 0, 0);\n        pretty1(buf, indent2, lineEnd, depth, type, typeVal, 0, 0);\n        pretty1(buf, indent2, lineEnd, depth, type, \")\", 0, 0);\n        return buf;\n      }\n      final TupleType tupleType = (TupleType) typeVal.type;\n      start = buf.length();\n      List<Type> argTypes = tupleType.argTypes;\n      for (int i = 0; i < argTypes.size(); i++) {\n        Type argType = argTypes.get(i);\n        if (buf.length() > start) {\n          pretty1(buf, indent2, lineEnd, depth, type,\n              \" * \", 0, 0);\n        }\n        pretty1(buf, indent2, lineEnd, depth, type,\n            new TypeVal(\"\", argType),\n            i == 0 ? leftPrec : Op.TUPLE_TYPE.right,\n            i == argTypes.size() - 1 ? rightPrec : Op.TUPLE_TYPE.left);\n      }\n      return buf;\n\n    case RECORD_TYPE:\n    case PROGRESSIVE_RECORD_TYPE:\n      final RecordType recordType = (RecordType) typeVal.type;\n      final boolean progressive = typeVal.type.isProgressive();\n      buf.append(\"{\");\n      start = buf.length();\n      recordType.argNameTypes.forEach((name, elementType) -> {\n        if (buf.length() > start) {\n          buf.append(\", \");\n        }\n        pretty1(buf, indent2 + 1, lineEnd, depth, type,\n            new LabelVal(name, elementType), 0, 0);\n      });\n      if (progressive) {\n        if (buf.length() > start) {\n          buf.append(\", \");\n        }\n        pretty1(buf, indent2 + 1, lineEnd, depth, type, \"...\", 0, 0);\n      }\n      return buf.append(\"}\");\n\n    case FUNCTION_TYPE:\n      if (leftPrec > Op.FUNCTION_TYPE.left\n          || rightPrec > Op.FUNCTION_TYPE.right) {\n        pretty1(buf, indent2, lineEnd, depth, type, \"(\", 0, 0);\n        pretty1(buf, indent2, lineEnd, depth, type, typeVal, 0, 0);\n        pretty1(buf, indent2, lineEnd, depth, type, \")\", 0, 0);\n        return buf;\n      }\n      final FnType fnType = (FnType) typeVal.type;\n      pretty1(buf, indent2 + 1, lineEnd, depth, type,\n          new TypeVal(\"\", fnType.paramType),\n          leftPrec, Op.FUNCTION_TYPE.left);\n      pretty1(buf, indent2 + 1, lineEnd, depth, type, \" -> \", 0, 0);\n      pretty1(buf, indent2 + 1, lineEnd, depth, type,\n          new TypeVal(\"\", fnType.resultType),\n          Op.FUNCTION_TYPE.right, rightPrec);\n      return buf;\n\n    default:\n      throw new AssertionError(\"unknown type \" + typeVal.type);\n    }\n  }\n\n  @SuppressWarnings(\"unchecked\")\n  private static List<Object> toList(Object value) {\n    if (value instanceof TypedValue) {\n      TypedValue typedValue = (TypedValue) value;\n      return (List<Object>) typedValue.valueAs(List.class);\n    }\n    return (List<Object>) value;\n  }\n\n  private static Type unqualified(Type type) {\n    return type instanceof ForallType ? unqualified(((ForallType) type).type)\n        : type;\n  }\n\n  private StringBuilder printList(@NonNull StringBuilder buf,\n      int indent, int[] lineEnd, int depth, @NonNull Type elementType,\n      @NonNull List<Object> list) {\n    buf.append(\"[\");\n    int start = buf.length();\n    for (Ord<Object> o : Ord.zip(list)) {\n      if (buf.length() > start) {\n        buf.append(\",\");\n      }\n      if (printLength >= 0 && o.i >= printLength) {\n        pretty1(buf, indent + 1, lineEnd, depth + 1, PrimitiveType.BOOL,\n            \"...\", 0, 0);\n        break;\n      } else {\n        pretty1(buf, indent + 1, lineEnd, depth + 1, elementType, o.e, 0, 0);\n      }\n    }\n    return buf.append(\"]\");\n  }\n\n  /** Wrapper that indicates that a value should be printed\n   * \"val name = value : type\". */\n  static class TypedVal {\n    final String name;\n    final Object o;\n    final Type type;\n\n    TypedVal(String name, Object o, Type type) {\n      this.name = name;\n      this.o = o;\n      this.type = type;\n    }\n  }\n\n  /** Wrapper that indicates that a value should be printed \"name = value\". */\n  private static class NamedVal {\n    final String name;\n    final Object o;\n\n    NamedVal(String name, Object o) {\n      this.name = name;\n      this.o = o;\n    }\n  }\n\n  /** Wrapper that indicates that a value should be printed \"label:type\". */\n  private static class LabelVal {\n    final String label;\n    final Type type;\n\n    LabelVal(String label, Type type) {\n      this.label = label;\n      this.type = type;\n    }\n  }\n\n  /** Wrapper around a type value. */\n  private static class TypeVal {\n    final String prefix;\n    final Type type;\n\n    TypeVal(String prefix, Type type) {\n      this.prefix = prefix;\n      this.type = type;\n    }\n  }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private final TypeSystem typeSystem;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "TypeSystem", "name": "typeSystem", "syntax_pass": true}, {"attribute_expression": "private final int lineWidth;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "int", "name": "lineWidth", "syntax_pass": true}, {"attribute_expression": "private final int printLength;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "int", "name": "printLength", "syntax_pass": true}, {"attribute_expression": "private final int printDepth;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "int", "name": "printDepth", "syntax_pass": true}, {"attribute_expression": "private final int stringDepth;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "int", "name": "stringDepth", "syntax_pass": true}]}, {"uris": "src/main/java/net/hydromatic/morel/compile/Compiler.java.Compiler", "name": "Compiler", "file_path": "src/main/java/net/hydromatic/morel/compile/Compiler.java", "superclasses": "", "methods": ["[]Compiler(TypeSystem)", "[CompiledStatement]compileStatement(Environment,Core.Decl,Core.@Nullable NamedPat,Set<Core.Exp>)", "[CalciteFunctions.Context]createContext(Environment)", "[Code]compile(Environment,Core.Exp)", "[Code]compileArg(Context,Core.Exp)", "[List<Code>]compileArgs(Context,Iterable<? extends Core.Exp>)", "[Code]compile(Context,Core.Exp)", "[Code]compileFieldName(Context,Core.NamedPat)", "[Code]compileApply(Context,Core.Apply)", "[Code]finishCompileApply(Context,Applicable,Code,Type)", "[Code]finishCompileApply(Context,Code,Code,Type)", "[Code]compileFrom(Context,Core.From)", "[Supplier<Codes.RowSink>]createRowSinkFactory(Context,ImmutableList<Binding>,List<Core.FromStep>,Type)", "[ImmutableSortedMap<String, Binding>]sortedBindingMap(Iterable<Binding>)", "[ImmutableList<String>]bindingNames(List<Binding>)", "[Applicable]compileApplicable(Context,Core.Exp,Type,Pos)", "[Applicable]toApplicable(Context,Object,Type,Pos)", "[Code]compileLet(Context,Core.Let)", "[Code]finishCompileLet(Context,List<Code>,Code,Type)", "[Code]compileLocal(Context,Core.Local)", "[void]compileDecl(Context,Core.Decl,Core.@Nullable NamedPat,Set<Core.Exp>,List<Code>,List<Binding>,List<Action>)", "[void]compileDatatypeDecl(List<DataType>,List<Binding>,List<Action>)", "[Code]compileCall(Context,BuiltIn,Core.Exp,Pos)", "[Code]compileMatchList(Context,List<Core.Match>)", "[void]compileMatch(Context,Core.Match,BiConsumer<Core.Pat, Code>)", "[void]compileValDecl(Context,Core.ValDecl,Core.@Nullable Pat,Set<Core.Exp>,List<Code>,List<Binding>,List<Action>)", "[void]link(Map<Core.NamedPat, LinkCode>,Core.Pat,Code)"], "method_uris": ["src/main/java/net/hydromatic/morel/compile/Compiler.java.Compiler.[]Compiler(TypeSystem)", "src/main/java/net/hydromatic/morel/compile/Compiler.java.Compiler.[CompiledStatement]compileStatement(Environment,Core.Decl,Core.@Nullable NamedPat,Set<Core.Exp>)", "src/main/java/net/hydromatic/morel/compile/Compiler.java.Compiler.[CalciteFunctions.Context]createContext(Environment)", "src/main/java/net/hydromatic/morel/compile/Compiler.java.Compiler.[Code]compile(Environment,Core.Exp)", "src/main/java/net/hydromatic/morel/compile/Compiler.java.Compiler.[Code]compileArg(Context,Core.Exp)", "src/main/java/net/hydromatic/morel/compile/Compiler.java.Compiler.[List<Code>]compileArgs(Context,Iterable<? extends Core.Exp>)", "src/main/java/net/hydromatic/morel/compile/Compiler.java.Compiler.[Code]compile(Context,Core.Exp)", "src/main/java/net/hydromatic/morel/compile/Compiler.java.Compiler.[Code]compileFieldName(Context,Core.NamedPat)", "src/main/java/net/hydromatic/morel/compile/Compiler.java.Compiler.[Code]compileApply(Context,Core.Apply)", "src/main/java/net/hydromatic/morel/compile/Compiler.java.Compiler.[Code]finishCompileApply(Context,Applicable,Code,Type)", "src/main/java/net/hydromatic/morel/compile/Compiler.java.Compiler.[Code]finishCompileApply(Context,Code,Code,Type)", "src/main/java/net/hydromatic/morel/compile/Compiler.java.Compiler.[Code]compileFrom(Context,Core.From)", "src/main/java/net/hydromatic/morel/compile/Compiler.java.Compiler.[Supplier<Codes.RowSink>]createRowSinkFactory(Context,ImmutableList<Binding>,List<Core.FromStep>,Type)", "src/main/java/net/hydromatic/morel/compile/Compiler.java.Compiler.[ImmutableSortedMap<String, Binding>]sortedBindingMap(Iterable<Binding>)", "src/main/java/net/hydromatic/morel/compile/Compiler.java.Compiler.[ImmutableList<String>]bindingNames(List<Binding>)", "src/main/java/net/hydromatic/morel/compile/Compiler.java.Compiler.[Applicable]compileApplicable(Context,Core.Exp,Type,Pos)", "src/main/java/net/hydromatic/morel/compile/Compiler.java.Compiler.[Applicable]toApplicable(Context,Object,Type,Pos)", "src/main/java/net/hydromatic/morel/compile/Compiler.java.Compiler.[Code]compileLet(Context,Core.Let)", "src/main/java/net/hydromatic/morel/compile/Compiler.java.Compiler.[Code]finishCompileLet(Context,List<Code>,Code,Type)", "src/main/java/net/hydromatic/morel/compile/Compiler.java.Compiler.[Code]compileLocal(Context,Core.Local)", "src/main/java/net/hydromatic/morel/compile/Compiler.java.Compiler.[void]compileDecl(Context,Core.Decl,Core.@Nullable NamedPat,Set<Core.Exp>,List<Code>,List<Binding>,List<Action>)", "src/main/java/net/hydromatic/morel/compile/Compiler.java.Compiler.[void]compileDatatypeDecl(List<DataType>,List<Binding>,List<Action>)", "src/main/java/net/hydromatic/morel/compile/Compiler.java.Compiler.[Code]compileCall(Context,BuiltIn,Core.Exp,Pos)", "src/main/java/net/hydromatic/morel/compile/Compiler.java.Compiler.[Code]compileMatchList(Context,List<Core.Match>)", "src/main/java/net/hydromatic/morel/compile/Compiler.java.Compiler.[void]compileMatch(Context,Core.Match,BiConsumer<Core.Pat, Code>)", "src/main/java/net/hydromatic/morel/compile/Compiler.java.Compiler.[void]compileValDecl(Context,Core.ValDecl,Core.@Nullable Pat,Set<Core.Exp>,List<Code>,List<Binding>,List<Action>)", "src/main/java/net/hydromatic/morel/compile/Compiler.java.Compiler.[void]link(Map<Core.NamedPat, LinkCode>,Core.Pat,Code)"], "overrides": null, "attributes": [{"original_string": "  public static class Context {\n    final Environment env;\n\n    Context(Environment env) {\n      this.env = env;\n    }\n\n    static Context of(Environment env) {\n      return new Context(env);\n    }\n\n    Context bindAll(Iterable<Binding> bindings) {\n      return of(env.bindAll(bindings));\n    }\n  }", "definition": "  public static class Context", "class_docstring": " Compilation context.", "name": "Context", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [{"attribute_expression": "final Environment env;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "Environment", "name": "env", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    Context(Environment env) {\n      this.env = env;\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "Context", "params": [{"name": "env", "type": "Environment"}], "body": "                             {\n      this.env = env;\n    }", "signature": "Context(Environment env)"}, {"syntax_pass": true, "original_string": "    static Context of(Environment env) {\n      return new Context(env);\n    }", "docstring": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "Context", "classes": []}, "name": "of", "params": [{"name": "env", "type": "Environment"}], "body": "                                       {\n      return new Context(env);\n    }", "signature": "static Context of(Environment env)"}, {"syntax_pass": true, "original_string": "    Context bindAll(Iterable<Binding> bindings) {\n      return of(env.bindAll(bindings));\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "Context", "classes": []}, "name": "bindAll", "params": [{"name": "bindings", "type": "Iterable<Binding>"}], "body": "                                                {\n      return of(env.bindAll(bindings));\n    }", "signature": "Context bindAll(Iterable<Binding> bindings)"}]}, {"original_string": "  private static class LinkCode implements Code {\n    private Code refCode;\n\n    @Override public Describer describe(Describer describer) {\n      return describer.start(\"link\", d -> {\n        if (false) {\n          // Don't recurse into refCode... or we'll never get out alive.\n          d.arg(\"refCode\", refCode);\n        }\n      });\n    }\n\n    public Object eval(EvalEnv env) {\n      assert refCode != null; // link should have completed by now\n      return refCode.eval(env);\n    }\n  }", "definition": "  private static class LinkCode implements Code", "class_docstring": " A piece of code that is references another piece of code.\nIt is useful when defining recursive functions.\nThe reference is mutable, and is fixed up when the\nfunction has been compiled.\n", "name": "LinkCode", "super_interfaces": ["Code"], "superclasses": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "fields": [{"attribute_expression": "private Code refCode;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Code", "name": "refCode", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @Override public Describer describe(Describer describer) {\n      return describer.start(\"link\", d -> {\n        if (false) {\n          // Don't recurse into refCode... or we'll never get out alive.\n          d.arg(\"refCode\", refCode);\n        }\n      });\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Describer", "classes": []}, "name": "describe", "params": [{"name": "describer", "type": "Describer"}], "body": "                                                             {\n      return describer.start(\"link\", d -> {\n        if (false) {\n          // Don't recurse into refCode... or we'll never get out alive.\n          d.arg(\"refCode\", refCode);\n        }\n      });\n    }", "signature": "@Override public Describer describe(Describer describer)"}, {"syntax_pass": true, "original_string": "    public Object eval(EvalEnv env) {\n      assert refCode != null; // link should have completed by now\n      return refCode.eval(env);\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Object", "classes": []}, "name": "eval", "params": [{"name": "env", "type": "EvalEnv"}], "body": "                                    {\n      assert refCode != null; // link should have completed by now\n      return refCode.eval(env);\n    }", "signature": "public Object eval(EvalEnv env)"}]}, {"original_string": "  private static class MatchCode implements Code {\n    private final ImmutablePairList<Core.Pat, Code> patCodes;\n    private final Pos pos;\n\n    MatchCode(ImmutablePairList<Core.Pat, Code> patCodes, Pos pos) {\n      this.patCodes = patCodes;\n      this.pos = pos;\n    }\n\n    @Override public Describer describe(Describer describer) {\n      return describer.start(\"match\", d ->\n          patCodes.forEach((pat, code) ->\n              d.arg(\"\", pat.toString()).arg(\"\", code)));\n    }\n\n    @Override public Object eval(EvalEnv evalEnv) {\n      return new Closure(evalEnv, patCodes, pos);\n    }\n  }", "definition": "  private static class MatchCode implements Code", "class_docstring": " Code that implements {@link Compiler#compileMatchList(Context, List)}.", "name": "MatchCode", "super_interfaces": ["Code"], "superclasses": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "fields": [{"attribute_expression": "private final ImmutablePairList<Core.Pat, Code> patCodes;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "ImmutablePairList<Core.Pat, Code>", "name": "patCodes", "syntax_pass": true}, {"attribute_expression": "private final Pos pos;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Pos", "name": "pos", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    MatchCode(ImmutablePairList<Core.Pat, Code> patCodes, Pos pos) {\n      this.patCodes = patCodes;\n      this.pos = pos;\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "MatchCode", "params": [{"name": "patCodes", "type": "ImmutablePairList<Core.Pat, Code>"}, {"name": "pos", "type": "Pos"}], "body": "                                                                   {\n      this.patCodes = patCodes;\n      this.pos = pos;\n    }", "signature": "MatchCode(ImmutablePairList<Core.Pat, Code> patCodes, Pos pos)"}, {"syntax_pass": true, "original_string": "    @Override public Describer describe(Describer describer) {\n      return describer.start(\"match\", d ->\n          patCodes.forEach((pat, code) ->\n              d.arg(\"\", pat.toString()).arg(\"\", code)));\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Describer", "classes": []}, "name": "describe", "params": [{"name": "describer", "type": "Describer"}], "body": "                                                             {\n      return describer.start(\"match\", d ->\n          patCodes.forEach((pat, code) ->\n              d.arg(\"\", pat.toString()).arg(\"\", code)));\n    }", "signature": "@Override public Describer describe(Describer describer)"}, {"syntax_pass": true, "original_string": "    @Override public Object eval(EvalEnv evalEnv) {\n      return new Closure(evalEnv, patCodes, pos);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Object", "classes": []}, "name": "eval", "params": [{"name": "evalEnv", "type": "EvalEnv"}], "body": "                                                  {\n      return new Closure(evalEnv, patCodes, pos);\n    }", "signature": "@Override public Object eval(EvalEnv evalEnv)"}]}], "class_docstring": " Compiles an expression to code that can be evaluated.", "original_string": "public class Compiler {\n  protected static final EvalEnv EMPTY_ENV = Codes.emptyEnv();\n\n  protected final TypeSystem typeSystem;\n\n  public Compiler(TypeSystem typeSystem) {\n    this.typeSystem = requireNonNull(typeSystem, \"typeSystem\");\n  }\n\n  CompiledStatement compileStatement(Environment env, Core.Decl decl,\n      Core.@Nullable NamedPat skipPat, Set<Core.Exp> queriesToWrap) {\n    final List<Code> matchCodes = new ArrayList<>();\n    final List<Binding> bindings = new ArrayList<>();\n    final List<Action> actions = new ArrayList<>();\n    final Context cx = Context.of(env);\n    compileDecl(cx, decl, skipPat, queriesToWrap, matchCodes, bindings,\n        actions);\n    final Type type = decl instanceof Core.NonRecValDecl\n        ? ((Core.NonRecValDecl) decl).pat.type\n        : PrimitiveType.UNIT;\n    final CalciteFunctions.Context context = createContext(env);\n\n    return new CompiledStatement() {\n      public Type getType() {\n        return type;\n      }\n\n      public void eval(Session session, Environment env,\n          Consumer<String> outLines, Consumer<Binding> outBindings) {\n        ThreadLocals.let(CalciteFunctions.THREAD_ENV, context,\n            () -> {\n              final EvalEnv evalEnv = Codes.emptyEnvWith(session, env);\n              for (Action action : actions) {\n                action.apply(outLines, outBindings, evalEnv);\n              }\n            });\n      }\n    };\n  }\n\n  /** Creates a context.\n   *\n   * <p>The whole way we provide compilation environments (including\n   * Environment) to generated code is a mess:\n   * <ul>\n   * <li>This method is protected so that CalciteCompiler can override and get\n   * a Calcite type factory.\n   * <li>User-defined functions should have a 'prepare' phase, where they use\n   * a type factory and environment, that is distinct from the 'eval' phase.\n   * <li>We should pass compile and runtime environments via parameters, not\n   * thread-locals.\n   * <li>The dummy session is there because session is mandatory, but we have\n   * not created a session yet. Lifecycle confusion.\n   * </ul> */\n  protected CalciteFunctions.Context createContext(Environment env) {\n    final Session dummySession = new Session(ImmutableMap.of());\n    return new CalciteFunctions.Context(dummySession, env, typeSystem, null);\n  }\n\n  /** Something that needs to happen when a declaration is evaluated.\n   *\n   * <p>Usually involves placing a type or value into the bindings that will\n   * make up the environment in which the next statement will be executed, and\n   * printing some text on the screen. */\n  interface Action {\n    void apply(Consumer<String> outLines, Consumer<Binding> outBindings,\n        EvalEnv evalEnv);\n  }\n\n  /** Compilation context. */\n  public static class Context {\n    final Environment env;\n\n    Context(Environment env) {\n      this.env = env;\n    }\n\n    static Context of(Environment env) {\n      return new Context(env);\n    }\n\n    Context bindAll(Iterable<Binding> bindings) {\n      return of(env.bindAll(bindings));\n    }\n  }\n\n  public final Code compile(Environment env, Core.Exp expression) {\n    return compile(Context.of(env), expression);\n  }\n\n  /** Compiles the argument to \"apply\". */\n  public Code compileArg(Context cx, Core.Exp expression) {\n    return compile(cx, expression);\n  }\n\n  /** Compiles the tuple arguments to \"apply\". */\n  public List<Code> compileArgs(Context cx,\n      Iterable<? extends Core.Exp> expressions) {\n    return transformEager(expressions, e -> compile(cx, e));\n  }\n\n  public Code compile(Context cx, Core.Exp expression) {\n    final Core.Literal literal;\n    final Code argCode;\n    final List<Code> codes;\n    switch (expression.op) {\n    case BOOL_LITERAL:\n      literal = (Core.Literal) expression;\n      final Boolean boolValue = literal.unwrap(Boolean.class);\n      return Codes.constant(boolValue);\n\n    case CHAR_LITERAL:\n      literal = (Core.Literal) expression;\n      final Character charValue = literal.unwrap(Character.class);\n      return Codes.constant(charValue);\n\n    case INT_LITERAL:\n      literal = (Core.Literal) expression;\n      return Codes.constant(literal.unwrap(Integer.class));\n\n    case REAL_LITERAL:\n      literal = (Core.Literal) expression;\n      return Codes.constant(literal.unwrap(Float.class));\n\n    case STRING_LITERAL:\n      literal = (Core.Literal) expression;\n      final String stringValue = literal.unwrap(String.class);\n      return Codes.constant(stringValue);\n\n    case UNIT_LITERAL:\n      return Codes.constant(Unit.INSTANCE);\n\n    case FN_LITERAL:\n      literal = (Core.Literal) expression;\n      final BuiltIn builtIn = literal.unwrap(BuiltIn.class);\n      return Codes.constant(Codes.BUILT_IN_VALUES.get(builtIn));\n\n    case INTERNAL_LITERAL:\n    case VALUE_LITERAL:\n      literal = (Core.Literal) expression;\n      return Codes.constant(literal.unwrap(Object.class));\n\n    case LET:\n      return compileLet(cx, (Core.Let) expression);\n\n    case LOCAL:\n      return compileLocal(cx, (Core.Local) expression);\n\n    case FN:\n      final Core.Fn fn = (Core.Fn) expression;\n      return compileMatchList(cx,\n          ImmutableList.of(core.match(fn.pos, fn.idPat, fn.exp)));\n\n    case CASE:\n      final Core.Case case_ = (Core.Case) expression;\n      final Code matchCode = compileMatchList(cx, case_.matchList);\n      argCode = compile(cx, case_.exp);\n      return Codes.apply(matchCode, argCode);\n\n    case RECORD_SELECTOR:\n      final Core.RecordSelector recordSelector = (Core.RecordSelector) expression;\n      return Codes.nth(recordSelector.slot).asCode();\n\n    case APPLY:\n      return compileApply(cx, (Core.Apply) expression);\n\n    case FROM:\n      return compileFrom(cx, (Core.From) expression);\n\n    case ID:\n      final Core.Id id = (Core.Id) expression;\n      return compileFieldName(cx, id.idPat);\n\n    case TUPLE:\n      final Core.Tuple tuple = (Core.Tuple) expression;\n      codes = new ArrayList<>();\n      for (Core.Exp arg : tuple.args) {\n        codes.add(compile(cx, arg));\n      }\n      return Codes.tuple(codes);\n\n    default:\n      throw new AssertionError(\"op not handled: \" + expression.op);\n    }\n  }\n\n  private Code compileFieldName(Context cx, Core.NamedPat idPat) {\n    final Binding binding = cx.env.getOpt(idPat.name);\n    if (binding != null && binding.value instanceof Code) {\n      return (Code) binding.value;\n    }\n    return Codes.get(idPat.name);\n  }\n\n  protected Code compileApply(Context cx, Core.Apply apply) {\n    // Is this is a call to a built-in operator?\n    switch (apply.fn.op) {\n    case FN_LITERAL:\n      final BuiltIn builtIn = ((Core.Literal) apply.fn).unwrap(BuiltIn.class);\n      return compileCall(cx, builtIn, apply.arg, apply.pos);\n    }\n    final Code argCode = compileArg(cx, apply.arg);\n    final Type argType = apply.arg.type;\n    final Applicable fnValue =\n        compileApplicable(cx, apply.fn, argType, apply.pos);\n    if (fnValue != null) {\n      return finishCompileApply(cx, fnValue, argCode, argType);\n    }\n    final Code fnCode = compile(cx, apply.fn);\n    return finishCompileApply(cx, fnCode, argCode, argType);\n  }\n\n  protected Code finishCompileApply(Context cx, Applicable fnValue,\n      Code argCode, Type argType) {\n    return Codes.apply(fnValue, argCode);\n  }\n\n  protected Code finishCompileApply(Context cx, Code fnCode, Code argCode,\n      Type argType) {\n    return Codes.apply(fnCode, argCode);\n  }\n\n  protected Code compileFrom(Context cx, Core.From from) {\n    Supplier<Codes.RowSink> rowSinkFactory =\n        createRowSinkFactory(cx, ImmutableList.of(), from.steps,\n            from.type().elementType);\n    return Codes.from(rowSinkFactory);\n  }\n\n  protected Supplier<Codes.RowSink> createRowSinkFactory(Context cx0,\n      ImmutableList<Binding> bindings, List<Core.FromStep> steps,\n      Type elementType) {\n    final Context cx = cx0.bindAll(bindings);\n    if (steps.isEmpty()) {\n      final List<String> fieldNames =\n          bindings.stream().map(b -> b.id.name).sorted()\n              .collect(toImmutableList());\n      final Code code;\n      if (fieldNames.size() == 1\n          && getOnlyElement(bindings).id.type.equals(elementType)) {\n        code = Codes.get(fieldNames.get(0));\n      } else {\n        code = Codes.getTuple(fieldNames);\n      }\n      return () -> Codes.collectRowSink(code);\n    }\n    final Core.FromStep firstStep = steps.get(0);\n    final Supplier<Codes.RowSink> nextFactory =\n        createRowSinkFactory(cx, firstStep.bindings, skip(steps),\n            elementType);\n    switch (firstStep.op) {\n    case SCAN:\n      final Core.Scan scan = (Core.Scan) firstStep;\n      final Code code = compile(cx, scan.exp);\n      final Code conditionCode = compile(cx, scan.condition);\n      return () -> Codes.scanRowSink(firstStep.op, scan.pat, code,\n          conditionCode, nextFactory.get());\n\n    case WHERE:\n      final Core.Where where = (Core.Where) firstStep;\n      final Code filterCode = compile(cx, where.exp);\n      return () -> Codes.whereRowSink(filterCode, nextFactory.get());\n\n    case SKIP:\n      final Core.Skip skip = (Core.Skip) firstStep;\n      final Code skipCode = compile(cx, skip.exp);\n      return () -> Codes.skipRowSink(skipCode, nextFactory.get());\n\n    case TAKE:\n      final Core.Take take = (Core.Take) firstStep;\n      final Code takeCode = compile(cx, take.exp);\n      return () -> Codes.takeRowSink(takeCode, nextFactory.get());\n\n    case YIELD:\n      final Core.Yield yield = (Core.Yield) firstStep;\n      if (steps.size() == 1) {\n        // Last step. Use a Collect row sink, and we're done.\n        // Note that we don't use nextFactory.\n        final Code yieldCode = compile(cx, yield.exp);\n        return () -> Codes.collectRowSink(yieldCode);\n      } else if (yield.exp instanceof Core.Tuple) {\n        final Core.Tuple tuple = (Core.Tuple) yield.exp;\n        final RecordLikeType recordType = tuple.type();\n        final ImmutableSortedMap.Builder<String, Code> mapCodes =\n            ImmutableSortedMap.orderedBy(RecordType.ORDERING);\n        forEach(tuple.args, recordType.argNameTypes().keySet(), (exp, name) ->\n            mapCodes.put(name, compile(cx, exp)));\n        return () -> Codes.yieldRowSink(mapCodes.build(), nextFactory.get());\n      } else {\n        final ImmutableSortedMap.Builder<String, Code> mapCodes =\n            ImmutableSortedMap.orderedBy(RecordType.ORDERING);\n        final Binding binding = yield.bindings.get(0);\n        mapCodes.put(binding.id.name, compile(cx, yield.exp));\n        return () -> Codes.yieldRowSink(mapCodes.build(), nextFactory.get());\n      }\n\n    case ORDER:\n      final Core.Order order = (Core.Order) firstStep;\n      final PairList<Code, Boolean> codes = PairList.of();\n      order.orderItems.forEach(e ->\n          codes.add(compile(cx, e.exp), e.direction == DESC));\n      return () -> Codes.orderRowSink(codes, bindings, nextFactory.get());\n\n    case GROUP:\n      final Core.Group group = (Core.Group) firstStep;\n      final ImmutableList.Builder<Code> groupCodesB = ImmutableList.builder();\n      for (Core.Exp exp : group.groupExps.values()) {\n        groupCodesB.add(compile(cx, exp));\n      }\n      final ImmutableList.Builder<Code> valueCodesB = ImmutableList.builder();\n      final SortedMap<String, Binding> bindingMap = sortedBindingMap(bindings);\n      for (Binding binding : bindingMap.values()) {\n        valueCodesB.add(compile(cx, core.id(binding.id)));\n      }\n      final ImmutableList<String> names =\n          ImmutableList.copyOf(bindingMap.keySet());\n      final ImmutableList.Builder<Applicable> aggregateCodesB =\n          ImmutableList.builder();\n      for (Core.Aggregate aggregate : group.aggregates.values()) {\n        final Code argumentCode;\n        final Type argumentType;\n        if (aggregate.argument == null) {\n          final PairList<String, Type> argNameTypes = PairList.of();\n          bindings.forEach(b -> argNameTypes.add(b.id.name, b.id.type));\n          argumentType = typeSystem.recordOrScalarType(argNameTypes);\n          argumentCode = null;\n        } else {\n          argumentType = aggregate.argument.type;\n          argumentCode = compile(cx, aggregate.argument);\n        }\n        final Applicable aggregateApplicable =\n            compileApplicable(cx, aggregate.aggregate,\n                typeSystem.listType(argumentType), aggregate.pos);\n        final Code aggregateCode;\n        if (aggregateApplicable == null) {\n          aggregateCode = compile(cx, aggregate.aggregate);\n        } else {\n          aggregateCode = aggregateApplicable.asCode();\n        }\n        aggregateCodesB.add(\n            Codes.aggregate(cx.env, aggregateCode, names, argumentCode));\n      }\n      final ImmutableList<Code> groupCodes = groupCodesB.build();\n      final Code keyCode = Codes.tuple(groupCodes);\n      final ImmutableList<Applicable> aggregateCodes = aggregateCodesB.build();\n      final ImmutableList<String> outNames = bindingNames(firstStep.bindings);\n      final ImmutableList<String> keyNames =\n          outNames.subList(0, group.groupExps.size());\n      return () -> Codes.groupRowSink(keyCode, aggregateCodes, names, keyNames,\n          outNames, nextFactory.get());\n\n    default:\n      throw new AssertionError(\"unknown step type \" + firstStep.op);\n    }\n  }\n\n  private ImmutableSortedMap<String, Binding> sortedBindingMap(\n      Iterable<Binding> bindings) {\n    final ImmutableSortedMap.Builder<String, Binding> b =\n        ImmutableSortedMap.orderedBy(RecordType.ORDERING);\n    bindings.forEach(binding -> b.put(binding.id.name, binding));\n    return b.build();\n  }\n\n  private ImmutableList<String> bindingNames(List<Binding> bindings) {\n    return transformEager(bindings, b -> b.id.name);\n  }\n\n  /** Compiles a function value to an {@link Applicable}, if possible, or\n   * returns null. */\n  private Applicable compileApplicable(Context cx, Core.Exp fn, Type argType,\n      Pos pos) {\n    switch (fn.op) {\n    case FN_LITERAL:\n      final BuiltIn builtIn = ((Core.Literal) fn).unwrap(BuiltIn.class);\n      final Object o = Codes.BUILT_IN_VALUES.get(builtIn);\n      return toApplicable(cx, o, argType, pos);\n\n    case VALUE_LITERAL:\n      final Core.Literal literal = (Core.Literal) fn;\n      return toApplicable(cx, literal.unwrap(Object.class), argType, pos);\n\n    case ID:\n      final Binding binding = cx.env.getOpt(((Core.Id) fn).idPat);\n      if (binding == null\n          || binding.value instanceof LinkCode\n          || binding.value == Unit.INSTANCE) {\n        return null;\n      }\n      return toApplicable(cx, binding.value, argType, pos);\n\n    case RECORD_SELECTOR:\n      final Core.RecordSelector recordSelector = (Core.RecordSelector) fn;\n      return Codes.nth(recordSelector.slot);\n\n    default:\n      return null;\n    }\n  }\n\n  private @Nullable Applicable toApplicable(Context cx, Object o,\n      Type argType, Pos pos) {\n    if (o instanceof Applicable) {\n      final Applicable applicable = (Applicable) o;\n      if (applicable instanceof Codes.Positioned) {\n        return ((Codes.Positioned) applicable).withPos(pos);\n      }\n      return applicable;\n    }\n    if (o instanceof Macro) {\n      final Macro value = (Macro) o;\n      final Core.Exp exp = value.expand(typeSystem, cx.env, argType);\n      switch (exp.op) {\n      case FN_LITERAL:\n        final Core.Literal literal = (Core.Literal) exp;\n        final BuiltIn builtIn = literal.unwrap(BuiltIn.class);\n        return (Applicable) Codes.BUILT_IN_VALUES.get(builtIn);\n      }\n      final Code code = compile(cx, exp);\n      return new Applicable() {\n        @Override public Describer describe(Describer describer) {\n          return code.describe(describer);\n        }\n\n        @Override public Object apply(EvalEnv evalEnv, Object arg) {\n          return code.eval(evalEnv);\n        }\n      };\n    }\n    return null;\n  }\n\n  private Code compileLet(Context cx, Core.Let let) {\n    final List<Code> matchCodes = new ArrayList<>();\n    final List<Binding> bindings = new ArrayList<>();\n    compileValDecl(cx, let.decl, null, ImmutableSet.of(), matchCodes, bindings,\n        null);\n    Context cx2 = cx.bindAll(bindings);\n    final Code resultCode = compile(cx2, let.exp);\n    return finishCompileLet(cx2, matchCodes, resultCode, let.type);\n  }\n\n  protected Code finishCompileLet(Context cx, List<Code> matchCodes,\n      Code resultCode, Type resultType) {\n    return Codes.let(matchCodes, resultCode);\n  }\n\n  private Code compileLocal(Context cx, Core.Local local) {\n    final List<Binding> bindings = new ArrayList<>();\n    compileDatatypeDecl(ImmutableList.of(local.dataType), bindings, null);\n    Context cx2 = cx.bindAll(bindings);\n    return compile(cx2, local.exp);\n  }\n\n  void compileDecl(Context cx, Core.Decl decl, Core.@Nullable NamedPat skipPat,\n      Set<Core.Exp> queriesToWrap, List<Code> matchCodes,\n      List<Binding> bindings, List<Action> actions) {\n    switch (decl.op) {\n    case VAL_DECL:\n    case REC_VAL_DECL:\n      final Core.ValDecl valDecl = (Core.ValDecl) decl;\n      compileValDecl(cx, valDecl, skipPat, queriesToWrap, matchCodes, bindings,\n          actions);\n      break;\n\n    case DATATYPE_DECL:\n      final Core.DatatypeDecl datatypeDecl = (Core.DatatypeDecl) decl;\n      compileDatatypeDecl(datatypeDecl.dataTypes, bindings, actions);\n      break;\n\n    default:\n      throw new AssertionError(\"unknown \" + decl.op + \" [\" + decl + \"]\");\n    }\n  }\n\n  private void compileDatatypeDecl(List<DataType> dataTypes,\n      List<Binding> bindings, List<Action> actions) {\n    for (DataType dataType : dataTypes) {\n      final List<Binding> newBindings = new TailList<>(bindings);\n      dataType.typeConstructors.keySet().forEach(name ->\n          bindings.add(typeSystem.bindTyCon(dataType, name)));\n      if (actions != null) {\n        final List<Binding> immutableBindings =\n            ImmutableList.copyOf(newBindings);\n        actions.add((outLines, outBindings, evalEnv) -> {\n          String line = dataType.describe(new StringBuilder()).toString();\n          outLines.accept(line);\n          immutableBindings.forEach(outBindings);\n        });\n      }\n    }\n  }\n\n  private Code compileCall(Context cx, BuiltIn builtIn, Core.Exp arg, Pos pos) {\n    final List<Code> argCodes;\n    switch (builtIn) {\n    case Z_ANDALSO:\n      // Argument for a built-in infix operator such as \"andalso\" is always a\n      // tuple; operators are never curried, nor do they evaluate an expression\n      // to yield the tuple of arguments.\n      argCodes = compileArgs(cx, ((Core.Tuple) arg).args);\n      return Codes.andAlso(argCodes.get(0), argCodes.get(1));\n    case Z_ORELSE:\n      argCodes = compileArgs(cx, ((Core.Tuple) arg).args);\n      return Codes.orElse(argCodes.get(0), argCodes.get(1));\n    case Z_LIST:\n      argCodes = compileArgs(cx, ((Core.Tuple) arg).args);\n      return Codes.list(argCodes);\n    default:\n      final Object o0 = Codes.BUILT_IN_VALUES.get(builtIn);\n      final Object o;\n      if (o0 instanceof Codes.Positioned) {\n        o = ((Codes.Positioned) o0).withPos(pos);\n      } else {\n        o = o0;\n      }\n      if (o instanceof Applicable) {\n        final Code argCode = compile(cx, arg);\n        if (argCode instanceof Codes.TupleCode) {\n          final Codes.TupleCode tupleCode = (Codes.TupleCode) argCode;\n          if (tupleCode.codes.size() == 2\n              && o instanceof Applicable2) {\n            //noinspection rawtypes\n            return Codes.apply2((Applicable2) o,\n                tupleCode.codes.get(0),\n                tupleCode.codes.get(1));\n          }\n          if (tupleCode.codes.size() == 3\n              && o instanceof Applicable3) {\n            //noinspection rawtypes\n            return Codes.apply3((Applicable3) o,\n                tupleCode.codes.get(0),\n                tupleCode.codes.get(1),\n                tupleCode.codes.get(2));\n          }\n        }\n        return Codes.apply((Applicable) o, argCode);\n      }\n      throw new AssertionError(\"unknown \" + builtIn);\n    }\n  }\n\n  /** Compiles a {@code match} expression.\n   *\n   * @param cx Compile context\n   * @param matchList List of Match\n   * @return Code for match\n   */\n  private Code compileMatchList(Context cx,\n      List<Core.Match> matchList) {\n    final PairList<Core.Pat, Code> patCodes = PairList.of();\n    matchList.forEach(match -> compileMatch(cx, match, patCodes::add));\n    return new MatchCode(patCodes.immutable(), getLast(matchList).pos);\n  }\n\n  private void compileMatch(Context cx, Core.Match match,\n      BiConsumer<Core.Pat, Code> consumer) {\n    final List<Binding> bindings = new ArrayList<>();\n    Compiles.bindPattern(typeSystem, bindings, match.pat);\n    final Code code = compile(cx.bindAll(bindings), match.exp);\n    consumer.accept(match.pat, code);\n  }\n\n  private void compileValDecl(Context cx, Core.ValDecl valDecl,\n      Core.@Nullable Pat skipPat,\n      Set<Core.Exp> queriesToWrap, List<Code> matchCodes,\n      List<Binding> bindings, List<Action> actions) {\n    Compiles.bindPattern(typeSystem, bindings, valDecl);\n    final List<Binding> newBindings = new TailList<>(bindings);\n    final Map<Core.NamedPat, LinkCode> linkCodes = new HashMap<>();\n    if (valDecl.op == Op.REC_VAL_DECL) {\n      valDecl.forEachBinding((pat, exp, pos) -> {\n        final LinkCode linkCode = new LinkCode();\n        linkCodes.put(pat, linkCode);\n        bindings.add(Binding.of(pat, linkCode));\n      });\n    }\n\n    final Context cx1 = cx.bindAll(newBindings);\n    valDecl.forEachBinding((pat, exp, pos) -> {\n      // Using 'compileArg' rather than 'compile' encourages CalciteCompiler\n      // to use a pure Calcite implementation if possible, and has no effect\n      // in the basic Compiler.\n      final Code code0 = compileArg(cx1, exp);\n      final Code code =\n          queriesToWrap.contains(exp) ? Codes.wrapRelList(code0) : code0;\n      if (!linkCodes.isEmpty()) {\n        link(linkCodes, pat, code);\n      }\n      matchCodes.add(new MatchCode(ImmutablePairList.of(pat, code), pos));\n\n      if (actions != null) {\n        final Type type0 = exp.type;\n        final Type type = typeSystem.ensureClosed(type0);\n        actions.add((outLines, outBindings, evalEnv) -> {\n          final Session session = (Session) evalEnv.getOpt(EvalEnv.SESSION);\n          final StringBuilder buf = new StringBuilder();\n          final List<String> outs = new ArrayList<>();\n          try {\n            final Object o = code.eval(evalEnv);\n            final Map<Core.NamedPat, Object> pairs = new LinkedHashMap<>();\n            if (!Closure.bindRecurse(pat.withType(type), o, pairs::put)) {\n              throw new Codes.MorelRuntimeException(Codes.BuiltInExn.BIND, pos);\n            }\n            pairs.forEach((pat2, o2) -> {\n              outBindings.accept(Binding.of(pat2, o2));\n              if (pat2 != skipPat) {\n                int stringDepth = Prop.STRING_DEPTH.intValue(session.map);\n                int lineWidth = Prop.LINE_WIDTH.intValue(session.map);\n                int printDepth = Prop.PRINT_DEPTH.intValue(session.map);\n                int printLength = Prop.PRINT_LENGTH.intValue(session.map);\n                final Pretty pretty =\n                    new Pretty(typeSystem, lineWidth, printLength, printDepth,\n                        stringDepth);\n                final Pretty.TypedVal typedVal;\n                if (o2 instanceof TypedValue) {\n                  TypedValue typedValue = (TypedValue) o2;\n                  typedVal =\n                      new Pretty.TypedVal(pat2.name,\n                          typedValue.valueAs(Object.class),\n                          Keys.toProgressive(pat2.type().key())\n                              .toType(typeSystem));\n                } else {\n                  typedVal = new Pretty.TypedVal(pat2.name, o2, pat2.type);\n                }\n                pretty.pretty(buf, pat2.type, typedVal);\n                final String line = str(buf);\n                outs.add(line);\n                outLines.accept(line);\n              }\n            });\n          } catch (Codes.MorelRuntimeException e) {\n            session.handle(e, buf);\n            final String line = str(buf);\n            outs.add(line);\n            outLines.accept(line);\n          }\n          session.code = code;\n          session.out = ImmutableList.copyOf(outs);\n        });\n      }\n    });\n\n    newBindings.clear();\n  }\n\n  private void link(Map<Core.NamedPat, LinkCode> linkCodes, Core.Pat pat,\n      Code code) {\n    if (pat instanceof Core.IdPat) {\n      final LinkCode linkCode = linkCodes.get(pat);\n      if (linkCode != null) {\n        linkCode.refCode = code; // link the reference to the definition\n      }\n    } else if (pat instanceof Core.TuplePat) {\n      if (code instanceof Codes.TupleCode) {\n        // Recurse into the tuple, binding names to code in parallel\n        final List<Code> codes = ((Codes.TupleCode) code).codes;\n        final List<Core.Pat> pats = ((Core.TuplePat) pat).args;\n        forEach(codes, pats, (code1, pat1) ->\n            link(linkCodes, pat1, code1));\n      }\n    }\n  }\n\n  /** A piece of code that is references another piece of code.\n   * It is useful when defining recursive functions.\n   * The reference is mutable, and is fixed up when the\n   * function has been compiled.\n   */\n  private static class LinkCode implements Code {\n    private Code refCode;\n\n    @Override public Describer describe(Describer describer) {\n      return describer.start(\"link\", d -> {\n        if (false) {\n          // Don't recurse into refCode... or we'll never get out alive.\n          d.arg(\"refCode\", refCode);\n        }\n      });\n    }\n\n    public Object eval(EvalEnv env) {\n      assert refCode != null; // link should have completed by now\n      return refCode.eval(env);\n    }\n  }\n\n  /** Code that implements {@link Compiler#compileMatchList(Context, List)}. */\n  private static class MatchCode implements Code {\n    private final ImmutablePairList<Core.Pat, Code> patCodes;\n    private final Pos pos;\n\n    MatchCode(ImmutablePairList<Core.Pat, Code> patCodes, Pos pos) {\n      this.patCodes = patCodes;\n      this.pos = pos;\n    }\n\n    @Override public Describer describe(Describer describer) {\n      return describer.start(\"match\", d ->\n          patCodes.forEach((pat, code) ->\n              d.arg(\"\", pat.toString()).arg(\"\", code)));\n    }\n\n    @Override public Object eval(EvalEnv evalEnv) {\n      return new Closure(evalEnv, patCodes, pos);\n    }\n  }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "protected static final EvalEnv EMPTY_ENV = Codes.emptyEnv();", "docstring": "", "modifiers": "protected static final", "marker_annotations": [], "non_marker_annotations": ["protected", "static", "final"], "comments": [], "type": "EvalEnv", "name": "EMPTY_ENV = Codes.emptyEnv()", "syntax_pass": true}, {"attribute_expression": "protected final TypeSystem typeSystem;", "docstring": "", "modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "type": "TypeSystem", "name": "typeSystem", "syntax_pass": true}]}, {"uris": "src/main/java/net/hydromatic/morel/compile/TypeResolver.java.TypeResolver", "name": "TypeResolver", "file_path": "src/main/java/net/hydromatic/morel/compile/TypeResolver.java", "superclasses": "", "methods": ["[]TypeResolver(TypeSystem)", "[Resolved]deduceType(Environment,Ast.Decl,TypeSystem)", "[Type]toType(Ast.Type,TypeSystem)", "[Type.Key]toTypeKey(Ast.Type)", "[Resolved]deduceType_(Environment,Ast.Decl)", "[void]checkNoUnresolvedFieldRefs(Ast.Decl,TypeMap)", "[void]forEachUnresolvedField(Ast.Decl,TypeMap,Consumer<Ast.Apply>,Consumer<Ast.Apply>,Consumer<Ast.Apply>)", "[E]reg(E,Unifier.Variable,Unifier.Term)", "[Ast.Exp]deduceType(TypeEnv,Ast.Exp,Unifier.Variable)", "[Pair<TypeEnv, Unifier.Variable>]deduceStepType(TypeEnv,Ast.FromStep,Unifier.Variable,TypeEnv,Map<Ast.Id, Unifier.Variable>,List<Ast.FromStep>)", "[void]validateGroup(Ast.Group)", "[Unifier.Variable]fieldVar(Map<Ast.Id, Unifier.Variable>)", "[Unifier.Term]record(NavigableMap<String, ? extends Unifier.Term>)", "[Unifier.Term]tuple(List<Unifier.Term>)", "[Ast.RecordSelector]deduceRecordSelectorType(TypeEnv,Unifier.Variable,Unifier.Variable,Ast.RecordSelector)", "[List<String>]fieldList(Unifier.Sequence)", "[Ast.Match]deduceMatchType(TypeEnv,Ast.Match,Map<Ast.IdPat, Unifier.Term>,Unifier.Variable,Unifier.Variable)", "[List<Ast.Match>]deduceMatchListType(TypeEnv,List<Ast.Match>,NavigableSet<String>,Unifier.Variable,Unifier.Variable)", "[AstNode]deduceValBindType(TypeEnv,Ast.ValBind,Map<Ast.IdPat, Unifier.Term>,Unifier.Variable,Unifier.Variable)", "[TypeEnv]bindAll(TypeEnv,Map<Ast.IdPat, Unifier.Term>)", "[Ast.Decl]deduceDeclType(TypeEnv,Ast.Decl,Map<Ast.IdPat, Unifier.Term>)", "[Ast.Decl]deduceDataTypeDeclType(TypeEnv,Ast.DatatypeDecl,Map<Ast.IdPat, Unifier.Term>)", "[Ast.Decl]deduceValDeclType(TypeEnv,Ast.ValDecl,Map<Ast.IdPat, Unifier.Term>)", "[void]deduceDatatypeBindType(Ast.DatatypeBind,SortedMap<String, Type.Key>)", "[Ast.ValDecl]toValDecl(TypeEnv,Ast.FunDecl)", "[Ast.ValBind]toValBind(TypeEnv,Ast.FunBind)", "[Ast.Exp]idTuple(List<String>)", "[Ast.Pat]patTuple(TypeEnv,List<Ast.Pat>)", "[Ast.Pat]deducePatType(TypeEnv,Ast.Pat,Map<Ast.IdPat, Unifier.Term>,NavigableSet<String>,Unifier.Variable)", "[Ast.Exp]infix(TypeEnv,Ast.InfixCall,Unifier.Variable,Type)", "[Ast.Exp]infix(TypeEnv,Ast.InfixCall,Unifier.Variable)", "[Ast.Exp]prefix(TypeEnv,Ast.PrefixCall,Unifier.Variable)", "[Unifier.Variable]equiv(Unifier.Term,Unifier.Variable)", "[void]equiv(Unifier.Term,Unifier.Term)", "[List<Unifier.Term>]toTerms(Iterable<? extends Type>,Subst)", "[Unifier.Term]toTerm(PrimitiveType)", "[Unifier.Term]toTerm(Type,Subst)"], "method_uris": ["src/main/java/net/hydromatic/morel/compile/TypeResolver.java.TypeResolver.[]TypeResolver(TypeSystem)", "src/main/java/net/hydromatic/morel/compile/TypeResolver.java.TypeResolver.[Resolved]deduceType(Environment,Ast.Decl,TypeSystem)", "src/main/java/net/hydromatic/morel/compile/TypeResolver.java.TypeResolver.[Type]toType(Ast.Type,TypeSystem)", "src/main/java/net/hydromatic/morel/compile/TypeResolver.java.TypeResolver.[Type.Key]toTypeKey(Ast.Type)", "src/main/java/net/hydromatic/morel/compile/TypeResolver.java.TypeResolver.[Resolved]deduceType_(Environment,Ast.Decl)", "src/main/java/net/hydromatic/morel/compile/TypeResolver.java.TypeResolver.[void]checkNoUnresolvedFieldRefs(Ast.Decl,TypeMap)", "src/main/java/net/hydromatic/morel/compile/TypeResolver.java.TypeResolver.[void]forEachUnresolvedField(Ast.Decl,TypeMap,Consumer<Ast.Apply>,Consumer<Ast.Apply>,Consumer<Ast.Apply>)", "src/main/java/net/hydromatic/morel/compile/TypeResolver.java.TypeResolver.[E]reg(E,Unifier.Variable,Unifier.Term)", "src/main/java/net/hydromatic/morel/compile/TypeResolver.java.TypeResolver.[Ast.Exp]deduceType(TypeEnv,Ast.Exp,Unifier.Variable)", "src/main/java/net/hydromatic/morel/compile/TypeResolver.java.TypeResolver.[Pair<TypeEnv, Unifier.Variable>]deduceStepType(TypeEnv,Ast.FromStep,Unifier.Variable,TypeEnv,Map<Ast.Id, Unifier.Variable>,List<Ast.FromStep>)", "src/main/java/net/hydromatic/morel/compile/TypeResolver.java.TypeResolver.[void]validateGroup(Ast.Group)", "src/main/java/net/hydromatic/morel/compile/TypeResolver.java.TypeResolver.[Unifier.Variable]fieldVar(Map<Ast.Id, Unifier.Variable>)", "src/main/java/net/hydromatic/morel/compile/TypeResolver.java.TypeResolver.[Unifier.Term]record(NavigableMap<String, ? extends Unifier.Term>)", "src/main/java/net/hydromatic/morel/compile/TypeResolver.java.TypeResolver.[Unifier.Term]tuple(List<Unifier.Term>)", "src/main/java/net/hydromatic/morel/compile/TypeResolver.java.TypeResolver.[Ast.RecordSelector]deduceRecordSelectorType(TypeEnv,Unifier.Variable,Unifier.Variable,Ast.RecordSelector)", "src/main/java/net/hydromatic/morel/compile/TypeResolver.java.TypeResolver.[List<String>]fieldList(Unifier.Sequence)", "src/main/java/net/hydromatic/morel/compile/TypeResolver.java.TypeResolver.[Ast.Match]deduceMatchType(TypeEnv,Ast.Match,Map<Ast.IdPat, Unifier.Term>,Unifier.Variable,Unifier.Variable)", "src/main/java/net/hydromatic/morel/compile/TypeResolver.java.TypeResolver.[List<Ast.Match>]deduceMatchListType(TypeEnv,List<Ast.Match>,NavigableSet<String>,Unifier.Variable,Unifier.Variable)", "src/main/java/net/hydromatic/morel/compile/TypeResolver.java.TypeResolver.[AstNode]deduceValBindType(TypeEnv,Ast.ValBind,Map<Ast.IdPat, Unifier.Term>,Unifier.Variable,Unifier.Variable)", "src/main/java/net/hydromatic/morel/compile/TypeResolver.java.TypeResolver.[TypeEnv]bindAll(TypeEnv,Map<Ast.IdPat, Unifier.Term>)", "src/main/java/net/hydromatic/morel/compile/TypeResolver.java.TypeResolver.[Ast.Decl]deduceDeclType(TypeEnv,Ast.Decl,Map<Ast.IdPat, Unifier.Term>)", "src/main/java/net/hydromatic/morel/compile/TypeResolver.java.TypeResolver.[Ast.Decl]deduceDataTypeDeclType(TypeEnv,Ast.DatatypeDecl,Map<Ast.IdPat, Unifier.Term>)", "src/main/java/net/hydromatic/morel/compile/TypeResolver.java.TypeResolver.[Ast.Decl]deduceValDeclType(TypeEnv,Ast.ValDecl,Map<Ast.IdPat, Unifier.Term>)", "src/main/java/net/hydromatic/morel/compile/TypeResolver.java.TypeResolver.[void]deduceDatatypeBindType(Ast.DatatypeBind,SortedMap<String, Type.Key>)", "src/main/java/net/hydromatic/morel/compile/TypeResolver.java.TypeResolver.[Ast.ValDecl]toValDecl(TypeEnv,Ast.FunDecl)", "src/main/java/net/hydromatic/morel/compile/TypeResolver.java.TypeResolver.[Ast.ValBind]toValBind(TypeEnv,Ast.FunBind)", "src/main/java/net/hydromatic/morel/compile/TypeResolver.java.TypeResolver.[Ast.Exp]idTuple(List<String>)", "src/main/java/net/hydromatic/morel/compile/TypeResolver.java.TypeResolver.[Ast.Pat]patTuple(TypeEnv,List<Ast.Pat>)", "src/main/java/net/hydromatic/morel/compile/TypeResolver.java.TypeResolver.[Ast.Pat]deducePatType(TypeEnv,Ast.Pat,Map<Ast.IdPat, Unifier.Term>,NavigableSet<String>,Unifier.Variable)", "src/main/java/net/hydromatic/morel/compile/TypeResolver.java.TypeResolver.[Ast.Exp]infix(TypeEnv,Ast.InfixCall,Unifier.Variable,Type)", "src/main/java/net/hydromatic/morel/compile/TypeResolver.java.TypeResolver.[Ast.Exp]infix(TypeEnv,Ast.InfixCall,Unifier.Variable)", "src/main/java/net/hydromatic/morel/compile/TypeResolver.java.TypeResolver.[Ast.Exp]prefix(TypeEnv,Ast.PrefixCall,Unifier.Variable)", "src/main/java/net/hydromatic/morel/compile/TypeResolver.java.TypeResolver.[Unifier.Variable]equiv(Unifier.Term,Unifier.Variable)", "src/main/java/net/hydromatic/morel/compile/TypeResolver.java.TypeResolver.[void]equiv(Unifier.Term,Unifier.Term)", "src/main/java/net/hydromatic/morel/compile/TypeResolver.java.TypeResolver.[List<Unifier.Term>]toTerms(Iterable<? extends Type>,Subst)", "src/main/java/net/hydromatic/morel/compile/TypeResolver.java.TypeResolver.[Unifier.Term]toTerm(PrimitiveType)", "src/main/java/net/hydromatic/morel/compile/TypeResolver.java.TypeResolver.[Unifier.Term]toTerm(Type,Subst)"], "overrides": null, "attributes": [{"original_string": "  private static class Foo {\n    final Map<String, Integer> tyVarMap = new HashMap<>();\n\n    /** Converts an AST type into a type key. */\n    Type.Key toTypeKey(Ast.Type type) {\n      switch (type.op) {\n      case TUPLE_TYPE:\n        final Ast.TupleType tupleType = (Ast.TupleType) type;\n        return Keys.tuple(toTypeKeys(tupleType.types));\n\n      case RECORD_TYPE:\n        final Ast.RecordType recordType = (Ast.RecordType) type;\n        final SortedMap<String, Type.Key> argNameTypes = mutableMap();\n        final AtomicBoolean progressive = new AtomicBoolean(false);\n        recordType.fieldTypes.forEach((name, t) -> {\n          if (name.equals(PROGRESSIVE_LABEL)) {\n            progressive.set(true);\n          } else {\n            argNameTypes.put(name, toTypeKey(t));\n          }\n        });\n        return progressive.get()\n            ? Keys.progressiveRecord(argNameTypes)\n            : Keys.record(argNameTypes);\n\n      case FUNCTION_TYPE:\n        final Ast.FunctionType functionType = (Ast.FunctionType) type;\n        final Type.Key paramType = toTypeKey(functionType.paramType);\n        final Type.Key resultType = toTypeKey(functionType.resultType);\n        return Keys.fn(paramType, resultType);\n\n      case NAMED_TYPE:\n        final Ast.NamedType namedType = (Ast.NamedType) type;\n        final List<Type.Key> typeList = toTypeKeys(namedType.types);\n        if (namedType.name.equals(LIST_TY_CON) && typeList.size() == 1) {\n          // TODO: make 'list' a regular generic type\n          return Keys.list(typeList.get(0));\n        }\n        if (typeList.isEmpty()) {\n          return Keys.name(namedType.name);\n        } else {\n          return Keys.apply(Keys.name(namedType.name), typeList);\n        }\n\n      case TY_VAR:\n        final Ast.TyVar tyVar = (Ast.TyVar) type;\n        return Keys.ordinal(\n            tyVarMap.computeIfAbsent(tyVar.name,\n                name -> tyVarMap.size()));\n\n      default:\n        throw new AssertionError(\"cannot convert type \" + type + \" \" + type.op);\n      }\n    }\n\n    List<Type.Key> toTypeKeys(Iterable<? extends Ast.Type> types) {\n      return transformEager(types, this::toTypeKey);\n    }\n  }", "definition": "  private static class Foo", "class_docstring": " Workspace for converting types to keys.", "name": "Foo", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "fields": [{"attribute_expression": "final Map<String, Integer> tyVarMap = new HashMap<>();", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "Map<String, Integer>", "name": "tyVarMap = new HashMap<>()", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    Type.Key toTypeKey(Ast.Type type) {\n      switch (type.op) {\n      case TUPLE_TYPE:\n        final Ast.TupleType tupleType = (Ast.TupleType) type;\n        return Keys.tuple(toTypeKeys(tupleType.types));\n\n      case RECORD_TYPE:\n        final Ast.RecordType recordType = (Ast.RecordType) type;\n        final SortedMap<String, Type.Key> argNameTypes = mutableMap();\n        final AtomicBoolean progressive = new AtomicBoolean(false);\n        recordType.fieldTypes.forEach((name, t) -> {\n          if (name.equals(PROGRESSIVE_LABEL)) {\n            progressive.set(true);\n          } else {\n            argNameTypes.put(name, toTypeKey(t));\n          }\n        });\n        return progressive.get()\n            ? Keys.progressiveRecord(argNameTypes)\n            : Keys.record(argNameTypes);\n\n      case FUNCTION_TYPE:\n        final Ast.FunctionType functionType = (Ast.FunctionType) type;\n        final Type.Key paramType = toTypeKey(functionType.paramType);\n        final Type.Key resultType = toTypeKey(functionType.resultType);\n        return Keys.fn(paramType, resultType);\n\n      case NAMED_TYPE:\n        final Ast.NamedType namedType = (Ast.NamedType) type;\n        final List<Type.Key> typeList = toTypeKeys(namedType.types);\n        if (namedType.name.equals(LIST_TY_CON) && typeList.size() == 1) {\n          // TODO: make 'list' a regular generic type\n          return Keys.list(typeList.get(0));\n        }\n        if (typeList.isEmpty()) {\n          return Keys.name(namedType.name);\n        } else {\n          return Keys.apply(Keys.name(namedType.name), typeList);\n        }\n\n      case TY_VAR:\n        final Ast.TyVar tyVar = (Ast.TyVar) type;\n        return Keys.ordinal(\n            tyVarMap.computeIfAbsent(tyVar.name,\n                name -> tyVarMap.size()));\n\n      default:\n        throw new AssertionError(\"cannot convert type \" + type + \" \" + type.op);\n      }\n    }", "docstring": " Converts an AST type into a type key.", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "Type.Key", "classes": []}, "name": "toTypeKey", "params": [{"name": "type", "type": "Ast.Type"}], "body": "                                      {\n      switch (type.op) {\n      case TUPLE_TYPE:\n        final Ast.TupleType tupleType = (Ast.TupleType) type;\n        return Keys.tuple(toTypeKeys(tupleType.types));\n\n      case RECORD_TYPE:\n        final Ast.RecordType recordType = (Ast.RecordType) type;\n        final SortedMap<String, Type.Key> argNameTypes = mutableMap();\n        final AtomicBoolean progressive = new AtomicBoolean(false);\n        recordType.fieldTypes.forEach((name, t) -> {\n          if (name.equals(PROGRESSIVE_LABEL)) {\n            progressive.set(true);\n          } else {\n            argNameTypes.put(name, toTypeKey(t));\n          }\n        });\n        return progressive.get()\n            ? Keys.progressiveRecord(argNameTypes)\n            : Keys.record(argNameTypes);\n\n      case FUNCTION_TYPE:\n        final Ast.FunctionType functionType = (Ast.FunctionType) type;\n        final Type.Key paramType = toTypeKey(functionType.paramType);\n        final Type.Key resultType = toTypeKey(functionType.resultType);\n        return Keys.fn(paramType, resultType);\n\n      case NAMED_TYPE:\n        final Ast.NamedType namedType = (Ast.NamedType) type;\n        final List<Type.Key> typeList = toTypeKeys(namedType.types);\n        if (namedType.name.equals(LIST_TY_CON) && typeList.size() == 1) {\n          // TODO: make 'list' a regular generic type\n          return Keys.list(typeList.get(0));\n        }\n        if (typeList.isEmpty()) {\n          return Keys.name(namedType.name);\n        } else {\n          return Keys.apply(Keys.name(namedType.name), typeList);\n        }\n\n      case TY_VAR:\n        final Ast.TyVar tyVar = (Ast.TyVar) type;\n        return Keys.ordinal(\n            tyVarMap.computeIfAbsent(tyVar.name,\n                name -> tyVarMap.size()));\n\n      default:\n        throw new AssertionError(\"cannot convert type \" + type + \" \" + type.op);\n      }\n    }", "signature": "Type.Key toTypeKey(Ast.Type type)"}, {"syntax_pass": true, "original_string": "    List<Type.Key> toTypeKeys(Iterable<? extends Ast.Type> types) {\n      return transformEager(types, this::toTypeKey);\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "List<Type.Key>", "classes": []}, "name": "toTypeKeys", "params": [{"name": "types", "type": "Iterable<? extends Ast.Type>"}], "body": "                                                                  {\n      return transformEager(types, this::toTypeKey);\n    }", "signature": "List<Type.Key> toTypeKeys(Iterable<? extends Ast.Type> types)"}]}, {"original_string": "  private static class TermVariable {\n    final Unifier.Term term;\n    final Unifier.Variable variable;\n\n    private TermVariable(Unifier.Term term, Unifier.Variable variable) {\n      this.term = term;\n      this.variable = variable;\n    }\n\n    @Override public String toString() {\n      return term + \" = \" + variable;\n    }\n  }", "definition": "  private static class TermVariable", "class_docstring": " Pair consisting of a term and a variable.", "name": "TermVariable", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "fields": [{"attribute_expression": "final Unifier.Term term;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "Unifier.Term", "name": "term", "syntax_pass": true}, {"attribute_expression": "final Unifier.Variable variable;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "Unifier.Variable", "name": "variable", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    private TermVariable(Unifier.Term term, Unifier.Variable variable) {\n      this.term = term;\n      this.variable = variable;\n    }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "", "classes": []}, "name": "TermVariable", "params": [{"name": "term", "type": "Unifier.Term"}, {"name": "variable", "type": "Unifier.Variable"}], "body": "                                                                       {\n      this.term = term;\n      this.variable = variable;\n    }", "signature": "private TermVariable(Unifier.Term term, Unifier.Variable variable)"}, {"syntax_pass": true, "original_string": "    @Override public String toString() {\n      return term + \" = \" + variable;\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "toString", "params": [], "body": "                                       {\n      return term + \" = \" + variable;\n    }", "signature": "@Override public String toString()"}]}, {"original_string": "  private static class BindTypeEnv implements TypeEnv {\n    private final String definedName;\n    private final Function<TypeSystem, Unifier.Term> termFactory;\n    private final TypeEnv parent;\n\n    BindTypeEnv(String definedName,\n        Function<TypeSystem, Unifier.Term> termFactory, TypeEnv parent) {\n      this.definedName = requireNonNull(definedName);\n      this.termFactory = requireNonNull(termFactory);\n      this.parent = requireNonNull(parent);\n    }\n\n    @Override public Unifier.Term get(TypeSystem typeSystem, String name,\n        Function<String, RuntimeException> exceptionFactory) {\n      for (BindTypeEnv e = this;; e = (BindTypeEnv) e.parent) {\n        if (e.definedName.equals(name)) {\n          return e.termFactory.apply(typeSystem);\n        }\n        if (!(e.parent instanceof BindTypeEnv)) {\n          return e.parent.get(typeSystem, name, exceptionFactory);\n        }\n      }\n    }\n\n    @Override public boolean has(String name) {\n      return name.equals(definedName) || parent.has(name);\n    }\n\n    @Override public TypeEnv bind(String name,\n        Function<TypeSystem, Unifier.Term> termFactory) {\n      return new BindTypeEnv(name, termFactory, this);\n    }\n\n    @Override public String toString() {\n      final Map<String, String> map = new LinkedHashMap<>();\n      for (BindTypeEnv e = this;;) {\n        map.putIfAbsent(e.definedName, e.termFactory.toString());\n        if (e.parent instanceof BindTypeEnv) {\n          e = (BindTypeEnv) e.parent;\n        } else {\n          return map.toString();\n        }\n      }\n    }\n  }", "definition": "  private static class BindTypeEnv implements TypeEnv", "class_docstring": " A type environment that consists of a type environment plus one\nbinding.", "name": "BindTypeEnv", "super_interfaces": ["TypeEnv"], "superclasses": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "fields": [{"attribute_expression": "private final String definedName;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "definedName", "syntax_pass": true}, {"attribute_expression": "private final Function<TypeSystem, Unifier.Term> termFactory;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Function<TypeSystem, Unifier.Term>", "name": "termFactory", "syntax_pass": true}, {"attribute_expression": "private final TypeEnv parent;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "TypeEnv", "name": "parent", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    BindTypeEnv(String definedName,\n        Function<TypeSystem, Unifier.Term> termFactory, TypeEnv parent) {\n      this.definedName = requireNonNull(definedName);\n      this.termFactory = requireNonNull(termFactory);\n      this.parent = requireNonNull(parent);\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "BindTypeEnv", "params": [{"name": "definedName", "type": "String"}, {"name": "termFactory", "type": "Function<TypeSystem, Unifier.Term>"}, {"name": "parent", "type": "TypeEnv"}], "body": "                                                                        {\n      this.definedName = requireNonNull(definedName);\n      this.termFactory = requireNonNull(termFactory);\n      this.parent = requireNonNull(parent);\n    }", "signature": "BindTypeEnv(String definedName,\n        Function<TypeSystem, Unifier.Term> termFactory, TypeEnv parent)"}, {"syntax_pass": true, "original_string": "    @Override public Unifier.Term get(TypeSystem typeSystem, String name,\n        Function<String, RuntimeException> exceptionFactory) {\n      for (BindTypeEnv e = this;; e = (BindTypeEnv) e.parent) {\n        if (e.definedName.equals(name)) {\n          return e.termFactory.apply(typeSystem);\n        }\n        if (!(e.parent instanceof BindTypeEnv)) {\n          return e.parent.get(typeSystem, name, exceptionFactory);\n        }\n      }\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Unifier.Term", "classes": []}, "name": "get", "params": [{"name": "typeSystem", "type": "TypeSystem"}, {"name": "name", "type": "String"}, {"name": "exceptionFactory", "type": "Function<String, RuntimeException>"}], "body": "                                                             {\n      for (BindTypeEnv e = this;; e = (BindTypeEnv) e.parent) {\n        if (e.definedName.equals(name)) {\n          return e.termFactory.apply(typeSystem);\n        }\n        if (!(e.parent instanceof BindTypeEnv)) {\n          return e.parent.get(typeSystem, name, exceptionFactory);\n        }\n      }\n    }", "signature": "@Override public Unifier.Term get(TypeSystem typeSystem, String name,\n        Function<String, RuntimeException> exceptionFactory)"}, {"syntax_pass": true, "original_string": "    @Override public boolean has(String name) {\n      return name.equals(definedName) || parent.has(name);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "has", "params": [{"name": "name", "type": "String"}], "body": "                                              {\n      return name.equals(definedName) || parent.has(name);\n    }", "signature": "@Override public boolean has(String name)"}, {"syntax_pass": true, "original_string": "    @Override public TypeEnv bind(String name,\n        Function<TypeSystem, Unifier.Term> termFactory) {\n      return new BindTypeEnv(name, termFactory, this);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "TypeEnv", "classes": []}, "name": "bind", "params": [{"name": "name", "type": "String"}, {"name": "termFactory", "type": "Function<TypeSystem, Unifier.Term>"}], "body": "                                                        {\n      return new BindTypeEnv(name, termFactory, this);\n    }", "signature": "@Override public TypeEnv bind(String name,\n        Function<TypeSystem, Unifier.Term> termFactory)"}, {"syntax_pass": true, "original_string": "    @Override public String toString() {\n      final Map<String, String> map = new LinkedHashMap<>();\n      for (BindTypeEnv e = this;;) {\n        map.putIfAbsent(e.definedName, e.termFactory.toString());\n        if (e.parent instanceof BindTypeEnv) {\n          e = (BindTypeEnv) e.parent;\n        } else {\n          return map.toString();\n        }\n      }\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "toString", "params": [], "body": "                                       {\n      final Map<String, String> map = new LinkedHashMap<>();\n      for (BindTypeEnv e = this;;) {\n        map.putIfAbsent(e.definedName, e.termFactory.toString());\n        if (e.parent instanceof BindTypeEnv) {\n          e = (BindTypeEnv) e.parent;\n        } else {\n          return map.toString();\n        }\n      }\n    }", "signature": "@Override public String toString()"}]}, {"original_string": "  private class TypeEnvHolder implements BiConsumer<String, Type> {\n    private TypeEnv typeEnv;\n\n    TypeEnvHolder(TypeEnv typeEnv) {\n      this.typeEnv = requireNonNull(typeEnv);\n    }\n\n    @Override public void accept(String name, Type type) {\n      typeEnv = typeEnv.bind(name, new Function<TypeSystem, Unifier.Term>() {\n        @Override public Unifier.Term apply(TypeSystem typeSystem_) {\n          return TypeResolver.this.toTerm(type, Subst.EMPTY);\n        }\n\n        @Override public String toString() {\n          return type.moniker();\n        }\n      });\n    }\n  }", "definition": "  private class TypeEnvHolder implements BiConsumer<String, Type>", "class_docstring": " Contains a {@link TypeEnv} and adds to it by calling\n{@link TypeEnv#bind(String, Function)}.", "name": "TypeEnvHolder", "super_interfaces": ["BiConsumer<String, Type>"], "superclasses": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "fields": [{"attribute_expression": "private TypeEnv typeEnv;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "TypeEnv", "name": "typeEnv", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    TypeEnvHolder(TypeEnv typeEnv) {\n      this.typeEnv = requireNonNull(typeEnv);\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "TypeEnvHolder", "params": [{"name": "typeEnv", "type": "TypeEnv"}], "body": "                                   {\n      this.typeEnv = requireNonNull(typeEnv);\n    }", "signature": "TypeEnvHolder(TypeEnv typeEnv)"}, {"syntax_pass": true, "original_string": "    @Override public void accept(String name, Type type) {\n      typeEnv = typeEnv.bind(name, new Function<TypeSystem, Unifier.Term>() {\n        @Override public Unifier.Term apply(TypeSystem typeSystem_) {\n          return TypeResolver.this.toTerm(type, Subst.EMPTY);\n        }\n\n        @Override public String toString() {\n          return type.moniker();\n        }\n      });\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "accept", "params": [{"name": "name", "type": "String"}, {"name": "type", "type": "Type"}], "body": "                                                         {\n      typeEnv = typeEnv.bind(name, new Function<TypeSystem, Unifier.Term>() {\n        @Override public Unifier.Term apply(TypeSystem typeSystem_) {\n          return TypeResolver.this.toTerm(type, Subst.EMPTY);\n        }\n\n        @Override public String toString() {\n          return type.moniker();\n        }\n      });\n    }", "signature": "@Override public void accept(String name, Type type)"}]}, {"original_string": "  public static class Resolved {\n    public final Environment env;\n    public final Ast.Decl originalNode;\n    public final Ast.Decl node;\n    public final TypeMap typeMap;\n\n    private Resolved(Environment env,\n        Ast.Decl originalNode, Ast.Decl node, TypeMap typeMap) {\n      this.env = env;\n      this.originalNode = requireNonNull(originalNode);\n      this.node = requireNonNull(node);\n      this.typeMap = requireNonNull(typeMap);\n      checkArgument(originalNode instanceof Ast.FunDecl\n          ? node instanceof Ast.ValDecl\n          : originalNode.getClass() == node.getClass());\n    }\n\n    static Resolved of(Environment env, Ast.Decl originalNode, Ast.Decl node,\n        TypeMap typeMap) {\n      return new Resolved(env, originalNode, node, typeMap);\n    }\n\n    public Ast.Exp exp() {\n      if (node instanceof Ast.ValDecl) {\n        final Ast.ValDecl valDecl = (Ast.ValDecl) this.node;\n        if (valDecl.valBinds.size() == 1) {\n          final Ast.ValBind valBind = valDecl.valBinds.get(0);\n          return valBind.exp;\n        }\n      }\n      throw new AssertionError(\"not an expression: \" + node);\n    }\n  }", "definition": "  public static class Resolved", "class_docstring": " Result of validating a declaration.", "name": "Resolved", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [{"attribute_expression": "public final Environment env;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "Environment", "name": "env", "syntax_pass": true}, {"attribute_expression": "public final Ast.Decl originalNode;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "Ast.Decl", "name": "originalNode", "syntax_pass": true}, {"attribute_expression": "public final Ast.Decl node;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "Ast.Decl", "name": "node", "syntax_pass": true}, {"attribute_expression": "public final TypeMap typeMap;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "TypeMap", "name": "typeMap", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    private Resolved(Environment env,\n        Ast.Decl originalNode, Ast.Decl node, TypeMap typeMap) {\n      this.env = env;\n      this.originalNode = requireNonNull(originalNode);\n      this.node = requireNonNull(node);\n      this.typeMap = requireNonNull(typeMap);\n      checkArgument(originalNode instanceof Ast.FunDecl\n          ? node instanceof Ast.ValDecl\n          : originalNode.getClass() == node.getClass());\n    }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "", "classes": []}, "name": "Resolved", "params": [{"name": "env", "type": "Environment"}, {"name": "originalNode", "type": "Ast.Decl"}, {"name": "node", "type": "Ast.Decl"}, {"name": "typeMap", "type": "TypeMap"}], "body": "                                                               {\n      this.env = env;\n      this.originalNode = requireNonNull(originalNode);\n      this.node = requireNonNull(node);\n      this.typeMap = requireNonNull(typeMap);\n      checkArgument(originalNode instanceof Ast.FunDecl\n          ? node instanceof Ast.ValDecl\n          : originalNode.getClass() == node.getClass());\n    }", "signature": "private Resolved(Environment env,\n        Ast.Decl originalNode, Ast.Decl node, TypeMap typeMap)"}, {"syntax_pass": true, "original_string": "    static Resolved of(Environment env, Ast.Decl originalNode, Ast.Decl node,\n        TypeMap typeMap) {\n      return new Resolved(env, originalNode, node, typeMap);\n    }", "docstring": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "Resolved", "classes": []}, "name": "of", "params": [{"name": "env", "type": "Environment"}, {"name": "originalNode", "type": "Ast.Decl"}, {"name": "node", "type": "Ast.Decl"}, {"name": "typeMap", "type": "TypeMap"}], "body": "                         {\n      return new Resolved(env, originalNode, node, typeMap);\n    }", "signature": "static Resolved of(Environment env, Ast.Decl originalNode, Ast.Decl node,\n        TypeMap typeMap)"}, {"syntax_pass": true, "original_string": "    public Ast.Exp exp() {\n      if (node instanceof Ast.ValDecl) {\n        final Ast.ValDecl valDecl = (Ast.ValDecl) this.node;\n        if (valDecl.valBinds.size() == 1) {\n          final Ast.ValBind valBind = valDecl.valBinds.get(0);\n          return valBind.exp;\n        }\n      }\n      throw new AssertionError(\"not an expression: \" + node);\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Ast.Exp", "classes": []}, "name": "exp", "params": [], "body": "                         {\n      if (node instanceof Ast.ValDecl) {\n        final Ast.ValDecl valDecl = (Ast.ValDecl) this.node;\n        if (valDecl.valBinds.size() == 1) {\n          final Ast.ValBind valBind = valDecl.valBinds.get(0);\n          return valBind.exp;\n        }\n      }\n      throw new AssertionError(\"not an expression: \" + node);\n    }", "signature": "public Ast.Exp exp()"}]}, {"original_string": "  private abstract static class Subst {\n    static final Subst EMPTY = new EmptySubst();\n\n    Subst plus(TypeVar typeVar, Unifier.Variable variable) {\n      return new PlusSubst(this, typeVar, variable);\n    }\n\n    abstract Unifier.Variable get(TypeVar typeVar);\n  }", "definition": "  private abstract static class Subst", "class_docstring": " Substitution.", "name": "Subst", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "private abstract static", "marker_annotations": [], "non_marker_annotations": ["private", "abstract", "static"], "comments": [], "fields": [{"attribute_expression": "static final Subst EMPTY = new EmptySubst();", "docstring": "", "modifiers": "static final", "marker_annotations": [], "non_marker_annotations": ["static", "final"], "comments": [], "type": "Subst", "name": "EMPTY = new EmptySubst()", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    Subst plus(TypeVar typeVar, Unifier.Variable variable) {\n      return new PlusSubst(this, typeVar, variable);\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "Subst", "classes": []}, "name": "plus", "params": [{"name": "typeVar", "type": "TypeVar"}, {"name": "variable", "type": "Unifier.Variable"}], "body": "                                                           {\n      return new PlusSubst(this, typeVar, variable);\n    }", "signature": "Subst plus(TypeVar typeVar, Unifier.Variable variable)"}, {"syntax_pass": true, "original_string": "    abstract Unifier.Variable get(TypeVar typeVar);", "docstring": "", "attributes": {"modifiers": "abstract", "marker_annotations": [], "non_marker_annotations": ["abstract"], "comments": [], "return_type": "Unifier.Variable", "classes": []}, "name": "get", "params": [{"name": "typeVar", "type": "TypeVar"}], "body": "", "signature": "abstract Unifier.Variable get(TypeVar typeVar)"}]}, {"original_string": "  private static class EmptySubst extends Subst {\n    @Override public String toString() {\n      return \"[]\";\n    }\n\n    @Override Unifier.Variable get(TypeVar typeVar) {\n      return null;\n    }\n  }", "definition": "  private static class EmptySubst extends Subst", "class_docstring": " Empty substitution.", "name": "EmptySubst", "super_interfaces": [], "superclasses": "Subst", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @Override public String toString() {\n      return \"[]\";\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "toString", "params": [], "body": "                                       {\n      return \"[]\";\n    }", "signature": "@Override public String toString()"}, {"syntax_pass": true, "original_string": "    @Override Unifier.Variable get(TypeVar typeVar) {\n      return null;\n    }", "docstring": "", "attributes": {"modifiers": "@Override", "marker_annotations": ["@Override"], "non_marker_annotations": [], "comments": [], "return_type": "Unifier.Variable", "classes": []}, "name": "get", "params": [{"name": "typeVar", "type": "TypeVar"}], "body": "                                                    {\n      return null;\n    }", "signature": "@Override Unifier.Variable get(TypeVar typeVar)"}]}, {"original_string": "  private static class PlusSubst extends Subst {\n    final Subst parent;\n    final TypeVar typeVar;\n    final Unifier.Variable variable;\n\n    PlusSubst(Subst parent, TypeVar typeVar, Unifier.Variable variable) {\n      this.parent = parent;\n      this.typeVar = typeVar;\n      this.variable = variable;\n    }\n\n    @Override Unifier.Variable get(TypeVar typeVar) {\n      return typeVar.equals(this.typeVar)\n          ? variable\n          : parent.get(typeVar);\n    }\n\n    @Override public String toString() {\n      final Map<TypeVar, Unifier.Term> map = new LinkedHashMap<>();\n      for (PlusSubst e = this;;) {\n        map.putIfAbsent(e.typeVar, e.variable);\n        if (e.parent instanceof PlusSubst) {\n          e = (PlusSubst) e.parent;\n        } else {\n          return map.toString();\n        }\n      }\n    }\n  }", "definition": "  private static class PlusSubst extends Subst", "class_docstring": " Substitution that adds one (type, variable) assignment to a parent\nsubstitution.", "name": "PlusSubst", "super_interfaces": [], "superclasses": "Subst", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "fields": [{"attribute_expression": "final Subst parent;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "Subst", "name": "parent", "syntax_pass": true}, {"attribute_expression": "final TypeVar typeVar;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "TypeVar", "name": "typeVar", "syntax_pass": true}, {"attribute_expression": "final Unifier.Variable variable;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "Unifier.Variable", "name": "variable", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    PlusSubst(Subst parent, TypeVar typeVar, Unifier.Variable variable) {\n      this.parent = parent;\n      this.typeVar = typeVar;\n      this.variable = variable;\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "PlusSubst", "params": [{"name": "parent", "type": "Subst"}, {"name": "typeVar", "type": "TypeVar"}, {"name": "variable", "type": "Unifier.Variable"}], "body": "                                                                        {\n      this.parent = parent;\n      this.typeVar = typeVar;\n      this.variable = variable;\n    }", "signature": "PlusSubst(Subst parent, TypeVar typeVar, Unifier.Variable variable)"}, {"syntax_pass": true, "original_string": "    @Override Unifier.Variable get(TypeVar typeVar) {\n      return typeVar.equals(this.typeVar)\n          ? variable\n          : parent.get(typeVar);\n    }", "docstring": "", "attributes": {"modifiers": "@Override", "marker_annotations": ["@Override"], "non_marker_annotations": [], "comments": [], "return_type": "Unifier.Variable", "classes": []}, "name": "get", "params": [{"name": "typeVar", "type": "TypeVar"}], "body": "                                                    {\n      return typeVar.equals(this.typeVar)\n          ? variable\n          : parent.get(typeVar);\n    }", "signature": "@Override Unifier.Variable get(TypeVar typeVar)"}, {"syntax_pass": true, "original_string": "    @Override public String toString() {\n      final Map<TypeVar, Unifier.Term> map = new LinkedHashMap<>();\n      for (PlusSubst e = this;;) {\n        map.putIfAbsent(e.typeVar, e.variable);\n        if (e.parent instanceof PlusSubst) {\n          e = (PlusSubst) e.parent;\n        } else {\n          return map.toString();\n        }\n      }\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "toString", "params": [], "body": "                                       {\n      final Map<TypeVar, Unifier.Term> map = new LinkedHashMap<>();\n      for (PlusSubst e = this;;) {\n        map.putIfAbsent(e.typeVar, e.variable);\n        if (e.parent instanceof PlusSubst) {\n          e = (PlusSubst) e.parent;\n        } else {\n          return map.toString();\n        }\n      }\n    }", "signature": "@Override public String toString()"}]}, {"original_string": "  public static class TypeException extends CompileException {\n    public TypeException(String message, Pos pos) {\n      super(message, false, pos);\n    }\n  }", "definition": "  public static class TypeException extends CompileException", "class_docstring": " Error while deducing type.", "name": "TypeException", "super_interfaces": [], "superclasses": "CompileException", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    public TypeException(String message, Pos pos) {\n      super(message, false, pos);\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "TypeException", "params": [{"name": "message", "type": "String"}, {"name": "pos", "type": "Pos"}], "body": "                                                  {\n      super(message, false, pos);\n    }", "signature": "public TypeException(String message, Pos pos)"}]}, {"original_string": "  static class FieldExpander extends EnvVisitor {\n    static FieldExpander create(TypeSystem typeSystem, Environment env) {\n      return new FieldExpander(typeSystem, env, new ArrayDeque<>());\n    }\n\n    private FieldExpander(TypeSystem typeSystem, Environment env,\n        Deque<FromContext> fromStack) {\n      super(typeSystem, env, fromStack);\n    }\n\n    @Override protected EnvVisitor push(Environment env) {\n      return new FieldExpander(typeSystem, env, fromStack);\n    }\n\n    @Override protected void visit(Ast.Apply apply) {\n      super.visit(apply);\n      expandField(env, apply);\n    }\n\n    @Override protected void visit(Ast.Id id) {\n      super.visit(id);\n      expandField(env, id);\n    }\n\n    private @Nullable TypedValue expandField(Environment env, Ast.Exp exp) {\n      switch (exp.op) {\n      case APPLY:\n        final Ast.Apply apply = (Ast.Apply) exp;\n        if (apply.fn.op == Op.RECORD_SELECTOR) {\n          final Ast.RecordSelector selector = (Ast.RecordSelector) apply.fn;\n          final TypedValue typedValue = expandField(env, apply.arg);\n          if (typedValue != null) {\n            typedValue.discoverField(typeSystem, selector.name);\n            return typedValue.fieldValueAs(selector.name, TypedValue.class);\n          }\n        }\n        return null;\n\n      case ID:\n        final Binding binding = env.getOpt(((Ast.Id) exp).name);\n        if (binding != null\n            && binding.value instanceof TypedValue) {\n          return (TypedValue) binding.value;\n        }\n        // fall through\n\n      default:\n        return null;\n      }\n    }\n  }", "definition": "  static class FieldExpander extends EnvVisitor", "class_docstring": " Visitor that expands progressive types if they are used in field\nreferences.", "name": "FieldExpander", "super_interfaces": [], "superclasses": "EnvVisitor", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    static FieldExpander create(TypeSystem typeSystem, Environment env) {\n      return new FieldExpander(typeSystem, env, new ArrayDeque<>());\n    }", "docstring": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "FieldExpander", "classes": []}, "name": "create", "params": [{"name": "typeSystem", "type": "TypeSystem"}, {"name": "env", "type": "Environment"}], "body": "                                                                        {\n      return new FieldExpander(typeSystem, env, new ArrayDeque<>());\n    }", "signature": "static FieldExpander create(TypeSystem typeSystem, Environment env)"}, {"syntax_pass": true, "original_string": "    private FieldExpander(TypeSystem typeSystem, Environment env,\n        Deque<FromContext> fromStack) {\n      super(typeSystem, env, fromStack);\n    }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "", "classes": []}, "name": "FieldExpander", "params": [{"name": "typeSystem", "type": "TypeSystem"}, {"name": "env", "type": "Environment"}, {"name": "fromStack", "type": "Deque<FromContext>"}], "body": "                                      {\n      super(typeSystem, env, fromStack);\n    }", "signature": "private FieldExpander(TypeSystem typeSystem, Environment env,\n        Deque<FromContext> fromStack)"}, {"syntax_pass": true, "original_string": "    @Override protected EnvVisitor push(Environment env) {\n      return new FieldExpander(typeSystem, env, fromStack);\n    }", "docstring": "", "attributes": {"modifiers": "@Override protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "EnvVisitor", "classes": []}, "name": "push", "params": [{"name": "env", "type": "Environment"}], "body": "                                                         {\n      return new FieldExpander(typeSystem, env, fromStack);\n    }", "signature": "@Override protected EnvVisitor push(Environment env)"}, {"syntax_pass": true, "original_string": "    @Override protected void visit(Ast.Apply apply) {\n      super.visit(apply);\n      expandField(env, apply);\n    }", "docstring": "", "attributes": {"modifiers": "@Override protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "name": "visit", "params": [{"name": "apply", "type": "Ast.Apply"}], "body": "                                                    {\n      super.visit(apply);\n      expandField(env, apply);\n    }", "signature": "@Override protected void visit(Ast.Apply apply)"}, {"syntax_pass": true, "original_string": "    @Override protected void visit(Ast.Id id) {\n      super.visit(id);\n      expandField(env, id);\n    }", "docstring": "", "attributes": {"modifiers": "@Override protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "name": "visit", "params": [{"name": "id", "type": "Ast.Id"}], "body": "                                              {\n      super.visit(id);\n      expandField(env, id);\n    }", "signature": "@Override protected void visit(Ast.Id id)"}, {"syntax_pass": true, "original_string": "    private @Nullable TypedValue expandField(Environment env, Ast.Exp exp) {\n      switch (exp.op) {\n      case APPLY:\n        final Ast.Apply apply = (Ast.Apply) exp;\n        if (apply.fn.op == Op.RECORD_SELECTOR) {\n          final Ast.RecordSelector selector = (Ast.RecordSelector) apply.fn;\n          final TypedValue typedValue = expandField(env, apply.arg);\n          if (typedValue != null) {\n            typedValue.discoverField(typeSystem, selector.name);\n            return typedValue.fieldValueAs(selector.name, TypedValue.class);\n          }\n        }\n        return null;\n\n      case ID:\n        final Binding binding = env.getOpt(((Ast.Id) exp).name);\n        if (binding != null\n            && binding.value instanceof TypedValue) {\n          return (TypedValue) binding.value;\n        }\n        // fall through\n\n      default:\n        return null;\n      }\n    }", "docstring": "", "attributes": {"modifiers": "private @Nullable", "marker_annotations": ["@Nullable"], "non_marker_annotations": ["private"], "comments": [], "return_type": "TypedValue", "classes": []}, "name": "expandField", "params": [{"name": "env", "type": "Environment"}, {"name": "exp", "type": "Ast.Exp"}], "body": "                                                                           {\n      switch (exp.op) {\n      case APPLY:\n        final Ast.Apply apply = (Ast.Apply) exp;\n        if (apply.fn.op == Op.RECORD_SELECTOR) {\n          final Ast.RecordSelector selector = (Ast.RecordSelector) apply.fn;\n          final TypedValue typedValue = expandField(env, apply.arg);\n          if (typedValue != null) {\n            typedValue.discoverField(typeSystem, selector.name);\n            return typedValue.fieldValueAs(selector.name, TypedValue.class);\n          }\n        }\n        return null;\n\n      case ID:\n        final Binding binding = env.getOpt(((Ast.Id) exp).name);\n        if (binding != null\n            && binding.value instanceof TypedValue) {\n          return (TypedValue) binding.value;\n        }\n        // fall through\n\n      default:\n        return null;\n      }\n    }", "signature": "private @Nullable TypedValue expandField(Environment env, Ast.Exp exp)"}]}], "class_docstring": " Resolves the type of an expression.", "original_string": "@SuppressWarnings(\"StaticPseudoFunctionalStyleMethod\")\npublic class TypeResolver {\n  private final TypeSystem typeSystem;\n  private final Unifier unifier = new MartelliUnifier();\n  private final List<TermVariable> terms = new ArrayList<>();\n  private final Map<AstNode, Unifier.Term> map = new HashMap<>();\n  private final Map<Unifier.Variable, Unifier.Action> actionMap =\n      new HashMap<>();\n  private final PairList<Unifier.Variable, PrimitiveType> preferredTypes =\n      PairList.of();\n\n  static final String TUPLE_TY_CON = \"tuple\";\n  static final String LIST_TY_CON = \"list\";\n  static final String RECORD_TY_CON = \"record\";\n  static final String FN_TY_CON = \"fn\";\n\n  /** A field of this name indicates that a record type is progressive. */\n  static final String PROGRESSIVE_LABEL = \"z$dummy\";\n\n  private TypeResolver(TypeSystem typeSystem) {\n    this.typeSystem = requireNonNull(typeSystem);\n  }\n\n  /** Deduces the datatype of a declaration. */\n  public static Resolved deduceType(Environment env, Ast.Decl decl,\n      TypeSystem typeSystem) {\n    final TypeResolver typeResolver = new TypeResolver(typeSystem);\n    int attempt = 0;\n    for (;;) {\n      int original = typeSystem.expandCount.get();\n      final TypeResolver.Resolved resolved =\n          typeResolver.deduceType_(env, decl);\n      if (typeSystem.expandCount.get() == original\n          || attempt++ > 1) {\n        return resolved;\n      }\n    }\n  }\n\n  /** Converts a type AST to a type. */\n  public static Type toType(Ast.Type type, TypeSystem typeSystem) {\n    return typeSystem.typeFor(toTypeKey(type));\n  }\n\n  /** Converts a type AST to a type key. */\n  public static Type.Key toTypeKey(Ast.Type type) {\n    return new Foo().toTypeKey(type);\n  }\n\n  private Resolved deduceType_(Environment env, Ast.Decl decl) {\n    final TypeEnvHolder typeEnvs = new TypeEnvHolder(EmptyTypeEnv.INSTANCE);\n    BuiltIn.forEach(typeSystem, (builtIn, type) -> {\n      if (builtIn.structure == null) {\n        typeEnvs.accept(builtIn.mlName, type);\n      }\n      if (builtIn.alias != null) {\n        typeEnvs.accept(builtIn.alias, type);\n      }\n    });\n    BuiltIn.forEachStructure(typeSystem, (structure, type) ->\n        typeEnvs.accept(structure.name, type));\n    env.forEachType(typeSystem, typeEnvs);\n    final TypeEnv typeEnv = typeEnvs.typeEnv;\n    final Map<Ast.IdPat, Unifier.Term> termMap = new LinkedHashMap<>();\n    final Ast.Decl node2 = deduceDeclType(typeEnv, decl, termMap);\n    final boolean debug = false;\n    @SuppressWarnings(\"ConstantConditions\")\n    final Unifier.Tracer tracer = debug\n        ? Tracers.printTracer(System.out)\n        : Tracers.nullTracer();\n\n    // Deduce types. The loop will retry, just once, if there are certain kinds\n    // of errors.\n    tryAgain:\n    for (;;) {\n      final List<Unifier.TermTerm> termPairs = new ArrayList<>();\n      terms.forEach(tv ->\n          termPairs.add(new Unifier.TermTerm(tv.term, tv.variable)));\n      final Unifier.Result result =\n          unifier.unify(termPairs, actionMap, tracer);\n      if (!(result instanceof Unifier.Substitution)) {\n        final String extra = \";\\n\"\n            + \" term pairs:\\n\"\n            + join(\"\\n\", transform(terms, Object::toString));\n        throw new TypeException(\"Cannot deduce type: \" + result, Pos.ZERO);\n      }\n      final TypeMap typeMap =\n          new TypeMap(typeSystem, map, (Unifier.Substitution) result);\n      while (!preferredTypes.isEmpty()) {\n        Map.Entry<Unifier.Variable, PrimitiveType> x = preferredTypes.remove(0);\n        final Type type =\n            typeMap.termToType(typeMap.substitution.resultMap.get(x.getKey()));\n        if (type instanceof TypeVar) {\n          equiv(toTerm(x.getValue()), x.getKey());\n          continue tryAgain;\n        }\n      }\n\n      final AtomicBoolean progressive = new AtomicBoolean();\n      forEachUnresolvedField(node2, typeMap, apply -> {\n        final Type type = typeMap.getType(apply.arg);\n        if (type.isProgressive()) {\n          progressive.set(true);\n        }\n      }, apply -> {}, apply -> {});\n      if (progressive.get()) {\n        node2.accept(FieldExpander.create(typeSystem, env));\n      } else {\n        checkNoUnresolvedFieldRefs(node2, typeMap);\n      }\n      return Resolved.of(env, decl, node2, typeMap);\n    }\n  }\n\n  /** Checks that there are no field references \"x.y\" or \"#y x\" where \"x\" has\n   * an unresolved type. Throws if there are unresolved field references. */\n  private static void checkNoUnresolvedFieldRefs(Ast.Decl decl,\n      TypeMap typeMap) {\n    forEachUnresolvedField(decl, typeMap,\n        apply -> {\n          throw new TypeException(\"unresolved flex record (can't tell \"\n              + \"what fields there are besides \" + apply.fn + \")\",\n              apply.arg.pos);\n        },\n        apply -> {\n          throw new TypeException(\"reference to field \"\n              + ((Ast.RecordSelector) apply.fn).name\n              + \" of non-record type \" + typeMap.getType(apply.arg),\n              apply.arg.pos);\n        },\n        apply -> {\n          throw new TypeException(\"no field '\"\n              + ((Ast.RecordSelector) apply.fn).name\n              + \"' in type '\" + typeMap.getType(apply.arg) + \"'\",\n              apply.arg.pos);\n        });\n  }\n\n  private static void forEachUnresolvedField(Ast.Decl decl, TypeMap typeMap,\n      Consumer<Ast.Apply> variableConsumer,\n      Consumer<Ast.Apply> notRecordTypeConsumer,\n      Consumer<Ast.Apply> noFieldConsumer) {\n    decl.accept(\n        new Visitor() {\n          @Override protected void visit(Ast.Apply apply) {\n            if (apply.fn.op == Op.RECORD_SELECTOR) {\n              final Ast.RecordSelector recordSelector =\n                  (Ast.RecordSelector) apply.fn;\n              if (typeMap.typeIsVariable(apply.arg)) {\n                variableConsumer.accept(apply);\n              } else {\n                final Collection<String> fieldNames =\n                    typeMap.typeFieldNames(apply.arg);\n                if (fieldNames == null) {\n                  notRecordTypeConsumer.accept(apply);\n                } else {\n                  if (!fieldNames.contains(recordSelector.name)) {\n                    // \"#f r\" is valid if \"r\" is a record type with a field \"f\"\n                    noFieldConsumer.accept(apply);\n                  }\n                }\n              }\n            }\n            super.visit(apply);\n          }\n        });\n  }\n\n  private <E extends AstNode> E reg(E node,\n      Unifier.Variable variable, Unifier.Term term) {\n    requireNonNull(node);\n    requireNonNull(term);\n    map.put(node, term);\n    if (variable != null) {\n      equiv(term, variable);\n    }\n    return node;\n  }\n\n  private Ast.Exp deduceType(TypeEnv env, Ast.Exp node, Unifier.Variable v) {\n    final List<Ast.Exp> args2;\n    final Unifier.Variable v2;\n    final Map<Ast.IdPat, Unifier.Term> termMap;\n    switch (node.op) {\n    case BOOL_LITERAL:\n      return reg(node, v, toTerm(PrimitiveType.BOOL));\n\n    case CHAR_LITERAL:\n      return reg(node, v, toTerm(PrimitiveType.CHAR));\n\n    case INT_LITERAL:\n      return reg(node, v, toTerm(PrimitiveType.INT));\n\n    case REAL_LITERAL:\n      return reg(node, v, toTerm(PrimitiveType.REAL));\n\n    case STRING_LITERAL:\n      return reg(node, v, toTerm(PrimitiveType.STRING));\n\n    case UNIT_LITERAL:\n      return reg(node, v, toTerm(PrimitiveType.UNIT));\n\n    case ANNOTATED_EXP:\n      final Ast.AnnotatedExp annotatedExp = (Ast.AnnotatedExp) node;\n      final Type type = toType(annotatedExp.type, typeSystem);\n      deduceType(env, annotatedExp.exp, v);\n      return reg(node, v, toTerm(type, Subst.EMPTY));\n\n    case ANDALSO:\n    case ORELSE:\n      return infix(env, (Ast.InfixCall) node, v, PrimitiveType.BOOL);\n\n    case TUPLE:\n      final Ast.Tuple tuple = (Ast.Tuple) node;\n      final List<Unifier.Term> types = new ArrayList<>();\n      args2 = new ArrayList<>();\n      for (Ast.Exp arg : tuple.args) {\n        final Unifier.Variable vArg = unifier.variable();\n        args2.add(deduceType(env, arg, vArg));\n        types.add(vArg);\n      }\n      return reg(tuple.copy(args2), v, tuple(types));\n\n    case LIST:\n      final Ast.ListExp list = (Ast.ListExp) node;\n      final Unifier.Variable vArg2 = unifier.variable();\n      args2 = new ArrayList<>();\n      for (Ast.Exp arg : list.args) {\n        args2.add(deduceType(env, arg, vArg2));\n      }\n      return reg(list.copy(args2), v, unifier.apply(LIST_TY_CON, vArg2));\n\n    case RECORD:\n      final Ast.Record record = (Ast.Record) node;\n      final NavigableMap<String, Unifier.Term> labelTypes = new TreeMap<>();\n      final NavigableMap<String, Ast.Exp> map2 = new TreeMap<>();\n      record.args.forEach((name, exp) -> {\n        final Unifier.Variable vArg = unifier.variable();\n        final Ast.Exp e2 = deduceType(env, exp, vArg);\n        labelTypes.put(name, vArg);\n        map2.put(name, e2);\n      });\n      return reg(record.copy(map2), v, record(labelTypes));\n\n    case LET:\n      final Ast.Let let = (Ast.Let) node;\n      termMap = new LinkedHashMap<>();\n      TypeEnv env2 = env;\n      final List<Ast.Decl> decls = new ArrayList<>();\n      for (Ast.Decl decl : let.decls) {\n        decls.add(deduceDeclType(env2, decl, termMap));\n        env2 = bindAll(env2, termMap);\n        termMap.clear();\n      }\n      final Ast.Exp e2 = deduceType(env2, let.exp, v);\n      final Ast.Let let2 = let.copy(decls, e2);\n      return reg(let2, null, v);\n\n    case RECORD_SELECTOR:\n      final Ast.RecordSelector recordSelector = (Ast.RecordSelector) node;\n      throw new RuntimeException(\"Error: unresolved flex record\\n\"\n          + \"   (can't tell what fields there are besides #\"\n          + recordSelector.name + \")\");\n\n    case IF:\n      // TODO: check that condition has type boolean\n      // TODO: check that ifTrue has same type as ifFalse\n      final Ast.If if_ = (Ast.If) node;\n      v2 = unifier.variable();\n      final Ast.Exp condition2 = deduceType(env, if_.condition, v2);\n      equiv(v2, toTerm(PrimitiveType.BOOL));\n      final Ast.Exp ifTrue2 = deduceType(env, if_.ifTrue, v);\n      final Ast.Exp ifFalse2 = deduceType(env, if_.ifFalse, v);\n      final Ast.If if2 = if_.copy(condition2, ifTrue2, ifFalse2);\n      return reg(if2, null, v);\n\n    case CASE:\n      final Ast.Case case_ = (Ast.Case) node;\n      v2 = unifier.variable();\n      final Ast.Exp e2b = deduceType(env, case_.exp, v2);\n      final NavigableSet<String> labelNames = new TreeSet<>();\n      final Unifier.Term argType = map.get(e2b);\n      if (argType instanceof Unifier.Sequence) {\n        final List<String> fieldList = fieldList((Unifier.Sequence) argType);\n        if (fieldList != null) {\n          labelNames.addAll(fieldList);\n        }\n      }\n      final List<Ast.Match> matchList2 =\n          deduceMatchListType(env, case_.matchList, labelNames, v2, v);\n      return reg(case_.copy(e2b, matchList2), null, v);\n\n    case FROM:\n      // \"(from exp: v50 as id: v60 [, exp: v51 as id: v61]...\n      //  [where filterExp: v5] [yield yieldExp: v4]): v\"\n      final Ast.From from = (Ast.From) node;\n      Unifier.Variable v3 = unifier.variable();\n      TypeEnv env3 = env;\n      final Map<Ast.Id, Unifier.Variable> fieldVars = new LinkedHashMap<>();\n      final List<Ast.FromStep> fromSteps = new ArrayList<>();\n      for (Ord<Ast.FromStep> step : Ord.zip(from.steps)) {\n        Pair<TypeEnv, Unifier.Variable> p =\n            deduceStepType(env, step.e, v3, env3, fieldVars, fromSteps);\n        if (step.i != from.steps.size() - 1) {\n          switch (step.e.op) {\n          case COMPUTE:\n            throw new IllegalArgumentException(\n                \"'compute' step must be last in 'from'\");\n          case INTO:\n            throw new CompileException(\"'into' step must be last in 'from'\",\n                false, step.e.pos);\n          }\n        }\n        env3 = p.left;\n        v3 = p.right;\n      }\n      final Ast.Exp yieldExp2;\n      if (from.implicitYieldExp != null) {\n        v3 = unifier.variable();\n        yieldExp2 = deduceType(env3, from.implicitYieldExp, v3);\n      } else {\n        requireNonNull(v3);\n        yieldExp2 = null;\n      }\n      final Ast.From from2 = from.copy(fromSteps, yieldExp2);\n      return reg(from2, v,\n          from.isCompute() || from.isInto() ? v3\n              : unifier.apply(LIST_TY_CON, v3));\n\n    case ID:\n      final Ast.Id id = (Ast.Id) node;\n      final Unifier.Term term = env.get(typeSystem, id.name, name ->\n          new CompileException(\"unbound variable or constructor: \" + name,\n              false, id.pos));\n      return reg(id, v, term);\n\n    case FN:\n      final Ast.Fn fn = (Ast.Fn) node;\n      final Unifier.Variable resultVariable = unifier.variable();\n      final List<Ast.Match> matchList = new ArrayList<>();\n      for (Ast.Match match : fn.matchList) {\n        matchList.add(\n            deduceMatchType(env, match, new HashMap<>(), v, resultVariable));\n      }\n      final Ast.Fn fn2b = fn.copy(matchList);\n      return reg(fn2b, null, v);\n\n    case APPLY:\n      final Ast.Apply apply = (Ast.Apply) node;\n      final Unifier.Variable vFn = unifier.variable();\n      final Unifier.Variable vArg = unifier.variable();\n      equiv(unifier.apply(FN_TY_CON, vArg, v), vFn);\n      final Ast.Exp arg2;\n      if (apply.arg instanceof Ast.RecordSelector) {\n        // node is \"f #field\" and has type \"v\"\n        // \"f\" has type \"vArg -> v\" and also \"vFn\"\n        // \"#field\" has type \"vArg\" and also \"vRec -> vField\"\n        // When we resolve \"vRec\" we can then deduce \"vField\".\n        final Unifier.Variable vRec = unifier.variable();\n        final Unifier.Variable vField = unifier.variable();\n        deduceRecordSelectorType(env, vField, vRec,\n            (Ast.RecordSelector) apply.arg);\n        arg2 = reg(apply.arg, vArg, unifier.apply(FN_TY_CON, vRec, vField));\n      } else {\n        arg2 = deduceType(env, apply.arg, vArg);\n      }\n      final Ast.Exp fn2;\n      if (apply.fn instanceof Ast.RecordSelector) {\n        // node is \"#field arg\" and has type \"v\"\n        // \"#field\" has type \"vArg -> v\"\n        // \"arg\" has type \"vArg\"\n        // When we resolve \"vArg\" we can then deduce \"v\".\n        deduceRecordSelectorType(env, v, vArg,\n            (Ast.RecordSelector) apply.fn);\n        fn2 = apply.fn;\n      } else {\n        fn2 = deduceType(env, apply.fn, vFn);\n      }\n      if (fn2 instanceof Ast.Id) {\n        final BuiltIn builtIn = BuiltIn.BY_ML_NAME.get(((Ast.Id) fn2).name);\n        if (builtIn != null) {\n          builtIn.prefer(t -> preferredTypes.add(v, t));\n        }\n      }\n      return reg(apply.copy(fn2, arg2), null, v);\n\n    case AT:\n    case CARET:\n    case COMPOSE:\n    case PLUS:\n    case MINUS:\n    case TIMES:\n    case DIVIDE:\n    case DIV:\n    case MOD:\n    case EQ:\n    case NE:\n    case GE:\n    case GT:\n    case LE:\n    case LT:\n    case ELEM:\n    case NOT_ELEM:\n    case CONS:\n    case UNION:\n    case INTERSECT:\n    case EXCEPT:\n      return infix(env, (Ast.InfixCall) node, v);\n\n    case NEGATE:\n      return prefix(env, (Ast.PrefixCall) node, v);\n\n    default:\n      throw new AssertionError(\"cannot deduce type for \" + node.op);\n    }\n  }\n\n  private Pair<TypeEnv, Unifier.Variable> deduceStepType(TypeEnv env,\n      Ast.FromStep step, Unifier.Variable v, final TypeEnv env2,\n      Map<Ast.Id, Unifier.Variable> fieldVars, List<Ast.FromStep> fromSteps) {\n    requireNonNull(v);\n    switch (step.op) {\n    case SCAN:\n      final Ast.Scan scan = (Ast.Scan) step;\n      final Ast.Exp scanExp;\n      final boolean eq;\n      final Ast.Exp scanExp3;\n      final Unifier.Variable v15 = unifier.variable();\n      final Unifier.Variable v16 = unifier.variable();\n      final Map<Ast.IdPat, Unifier.Term> termMap1 = new HashMap<>();\n      if (scan.exp == null) {\n        scanExp = null;\n        eq = false;\n        scanExp3 = null;\n      } else if (scan.exp.op == Op.FROM_EQ) {\n        scanExp = ((Ast.PrefixCall) scan.exp).a;\n        eq = true;\n        final Ast.Exp scanExp2 = deduceType(env2, scanExp, v15);\n        scanExp3 = ast.fromEq(scanExp2);\n      } else {\n        scanExp = scan.exp;\n        eq = false;\n        scanExp3 = deduceType(env2, scanExp, v15);\n      }\n      final Ast.Pat pat2 =\n          deducePatType(env2, scan.pat, termMap1, null, v16);\n      if (scanExp != null) {\n        reg(scanExp, v15, eq ? v16 : unifier.apply(LIST_TY_CON, v16));\n      }\n      TypeEnv env4 = env2;\n      for (Map.Entry<Ast.IdPat, Unifier.Term> e : termMap1.entrySet()) {\n        env4 = env4.bind(e.getKey().name, e.getValue());\n        fieldVars.put(ast.id(Pos.ZERO, e.getKey().name),\n            (Unifier.Variable) e.getValue());\n      }\n      v = fieldVar(fieldVars);\n      final Ast.Exp scanCondition2;\n      if (scan.condition != null) {\n        final Unifier.Variable v5 = unifier.variable();\n        scanCondition2 = deduceType(env4, scan.condition, v5);\n        equiv(v5, toTerm(PrimitiveType.BOOL));\n      } else {\n        scanCondition2 = null;\n      }\n      fromSteps.add(scan.copy(pat2, scanExp3, scanCondition2));\n      return Pair.of(env4, v);\n\n    case WHERE:\n      final Ast.Where where = (Ast.Where) step;\n      final Unifier.Variable v5 = unifier.variable();\n      final Ast.Exp filter2 = deduceType(env2, where.exp, v5);\n      equiv(v5, toTerm(PrimitiveType.BOOL));\n      fromSteps.add(where.copy(filter2));\n      return Pair.of(env2, v);\n\n    case SKIP:\n      final Ast.Skip skip = (Ast.Skip) step;\n      final Unifier.Variable v11 = unifier.variable();\n      final Ast.Exp skipCount = deduceType(env2, skip.exp, v11);\n      equiv(v11, toTerm(PrimitiveType.INT));\n      fromSteps.add(skip.copy(skipCount));\n      return Pair.of(env2, v);\n\n    case TAKE:\n      final Ast.Take take = (Ast.Take) step;\n      final Unifier.Variable v12 = unifier.variable();\n      final Ast.Exp takeCount = deduceType(env2, take.exp, v12);\n      equiv(v12, toTerm(PrimitiveType.INT));\n      fromSteps.add(take.copy(takeCount));\n      return Pair.of(env2, v);\n\n    case YIELD:\n      final Ast.Yield yield = (Ast.Yield) step;\n      final Unifier.Variable v6 = unifier.variable();\n      v = v6;\n      final Ast.Exp yieldExp2 = deduceType(env2, yield.exp, v6);\n      fromSteps.add(yield.copy(yieldExp2));\n      if (yieldExp2.op == Op.RECORD) {\n        final Unifier.Sequence sequence =\n            (Unifier.Sequence) map.get(yieldExp2);\n        final Ast.Record record2 = (Ast.Record) yieldExp2;\n        final TypeEnv[] envs = {env};\n        forEach(record2.args.keySet(), sequence.terms, (name, term) ->\n            envs[0] = envs[0].bind(name, term));\n        return Pair.of(envs[0], v);\n      } else {\n        return Pair.of(env2, v);\n      }\n\n    case ORDER:\n      final Ast.Order order = (Ast.Order) step;\n      final List<Ast.OrderItem> orderItems = new ArrayList<>();\n      for (Ast.OrderItem orderItem : order.orderItems) {\n        orderItems.add(\n            orderItem.copy(\n                deduceType(env2, orderItem.exp, unifier.variable()),\n                orderItem.direction));\n      }\n      fromSteps.add(order.copy(orderItems));\n      return Pair.of(env2, v);\n\n    case GROUP:\n    case COMPUTE:\n      final Ast.Group group = (Ast.Group) step;\n      validateGroup(group);\n      TypeEnv env3 = env;\n      fieldVars.clear();\n      final PairList<Ast.Id, Ast.Exp> groupExps = PairList.of();\n      for (Map.Entry<Ast.Id, Ast.Exp> groupExp : group.groupExps) {\n        final Ast.Id id = groupExp.getKey();\n        final Ast.Exp exp = groupExp.getValue();\n        final Unifier.Variable v7 = unifier.variable();\n        final Ast.Exp exp2 = deduceType(env2, exp, v7);\n        reg(id, null, v7);\n        env3 = env3.bind(id.name, v7);\n        fieldVars.put(id, v7);\n        groupExps.add(id, exp2);\n      }\n      final List<Ast.Aggregate> aggregates = new ArrayList<>();\n      for (Ast.Aggregate aggregate : group.aggregates) {\n        final Ast.Id id = aggregate.id;\n        final Unifier.Variable v8 = unifier.variable();\n        reg(id, null, v8);\n        final Unifier.Variable v9 = unifier.variable();\n        final Ast.Exp aggregateFn2 =\n            deduceType(env2, aggregate.aggregate, v9);\n        final Ast.Exp arg2;\n        final Unifier.Variable v10;\n        if (aggregate.argument == null) {\n          arg2 = null;\n          v10 = v;\n        } else {\n          v10 = unifier.variable();\n          arg2 = deduceType(env2, aggregate.argument, v10);\n        }\n        reg(aggregate.aggregate, null, v9);\n        equiv(unifier.apply(FN_TY_CON, unifier.apply(LIST_TY_CON, v10), v8),\n            v9);\n        env3 = env3.bind(id.name, v8);\n        fieldVars.put(id, v8);\n        final Ast.Aggregate aggregate2 =\n            aggregate.copy(aggregateFn2, arg2, aggregate.id);\n        aggregates.add(aggregate2);\n        reg(aggregate2, null, v8);\n      }\n      fromSteps.add(step.op == Op.GROUP\n          ? group.copy(groupExps, aggregates)\n          : ((Ast.Compute) step).copy(aggregates));\n      return Pair.of(env3, v);\n\n    case INTO:\n      // from i in [1,2,3] into f\n      //   f: int list -> string\n      //   expression: string\n      final Ast.Into into = (Ast.Into) step;\n      final Unifier.Variable v13 = unifier.variable();\n      final Unifier.Variable v14 = unifier.variable();\n      final Ast.Exp intoExp = deduceType(env2, into.exp, v14);\n      equiv(unifier.apply(FN_TY_CON, unifier.apply(LIST_TY_CON, v), v13),\n          v14);\n      fromSteps.add(into.copy(intoExp));\n      return Pair.of(EmptyTypeEnv.INSTANCE, v13);\n\n    case THROUGH:\n      // from i in [1,2,3] through p in f\n      //   f: int list -> string list\n      //   expression: string list\n      // v: int (i)\n      // v20: int list\n      // v17: int list -> string list (f)\n      // v18: string (p)\n      // v19: string list (from i in [1,2,3] through p in f)\n      final Ast.Through through = (Ast.Through) step;\n      final Unifier.Variable v17 = unifier.variable();\n      final Unifier.Variable v18 = unifier.variable();\n      final Unifier.Variable v19 = unifier.variable();\n      final Unifier.Variable v20 = unifier.variable();\n      equiv(unifier.apply(LIST_TY_CON, v), v20);\n\n      final Map<Ast.IdPat, Unifier.Term> termMap = new HashMap<>();\n      final Ast.Pat throughPat =\n          deducePatType(env, through.pat, termMap, null, v18);\n      final Ast.Exp throughExp = deduceType(env2, through.exp, v17);\n      equiv(unifier.apply(LIST_TY_CON, v18), v19);\n      equiv(unifier.apply(FN_TY_CON, v20, v19), v17);\n      fromSteps.add(through.copy(throughPat, throughExp));\n      TypeEnv env5 = env;\n      fieldVars.clear();\n      for (Map.Entry<Ast.IdPat, Unifier.Term> e : termMap.entrySet()) {\n        env5 = env5.bind(e.getKey().name, e.getValue());\n        fieldVars.put(ast.id(Pos.ZERO, e.getKey().name),\n            (Unifier.Variable) e.getValue());\n      }\n      return Pair.of(env5, v18);\n\n    default:\n      throw new AssertionError(\"unknown step type \" + step.op);\n    }\n  }\n\n  /** Validates a {@code Group}. Throws if there are duplicate names among\n   * the keys and aggregates. */\n  private void validateGroup(Ast.Group group) {\n    final List<String> names = new ArrayList<>();\n    group.groupExps.leftList().forEach(id -> names.add(id.name));\n    group.aggregates.forEach(aggregate -> names.add(aggregate.id.name));\n    int duplicate = Util.firstDuplicate(names);\n    if (duplicate >= 0) {\n      throw new RuntimeException(\"Duplicate field name '\"\n          + names.get(duplicate) + \"' in group\");\n    }\n  }\n\n  private Unifier.Variable fieldVar(Map<Ast.Id, Unifier.Variable> fieldVars) {\n    switch (fieldVars.size()) {\n    case 0:\n      return equiv(toTerm(PrimitiveType.UNIT), unifier.variable());\n    case 1:\n      return Iterables.getOnlyElement(fieldVars.values());\n    default:\n      final TreeMap<String, Unifier.Variable> map = new TreeMap<>();\n      fieldVars.forEach((k, v) -> map.put(k.name, v));\n      return equiv(record(map), unifier.variable());\n    }\n  }\n\n  private Unifier.Term record(\n      NavigableMap<String, ? extends Unifier.Term> labelTypes) {\n    if (labelTypes.isEmpty()) {\n      return toTerm(PrimitiveType.UNIT);\n    } else if (TypeSystem.areContiguousIntegers(labelTypes.navigableKeySet())\n        && labelTypes.size() != 1) {\n      return unifier.apply(TUPLE_TY_CON, labelTypes.values());\n    } else {\n      final StringBuilder b = new StringBuilder(RECORD_TY_CON);\n      for (String label : labelTypes.navigableKeySet()) {\n        b.append(':').append(label);\n      }\n      return unifier.apply(b.toString(), labelTypes.values());\n    }\n  }\n\n  private Unifier.Term tuple(List<Unifier.Term> types) {\n    if (types.isEmpty()) {\n      return toTerm(PrimitiveType.UNIT);\n    } else {\n      return unifier.apply(TUPLE_TY_CON, types);\n    }\n  }\n\n  private Ast.RecordSelector deduceRecordSelectorType(TypeEnv env,\n      Unifier.Variable vResult, Unifier.Variable vArg,\n      Ast.RecordSelector recordSelector) {\n    final String fieldName = recordSelector.name;\n    actionMap.put(vArg, (v, t, substitution, termPairs) -> {\n      // We now know that the type arg, say \"{a: int, b: real}\".\n      // So, now we can declare that the type of vResult, say \"#b\", is\n      // \"real\".\n      if (t instanceof Unifier.Sequence) {\n        final Unifier.Sequence sequence = (Unifier.Sequence) t;\n        final List<String> fieldList = fieldList(sequence);\n        if (fieldList != null) {\n          int i = fieldList.indexOf(fieldName);\n          if (i >= 0) {\n            final Unifier.Term result2 = substitution.resolve(vResult);\n            final Unifier.Term term = sequence.terms.get(i);\n            final Unifier.Term term2 = substitution.resolve(term);\n            termPairs.add(new Unifier.TermTerm(result2, term2));\n          }\n        }\n      }\n    });\n    return recordSelector;\n  }\n\n  static List<String> fieldList(final Unifier.Sequence sequence) {\n    if (sequence.operator.equals(RECORD_TY_CON)) {\n      return ImmutableList.of();\n    } else if (sequence.operator.startsWith(RECORD_TY_CON + \":\")) {\n      final String[] fields = sequence.operator.split(\":\");\n      return skip(Arrays.asList(fields));\n    } else if (sequence.operator.equals(TUPLE_TY_CON)) {\n      final int size = sequence.terms.size();\n      return TupleType.ordinalNames(size);\n    } else {\n      return null;\n    }\n  }\n\n  private Ast.Match deduceMatchType(TypeEnv env, Ast.Match match,\n      Map<Ast.IdPat, Unifier.Term> termMap, Unifier.Variable argVariable,\n      Unifier.Variable resultVariable) {\n    final Unifier.Variable vPat = unifier.variable();\n    Ast.Pat pat2 = deducePatType(env, match.pat, termMap, null, vPat);\n    TypeEnv env2 = bindAll(env, termMap);\n    Ast.Exp e2 = deduceType(env2, match.exp, resultVariable);\n    Ast.Match match2 = match.copy(pat2, e2);\n    return reg(match2, argVariable,\n        unifier.apply(FN_TY_CON, vPat, resultVariable));\n  }\n\n  private List<Ast.Match> deduceMatchListType(TypeEnv env, List<Ast.Match> matchList,\n      NavigableSet<String> labelNames, Unifier.Variable argVariable,\n      Unifier.Variable resultVariable) {\n    for (Ast.Match match : matchList) {\n      if (match.pat instanceof Ast.RecordPat) {\n        labelNames.addAll(((Ast.RecordPat) match.pat).args.keySet());\n      }\n    }\n    final List<Ast.Match> matchList2 = new ArrayList<>();\n    for (Ast.Match match : matchList) {\n      final Map<Ast.IdPat, Unifier.Term> termMap = new HashMap<>();\n      final Ast.Pat pat2 =\n          deducePatType(env, match.pat, termMap, labelNames, argVariable);\n      final TypeEnv env2 = bindAll(env, termMap);\n      final Ast.Exp e2 = deduceType(env2, match.exp, resultVariable);\n      matchList2.add(match.copy(pat2, e2));\n    }\n    return matchList2;\n  }\n\n  private AstNode deduceValBindType(TypeEnv env, Ast.ValBind valBind,\n      Map<Ast.IdPat, Unifier.Term> termMap, Unifier.Variable v,\n      Unifier.Variable vPat) {\n    deducePatType(env, valBind.pat, termMap, null, vPat);\n    final Ast.Exp e2 = deduceType(env, valBind.exp, vPat);\n    final Ast.ValBind valBind2 = valBind.copy(valBind.pat, e2);\n    return reg(valBind2, v, unifier.apply(FN_TY_CON, vPat, vPat));\n  }\n\n  private static TypeEnv bindAll(TypeEnv env,\n      Map<Ast.IdPat, Unifier.Term> termMap) {\n    for (Map.Entry<Ast.IdPat, Unifier.Term> entry : termMap.entrySet()) {\n      env = env.bind(entry.getKey().name, entry.getValue());\n    }\n    return env;\n  }\n\n  private Ast.Decl deduceDeclType(TypeEnv env, Ast.Decl node,\n      Map<Ast.IdPat, Unifier.Term> termMap) {\n    switch (node.op) {\n    case VAL_DECL:\n      return deduceValDeclType(env, (Ast.ValDecl) node, termMap);\n\n    case FUN_DECL:\n      final Ast.ValDecl valDecl = toValDecl(env, (Ast.FunDecl) node);\n      return deduceValDeclType(env, valDecl, termMap);\n\n    case DATATYPE_DECL:\n      final Ast.DatatypeDecl datatypeDecl = (Ast.DatatypeDecl) node;\n      return deduceDataTypeDeclType(env, datatypeDecl, termMap);\n\n    default:\n      throw new AssertionError(\"cannot deduce type for \" + node.op + \" [\"\n          + node + \"]\");\n    }\n  }\n\n  private Ast.Decl deduceDataTypeDeclType(TypeEnv env,\n      Ast.DatatypeDecl datatypeDecl,\n      Map<Ast.IdPat, Unifier.Term> termMap) {\n    final List<Keys.DataTypeKey> keys = new ArrayList<>();\n    for (Ast.DatatypeBind bind : datatypeDecl.binds) {\n      final Foo foo = new Foo();\n      bind.tyVars.forEach(foo::toTypeKey);\n\n      final SortedMap<String, Type.Key> tyCons = new TreeMap<>();\n      deduceDatatypeBindType(bind, tyCons);\n\n      keys.add(\n          Keys.datatype(bind.name.name, Keys.ordinals(foo.tyVarMap.size()),\n              tyCons));\n    }\n    final List<Type> types = typeSystem.dataTypes(keys);\n\n    forEach(datatypeDecl.binds, types, (datatypeBind, type) -> {\n      final DataType dataType =\n          (DataType) (type instanceof DataType ? type\n              : ((ForallType) type).type);\n      for (Ast.TyCon tyCon : datatypeBind.tyCons) {\n        final Type tyConType;\n        if (tyCon.type != null) {\n          final Type.Key conKey = toTypeKey(tyCon.type);\n          tyConType = typeSystem.fnType(conKey.toType(typeSystem), dataType);\n        } else {\n          tyConType = dataType;\n        }\n        termMap.put((Ast.IdPat) ast.idPat(tyCon.pos, tyCon.id.name),\n            toTerm(tyConType, Subst.EMPTY));\n        map.put(tyCon, toTerm(tyConType, Subst.EMPTY));\n      }\n    });\n\n    map.put(datatypeDecl, toTerm(PrimitiveType.UNIT));\n    return datatypeDecl;\n  }\n\n  private Ast.Decl deduceValDeclType(TypeEnv env, Ast.ValDecl valDecl,\n      Map<Ast.IdPat, Unifier.Term> termMap) {\n    final Holder<TypeEnv> envHolder = Holder.of(env);\n    final Map<Ast.ValBind, Supplier<Unifier.Variable>> map0 =\n        new LinkedHashMap<>();\n    //noinspection FunctionalExpressionCanBeFolded\n    valDecl.valBinds.forEach(b ->\n        map0.put(b, Suppliers.memoize(unifier::variable)::get));\n    map0.forEach((valBind, vPatSupplier) -> {\n      // If recursive, bind each value (presumably a function) to its type\n      // in the environment before we try to deduce the type of the expression.\n      if (valDecl.rec && valBind.pat instanceof Ast.IdPat) {\n        envHolder.set(\n            envHolder.get().bind(\n                ((Ast.IdPat) valBind.pat).name, vPatSupplier.get()));\n      }\n    });\n    final List<Ast.ValBind> valBinds = new ArrayList<>();\n    final TypeEnv env2 = envHolder.get();\n    map0.forEach((valBind, vPatSupplier) ->\n        valBinds.add((Ast.ValBind)\n            deduceValBindType(env2, valBind, termMap, unifier.variable(),\n                vPatSupplier.get())));\n    Ast.Decl node2 = valDecl.copy(valBinds);\n    map.put(node2, toTerm(PrimitiveType.UNIT));\n    return node2;\n  }\n\n  private void deduceDatatypeBindType(Ast.DatatypeBind datatypeBind,\n      SortedMap<String, Type.Key> tyCons) {\n    Foo foo = new Foo();\n    for (Ast.TyCon tyCon : datatypeBind.tyCons) {\n      tyCons.put(tyCon.id.name,\n          tyCon.type == null ? Keys.dummy() : foo.toTypeKey(tyCon.type));\n    }\n  }\n\n  /** Workspace for converting types to keys. */\n  private static class Foo {\n    final Map<String, Integer> tyVarMap = new HashMap<>();\n\n    /** Converts an AST type into a type key. */\n    Type.Key toTypeKey(Ast.Type type) {\n      switch (type.op) {\n      case TUPLE_TYPE:\n        final Ast.TupleType tupleType = (Ast.TupleType) type;\n        return Keys.tuple(toTypeKeys(tupleType.types));\n\n      case RECORD_TYPE:\n        final Ast.RecordType recordType = (Ast.RecordType) type;\n        final SortedMap<String, Type.Key> argNameTypes = mutableMap();\n        final AtomicBoolean progressive = new AtomicBoolean(false);\n        recordType.fieldTypes.forEach((name, t) -> {\n          if (name.equals(PROGRESSIVE_LABEL)) {\n            progressive.set(true);\n          } else {\n            argNameTypes.put(name, toTypeKey(t));\n          }\n        });\n        return progressive.get()\n            ? Keys.progressiveRecord(argNameTypes)\n            : Keys.record(argNameTypes);\n\n      case FUNCTION_TYPE:\n        final Ast.FunctionType functionType = (Ast.FunctionType) type;\n        final Type.Key paramType = toTypeKey(functionType.paramType);\n        final Type.Key resultType = toTypeKey(functionType.resultType);\n        return Keys.fn(paramType, resultType);\n\n      case NAMED_TYPE:\n        final Ast.NamedType namedType = (Ast.NamedType) type;\n        final List<Type.Key> typeList = toTypeKeys(namedType.types);\n        if (namedType.name.equals(LIST_TY_CON) && typeList.size() == 1) {\n          // TODO: make 'list' a regular generic type\n          return Keys.list(typeList.get(0));\n        }\n        if (typeList.isEmpty()) {\n          return Keys.name(namedType.name);\n        } else {\n          return Keys.apply(Keys.name(namedType.name), typeList);\n        }\n\n      case TY_VAR:\n        final Ast.TyVar tyVar = (Ast.TyVar) type;\n        return Keys.ordinal(\n            tyVarMap.computeIfAbsent(tyVar.name,\n                name -> tyVarMap.size()));\n\n      default:\n        throw new AssertionError(\"cannot convert type \" + type + \" \" + type.op);\n      }\n    }\n\n    List<Type.Key> toTypeKeys(Iterable<? extends Ast.Type> types) {\n      return transformEager(types, this::toTypeKey);\n    }\n  }\n\n  /** Converts a function declaration to a value declaration.\n   * In other words, {@code fun} is syntactic sugar, and this\n   * is the de-sugaring machine.\n   *\n   * <p>For example, {@code fun inc x = x + 1}\n   * becomes {@code val rec inc = fn x => x + 1}.\n   *\n   * <p>If there are multiple arguments, there is one {@code fn} for each\n   * argument: {@code fun sum x y = x + y}\n   * becomes {@code val rec sum = fn x => fn y => x + y}.\n   *\n   * <p>If there are multiple clauses, we generate {@code case}:\n   * {@code fun gcd a 0 = a | gcd a b = gcd b (a mod b)}\n   * becomes\n   * {@code val rec gcd = fn x => fn y =>\n   * case (x, y) of\n   *     (a, 0) => a\n   *   | (a, b) = gcd b (a mod b)}.\n   */\n  private Ast.ValDecl toValDecl(TypeEnv env, Ast.FunDecl funDecl) {\n    final List<Ast.ValBind> valBindList = new ArrayList<>();\n    for (Ast.FunBind funBind : funDecl.funBinds) {\n      valBindList.add(toValBind(env, funBind));\n    }\n    return ast.valDecl(funDecl.pos, true, valBindList);\n  }\n\n  private Ast.ValBind toValBind(TypeEnv env, Ast.FunBind funBind) {\n    final List<Ast.Pat> vars;\n    Ast.Exp exp;\n    Ast.Type returnType = null;\n    if (funBind.matchList.size() == 1) {\n      final Ast.FunMatch funMatch = funBind.matchList.get(0);\n      exp = funMatch.exp;\n      vars = funMatch.patList;\n      returnType = funMatch.returnType;\n    } else {\n      final List<String> varNames =\n          MapList.of(funBind.matchList.get(0).patList.size(),\n              index -> \"v\" + index);\n      vars = Lists.transform(varNames, v -> ast.idPat(Pos.ZERO, v));\n      final List<Ast.Match> matchList = new ArrayList<>();\n      Pos prevReturnTypePos = null;\n      for (Ast.FunMatch funMatch : funBind.matchList) {\n        matchList.add(\n            ast.match(funMatch.pos, patTuple(env, funMatch.patList),\n                funMatch.exp));\n        if (funMatch.returnType != null) {\n          if (returnType != null\n              && !returnType.equals(funMatch.returnType)) {\n            throw new CompileException(\"parameter or result constraints of \"\n                + \"clauses don't agree [tycon mismatch]\", false,\n                prevReturnTypePos.plus(funMatch.pos));\n          }\n          returnType = funMatch.returnType;\n          prevReturnTypePos = funMatch.pos;\n        }\n      }\n      exp = ast.caseOf(Pos.ZERO, idTuple(varNames), matchList);\n    }\n    if (returnType != null) {\n      exp = ast.annotatedExp(exp.pos, exp, returnType);\n    }\n    final Pos pos = funBind.pos;\n    for (Ast.Pat var : Lists.reverse(vars)) {\n      exp = ast.fn(pos, ast.match(pos, var, exp));\n    }\n    return ast.valBind(pos, ast.idPat(pos, funBind.name), exp);\n  }\n\n  /** Converts a list of variable names to a variable or tuple.\n   *\n   * <p>For example, [\"x\"] becomes \"{@code x}\" (an {@link Ast.Id}),\n   * and [\"x\", \"y\"] becomes \"{@code (x, y)}\" (a {@link Ast.Tuple} of\n   * {@link Ast.Id Ids}). */\n  private static Ast.Exp idTuple(List<String> vars) {\n    final List<Ast.Id> idList =\n        Lists.transform(vars, v -> ast.id(Pos.ZERO, v));\n    if (idList.size() == 1) {\n      return idList.get(0);\n    }\n    return ast.tuple(Pos.ZERO, idList);\n  }\n\n  /** Converts a list of patterns to a singleton pattern or tuple pattern. */\n  @SuppressWarnings(\"SwitchStatementWithTooFewBranches\")\n  private Ast.Pat patTuple(TypeEnv env, List<Ast.Pat> patList) {\n    final List<Ast.Pat> list2 = new ArrayList<>();\n    for (int i = 0; i < patList.size(); i++) {\n      final Ast.Pat pat = patList.get(i);\n      switch (pat.op) {\n      case ID_PAT:\n        final Ast.IdPat idPat = (Ast.IdPat) pat;\n        if (env.has(idPat.name)\n            && typeSystem.lookupTyCon(idPat.name) != null) {\n          final Unifier.Term term = env.get(typeSystem, idPat.name, name ->\n              new RuntimeException(\"oops, should have \" + idPat.name));\n          if (term instanceof Unifier.Sequence\n              && ((Unifier.Sequence) term).operator.equals(FN_TY_CON)) {\n            list2.add(\n                ast.conPat(idPat.pos, ast.id(idPat.pos, idPat.name),\n                    patList.get(++i)));\n          } else {\n            list2.add(ast.con0Pat(idPat.pos, ast.id(idPat.pos, idPat.name)));\n          }\n          break;\n        }\n        // fall through\n      default:\n        list2.add(pat);\n      }\n    }\n    if (list2.size() == 1) {\n      return list2.get(0);\n    } else {\n      return ast.tuplePat(Pos.sum(list2), list2);\n    }\n  }\n\n  /** Derives a type term for a pattern, collecting the names of pattern\n   * variables.\n   *\n   * @param env Compile-time environment\n   * @param pat Pattern AST\n   * @param termMap Map from names to bound terms, populated by this method\n   * @param labelNames List of names of labels in this pattern and sibling\n   *   patterns in a {@code |} match, or null if not a record pattern\n   * @param v Type variable that this method should equate the type term that it\n   *   derives for this pattern */\n  private Ast.Pat deducePatType(TypeEnv env, Ast.Pat pat,\n      Map<Ast.IdPat, Unifier.Term> termMap, NavigableSet<String> labelNames,\n      Unifier.Variable v) {\n    switch (pat.op) {\n    case BOOL_LITERAL_PAT:\n      return reg(pat, v, toTerm(PrimitiveType.BOOL));\n\n    case CHAR_LITERAL_PAT:\n      return reg(pat, v, toTerm(PrimitiveType.CHAR));\n\n    case INT_LITERAL_PAT:\n      return reg(pat, v, toTerm(PrimitiveType.INT));\n\n    case REAL_LITERAL_PAT:\n      return reg(pat, v, toTerm(PrimitiveType.REAL));\n\n    case STRING_LITERAL_PAT:\n      return reg(pat, v, toTerm(PrimitiveType.STRING));\n\n    case ID_PAT:\n      termMap.put((Ast.IdPat) pat, v);\n      // fall through\n\n    case WILDCARD_PAT:\n      return reg(pat, null, v);\n\n    case AS_PAT:\n      final Ast.AsPat asPat = (Ast.AsPat) pat;\n      termMap.put(asPat.id, v);\n      deducePatType(env, asPat.pat, termMap, null, v);\n      return reg(pat, null, v);\n\n    case ANNOTATED_PAT:\n      final Ast.AnnotatedPat annotatedPat = (Ast.AnnotatedPat) pat;\n      final Type type = toType(annotatedPat.type, typeSystem);\n      deducePatType(env, annotatedPat.pat, termMap, null, v);\n      return reg(pat, v, toTerm(type, Subst.EMPTY));\n\n    case TUPLE_PAT:\n      final List<Unifier.Term> typeTerms = new ArrayList<>();\n      final Ast.TuplePat tuple = (Ast.TuplePat) pat;\n      for (Ast.Pat arg : tuple.args) {\n        final Unifier.Variable vArg = unifier.variable();\n        deducePatType(env, arg, termMap, null, vArg);\n        typeTerms.add(vArg);\n      }\n      return reg(pat, v, tuple(typeTerms));\n\n    case RECORD_PAT:\n      // First, determine the set of field names.\n      //\n      // If the pattern is in a 'case', we know the field names from the\n      // argument. But it we are in a function, we require at least one of the\n      // patterns to not be a wildcard and not have an ellipsis. For example, in\n      //\n      //  fun f {a=1,...} = 1 | f {b=2,...} = 2\n      //\n      // we cannot deduce whether a 'c' field is allowed.\n      final Ast.RecordPat recordPat = (Ast.RecordPat) pat;\n      final NavigableMap<String, Unifier.Term> labelTerms =\n          RecordType.mutableMap();\n      if (labelNames == null) {\n        labelNames = new TreeSet<>(recordPat.args.keySet());\n      }\n      final SortedMap<String, Ast.Pat> args = RecordType.mutableMap();\n      for (String labelName : labelNames) {\n        final Unifier.Variable vArg = unifier.variable();\n        labelTerms.put(labelName, vArg);\n        final Ast.Pat argPat = recordPat.args.get(labelName);\n        if (argPat != null) {\n          args.put(labelName,\n              deducePatType(env, argPat, termMap, null, vArg));\n        }\n      }\n      final Unifier.Term record = record(labelTerms);\n      final Ast.RecordPat recordPat2 = recordPat.copy(recordPat.ellipsis, args);\n      if (!recordPat.ellipsis) {\n        return reg(recordPat2, v, record);\n      }\n      final Unifier.Variable v2 = unifier.variable();\n      equiv(record, v2);\n      actionMap.put(v, (v3, t, substitution, termPairs) -> {\n        // We now know the type of the source record, say \"{a: int, b: real}\".\n        // So, now we can fill out the ellipsis.\n        assert v == v3;\n        if (t instanceof Unifier.Sequence) {\n          final Unifier.Sequence sequence = (Unifier.Sequence) t;\n          final List<String> fieldList = fieldList(sequence);\n          if (fieldList != null) {\n            final NavigableMap<String, Unifier.Term> labelTerms2 =\n                RecordType.mutableMap();\n            forEachIndexed(fieldList, (fieldName, i) -> {\n              if (labelTerms.containsKey(fieldName)) {\n                labelTerms2.put(fieldName, sequence.terms.get(i));\n              }\n            });\n            final Unifier.Term result2 = substitution.resolve(v2);\n            final Unifier.Term term2 = record(labelTerms2);\n            termPairs.add(new Unifier.TermTerm(result2, term2));\n          }\n        }\n      });\n      return reg(recordPat2, null, record);\n\n    case CON_PAT:\n      final Ast.ConPat conPat = (Ast.ConPat) pat;\n      // e.g. \"SOME x\" has type \"int option\", \"x\" has type \"int\"\n      final Pair<DataType, Type.Key> pair =\n          typeSystem.lookupTyCon(conPat.tyCon.name);\n      if (pair == null) {\n        throw new AssertionError(\"not found: \" + conPat.tyCon.name);\n      }\n      final DataType dataType = pair.left;\n      final Type argType = pair.right.toType(typeSystem);\n      final Unifier.Variable vArg = unifier.variable();\n      deducePatType(env, conPat.pat, termMap, null, vArg);\n      final Unifier.Term argTerm = toTerm(argType, Subst.EMPTY);\n      equiv(vArg, argTerm);\n      final Unifier.Term term = toTerm(dataType, Subst.EMPTY);\n      if (argType instanceof TypeVar) {\n        // E.g. Suppose arg is \"NODE 'b\"\n        // (therefore argType is \"'b\", argTerm is \"T7\"),\n        // datatype is \"('a,'b) tree\"\n        // (therefore term is \"tree(T8,T9)\").\n        // We can say that argTerm (T7) is equivalent to\n        // the second type parameter (T9).\n        //\n        // TODO: handle more complex types, e.g. \"NODE (int * 'b)\"\n        equiv(argTerm,\n            ((Unifier.Sequence) term).terms.get(((TypeVar) argType).ordinal));\n      }\n      return reg(pat, v, term);\n\n    case CON0_PAT:\n      final Ast.Con0Pat con0Pat = (Ast.Con0Pat) pat;\n      final Pair<DataType, Type.Key> pair0 =\n          typeSystem.lookupTyCon(con0Pat.tyCon.name);\n      if (pair0 == null) {\n        throw new AssertionError();\n      }\n      final DataType dataType0 = pair0.left;\n      return reg(pat, v, toTerm(dataType0, Subst.EMPTY));\n\n    case LIST_PAT:\n      final Ast.ListPat list = (Ast.ListPat) pat;\n      final Unifier.Variable vArg2 = unifier.variable();\n      for (Ast.Pat arg : list.args) {\n        deducePatType(env, arg, termMap, null, vArg2);\n      }\n      return reg(list, v, unifier.apply(LIST_TY_CON, vArg2));\n\n    case CONS_PAT:\n      final Unifier.Variable elementType = unifier.variable();\n      final Ast.InfixPat call = (Ast.InfixPat) pat;\n      deducePatType(env, call.p0, termMap, null, elementType);\n      deducePatType(env, call.p1, termMap, null, v);\n      return reg(call, v, unifier.apply(LIST_TY_CON, elementType));\n\n    default:\n      throw new AssertionError(\"cannot deduce type for pattern \" + pat.op);\n    }\n  }\n\n  /** Registers an infix operator whose type is a given type. */\n  private Ast.Exp infix(TypeEnv env, Ast.InfixCall call, Unifier.Variable v,\n      Type type) {\n    final Unifier.Term term = toTerm(type, Subst.EMPTY);\n    final Ast.Exp a0 = deduceType(env, call.a0, v);\n    final Ast.Exp a1 = deduceType(env, call.a1, v);\n    return reg(call.copy(a0, a1), v, term);\n  }\n\n  /** Registers an infix operator. */\n  private Ast.Exp infix(TypeEnv env, Ast.InfixCall call,\n      Unifier.Variable v) {\n    return deduceType(env,\n        ast.apply(ast.id(Pos.ZERO, call.op.opName),\n            ast.tuple(Pos.ZERO, ImmutableList.of(call.a0, call.a1))), v);\n  }\n\n  /** Registers a prefix operator. */\n  private Ast.Exp prefix(TypeEnv env, Ast.PrefixCall call, Unifier.Variable v) {\n    return deduceType(env,\n        ast.apply(ast.id(Pos.ZERO, call.op.opName), call.a), v);\n  }\n\n  private Unifier.Variable equiv(Unifier.Term term, Unifier.Variable v) {\n    terms.add(new TermVariable(term, v));\n    return v;\n  }\n\n  private void equiv(Unifier.Term term, Unifier.Term term2) {\n    if (term2 instanceof Unifier.Variable) {\n      equiv(term, (Unifier.Variable) term2);\n    } else if (term instanceof Unifier.Variable) {\n      equiv(term2, (Unifier.Variable) term);\n    } else {\n      final Unifier.Variable variable = unifier.variable();\n      equiv(term, variable);\n      equiv(term2, variable);\n    }\n  }\n\n  private List<Unifier.Term> toTerms(Iterable<? extends Type> types,\n      Subst subst) {\n    return transformEager(types, type -> toTerm(type, subst));\n  }\n\n  private Unifier.Term toTerm(PrimitiveType type) {\n    return unifier.atom(type.moniker);\n  }\n\n  private Unifier.Term toTerm(Type type, Subst subst) {\n    switch (type.op()) {\n    case ID:\n      return toTerm((PrimitiveType) type);\n    case TY_VAR:\n      final Unifier.Variable variable = subst.get((TypeVar) type);\n      return variable != null ? variable : unifier.variable();\n    case DATA_TYPE:\n      final DataType dataType = (DataType) type;\n      return unifier.apply(dataType.name(), toTerms(dataType.arguments, subst));\n    case FUNCTION_TYPE:\n      final FnType fnType = (FnType) type;\n      return unifier.apply(FN_TY_CON, toTerm(fnType.paramType, subst),\n          toTerm(fnType.resultType, subst));\n    case TUPLE_TYPE:\n      final TupleType tupleType = (TupleType) type;\n      return unifier.apply(TUPLE_TY_CON,\n          transform(tupleType.argTypes, type1 -> toTerm(type1, subst)));\n    case RECORD_TYPE:\n      final RecordType recordType = (RecordType) type;\n      SortedMap<String, Type> argNameTypes = recordType.argNameTypes;\n      if (recordType.isProgressive()) {\n        argNameTypes = new TreeMap<>(argNameTypes);\n        argNameTypes.put(PROGRESSIVE_LABEL, PrimitiveType.UNIT);\n      }\n      @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n      final NavigableSet<String> labelNames =\n          (NavigableSet) argNameTypes.keySet();\n      final String result;\n      if (labelNames.isEmpty()) {\n        result = PrimitiveType.UNIT.name();\n      } else if (TypeSystem.areContiguousIntegers(labelNames)) {\n        result = TUPLE_TY_CON;\n      } else {\n        final StringBuilder b = new StringBuilder(RECORD_TY_CON);\n        for (String label : labelNames) {\n          b.append(':').append(label);\n        }\n        result = b.toString();\n      }\n      final List<Unifier.Term> args =\n          transformEager(argNameTypes.values(),\n              type1 -> toTerm(type1, subst));\n      return unifier.apply(result, args);\n    case LIST:\n      final ListType listType = (ListType) type;\n      return unifier.apply(LIST_TY_CON,\n          toTerm(listType.elementType, subst));\n    case FORALL_TYPE:\n      final ForallType forallType = (ForallType) type;\n      Subst subst2 = subst;\n      for (int i = 0; i < forallType.parameterCount; i++) {\n        subst2 = subst2.plus(typeSystem.typeVariable(i), unifier.variable());\n      }\n      return toTerm(forallType.type, subst2);\n    default:\n      throw new AssertionError(\"unknown type: \" + type.moniker());\n    }\n  }\n\n  /** Empty type environment. */\n  enum EmptyTypeEnv implements TypeEnv {\n    INSTANCE;\n\n    @Override public Unifier.Term get(TypeSystem typeSystem, String name,\n        Function<String, RuntimeException> exceptionFactory) {\n      throw exceptionFactory.apply(name);\n    }\n\n    @Override public boolean has(String name) {\n      return false;\n    }\n\n    @Override public TypeEnv bind(String name,\n        Function<TypeSystem, Unifier.Term> termFactory) {\n      return new BindTypeEnv(name, termFactory, this);\n    }\n\n    @Override public String toString() {\n      return \"[]\";\n    }\n  }\n\n  /** Type environment. */\n  interface TypeEnv {\n    Unifier.Term get(TypeSystem typeSystem, String name,\n        Function<String, RuntimeException> exceptionFactory);\n    boolean has(String name);\n    TypeEnv bind(String name, Function<TypeSystem, Unifier.Term> termFactory);\n\n    default TypeEnv bind(String name, Unifier.Term term) {\n      return bind(name, new Function<TypeSystem, Unifier.Term>() {\n        @Override public Unifier.Term apply(TypeSystem typeSystem) {\n          return term;\n        }\n\n        @Override public String toString() {\n          return term.toString();\n        }\n      });\n    }\n  }\n\n  /** Pair consisting of a term and a variable. */\n  private static class TermVariable {\n    final Unifier.Term term;\n    final Unifier.Variable variable;\n\n    private TermVariable(Unifier.Term term, Unifier.Variable variable) {\n      this.term = term;\n      this.variable = variable;\n    }\n\n    @Override public String toString() {\n      return term + \" = \" + variable;\n    }\n  }\n\n  /** A type environment that consists of a type environment plus one\n   * binding. */\n  private static class BindTypeEnv implements TypeEnv {\n    private final String definedName;\n    private final Function<TypeSystem, Unifier.Term> termFactory;\n    private final TypeEnv parent;\n\n    BindTypeEnv(String definedName,\n        Function<TypeSystem, Unifier.Term> termFactory, TypeEnv parent) {\n      this.definedName = requireNonNull(definedName);\n      this.termFactory = requireNonNull(termFactory);\n      this.parent = requireNonNull(parent);\n    }\n\n    @Override public Unifier.Term get(TypeSystem typeSystem, String name,\n        Function<String, RuntimeException> exceptionFactory) {\n      for (BindTypeEnv e = this;; e = (BindTypeEnv) e.parent) {\n        if (e.definedName.equals(name)) {\n          return e.termFactory.apply(typeSystem);\n        }\n        if (!(e.parent instanceof BindTypeEnv)) {\n          return e.parent.get(typeSystem, name, exceptionFactory);\n        }\n      }\n    }\n\n    @Override public boolean has(String name) {\n      return name.equals(definedName) || parent.has(name);\n    }\n\n    @Override public TypeEnv bind(String name,\n        Function<TypeSystem, Unifier.Term> termFactory) {\n      return new BindTypeEnv(name, termFactory, this);\n    }\n\n    @Override public String toString() {\n      final Map<String, String> map = new LinkedHashMap<>();\n      for (BindTypeEnv e = this;;) {\n        map.putIfAbsent(e.definedName, e.termFactory.toString());\n        if (e.parent instanceof BindTypeEnv) {\n          e = (BindTypeEnv) e.parent;\n        } else {\n          return map.toString();\n        }\n      }\n    }\n  }\n\n  /** Contains a {@link TypeEnv} and adds to it by calling\n   * {@link TypeEnv#bind(String, Function)}. */\n  private class TypeEnvHolder implements BiConsumer<String, Type> {\n    private TypeEnv typeEnv;\n\n    TypeEnvHolder(TypeEnv typeEnv) {\n      this.typeEnv = requireNonNull(typeEnv);\n    }\n\n    @Override public void accept(String name, Type type) {\n      typeEnv = typeEnv.bind(name, new Function<TypeSystem, Unifier.Term>() {\n        @Override public Unifier.Term apply(TypeSystem typeSystem_) {\n          return TypeResolver.this.toTerm(type, Subst.EMPTY);\n        }\n\n        @Override public String toString() {\n          return type.moniker();\n        }\n      });\n    }\n  }\n\n  /** Result of validating a declaration. */\n  public static class Resolved {\n    public final Environment env;\n    public final Ast.Decl originalNode;\n    public final Ast.Decl node;\n    public final TypeMap typeMap;\n\n    private Resolved(Environment env,\n        Ast.Decl originalNode, Ast.Decl node, TypeMap typeMap) {\n      this.env = env;\n      this.originalNode = requireNonNull(originalNode);\n      this.node = requireNonNull(node);\n      this.typeMap = requireNonNull(typeMap);\n      checkArgument(originalNode instanceof Ast.FunDecl\n          ? node instanceof Ast.ValDecl\n          : originalNode.getClass() == node.getClass());\n    }\n\n    static Resolved of(Environment env, Ast.Decl originalNode, Ast.Decl node,\n        TypeMap typeMap) {\n      return new Resolved(env, originalNode, node, typeMap);\n    }\n\n    public Ast.Exp exp() {\n      if (node instanceof Ast.ValDecl) {\n        final Ast.ValDecl valDecl = (Ast.ValDecl) this.node;\n        if (valDecl.valBinds.size() == 1) {\n          final Ast.ValBind valBind = valDecl.valBinds.get(0);\n          return valBind.exp;\n        }\n      }\n      throw new AssertionError(\"not an expression: \" + node);\n    }\n  }\n\n  /** Substitution. */\n  private abstract static class Subst {\n    static final Subst EMPTY = new EmptySubst();\n\n    Subst plus(TypeVar typeVar, Unifier.Variable variable) {\n      return new PlusSubst(this, typeVar, variable);\n    }\n\n    abstract Unifier.Variable get(TypeVar typeVar);\n  }\n\n  /** Empty substitution. */\n  private static class EmptySubst extends Subst {\n    @Override public String toString() {\n      return \"[]\";\n    }\n\n    @Override Unifier.Variable get(TypeVar typeVar) {\n      return null;\n    }\n  }\n\n  /** Substitution that adds one (type, variable) assignment to a parent\n   * substitution. */\n  private static class PlusSubst extends Subst {\n    final Subst parent;\n    final TypeVar typeVar;\n    final Unifier.Variable variable;\n\n    PlusSubst(Subst parent, TypeVar typeVar, Unifier.Variable variable) {\n      this.parent = parent;\n      this.typeVar = typeVar;\n      this.variable = variable;\n    }\n\n    @Override Unifier.Variable get(TypeVar typeVar) {\n      return typeVar.equals(this.typeVar)\n          ? variable\n          : parent.get(typeVar);\n    }\n\n    @Override public String toString() {\n      final Map<TypeVar, Unifier.Term> map = new LinkedHashMap<>();\n      for (PlusSubst e = this;;) {\n        map.putIfAbsent(e.typeVar, e.variable);\n        if (e.parent instanceof PlusSubst) {\n          e = (PlusSubst) e.parent;\n        } else {\n          return map.toString();\n        }\n      }\n    }\n  }\n\n  /** Error while deducing type. */\n  public static class TypeException extends CompileException {\n    public TypeException(String message, Pos pos) {\n      super(message, false, pos);\n    }\n  }\n\n  /** Visitor that expands progressive types if they are used in field\n   * references. */\n  static class FieldExpander extends EnvVisitor {\n    static FieldExpander create(TypeSystem typeSystem, Environment env) {\n      return new FieldExpander(typeSystem, env, new ArrayDeque<>());\n    }\n\n    private FieldExpander(TypeSystem typeSystem, Environment env,\n        Deque<FromContext> fromStack) {\n      super(typeSystem, env, fromStack);\n    }\n\n    @Override protected EnvVisitor push(Environment env) {\n      return new FieldExpander(typeSystem, env, fromStack);\n    }\n\n    @Override protected void visit(Ast.Apply apply) {\n      super.visit(apply);\n      expandField(env, apply);\n    }\n\n    @Override protected void visit(Ast.Id id) {\n      super.visit(id);\n      expandField(env, id);\n    }\n\n    private @Nullable TypedValue expandField(Environment env, Ast.Exp exp) {\n      switch (exp.op) {\n      case APPLY:\n        final Ast.Apply apply = (Ast.Apply) exp;\n        if (apply.fn.op == Op.RECORD_SELECTOR) {\n          final Ast.RecordSelector selector = (Ast.RecordSelector) apply.fn;\n          final TypedValue typedValue = expandField(env, apply.arg);\n          if (typedValue != null) {\n            typedValue.discoverField(typeSystem, selector.name);\n            return typedValue.fieldValueAs(selector.name, TypedValue.class);\n          }\n        }\n        return null;\n\n      case ID:\n        final Binding binding = env.getOpt(((Ast.Id) exp).name);\n        if (binding != null\n            && binding.value instanceof TypedValue) {\n          return (TypedValue) binding.value;\n        }\n        // fall through\n\n      default:\n        return null;\n      }\n    }\n  }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private final TypeSystem typeSystem;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "TypeSystem", "name": "typeSystem", "syntax_pass": true}, {"attribute_expression": "private final Unifier unifier = new MartelliUnifier();", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Unifier", "name": "unifier = new MartelliUnifier()", "syntax_pass": true}, {"attribute_expression": "private final List<TermVariable> terms = new ArrayList<>();", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "List<TermVariable>", "name": "terms = new ArrayList<>()", "syntax_pass": true}, {"attribute_expression": "private final Map<AstNode, Unifier.Term> map = new HashMap<>();", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Map<AstNode, Unifier.Term>", "name": "map = new HashMap<>()", "syntax_pass": true}, {"attribute_expression": "private final Map<Unifier.Variable, Unifier.Action> actionMap =\n      new HashMap<>();", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Map<Unifier.Variable, Unifier.Action>", "name": "actionMap =\n      new HashMap<>()", "syntax_pass": true}, {"attribute_expression": "private final PairList<Unifier.Variable, PrimitiveType> preferredTypes =\n      PairList.of();", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "PairList<Unifier.Variable, PrimitiveType>", "name": "preferredTypes =\n      PairList.of()", "syntax_pass": true}, {"attribute_expression": "static final String TUPLE_TY_CON = \"tuple\";", "docstring": "", "modifiers": "static final", "marker_annotations": [], "non_marker_annotations": ["static", "final"], "comments": [], "type": "String", "name": "TUPLE_TY_CON = \"tuple\"", "syntax_pass": true}, {"attribute_expression": "static final String LIST_TY_CON = \"list\";", "docstring": "", "modifiers": "static final", "marker_annotations": [], "non_marker_annotations": ["static", "final"], "comments": [], "type": "String", "name": "LIST_TY_CON = \"list\"", "syntax_pass": true}, {"attribute_expression": "static final String RECORD_TY_CON = \"record\";", "docstring": "", "modifiers": "static final", "marker_annotations": [], "non_marker_annotations": ["static", "final"], "comments": [], "type": "String", "name": "RECORD_TY_CON = \"record\"", "syntax_pass": true}, {"attribute_expression": "static final String FN_TY_CON = \"fn\";", "docstring": "", "modifiers": "static final", "marker_annotations": [], "non_marker_annotations": ["static", "final"], "comments": [], "type": "String", "name": "FN_TY_CON = \"fn\"", "syntax_pass": true}, {"attribute_expression": "static final String PROGRESSIVE_LABEL = \"z$dummy\";", "docstring": " A field of this name indicates that a record type is progressive.", "modifiers": "static final", "marker_annotations": [], "non_marker_annotations": ["static", "final"], "comments": [], "type": "String", "name": "PROGRESSIVE_LABEL = \"z$dummy\"", "syntax_pass": true}]}, {"uris": "src/main/java/net/hydromatic/morel/compile/Replacer.java.Replacer", "name": "Replacer", "file_path": "src/main/java/net/hydromatic/morel/compile/Replacer.java", "superclasses": "EnvShuttle", "methods": ["[]Replacer(TypeSystem,Environment,Map<Core.Id, Core.Id>)", "[Core.Exp]substitute(TypeSystem,Map<Core.Id, Core.Id>,Core.Exp)", "[Replacer]push(Environment)", "[Core.Exp]visit(Core.Id)"], "method_uris": ["src/main/java/net/hydromatic/morel/compile/Replacer.java.Replacer.[]Replacer(TypeSystem,Environment,Map<Core.Id, Core.Id>)", "src/main/java/net/hydromatic/morel/compile/Replacer.java.Replacer.[Core.Exp]substitute(TypeSystem,Map<Core.Id, Core.Id>,Core.Exp)", "src/main/java/net/hydromatic/morel/compile/Replacer.java.Replacer.[Replacer]push(Environment)", "src/main/java/net/hydromatic/morel/compile/Replacer.java.Replacer.[Core.Exp]visit(Core.Id)"], "overrides": null, "attributes": [], "class_docstring": "\nReplaces identifiers with other identifiers.\n", "original_string": "public class Replacer extends EnvShuttle {\n  private final Map<Core.Id, Core.Id> substitution;\n\n  private Replacer(TypeSystem typeSystem, Environment env,\n      Map<Core.Id, Core.Id> substitution) {\n    super(typeSystem, env);\n    this.substitution = requireNonNull(substitution);\n  }\n\n  static Core.Exp substitute(TypeSystem typeSystem,\n      Map<Core.Id, Core.Id> substitution, Core.Exp exp) {\n    final Replacer replacer =\n        new Replacer(typeSystem, Environments.empty(), substitution);\n    return exp.accept(replacer);\n  }\n\n  @Override protected Replacer push(Environment env) {\n    return new Replacer(typeSystem, env, substitution);\n  }\n\n  @Override protected Core.Exp visit(Core.Id id) {\n    final Core.Id id2 = substitution.get(id);\n    return id2 != null ? id2 : id;\n  }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private final Map<Core.Id, Core.Id> substitution;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Map<Core.Id, Core.Id>", "name": "substitution", "syntax_pass": true}]}, {"uris": "src/main/java/net/hydromatic/morel/compile/RefChecker.java.RefChecker", "name": "RefChecker", "file_path": "src/main/java/net/hydromatic/morel/compile/RefChecker.java", "superclasses": "EnvVisitor", "methods": ["[RefChecker]of(TypeSystem,Environment)", "[]RefChecker(TypeSystem,Environment,Deque<FromContext>)", "[RefChecker]push(Environment)", "[void]visit(Core.Id)"], "method_uris": ["src/main/java/net/hydromatic/morel/compile/RefChecker.java.RefChecker.[RefChecker]of(TypeSystem,Environment)", "src/main/java/net/hydromatic/morel/compile/RefChecker.java.RefChecker.[]RefChecker(TypeSystem,Environment,Deque<FromContext>)", "src/main/java/net/hydromatic/morel/compile/RefChecker.java.RefChecker.[RefChecker]push(Environment)", "src/main/java/net/hydromatic/morel/compile/RefChecker.java.RefChecker.[void]visit(Core.Id)"], "overrides": null, "attributes": [], "class_docstring": " Validates expressions, making sure that every {@link Core.Id}\nexists in the environment.", "original_string": "public class RefChecker extends EnvVisitor {\n  /** Creates a reference checker. */\n  public static RefChecker of(TypeSystem typeSystem, Environment env) {\n    return new RefChecker(typeSystem, env, new ArrayDeque<>());\n  }\n\n  private RefChecker(TypeSystem typeSystem, Environment env,\n      Deque<FromContext> fromStack) {\n    super(typeSystem, env, fromStack);\n  }\n\n  @Override protected RefChecker push(Environment env) {\n    return new RefChecker(typeSystem, env, fromStack);\n  }\n\n  @Override protected void visit(Core.Id id) {\n    verifyNotNull(env.getOpt(id.idPat), \"not found\", id);\n  }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/main/java/net/hydromatic/morel/compile/Extents.java.Extents", "name": "Extents", "file_path": "src/main/java/net/hydromatic/morel/compile/Extents.java", "superclasses": "", "methods": ["[]Extents()", "[Analysis]create(TypeSystem,Core.Pat,SortedMap<Core.NamedPat, Core.Exp>,Iterable<? extends Core.FromStep>,PairList<Core.IdPat, Core.Exp>)", "[List<Core.IdPat>]flatten(Core.Pat)", "[boolean]isInfinite(Core.Exp)", "[Core.Decl]infinitePats(TypeSystem,Core.Decl)", "[Map<String, ImmutableRangeSet<C>>]intersect(List<Map<String, ImmutableRangeSet<C>>>)", "[Map<String, ImmutableRangeSet<C>>]union(List<Map<String, ImmutableRangeSet<C>>>)", "[ImmutableRangeSet<C>]intersectRangeSets(Collection<ImmutableRangeSet<C>>)", "[ImmutableRangeSet<C>]unionRangeSets(Collection<ImmutableRangeSet<C>>)", "[Pair<Core.Exp, Core.Exp>]reduceAnd(TypeSystem,PairList<Core.Exp, Core.Exp>)", "[Pair<Core.Exp, Core.Exp>]reduceOr(TypeSystem,PairList<Core.Exp, Core.Exp>)"], "method_uris": ["src/main/java/net/hydromatic/morel/compile/Extents.java.Extents.[]Extents()", "src/main/java/net/hydromatic/morel/compile/Extents.java.Extents.[Analysis]create(TypeSystem,Core.Pat,SortedMap<Core.NamedPat, Core.Exp>,Iterable<? extends Core.FromStep>,PairList<Core.IdPat, Core.Exp>)", "src/main/java/net/hydromatic/morel/compile/Extents.java.Extents.[List<Core.IdPat>]flatten(Core.Pat)", "src/main/java/net/hydromatic/morel/compile/Extents.java.Extents.[boolean]isInfinite(Core.Exp)", "src/main/java/net/hydromatic/morel/compile/Extents.java.Extents.[Core.Decl]infinitePats(TypeSystem,Core.Decl)", "src/main/java/net/hydromatic/morel/compile/Extents.java.Extents.[Map<String, ImmutableRangeSet<C>>]intersect(List<Map<String, ImmutableRangeSet<C>>>)", "src/main/java/net/hydromatic/morel/compile/Extents.java.Extents.[Map<String, ImmutableRangeSet<C>>]union(List<Map<String, ImmutableRangeSet<C>>>)", "src/main/java/net/hydromatic/morel/compile/Extents.java.Extents.[ImmutableRangeSet<C>]intersectRangeSets(Collection<ImmutableRangeSet<C>>)", "src/main/java/net/hydromatic/morel/compile/Extents.java.Extents.[ImmutableRangeSet<C>]unionRangeSets(Collection<ImmutableRangeSet<C>>)", "src/main/java/net/hydromatic/morel/compile/Extents.java.Extents.[Pair<Core.Exp, Core.Exp>]reduceAnd(TypeSystem,PairList<Core.Exp, Core.Exp>)", "src/main/java/net/hydromatic/morel/compile/Extents.java.Extents.[Pair<Core.Exp, Core.Exp>]reduceOr(TypeSystem,PairList<Core.Exp, Core.Exp>)"], "overrides": null, "attributes": [{"original_string": "  public static class Analysis {\n    final SortedMap<Core.NamedPat, Core.Exp> boundPats;\n    final Set<Core.NamedPat> goalPats;\n    final Core.Exp extentExp;\n    final List<Core.Exp> satisfiedFilters; // filters satisfied by extentExp\n    final List<Core.Exp> remainingFilters;\n\n    private Analysis(SortedMap<Core.NamedPat, Core.Exp> boundPats,\n        Set<Core.NamedPat> goalPats,\n        Core.Exp extentExp, List<Core.Exp> satisfiedFilters,\n        List<Core.Exp> remainingFilters) {\n      this.boundPats = ImmutableSortedMap.copyOf(boundPats);\n      this.goalPats = ImmutableSet.copyOf(goalPats);\n      this.extentExp = extentExp;\n      this.satisfiedFilters = ImmutableList.copyOf(satisfiedFilters);\n      this.remainingFilters = ImmutableList.copyOf(remainingFilters);\n    }\n\n    Set<Core.NamedPat> unboundPats() {\n      return minus(goalPats, boundPats.keySet());\n    }\n  }", "definition": "  public static class Analysis", "class_docstring": " Result of analyzing the variables in a query, pulling filters into the\nextent expression for each variable, so that no variable is over an\ninfinite extent.", "name": "Analysis", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [{"attribute_expression": "final SortedMap<Core.NamedPat, Core.Exp> boundPats;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "SortedMap<Core.NamedPat, Core.Exp>", "name": "boundPats", "syntax_pass": true}, {"attribute_expression": "final Set<Core.NamedPat> goalPats;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "Set<Core.NamedPat>", "name": "goalPats", "syntax_pass": true}, {"attribute_expression": "final Core.Exp extentExp;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "Core.Exp", "name": "extentExp", "syntax_pass": true}, {"attribute_expression": "final List<Core.Exp> satisfiedFilters;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "List<Core.Exp>", "name": "satisfiedFilters", "syntax_pass": true}, {"attribute_expression": "final List<Core.Exp> remainingFilters;", "docstring": " filters satisfied by extentExp", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "List<Core.Exp>", "name": "remainingFilters", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    private Analysis(SortedMap<Core.NamedPat, Core.Exp> boundPats,\n        Set<Core.NamedPat> goalPats,\n        Core.Exp extentExp, List<Core.Exp> satisfiedFilters,\n        List<Core.Exp> remainingFilters) {\n      this.boundPats = ImmutableSortedMap.copyOf(boundPats);\n      this.goalPats = ImmutableSet.copyOf(goalPats);\n      this.extentExp = extentExp;\n      this.satisfiedFilters = ImmutableList.copyOf(satisfiedFilters);\n      this.remainingFilters = ImmutableList.copyOf(remainingFilters);\n    }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "", "classes": []}, "name": "Analysis", "params": [{"name": "boundPats", "type": "SortedMap<Core.NamedPat, Core.Exp>"}, {"name": "goalPats", "type": "Set<Core.NamedPat>"}, {"name": "extentExp", "type": "Core.Exp"}, {"name": "satisfiedFilters", "type": "List<Core.Exp>"}, {"name": "remainingFilters", "type": "List<Core.Exp>"}], "body": "                                         {\n      this.boundPats = ImmutableSortedMap.copyOf(boundPats);\n      this.goalPats = ImmutableSet.copyOf(goalPats);\n      this.extentExp = extentExp;\n      this.satisfiedFilters = ImmutableList.copyOf(satisfiedFilters);\n      this.remainingFilters = ImmutableList.copyOf(remainingFilters);\n    }", "signature": "private Analysis(SortedMap<Core.NamedPat, Core.Exp> boundPats,\n        Set<Core.NamedPat> goalPats,\n        Core.Exp extentExp, List<Core.Exp> satisfiedFilters,\n        List<Core.Exp> remainingFilters)"}, {"syntax_pass": true, "original_string": "    Set<Core.NamedPat> unboundPats() {\n      return minus(goalPats, boundPats.keySet());\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "Set<Core.NamedPat>", "classes": []}, "name": "unboundPats", "params": [], "body": "                                     {\n      return minus(goalPats, boundPats.keySet());\n    }", "signature": "Set<Core.NamedPat> unboundPats()"}]}, {"original_string": "  private static class Extent {\n    private final TypeSystem typeSystem;\n    final Set<Core.NamedPat> goalPats;\n    final SortedMap<Core.NamedPat, Core.Exp> boundPats;\n\n    /** New variables introduced as scans over an existing relation (list of\n     * records). Other variables, which are goals of this extent, are typically\n     * fields of this variable. */\n    final PairList<Core.IdPat, Core.Exp> idPats;\n\n    /** Contains definitions, such as \"name = d.dname\".\n     * With such a definition, \"name\" won't need an extent, because we\n     * can define it (or inline it) as the expression \"d.dname\". */\n    final Map<Core.NamedPat, Core.Exp> definitions = new HashMap<>();\n\n    Extent(TypeSystem typeSystem, Core.Pat pat,\n        SortedMap<Core.NamedPat, Core.Exp> boundPats,\n        PairList<Core.IdPat, Core.Exp> idPats) {\n      this.typeSystem = typeSystem;\n      this.goalPats = ImmutableSet.copyOf(flatten(pat));\n      this.boundPats = ImmutableSortedMap.copyOf(boundPats);\n      this.idPats = idPats;\n    }\n\n    @SuppressWarnings(\"SwitchStatementWithTooFewBranches\")\n    void g3(Map<Core.Pat, PairList<Core.Exp, Core.Exp>> map, Core.Exp filter) {\n      final Core.Apply apply;\n      switch (filter.op) {\n      case APPLY:\n        apply = (Core.Apply) filter;\n        switch (apply.fn.op) {\n        case FN_LITERAL:\n          BuiltIn builtIn = ((Core.Literal) apply.fn).unwrap(BuiltIn.class);\n          final Map<Core.Pat, PairList<Core.Exp, Core.Exp>> map2;\n          switch (builtIn) {\n          case Z_ANDALSO:\n            // Expression is 'andalso'. Visit each pattern, and 'and' the\n            // filters (intersect the extents).\n            map2 = new LinkedHashMap<>();\n            apply.arg.forEachArg((arg, i) -> g3(map2, arg));\n            map2.forEach((pat, foo) ->\n                map.computeIfAbsent(pat, p -> PairList.of())\n                    .addAll(foo));\n            break;\n\n          case Z_ORELSE:\n            // Expression is 'orelse'. Visit each pattern, and intersect the\n            // constraints (union the generators).\n            map2 = new LinkedHashMap<>();\n            final Map<Core.Pat, PairList<Core.Exp, Core.Exp>> map3 =\n                new LinkedHashMap<>();\n            apply.arg.forEachArg((arg, i) -> {\n              g3(map3, arg);\n              map3.forEach((pat, foo) ->\n                  map2.computeIfAbsent(pat, p -> PairList.of())\n                      .add(reduceAnd(typeSystem, foo)));\n              map3.clear();\n            });\n            map2.forEach((pat, foo) -> {\n              final PairList<Core.Exp, Core.Exp> foo1 =\n                  map.computeIfAbsent(pat, p -> PairList.of());\n              if (foo1.isEmpty()) {\n                // [] union [x2, x3, x4]\n                //  =>\n                // [x2, x3, x4]\n                foo1.add(reduceOr(typeSystem, foo));\n              } else {\n                // [x0, x1] union [x2, x3, x4]\n                //  =>\n                // [union(intersect(x0, x1), intersect(x2, x3, x4))]\n                PairList<Core.Exp, Core.Exp> intersectExtents = PairList.of();\n                intersectExtents.add(reduceAnd(typeSystem, foo1));\n                intersectExtents.add(reduceAnd(typeSystem, foo));\n                foo1.clear();\n                foo1.add(reduceOr(typeSystem, intersectExtents));\n              }\n            });\n            break;\n\n          case OP_EQ:\n          case OP_NE:\n          case OP_GE:\n          case OP_GT:\n          case OP_LT:\n          case OP_LE:\n            g4(builtIn, apply.arg(0), apply.arg(1), (pat, filter2, extent) ->\n                map.computeIfAbsent(pat, p -> PairList.of())\n                    .add(extent, filter2));\n            break;\n\n          case OP_ELEM:\n            switch (apply.arg(0).op) {\n            case ID:\n              final Core.NamedPat pat = ((Core.Id) apply.arg(0)).idPat;\n              map.computeIfAbsent(pat, p1 -> PairList.of())\n                  .add(apply.arg(1), apply);\n              break;\n\n            case TUPLE:\n              final Core.Tuple tuple = (Core.Tuple) apply.arg(0);\n              final Core.Id id = core.id(createId(tuple.type, apply.arg(1)));\n              final Core.Exp elem = core.elem(typeSystem, id, apply.arg(1));\n              g3(map,\n                  core.andAlso(typeSystem, elem,\n                      core.equal(typeSystem, id, tuple)));\n              final List<Core.Exp> conjunctions = new ArrayList<>();\n              conjunctions.add(core.elem(typeSystem, id, apply.arg(1)));\n              tuple.forEach((i, name, arg) ->\n                  conjunctions.add(\n                      core.equal(typeSystem,\n                          core.field(typeSystem, id, i),\n                          arg)));\n              g3(map, core.andAlso(typeSystem, conjunctions));\n              break;\n            }\n            break;\n          }\n        }\n        break;\n\n      default:\n        break;\n      }\n    }\n\n    private void g4(BuiltIn builtIn, Core.Exp arg0, Core.Exp arg1,\n        TriConsumer<Core.Pat, Core.Exp, Core.Exp> consumer) {\n      g5(builtIn, arg0, arg1, consumer);\n      g5(builtIn.reverse(), arg1, arg0, consumer);\n    }\n\n    @SuppressWarnings(\"SwitchStatementWithTooFewBranches\")\n    private void g5(BuiltIn builtIn, Core.Exp arg0, Core.Exp arg1,\n        TriConsumer<Core.Pat, Core.Exp, Core.Exp> consumer) {\n      switch (builtIn) {\n      case OP_EQ:\n        switch (arg0.op) {\n        case ID:\n          final Core.Id id = (Core.Id) arg0;\n          definitions.put(id.idPat, arg1);\n        }\n        // fall through\n      case OP_NE:\n      case OP_GE:\n      case OP_GT:\n      case OP_LE:\n      case OP_LT:\n        switch (arg0.op) {\n        case ID:\n          final Core.Id id = (Core.Id) arg0;\n          if (arg1.isConstant()) {\n            // If exp is \"id = literal\", add extent \"id: [literal]\";\n            // if exp is \"id > literal\", add extent \"id: (literal, inf)\", etc.\n            consumer.accept(id.idPat,\n                core.call(typeSystem, builtIn, arg0.type, Pos.ZERO, arg0, arg1),\n                baz(builtIn, arg1));\n          }\n          break;\n        }\n        break;\n\n      default:\n        throw new AssertionError(\"unexpected: \" + builtIn);\n      }\n    }\n\n    private Core.Exp baz(BuiltIn builtIn, Core.Exp arg) {\n      switch (builtIn) {\n      case OP_EQ:\n        return core.list(typeSystem, arg);\n      case OP_NE:\n        return core.extent(typeSystem, arg.type,\n            ImmutableRangeSet.of(Range.singleton(((Core.Literal) arg).value))\n                .complement());\n      case OP_GE:\n        return core.extent(typeSystem, arg.type,\n            ImmutableRangeSet.of(Range.atLeast(((Core.Literal) arg).value)));\n      case OP_GT:\n        return core.extent(typeSystem, arg.type,\n            ImmutableRangeSet.of(Range.greaterThan(((Core.Literal) arg).value)));\n      case OP_LE:\n        return core.extent(typeSystem, arg.type,\n            ImmutableRangeSet.of(Range.atMost(((Core.Literal) arg).value)));\n      case OP_LT:\n        return core.extent(typeSystem, arg.type,\n            ImmutableRangeSet.of(Range.lessThan(((Core.Literal) arg).value)));\n      default:\n        throw new AssertionError(\"unexpected: \" + builtIn);\n      }\n    }\n\n    private Core.IdPat createId(Type type, Core.Exp extent) {\n      int i = idPats.firstMatch((id, e) -> extent.equals(e));\n      if (i >= 0) {\n        return idPats.leftList().get(i);\n      }\n      final Core.IdPat idPat = core.idPat(type, typeSystem.nameGenerator);\n      idPats.add(idPat, extent);\n      return idPat;\n    }\n  }", "definition": "  private static class Extent", "class_docstring": "", "name": "Extent", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "fields": [{"attribute_expression": "private final TypeSystem typeSystem;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "TypeSystem", "name": "typeSystem", "syntax_pass": true}, {"attribute_expression": "final Set<Core.NamedPat> goalPats;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "Set<Core.NamedPat>", "name": "goalPats", "syntax_pass": true}, {"attribute_expression": "final SortedMap<Core.NamedPat, Core.Exp> boundPats;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "SortedMap<Core.NamedPat, Core.Exp>", "name": "boundPats", "syntax_pass": true}, {"attribute_expression": "final PairList<Core.IdPat, Core.Exp> idPats;", "docstring": " New variables introduced as scans over an existing relation (list of\nrecords). Other variables, which are goals of this extent, are typically\nfields of this variable.", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "PairList<Core.IdPat, Core.Exp>", "name": "idPats", "syntax_pass": true}, {"attribute_expression": "final Map<Core.NamedPat, Core.Exp> definitions = new HashMap<>();", "docstring": " Contains definitions, such as \"name = d.dname\".\nWith such a definition, \"name\" won't need an extent, because we\ncan define it (or inline it) as the expression \"d.dname\".", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "Map<Core.NamedPat, Core.Exp>", "name": "definitions = new HashMap<>()", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    Extent(TypeSystem typeSystem, Core.Pat pat,\n        SortedMap<Core.NamedPat, Core.Exp> boundPats,\n        PairList<Core.IdPat, Core.Exp> idPats) {\n      this.typeSystem = typeSystem;\n      this.goalPats = ImmutableSet.copyOf(flatten(pat));\n      this.boundPats = ImmutableSortedMap.copyOf(boundPats);\n      this.idPats = idPats;\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "Extent", "params": [{"name": "typeSystem", "type": "TypeSystem"}, {"name": "pat", "type": "Core.Pat"}, {"name": "boundPats", "type": "SortedMap<Core.NamedPat, Core.Exp>"}, {"name": "idPats", "type": "PairList<Core.IdPat, Core.Exp>"}], "body": "                                               {\n      this.typeSystem = typeSystem;\n      this.goalPats = ImmutableSet.copyOf(flatten(pat));\n      this.boundPats = ImmutableSortedMap.copyOf(boundPats);\n      this.idPats = idPats;\n    }", "signature": "Extent(TypeSystem typeSystem, Core.Pat pat,\n        SortedMap<Core.NamedPat, Core.Exp> boundPats,\n        PairList<Core.IdPat, Core.Exp> idPats)"}, {"syntax_pass": true, "original_string": "    @SuppressWarnings(\"SwitchStatementWithTooFewBranches\")\n    void g3(Map<Core.Pat, PairList<Core.Exp, Core.Exp>> map, Core.Exp filter) {\n      final Core.Apply apply;\n      switch (filter.op) {\n      case APPLY:\n        apply = (Core.Apply) filter;\n        switch (apply.fn.op) {\n        case FN_LITERAL:\n          BuiltIn builtIn = ((Core.Literal) apply.fn).unwrap(BuiltIn.class);\n          final Map<Core.Pat, PairList<Core.Exp, Core.Exp>> map2;\n          switch (builtIn) {\n          case Z_ANDALSO:\n            // Expression is 'andalso'. Visit each pattern, and 'and' the\n            // filters (intersect the extents).\n            map2 = new LinkedHashMap<>();\n            apply.arg.forEachArg((arg, i) -> g3(map2, arg));\n            map2.forEach((pat, foo) ->\n                map.computeIfAbsent(pat, p -> PairList.of())\n                    .addAll(foo));\n            break;\n\n          case Z_ORELSE:\n            // Expression is 'orelse'. Visit each pattern, and intersect the\n            // constraints (union the generators).\n            map2 = new LinkedHashMap<>();\n            final Map<Core.Pat, PairList<Core.Exp, Core.Exp>> map3 =\n                new LinkedHashMap<>();\n            apply.arg.forEachArg((arg, i) -> {\n              g3(map3, arg);\n              map3.forEach((pat, foo) ->\n                  map2.computeIfAbsent(pat, p -> PairList.of())\n                      .add(reduceAnd(typeSystem, foo)));\n              map3.clear();\n            });\n            map2.forEach((pat, foo) -> {\n              final PairList<Core.Exp, Core.Exp> foo1 =\n                  map.computeIfAbsent(pat, p -> PairList.of());\n              if (foo1.isEmpty()) {\n                // [] union [x2, x3, x4]\n                //  =>\n                // [x2, x3, x4]\n                foo1.add(reduceOr(typeSystem, foo));\n              } else {\n                // [x0, x1] union [x2, x3, x4]\n                //  =>\n                // [union(intersect(x0, x1), intersect(x2, x3, x4))]\n                PairList<Core.Exp, Core.Exp> intersectExtents = PairList.of();\n                intersectExtents.add(reduceAnd(typeSystem, foo1));\n                intersectExtents.add(reduceAnd(typeSystem, foo));\n                foo1.clear();\n                foo1.add(reduceOr(typeSystem, intersectExtents));\n              }\n            });\n            break;\n\n          case OP_EQ:\n          case OP_NE:\n          case OP_GE:\n          case OP_GT:\n          case OP_LT:\n          case OP_LE:\n            g4(builtIn, apply.arg(0), apply.arg(1), (pat, filter2, extent) ->\n                map.computeIfAbsent(pat, p -> PairList.of())\n                    .add(extent, filter2));\n            break;\n\n          case OP_ELEM:\n            switch (apply.arg(0).op) {\n            case ID:\n              final Core.NamedPat pat = ((Core.Id) apply.arg(0)).idPat;\n              map.computeIfAbsent(pat, p1 -> PairList.of())\n                  .add(apply.arg(1), apply);\n              break;\n\n            case TUPLE:\n              final Core.Tuple tuple = (Core.Tuple) apply.arg(0);\n              final Core.Id id = core.id(createId(tuple.type, apply.arg(1)));\n              final Core.Exp elem = core.elem(typeSystem, id, apply.arg(1));\n              g3(map,\n                  core.andAlso(typeSystem, elem,\n                      core.equal(typeSystem, id, tuple)));\n              final List<Core.Exp> conjunctions = new ArrayList<>();\n              conjunctions.add(core.elem(typeSystem, id, apply.arg(1)));\n              tuple.forEach((i, name, arg) ->\n                  conjunctions.add(\n                      core.equal(typeSystem,\n                          core.field(typeSystem, id, i),\n                          arg)));\n              g3(map, core.andAlso(typeSystem, conjunctions));\n              break;\n            }\n            break;\n          }\n        }\n        break;\n\n      default:\n        break;\n      }\n    }", "docstring": "", "attributes": {"modifiers": "@SuppressWarnings(\"SwitchStatementWithTooFewBranches\")", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings(\"SwitchStatementWithTooFewBranches\")"], "comments": [], "return_type": "void", "classes": []}, "name": "g3", "params": [{"name": "map", "type": "Map<Core.Pat, PairList<Core.Exp, Core.Exp>>"}, {"name": "filter", "type": "Core.Exp"}], "body": "                                                                              {\n      final Core.Apply apply;\n      switch (filter.op) {\n      case APPLY:\n        apply = (Core.Apply) filter;\n        switch (apply.fn.op) {\n        case FN_LITERAL:\n          BuiltIn builtIn = ((Core.Literal) apply.fn).unwrap(BuiltIn.class);\n          final Map<Core.Pat, PairList<Core.Exp, Core.Exp>> map2;\n          switch (builtIn) {\n          case Z_ANDALSO:\n            // Expression is 'andalso'. Visit each pattern, and 'and' the\n            // filters (intersect the extents).\n            map2 = new LinkedHashMap<>();\n            apply.arg.forEachArg((arg, i) -> g3(map2, arg));\n            map2.forEach((pat, foo) ->\n                map.computeIfAbsent(pat, p -> PairList.of())\n                    .addAll(foo));\n            break;\n\n          case Z_ORELSE:\n            // Expression is 'orelse'. Visit each pattern, and intersect the\n            // constraints (union the generators).\n            map2 = new LinkedHashMap<>();\n            final Map<Core.Pat, PairList<Core.Exp, Core.Exp>> map3 =\n                new LinkedHashMap<>();\n            apply.arg.forEachArg((arg, i) -> {\n              g3(map3, arg);\n              map3.forEach((pat, foo) ->\n                  map2.computeIfAbsent(pat, p -> PairList.of())\n                      .add(reduceAnd(typeSystem, foo)));\n              map3.clear();\n            });\n            map2.forEach((pat, foo) -> {\n              final PairList<Core.Exp, Core.Exp> foo1 =\n                  map.computeIfAbsent(pat, p -> PairList.of());\n              if (foo1.isEmpty()) {\n                // [] union [x2, x3, x4]\n                //  =>\n                // [x2, x3, x4]\n                foo1.add(reduceOr(typeSystem, foo));\n              } else {\n                // [x0, x1] union [x2, x3, x4]\n                //  =>\n                // [union(intersect(x0, x1), intersect(x2, x3, x4))]\n                PairList<Core.Exp, Core.Exp> intersectExtents = PairList.of();\n                intersectExtents.add(reduceAnd(typeSystem, foo1));\n                intersectExtents.add(reduceAnd(typeSystem, foo));\n                foo1.clear();\n                foo1.add(reduceOr(typeSystem, intersectExtents));\n              }\n            });\n            break;\n\n          case OP_EQ:\n          case OP_NE:\n          case OP_GE:\n          case OP_GT:\n          case OP_LT:\n          case OP_LE:\n            g4(builtIn, apply.arg(0), apply.arg(1), (pat, filter2, extent) ->\n                map.computeIfAbsent(pat, p -> PairList.of())\n                    .add(extent, filter2));\n            break;\n\n          case OP_ELEM:\n            switch (apply.arg(0).op) {\n            case ID:\n              final Core.NamedPat pat = ((Core.Id) apply.arg(0)).idPat;\n              map.computeIfAbsent(pat, p1 -> PairList.of())\n                  .add(apply.arg(1), apply);\n              break;\n\n            case TUPLE:\n              final Core.Tuple tuple = (Core.Tuple) apply.arg(0);\n              final Core.Id id = core.id(createId(tuple.type, apply.arg(1)));\n              final Core.Exp elem = core.elem(typeSystem, id, apply.arg(1));\n              g3(map,\n                  core.andAlso(typeSystem, elem,\n                      core.equal(typeSystem, id, tuple)));\n              final List<Core.Exp> conjunctions = new ArrayList<>();\n              conjunctions.add(core.elem(typeSystem, id, apply.arg(1)));\n              tuple.forEach((i, name, arg) ->\n                  conjunctions.add(\n                      core.equal(typeSystem,\n                          core.field(typeSystem, id, i),\n                          arg)));\n              g3(map, core.andAlso(typeSystem, conjunctions));\n              break;\n            }\n            break;\n          }\n        }\n        break;\n\n      default:\n        break;\n      }\n    }", "signature": "@SuppressWarnings(\"SwitchStatementWithTooFewBranches\")\n    void g3(Map<Core.Pat, PairList<Core.Exp, Core.Exp>> map, Core.Exp filter)"}, {"syntax_pass": true, "original_string": "    private void g4(BuiltIn builtIn, Core.Exp arg0, Core.Exp arg1,\n        TriConsumer<Core.Pat, Core.Exp, Core.Exp> consumer) {\n      g5(builtIn, arg0, arg1, consumer);\n      g5(builtIn.reverse(), arg1, arg0, consumer);\n    }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "name": "g4", "params": [{"name": "builtIn", "type": "BuiltIn"}, {"name": "arg0", "type": "Core.Exp"}, {"name": "arg1", "type": "Core.Exp"}, {"name": "consumer", "type": "TriConsumer<Core.Pat, Core.Exp, Core.Exp>"}], "body": "                                                            {\n      g5(builtIn, arg0, arg1, consumer);\n      g5(builtIn.reverse(), arg1, arg0, consumer);\n    }", "signature": "private void g4(BuiltIn builtIn, Core.Exp arg0, Core.Exp arg1,\n        TriConsumer<Core.Pat, Core.Exp, Core.Exp> consumer)"}, {"syntax_pass": true, "original_string": "    @SuppressWarnings(\"SwitchStatementWithTooFewBranches\")\n    private void g5(BuiltIn builtIn, Core.Exp arg0, Core.Exp arg1,\n        TriConsumer<Core.Pat, Core.Exp, Core.Exp> consumer) {\n      switch (builtIn) {\n      case OP_EQ:\n        switch (arg0.op) {\n        case ID:\n          final Core.Id id = (Core.Id) arg0;\n          definitions.put(id.idPat, arg1);\n        }\n        // fall through\n      case OP_NE:\n      case OP_GE:\n      case OP_GT:\n      case OP_LE:\n      case OP_LT:\n        switch (arg0.op) {\n        case ID:\n          final Core.Id id = (Core.Id) arg0;\n          if (arg1.isConstant()) {\n            // If exp is \"id = literal\", add extent \"id: [literal]\";\n            // if exp is \"id > literal\", add extent \"id: (literal, inf)\", etc.\n            consumer.accept(id.idPat,\n                core.call(typeSystem, builtIn, arg0.type, Pos.ZERO, arg0, arg1),\n                baz(builtIn, arg1));\n          }\n          break;\n        }\n        break;\n\n      default:\n        throw new AssertionError(\"unexpected: \" + builtIn);\n      }\n    }", "docstring": "", "attributes": {"modifiers": "@SuppressWarnings(\"SwitchStatementWithTooFewBranches\")\n    private", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings(\"SwitchStatementWithTooFewBranches\")", "private"], "comments": [], "return_type": "void", "classes": []}, "name": "g5", "params": [{"name": "builtIn", "type": "BuiltIn"}, {"name": "arg0", "type": "Core.Exp"}, {"name": "arg1", "type": "Core.Exp"}, {"name": "consumer", "type": "TriConsumer<Core.Pat, Core.Exp, Core.Exp>"}], "body": "                                                            {\n      switch (builtIn) {\n      case OP_EQ:\n        switch (arg0.op) {\n        case ID:\n          final Core.Id id = (Core.Id) arg0;\n          definitions.put(id.idPat, arg1);\n        }\n        // fall through\n      case OP_NE:\n      case OP_GE:\n      case OP_GT:\n      case OP_LE:\n      case OP_LT:\n        switch (arg0.op) {\n        case ID:\n          final Core.Id id = (Core.Id) arg0;\n          if (arg1.isConstant()) {\n            // If exp is \"id = literal\", add extent \"id: [literal]\";\n            // if exp is \"id > literal\", add extent \"id: (literal, inf)\", etc.\n            consumer.accept(id.idPat,\n                core.call(typeSystem, builtIn, arg0.type, Pos.ZERO, arg0, arg1),\n                baz(builtIn, arg1));\n          }\n          break;\n        }\n        break;\n\n      default:\n        throw new AssertionError(\"unexpected: \" + builtIn);\n      }\n    }", "signature": "@SuppressWarnings(\"SwitchStatementWithTooFewBranches\")\n    private void g5(BuiltIn builtIn, Core.Exp arg0, Core.Exp arg1,\n        TriConsumer<Core.Pat, Core.Exp, Core.Exp> consumer)"}, {"syntax_pass": true, "original_string": "    private Core.Exp baz(BuiltIn builtIn, Core.Exp arg) {\n      switch (builtIn) {\n      case OP_EQ:\n        return core.list(typeSystem, arg);\n      case OP_NE:\n        return core.extent(typeSystem, arg.type,\n            ImmutableRangeSet.of(Range.singleton(((Core.Literal) arg).value))\n                .complement());\n      case OP_GE:\n        return core.extent(typeSystem, arg.type,\n            ImmutableRangeSet.of(Range.atLeast(((Core.Literal) arg).value)));\n      case OP_GT:\n        return core.extent(typeSystem, arg.type,\n            ImmutableRangeSet.of(Range.greaterThan(((Core.Literal) arg).value)));\n      case OP_LE:\n        return core.extent(typeSystem, arg.type,\n            ImmutableRangeSet.of(Range.atMost(((Core.Literal) arg).value)));\n      case OP_LT:\n        return core.extent(typeSystem, arg.type,\n            ImmutableRangeSet.of(Range.lessThan(((Core.Literal) arg).value)));\n      default:\n        throw new AssertionError(\"unexpected: \" + builtIn);\n      }\n    }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "Core.Exp", "classes": []}, "name": "baz", "params": [{"name": "builtIn", "type": "BuiltIn"}, {"name": "arg", "type": "Core.Exp"}], "body": "                                                        {\n      switch (builtIn) {\n      case OP_EQ:\n        return core.list(typeSystem, arg);\n      case OP_NE:\n        return core.extent(typeSystem, arg.type,\n            ImmutableRangeSet.of(Range.singleton(((Core.Literal) arg).value))\n                .complement());\n      case OP_GE:\n        return core.extent(typeSystem, arg.type,\n            ImmutableRangeSet.of(Range.atLeast(((Core.Literal) arg).value)));\n      case OP_GT:\n        return core.extent(typeSystem, arg.type,\n            ImmutableRangeSet.of(Range.greaterThan(((Core.Literal) arg).value)));\n      case OP_LE:\n        return core.extent(typeSystem, arg.type,\n            ImmutableRangeSet.of(Range.atMost(((Core.Literal) arg).value)));\n      case OP_LT:\n        return core.extent(typeSystem, arg.type,\n            ImmutableRangeSet.of(Range.lessThan(((Core.Literal) arg).value)));\n      default:\n        throw new AssertionError(\"unexpected: \" + builtIn);\n      }\n    }", "signature": "private Core.Exp baz(BuiltIn builtIn, Core.Exp arg)"}, {"syntax_pass": true, "original_string": "    private Core.IdPat createId(Type type, Core.Exp extent) {\n      int i = idPats.firstMatch((id, e) -> extent.equals(e));\n      if (i >= 0) {\n        return idPats.leftList().get(i);\n      }\n      final Core.IdPat idPat = core.idPat(type, typeSystem.nameGenerator);\n      idPats.add(idPat, extent);\n      return idPat;\n    }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "Core.IdPat", "classes": []}, "name": "createId", "params": [{"name": "type", "type": "Type"}, {"name": "extent", "type": "Core.Exp"}], "body": "                                                            {\n      int i = idPats.firstMatch((id, e) -> extent.equals(e));\n      if (i >= 0) {\n        return idPats.leftList().get(i);\n      }\n      final Core.IdPat idPat = core.idPat(type, typeSystem.nameGenerator);\n      idPats.add(idPat, extent);\n      return idPat;\n    }", "signature": "private Core.IdPat createId(Type type, Core.Exp extent)"}]}, {"original_string": "  static class ExtentMap {\n    final Map<Core.Pat, PairList<Core.Exp, Core.Exp>> map =\n        new LinkedHashMap<>();\n\n    public PairList<Core.Exp, Core.Exp> get(TypeSystem typeSystem,\n        Core.Pat pat) {\n      PairList<Core.Exp, Core.Exp> foo = map.get(pat);\n      if (foo != null && !foo.isEmpty()) {\n        return foo;\n      }\n      if (canGet(pat)) {\n        return get_(typeSystem, pat);\n      }\n      return ImmutablePairList.of();\n    }\n\n    /**\n     * Constructs an expression for the extent of a pattern.\n     * You must have called {@link #canGet} first.\n     */\n    private @NonNull PairList<Core.Exp, Core.Exp> get_(TypeSystem typeSystem,\n        Core.Pat pat) {\n      final PairList<Core.Exp, Core.Exp> foo = map.get(pat);\n      if (foo != null && !foo.isEmpty()) {\n        return foo;\n      }\n      switch (pat.op) {\n      case TUPLE_PAT:\n        final Core.TuplePat tuplePat = (Core.TuplePat) pat;\n        if (tuplePat.args.stream().allMatch(this::canGet)) {\n          // Convert 'from x, y where p(x) andalso q(y)'\n          // to 'from x in extentP, y in extentQ'\n          // and that becomes the extent of '(x, y)'.\n          final FromBuilder fromBuilder = core.fromBuilder(typeSystem);\n          final List<Core.Exp> filters = new ArrayList<>();\n          for (Core.Pat p : tuplePat.args) {\n            PairList<Core.Exp, Core.Exp> f =\n                requireNonNull(get(typeSystem, p), \"contradicts canGet\");\n            fromBuilder.scan(p, core.union(typeSystem, f.leftList()));\n            core.flattenAnds(f.rightList(), filters::add);\n          }\n          return PairList.of(fromBuilder.build(),\n              core.andAlso(typeSystem, filters));\n        } else {\n          final PairList<Core.Exp, Core.Exp> foo1 = PairList.of();\n          map.forEach((pat1, foo2) -> {\n            if (pat1.op == Op.TUPLE_PAT) {\n              final Core.TuplePat tuplePat1 = (Core.TuplePat) pat1;\n              final List<String> fieldNames = tuplePat1.fieldNames();\n              if (tuplePat.args.stream().allMatch(arg ->\n                  arg instanceof Core.NamedPat\n                      && fieldNames.contains(((Core.NamedPat) arg).name))) {\n                foo1.addAll(foo2);\n              }\n            }\n          });\n          return foo1;\n        }\n      default:\n        throw new AssertionError(\"contradicts canGet\");\n      }\n    }\n\n    boolean canGet(Core.Pat pat) {\n      PairList<Core.Exp, Core.Exp> foo = map.get(pat);\n      if (foo != null && !foo.isEmpty()) {\n        return true;\n      }\n      if (pat.type.isFinite()) {\n        return true;\n      }\n      switch (pat.op) {\n      case TUPLE_PAT:\n        final Core.TuplePat tuplePat = (Core.TuplePat) pat;\n        if (tuplePat.args.stream().allMatch(this::canGet)) {\n          return true;\n        }\n        // If the map contains a tuple with a field for every one of this\n        // tuple's fields (not necessarily in the same order) then we can use\n        // it.\n        for (Core.Pat pat1 : map.keySet()) {\n          if (pat1.op == Op.TUPLE_PAT) {\n            final Core.TuplePat tuplePat1 = (Core.TuplePat) pat1;\n            final List<String> fieldNames = tuplePat1.fieldNames();\n            if (tuplePat.args.stream().allMatch(arg ->\n                arg instanceof Core.NamedPat\n                    && fieldNames.contains(((Core.NamedPat) arg).name))) {\n              return true;\n            }\n          }\n        }\n        return false;\n      default:\n        return false;\n      }\n    }\n  }", "definition": "  static class ExtentMap", "class_docstring": "", "name": "ExtentMap", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "fields": [{"attribute_expression": "final Map<Core.Pat, PairList<Core.Exp, Core.Exp>> map =\n        new LinkedHashMap<>();", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "Map<Core.Pat, PairList<Core.Exp, Core.Exp>>", "name": "map =\n        new LinkedHashMap<>()", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    public PairList<Core.Exp, Core.Exp> get(TypeSystem typeSystem,\n        Core.Pat pat) {\n      PairList<Core.Exp, Core.Exp> foo = map.get(pat);\n      if (foo != null && !foo.isEmpty()) {\n        return foo;\n      }\n      if (canGet(pat)) {\n        return get_(typeSystem, pat);\n      }\n      return ImmutablePairList.of();\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "PairList<Core.Exp, Core.Exp>", "classes": []}, "name": "get", "params": [{"name": "typeSystem", "type": "TypeSystem"}, {"name": "pat", "type": "Core.Pat"}], "body": "                      {\n      PairList<Core.Exp, Core.Exp> foo = map.get(pat);\n      if (foo != null && !foo.isEmpty()) {\n        return foo;\n      }\n      if (canGet(pat)) {\n        return get_(typeSystem, pat);\n      }\n      return ImmutablePairList.of();\n    }", "signature": "public PairList<Core.Exp, Core.Exp> get(TypeSystem typeSystem,\n        Core.Pat pat)"}, {"syntax_pass": true, "original_string": "    private @NonNull PairList<Core.Exp, Core.Exp> get_(TypeSystem typeSystem,\n        Core.Pat pat) {\n      final PairList<Core.Exp, Core.Exp> foo = map.get(pat);\n      if (foo != null && !foo.isEmpty()) {\n        return foo;\n      }\n      switch (pat.op) {\n      case TUPLE_PAT:\n        final Core.TuplePat tuplePat = (Core.TuplePat) pat;\n        if (tuplePat.args.stream().allMatch(this::canGet)) {\n          // Convert 'from x, y where p(x) andalso q(y)'\n          // to 'from x in extentP, y in extentQ'\n          // and that becomes the extent of '(x, y)'.\n          final FromBuilder fromBuilder = core.fromBuilder(typeSystem);\n          final List<Core.Exp> filters = new ArrayList<>();\n          for (Core.Pat p : tuplePat.args) {\n            PairList<Core.Exp, Core.Exp> f =\n                requireNonNull(get(typeSystem, p), \"contradicts canGet\");\n            fromBuilder.scan(p, core.union(typeSystem, f.leftList()));\n            core.flattenAnds(f.rightList(), filters::add);\n          }\n          return PairList.of(fromBuilder.build(),\n              core.andAlso(typeSystem, filters));\n        } else {\n          final PairList<Core.Exp, Core.Exp> foo1 = PairList.of();\n          map.forEach((pat1, foo2) -> {\n            if (pat1.op == Op.TUPLE_PAT) {\n              final Core.TuplePat tuplePat1 = (Core.TuplePat) pat1;\n              final List<String> fieldNames = tuplePat1.fieldNames();\n              if (tuplePat.args.stream().allMatch(arg ->\n                  arg instanceof Core.NamedPat\n                      && fieldNames.contains(((Core.NamedPat) arg).name))) {\n                foo1.addAll(foo2);\n              }\n            }\n          });\n          return foo1;\n        }\n      default:\n        throw new AssertionError(\"contradicts canGet\");\n      }\n    }", "docstring": "\nConstructs an expression for the extent of a pattern.\nYou must have called {@link #canGet} first.\n", "attributes": {"modifiers": "private @NonNull", "marker_annotations": ["@NonNull"], "non_marker_annotations": ["private"], "comments": [], "return_type": "PairList<Core.Exp, Core.Exp>", "classes": []}, "name": "get_", "params": [{"name": "typeSystem", "type": "TypeSystem"}, {"name": "pat", "type": "Core.Pat"}], "body": "                      {\n      final PairList<Core.Exp, Core.Exp> foo = map.get(pat);\n      if (foo != null && !foo.isEmpty()) {\n        return foo;\n      }\n      switch (pat.op) {\n      case TUPLE_PAT:\n        final Core.TuplePat tuplePat = (Core.TuplePat) pat;\n        if (tuplePat.args.stream().allMatch(this::canGet)) {\n          // Convert 'from x, y where p(x) andalso q(y)'\n          // to 'from x in extentP, y in extentQ'\n          // and that becomes the extent of '(x, y)'.\n          final FromBuilder fromBuilder = core.fromBuilder(typeSystem);\n          final List<Core.Exp> filters = new ArrayList<>();\n          for (Core.Pat p : tuplePat.args) {\n            PairList<Core.Exp, Core.Exp> f =\n                requireNonNull(get(typeSystem, p), \"contradicts canGet\");\n            fromBuilder.scan(p, core.union(typeSystem, f.leftList()));\n            core.flattenAnds(f.rightList(), filters::add);\n          }\n          return PairList.of(fromBuilder.build(),\n              core.andAlso(typeSystem, filters));\n        } else {\n          final PairList<Core.Exp, Core.Exp> foo1 = PairList.of();\n          map.forEach((pat1, foo2) -> {\n            if (pat1.op == Op.TUPLE_PAT) {\n              final Core.TuplePat tuplePat1 = (Core.TuplePat) pat1;\n              final List<String> fieldNames = tuplePat1.fieldNames();\n              if (tuplePat.args.stream().allMatch(arg ->\n                  arg instanceof Core.NamedPat\n                      && fieldNames.contains(((Core.NamedPat) arg).name))) {\n                foo1.addAll(foo2);\n              }\n            }\n          });\n          return foo1;\n        }\n      default:\n        throw new AssertionError(\"contradicts canGet\");\n      }\n    }", "signature": "private @NonNull PairList<Core.Exp, Core.Exp> get_(TypeSystem typeSystem,\n        Core.Pat pat)"}, {"syntax_pass": true, "original_string": "    boolean canGet(Core.Pat pat) {\n      PairList<Core.Exp, Core.Exp> foo = map.get(pat);\n      if (foo != null && !foo.isEmpty()) {\n        return true;\n      }\n      if (pat.type.isFinite()) {\n        return true;\n      }\n      switch (pat.op) {\n      case TUPLE_PAT:\n        final Core.TuplePat tuplePat = (Core.TuplePat) pat;\n        if (tuplePat.args.stream().allMatch(this::canGet)) {\n          return true;\n        }\n        // If the map contains a tuple with a field for every one of this\n        // tuple's fields (not necessarily in the same order) then we can use\n        // it.\n        for (Core.Pat pat1 : map.keySet()) {\n          if (pat1.op == Op.TUPLE_PAT) {\n            final Core.TuplePat tuplePat1 = (Core.TuplePat) pat1;\n            final List<String> fieldNames = tuplePat1.fieldNames();\n            if (tuplePat.args.stream().allMatch(arg ->\n                arg instanceof Core.NamedPat\n                    && fieldNames.contains(((Core.NamedPat) arg).name))) {\n              return true;\n            }\n          }\n        }\n        return false;\n      default:\n        return false;\n      }\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "boolean", "classes": []}, "name": "canGet", "params": [{"name": "pat", "type": "Core.Pat"}], "body": "                                 {\n      PairList<Core.Exp, Core.Exp> foo = map.get(pat);\n      if (foo != null && !foo.isEmpty()) {\n        return true;\n      }\n      if (pat.type.isFinite()) {\n        return true;\n      }\n      switch (pat.op) {\n      case TUPLE_PAT:\n        final Core.TuplePat tuplePat = (Core.TuplePat) pat;\n        if (tuplePat.args.stream().allMatch(this::canGet)) {\n          return true;\n        }\n        // If the map contains a tuple with a field for every one of this\n        // tuple's fields (not necessarily in the same order) then we can use\n        // it.\n        for (Core.Pat pat1 : map.keySet()) {\n          if (pat1.op == Op.TUPLE_PAT) {\n            final Core.TuplePat tuplePat1 = (Core.TuplePat) pat1;\n            final List<String> fieldNames = tuplePat1.fieldNames();\n            if (tuplePat.args.stream().allMatch(arg ->\n                arg instanceof Core.NamedPat\n                    && fieldNames.contains(((Core.NamedPat) arg).name))) {\n              return true;\n            }\n          }\n        }\n        return false;\n      default:\n        return false;\n      }\n    }", "signature": "boolean canGet(Core.Pat pat)"}]}], "class_docstring": " Generates an expression for the set of values that a variable can take in\na program.\n\n<p>If {@code i} is a variable of type {@code int} then one approximation is\nthe set of all 2<sup>32</sup> values of the {@code int} data type. (Every\ndata type, primitive data types and those built using sum ({@code datatype})\nor product (record and tuple), has a finite set of values, but the set is\nusually too large to iterate over.)\n\n<p>There is often a better approximation that can be deduced from the uses\nof the variable. For example,\n\n<blockquote><pre>{@code\n  let\n    fun isOdd i = i % 2 = 0\n  in\n    from e in emps,\n        i\n      where isOdd i\n        andalso i < 100\n        andalso i = e.deptno\n  end\n}</pre></blockquote>\n\n<p>we can deduce a better extent for {@code i}, namely\n\n<blockquote><pre>{@code\n   from e in emps\n     yield e.deptno\n     where deptno % 2 = 0\n       andalso deptno < 100\n}</pre></blockquote>\n", "original_string": "public class Extents {\n  private Extents() {}\n\n  /** Analyzes the extent of a pattern in an expression and creates an\n   * {@link Analysis}.\n   *\n   * <p>For example, given the program\n   *\n   * <blockquote><pre>{@code\n   *   let\n   *     fun f i = i elem [1, 2, 4]\n   *   in\n   *     from x where f x\n   *   end\n   * }</pre></blockquote>\n   *\n   * <p>we can deduce that the extent of \"x\" is \"[1, 2, 4]\".\n   *\n   * <p>We can also compute the extent of tuples. For the program\n   *\n   * <blockquote><pre>{@code\n   *   let\n   *     val edges = [(1, 2), (2, 3), (1, 4), (4, 2), (4, 3)]\n   *     fun edge (i, j) = (i, j) elem edges\n   *   in\n   *     from x, y, z\n   *     where edge (x, y) andalso edge (y, z) andalso x <> z\n   *   end\n   * }</pre></blockquote>\n   *\n   * <p>we could deduce that \"x\" has extent \"from e in edges group e.i\",\n   * \"y\" has extent \"from e in edges group e.j\"\n   * (\"from e in edges group e.i\" is also valid),\n   * \"z\" has extent \"from e in edges group e.j\",\n   * and therefore \"(x, y, z)\" has extent\n   *\n   * <blockquote><pre>{@code\n   * from x in (from e in edges group e.i),\n   *   y in (from e in edges group e.j),\n   *   z in (from e in edges group e.j)\n   * }</pre></blockquote>\n   *\n   * <p>but we can do better by computing the extent of (x, y) simultaneously:\n   *\n   * <blockquote><pre>{@code\n   * from (x, y) in (from e in edges),\n   *   z in (from e in edges group e.j)\n   * }</pre></blockquote>\n   */\n  public static Analysis create(TypeSystem typeSystem, Core.Pat pat,\n      SortedMap<Core.NamedPat, Core.Exp> boundPats,\n      Iterable<? extends Core.FromStep> followingSteps,\n      PairList<Core.IdPat, Core.Exp> idPats) {\n    final Extent extent = new Extent(typeSystem, pat, boundPats, idPats);\n    final List<Core.Exp> remainingFilters = new ArrayList<>();\n\n    final ExtentMap map = new ExtentMap();\n    for (Core.FromStep step : followingSteps) {\n      if (step instanceof Core.Where) {\n        extent.g3(map.map, ((Core.Where) step).exp);\n      }\n    }\n    extent.definitions.forEach((namedPat, exp) -> {\n      // Is this expression better than the existing one?\n      // Yes, if there's no existing expression,\n      // or if the existing expression is infinite.\n      // For example, 'dno = v.deptno' is better than 'dno > 25'.\n      if (!map.map.containsKey(namedPat)\n          || Extents.isInfinite(map.map.get(namedPat).left(0))) {\n        map.map.put(namedPat,\n            ImmutablePairList.of(core.list(typeSystem, exp),\n                core.equal(typeSystem, core.id(namedPat), exp)));\n      }\n    });\n    final PairList<Core.Exp, Core.Exp> foo = map.get(typeSystem, pat);\n    final Pair<Core.Exp, Core.Exp> extentFilter;\n    if (foo.isEmpty()) {\n      extentFilter =\n          Pair.of(\n              core.extent(typeSystem, pat.type,\n                  ImmutableRangeSet.of(Range.all())),\n              core.boolLiteral(true));\n    } else {\n      extentFilter = reduceAnd(typeSystem, foo);\n    }\n    return new Analysis(boundPats, extent.goalPats,\n        extentFilter.left, core.decomposeAnd(extentFilter.right),\n        remainingFilters);\n  }\n\n  /** Converts a singleton id pattern \"x\" or tuple pattern \"(x, y)\"\n   * to a list of id patterns. */\n  private static List<Core.IdPat> flatten(Core.Pat pat) {\n    switch (pat.op) {\n    case ID_PAT:\n      return ImmutableList.of((Core.IdPat) pat);\n\n    case TUPLE_PAT:\n      final Core.TuplePat tuplePat = (Core.TuplePat) pat;\n      for (Core.Pat arg : tuplePat.args) {\n        if (arg.op != Op.ID_PAT) {\n          throw new CompileException(\"must be id\", false, arg.pos);\n        }\n      }\n      //noinspection unchecked,rawtypes\n      return (List) tuplePat.args;\n\n    case RECORD_PAT:\n      final Core.RecordPat recordPat = (Core.RecordPat) pat;\n      for (Core.Pat arg : recordPat.args) {\n        if (arg.op != Op.ID_PAT) {\n          throw new CompileException(\"must be id\", false, arg.pos);\n        }\n      }\n      //noinspection unchecked,rawtypes\n      return (List) recordPat.args;\n\n    default:\n      throw new CompileException(\"must be id\", false, pat.pos);\n    }\n  }\n\n  /** Returns whether an expression is an infinite extent. */\n  public static boolean isInfinite(Core.Exp exp) {\n    if (!exp.isCallTo(BuiltIn.Z_EXTENT)) {\n      return false;\n    }\n    final Core.Apply apply = (Core.Apply) exp;\n    final Core.Literal literal = (Core.Literal) apply.arg;\n    final RangeExtent rangeExtent = literal.unwrap(RangeExtent.class);\n    return rangeExtent.iterable == null;\n  }\n\n  public static Core.Decl infinitePats(TypeSystem typeSystem,\n      Core.Decl node) {\n    return node.accept(\n        new Shuttle(typeSystem) {\n          @Override protected Core.From visit(Core.From from) {\n            for (Ord<Core.FromStep> step : Ord.zip(from.steps)) {\n              if (step.e instanceof Core.Scan) {\n                final Core.Scan scan = (Core.Scan) step.e;\n                if (isInfinite(scan.exp)) {\n                  final FromBuilder fromBuilder = core.fromBuilder(typeSystem);\n                  List<Core.FromStep> followingSteps =\n                      skip(from.steps, step.i + 1);\n                  final Analysis analysis =\n                      create(typeSystem, scan.pat, ImmutableSortedMap.of(),\n                          followingSteps, ImmutablePairList.of());\n                  for (Core.FromStep step2 : from.steps) {\n                    if (step2 == scan) {\n                      fromBuilder.scan(scan.pat, analysis.extentExp,\n                          scan.condition); // TODO\n                    } else if (step2 instanceof Core.Where) {\n                      fromBuilder.where(\n                          core.subTrue(typeSystem,\n                              ((Core.Where) step2).exp,\n                              analysis.satisfiedFilters));\n                    } else {\n                      fromBuilder.addAll(ImmutableList.of(step2));\n                    }\n                  }\n                  return fromBuilder.build();\n                }\n              }\n            }\n            return from; // unchanged\n          }\n        });\n  }\n\n  /** Intersects a collection of range set maps\n   * (maps from prefix to {@link RangeSet}) into one. */\n  public static <C extends Comparable<C>>\n      Map<String, ImmutableRangeSet<C>> intersect(\n          List<Map<String, ImmutableRangeSet<C>>> rangeSetMaps) {\n    switch (rangeSetMaps.size()) {\n    case 0:\n      // No filters, therefore the extent allows all values.\n      // An empty map expresses this.\n      return ImmutableMap.of();\n\n    case 1:\n      return rangeSetMaps.get(0);\n\n    default:\n      final Multimap<String, ImmutableRangeSet<C>> rangeSetMultimap =\n          HashMultimap.create();\n      for (Map<String, ImmutableRangeSet<C>> rangeSetMap : rangeSetMaps) {\n        rangeSetMap.forEach(rangeSetMultimap::put);\n      }\n      final ImmutableMap.Builder<String, ImmutableRangeSet<C>> rangeSetMap =\n          ImmutableMap.builder();\n      rangeSetMultimap.asMap().forEach((path, rangeSets) ->\n          rangeSetMap.put(path, intersectRangeSets(rangeSets)));\n      return rangeSetMap.build();\n    }\n  }\n\n  /** Unions a collection of range set maps\n   * (maps from prefix to {@link RangeSet}) into one. */\n  public static <C extends Comparable<C>>\n      Map<String, ImmutableRangeSet<C>> union(\n          List<Map<String, ImmutableRangeSet<C>>> rangeSetMaps) {\n    switch (rangeSetMaps.size()) {\n    case 0:\n      // No filters, therefore the extent is empty.\n      // A map containing an empty RangeSet for path \"/\" expresses this.\n      return ImmutableMap.of(\"/\", ImmutableRangeSet.of());\n\n    case 1:\n      return rangeSetMaps.get(0);\n\n    default:\n      final Multimap<String, ImmutableRangeSet<C>> rangeSetMultimap =\n          HashMultimap.create();\n      for (Map<String, ImmutableRangeSet<C>> rangeSetMap : rangeSetMaps) {\n        rangeSetMap.forEach(rangeSetMultimap::put);\n      }\n      final ImmutableMap.Builder<String, ImmutableRangeSet<C>> rangeSetMap =\n          ImmutableMap.builder();\n      rangeSetMultimap.asMap().forEach((path, rangeSets) ->\n          rangeSetMap.put(path, unionRangeSets(rangeSets)));\n      return rangeSetMap.build();\n    }\n  }\n\n  /** Intersects a collection of {@link RangeSet} into one.\n   *\n   * @see ImmutableRangeSet#intersection(RangeSet) */\n  private static <C extends Comparable<C>> ImmutableRangeSet<C>\n      intersectRangeSets(Collection<ImmutableRangeSet<C>> rangeSets) {\n    return rangeSets.stream().reduce(ImmutableRangeSet.of(Range.all()),\n        ImmutableRangeSet::intersection);\n  }\n\n  /** Unions a collection of {@link RangeSet} into one.\n   *\n   * @see ImmutableRangeSet#union(RangeSet) */\n  private static <C extends Comparable<C>> ImmutableRangeSet<C> unionRangeSets(\n      Collection<ImmutableRangeSet<C>> rangeSets) {\n    return rangeSets.stream().reduce(ImmutableRangeSet.of(),\n        ImmutableRangeSet::union);\n  }\n\n  /** Result of analyzing the variables in a query, pulling filters into the\n   * extent expression for each variable, so that no variable is over an\n   * infinite extent. */\n  public static class Analysis {\n    final SortedMap<Core.NamedPat, Core.Exp> boundPats;\n    final Set<Core.NamedPat> goalPats;\n    final Core.Exp extentExp;\n    final List<Core.Exp> satisfiedFilters; // filters satisfied by extentExp\n    final List<Core.Exp> remainingFilters;\n\n    private Analysis(SortedMap<Core.NamedPat, Core.Exp> boundPats,\n        Set<Core.NamedPat> goalPats,\n        Core.Exp extentExp, List<Core.Exp> satisfiedFilters,\n        List<Core.Exp> remainingFilters) {\n      this.boundPats = ImmutableSortedMap.copyOf(boundPats);\n      this.goalPats = ImmutableSet.copyOf(goalPats);\n      this.extentExp = extentExp;\n      this.satisfiedFilters = ImmutableList.copyOf(satisfiedFilters);\n      this.remainingFilters = ImmutableList.copyOf(remainingFilters);\n    }\n\n    Set<Core.NamedPat> unboundPats() {\n      return minus(goalPats, boundPats.keySet());\n    }\n  }\n\n  private static class Extent {\n    private final TypeSystem typeSystem;\n    final Set<Core.NamedPat> goalPats;\n    final SortedMap<Core.NamedPat, Core.Exp> boundPats;\n\n    /** New variables introduced as scans over an existing relation (list of\n     * records). Other variables, which are goals of this extent, are typically\n     * fields of this variable. */\n    final PairList<Core.IdPat, Core.Exp> idPats;\n\n    /** Contains definitions, such as \"name = d.dname\".\n     * With such a definition, \"name\" won't need an extent, because we\n     * can define it (or inline it) as the expression \"d.dname\". */\n    final Map<Core.NamedPat, Core.Exp> definitions = new HashMap<>();\n\n    Extent(TypeSystem typeSystem, Core.Pat pat,\n        SortedMap<Core.NamedPat, Core.Exp> boundPats,\n        PairList<Core.IdPat, Core.Exp> idPats) {\n      this.typeSystem = typeSystem;\n      this.goalPats = ImmutableSet.copyOf(flatten(pat));\n      this.boundPats = ImmutableSortedMap.copyOf(boundPats);\n      this.idPats = idPats;\n    }\n\n    @SuppressWarnings(\"SwitchStatementWithTooFewBranches\")\n    void g3(Map<Core.Pat, PairList<Core.Exp, Core.Exp>> map, Core.Exp filter) {\n      final Core.Apply apply;\n      switch (filter.op) {\n      case APPLY:\n        apply = (Core.Apply) filter;\n        switch (apply.fn.op) {\n        case FN_LITERAL:\n          BuiltIn builtIn = ((Core.Literal) apply.fn).unwrap(BuiltIn.class);\n          final Map<Core.Pat, PairList<Core.Exp, Core.Exp>> map2;\n          switch (builtIn) {\n          case Z_ANDALSO:\n            // Expression is 'andalso'. Visit each pattern, and 'and' the\n            // filters (intersect the extents).\n            map2 = new LinkedHashMap<>();\n            apply.arg.forEachArg((arg, i) -> g3(map2, arg));\n            map2.forEach((pat, foo) ->\n                map.computeIfAbsent(pat, p -> PairList.of())\n                    .addAll(foo));\n            break;\n\n          case Z_ORELSE:\n            // Expression is 'orelse'. Visit each pattern, and intersect the\n            // constraints (union the generators).\n            map2 = new LinkedHashMap<>();\n            final Map<Core.Pat, PairList<Core.Exp, Core.Exp>> map3 =\n                new LinkedHashMap<>();\n            apply.arg.forEachArg((arg, i) -> {\n              g3(map3, arg);\n              map3.forEach((pat, foo) ->\n                  map2.computeIfAbsent(pat, p -> PairList.of())\n                      .add(reduceAnd(typeSystem, foo)));\n              map3.clear();\n            });\n            map2.forEach((pat, foo) -> {\n              final PairList<Core.Exp, Core.Exp> foo1 =\n                  map.computeIfAbsent(pat, p -> PairList.of());\n              if (foo1.isEmpty()) {\n                // [] union [x2, x3, x4]\n                //  =>\n                // [x2, x3, x4]\n                foo1.add(reduceOr(typeSystem, foo));\n              } else {\n                // [x0, x1] union [x2, x3, x4]\n                //  =>\n                // [union(intersect(x0, x1), intersect(x2, x3, x4))]\n                PairList<Core.Exp, Core.Exp> intersectExtents = PairList.of();\n                intersectExtents.add(reduceAnd(typeSystem, foo1));\n                intersectExtents.add(reduceAnd(typeSystem, foo));\n                foo1.clear();\n                foo1.add(reduceOr(typeSystem, intersectExtents));\n              }\n            });\n            break;\n\n          case OP_EQ:\n          case OP_NE:\n          case OP_GE:\n          case OP_GT:\n          case OP_LT:\n          case OP_LE:\n            g4(builtIn, apply.arg(0), apply.arg(1), (pat, filter2, extent) ->\n                map.computeIfAbsent(pat, p -> PairList.of())\n                    .add(extent, filter2));\n            break;\n\n          case OP_ELEM:\n            switch (apply.arg(0).op) {\n            case ID:\n              final Core.NamedPat pat = ((Core.Id) apply.arg(0)).idPat;\n              map.computeIfAbsent(pat, p1 -> PairList.of())\n                  .add(apply.arg(1), apply);\n              break;\n\n            case TUPLE:\n              final Core.Tuple tuple = (Core.Tuple) apply.arg(0);\n              final Core.Id id = core.id(createId(tuple.type, apply.arg(1)));\n              final Core.Exp elem = core.elem(typeSystem, id, apply.arg(1));\n              g3(map,\n                  core.andAlso(typeSystem, elem,\n                      core.equal(typeSystem, id, tuple)));\n              final List<Core.Exp> conjunctions = new ArrayList<>();\n              conjunctions.add(core.elem(typeSystem, id, apply.arg(1)));\n              tuple.forEach((i, name, arg) ->\n                  conjunctions.add(\n                      core.equal(typeSystem,\n                          core.field(typeSystem, id, i),\n                          arg)));\n              g3(map, core.andAlso(typeSystem, conjunctions));\n              break;\n            }\n            break;\n          }\n        }\n        break;\n\n      default:\n        break;\n      }\n    }\n\n    private void g4(BuiltIn builtIn, Core.Exp arg0, Core.Exp arg1,\n        TriConsumer<Core.Pat, Core.Exp, Core.Exp> consumer) {\n      g5(builtIn, arg0, arg1, consumer);\n      g5(builtIn.reverse(), arg1, arg0, consumer);\n    }\n\n    @SuppressWarnings(\"SwitchStatementWithTooFewBranches\")\n    private void g5(BuiltIn builtIn, Core.Exp arg0, Core.Exp arg1,\n        TriConsumer<Core.Pat, Core.Exp, Core.Exp> consumer) {\n      switch (builtIn) {\n      case OP_EQ:\n        switch (arg0.op) {\n        case ID:\n          final Core.Id id = (Core.Id) arg0;\n          definitions.put(id.idPat, arg1);\n        }\n        // fall through\n      case OP_NE:\n      case OP_GE:\n      case OP_GT:\n      case OP_LE:\n      case OP_LT:\n        switch (arg0.op) {\n        case ID:\n          final Core.Id id = (Core.Id) arg0;\n          if (arg1.isConstant()) {\n            // If exp is \"id = literal\", add extent \"id: [literal]\";\n            // if exp is \"id > literal\", add extent \"id: (literal, inf)\", etc.\n            consumer.accept(id.idPat,\n                core.call(typeSystem, builtIn, arg0.type, Pos.ZERO, arg0, arg1),\n                baz(builtIn, arg1));\n          }\n          break;\n        }\n        break;\n\n      default:\n        throw new AssertionError(\"unexpected: \" + builtIn);\n      }\n    }\n\n    private Core.Exp baz(BuiltIn builtIn, Core.Exp arg) {\n      switch (builtIn) {\n      case OP_EQ:\n        return core.list(typeSystem, arg);\n      case OP_NE:\n        return core.extent(typeSystem, arg.type,\n            ImmutableRangeSet.of(Range.singleton(((Core.Literal) arg).value))\n                .complement());\n      case OP_GE:\n        return core.extent(typeSystem, arg.type,\n            ImmutableRangeSet.of(Range.atLeast(((Core.Literal) arg).value)));\n      case OP_GT:\n        return core.extent(typeSystem, arg.type,\n            ImmutableRangeSet.of(Range.greaterThan(((Core.Literal) arg).value)));\n      case OP_LE:\n        return core.extent(typeSystem, arg.type,\n            ImmutableRangeSet.of(Range.atMost(((Core.Literal) arg).value)));\n      case OP_LT:\n        return core.extent(typeSystem, arg.type,\n            ImmutableRangeSet.of(Range.lessThan(((Core.Literal) arg).value)));\n      default:\n        throw new AssertionError(\"unexpected: \" + builtIn);\n      }\n    }\n\n    private Core.IdPat createId(Type type, Core.Exp extent) {\n      int i = idPats.firstMatch((id, e) -> extent.equals(e));\n      if (i >= 0) {\n        return idPats.leftList().get(i);\n      }\n      final Core.IdPat idPat = core.idPat(type, typeSystem.nameGenerator);\n      idPats.add(idPat, extent);\n      return idPat;\n    }\n  }\n\n  /** Reduces a list of extent-filter pairs [e0, f0, e1, f1, ...]\n   * to an extent-filter pair [e0 intersect e1 ..., f0 andalso f1 ...].\n   *\n   * <p>If any of the e<sub>i</sub> are calls to\n   * {@link BuiltIn#Z_EXTENT extent}, merges them into a single extent.\n   * For example, in\n   *\n   * <blockquote><pre>{@code\n   * [extent \"int: (0, inf)\", x > 0,\n   *   x elem primes, isPrime x,\n   *   extent \"int: (-inf, 10)\", x < 10]\n   * }</pre></blockquote>\n   *\n   * <p>the extents for \"(0, inf)\" and \"(-inf, 10)\" are merged into\n   * extent \"(0, 10)\":\n   *\n   * <blockquote><pre>{@code\n   * (extent \"int: (0, 10)\" intersect primes,\n   *   x > 0 andalso isPrime x andalso x < 10)\n   * }</pre></blockquote>\n   */\n  static Pair<Core.Exp, Core.Exp> reduceAnd(TypeSystem typeSystem,\n      PairList<Core.Exp, Core.Exp> extentFilters) {\n    if (extentFilters.isEmpty()) {\n      // Empty list would require us to create an infinite extent, but we\n      // don't know the type. Caller must ensure that the list is non-empty.\n      throw new IllegalArgumentException();\n    }\n    final List<Core.Exp> extents = new ArrayList<>();\n    core.flattenAnds(extentFilters.leftList(), extents::add);\n    final Pair<Core.Exp, List<Core.Exp>> pair =\n        core.intersectExtents(typeSystem, extents);\n    return Pair.of(pair.left,\n        core.andAlso(typeSystem, extentFilters.rightList()));\n  }\n\n  /** Reduces a list of extent-filter pairs [e0, f0, e1, f1, ...]\n   * to an extent-filter pair [e0 union e1 ..., f0 orelse f1 ...]. */\n  static Pair<Core.Exp, Core.Exp> reduceOr(TypeSystem typeSystem,\n      PairList<Core.Exp, Core.Exp> extentFilters) {\n    return Pair.of(core.union(typeSystem, extentFilters.leftList()),\n        core.orElse(typeSystem, extentFilters.rightList()));\n  }\n\n  @FunctionalInterface\n  interface TriConsumer<R, S, T> {\n    void accept(R r, S s, T t);\n  }\n\n  static class ExtentMap {\n    final Map<Core.Pat, PairList<Core.Exp, Core.Exp>> map =\n        new LinkedHashMap<>();\n\n    public PairList<Core.Exp, Core.Exp> get(TypeSystem typeSystem,\n        Core.Pat pat) {\n      PairList<Core.Exp, Core.Exp> foo = map.get(pat);\n      if (foo != null && !foo.isEmpty()) {\n        return foo;\n      }\n      if (canGet(pat)) {\n        return get_(typeSystem, pat);\n      }\n      return ImmutablePairList.of();\n    }\n\n    /**\n     * Constructs an expression for the extent of a pattern.\n     * You must have called {@link #canGet} first.\n     */\n    private @NonNull PairList<Core.Exp, Core.Exp> get_(TypeSystem typeSystem,\n        Core.Pat pat) {\n      final PairList<Core.Exp, Core.Exp> foo = map.get(pat);\n      if (foo != null && !foo.isEmpty()) {\n        return foo;\n      }\n      switch (pat.op) {\n      case TUPLE_PAT:\n        final Core.TuplePat tuplePat = (Core.TuplePat) pat;\n        if (tuplePat.args.stream().allMatch(this::canGet)) {\n          // Convert 'from x, y where p(x) andalso q(y)'\n          // to 'from x in extentP, y in extentQ'\n          // and that becomes the extent of '(x, y)'.\n          final FromBuilder fromBuilder = core.fromBuilder(typeSystem);\n          final List<Core.Exp> filters = new ArrayList<>();\n          for (Core.Pat p : tuplePat.args) {\n            PairList<Core.Exp, Core.Exp> f =\n                requireNonNull(get(typeSystem, p), \"contradicts canGet\");\n            fromBuilder.scan(p, core.union(typeSystem, f.leftList()));\n            core.flattenAnds(f.rightList(), filters::add);\n          }\n          return PairList.of(fromBuilder.build(),\n              core.andAlso(typeSystem, filters));\n        } else {\n          final PairList<Core.Exp, Core.Exp> foo1 = PairList.of();\n          map.forEach((pat1, foo2) -> {\n            if (pat1.op == Op.TUPLE_PAT) {\n              final Core.TuplePat tuplePat1 = (Core.TuplePat) pat1;\n              final List<String> fieldNames = tuplePat1.fieldNames();\n              if (tuplePat.args.stream().allMatch(arg ->\n                  arg instanceof Core.NamedPat\n                      && fieldNames.contains(((Core.NamedPat) arg).name))) {\n                foo1.addAll(foo2);\n              }\n            }\n          });\n          return foo1;\n        }\n      default:\n        throw new AssertionError(\"contradicts canGet\");\n      }\n    }\n\n    boolean canGet(Core.Pat pat) {\n      PairList<Core.Exp, Core.Exp> foo = map.get(pat);\n      if (foo != null && !foo.isEmpty()) {\n        return true;\n      }\n      if (pat.type.isFinite()) {\n        return true;\n      }\n      switch (pat.op) {\n      case TUPLE_PAT:\n        final Core.TuplePat tuplePat = (Core.TuplePat) pat;\n        if (tuplePat.args.stream().allMatch(this::canGet)) {\n          return true;\n        }\n        // If the map contains a tuple with a field for every one of this\n        // tuple's fields (not necessarily in the same order) then we can use\n        // it.\n        for (Core.Pat pat1 : map.keySet()) {\n          if (pat1.op == Op.TUPLE_PAT) {\n            final Core.TuplePat tuplePat1 = (Core.TuplePat) pat1;\n            final List<String> fieldNames = tuplePat1.fieldNames();\n            if (tuplePat.args.stream().allMatch(arg ->\n                arg instanceof Core.NamedPat\n                    && fieldNames.contains(((Core.NamedPat) arg).name))) {\n              return true;\n            }\n          }\n        }\n        return false;\n      default:\n        return false;\n      }\n    }\n  }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/main/java/net/hydromatic/morel/compile/CompileException.java.CompileException", "name": "CompileException", "file_path": "src/main/java/net/hydromatic/morel/compile/CompileException.java", "superclasses": "RuntimeException", "methods": ["[]CompileException(String,boolean,Pos)", "[String]toString()", "[Pos]pos()", "[StringBuilder]describeTo(StringBuilder)"], "method_uris": ["src/main/java/net/hydromatic/morel/compile/CompileException.java.CompileException.[]CompileException(String,boolean,Pos)", "src/main/java/net/hydromatic/morel/compile/CompileException.java.CompileException.[String]toString()", "src/main/java/net/hydromatic/morel/compile/CompileException.java.CompileException.[Pos]pos()", "src/main/java/net/hydromatic/morel/compile/CompileException.java.CompileException.[StringBuilder]describeTo(StringBuilder)"], "overrides": null, "attributes": [], "class_docstring": " An error occurred during compilation.", "original_string": "public class CompileException extends RuntimeException\n    implements MorelException {\n  private final boolean warning;\n  private final Pos pos;\n\n  public CompileException(String message, boolean warning, Pos pos) {\n    super(message);\n    this.warning = warning;\n    this.pos = pos;\n  }\n\n  @Override public String toString() {\n    return super.toString() + \" at \" + pos;\n  }\n\n  @Override public Pos pos() {\n    return pos;\n  }\n\n  public StringBuilder describeTo(StringBuilder buf) {\n    return pos.describeTo(buf)\n        .append(warning ? \" Warning: \" : \" Error: \")\n        .append(getMessage());\n  }\n}", "super_interfaces": ["MorelException"], "fields": [{"attribute_expression": "private final boolean warning;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "boolean", "name": "warning", "syntax_pass": true}, {"attribute_expression": "private final Pos pos;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Pos", "name": "pos", "syntax_pass": true}]}, {"uris": "src/main/java/net/hydromatic/morel/compile/Resolver.java.Resolver", "name": "Resolver", "file_path": "src/main/java/net/hydromatic/morel/compile/Resolver.java", "superclasses": "", "methods": ["[]Resolver(TypeMap,NameGenerator,Map<Pair<Core.NamedPat, Type>, Core.NamedPat>,Environment,Session)", "[Resolver]of(TypeMap,Environment,Session)", "[Resolver]withEnv(Environment)", "[Resolver]withEnv(Iterable<Binding>)", "[Core.Decl]toCore(Ast.Decl)", "[Core.ValDecl]toCore(Ast.ValDecl)", "[Core.DatatypeDecl]toCore(Ast.DatatypeDecl)", "[ResolvedDecl]resolve(Ast.Decl,List<Binding>)", "[ResolvedDatatypeDecl]resolveDatatypeDecl(Ast.DatatypeDecl,List<Binding>)", "[ResolvedValDecl]resolveValDecl(Ast.ValDecl,List<Binding>)", "[boolean]references(List<PatExp>)", "[DataType]toCore(Ast.DatatypeBind)", "[Core.Exp]toCore(Ast.Exp)", "[Core.Id]toCore(Ast.Id)", "[Core.IdPat]toCorePat(Ast.Id)", "[Core.NamedPat]getIdPat(Ast.Id,Binding)", "[Core.Tuple]toCore(Ast.Tuple)", "[Core.Tuple]toCore(Ast.Record)", "[Core.Exp]toCore(Ast.ListExp)", "[Core.Exp]toCoreFromEq(Ast.Exp)", "[Core.Apply]toCore(Ast.Apply)", "[Object]valueOf(Environment,Core.Exp)", "[Core.RecordSelector]toCore(Ast.RecordSelector)", "[Core.Apply]toCore(Ast.InfixCall)", "[BuiltIn]toBuiltIn(Op)", "[Core.Fn]toCore(Ast.Fn)", "[Core.Case]toCore(Ast.If)", "[Core.Case]toCore(Ast.Case)", "[Core.Exp]toCore(Ast.Let)", "[Core.Exp]flattenLet(List<Ast.Decl>,Ast.Exp)", "[void]flatten(Map<Ast.Pat, Ast.Exp>,boolean,Ast.Pat,Ast.Exp)", "[Core.Pat]toCore(Ast.Pat)", "[Core.Pat]toCore(Ast.Pat,Type)", "[Core.Pat]toCore(Ast.Pat,Type,Type)", "[Core.Match]toCore(Ast.Match)", "[Core.Exp]toCore(Ast.From)", "[boolean]subsumes(Type,Type)", "[Core.Aggregate]toCore(Ast.Aggregate,Collection<? extends Core.IdPat>)", "[Core.OrderItem]toCore(Ast.OrderItem)"], "method_uris": ["src/main/java/net/hydromatic/morel/compile/Resolver.java.Resolver.[]Resolver(TypeMap,NameGenerator,Map<Pair<Core.NamedPat, Type>, Core.NamedPat>,Environment,Session)", "src/main/java/net/hydromatic/morel/compile/Resolver.java.Resolver.[Resolver]of(TypeMap,Environment,Session)", "src/main/java/net/hydromatic/morel/compile/Resolver.java.Resolver.[Resolver]withEnv(Environment)", "src/main/java/net/hydromatic/morel/compile/Resolver.java.Resolver.[Resolver]withEnv(Iterable<Binding>)", "src/main/java/net/hydromatic/morel/compile/Resolver.java.Resolver.[Core.Decl]toCore(Ast.Decl)", "src/main/java/net/hydromatic/morel/compile/Resolver.java.Resolver.[Core.ValDecl]toCore(Ast.ValDecl)", "src/main/java/net/hydromatic/morel/compile/Resolver.java.Resolver.[Core.DatatypeDecl]toCore(Ast.DatatypeDecl)", "src/main/java/net/hydromatic/morel/compile/Resolver.java.Resolver.[ResolvedDecl]resolve(Ast.Decl,List<Binding>)", "src/main/java/net/hydromatic/morel/compile/Resolver.java.Resolver.[ResolvedDatatypeDecl]resolveDatatypeDecl(Ast.DatatypeDecl,List<Binding>)", "src/main/java/net/hydromatic/morel/compile/Resolver.java.Resolver.[ResolvedValDecl]resolveValDecl(Ast.ValDecl,List<Binding>)", "src/main/java/net/hydromatic/morel/compile/Resolver.java.Resolver.[boolean]references(List<PatExp>)", "src/main/java/net/hydromatic/morel/compile/Resolver.java.Resolver.[DataType]toCore(Ast.DatatypeBind)", "src/main/java/net/hydromatic/morel/compile/Resolver.java.Resolver.[Core.Exp]toCore(Ast.Exp)", "src/main/java/net/hydromatic/morel/compile/Resolver.java.Resolver.[Core.Id]toCore(Ast.Id)", "src/main/java/net/hydromatic/morel/compile/Resolver.java.Resolver.[Core.IdPat]toCorePat(Ast.Id)", "src/main/java/net/hydromatic/morel/compile/Resolver.java.Resolver.[Core.NamedPat]getIdPat(Ast.Id,Binding)", "src/main/java/net/hydromatic/morel/compile/Resolver.java.Resolver.[Core.Tuple]toCore(Ast.Tuple)", "src/main/java/net/hydromatic/morel/compile/Resolver.java.Resolver.[Core.Tuple]toCore(Ast.Record)", "src/main/java/net/hydromatic/morel/compile/Resolver.java.Resolver.[Core.Exp]toCore(Ast.ListExp)", "src/main/java/net/hydromatic/morel/compile/Resolver.java.Resolver.[Core.Exp]toCoreFromEq(Ast.Exp)", "src/main/java/net/hydromatic/morel/compile/Resolver.java.Resolver.[Core.Apply]toCore(Ast.Apply)", "src/main/java/net/hydromatic/morel/compile/Resolver.java.Resolver.[Object]valueOf(Environment,Core.Exp)", "src/main/java/net/hydromatic/morel/compile/Resolver.java.Resolver.[Core.RecordSelector]toCore(Ast.RecordSelector)", "src/main/java/net/hydromatic/morel/compile/Resolver.java.Resolver.[Core.Apply]toCore(Ast.InfixCall)", "src/main/java/net/hydromatic/morel/compile/Resolver.java.Resolver.[BuiltIn]toBuiltIn(Op)", "src/main/java/net/hydromatic/morel/compile/Resolver.java.Resolver.[Core.Fn]toCore(Ast.Fn)", "src/main/java/net/hydromatic/morel/compile/Resolver.java.Resolver.[Core.Case]toCore(Ast.If)", "src/main/java/net/hydromatic/morel/compile/Resolver.java.Resolver.[Core.Case]toCore(Ast.Case)", "src/main/java/net/hydromatic/morel/compile/Resolver.java.Resolver.[Core.Exp]toCore(Ast.Let)", "src/main/java/net/hydromatic/morel/compile/Resolver.java.Resolver.[Core.Exp]flattenLet(List<Ast.Decl>,Ast.Exp)", "src/main/java/net/hydromatic/morel/compile/Resolver.java.Resolver.[void]flatten(Map<Ast.Pat, Ast.Exp>,boolean,Ast.Pat,Ast.Exp)", "src/main/java/net/hydromatic/morel/compile/Resolver.java.Resolver.[Core.Pat]toCore(Ast.Pat)", "src/main/java/net/hydromatic/morel/compile/Resolver.java.Resolver.[Core.Pat]toCore(Ast.Pat,Type)", "src/main/java/net/hydromatic/morel/compile/Resolver.java.Resolver.[Core.Pat]toCore(Ast.Pat,Type,Type)", "src/main/java/net/hydromatic/morel/compile/Resolver.java.Resolver.[Core.Match]toCore(Ast.Match)", "src/main/java/net/hydromatic/morel/compile/Resolver.java.Resolver.[Core.Exp]toCore(Ast.From)", "src/main/java/net/hydromatic/morel/compile/Resolver.java.Resolver.[boolean]subsumes(Type,Type)", "src/main/java/net/hydromatic/morel/compile/Resolver.java.Resolver.[Core.Aggregate]toCore(Ast.Aggregate,Collection<? extends Core.IdPat>)", "src/main/java/net/hydromatic/morel/compile/Resolver.java.Resolver.[Core.OrderItem]toCore(Ast.OrderItem)"], "overrides": null, "attributes": [{"original_string": "  static class ReferenceFinder extends EnvVisitor {\n    final Set<Core.NamedPat> set;\n\n    protected ReferenceFinder(TypeSystem typeSystem, Environment env,\n        Set<Core.NamedPat> set, Deque<FromContext> fromStack) {\n      super(typeSystem, env, fromStack);\n      this.set = set;\n    }\n\n    @Override protected ReferenceFinder push(Environment env) {\n      return new ReferenceFinder(typeSystem, env, set, fromStack);\n    }\n\n    @Override protected void visit(Core.Id id) {\n      if (env.getOpt(id.idPat) == null) {\n        set.add(id.idPat);\n      }\n      super.visit(id);\n    }\n  }", "definition": "  static class ReferenceFinder extends EnvVisitor", "class_docstring": " Visitor that finds all references to unbound variables in an expression.", "name": "ReferenceFinder", "super_interfaces": [], "superclasses": "EnvVisitor", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "fields": [{"attribute_expression": "final Set<Core.NamedPat> set;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "Set<Core.NamedPat>", "name": "set", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    protected ReferenceFinder(TypeSystem typeSystem, Environment env,\n        Set<Core.NamedPat> set, Deque<FromContext> fromStack) {\n      super(typeSystem, env, fromStack);\n      this.set = set;\n    }", "docstring": "", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "", "classes": []}, "name": "ReferenceFinder", "params": [{"name": "typeSystem", "type": "TypeSystem"}, {"name": "env", "type": "Environment"}, {"name": "set", "type": "Set<Core.NamedPat>"}, {"name": "fromStack", "type": "Deque<FromContext>"}], "body": "                                                              {\n      super(typeSystem, env, fromStack);\n      this.set = set;\n    }", "signature": "protected ReferenceFinder(TypeSystem typeSystem, Environment env,\n        Set<Core.NamedPat> set, Deque<FromContext> fromStack)"}, {"syntax_pass": true, "original_string": "    @Override protected ReferenceFinder push(Environment env) {\n      return new ReferenceFinder(typeSystem, env, set, fromStack);\n    }", "docstring": "", "attributes": {"modifiers": "@Override protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "ReferenceFinder", "classes": []}, "name": "push", "params": [{"name": "env", "type": "Environment"}], "body": "                                                              {\n      return new ReferenceFinder(typeSystem, env, set, fromStack);\n    }", "signature": "@Override protected ReferenceFinder push(Environment env)"}, {"syntax_pass": true, "original_string": "    @Override protected void visit(Core.Id id) {\n      if (env.getOpt(id.idPat) == null) {\n        set.add(id.idPat);\n      }\n      super.visit(id);\n    }", "docstring": "", "attributes": {"modifiers": "@Override protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "name": "visit", "params": [{"name": "id", "type": "Core.Id"}], "body": "                                               {\n      if (env.getOpt(id.idPat) == null) {\n        set.add(id.idPat);\n      }\n      super.visit(id);\n    }", "signature": "@Override protected void visit(Core.Id id)"}]}, {"original_string": "  public abstract static class ResolvedDecl {\n    /** Converts the declaration to a {@code let} or a {@code local}. */\n    abstract Core.Exp toExp(Core.Exp resultExp);\n  }", "definition": "  public abstract static class ResolvedDecl", "class_docstring": " Resolved declaration. It can be converted to an expression given a\nresult expression; depending on sub-type, that expression will either be\na {@code let} (for a {@link net.hydromatic.morel.ast.Ast.ValDecl} or a\n{@code local} (for a {@link net.hydromatic.morel.ast.Ast.DatatypeDecl}.", "name": "ResolvedDecl", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public abstract static", "marker_annotations": [], "non_marker_annotations": ["public", "abstract", "static"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    abstract Core.Exp toExp(Core.Exp resultExp);", "docstring": " Converts the declaration to a {@code let} or a {@code local}.", "attributes": {"modifiers": "abstract", "marker_annotations": [], "non_marker_annotations": ["abstract"], "comments": [], "return_type": "Core.Exp", "classes": []}, "name": "toExp", "params": [{"name": "resultExp", "type": "Core.Exp"}], "body": "", "signature": "abstract Core.Exp toExp(Core.Exp resultExp)"}]}, {"original_string": "  class ResolvedValDecl extends ResolvedDecl {\n    final boolean rec;\n    final boolean composite;\n    final ImmutableList<PatExp> patExps;\n    final Core.NamedPat pat;\n    final Core.Exp exp;\n\n    ResolvedValDecl(boolean rec,\n        ImmutableList<PatExp> patExps,\n        Core.NamedPat pat, Core.Exp exp) {\n      this.rec = rec;\n      this.composite = patExps.size() > 1;\n      this.patExps = patExps;\n      this.pat = pat;\n      this.exp = exp;\n    }\n\n    @Override Core.Let toExp(Core.Exp resultExp) {\n      if (rec) {\n        final List<Core.NonRecValDecl> valDecls = new ArrayList<>();\n        patExps.forEach(x ->\n            valDecls.add(core.nonRecValDecl(x.pos, (Core.IdPat) x.pat, x.exp)));\n        return core.let(core.recValDecl(valDecls), resultExp);\n      }\n      if (!composite && patExps.get(0).pat instanceof Core.IdPat) {\n        final PatExp x = patExps.get(0);\n        Core.NonRecValDecl valDecl =\n            core.nonRecValDecl(x.pos, (Core.IdPat) x.pat, x.exp);\n        return core.let(valDecl, resultExp);\n      } else {\n        // This is a complex pattern. Allocate an intermediate variable.\n        final String name = nameGenerator.get();\n        final Core.IdPat idPat = core.idPat(pat.type, name, nameGenerator);\n        final Core.Id id = core.id(idPat);\n        final Pos pos = patExps.get(0).pos;\n        return core.let(core.nonRecValDecl(pos, idPat, exp),\n            core.caseOf(pos, resultExp.type, id,\n                ImmutableList.of(core.match(pos, pat, resultExp))));\n      }\n    }\n  }", "definition": "  class ResolvedValDecl extends ResolvedDecl", "class_docstring": " Resolved value declaration.", "name": "ResolvedValDecl", "super_interfaces": [], "superclasses": "ResolvedDecl", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "fields": [{"attribute_expression": "final boolean rec;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "boolean", "name": "rec", "syntax_pass": true}, {"attribute_expression": "final boolean composite;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "boolean", "name": "composite", "syntax_pass": true}, {"attribute_expression": "final ImmutableList<PatExp> patExps;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "ImmutableList<PatExp>", "name": "patExps", "syntax_pass": true}, {"attribute_expression": "final Core.NamedPat pat;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "Core.NamedPat", "name": "pat", "syntax_pass": true}, {"attribute_expression": "final Core.Exp exp;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "Core.Exp", "name": "exp", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    ResolvedValDecl(boolean rec,\n        ImmutableList<PatExp> patExps,\n        Core.NamedPat pat, Core.Exp exp) {\n      this.rec = rec;\n      this.composite = patExps.size() > 1;\n      this.patExps = patExps;\n      this.pat = pat;\n      this.exp = exp;\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "ResolvedValDecl", "params": [{"name": "rec", "type": "boolean"}, {"name": "patExps", "type": "ImmutableList<PatExp>"}, {"name": "pat", "type": "Core.NamedPat"}, {"name": "exp", "type": "Core.Exp"}], "body": "                                         {\n      this.rec = rec;\n      this.composite = patExps.size() > 1;\n      this.patExps = patExps;\n      this.pat = pat;\n      this.exp = exp;\n    }", "signature": "ResolvedValDecl(boolean rec,\n        ImmutableList<PatExp> patExps,\n        Core.NamedPat pat, Core.Exp exp)"}, {"syntax_pass": true, "original_string": "    @Override Core.Let toExp(Core.Exp resultExp) {\n      if (rec) {\n        final List<Core.NonRecValDecl> valDecls = new ArrayList<>();\n        patExps.forEach(x ->\n            valDecls.add(core.nonRecValDecl(x.pos, (Core.IdPat) x.pat, x.exp)));\n        return core.let(core.recValDecl(valDecls), resultExp);\n      }\n      if (!composite && patExps.get(0).pat instanceof Core.IdPat) {\n        final PatExp x = patExps.get(0);\n        Core.NonRecValDecl valDecl =\n            core.nonRecValDecl(x.pos, (Core.IdPat) x.pat, x.exp);\n        return core.let(valDecl, resultExp);\n      } else {\n        // This is a complex pattern. Allocate an intermediate variable.\n        final String name = nameGenerator.get();\n        final Core.IdPat idPat = core.idPat(pat.type, name, nameGenerator);\n        final Core.Id id = core.id(idPat);\n        final Pos pos = patExps.get(0).pos;\n        return core.let(core.nonRecValDecl(pos, idPat, exp),\n            core.caseOf(pos, resultExp.type, id,\n                ImmutableList.of(core.match(pos, pat, resultExp))));\n      }\n    }", "docstring": "", "attributes": {"modifiers": "@Override", "marker_annotations": ["@Override"], "non_marker_annotations": [], "comments": [], "return_type": "Core.Let", "classes": []}, "name": "toExp", "params": [{"name": "resultExp", "type": "Core.Exp"}], "body": "                                                 {\n      if (rec) {\n        final List<Core.NonRecValDecl> valDecls = new ArrayList<>();\n        patExps.forEach(x ->\n            valDecls.add(core.nonRecValDecl(x.pos, (Core.IdPat) x.pat, x.exp)));\n        return core.let(core.recValDecl(valDecls), resultExp);\n      }\n      if (!composite && patExps.get(0).pat instanceof Core.IdPat) {\n        final PatExp x = patExps.get(0);\n        Core.NonRecValDecl valDecl =\n            core.nonRecValDecl(x.pos, (Core.IdPat) x.pat, x.exp);\n        return core.let(valDecl, resultExp);\n      } else {\n        // This is a complex pattern. Allocate an intermediate variable.\n        final String name = nameGenerator.get();\n        final Core.IdPat idPat = core.idPat(pat.type, name, nameGenerator);\n        final Core.Id id = core.id(idPat);\n        final Pos pos = patExps.get(0).pos;\n        return core.let(core.nonRecValDecl(pos, idPat, exp),\n            core.caseOf(pos, resultExp.type, id,\n                ImmutableList.of(core.match(pos, pat, resultExp))));\n      }\n    }", "signature": "@Override Core.Let toExp(Core.Exp resultExp)"}]}, {"original_string": "  static class PatExp {\n    final Core.Pat pat;\n    final Core.Exp exp;\n    final Pos pos;\n\n    PatExp(Core.Pat pat, Core.Exp exp, Pos pos) {\n      this.pat = pat;\n      this.exp = exp;\n      this.pos = pos;\n    }\n\n    @Override public String toString() {\n      return \"[pat: \" + pat + \", exp: \" + exp + \", pos: \" + pos + \"]\";\n    }\n  }", "definition": "  static class PatExp", "class_docstring": " Pattern and expression.", "name": "PatExp", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "fields": [{"attribute_expression": "final Core.Pat pat;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "Core.Pat", "name": "pat", "syntax_pass": true}, {"attribute_expression": "final Core.Exp exp;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "Core.Exp", "name": "exp", "syntax_pass": true}, {"attribute_expression": "final Pos pos;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "Pos", "name": "pos", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    PatExp(Core.Pat pat, Core.Exp exp, Pos pos) {\n      this.pat = pat;\n      this.exp = exp;\n      this.pos = pos;\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "PatExp", "params": [{"name": "pat", "type": "Core.Pat"}, {"name": "exp", "type": "Core.Exp"}, {"name": "pos", "type": "Pos"}], "body": "                                                {\n      this.pat = pat;\n      this.exp = exp;\n      this.pos = pos;\n    }", "signature": "PatExp(Core.Pat pat, Core.Exp exp, Pos pos)"}, {"syntax_pass": true, "original_string": "    @Override public String toString() {\n      return \"[pat: \" + pat + \", exp: \" + exp + \", pos: \" + pos + \"]\";\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "toString", "params": [], "body": "                                       {\n      return \"[pat: \" + pat + \", exp: \" + exp + \", pos: \" + pos + \"]\";\n    }", "signature": "@Override public String toString()"}]}, {"original_string": "  static class ResolvedDatatypeDecl extends ResolvedDecl {\n    private final ImmutableList<DataType> dataTypes;\n\n    ResolvedDatatypeDecl(ImmutableList<DataType> dataTypes) {\n      this.dataTypes = dataTypes;\n    }\n\n    @Override Core.Exp toExp(Core.Exp resultExp) {\n      return toExp(dataTypes, resultExp);\n    }\n\n    private Core.Exp toExp(List<DataType> dataTypes, Core.Exp resultExp) {\n      if (dataTypes.isEmpty()) {\n        return resultExp;\n      } else {\n        return core.local(dataTypes.get(0),\n            toExp(skip(dataTypes), resultExp));\n      }\n    }\n\n    /** Creates a datatype declaration that may have multiple datatypes.\n     *\n     * <p>Only the REPL needs this. Because datatypes are not recursive,\n     * a composite declaration\n     *\n     * <pre>{@code\n     * datatype d1 ... and d2 ...}</pre>\n     *\n     * <p>can always be converted to a chained local,\n     *\n     * <pre>{@code\n     * local datatype d1 ... in local datatype d2 ... end end}</pre>\n     */\n    public Core.DatatypeDecl toDecl() {\n      return core.datatypeDecl(dataTypes);\n    }\n  }", "definition": "  static class ResolvedDatatypeDecl extends ResolvedDecl", "class_docstring": " Resolved datatype declaration.", "name": "ResolvedDatatypeDecl", "super_interfaces": [], "superclasses": "ResolvedDecl", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "fields": [{"attribute_expression": "private final ImmutableList<DataType> dataTypes;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "ImmutableList<DataType>", "name": "dataTypes", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    ResolvedDatatypeDecl(ImmutableList<DataType> dataTypes) {\n      this.dataTypes = dataTypes;\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "ResolvedDatatypeDecl", "params": [{"name": "dataTypes", "type": "ImmutableList<DataType>"}], "body": "                                                            {\n      this.dataTypes = dataTypes;\n    }", "signature": "ResolvedDatatypeDecl(ImmutableList<DataType> dataTypes)"}, {"syntax_pass": true, "original_string": "    @Override Core.Exp toExp(Core.Exp resultExp) {\n      return toExp(dataTypes, resultExp);\n    }", "docstring": "", "attributes": {"modifiers": "@Override", "marker_annotations": ["@Override"], "non_marker_annotations": [], "comments": [], "return_type": "Core.Exp", "classes": []}, "name": "toExp", "params": [{"name": "resultExp", "type": "Core.Exp"}], "body": "                                                 {\n      return toExp(dataTypes, resultExp);\n    }", "signature": "@Override Core.Exp toExp(Core.Exp resultExp)"}, {"syntax_pass": true, "original_string": "    private Core.Exp toExp(List<DataType> dataTypes, Core.Exp resultExp) {\n      if (dataTypes.isEmpty()) {\n        return resultExp;\n      } else {\n        return core.local(dataTypes.get(0),\n            toExp(skip(dataTypes), resultExp));\n      }\n    }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "Core.Exp", "classes": []}, "name": "toExp", "params": [{"name": "dataTypes", "type": "List<DataType>"}, {"name": "resultExp", "type": "Core.Exp"}], "body": "                                                                         {\n      if (dataTypes.isEmpty()) {\n        return resultExp;\n      } else {\n        return core.local(dataTypes.get(0),\n            toExp(skip(dataTypes), resultExp));\n      }\n    }", "signature": "private Core.Exp toExp(List<DataType> dataTypes, Core.Exp resultExp)"}, {"syntax_pass": true, "original_string": "    public Core.DatatypeDecl toDecl() {\n      return core.datatypeDecl(dataTypes);\n    }", "docstring": " Creates a datatype declaration that may have multiple datatypes.\n\n<p>Only the REPL needs this. Because datatypes are not recursive,\na composite declaration\n\n<pre>{@code\ndatatype d1 ... and d2 ...}</pre>\n\n<p>can always be converted to a chained local,\n\n<pre>{@code\nlocal datatype d1 ... in local datatype d2 ... end end}</pre>\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Core.DatatypeDecl", "classes": []}, "name": "toDecl", "params": [], "body": "                                      {\n      return core.datatypeDecl(dataTypes);\n    }", "signature": "public Core.DatatypeDecl toDecl()"}]}, {"original_string": "  private class FromResolver extends Visitor {\n    final FromBuilder fromBuilder = core.fromBuilder(typeMap.typeSystem, env);\n\n    Core.Exp run(Ast.From from) {\n      if (from.isInto()) {\n        // Translate \"from ... into f\" as if they had written \"f (from ...)\"\n        final Core.Exp coreFrom = run(skipLast(from.steps));\n        final Ast.Into into = (Ast.Into) last(from.steps);\n        final Core.Exp exp = toCore(into.exp);\n        return core.apply(exp.pos, typeMap.getType(from), exp, coreFrom);\n      }\n\n      final Core.Exp coreFrom = run(from.steps);\n      if (from.isCompute()) {\n        return core.only(typeMap.typeSystem, from.pos, coreFrom);\n      } else {\n        return coreFrom;\n      }\n    }\n\n    private Core.Exp run(List<Ast.FromStep> steps) {\n      steps.forEach(this::accept);\n      return fromBuilder.buildSimplify();\n    }\n\n    @Override protected void visit(Ast.From from) {\n      // Do not traverse into the sub-\"from\".\n    }\n\n    @Override protected void visit(Ast.Scan scan) {\n      final Resolver r = withEnv(fromBuilder.bindings());\n      final Core.Exp coreExp;\n      final Core.Pat corePat;\n      if (scan.exp == null) {\n        corePat = r.toCore(scan.pat);\n        coreExp =\n            core.extent(typeMap.typeSystem, corePat.type,\n                ImmutableRangeSet.of(Range.all()));\n      } else {\n        coreExp = r.toCore(scan.exp);\n        final ListType listType = (ListType) coreExp.type;\n        corePat = r.toCore(scan.pat, listType.elementType);\n      }\n      final List<Binding> bindings2 = new ArrayList<>(fromBuilder.bindings());\n      Compiles.acceptBinding(typeMap.typeSystem, corePat, bindings2);\n      Core.Exp coreCondition = scan.condition == null\n          ? core.boolLiteral(true)\n          : r.withEnv(bindings2).toCore(scan.condition);\n      fromBuilder.scan(corePat, coreExp, coreCondition);\n    }\n\n    @Override protected void visit(Ast.Where where) {\n      final Resolver r = withEnv(fromBuilder.bindings());\n      fromBuilder.where(r.toCore(where.exp));\n    }\n\n    @Override protected void visit(Ast.Skip skip) {\n      final Resolver r = withEnv(env); // do not use 'from' bindings\n      fromBuilder.skip(r.toCore(skip.exp));\n    }\n\n    @Override protected void visit(Ast.Take take) {\n      final Resolver r = withEnv(env); // do not use 'from' bindings\n      fromBuilder.take(r.toCore(take.exp));\n    }\n\n    @Override protected void visit(Ast.Yield yield) {\n      final Resolver r = withEnv(fromBuilder.bindings());\n      fromBuilder.yield_(r.toCore(yield.exp));\n    }\n\n    @Override protected void visit(Ast.Order order) {\n      final Resolver r = withEnv(fromBuilder.bindings());\n      fromBuilder.order(transformEager(order.orderItems, r::toCore));\n    }\n\n    @Override protected void visit(Ast.Through through) {\n      // Translate \"from ... through p in f\"\n      // as if they wrote \"from p in f (from ...)\"\n      final Core.From from = fromBuilder.build();\n      fromBuilder.clear();\n      final Core.Exp exp = toCore(through.exp);\n      final Core.Pat pat = toCore(through.pat);\n      final Type type = typeMap.typeSystem.listType(pat.type);\n      fromBuilder.scan(pat, core.apply(through.pos, type, exp, from));\n    }\n\n    @Override protected void visit(Ast.Compute compute) {\n      visit((Ast.Group) compute);\n    }\n\n    @Override protected void visit(Ast.Group group) {\n      final Resolver r = withEnv(fromBuilder.bindings());\n      final ImmutableSortedMap.Builder<Core.IdPat, Core.Exp> groupExpsB =\n          ImmutableSortedMap.naturalOrder();\n      final ImmutableSortedMap.Builder<Core.IdPat, Core.Aggregate> aggregates =\n          ImmutableSortedMap.naturalOrder();\n      forEach(group.groupExps, (id, exp) ->\n          groupExpsB.put(toCorePat(id), r.toCore(exp)));\n      final SortedMap<Core.IdPat, Core.Exp> groupExps = groupExpsB.build();\n      group.aggregates.forEach(aggregate ->\n          aggregates.put(toCorePat(aggregate.id),\n              r.toCore(aggregate, groupExps.keySet())));\n      fromBuilder.group(groupExps, aggregates.build());\n    }\n  }", "definition": "  private class FromResolver extends Visitor", "class_docstring": " Visitor that converts {@link Ast.From} to {@link Core.From} by\nhandling each subtype of {@link Ast.FromStep} calling\n{@link FromBuilder} appropriately.", "name": "FromResolver", "super_interfaces": [], "superclasses": "Visitor", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "fields": [{"attribute_expression": "final FromBuilder fromBuilder = core.fromBuilder(typeMap.typeSystem, env);", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "FromBuilder", "name": "fromBuilder = core.fromBuilder(typeMap.typeSystem, env)", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    Core.Exp run(Ast.From from) {\n      if (from.isInto()) {\n        // Translate \"from ... into f\" as if they had written \"f (from ...)\"\n        final Core.Exp coreFrom = run(skipLast(from.steps));\n        final Ast.Into into = (Ast.Into) last(from.steps);\n        final Core.Exp exp = toCore(into.exp);\n        return core.apply(exp.pos, typeMap.getType(from), exp, coreFrom);\n      }\n\n      final Core.Exp coreFrom = run(from.steps);\n      if (from.isCompute()) {\n        return core.only(typeMap.typeSystem, from.pos, coreFrom);\n      } else {\n        return coreFrom;\n      }\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "Core.Exp", "classes": []}, "name": "run", "params": [{"name": "from", "type": "Ast.From"}], "body": "                                {\n      if (from.isInto()) {\n        // Translate \"from ... into f\" as if they had written \"f (from ...)\"\n        final Core.Exp coreFrom = run(skipLast(from.steps));\n        final Ast.Into into = (Ast.Into) last(from.steps);\n        final Core.Exp exp = toCore(into.exp);\n        return core.apply(exp.pos, typeMap.getType(from), exp, coreFrom);\n      }\n\n      final Core.Exp coreFrom = run(from.steps);\n      if (from.isCompute()) {\n        return core.only(typeMap.typeSystem, from.pos, coreFrom);\n      } else {\n        return coreFrom;\n      }\n    }", "signature": "Core.Exp run(Ast.From from)"}, {"syntax_pass": true, "original_string": "    private Core.Exp run(List<Ast.FromStep> steps) {\n      steps.forEach(this::accept);\n      return fromBuilder.buildSimplify();\n    }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "Core.Exp", "classes": []}, "name": "run", "params": [{"name": "steps", "type": "List<Ast.FromStep>"}], "body": "                                                   {\n      steps.forEach(this::accept);\n      return fromBuilder.buildSimplify();\n    }", "signature": "private Core.Exp run(List<Ast.FromStep> steps)"}, {"syntax_pass": true, "original_string": "    @Override protected void visit(Ast.From from) {\n      // Do not traverse into the sub-\"from\".\n    }", "docstring": "", "attributes": {"modifiers": "@Override protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "name": "visit", "params": [{"name": "from", "type": "Ast.From"}], "body": "                                                  {\n      // Do not traverse into the sub-\"from\".\n    }", "signature": "@Override protected void visit(Ast.From from)"}, {"syntax_pass": true, "original_string": "    @Override protected void visit(Ast.Scan scan) {\n      final Resolver r = withEnv(fromBuilder.bindings());\n      final Core.Exp coreExp;\n      final Core.Pat corePat;\n      if (scan.exp == null) {\n        corePat = r.toCore(scan.pat);\n        coreExp =\n            core.extent(typeMap.typeSystem, corePat.type,\n                ImmutableRangeSet.of(Range.all()));\n      } else {\n        coreExp = r.toCore(scan.exp);\n        final ListType listType = (ListType) coreExp.type;\n        corePat = r.toCore(scan.pat, listType.elementType);\n      }\n      final List<Binding> bindings2 = new ArrayList<>(fromBuilder.bindings());\n      Compiles.acceptBinding(typeMap.typeSystem, corePat, bindings2);\n      Core.Exp coreCondition = scan.condition == null\n          ? core.boolLiteral(true)\n          : r.withEnv(bindings2).toCore(scan.condition);\n      fromBuilder.scan(corePat, coreExp, coreCondition);\n    }", "docstring": "", "attributes": {"modifiers": "@Override protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "name": "visit", "params": [{"name": "scan", "type": "Ast.Scan"}], "body": "                                                  {\n      final Resolver r = withEnv(fromBuilder.bindings());\n      final Core.Exp coreExp;\n      final Core.Pat corePat;\n      if (scan.exp == null) {\n        corePat = r.toCore(scan.pat);\n        coreExp =\n            core.extent(typeMap.typeSystem, corePat.type,\n                ImmutableRangeSet.of(Range.all()));\n      } else {\n        coreExp = r.toCore(scan.exp);\n        final ListType listType = (ListType) coreExp.type;\n        corePat = r.toCore(scan.pat, listType.elementType);\n      }\n      final List<Binding> bindings2 = new ArrayList<>(fromBuilder.bindings());\n      Compiles.acceptBinding(typeMap.typeSystem, corePat, bindings2);\n      Core.Exp coreCondition = scan.condition == null\n          ? core.boolLiteral(true)\n          : r.withEnv(bindings2).toCore(scan.condition);\n      fromBuilder.scan(corePat, coreExp, coreCondition);\n    }", "signature": "@Override protected void visit(Ast.Scan scan)"}, {"syntax_pass": true, "original_string": "    @Override protected void visit(Ast.Where where) {\n      final Resolver r = withEnv(fromBuilder.bindings());\n      fromBuilder.where(r.toCore(where.exp));\n    }", "docstring": "", "attributes": {"modifiers": "@Override protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "name": "visit", "params": [{"name": "where", "type": "Ast.Where"}], "body": "                                                    {\n      final Resolver r = withEnv(fromBuilder.bindings());\n      fromBuilder.where(r.toCore(where.exp));\n    }", "signature": "@Override protected void visit(Ast.Where where)"}, {"syntax_pass": true, "original_string": "    @Override protected void visit(Ast.Skip skip) {\n      final Resolver r = withEnv(env); // do not use 'from' bindings\n      fromBuilder.skip(r.toCore(skip.exp));\n    }", "docstring": "", "attributes": {"modifiers": "@Override protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "name": "visit", "params": [{"name": "skip", "type": "Ast.Skip"}], "body": "                                                  {\n      final Resolver r = withEnv(env); // do not use 'from' bindings\n      fromBuilder.skip(r.toCore(skip.exp));\n    }", "signature": "@Override protected void visit(Ast.Skip skip)"}, {"syntax_pass": true, "original_string": "    @Override protected void visit(Ast.Take take) {\n      final Resolver r = withEnv(env); // do not use 'from' bindings\n      fromBuilder.take(r.toCore(take.exp));\n    }", "docstring": "", "attributes": {"modifiers": "@Override protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "name": "visit", "params": [{"name": "take", "type": "Ast.Take"}], "body": "                                                  {\n      final Resolver r = withEnv(env); // do not use 'from' bindings\n      fromBuilder.take(r.toCore(take.exp));\n    }", "signature": "@Override protected void visit(Ast.Take take)"}, {"syntax_pass": true, "original_string": "    @Override protected void visit(Ast.Yield yield) {\n      final Resolver r = withEnv(fromBuilder.bindings());\n      fromBuilder.yield_(r.toCore(yield.exp));\n    }", "docstring": "", "attributes": {"modifiers": "@Override protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "name": "visit", "params": [{"name": "yield", "type": "Ast.Yield"}], "body": "                                                    {\n      final Resolver r = withEnv(fromBuilder.bindings());\n      fromBuilder.yield_(r.toCore(yield.exp));\n    }", "signature": "@Override protected void visit(Ast.Yield yield)"}, {"syntax_pass": true, "original_string": "    @Override protected void visit(Ast.Order order) {\n      final Resolver r = withEnv(fromBuilder.bindings());\n      fromBuilder.order(transformEager(order.orderItems, r::toCore));\n    }", "docstring": "", "attributes": {"modifiers": "@Override protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "name": "visit", "params": [{"name": "order", "type": "Ast.Order"}], "body": "                                                    {\n      final Resolver r = withEnv(fromBuilder.bindings());\n      fromBuilder.order(transformEager(order.orderItems, r::toCore));\n    }", "signature": "@Override protected void visit(Ast.Order order)"}, {"syntax_pass": true, "original_string": "    @Override protected void visit(Ast.Through through) {\n      // Translate \"from ... through p in f\"\n      // as if they wrote \"from p in f (from ...)\"\n      final Core.From from = fromBuilder.build();\n      fromBuilder.clear();\n      final Core.Exp exp = toCore(through.exp);\n      final Core.Pat pat = toCore(through.pat);\n      final Type type = typeMap.typeSystem.listType(pat.type);\n      fromBuilder.scan(pat, core.apply(through.pos, type, exp, from));\n    }", "docstring": "", "attributes": {"modifiers": "@Override protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "name": "visit", "params": [{"name": "through", "type": "Ast.Through"}], "body": "                                                        {\n      // Translate \"from ... through p in f\"\n      // as if they wrote \"from p in f (from ...)\"\n      final Core.From from = fromBuilder.build();\n      fromBuilder.clear();\n      final Core.Exp exp = toCore(through.exp);\n      final Core.Pat pat = toCore(through.pat);\n      final Type type = typeMap.typeSystem.listType(pat.type);\n      fromBuilder.scan(pat, core.apply(through.pos, type, exp, from));\n    }", "signature": "@Override protected void visit(Ast.Through through)"}, {"syntax_pass": true, "original_string": "    @Override protected void visit(Ast.Compute compute) {\n      visit((Ast.Group) compute);\n    }", "docstring": "", "attributes": {"modifiers": "@Override protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "name": "visit", "params": [{"name": "compute", "type": "Ast.Compute"}], "body": "                                                        {\n      visit((Ast.Group) compute);\n    }", "signature": "@Override protected void visit(Ast.Compute compute)"}, {"syntax_pass": true, "original_string": "    @Override protected void visit(Ast.Group group) {\n      final Resolver r = withEnv(fromBuilder.bindings());\n      final ImmutableSortedMap.Builder<Core.IdPat, Core.Exp> groupExpsB =\n          ImmutableSortedMap.naturalOrder();\n      final ImmutableSortedMap.Builder<Core.IdPat, Core.Aggregate> aggregates =\n          ImmutableSortedMap.naturalOrder();\n      forEach(group.groupExps, (id, exp) ->\n          groupExpsB.put(toCorePat(id), r.toCore(exp)));\n      final SortedMap<Core.IdPat, Core.Exp> groupExps = groupExpsB.build();\n      group.aggregates.forEach(aggregate ->\n          aggregates.put(toCorePat(aggregate.id),\n              r.toCore(aggregate, groupExps.keySet())));\n      fromBuilder.group(groupExps, aggregates.build());\n    }", "docstring": "", "attributes": {"modifiers": "@Override protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "name": "visit", "params": [{"name": "group", "type": "Ast.Group"}], "body": "                                                    {\n      final Resolver r = withEnv(fromBuilder.bindings());\n      final ImmutableSortedMap.Builder<Core.IdPat, Core.Exp> groupExpsB =\n          ImmutableSortedMap.naturalOrder();\n      final ImmutableSortedMap.Builder<Core.IdPat, Core.Aggregate> aggregates =\n          ImmutableSortedMap.naturalOrder();\n      forEach(group.groupExps, (id, exp) ->\n          groupExpsB.put(toCorePat(id), r.toCore(exp)));\n      final SortedMap<Core.IdPat, Core.Exp> groupExps = groupExpsB.build();\n      group.aggregates.forEach(aggregate ->\n          aggregates.put(toCorePat(aggregate.id),\n              r.toCore(aggregate, groupExps.keySet())));\n      fromBuilder.group(groupExps, aggregates.build());\n    }", "signature": "@Override protected void visit(Ast.Group group)"}]}], "class_docstring": " Converts AST expressions to Core expressions.", "original_string": "public class Resolver {\n  /** Map from {@link Op} to {@link BuiltIn}. */\n  public static final ImmutableMap<Op, BuiltIn> OP_BUILT_IN_MAP =\n      Init.INSTANCE.opBuiltInMap;\n\n  /** Map from {@link BuiltIn}, to {@link Op};\n   * the reverse of {@link #OP_BUILT_IN_MAP}, and needed when we convert\n   * an optimized expression back to human-readable Morel code. */\n  public static final ImmutableMap<BuiltIn, Op> BUILT_IN_OP_MAP =\n      Init.INSTANCE.builtInOpMap;\n\n  final TypeMap typeMap;\n  private final NameGenerator nameGenerator;\n  private final Environment env;\n  private final @Nullable Session session;\n\n  /** Contains variable declarations whose type at the point they are used is\n   * different (more specific) than in their declaration.\n   *\n   * <p>For example, the infix operator \"op +\" has type\n   * \"&alpha; * &alpha; &rarr;\" in the base environment, but at point of use\n   * might instead be \"int * int &rarr; int\". This map will contain a new\n   * {@link Core.IdPat} for all points that use it with that second type.\n   * Effectively, it is a phantom declaration, in a {@code let} that doesn't\n   * exist. Without this shared declaration, all points have their own distinct\n   * {@link Core.IdPat}, which the {@link Analyzer} will think is used just\n   * once.\n   */\n  private final Map<Pair<Core.NamedPat, Type>, Core.NamedPat> variantIdMap;\n\n  private Resolver(TypeMap typeMap, NameGenerator nameGenerator,\n      Map<Pair<Core.NamedPat, Type>, Core.NamedPat> variantIdMap,\n      Environment env, @Nullable Session session) {\n    this.typeMap = typeMap;\n    this.nameGenerator = nameGenerator;\n    this.variantIdMap = variantIdMap;\n    this.env = env;\n    this.session = session;\n  }\n\n  /** Creates a root Resolver. */\n  public static Resolver of(TypeMap typeMap, Environment env,\n      @Nullable Session session) {\n    return new Resolver(typeMap, new NameGenerator(), new HashMap<>(), env,\n        session);\n  }\n\n  /** Binds a Resolver to a new environment. */\n  public Resolver withEnv(Environment env) {\n    return env == this.env ? this\n        : new Resolver(typeMap, nameGenerator, variantIdMap, env, session);\n  }\n\n  /** Binds a Resolver to an environment that consists of the current\n   * environment plus some bindings. */\n  public final Resolver withEnv(Iterable<Binding> bindings) {\n    return withEnv(Environments.bind(env, bindings));\n  }\n\n  public Core.Decl toCore(Ast.Decl node) {\n    switch (node.op) {\n    case VAL_DECL:\n      return toCore((Ast.ValDecl) node);\n\n    case DATATYPE_DECL:\n      return toCore((Ast.DatatypeDecl) node);\n\n    default:\n      throw new AssertionError(\"unknown decl [\" + node.op + \", \" + node + \"]\");\n    }\n  }\n\n  /** Converts a simple {@link net.hydromatic.morel.ast.Ast.ValDecl},\n   * of the form {@code val v = e},\n   * to a Core {@link net.hydromatic.morel.ast.Core.ValDecl}.\n   *\n   * <p>Declarations such as {@code val (x, y) = (1, 2)}\n   * and {@code val emp :: rest = emps} are considered complex,\n   * and are not handled by this method.\n   *\n   * <p>Likewise recursive declarations. */\n  public Core.ValDecl toCore(Ast.ValDecl valDecl) {\n    final List<Binding> bindings = new ArrayList<>(); // discard\n    final ResolvedValDecl resolvedValDecl = resolveValDecl(valDecl, bindings);\n    Core.NonRecValDecl nonRecValDecl =\n        core.nonRecValDecl(resolvedValDecl.patExps.get(0).pos,\n            resolvedValDecl.pat, resolvedValDecl.exp);\n    return resolvedValDecl.rec\n        ? core.recValDecl(ImmutableList.of(nonRecValDecl))\n        : nonRecValDecl;\n  }\n\n  public Core.DatatypeDecl toCore(Ast.DatatypeDecl datatypeDecl) {\n    final List<Binding> bindings = new ArrayList<>(); // populated, never read\n    final ResolvedDatatypeDecl resolvedDatatypeDecl =\n        resolveDatatypeDecl(datatypeDecl, bindings);\n    return resolvedDatatypeDecl.toDecl();\n  }\n\n  private ResolvedDecl resolve(Ast.Decl decl, List<Binding> bindings) {\n    if (decl instanceof Ast.DatatypeDecl) {\n      return resolveDatatypeDecl((Ast.DatatypeDecl) decl, bindings);\n    } else {\n      return resolveValDecl((Ast.ValDecl) decl, bindings);\n    }\n  }\n\n  private ResolvedDatatypeDecl resolveDatatypeDecl(Ast.DatatypeDecl decl,\n      List<Binding> bindings) {\n    final List<DataType> dataTypes = new ArrayList<>();\n    for (Ast.DatatypeBind bind : decl.binds) {\n      final DataType dataType = toCore(bind);\n      dataTypes.add(dataType);\n      dataType.typeConstructors.keySet().forEach(name ->\n          bindings.add(typeMap.typeSystem.bindTyCon(dataType, name)));\n    }\n    return new ResolvedDatatypeDecl(ImmutableList.copyOf(dataTypes));\n  }\n\n  private ResolvedValDecl resolveValDecl(Ast.ValDecl valDecl,\n      List<Binding> bindings) {\n    final boolean composite = valDecl.valBinds.size() > 1;\n    final Map<Ast.Pat, Ast.Exp> matches = new LinkedHashMap<>();\n    valDecl.valBinds.forEach(valBind ->\n        flatten(matches, composite, valBind.pat, valBind.exp));\n\n    final List<PatExp> patExps = new ArrayList<>();\n    if (valDecl.rec) {\n      final List<Core.Pat> pats = new ArrayList<>();\n      matches.forEach((pat, exp) -> pats.add(toCore(pat)));\n      pats.forEach(p -> Compiles.acceptBinding(typeMap.typeSystem, p, bindings));\n      final Resolver r = withEnv(bindings);\n      final Iterator<Core.Pat> patIter = pats.iterator();\n      matches.forEach((pat, exp) ->\n          patExps.add(\n              new PatExp(patIter.next(), r.toCore(exp),\n                  pat.pos.plus(exp.pos))));\n    } else {\n      matches.forEach((pat, exp) ->\n          patExps.add(\n              new PatExp(toCore(pat), toCore(exp), pat.pos.plus(exp.pos))));\n      patExps.forEach(x ->\n          Compiles.acceptBinding(typeMap.typeSystem, x.pat, bindings));\n    }\n\n    // Convert recursive to non-recursive if the bound variable is not\n    // referenced in its definition. For example,\n    //   val rec inc = fn i => i + 1\n    // can be converted to\n    //   val inc = fn i => i + 1\n    // because \"i + 1\" does not reference \"inc\".\n    boolean rec = valDecl.rec\n        && references(patExps);\n    // Transform \"let val v1 = E1 and v2 = E2 in E end\"\n    // to \"let val v = (v1, v2) in case v of (E1, E2) => E end\"\n    final Core.Pat pat0;\n    final Core.Exp exp;\n    if (composite) {\n      final List<Core.Pat> pats = transform(patExps, x -> x.pat);\n      final List<Core.Exp> exps = transform(patExps, x -> x.exp);\n      pat0 = core.tuplePat(typeMap.typeSystem, pats);\n      exp = core.tuple((RecordLikeType) pat0.type, exps);\n    } else {\n      final PatExp patExp = patExps.get(0);\n      pat0 = patExp.pat;\n      exp = patExp.exp;\n    }\n    final Core.NamedPat pat;\n    if (pat0 instanceof Core.NamedPat) {\n      pat = (Core.NamedPat) pat0;\n    } else {\n      pat = core.asPat(exp.type, \"it\", nameGenerator, pat0);\n    }\n\n    return new ResolvedValDecl(rec, ImmutableList.copyOf(patExps), pat, exp);\n  }\n\n  /** Returns whether any of the expressions in {@code exps} references\n   * and of the variables defined in {@code pats}.\n   *\n   * <p>This method is used to decide whether it is safe to convert a recursive\n   * declaration into a non-recursive one. */\n  private boolean references(List<PatExp> patExps) {\n    final Set<Core.NamedPat> refSet = new HashSet<>();\n    final ReferenceFinder finder =\n        new ReferenceFinder(typeMap.typeSystem, Environments.empty(), refSet,\n            new ArrayDeque<>());\n    patExps.forEach(x -> x.exp.accept(finder));\n\n    final Set<Core.NamedPat> defSet = new HashSet<>();\n    final Visitor v = new Visitor() {\n      @Override protected void visit(Core.IdPat idPat) {\n        defSet.add(idPat);\n      }\n    };\n    patExps.forEach(x -> x.pat.accept(v));\n\n    return intersects(refSet, defSet);\n  }\n\n  private DataType toCore(Ast.DatatypeBind bind) {\n    final Type type = typeMap.typeSystem.lookup(bind.name.name);\n    return type instanceof ForallType\n        ? (DataType) ((ForallType) type).type\n        : (DataType) type;\n  }\n\n  /** Visitor that finds all references to unbound variables in an expression. */\n  static class ReferenceFinder extends EnvVisitor {\n    final Set<Core.NamedPat> set;\n\n    protected ReferenceFinder(TypeSystem typeSystem, Environment env,\n        Set<Core.NamedPat> set, Deque<FromContext> fromStack) {\n      super(typeSystem, env, fromStack);\n      this.set = set;\n    }\n\n    @Override protected ReferenceFinder push(Environment env) {\n      return new ReferenceFinder(typeSystem, env, set, fromStack);\n    }\n\n    @Override protected void visit(Core.Id id) {\n      if (env.getOpt(id.idPat) == null) {\n        set.add(id.idPat);\n      }\n      super.visit(id);\n    }\n  }\n\n  private Core.Exp toCore(Ast.Exp exp) {\n    switch (exp.op) {\n    case BOOL_LITERAL:\n      return core.boolLiteral((Boolean) ((Ast.Literal) exp).value);\n    case CHAR_LITERAL:\n      return core.charLiteral((Character) ((Ast.Literal) exp).value);\n    case INT_LITERAL:\n      return core.intLiteral((BigDecimal) ((Ast.Literal) exp).value);\n    case REAL_LITERAL:\n      return ((Ast.Literal) exp).value instanceof BigDecimal\n          ? core.realLiteral((BigDecimal) ((Ast.Literal) exp).value)\n          : core.realLiteral((Float) ((Ast.Literal) exp).value);\n    case STRING_LITERAL:\n      return core.stringLiteral((String) ((Ast.Literal) exp).value);\n    case UNIT_LITERAL:\n      return core.unitLiteral();\n    case ANNOTATED_EXP:\n      return toCore(((Ast.AnnotatedExp) exp).exp);\n    case ID:\n      return toCore((Ast.Id) exp);\n    case ANDALSO:\n    case ORELSE:\n      return toCore((Ast.InfixCall) exp);\n    case APPLY:\n      return toCore((Ast.Apply) exp);\n    case FN:\n      return toCore((Ast.Fn) exp);\n    case IF:\n      return toCore((Ast.If) exp);\n    case CASE:\n      return toCore((Ast.Case) exp);\n    case LET:\n      return toCore((Ast.Let) exp);\n    case FROM:\n      return toCore((Ast.From) exp);\n    case TUPLE:\n      return toCore((Ast.Tuple) exp);\n    case RECORD:\n      return toCore((Ast.Record) exp);\n    case RECORD_SELECTOR:\n      return toCore((Ast.RecordSelector) exp);\n    case LIST:\n      return toCore((Ast.ListExp) exp);\n    case FROM_EQ:\n      return toCoreFromEq(((Ast.PrefixCall) exp).a);\n    default:\n      throw new AssertionError(\"unknown exp \" + exp.op);\n    }\n  }\n\n  private Core.Id toCore(Ast.Id id) {\n    final Binding binding = env.getOpt(id.name);\n    checkNotNull(binding, \"not found\", id);\n    final Core.NamedPat idPat = getIdPat(id, binding);\n    return core.id(idPat);\n  }\n\n  /** Converts an id in a declaration to Core. */\n  private Core.IdPat toCorePat(Ast.Id id) {\n    final Type type = typeMap.getType(id);\n    return core.idPat(type, id.name, nameGenerator);\n  }\n\n  /** Converts an Id that is a reference to a variable into an IdPat that\n   * represents its declaration. */\n  private Core.NamedPat getIdPat(Ast.Id id, Binding binding) {\n    final Type type = typeMap.getType(id);\n    if (type == binding.id.type) {\n      return binding.id;\n    }\n    // The required type is different from the binding type, presumably more\n    // specific. Create a new IdPat, reusing an existing IdPat if there was\n    // one for the same type.\n    return variantIdMap.computeIfAbsent(Pair.of(binding.id, type),\n        k -> k.left.withType(k.right));\n  }\n\n  private Core.Tuple toCore(Ast.Tuple tuple) {\n    return core.tuple((RecordLikeType) typeMap.getType(tuple),\n        transformEager(tuple.args, this::toCore));\n  }\n\n  private Core.Tuple toCore(Ast.Record record) {\n    return core.tuple((RecordLikeType) typeMap.getType(record),\n        transformEager(record.args(), this::toCore));\n  }\n\n  private Core.Exp toCore(Ast.ListExp list) {\n    final ListType type = (ListType) typeMap.getType(list);\n    return core.apply(list.pos, type,\n        core.functionLiteral(typeMap.typeSystem, BuiltIn.Z_LIST),\n        core.tuple(typeMap.typeSystem, null,\n            transformEager(list.args, this::toCore)));\n  }\n\n  /** Translates \"x\" in \"from e = x\". Desugar to the same as if they had\n   * written \"from e in [x]\". */\n  private Core.Exp toCoreFromEq(Ast.Exp exp) {\n    final Type type = typeMap.getType(exp);\n    final ListType listType = typeMap.typeSystem.listType(type);\n    return core.apply(exp.pos, listType,\n        core.functionLiteral(typeMap.typeSystem, BuiltIn.Z_LIST),\n        core.tuple(typeMap.typeSystem, toCore(exp)));\n  }\n\n  private Core.Apply toCore(Ast.Apply apply) {\n    Core.Exp coreArg = toCore(apply.arg);\n    Type type = typeMap.getType(apply);\n    Core.Exp coreFn;\n    if (apply.fn.op == Op.RECORD_SELECTOR) {\n      final Ast.RecordSelector recordSelector = (Ast.RecordSelector) apply.fn;\n      RecordLikeType recordType = (RecordLikeType) coreArg.type;\n      if (coreArg.type.isProgressive()) {\n        Object o = valueOf(env, coreArg);\n        if (o instanceof TypedValue) {\n          final TypedValue typedValue = (TypedValue) o;\n          TypedValue typedValue2 =\n              typedValue.discoverField(typeMap.typeSystem, recordSelector.name);\n          recordType =\n              (RecordLikeType) typedValue2.typeKey().toType(typeMap.typeSystem);\n        }\n      }\n      coreFn =\n          core.recordSelector(typeMap.typeSystem, recordType,\n              recordSelector.name);\n      if (type.op() == Op.TY_VAR\n              && coreFn.type.op() == Op.FUNCTION_TYPE\n          || type.isProgressive()\n          || type instanceof ListType\n              && ((ListType) type).elementType.isProgressive()) {\n        // If we are dereferencing a field in a progressive type, the type\n        // available now may be more precise than the deduced type.\n        type = ((FnType) coreFn.type).resultType;\n      }\n    } else {\n      coreFn = toCore(apply.fn);\n    }\n    return core.apply(apply.pos, type, coreFn, coreArg);\n  }\n\n  static Object valueOf(Environment env, Core.Exp exp) {\n    if (exp instanceof Core.Literal) {\n      return ((Core.Literal) exp).value;\n    }\n    if (exp.op == Op.ID) {\n      final Core.Id id = (Core.Id) exp;\n      Binding binding = env.getOpt(id.idPat);\n      if (binding != null) {\n        return binding.value;\n      }\n    }\n    if (exp.op == Op.APPLY) {\n      final Core.Apply apply = (Core.Apply) exp;\n      if (apply.fn.op == Op.RECORD_SELECTOR) {\n        final Core.RecordSelector recordSelector =\n            (Core.RecordSelector) apply.fn;\n        final Object o = valueOf(env, apply.arg);\n        if (o instanceof TypedValue) {\n          return ((TypedValue) o).fieldValueAs(recordSelector.slot,\n              Object.class);\n        } else if (o instanceof List) {\n          @SuppressWarnings(\"unchecked\") List<Object> list = (List<Object>) o;\n          return list.get(recordSelector.slot);\n        }\n      }\n    }\n    return null; // not constant\n  }\n\n  private Core.RecordSelector toCore(Ast.RecordSelector recordSelector) {\n    final FnType fnType = (FnType) typeMap.getType(recordSelector);\n    return core.recordSelector(typeMap.typeSystem,\n        (RecordLikeType) fnType.paramType, recordSelector.name);\n  }\n\n  private Core.Apply toCore(Ast.InfixCall call) {\n    Core.Exp core0 = toCore(call.a0);\n    Core.Exp core1 = toCore(call.a1);\n    final BuiltIn builtIn = toBuiltIn(call.op);\n    return core.apply(call.pos, typeMap.getType(call),\n        core.functionLiteral(typeMap.typeSystem, builtIn),\n        core.tuple(typeMap.typeSystem, core0, core1));\n  }\n\n  private BuiltIn toBuiltIn(Op op) {\n    return OP_BUILT_IN_MAP.get(op);\n  }\n\n  private Core.Fn toCore(Ast.Fn fn) {\n    final FnType type = (FnType) typeMap.getType(fn);\n    final List<Core.Match> matchList = transformEager(fn.matchList, this::toCore);\n    return core.fn(fn.pos, type, matchList, nameGenerator);\n  }\n\n  private Core.Case toCore(Ast.If if_) {\n    return core.ifThenElse(toCore(if_.condition), toCore(if_.ifTrue),\n        toCore(if_.ifFalse));\n  }\n\n  private Core.Case toCore(Ast.Case case_) {\n    return core.caseOf(case_.pos, typeMap.getType(case_), toCore(case_.exp),\n        transformEager(case_.matchList, this::toCore));\n  }\n\n  private Core.Exp toCore(Ast.Let let) {\n    return flattenLet(let.decls, let.exp);\n  }\n\n  private Core.Exp flattenLet(List<Ast.Decl> decls, Ast.Exp exp) {\n    //   flattenLet(val x :: xs = [1, 2, 3] and (y, z) = (2, 4), x + y)\n    // becomes\n    //   let v = ([1, 2, 3], (2, 4)) in case v of (x :: xs, (y, z)) => x + y end\n    if (decls.isEmpty()) {\n      return toCore(exp);\n    }\n    final Ast.Decl decl = decls.get(0);\n    final List<Binding> bindings = new ArrayList<>();\n    final ResolvedDecl resolvedDecl = resolve(decl, bindings);\n    final Core.Exp e2 = withEnv(bindings).flattenLet(skip(decls), exp);\n    return resolvedDecl.toExp(e2);\n  }\n\n  static void flatten(Map<Ast.Pat, Ast.Exp> matches, boolean flatten,\n      Ast.Pat pat, Ast.Exp exp) {\n    if (flatten && pat.op == Op.TUPLE_PAT && exp.op == Op.TUPLE) {\n      forEach(((Ast.TuplePat) pat).args, ((Ast.Tuple) exp).args,\n          (p, e) -> flatten(matches, true, p, e));\n    } else {\n      matches.put(pat, exp);\n    }\n  }\n\n  private Core.Pat toCore(Ast.Pat pat) {\n    final Type type = typeMap.getType(pat);\n    return toCore(pat, type, type);\n  }\n\n  private Core.Pat toCore(Ast.Pat pat, Type targetType) {\n    final Type type = typeMap.getType(pat);\n    return toCore(pat, type, targetType);\n  }\n\n  /** Converts a pattern to Core.\n   *\n   * <p>Expands a pattern if it is a record pattern that has an ellipsis\n   * or if the arguments are not in the same order as the labels in the type. */\n  private Core.Pat toCore(Ast.Pat pat, Type type, Type targetType) {\n    final TupleType tupleType;\n    switch (pat.op) {\n    case BOOL_LITERAL_PAT:\n    case CHAR_LITERAL_PAT:\n    case INT_LITERAL_PAT:\n    case REAL_LITERAL_PAT:\n    case STRING_LITERAL_PAT:\n      return core.literalPat(pat.op, type, ((Ast.LiteralPat) pat).value);\n\n    case WILDCARD_PAT:\n      return core.wildcardPat(type);\n\n    case ID_PAT:\n      final Ast.IdPat idPat = (Ast.IdPat) pat;\n      if (type.op() == Op.DATA_TYPE\n          && ((DataType) type).typeConstructors.containsKey(idPat.name)) {\n        return core.con0Pat((DataType) type, idPat.name);\n      }\n      return core.idPat(type, idPat.name, nameGenerator);\n\n    case AS_PAT:\n      final Ast.AsPat asPat = (Ast.AsPat) pat;\n      return core.asPat(type, asPat.id.name, nameGenerator, toCore(asPat.pat));\n\n    case ANNOTATED_PAT:\n      // There is no annotated pat in core, because all patterns have types.\n      final Ast.AnnotatedPat annotatedPat = (Ast.AnnotatedPat) pat;\n      return toCore(annotatedPat.pat);\n\n    case CON_PAT:\n      final Ast.ConPat conPat = (Ast.ConPat) pat;\n      return core.conPat(type, conPat.tyCon.name, toCore(conPat.pat));\n\n    case CON0_PAT:\n      final Ast.Con0Pat con0Pat = (Ast.Con0Pat) pat;\n      return core.con0Pat((DataType) type, con0Pat.tyCon.name);\n\n    case CONS_PAT:\n      // Cons \"::\" is an infix operator in Ast, a type constructor in Core, so\n      // Ast.InfixPat becomes Core.ConPat.\n      final Ast.InfixPat infixPat = (Ast.InfixPat) pat;\n      final Type type0 = typeMap.getType(infixPat.p0);\n      final Type type1 = typeMap.getType(infixPat.p1);\n      tupleType = typeMap.typeSystem.tupleType(type0, type1);\n      return core.consPat(type, BuiltIn.OP_CONS.mlName,\n          core.tuplePat(tupleType, toCore(infixPat.p0), toCore(infixPat.p1)));\n\n    case LIST_PAT:\n      final Ast.ListPat listPat = (Ast.ListPat) pat;\n      return core.listPat(type, transformEager(listPat.args, this::toCore));\n\n    case RECORD_PAT:\n      final RecordType recordType = (RecordType) targetType;\n      final Ast.RecordPat recordPat = (Ast.RecordPat) pat;\n      final ImmutableList.Builder<Core.Pat> args = ImmutableList.builder();\n      recordType.argNameTypes.forEach((label, argType) -> {\n        final Ast.Pat argPat = recordPat.args.get(label);\n        final Core.Pat corePat = argPat != null ? toCore(argPat)\n            : core.wildcardPat(argType);\n        args.add(corePat);\n      });\n      return core.recordPat(recordType, args.build());\n\n    case TUPLE_PAT:\n      final Ast.TuplePat tuplePat = (Ast.TuplePat) pat;\n      final List<Core.Pat> argList = transformEager(tuplePat.args, this::toCore);\n      return core.tuplePat((RecordLikeType) type, argList);\n\n    default:\n      throw new AssertionError(\"unknown pat \" + pat.op);\n    }\n  }\n\n  private Core.Match toCore(Ast.Match match) {\n    final Core.Pat pat = toCore(match.pat);\n    final List<Binding> bindings = new ArrayList<>();\n    Compiles.acceptBinding(typeMap.typeSystem, pat, bindings);\n    final Core.Exp exp = withEnv(bindings).toCore(match.exp);\n    return core.match(match.pos, pat, exp);\n  }\n\n  Core.Exp toCore(Ast.From from) {\n    final Type type = typeMap.getType(from);\n    final Core.Exp coreFrom = new FromResolver().run(from);\n    checkArgument(subsumes(type, coreFrom.type()),\n        \"Conversion to core did not preserve type: expected [%s] \"\n            + \"actual [%s] from [%s]\", type, coreFrom.type, coreFrom);\n    return coreFrom;\n  }\n\n  /** An actual type subsumes an expected type if it is equal\n   * or if progressive record types have been expanded. */\n  private static boolean subsumes(Type actualType, Type expectedType) {\n    switch (actualType.op()) {\n    case LIST:\n      if (expectedType.op() != Op.LIST) {\n        return false;\n      }\n      return subsumes(((ListType) actualType).elementType,\n          ((ListType) expectedType).elementType);\n    case RECORD_TYPE:\n      if (expectedType.op() != Op.RECORD_TYPE) {\n        return false;\n      }\n      if (actualType.isProgressive()) {\n        return true;\n      }\n      final SortedMap<String, Type> actualMap =\n          ((RecordType) actualType).argNameTypes();\n      final SortedMap<String, Type> expectedMap =\n          ((RecordType) expectedType).argNameTypes();\n      final Iterator<Map.Entry<String, Type>> actualIterator =\n          actualMap.entrySet().iterator();\n      final Iterator<Map.Entry<String, Type>> expectedIterator =\n          expectedMap.entrySet().iterator();\n      for (;;) {\n        if (actualIterator.hasNext()) {\n          if (!expectedIterator.hasNext()) {\n            // expected had fewer entries than actual\n            return false;\n          }\n        } else {\n          if (!expectedIterator.hasNext()) {\n            // expected and actual had same number of entries\n            return true;\n          }\n        }\n        final Map.Entry<String, Type> actual = actualIterator.next();\n        final Map.Entry<String, Type> expected = expectedIterator.next();\n        if (!actual.getKey().equals(expected.getKey())) {\n          return false;\n        }\n        if (!subsumes(actual.getValue(), expected.getValue())) {\n          return false;\n        }\n      }\n      // fall through\n    default:\n      return actualType.equals(expectedType);\n    }\n  }\n\n  private Core.Aggregate toCore(Ast.Aggregate aggregate,\n      Collection<? extends Core.IdPat> groupKeys) {\n    final Resolver resolver = withEnv(transform(groupKeys, Binding::of));\n    return core.aggregate(typeMap.getType(aggregate),\n        resolver.toCore(aggregate.aggregate),\n        aggregate.argument == null ? null : toCore(aggregate.argument));\n  }\n\n  private Core.OrderItem toCore(Ast.OrderItem orderItem) {\n    return core.orderItem(toCore(orderItem.exp), orderItem.direction);\n  }\n\n  /** Helper for initialization. */\n  private enum Init {\n    INSTANCE;\n\n    final ImmutableMap<Op, BuiltIn> opBuiltInMap;\n    final ImmutableMap<BuiltIn, Op> builtInOpMap;\n\n    Init() {\n      Object[] values = {\n          BuiltIn.LIST_OP_AT, Op.AT,\n          BuiltIn.OP_CONS, Op.CONS,\n          BuiltIn.OP_EQ, Op.EQ,\n          BuiltIn.OP_EXCEPT, Op.EXCEPT,\n          BuiltIn.OP_GE, Op.GE,\n          BuiltIn.OP_GT, Op.GT,\n          BuiltIn.OP_INTERSECT, Op.INTERSECT,\n          BuiltIn.OP_LE, Op.LE,\n          BuiltIn.OP_LT, Op.LT,\n          BuiltIn.OP_NE, Op.NE,\n          BuiltIn.OP_UNION, Op.UNION,\n          BuiltIn.Z_ANDALSO, Op.ANDALSO,\n          BuiltIn.Z_ORELSE, Op.ORELSE,\n          BuiltIn.Z_PLUS_INT, Op.PLUS,\n          BuiltIn.Z_PLUS_REAL, Op.PLUS,\n      };\n      final ImmutableMap.Builder<BuiltIn, Op> b2o = ImmutableMap.builder();\n      final Map<Op, BuiltIn> o2b = new HashMap<>();\n      for (int i = 0; i < values.length / 2; i++) {\n        BuiltIn builtIn = (BuiltIn) values[i * 2];\n        Op op = (Op) values[i * 2 + 1];\n        b2o.put(builtIn, op);\n        o2b.put(op, builtIn);\n      }\n      builtInOpMap = b2o.build();\n      opBuiltInMap = ImmutableMap.copyOf(o2b);\n    }\n  }\n\n  /** Resolved declaration. It can be converted to an expression given a\n   * result expression; depending on sub-type, that expression will either be\n   * a {@code let} (for a {@link net.hydromatic.morel.ast.Ast.ValDecl} or a\n   * {@code local} (for a {@link net.hydromatic.morel.ast.Ast.DatatypeDecl}. */\n  public abstract static class ResolvedDecl {\n    /** Converts the declaration to a {@code let} or a {@code local}. */\n    abstract Core.Exp toExp(Core.Exp resultExp);\n  }\n\n  /** Resolved value declaration. */\n  class ResolvedValDecl extends ResolvedDecl {\n    final boolean rec;\n    final boolean composite;\n    final ImmutableList<PatExp> patExps;\n    final Core.NamedPat pat;\n    final Core.Exp exp;\n\n    ResolvedValDecl(boolean rec,\n        ImmutableList<PatExp> patExps,\n        Core.NamedPat pat, Core.Exp exp) {\n      this.rec = rec;\n      this.composite = patExps.size() > 1;\n      this.patExps = patExps;\n      this.pat = pat;\n      this.exp = exp;\n    }\n\n    @Override Core.Let toExp(Core.Exp resultExp) {\n      if (rec) {\n        final List<Core.NonRecValDecl> valDecls = new ArrayList<>();\n        patExps.forEach(x ->\n            valDecls.add(core.nonRecValDecl(x.pos, (Core.IdPat) x.pat, x.exp)));\n        return core.let(core.recValDecl(valDecls), resultExp);\n      }\n      if (!composite && patExps.get(0).pat instanceof Core.IdPat) {\n        final PatExp x = patExps.get(0);\n        Core.NonRecValDecl valDecl =\n            core.nonRecValDecl(x.pos, (Core.IdPat) x.pat, x.exp);\n        return core.let(valDecl, resultExp);\n      } else {\n        // This is a complex pattern. Allocate an intermediate variable.\n        final String name = nameGenerator.get();\n        final Core.IdPat idPat = core.idPat(pat.type, name, nameGenerator);\n        final Core.Id id = core.id(idPat);\n        final Pos pos = patExps.get(0).pos;\n        return core.let(core.nonRecValDecl(pos, idPat, exp),\n            core.caseOf(pos, resultExp.type, id,\n                ImmutableList.of(core.match(pos, pat, resultExp))));\n      }\n    }\n  }\n\n  /** Pattern and expression. */\n  static class PatExp {\n    final Core.Pat pat;\n    final Core.Exp exp;\n    final Pos pos;\n\n    PatExp(Core.Pat pat, Core.Exp exp, Pos pos) {\n      this.pat = pat;\n      this.exp = exp;\n      this.pos = pos;\n    }\n\n    @Override public String toString() {\n      return \"[pat: \" + pat + \", exp: \" + exp + \", pos: \" + pos + \"]\";\n    }\n  }\n\n  /** Resolved datatype declaration. */\n  static class ResolvedDatatypeDecl extends ResolvedDecl {\n    private final ImmutableList<DataType> dataTypes;\n\n    ResolvedDatatypeDecl(ImmutableList<DataType> dataTypes) {\n      this.dataTypes = dataTypes;\n    }\n\n    @Override Core.Exp toExp(Core.Exp resultExp) {\n      return toExp(dataTypes, resultExp);\n    }\n\n    private Core.Exp toExp(List<DataType> dataTypes, Core.Exp resultExp) {\n      if (dataTypes.isEmpty()) {\n        return resultExp;\n      } else {\n        return core.local(dataTypes.get(0),\n            toExp(skip(dataTypes), resultExp));\n      }\n    }\n\n    /** Creates a datatype declaration that may have multiple datatypes.\n     *\n     * <p>Only the REPL needs this. Because datatypes are not recursive,\n     * a composite declaration\n     *\n     * <pre>{@code\n     * datatype d1 ... and d2 ...}</pre>\n     *\n     * <p>can always be converted to a chained local,\n     *\n     * <pre>{@code\n     * local datatype d1 ... in local datatype d2 ... end end}</pre>\n     */\n    public Core.DatatypeDecl toDecl() {\n      return core.datatypeDecl(dataTypes);\n    }\n  }\n\n  /** Visitor that converts {@link Ast.From} to {@link Core.From} by\n   * handling each subtype of {@link Ast.FromStep} calling\n   * {@link FromBuilder} appropriately. */\n  private class FromResolver extends Visitor {\n    final FromBuilder fromBuilder = core.fromBuilder(typeMap.typeSystem, env);\n\n    Core.Exp run(Ast.From from) {\n      if (from.isInto()) {\n        // Translate \"from ... into f\" as if they had written \"f (from ...)\"\n        final Core.Exp coreFrom = run(skipLast(from.steps));\n        final Ast.Into into = (Ast.Into) last(from.steps);\n        final Core.Exp exp = toCore(into.exp);\n        return core.apply(exp.pos, typeMap.getType(from), exp, coreFrom);\n      }\n\n      final Core.Exp coreFrom = run(from.steps);\n      if (from.isCompute()) {\n        return core.only(typeMap.typeSystem, from.pos, coreFrom);\n      } else {\n        return coreFrom;\n      }\n    }\n\n    private Core.Exp run(List<Ast.FromStep> steps) {\n      steps.forEach(this::accept);\n      return fromBuilder.buildSimplify();\n    }\n\n    @Override protected void visit(Ast.From from) {\n      // Do not traverse into the sub-\"from\".\n    }\n\n    @Override protected void visit(Ast.Scan scan) {\n      final Resolver r = withEnv(fromBuilder.bindings());\n      final Core.Exp coreExp;\n      final Core.Pat corePat;\n      if (scan.exp == null) {\n        corePat = r.toCore(scan.pat);\n        coreExp =\n            core.extent(typeMap.typeSystem, corePat.type,\n                ImmutableRangeSet.of(Range.all()));\n      } else {\n        coreExp = r.toCore(scan.exp);\n        final ListType listType = (ListType) coreExp.type;\n        corePat = r.toCore(scan.pat, listType.elementType);\n      }\n      final List<Binding> bindings2 = new ArrayList<>(fromBuilder.bindings());\n      Compiles.acceptBinding(typeMap.typeSystem, corePat, bindings2);\n      Core.Exp coreCondition = scan.condition == null\n          ? core.boolLiteral(true)\n          : r.withEnv(bindings2).toCore(scan.condition);\n      fromBuilder.scan(corePat, coreExp, coreCondition);\n    }\n\n    @Override protected void visit(Ast.Where where) {\n      final Resolver r = withEnv(fromBuilder.bindings());\n      fromBuilder.where(r.toCore(where.exp));\n    }\n\n    @Override protected void visit(Ast.Skip skip) {\n      final Resolver r = withEnv(env); // do not use 'from' bindings\n      fromBuilder.skip(r.toCore(skip.exp));\n    }\n\n    @Override protected void visit(Ast.Take take) {\n      final Resolver r = withEnv(env); // do not use 'from' bindings\n      fromBuilder.take(r.toCore(take.exp));\n    }\n\n    @Override protected void visit(Ast.Yield yield) {\n      final Resolver r = withEnv(fromBuilder.bindings());\n      fromBuilder.yield_(r.toCore(yield.exp));\n    }\n\n    @Override protected void visit(Ast.Order order) {\n      final Resolver r = withEnv(fromBuilder.bindings());\n      fromBuilder.order(transformEager(order.orderItems, r::toCore));\n    }\n\n    @Override protected void visit(Ast.Through through) {\n      // Translate \"from ... through p in f\"\n      // as if they wrote \"from p in f (from ...)\"\n      final Core.From from = fromBuilder.build();\n      fromBuilder.clear();\n      final Core.Exp exp = toCore(through.exp);\n      final Core.Pat pat = toCore(through.pat);\n      final Type type = typeMap.typeSystem.listType(pat.type);\n      fromBuilder.scan(pat, core.apply(through.pos, type, exp, from));\n    }\n\n    @Override protected void visit(Ast.Compute compute) {\n      visit((Ast.Group) compute);\n    }\n\n    @Override protected void visit(Ast.Group group) {\n      final Resolver r = withEnv(fromBuilder.bindings());\n      final ImmutableSortedMap.Builder<Core.IdPat, Core.Exp> groupExpsB =\n          ImmutableSortedMap.naturalOrder();\n      final ImmutableSortedMap.Builder<Core.IdPat, Core.Aggregate> aggregates =\n          ImmutableSortedMap.naturalOrder();\n      forEach(group.groupExps, (id, exp) ->\n          groupExpsB.put(toCorePat(id), r.toCore(exp)));\n      final SortedMap<Core.IdPat, Core.Exp> groupExps = groupExpsB.build();\n      group.aggregates.forEach(aggregate ->\n          aggregates.put(toCorePat(aggregate.id),\n              r.toCore(aggregate, groupExps.keySet())));\n      fromBuilder.group(groupExps, aggregates.build());\n    }\n  }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "public static final ImmutableMap<Op, BuiltIn> OP_BUILT_IN_MAP =\n      Init.INSTANCE.opBuiltInMap;", "docstring": " Map from {@link Op} to {@link BuiltIn}.", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "ImmutableMap<Op, BuiltIn>", "name": "OP_BUILT_IN_MAP =\n      Init.INSTANCE.opBuiltInMap", "syntax_pass": true}, {"attribute_expression": "public static final ImmutableMap<BuiltIn, Op> BUILT_IN_OP_MAP =\n      Init.INSTANCE.builtInOpMap;", "docstring": " Map from {@link BuiltIn}, to {@link Op};\nthe reverse of {@link #OP_BUILT_IN_MAP}, and needed when we convert\nan optimized expression back to human-readable Morel code.", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "ImmutableMap<BuiltIn, Op>", "name": "BUILT_IN_OP_MAP =\n      Init.INSTANCE.builtInOpMap", "syntax_pass": true}, {"attribute_expression": "final TypeMap typeMap;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "TypeMap", "name": "typeMap", "syntax_pass": true}, {"attribute_expression": "private final NameGenerator nameGenerator;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "NameGenerator", "name": "nameGenerator", "syntax_pass": true}, {"attribute_expression": "private final Environment env;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Environment", "name": "env", "syntax_pass": true}, {"attribute_expression": "private final @Nullable Session session;", "docstring": "", "modifiers": "private final @Nullable", "marker_annotations": ["@Nullable"], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Session", "name": "session", "syntax_pass": true}, {"attribute_expression": "private final Map<Pair<Core.NamedPat, Type>, Core.NamedPat> variantIdMap;", "docstring": " Contains variable declarations whose type at the point they are used is\ndifferent (more specific) than in their declaration.\n\n<p>For example, the infix operator \"op +\" has type\n\"&alpha; * &alpha; &rarr;\" in the base environment, but at point of use\nmight instead be \"int * int &rarr; int\". This map will contain a new\n{@link Core.IdPat} for all points that use it with that second type.\nEffectively, it is a phantom declaration, in a {@code let} that doesn't\nexist. Without this shared declaration, all points have their own distinct\n{@link Core.IdPat}, which the {@link Analyzer} will think is used just\nonce.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Map<Pair<Core.NamedPat, Type>, Core.NamedPat>", "name": "variantIdMap", "syntax_pass": true}]}, {"uris": "src/main/java/net/hydromatic/morel/compile/Analyzer.java.Analyzer", "name": "Analyzer", "file_path": "src/main/java/net/hydromatic/morel/compile/Analyzer.java", "superclasses": "EnvVisitor", "methods": ["[Analyzer]of(TypeSystem,Environment)", "[]Analyzer(TypeSystem,Environment,Map<Core.NamedPat, MutableUse>,Deque<FromContext>)", "[Analysis]analyze(TypeSystem,Environment,AstNode)", "[Analysis]result()", "[Analyzer]push(Environment)", "[void]visit(Core.IdPat)", "[void]visit(Core.Id)", "[MutableUse]use(Core.NamedPat)", "[void]visit(Core.NonRecValDecl)", "[boolean]isAtom(Core.Exp)", "[void]visit(Core.Case)"], "method_uris": ["src/main/java/net/hydromatic/morel/compile/Analyzer.java.Analyzer.[Analyzer]of(TypeSystem,Environment)", "src/main/java/net/hydromatic/morel/compile/Analyzer.java.Analyzer.[]Analyzer(TypeSystem,Environment,Map<Core.NamedPat, MutableUse>,Deque<FromContext>)", "src/main/java/net/hydromatic/morel/compile/Analyzer.java.Analyzer.[Analysis]analyze(TypeSystem,Environment,AstNode)", "src/main/java/net/hydromatic/morel/compile/Analyzer.java.Analyzer.[Analysis]result()", "src/main/java/net/hydromatic/morel/compile/Analyzer.java.Analyzer.[Analyzer]push(Environment)", "src/main/java/net/hydromatic/morel/compile/Analyzer.java.Analyzer.[void]visit(Core.IdPat)", "src/main/java/net/hydromatic/morel/compile/Analyzer.java.Analyzer.[void]visit(Core.Id)", "src/main/java/net/hydromatic/morel/compile/Analyzer.java.Analyzer.[MutableUse]use(Core.NamedPat)", "src/main/java/net/hydromatic/morel/compile/Analyzer.java.Analyzer.[void]visit(Core.NonRecValDecl)", "src/main/java/net/hydromatic/morel/compile/Analyzer.java.Analyzer.[boolean]isAtom(Core.Exp)", "src/main/java/net/hydromatic/morel/compile/Analyzer.java.Analyzer.[void]visit(Core.Case)"], "overrides": null, "attributes": [{"original_string": "  private static class MutableUse {\n    boolean top;\n    boolean atomic;\n    boolean parallel;\n    int useCount;\n\n    static int max(Collection<MutableUse> uses) {\n      int max = 0;\n      for (MutableUse use : uses) {\n        max = Math.max(max, use.useCount);\n      }\n      return max;\n    }\n\n    @Override public String toString() {\n      return \"[\" + useCount + (parallel ? \" parallel]\" : \"]\");\n    }\n\n    Use fix() {\n      return top ? Use.MULTI_UNSAFE\n          : useCount == 0 ? Use.DEAD\n          : atomic ? Use.ATOMIC\n          : useCount == 1 ? (parallel ? Use.MULTI_SAFE : Use.ONCE_SAFE)\n          : Use.MULTI_UNSAFE;\n    }\n  }", "definition": "  private static class MutableUse", "class_docstring": " Work space where the uses of a binding are counted. When all the uses\nhave been found, call {@link #fix} to convert this into a {@link Use}.", "name": "MutableUse", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "fields": [{"attribute_expression": "boolean top;", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "boolean", "name": "top", "syntax_pass": true}, {"attribute_expression": "boolean atomic;", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "boolean", "name": "atomic", "syntax_pass": true}, {"attribute_expression": "boolean parallel;", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "boolean", "name": "parallel", "syntax_pass": true}, {"attribute_expression": "int useCount;", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "int", "name": "useCount", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    static int max(Collection<MutableUse> uses) {\n      int max = 0;\n      for (MutableUse use : uses) {\n        max = Math.max(max, use.useCount);\n      }\n      return max;\n    }", "docstring": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "int", "classes": []}, "name": "max", "params": [{"name": "uses", "type": "Collection<MutableUse>"}], "body": "                                                {\n      int max = 0;\n      for (MutableUse use : uses) {\n        max = Math.max(max, use.useCount);\n      }\n      return max;\n    }", "signature": "static int max(Collection<MutableUse> uses)"}, {"syntax_pass": true, "original_string": "    @Override public String toString() {\n      return \"[\" + useCount + (parallel ? \" parallel]\" : \"]\");\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "toString", "params": [], "body": "                                       {\n      return \"[\" + useCount + (parallel ? \" parallel]\" : \"]\");\n    }", "signature": "@Override public String toString()"}, {"syntax_pass": true, "original_string": "    Use fix() {\n      return top ? Use.MULTI_UNSAFE\n          : useCount == 0 ? Use.DEAD\n          : atomic ? Use.ATOMIC\n          : useCount == 1 ? (parallel ? Use.MULTI_SAFE : Use.ONCE_SAFE)\n          : Use.MULTI_UNSAFE;\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "Use", "classes": []}, "name": "fix", "params": [], "body": "              {\n      return top ? Use.MULTI_UNSAFE\n          : useCount == 0 ? Use.DEAD\n          : atomic ? Use.ATOMIC\n          : useCount == 1 ? (parallel ? Use.MULTI_SAFE : Use.ONCE_SAFE)\n          : Use.MULTI_UNSAFE;\n    }", "signature": "Use fix()"}]}, {"original_string": "  public static class Analysis {\n    public final ImmutableMap<Core.NamedPat, Use> map;\n\n    Analysis(ImmutableMap<Core.NamedPat, Use> map) {\n      this.map = map;\n    }\n  }", "definition": "  public static class Analysis", "class_docstring": " Result of an analysis.", "name": "Analysis", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [{"attribute_expression": "public final ImmutableMap<Core.NamedPat, Use> map;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "ImmutableMap<Core.NamedPat, Use>", "name": "map", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    Analysis(ImmutableMap<Core.NamedPat, Use> map) {\n      this.map = map;\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "Analysis", "params": [{"name": "map", "type": "ImmutableMap<Core.NamedPat, Use>"}], "body": "                                                   {\n      this.map = map;\n    }", "signature": "Analysis(ImmutableMap<Core.NamedPat, Use> map)"}]}], "class_docstring": "\nShuttle that counts how many times each expression is used.\n", "original_string": "public class Analyzer extends EnvVisitor {\n  private final Map<Core.NamedPat, MutableUse> map;\n\n  /** Creates an Analyzer. */\n  private static Analyzer of(TypeSystem typeSystem, Environment env) {\n    return new Analyzer(typeSystem, env, new HashMap<>(), new ArrayDeque<>());\n  }\n\n  /** Private constructor. */\n  private Analyzer(TypeSystem typeSystem, Environment env,\n      Map<Core.NamedPat, MutableUse> map, Deque<FromContext> fromStack) {\n    super(typeSystem, env, fromStack);\n    this.map = map;\n  }\n\n  /** Analyzes an expression. */\n  public static Analysis analyze(TypeSystem typeSystem, Environment env,\n      AstNode node) {\n    final Analyzer analyzer = of(typeSystem, env);\n\n    // Mark all top-level bindings so that they will not be removed\n    if (node instanceof Core.NonRecValDecl) {\n      analyzer.use(((Core.NonRecValDecl) node).pat).top = true;\n    }\n    node.accept(analyzer);\n    return analyzer.result();\n  }\n\n  /** Returns the result of an analysis. */\n  private Analysis result() {\n    final ImmutableMap.Builder<Core.NamedPat, Use> b = ImmutableMap.builder();\n    map.forEach((k, v) -> b.put(k, v.fix()));\n    return new Analysis(b.build());\n  }\n\n  @Override protected Analyzer push(Environment env) {\n    return new Analyzer(typeSystem, env, map, fromStack);\n  }\n\n  @Override protected void visit(Core.IdPat idPat) {\n    use(idPat);\n  }\n\n  @Override protected void visit(Core.Id id) {\n    use(id.idPat).useCount++;\n    super.visit(id);\n  }\n\n  /** Gets or creates a {@link MutableUse} for a given name. */\n  private MutableUse use(Core.NamedPat name) {\n    return map.computeIfAbsent(name, k -> new MutableUse());\n  }\n\n  @Override protected void visit(Core.NonRecValDecl valDecl) {\n    super.visit(valDecl);\n    if (isAtom(valDecl.exp)) {\n      use(valDecl.pat).atomic = true;\n    }\n  }\n\n  private static boolean isAtom(Core.Exp exp) {\n    switch (exp.op) {\n    case ID:\n    case BOOL_LITERAL:\n    case CHAR_LITERAL:\n    case INT_LITERAL:\n    case REAL_LITERAL:\n    case STRING_LITERAL:\n    case UNIT_LITERAL:\n      return true;\n    default:\n      return false;\n    }\n  }\n\n  @Override protected void visit(Core.Case case_) {\n    case_.exp.accept(this);\n    if (case_.matchList.size() == 1) {\n      // When there is a single branch, we don't need to check for a single use\n      // on multiple branches, so we can expedite.\n      case_.matchList.get(0).accept(this);\n    } else {\n      // Create a multimap of all uses of bindings along the separate\n      // branches. Example:\n      //  case e of\n      //    1 => a + c\n      //  | 2 => a + b + a\n      //  | _ => c\n      //\n      // a has use counts [1, 2] and is therefore MULTI_UNSAFE\n      // b has use counts [1] and is therefore ONCE_SAFE\n      // c has use counts [1, 1] and is therefore MULTI_SAFE\n      final Multimap<Core.NamedPat, MutableUse> multimap =\n          HashMultimap.create();\n      final Map<Core.NamedPat, MutableUse> subMap = new HashMap<>();\n      final Analyzer analyzer =\n          new Analyzer(typeSystem, env, subMap, new ArrayDeque<>());\n      case_.matchList.forEach(e -> {\n        subMap.clear();\n        e.accept(analyzer);\n        subMap.forEach(multimap::put);\n      });\n      multimap.asMap().forEach((id, uses) -> {\n        final MutableUse baseUse = use(id);\n        int maxCount = MutableUse.max(uses);\n        if (uses.size() > 1) {\n          baseUse.parallel = true;\n        }\n        baseUse.useCount += maxCount;\n      });\n    }\n  }\n\n  /** How a binding (assignment of a value to a variable) is used. */\n  public enum Use {\n    /** Indicates that the binding cannot be inlined because recursively\n     * refers to itself (or more precisely, is part of a recursive cycle\n     * and has been chosen as the link to remove to break the cycle). */\n    LOOP_BREAKER,\n\n    /** Binding is not used. For a let (whether recursive or not), the binding\n     * can be discarded. */\n    DEAD,\n\n    /** The binding occurs exactly once, and that occurrence is not inside a\n     * lambda, nor is a constructor argument. Inlining is unconditionally safe;\n     * it duplicates neither code nor work. */\n    ONCE_SAFE,\n\n    /** The binding is an atom (variable or literal). Regardless of how many\n     * times it is used, inlining is unconditionally safe;\n     * it duplicates neither code nor work. */\n    ATOMIC,\n\n    /** The binding occurs at most once in each of several distinct case\n     * branches; none of these occurrences is inside a lambda. For example:\n     *\n     * <pre>{@code\n     * case xs of\n     *   [] => y + 1\n     * | x :: xs => y + 2\n     * }</pre>\n     *\n     * <p>In this expression, {@code y} occurs only once in each case branch.\n     * Inlining {@code y} may duplicate code, but it will not duplicate work. */\n    MULTI_SAFE,\n\n    /** The binding occurs exactly once, but inside a lambda. Inlining will not\n     * duplicate code, but it might duplicate work.\n     *\n     * <p>We must not inline an arbitrary expression inside a lambda, as the\n     * following example (from GHC inlining section 2.2) shows:\n     *\n     * <pre>{@code\n     * val f = fn x => E\n     * val g = fn ys => map f ys\n     * }</pre>\n     *\n     * <p>If we were to inline f inside g, thus:\n     *\n     * <pre>{@code\n     * val g = fn ys => map (fn x => E) ys\n     * }</pre>\n     *\n     * <p>no code is duplicated, but a small bounded amount of work is\n     * duplicated, because the closure {@code fn x => E} must be allocated\n     * each time {@code g} is called. */\n    ONCE_UNSAFE,\n\n    /** The binding may occur many times, including inside lambdas. */\n    MULTI_UNSAFE,\n  }\n\n  /** Work space where the uses of a binding are counted. When all the uses\n   * have been found, call {@link #fix} to convert this into a {@link Use}. */\n  private static class MutableUse {\n    boolean top;\n    boolean atomic;\n    boolean parallel;\n    int useCount;\n\n    static int max(Collection<MutableUse> uses) {\n      int max = 0;\n      for (MutableUse use : uses) {\n        max = Math.max(max, use.useCount);\n      }\n      return max;\n    }\n\n    @Override public String toString() {\n      return \"[\" + useCount + (parallel ? \" parallel]\" : \"]\");\n    }\n\n    Use fix() {\n      return top ? Use.MULTI_UNSAFE\n          : useCount == 0 ? Use.DEAD\n          : atomic ? Use.ATOMIC\n          : useCount == 1 ? (parallel ? Use.MULTI_SAFE : Use.ONCE_SAFE)\n          : Use.MULTI_UNSAFE;\n    }\n  }\n\n  /** Result of an analysis. */\n  public static class Analysis {\n    public final ImmutableMap<Core.NamedPat, Use> map;\n\n    Analysis(ImmutableMap<Core.NamedPat, Use> map) {\n      this.map = map;\n    }\n  }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private final Map<Core.NamedPat, MutableUse> map;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Map<Core.NamedPat, MutableUse>", "name": "map", "syntax_pass": true}]}, {"uris": "src/main/java/net/hydromatic/morel/compile/TypeMap.java.TypeMap", "name": "TypeMap", "file_path": "src/main/java/net/hydromatic/morel/compile/TypeMap.java", "superclasses": "", "methods": ["[]TypeMap(TypeSystem,Map<AstNode, Unifier.Term>,Unifier.Substitution)", "[String]toString()", "[Type]termToType(Unifier.Term)", "[Type]getType(AstNode)", "[Type]getTypeOpt(AstNode)", "[boolean]typeIsVariable(AstNode)", "[boolean]hasType(AstNode)", "[SortedSet<String>]typeFieldNames(AstNode)"], "method_uris": ["src/main/java/net/hydromatic/morel/compile/TypeMap.java.TypeMap.[]TypeMap(TypeSystem,Map<AstNode, Unifier.Term>,Unifier.Substitution)", "src/main/java/net/hydromatic/morel/compile/TypeMap.java.TypeMap.[String]toString()", "src/main/java/net/hydromatic/morel/compile/TypeMap.java.TypeMap.[Type]termToType(Unifier.Term)", "src/main/java/net/hydromatic/morel/compile/TypeMap.java.TypeMap.[Type]getType(AstNode)", "src/main/java/net/hydromatic/morel/compile/TypeMap.java.TypeMap.[Type]getTypeOpt(AstNode)", "src/main/java/net/hydromatic/morel/compile/TypeMap.java.TypeMap.[boolean]typeIsVariable(AstNode)", "src/main/java/net/hydromatic/morel/compile/TypeMap.java.TypeMap.[boolean]hasType(AstNode)", "src/main/java/net/hydromatic/morel/compile/TypeMap.java.TypeMap.[SortedSet<String>]typeFieldNames(AstNode)"], "overrides": null, "attributes": [{"original_string": "  private static class TermToTypeConverter\n      implements Unifier.TermVisitor<Type> {\n    private final TypeMap typeMap;\n\n    TermToTypeConverter(TypeMap typeMap) {\n      this.typeMap = typeMap;\n    }\n\n    public Type visit(Unifier.Sequence sequence) {\n      final Type type;\n      switch (sequence.operator) {\n      case TypeResolver.FN_TY_CON:\n        assert sequence.terms.size() == 2;\n        final Type paramType = sequence.terms.get(0).accept(this);\n        final Type resultType = sequence.terms.get(1).accept(this);\n        return typeMap.typeSystem.fnType(paramType, resultType);\n\n      case TypeResolver.TUPLE_TY_CON:\n        assert sequence.terms.size() != 1;\n        final List<Type> argTypes =\n            transformEager(sequence.terms, term -> term.accept(this));\n        return typeMap.typeSystem.tupleType(argTypes);\n\n      case TypeResolver.LIST_TY_CON:\n        assert sequence.terms.size() == 1;\n        final Type elementType = sequence.terms.get(0).accept(this);\n        return typeMap.typeSystem.listType(elementType);\n\n      case \"bool\":\n      case \"char\":\n      case \"int\":\n      case \"real\":\n      case \"string\":\n      case \"unit\":\n      default:\n        type = typeMap.typeSystem.lookupOpt(sequence.operator);\n        if (type != null) {\n          if (sequence.terms.isEmpty()) {\n            return type;\n          }\n          final List<Type> types =\n              transform(sequence.terms, t -> t.accept(this));\n          return typeMap.typeSystem.apply(type, types);\n        }\n        if (sequence.operator.startsWith(TypeResolver.RECORD_TY_CON)) {\n          // E.g. \"record:a:b\" becomes record type \"{a:t0, b:t1}\".\n          final List<String> argNames = TypeResolver.fieldList(sequence);\n          if (argNames != null) {\n            final PairList<String, Type> argNameTypes = PairList.of();\n            final AtomicBoolean progressive = new AtomicBoolean(false);\n            forEach(argNames, sequence.terms, (name, term) -> {\n              if (name.equals(TypeResolver.PROGRESSIVE_LABEL)) {\n                progressive.set(true);\n              } else {\n                argNameTypes.add(name, term.accept(this));\n              }\n            });\n            return progressive.get()\n                ? typeMap.typeSystem.progressiveRecordType(argNameTypes)\n                : typeMap.typeSystem.recordType(argNameTypes);\n          }\n        }\n        throw new AssertionError(\"unknown type constructor \"\n            + sequence.operator);\n      }\n    }\n\n    public Type visit(Unifier.Variable variable) {\n      final Unifier.Term term = typeMap.substitution.resultMap.get(variable);\n      if (term == null) {\n        return typeMap.typeVars.computeIfAbsent(variable.toString(),\n            varName -> new TypeVar(typeMap.typeVars.size()));\n      }\n      return term.accept(this);\n    }\n  }", "definition": "  private static class TermToTypeConverter\n      implements Unifier.TermVisitor<Type>", "class_docstring": " Visitor that converts type terms into actual types.", "name": "TermToTypeConverter", "super_interfaces": ["Unifier.TermVisitor<Type>"], "superclasses": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "fields": [{"attribute_expression": "private final TypeMap typeMap;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "TypeMap", "name": "typeMap", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    TermToTypeConverter(TypeMap typeMap) {\n      this.typeMap = typeMap;\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "TermToTypeConverter", "params": [{"name": "typeMap", "type": "TypeMap"}], "body": "                                         {\n      this.typeMap = typeMap;\n    }", "signature": "TermToTypeConverter(TypeMap typeMap)"}, {"syntax_pass": true, "original_string": "    public Type visit(Unifier.Sequence sequence) {\n      final Type type;\n      switch (sequence.operator) {\n      case TypeResolver.FN_TY_CON:\n        assert sequence.terms.size() == 2;\n        final Type paramType = sequence.terms.get(0).accept(this);\n        final Type resultType = sequence.terms.get(1).accept(this);\n        return typeMap.typeSystem.fnType(paramType, resultType);\n\n      case TypeResolver.TUPLE_TY_CON:\n        assert sequence.terms.size() != 1;\n        final List<Type> argTypes =\n            transformEager(sequence.terms, term -> term.accept(this));\n        return typeMap.typeSystem.tupleType(argTypes);\n\n      case TypeResolver.LIST_TY_CON:\n        assert sequence.terms.size() == 1;\n        final Type elementType = sequence.terms.get(0).accept(this);\n        return typeMap.typeSystem.listType(elementType);\n\n      case \"bool\":\n      case \"char\":\n      case \"int\":\n      case \"real\":\n      case \"string\":\n      case \"unit\":\n      default:\n        type = typeMap.typeSystem.lookupOpt(sequence.operator);\n        if (type != null) {\n          if (sequence.terms.isEmpty()) {\n            return type;\n          }\n          final List<Type> types =\n              transform(sequence.terms, t -> t.accept(this));\n          return typeMap.typeSystem.apply(type, types);\n        }\n        if (sequence.operator.startsWith(TypeResolver.RECORD_TY_CON)) {\n          // E.g. \"record:a:b\" becomes record type \"{a:t0, b:t1}\".\n          final List<String> argNames = TypeResolver.fieldList(sequence);\n          if (argNames != null) {\n            final PairList<String, Type> argNameTypes = PairList.of();\n            final AtomicBoolean progressive = new AtomicBoolean(false);\n            forEach(argNames, sequence.terms, (name, term) -> {\n              if (name.equals(TypeResolver.PROGRESSIVE_LABEL)) {\n                progressive.set(true);\n              } else {\n                argNameTypes.add(name, term.accept(this));\n              }\n            });\n            return progressive.get()\n                ? typeMap.typeSystem.progressiveRecordType(argNameTypes)\n                : typeMap.typeSystem.recordType(argNameTypes);\n          }\n        }\n        throw new AssertionError(\"unknown type constructor \"\n            + sequence.operator);\n      }\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Type", "classes": []}, "name": "visit", "params": [{"name": "sequence", "type": "Unifier.Sequence"}], "body": "                                                 {\n      final Type type;\n      switch (sequence.operator) {\n      case TypeResolver.FN_TY_CON:\n        assert sequence.terms.size() == 2;\n        final Type paramType = sequence.terms.get(0).accept(this);\n        final Type resultType = sequence.terms.get(1).accept(this);\n        return typeMap.typeSystem.fnType(paramType, resultType);\n\n      case TypeResolver.TUPLE_TY_CON:\n        assert sequence.terms.size() != 1;\n        final List<Type> argTypes =\n            transformEager(sequence.terms, term -> term.accept(this));\n        return typeMap.typeSystem.tupleType(argTypes);\n\n      case TypeResolver.LIST_TY_CON:\n        assert sequence.terms.size() == 1;\n        final Type elementType = sequence.terms.get(0).accept(this);\n        return typeMap.typeSystem.listType(elementType);\n\n      case \"bool\":\n      case \"char\":\n      case \"int\":\n      case \"real\":\n      case \"string\":\n      case \"unit\":\n      default:\n        type = typeMap.typeSystem.lookupOpt(sequence.operator);\n        if (type != null) {\n          if (sequence.terms.isEmpty()) {\n            return type;\n          }\n          final List<Type> types =\n              transform(sequence.terms, t -> t.accept(this));\n          return typeMap.typeSystem.apply(type, types);\n        }\n        if (sequence.operator.startsWith(TypeResolver.RECORD_TY_CON)) {\n          // E.g. \"record:a:b\" becomes record type \"{a:t0, b:t1}\".\n          final List<String> argNames = TypeResolver.fieldList(sequence);\n          if (argNames != null) {\n            final PairList<String, Type> argNameTypes = PairList.of();\n            final AtomicBoolean progressive = new AtomicBoolean(false);\n            forEach(argNames, sequence.terms, (name, term) -> {\n              if (name.equals(TypeResolver.PROGRESSIVE_LABEL)) {\n                progressive.set(true);\n              } else {\n                argNameTypes.add(name, term.accept(this));\n              }\n            });\n            return progressive.get()\n                ? typeMap.typeSystem.progressiveRecordType(argNameTypes)\n                : typeMap.typeSystem.recordType(argNameTypes);\n          }\n        }\n        throw new AssertionError(\"unknown type constructor \"\n            + sequence.operator);\n      }\n    }", "signature": "public Type visit(Unifier.Sequence sequence)"}, {"syntax_pass": true, "original_string": "    public Type visit(Unifier.Variable variable) {\n      final Unifier.Term term = typeMap.substitution.resultMap.get(variable);\n      if (term == null) {\n        return typeMap.typeVars.computeIfAbsent(variable.toString(),\n            varName -> new TypeVar(typeMap.typeVars.size()));\n      }\n      return term.accept(this);\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Type", "classes": []}, "name": "visit", "params": [{"name": "variable", "type": "Unifier.Variable"}], "body": "                                                 {\n      final Unifier.Term term = typeMap.substitution.resultMap.get(variable);\n      if (term == null) {\n        return typeMap.typeVars.computeIfAbsent(variable.toString(),\n            varName -> new TypeVar(typeMap.typeVars.size()));\n      }\n      return term.accept(this);\n    }", "signature": "public Type visit(Unifier.Variable variable)"}]}], "class_docstring": " The result of type resolution, a map from AST nodes to types.", "original_string": "public class TypeMap {\n  public final TypeSystem typeSystem;\n  private final Map<AstNode, Unifier.Term> nodeTypeTerms;\n  final Unifier.Substitution substitution;\n\n  /** Map from type variable name to type variable. The ordinal of the variable\n   * is the size of the map at the time it is registered.\n   *\n   * <p>This map is never iterated over, and therefore the deterministic\n   * iteration provided by LinkedHashMap is not necessary, and HashMap is\n   * sufficient. */\n  private final Map<String, TypeVar> typeVars = new HashMap<>();\n\n  TypeMap(TypeSystem typeSystem, Map<AstNode, Unifier.Term> nodeTypeTerms,\n      Unifier.Substitution substitution) {\n    this.typeSystem = requireNonNull(typeSystem);\n    this.nodeTypeTerms = ImmutableMap.copyOf(nodeTypeTerms);\n    this.substitution = requireNonNull(substitution.resolve());\n  }\n\n  @Override public String toString() {\n    final StringBuilder b = new StringBuilder();\n    b.append(\"terms:\\n\");\n    final List<Map.Entry<AstNode, Unifier.Term>> nodeTerms =\n        new ArrayList<>(nodeTypeTerms.entrySet());\n    nodeTerms.sort(Comparator.comparing(o -> o.getValue().toString()));\n    nodeTerms.forEach(pair ->\n        b.append(pair.getValue()).append(\": \").append(pair.getKey())\n            .append('\\n'));\n    b.append(\"substitution:\\n\");\n    substitution.accept(b);\n    return b.toString();\n  }\n\n  Type termToType(Unifier.Term term) {\n    return term.accept(new TermToTypeConverter(this));\n  }\n\n  /** Returns the type of an AST node. */\n  public Type getType(AstNode node) {\n    final Unifier.Term term = requireNonNull(nodeTypeTerms.get(node));\n    return termToType(term);\n  }\n\n  /** Returns an AST node's type, or null if no type is known. */\n  public @Nullable Type getTypeOpt(AstNode node) {\n    final Unifier.Term term = nodeTypeTerms.get(node);\n    return term == null ? null : termToType(term);\n  }\n\n  /** Returns whether an AST node's type will be a type variable. */\n  public boolean typeIsVariable(AstNode node) {\n    final Unifier.Term term = nodeTypeTerms.get(node);\n    if (term instanceof Unifier.Variable) {\n      final Type type = termToType(term);\n      return type instanceof TypeVar\n          || type.isProgressive();\n    }\n    return false;\n  }\n\n  /** Returns whether an AST node has a type.\n   *\n   * <p>If it does not, perhaps it was ignored by the unification algorithm\n   * because it is not relevant to the program. */\n  public boolean hasType(AstNode node) {\n    return nodeTypeTerms.containsKey(node);\n  }\n\n  /** Returns the field names if an AST node has a type that is a record or a\n   * tuple, otherwise null. */\n  @Nullable SortedSet<String> typeFieldNames(AstNode node) {\n    // The term might be a sequence or a variable. We only materialize a type\n    // if it is a variable. Materializing a type for every sequence allocated\n    // lots of temporary type variables, and created a lot of noise in ref logs.\n    final Unifier.Term term = nodeTypeTerms.get(node);\n    if (term instanceof Unifier.Sequence) {\n      final Unifier.Sequence sequence = (Unifier.Sequence) term;\n      // E.g. \"record:a:b\" becomes record type \"{a:t0, b:t1}\".\n      final List<String> fieldList = TypeResolver.fieldList(sequence);\n      if (fieldList != null) {\n        return ImmutableSortedSet.copyOf(RecordType.ORDERING, fieldList);\n      }\n    }\n    if (term instanceof Unifier.Variable) {\n      final Type type = termToType(term);\n      if (type instanceof RecordLikeType) {\n        return (SortedSet<String>)\n            ((RecordLikeType) type).argNameTypes().keySet();\n      }\n    }\n    return null;\n  }\n\n  /** Visitor that converts type terms into actual types. */\n  private static class TermToTypeConverter\n      implements Unifier.TermVisitor<Type> {\n    private final TypeMap typeMap;\n\n    TermToTypeConverter(TypeMap typeMap) {\n      this.typeMap = typeMap;\n    }\n\n    public Type visit(Unifier.Sequence sequence) {\n      final Type type;\n      switch (sequence.operator) {\n      case TypeResolver.FN_TY_CON:\n        assert sequence.terms.size() == 2;\n        final Type paramType = sequence.terms.get(0).accept(this);\n        final Type resultType = sequence.terms.get(1).accept(this);\n        return typeMap.typeSystem.fnType(paramType, resultType);\n\n      case TypeResolver.TUPLE_TY_CON:\n        assert sequence.terms.size() != 1;\n        final List<Type> argTypes =\n            transformEager(sequence.terms, term -> term.accept(this));\n        return typeMap.typeSystem.tupleType(argTypes);\n\n      case TypeResolver.LIST_TY_CON:\n        assert sequence.terms.size() == 1;\n        final Type elementType = sequence.terms.get(0).accept(this);\n        return typeMap.typeSystem.listType(elementType);\n\n      case \"bool\":\n      case \"char\":\n      case \"int\":\n      case \"real\":\n      case \"string\":\n      case \"unit\":\n      default:\n        type = typeMap.typeSystem.lookupOpt(sequence.operator);\n        if (type != null) {\n          if (sequence.terms.isEmpty()) {\n            return type;\n          }\n          final List<Type> types =\n              transform(sequence.terms, t -> t.accept(this));\n          return typeMap.typeSystem.apply(type, types);\n        }\n        if (sequence.operator.startsWith(TypeResolver.RECORD_TY_CON)) {\n          // E.g. \"record:a:b\" becomes record type \"{a:t0, b:t1}\".\n          final List<String> argNames = TypeResolver.fieldList(sequence);\n          if (argNames != null) {\n            final PairList<String, Type> argNameTypes = PairList.of();\n            final AtomicBoolean progressive = new AtomicBoolean(false);\n            forEach(argNames, sequence.terms, (name, term) -> {\n              if (name.equals(TypeResolver.PROGRESSIVE_LABEL)) {\n                progressive.set(true);\n              } else {\n                argNameTypes.add(name, term.accept(this));\n              }\n            });\n            return progressive.get()\n                ? typeMap.typeSystem.progressiveRecordType(argNameTypes)\n                : typeMap.typeSystem.recordType(argNameTypes);\n          }\n        }\n        throw new AssertionError(\"unknown type constructor \"\n            + sequence.operator);\n      }\n    }\n\n    public Type visit(Unifier.Variable variable) {\n      final Unifier.Term term = typeMap.substitution.resultMap.get(variable);\n      if (term == null) {\n        return typeMap.typeVars.computeIfAbsent(variable.toString(),\n            varName -> new TypeVar(typeMap.typeVars.size()));\n      }\n      return term.accept(this);\n    }\n  }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "public final TypeSystem typeSystem;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "TypeSystem", "name": "typeSystem", "syntax_pass": true}, {"attribute_expression": "private final Map<AstNode, Unifier.Term> nodeTypeTerms;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Map<AstNode, Unifier.Term>", "name": "nodeTypeTerms", "syntax_pass": true}, {"attribute_expression": "final Unifier.Substitution substitution;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "Unifier.Substitution", "name": "substitution", "syntax_pass": true}, {"attribute_expression": "private final Map<String, TypeVar> typeVars = new HashMap<>();", "docstring": " Map from type variable name to type variable. The ordinal of the variable\nis the size of the map at the time it is registered.\n\n<p>This map is never iterated over, and therefore the deterministic\niteration provided by LinkedHashMap is not necessary, and HashMap is\nsufficient.", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Map<String, TypeVar>", "name": "typeVars = new HashMap<>()", "syntax_pass": true}]}, {"uris": "src/main/java/net/hydromatic/morel/util/MartelliUnifier.java.MartelliUnifier", "name": "MartelliUnifier", "file_path": "src/main/java/net/hydromatic/morel/util/MartelliUnifier.java", "superclasses": "Unifier", "methods": ["[Result]unify(List<TermTerm>,Map<Variable, Action>,Tracer)", "[void]substituteList(List<TermTerm>,Tracer,Map<Variable, Term>)", "[void]act(Variable,Term,List<TermTerm>,Substitution,Map<Variable, Action>,int)", "[int]findDelete(List<TermTerm>)", "[int]findSeqSeq(List<TermTerm>)", "[int]findNonVarVar(List<TermTerm>)", "[int]findVarAny(List<TermTerm>)"], "method_uris": ["src/main/java/net/hydromatic/morel/util/MartelliUnifier.java.MartelliUnifier.[Result]unify(List<TermTerm>,Map<Variable, Action>,Tracer)", "src/main/java/net/hydromatic/morel/util/MartelliUnifier.java.MartelliUnifier.[void]substituteList(List<TermTerm>,Tracer,Map<Variable, Term>)", "src/main/java/net/hydromatic/morel/util/MartelliUnifier.java.MartelliUnifier.[void]act(Variable,Term,List<TermTerm>,Substitution,Map<Variable, Action>,int)", "src/main/java/net/hydromatic/morel/util/MartelliUnifier.java.MartelliUnifier.[int]findDelete(List<TermTerm>)", "src/main/java/net/hydromatic/morel/util/MartelliUnifier.java.MartelliUnifier.[int]findSeqSeq(List<TermTerm>)", "src/main/java/net/hydromatic/morel/util/MartelliUnifier.java.MartelliUnifier.[int]findNonVarVar(List<TermTerm>)", "src/main/java/net/hydromatic/morel/util/MartelliUnifier.java.MartelliUnifier.[int]findVarAny(List<TermTerm>)"], "overrides": null, "attributes": [], "class_docstring": " Unification algorithm due to Martelli, Montanari (1976) and\nPaterson, Wegman (1978).", "original_string": "public class MartelliUnifier extends Unifier {\n  public @NonNull Result unify(List<TermTerm> termPairs,\n      Map<Variable, Action> termActions, Tracer tracer) {\n\n    // delete: G u { t = t }\n    //   => G\n\n    // decompose: G u { f(s0, ..., sk) = f(t0, ..., tk) }\n    //   => G u {s0 = t0, ..., sk = tk}\n\n    // conflict: G u { f(s0, ..., sk) = g(t0, ..., tm) }\n    //   => fail\n    // if f <> g or k <> m\n\n    // swap: G u { f(s0, ..., sk) = x }\n    //  => G u { x = f(s0, ..., sk) }\n\n    // eliminate: G u { x = t }\n    //  => G { x |-> t } u { x = t }\n    // if x not in vars(t) and x in vars(G)\n\n    // check: G u { x = f(s0, ..., sk)}\n    //  => fail\n    // if x in vars(f(s0, ..., sk))\n\n    termPairs = new ArrayList<>(termPairs);\n    final Map<Variable, Term> result = new LinkedHashMap<>();\n    for (;;) {\n      if (termPairs.isEmpty()) {\n        return SubstitutionResult.create(result);\n      }\n      int i = findDelete(termPairs);\n      if (i >= 0) {\n        final TermTerm pair = termPairs.remove(i); // delete\n        tracer.onDelete(pair.left, pair.right);\n        continue;\n      }\n\n      i = findSeqSeq(termPairs);\n      if (i >= 0) {\n        final TermTerm pair = termPairs.get(i);\n        final Sequence left = (Sequence) pair.left;\n        final Sequence right = (Sequence) pair.right;\n\n        if (!left.operator.equals(right.operator)\n            || left.terms.size() != right.terms.size()) {\n          tracer.onConflict(left, right);\n          return failure(\"conflict: \" + left + \" vs \" + right);\n        }\n        termPairs.remove(i); // decompose\n        tracer.onSequence(left, right);\n        for (int j = 0; j < left.terms.size(); j++) {\n          termPairs.add(new TermTerm(left.terms.get(j), right.terms.get(j)));\n        }\n        continue;\n      }\n\n      i = findNonVarVar(termPairs);\n      if (i >= 0) {\n        final TermTerm pair = termPairs.get(i);\n        termPairs.set(i, new TermTerm(pair.right, pair.left));\n        tracer.onSwap(pair.left, pair.right);\n        continue; // swap\n      }\n\n      i = findVarAny(termPairs);\n      if (i >= 0) {\n        final TermTerm pair = termPairs.remove(i);\n        final Variable variable = (Variable) pair.left;\n        final Term term = pair.right;\n        if (term.contains(variable)) {\n          tracer.onCycle(variable, term);\n          return failure(\"cycle: variable \" + variable + \" in \" + term);\n        }\n        tracer.onVariable(variable, term);\n        result.put(variable, term);\n        act(variable, term, termPairs, new Substitution(result),\n            termActions, 0);\n        substituteList(termPairs, tracer, ImmutableMap.of(variable, term));\n      }\n    }\n  }\n\n  /** Applies a mapping to all term pairs in a list, modifying them in place. */\n  private void substituteList(List<TermTerm> termPairs, Tracer tracer,\n      Map<Variable, Term> map) {\n    for (int j = 0; j < termPairs.size(); j++) {\n      final TermTerm pair2 = termPairs.get(j);\n      final Term left2 = pair2.left.apply(map);\n      final Term right2 = pair2.right.apply(map);\n      if (left2 != pair2.left\n          || right2 != pair2.right) {\n        tracer.onSubstitute(pair2.left, pair2.right, left2, right2);\n        termPairs.set(j, new TermTerm(left2, right2));\n      }\n    }\n  }\n\n  private void act(Variable variable, Term term, List<TermTerm> termPairs,\n      Substitution substitution, Map<Variable, Action> termActions,\n      int depth) {\n    final Action action = termActions.get(variable);\n    if (action != null) {\n      action.accept(variable, term, substitution, termPairs);\n    }\n    if (term instanceof Variable) {\n      // Copy list to prevent concurrent modification, in case the action\n      // appends to the list. Limit on depth, to prevent infinite recursion.\n      final List<TermTerm> termPairsCopy = new ArrayList<>(termPairs);\n      termPairsCopy.forEach(termPair -> {\n        if (termPair.left.equals(term) && depth < 2) {\n          act(variable, termPair.right, termPairs, substitution, termActions,\n              depth + 1);\n        }\n      });\n      // If the term is a variable, recurse to see whether there is an\n      // action for that variable. Limit on depth to prevent swapping back.\n      if (depth < 1) {\n        act((Variable) term, variable, termPairs, substitution, termActions,\n            depth + 1);\n      }\n    }\n    substitution.resultMap.forEach((variable2, v) -> {\n      // Substitution contains \"variable2 -> variable\"; call the actions of\n      // \"variable2\", because it too has just been unified.\n      if (v.equals(variable)) {\n        act(variable2, term, termPairs, substitution, termActions,\n            depth + 1);\n      }\n    });\n  }\n\n  private int findDelete(List<TermTerm> termPairs) {\n    for (int i = 0; i < termPairs.size(); i++) {\n      TermTerm termTerm = termPairs.get(i);\n      if (termTerm.left.equals(termTerm.right)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  private int findSeqSeq(List<TermTerm> termPairs) {\n    for (int i = 0; i < termPairs.size(); i++) {\n      TermTerm termTerm = termPairs.get(i);\n      if (termTerm.left instanceof Sequence\n          && termTerm.right instanceof Sequence) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  private int findNonVarVar(List<TermTerm> termPairs) {\n    for (int i = 0; i < termPairs.size(); i++) {\n      TermTerm termTerm = termPairs.get(i);\n      if (!(termTerm.left instanceof Variable)\n          && termTerm.right instanceof Variable) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  private int findVarAny(List<TermTerm> termPairs) {\n    for (int i = 0; i < termPairs.size(); i++) {\n      TermTerm termTerm = termPairs.get(i);\n      if (termTerm.left instanceof Variable) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/main/java/net/hydromatic/morel/util/MapList.java.MapList", "name": "MapList", "file_path": "src/main/java/net/hydromatic/morel/util/MapList.java", "superclasses": "", "methods": ["[]MapList(int,IntFunction<E>)", "[MapList<E>]of(int,IntFunction<E>)", "[E]get(int)", "[int]size()"], "method_uris": ["src/main/java/net/hydromatic/morel/util/MapList.java.MapList.[]MapList(int,IntFunction<E>)", "src/main/java/net/hydromatic/morel/util/MapList.java.MapList.[MapList<E>]of(int,IntFunction<E>)", "src/main/java/net/hydromatic/morel/util/MapList.java.MapList.[E]get(int)", "src/main/java/net/hydromatic/morel/util/MapList.java.MapList.[int]size()"], "overrides": null, "attributes": [], "class_docstring": " Read-only list that generates elements between 0 and {@code size} - 1\nby applying a function.\n\n@param <E> Element type\n", "original_string": "public final class MapList<E> extends AbstractList<E> implements RandomAccess {\n  private final int size;\n  private final IntFunction<E> fn;\n\n  private MapList(int size, IntFunction<E> fn) {\n    this.size = size;\n    this.fn = fn;\n  }\n\n  /** Creates a MapList. */\n  public static <E> MapList<E> of(int size, IntFunction<E> fn) {\n    return new MapList<>(size, fn);\n  }\n\n  public E get(int index) {\n    return fn.apply(index);\n  }\n\n  public int size() {\n    return size;\n  }\n}", "super_interfaces": ["RandomAccess"], "fields": [{"attribute_expression": "private final int size;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "int", "name": "size", "syntax_pass": true}, {"attribute_expression": "private final IntFunction<E> fn;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "IntFunction<E>", "name": "fn", "syntax_pass": true}]}, {"uris": "src/main/java/net/hydromatic/morel/util/Ord.java.Ord", "name": "Ord", "file_path": "src/main/java/net/hydromatic/morel/util/Ord.java", "superclasses": "", "methods": ["[]Ord(int,E)", "[Ord<E>]of(int,E)", "[Iterable<Ord<E>>]zip(Iterable<? extends E>)", "[Iterator<Ord<E>>]zip(Iterator<? extends E>)", "[List<Ord<E>>]zip(E[])", "[List<Ord<E>>]zip(List<? extends E>)", "[void]forEachIndexed(Iterable<E>,ObjIntConsumer<E>)", "[void]forEach(List<E>,ObjIntConsumer<E>)", "[void]forEachIndexed(Map<K, V>,IntObjObjConsumer<K, V>)", "[Iterable<Ord<E>>]reverse()", "[Iterable<Ord<E>>]reverse(Iterable<? extends E>)", "[Integer]getKey()", "[E]getValue()", "[E]setValue(E)"], "method_uris": ["src/main/java/net/hydromatic/morel/util/Ord.java.Ord.[]Ord(int,E)", "src/main/java/net/hydromatic/morel/util/Ord.java.Ord.[Ord<E>]of(int,E)", "src/main/java/net/hydromatic/morel/util/Ord.java.Ord.[Iterable<Ord<E>>]zip(Iterable<? extends E>)", "src/main/java/net/hydromatic/morel/util/Ord.java.Ord.[Iterator<Ord<E>>]zip(Iterator<? extends E>)", "src/main/java/net/hydromatic/morel/util/Ord.java.Ord.[List<Ord<E>>]zip(E[])", "src/main/java/net/hydromatic/morel/util/Ord.java.Ord.[List<Ord<E>>]zip(List<? extends E>)", "src/main/java/net/hydromatic/morel/util/Ord.java.Ord.[void]forEachIndexed(Iterable<E>,ObjIntConsumer<E>)", "src/main/java/net/hydromatic/morel/util/Ord.java.Ord.[void]forEach(List<E>,ObjIntConsumer<E>)", "src/main/java/net/hydromatic/morel/util/Ord.java.Ord.[void]forEachIndexed(Map<K, V>,IntObjObjConsumer<K, V>)", "src/main/java/net/hydromatic/morel/util/Ord.java.Ord.[Iterable<Ord<E>>]reverse()", "src/main/java/net/hydromatic/morel/util/Ord.java.Ord.[Iterable<Ord<E>>]reverse(Iterable<? extends E>)", "src/main/java/net/hydromatic/morel/util/Ord.java.Ord.[Integer]getKey()", "src/main/java/net/hydromatic/morel/util/Ord.java.Ord.[E]getValue()", "src/main/java/net/hydromatic/morel/util/Ord.java.Ord.[E]setValue(E)"], "overrides": null, "attributes": [{"original_string": "  private static class OrdList<E> extends AbstractList<Ord<E>> {\n    private final List<? extends E> elements;\n\n    OrdList(List<? extends E> elements) {\n      this.elements = elements;\n    }\n\n    public Ord<E> get(int index) {\n      return Ord.of(index, elements.get(index));\n    }\n\n    public int size() {\n      return elements.size();\n    }\n  }", "definition": "  private static class OrdList<E> extends AbstractList<Ord<E>>", "class_docstring": " List of {@link Ord} backed by a list of elements.\n\n@param <E> element type", "name": "OrdList", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "fields": [{"attribute_expression": "private final List<? extends E> elements;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "List<? extends E>", "name": "elements", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    OrdList(List<? extends E> elements) {\n      this.elements = elements;\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "OrdList", "params": [{"name": "elements", "type": "List<? extends E>"}], "body": "                                        {\n      this.elements = elements;\n    }", "signature": "OrdList(List<? extends E> elements)"}, {"syntax_pass": true, "original_string": "    public Ord<E> get(int index) {\n      return Ord.of(index, elements.get(index));\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Ord<E>", "classes": []}, "name": "get", "params": [{"name": "index", "type": "int"}], "body": "                                 {\n      return Ord.of(index, elements.get(index));\n    }", "signature": "public Ord<E> get(int index)"}, {"syntax_pass": true, "original_string": "    public int size() {\n      return elements.size();\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "size", "params": [], "body": "                      {\n      return elements.size();\n    }", "signature": "public int size()"}]}, {"original_string": "  private static class OrdRandomAccessList<E> extends OrdList<E>\n      implements RandomAccess {\n    OrdRandomAccessList(List<? extends E> elements) {\n      super(elements);\n    }\n  }", "definition": "  private static class OrdRandomAccessList<E> extends OrdList<E>\n      implements RandomAccess", "class_docstring": " List of {@link Ord} backed by a random-access list of elements.\n\n@param <E> element type", "name": "OrdRandomAccessList", "super_interfaces": ["RandomAccess"], "superclasses": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    OrdRandomAccessList(List<? extends E> elements) {\n      super(elements);\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "OrdRandomAccessList", "params": [{"name": "elements", "type": "List<? extends E>"}], "body": "                                                    {\n      super(elements);\n    }", "signature": "OrdRandomAccessList(List<? extends E> elements)"}]}, {"original_string": "  private static class OrdArrayList<E> extends AbstractList<Ord<E>>\n      implements RandomAccess {\n    private final E[] elements;\n\n    OrdArrayList(E[] elements) {\n      this.elements = elements;\n    }\n\n    @Override public Ord<E> get(int index) {\n      return Ord.of(index, elements[index]);\n    }\n\n    @Override public int size() {\n      return elements.length;\n    }\n  }", "definition": "  private static class OrdArrayList<E> extends AbstractList<Ord<E>>\n      implements RandomAccess", "class_docstring": " List of {@link Ord} backed by an array of elements.\n\n@param <E> element type", "name": "OrdArrayList", "super_interfaces": ["RandomAccess"], "superclasses": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "fields": [{"attribute_expression": "private final E[] elements;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "E[]", "name": "elements", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    OrdArrayList(E[] elements) {\n      this.elements = elements;\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "OrdArrayList", "params": [{"name": "elements", "type": "E[]"}], "body": "                               {\n      this.elements = elements;\n    }", "signature": "OrdArrayList(E[] elements)"}, {"syntax_pass": true, "original_string": "    @Override public Ord<E> get(int index) {\n      return Ord.of(index, elements[index]);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Ord<E>", "classes": []}, "name": "get", "params": [{"name": "index", "type": "int"}], "body": "                                           {\n      return Ord.of(index, elements[index]);\n    }", "signature": "@Override public Ord<E> get(int index)"}, {"syntax_pass": true, "original_string": "    @Override public int size() {\n      return elements.length;\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "size", "params": [], "body": "                                {\n      return elements.length;\n    }", "signature": "@Override public int size()"}]}], "class_docstring": "\nPair of an element and an ordinal.\n\n@param <E> Element type\n", "original_string": "public class Ord<E> implements Map.Entry<Integer, E> {\n  public final int i;\n  public final E e;\n\n  /**\n   * Creates an Ord.\n   */\n  private Ord(int i, E e) {\n    this.i = i;\n    this.e = e;\n  }\n\n  /**\n   * Creates an Ord.\n   */\n  public static <E> Ord<E> of(int n, E e) {\n    return new Ord<>(n, e);\n  }\n\n  /**\n   * Creates an iterable of {@code Ord}s over an iterable.\n   */\n  public static <E> Iterable<Ord<E>> zip(final Iterable<? extends E> iterable) {\n    return () -> zip(iterable.iterator());\n  }\n\n  /**\n   * Creates an iterator of {@code Ord}s over an iterator.\n   */\n  public static <E> Iterator<Ord<E>> zip(final Iterator<? extends E> iterator) {\n    return new Iterator<Ord<E>>() {\n      int n = 0;\n\n      public boolean hasNext() {\n        return iterator.hasNext();\n      }\n\n      public Ord<E> next() {\n        return Ord.of(n++, iterator.next());\n      }\n\n      public void remove() {\n        iterator.remove();\n      }\n    };\n  }\n\n  /**\n   * Returns a numbered list based on an array.\n   */\n  public static <E> List<Ord<E>> zip(final E[] elements) {\n    return new OrdArrayList<>(elements);\n  }\n\n  /**\n   * Returns a numbered list.\n   */\n  public static <E> List<Ord<E>> zip(final List<? extends E> elements) {\n    return elements instanceof RandomAccess\n        ? new OrdRandomAccessList<>(elements)\n        : new OrdList<>(elements);\n  }\n\n  /**\n   * Performs the given action for each element of the {@code Iterable}.\n   */\n  public static <E> void forEachIndexed(final Iterable<E> iterable,\n      ObjIntConsumer<E> consumer) {\n    int i = 0;\n    for (E e : iterable) {\n      consumer.accept(e, i++);\n    }\n  }\n\n  /**\n   * Performs the given action for each element of the {@code List}.\n   *\n   * <p>More efficient than {@link #forEachIndexed(Iterable, ObjIntConsumer)}\n   * if the list implements {@link RandomAccess}.\n   */\n  public static <E> void forEach(final List<E> list,\n      ObjIntConsumer<E> consumer) {\n    for (int i = 0; i < list.size(); i++) {\n      consumer.accept(list.get(i), i);\n    }\n  }\n\n  /**\n   * Performs the given action for each entry of a {@code Map}.\n   */\n  public static <K, V> void forEachIndexed(final Map<K, V> map,\n      IntObjObjConsumer<K, V> consumer) {\n    int i = 0;\n    for (Map.Entry<K, V> e : map.entrySet()) {\n      consumer.accept(i++, e.getKey(), e.getValue());\n    }\n  }\n\n  /**\n   * Iterates over an array in reverse order.\n   *\n   * <p>Given the array [\"a\", \"b\", \"c\"], returns (2, \"c\") then (1, \"b\") then\n   * (0, \"a\").\n   */\n  public static <E> Iterable<Ord<E>> reverse(E... elements) {\n    return reverse(ImmutableList.copyOf(elements));\n  }\n\n  /**\n   * Iterates over a list in reverse order.\n   *\n   * <p>Given the list [\"a\", \"b\", \"c\"], returns (2, \"c\") then (1, \"b\") then\n   * (0, \"a\").\n   */\n  public static <E> Iterable<Ord<E>> reverse(Iterable<? extends E> elements) {\n    final ImmutableList<E> elementList = ImmutableList.copyOf(elements);\n    return () -> new Iterator<Ord<E>>() {\n      int i = elementList.size() - 1;\n\n      public boolean hasNext() {\n        return i >= 0;\n      }\n\n      public Ord<E> next() {\n        return Ord.of(i, elementList.get(i--));\n      }\n\n      public void remove() {\n        throw new UnsupportedOperationException(\"remove\");\n      }\n    };\n  }\n\n  public Integer getKey() {\n    return i;\n  }\n\n  public E getValue() {\n    return e;\n  }\n\n  public E setValue(E value) {\n    throw new UnsupportedOperationException();\n  }\n\n  /** List of {@link Ord} backed by a list of elements.\n   *\n   * @param <E> element type */\n  private static class OrdList<E> extends AbstractList<Ord<E>> {\n    private final List<? extends E> elements;\n\n    OrdList(List<? extends E> elements) {\n      this.elements = elements;\n    }\n\n    public Ord<E> get(int index) {\n      return Ord.of(index, elements.get(index));\n    }\n\n    public int size() {\n      return elements.size();\n    }\n  }\n\n  /** List of {@link Ord} backed by a random-access list of elements.\n   *\n   * @param <E> element type */\n  private static class OrdRandomAccessList<E> extends OrdList<E>\n      implements RandomAccess {\n    OrdRandomAccessList(List<? extends E> elements) {\n      super(elements);\n    }\n  }\n\n  /** List of {@link Ord} backed by an array of elements.\n   *\n   * @param <E> element type */\n  private static class OrdArrayList<E> extends AbstractList<Ord<E>>\n      implements RandomAccess {\n    private final E[] elements;\n\n    OrdArrayList(E[] elements) {\n      this.elements = elements;\n    }\n\n    @Override public Ord<E> get(int index) {\n      return Ord.of(index, elements[index]);\n    }\n\n    @Override public int size() {\n      return elements.length;\n    }\n  }\n\n  /** Consumer that receives an ordinal, a key, and a value.\n   *\n   * <p>Analogous to {@link BiConsumer}, but with an extra ordinal.\n   *\n   * @see #forEachIndexed(Map, IntObjObjConsumer)\n   *\n   * @param <K> Key type\n   * @param <V> Value type\n   */\n  @FunctionalInterface\n  public interface IntObjObjConsumer<K, V> {\n    void accept(int i, K key, V value);\n  }\n}", "super_interfaces": ["Map.Entry<Integer, E>"], "fields": [{"attribute_expression": "public final int i;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "int", "name": "i", "syntax_pass": true}, {"attribute_expression": "public final E e;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "E", "name": "e", "syntax_pass": true}]}, {"uris": "src/main/java/net/hydromatic/morel/util/ConsList.java.ConsList", "name": "ConsList", "file_path": "src/main/java/net/hydromatic/morel/util/ConsList.java", "superclasses": "", "methods": ["[List<E>]of(E,List<? extends E>)", "[]ConsList(E,List<E>)", "[E]get(int)", "[int]size()", "[int]hashCode()", "[boolean]equals(Object)", "[String]toString()", "[List<E>]toList()", "[ListIterator<E>]listIterator()", "[Iterator<E>]iterator()", "[ListIterator<E>]listIterator(int)", "[Object @NonNull[]]toArray()", "[T @NonNull[]]toArray(T @NonNull[])", "[int]indexOf(Object)", "[int]lastIndexOf(Object)"], "method_uris": ["src/main/java/net/hydromatic/morel/util/ConsList.java.ConsList.[List<E>]of(E,List<? extends E>)", "src/main/java/net/hydromatic/morel/util/ConsList.java.ConsList.[]ConsList(E,List<E>)", "src/main/java/net/hydromatic/morel/util/ConsList.java.ConsList.[E]get(int)", "src/main/java/net/hydromatic/morel/util/ConsList.java.ConsList.[int]size()", "src/main/java/net/hydromatic/morel/util/ConsList.java.ConsList.[int]hashCode()", "src/main/java/net/hydromatic/morel/util/ConsList.java.ConsList.[boolean]equals(Object)", "src/main/java/net/hydromatic/morel/util/ConsList.java.ConsList.[String]toString()", "src/main/java/net/hydromatic/morel/util/ConsList.java.ConsList.[List<E>]toList()", "src/main/java/net/hydromatic/morel/util/ConsList.java.ConsList.[ListIterator<E>]listIterator()", "src/main/java/net/hydromatic/morel/util/ConsList.java.ConsList.[Iterator<E>]iterator()", "src/main/java/net/hydromatic/morel/util/ConsList.java.ConsList.[ListIterator<E>]listIterator(int)", "src/main/java/net/hydromatic/morel/util/ConsList.java.ConsList.[Object @NonNull[]]toArray()", "src/main/java/net/hydromatic/morel/util/ConsList.java.ConsList.[T @NonNull[]]toArray(T @NonNull[])", "src/main/java/net/hydromatic/morel/util/ConsList.java.ConsList.[int]indexOf(Object)", "src/main/java/net/hydromatic/morel/util/ConsList.java.ConsList.[int]lastIndexOf(Object)"], "overrides": null, "attributes": [], "class_docstring": "\nList that consists of a head element and an immutable non-empty list.\n\n@param <E> Element type\n", "original_string": "public class ConsList<E> extends AbstractImmutableList<E> {\n  private final E first;\n  private final List<E> rest;\n\n  /** Creates a ConsList.\n   * It consists of an element pre-pended to another list.\n   * If the other list is mutable, creates an immutable copy. */\n  public static <E> List<E> of(E first, List<? extends E> rest) {\n    if (rest instanceof ConsList\n        || rest instanceof ImmutableList\n        && !rest.isEmpty()) {\n      //noinspection unchecked\n      return new ConsList<>(first, (List<E>) rest);\n    } else {\n      return ImmutableList.<E>builder().add(first).addAll(rest).build();\n    }\n  }\n\n  private ConsList(E first, List<E> rest) {\n    this.first = first;\n    this.rest = rest;\n  }\n\n  public E get(int index) {\n    for (ConsList<E> c = this;; c = (ConsList<E>) c.rest) {\n      if (index == 0) {\n        return c.first;\n      }\n      --index;\n      if (!(c.rest instanceof ConsList)) {\n        return c.rest.get(index);\n      }\n    }\n  }\n\n  @SuppressWarnings(\"rawtypes\")\n  public int size() {\n    int s = 1;\n    for (ConsList c = this;; c = (ConsList) c.rest, ++s) {\n      if (!(c.rest instanceof ConsList)) {\n        return s + c.rest.size();\n      }\n    }\n  }\n\n  @Override public int hashCode() {\n    return toList().hashCode();\n  }\n\n  @Override public boolean equals(Object o) {\n    return o == this\n        || o instanceof List\n        && toList().equals(o);\n  }\n\n  @Override public String toString() {\n    return toList().toString();\n  }\n\n  protected final List<E> toList() {\n    final List<E> list = new ArrayList<>();\n    for (ConsList<E> c = this;; c = (ConsList<E>) c.rest) {\n      list.add(c.first);\n      if (!(c.rest instanceof ConsList)) {\n        list.addAll(c.rest);\n        return list;\n      }\n    }\n  }\n\n  @Override @NonNull public ListIterator<E> listIterator() {\n    return toList().listIterator();\n  }\n\n  @Override @NonNull public Iterator<E> iterator() {\n    return toList().iterator();\n  }\n\n  @Override @NonNull public ListIterator<E> listIterator(int index) {\n    return toList().listIterator(index);\n  }\n\n  public @Nullable Object @NonNull[] toArray() {\n    return toList().toArray();\n  }\n\n  @SuppressWarnings(\"rawtypes\")\n  public <T> @Nullable T @NonNull[] toArray(@Nullable T @NonNull[] a) {\n    final int s = size();\n    if (s > a.length) {\n      a = Arrays.copyOf(a, s);\n    } else if (s < a.length) {\n      a[s] = null;\n    }\n    int i = 0;\n    for (ConsList c = this;; c = (ConsList) c.rest) {\n      //noinspection unchecked\n      a[i++] = (T) c.first;\n      if (!(c.rest instanceof ConsList)) {\n        Object[] a2 = c.rest.toArray();\n        //noinspection SuspiciousSystemArraycopy\n        System.arraycopy(a2, 0, a, i, a2.length);\n        return a;\n      }\n    }\n  }\n\n  public int indexOf(Object o) {\n    return toList().indexOf(o);\n  }\n\n  public int lastIndexOf(Object o) {\n    return toList().lastIndexOf(o);\n  }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private final E first;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "E", "name": "first", "syntax_pass": true}, {"attribute_expression": "private final List<E> rest;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "List<E>", "name": "rest", "syntax_pass": true}]}, {"uris": "src/main/java/net/hydromatic/morel/util/TailList.java.TailList", "name": "TailList", "file_path": "src/main/java/net/hydromatic/morel/util/TailList.java", "superclasses": "", "methods": ["[]TailList(List<E>,int)", "[]TailList(List<E>)", "[E]get(int)", "[int]size()", "[void]clear()", "[boolean]add(E)", "[void]add(int,E)", "[boolean]addAll(int,Collection<? extends E>)", "[boolean]addAll(Collection<? extends E>)", "[E]remove(int)", "[E]set(int,E)"], "method_uris": ["src/main/java/net/hydromatic/morel/util/TailList.java.TailList.[]TailList(List<E>,int)", "src/main/java/net/hydromatic/morel/util/TailList.java.TailList.[]TailList(List<E>)", "src/main/java/net/hydromatic/morel/util/TailList.java.TailList.[E]get(int)", "src/main/java/net/hydromatic/morel/util/TailList.java.TailList.[int]size()", "src/main/java/net/hydromatic/morel/util/TailList.java.TailList.[void]clear()", "src/main/java/net/hydromatic/morel/util/TailList.java.TailList.[boolean]add(E)", "src/main/java/net/hydromatic/morel/util/TailList.java.TailList.[void]add(int,E)", "src/main/java/net/hydromatic/morel/util/TailList.java.TailList.[boolean]addAll(int,Collection<? extends E>)", "src/main/java/net/hydromatic/morel/util/TailList.java.TailList.[boolean]addAll(Collection<? extends E>)", "src/main/java/net/hydromatic/morel/util/TailList.java.TailList.[E]remove(int)", "src/main/java/net/hydromatic/morel/util/TailList.java.TailList.[E]set(int,E)"], "overrides": null, "attributes": [], "class_docstring": " A dynamic list that reads from a given point in a backing list.\n\n@param <E> Element type", "original_string": "public class TailList<E> extends AbstractList<E> {\n  private final List<E> list;\n  private final int start;\n\n  /** Creates a list that reads elements from a given backing list\n   * after a given start point.\n   *\n   * @param list Backing list\n   * @param start Start point\n   */\n  public TailList(List<E> list, int start) {\n    this.list = requireNonNull(list);\n    this.start = start;\n  }\n\n  /** Creates a list whose start is the current size of the backing list.\n   *\n   * <p>Thus only elements appended to the backing list after creation will\n   * appear in this list. */\n  public TailList(List<E> list) {\n    this(list, list.size());\n  }\n\n  @Override public E get(int index) {\n    return list.get(start + index);\n  }\n\n  @Override public int size() {\n    return list.size() - start;\n  }\n\n  @Override public void clear() {\n    while (list.size() > start) {\n      list.remove(list.size() - 1);\n    }\n  }\n\n  @Override public boolean add(E e) {\n    return list.add(e);\n  }\n\n  @Override public void add(int index, E element) {\n    list.add(start + index, element);\n  }\n\n  @Override public boolean addAll(int index, Collection<? extends E> c) {\n    return list.addAll(start + index, c);\n  }\n\n  @Override public boolean addAll(Collection<? extends E> c) {\n    return list.addAll(c);\n  }\n\n  @Override public E remove(int index) {\n    return list.remove(start + index);\n  }\n\n  @Override public E set(int index, E element) {\n    return list.set(start + index, element);\n  }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private final List<E> list;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "List<E>", "name": "list", "syntax_pass": true}, {"attribute_expression": "private final int start;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "int", "name": "start", "syntax_pass": true}]}, {"uris": "src/main/java/net/hydromatic/morel/util/MapEntry.java.MapEntry", "name": "MapEntry", "file_path": "src/main/java/net/hydromatic/morel/util/MapEntry.java", "superclasses": "", "methods": ["[]MapEntry(T,U)", "[String]toString()", "[boolean]equals(Object)", "[int]hashCode()", "[T]getKey()", "[U]getValue()", "[U]setValue(U)"], "method_uris": ["src/main/java/net/hydromatic/morel/util/MapEntry.java.MapEntry.[]MapEntry(T,U)", "src/main/java/net/hydromatic/morel/util/MapEntry.java.MapEntry.[String]toString()", "src/main/java/net/hydromatic/morel/util/MapEntry.java.MapEntry.[boolean]equals(Object)", "src/main/java/net/hydromatic/morel/util/MapEntry.java.MapEntry.[int]hashCode()", "src/main/java/net/hydromatic/morel/util/MapEntry.java.MapEntry.[T]getKey()", "src/main/java/net/hydromatic/morel/util/MapEntry.java.MapEntry.[U]getValue()", "src/main/java/net/hydromatic/morel/util/MapEntry.java.MapEntry.[U]setValue(U)"], "overrides": null, "attributes": [], "class_docstring": "\nSimple implementation of {@link Map.Entry}.\n\n<p>It is immutable.\n\n<p>Key and value may be null if their types allow.\n\n@param <T> Key type\n@param <U> Value type\n", "original_string": "public class MapEntry<T, U> implements Map.Entry<T, U> {\n  final T t;\n  final U u;\n\n  /** Creates a MapEntry. */\n  public MapEntry(T t, U u) {\n    this.t = t;\n    this.u = u;\n  }\n\n  @Override public String toString() {\n    return \"<\" + t + \", \" + u + \">\";\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * <p>Compares equal to any {@link Map.Entry} with the equal key and value.\n   */\n  @SuppressWarnings(\"unchecked\")\n  @Override public boolean equals(@Nullable Object o) {\n    return this == o\n        || o instanceof Map.Entry\n        && Objects.equals(this.t, ((Map.Entry<T, U>) o).getKey())\n        && Objects.equals(this.u, ((Map.Entry<T, U>) o).getValue());\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * <p>Computes hash code consistent with\n   * {@link Map.Entry#hashCode()}.\n   */\n  @Override public int hashCode() {\n    int keyHash = t == null ? 0 : t.hashCode();\n    int valueHash = u == null ? 0 : u.hashCode();\n    return keyHash ^ valueHash;\n  }\n\n  @Override public T getKey() {\n    return t;\n  }\n\n  @Override public U getValue() {\n    return u;\n  }\n\n  @Override public U setValue(U value) {\n    throw new UnsupportedOperationException(\"setValue\");\n  }\n}", "super_interfaces": ["Map.Entry<T, U>"], "fields": [{"attribute_expression": "final T t;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "T", "name": "t", "syntax_pass": true}, {"attribute_expression": "final U u;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "U", "name": "u", "syntax_pass": true}]}, {"uris": "src/main/java/net/hydromatic/morel/util/Tracers.java.Tracers", "name": "Tracers", "file_path": "src/main/java/net/hydromatic/morel/util/Tracers.java", "superclasses": "", "methods": ["[]Tracers()", "[Unifier.Tracer]nullTracer()", "[Unifier.Tracer]printTracer(PrintWriter)", "[Unifier.Tracer]printTracer(OutputStream)"], "method_uris": ["src/main/java/net/hydromatic/morel/util/Tracers.java.Tracers.[]Tracers()", "src/main/java/net/hydromatic/morel/util/Tracers.java.Tracers.[Unifier.Tracer]nullTracer()", "src/main/java/net/hydromatic/morel/util/Tracers.java.Tracers.[Unifier.Tracer]printTracer(PrintWriter)", "src/main/java/net/hydromatic/morel/util/Tracers.java.Tracers.[Unifier.Tracer]printTracer(OutputStream)"], "overrides": null, "attributes": [{"original_string": "  private static class NullTracer implements Unifier.Tracer {\n    public void onDelete(Unifier.Term left, Unifier.Term right) { }\n    public void onConflict(Unifier.Sequence left, Unifier.Sequence right) { }\n    public void onSequence(Unifier.Sequence left, Unifier.Sequence right) { }\n    public void onSwap(Unifier.Term left, Unifier.Term right) { }\n    public void onCycle(Unifier.Variable variable, Unifier.Term term) { }\n    public void onVariable(Unifier.Variable variable, Unifier.Term term) { }\n    public void onSubstitute(Unifier.Term left, Unifier.Term right,\n        Unifier.Term left2, Unifier.Term right2) { }\n  }", "definition": "  private static class NullTracer implements Unifier.Tracer", "class_docstring": " Implementation of {@link Unifier.Tracer} that does nothing.", "name": "NullTracer", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    public void onDelete(Unifier.Term left, Unifier.Term right) { }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "onDelete", "params": [{"name": "left", "type": "Unifier.Term"}, {"name": "right", "type": "Unifier.Term"}], "body": "                                                                { }", "signature": "public void onDelete(Unifier.Term left, Unifier.Term right)"}, {"syntax_pass": true, "original_string": "    public void onConflict(Unifier.Sequence left, Unifier.Sequence right) { }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "onConflict", "params": [{"name": "left", "type": "Unifier.Sequence"}, {"name": "right", "type": "Unifier.Sequence"}], "body": "                                                                          { }", "signature": "public void onConflict(Unifier.Sequence left, Unifier.Sequence right)"}, {"syntax_pass": true, "original_string": "    public void onSequence(Unifier.Sequence left, Unifier.Sequence right) { }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "onSequence", "params": [{"name": "left", "type": "Unifier.Sequence"}, {"name": "right", "type": "Unifier.Sequence"}], "body": "                                                                          { }", "signature": "public void onSequence(Unifier.Sequence left, Unifier.Sequence right)"}, {"syntax_pass": true, "original_string": "    public void onSwap(Unifier.Term left, Unifier.Term right) { }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "onSwap", "params": [{"name": "left", "type": "Unifier.Term"}, {"name": "right", "type": "Unifier.Term"}], "body": "                                                              { }", "signature": "public void onSwap(Unifier.Term left, Unifier.Term right)"}, {"syntax_pass": true, "original_string": "    public void onCycle(Unifier.Variable variable, Unifier.Term term) { }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "onCycle", "params": [{"name": "variable", "type": "Unifier.Variable"}, {"name": "term", "type": "Unifier.Term"}], "body": "                                                                      { }", "signature": "public void onCycle(Unifier.Variable variable, Unifier.Term term)"}, {"syntax_pass": true, "original_string": "    public void onVariable(Unifier.Variable variable, Unifier.Term term) { }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "onVariable", "params": [{"name": "variable", "type": "Unifier.Variable"}, {"name": "term", "type": "Unifier.Term"}], "body": "                                                                         { }", "signature": "public void onVariable(Unifier.Variable variable, Unifier.Term term)"}, {"syntax_pass": true, "original_string": "    public void onSubstitute(Unifier.Term left, Unifier.Term right,\n        Unifier.Term left2, Unifier.Term right2) { }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "onSubstitute", "params": [{"name": "left", "type": "Unifier.Term"}, {"name": "right", "type": "Unifier.Term"}, {"name": "left2", "type": "Unifier.Term"}, {"name": "right2", "type": "Unifier.Term"}], "body": "                                                 { }", "signature": "public void onSubstitute(Unifier.Term left, Unifier.Term right,\n        Unifier.Term left2, Unifier.Term right2)"}]}, {"original_string": "  private static class PrintTracer implements Unifier.Tracer {\n    private final StringBuilder b = new StringBuilder();\n    private final PrintWriter w;\n\n    PrintTracer(PrintWriter w) {\n      this.w = requireNonNull(w);\n    }\n\n    private void flush() {\n      w.println(str(b));\n      w.flush();\n    }\n\n    public void onDelete(Unifier.Term left, Unifier.Term right) {\n      b.append(\"delete \").append(left).append(' ').append(right);\n      flush();\n    }\n\n    public void onConflict(Unifier.Sequence left, Unifier.Sequence right) {\n      b.append(\"conflict \").append(left).append(' ').append(right);\n      flush();\n    }\n\n    public void onSequence(Unifier.Sequence left, Unifier.Sequence right) {\n      b.append(\"sequence \").append(left).append(' ').append(right);\n      flush();\n    }\n\n    public void onSwap(Unifier.Term left, Unifier.Term right) {\n      b.append(\"swap \").append(left).append(' ').append(right);\n      flush();\n    }\n\n    public void onCycle(Unifier.Variable variable, Unifier.Term term) {\n      b.append(\"cycle \").append(variable).append(' ').append(term);\n      flush();\n    }\n\n    public void onVariable(Unifier.Variable variable, Unifier.Term term) {\n      b.append(\"variable \").append(variable).append(' ').append(term);\n      flush();\n    }\n\n    public void onSubstitute(Unifier.Term left, Unifier.Term right,\n        Unifier.Term left2, Unifier.Term right2) {\n      b.append(\"substitute \").append(left).append(' ').append(right);\n      if (left2 != left) {\n        b.append(\"; \").append(left).append(\" -> \").append(left2);\n      }\n      if (right2 != right) {\n        b.append(\"; \").append(right).append(\" -> \").append(right2);\n      }\n      flush();\n    }\n  }", "definition": "  private static class PrintTracer implements Unifier.Tracer", "class_docstring": " Implementation of {@link Unifier.Tracer} that writes to a given\n{@link PrintWriter}.", "name": "PrintTracer", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "fields": [{"attribute_expression": "private final StringBuilder b = new StringBuilder();", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "StringBuilder", "name": "b = new StringBuilder()", "syntax_pass": true}, {"attribute_expression": "private final PrintWriter w;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "PrintWriter", "name": "w", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    PrintTracer(PrintWriter w) {\n      this.w = requireNonNull(w);\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "PrintTracer", "params": [{"name": "w", "type": "PrintWriter"}], "body": "                               {\n      this.w = requireNonNull(w);\n    }", "signature": "PrintTracer(PrintWriter w)"}, {"syntax_pass": true, "original_string": "    private void flush() {\n      w.println(str(b));\n      w.flush();\n    }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "name": "flush", "params": [], "body": "                         {\n      w.println(str(b));\n      w.flush();\n    }", "signature": "private void flush()"}, {"syntax_pass": true, "original_string": "    public void onDelete(Unifier.Term left, Unifier.Term right) {\n      b.append(\"delete \").append(left).append(' ').append(right);\n      flush();\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "onDelete", "params": [{"name": "left", "type": "Unifier.Term"}, {"name": "right", "type": "Unifier.Term"}], "body": "                                                                {\n      b.append(\"delete \").append(left).append(' ').append(right);\n      flush();\n    }", "signature": "public void onDelete(Unifier.Term left, Unifier.Term right)"}, {"syntax_pass": true, "original_string": "    public void onConflict(Unifier.Sequence left, Unifier.Sequence right) {\n      b.append(\"conflict \").append(left).append(' ').append(right);\n      flush();\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "onConflict", "params": [{"name": "left", "type": "Unifier.Sequence"}, {"name": "right", "type": "Unifier.Sequence"}], "body": "                                                                          {\n      b.append(\"conflict \").append(left).append(' ').append(right);\n      flush();\n    }", "signature": "public void onConflict(Unifier.Sequence left, Unifier.Sequence right)"}, {"syntax_pass": true, "original_string": "    public void onSequence(Unifier.Sequence left, Unifier.Sequence right) {\n      b.append(\"sequence \").append(left).append(' ').append(right);\n      flush();\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "onSequence", "params": [{"name": "left", "type": "Unifier.Sequence"}, {"name": "right", "type": "Unifier.Sequence"}], "body": "                                                                          {\n      b.append(\"sequence \").append(left).append(' ').append(right);\n      flush();\n    }", "signature": "public void onSequence(Unifier.Sequence left, Unifier.Sequence right)"}, {"syntax_pass": true, "original_string": "    public void onSwap(Unifier.Term left, Unifier.Term right) {\n      b.append(\"swap \").append(left).append(' ').append(right);\n      flush();\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "onSwap", "params": [{"name": "left", "type": "Unifier.Term"}, {"name": "right", "type": "Unifier.Term"}], "body": "                                                              {\n      b.append(\"swap \").append(left).append(' ').append(right);\n      flush();\n    }", "signature": "public void onSwap(Unifier.Term left, Unifier.Term right)"}, {"syntax_pass": true, "original_string": "    public void onCycle(Unifier.Variable variable, Unifier.Term term) {\n      b.append(\"cycle \").append(variable).append(' ').append(term);\n      flush();\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "onCycle", "params": [{"name": "variable", "type": "Unifier.Variable"}, {"name": "term", "type": "Unifier.Term"}], "body": "                                                                      {\n      b.append(\"cycle \").append(variable).append(' ').append(term);\n      flush();\n    }", "signature": "public void onCycle(Unifier.Variable variable, Unifier.Term term)"}, {"syntax_pass": true, "original_string": "    public void onVariable(Unifier.Variable variable, Unifier.Term term) {\n      b.append(\"variable \").append(variable).append(' ').append(term);\n      flush();\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "onVariable", "params": [{"name": "variable", "type": "Unifier.Variable"}, {"name": "term", "type": "Unifier.Term"}], "body": "                                                                         {\n      b.append(\"variable \").append(variable).append(' ').append(term);\n      flush();\n    }", "signature": "public void onVariable(Unifier.Variable variable, Unifier.Term term)"}, {"syntax_pass": true, "original_string": "    public void onSubstitute(Unifier.Term left, Unifier.Term right,\n        Unifier.Term left2, Unifier.Term right2) {\n      b.append(\"substitute \").append(left).append(' ').append(right);\n      if (left2 != left) {\n        b.append(\"; \").append(left).append(\" -> \").append(left2);\n      }\n      if (right2 != right) {\n        b.append(\"; \").append(right).append(\" -> \").append(right2);\n      }\n      flush();\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "onSubstitute", "params": [{"name": "left", "type": "Unifier.Term"}, {"name": "right", "type": "Unifier.Term"}, {"name": "left2", "type": "Unifier.Term"}, {"name": "right2", "type": "Unifier.Term"}], "body": "                                                 {\n      b.append(\"substitute \").append(left).append(' ').append(right);\n      if (left2 != left) {\n        b.append(\"; \").append(left).append(\" -> \").append(left2);\n      }\n      if (right2 != right) {\n        b.append(\"; \").append(right).append(\" -> \").append(right2);\n      }\n      flush();\n    }", "signature": "public void onSubstitute(Unifier.Term left, Unifier.Term right,\n        Unifier.Term left2, Unifier.Term right2)"}]}], "class_docstring": " Implementations of {@link net.hydromatic.morel.util.Unifier.Tracer}.", "original_string": "public class Tracers {\n\n  private static final NullTracer NULL_TRACER = new NullTracer();\n\n  private Tracers() {}\n\n  /** Returns a tracer that does nothing. */\n  public static Unifier.Tracer nullTracer() {\n    return NULL_TRACER;\n  }\n\n  /** Returns a tracer that writes debugging messages to a writer. */\n  public static Unifier.Tracer printTracer(PrintWriter w) {\n    return new PrintTracer(w);\n  }\n\n  /** Returns a tracer that writes debugging messages to a stream. */\n  public static Unifier.Tracer printTracer(OutputStream stream) {\n    return printTracer(new PrintWriter(stream));\n  }\n\n  /** Implementation of {@link Unifier.Tracer} that does nothing. */\n  private static class NullTracer implements Unifier.Tracer {\n    public void onDelete(Unifier.Term left, Unifier.Term right) { }\n    public void onConflict(Unifier.Sequence left, Unifier.Sequence right) { }\n    public void onSequence(Unifier.Sequence left, Unifier.Sequence right) { }\n    public void onSwap(Unifier.Term left, Unifier.Term right) { }\n    public void onCycle(Unifier.Variable variable, Unifier.Term term) { }\n    public void onVariable(Unifier.Variable variable, Unifier.Term term) { }\n    public void onSubstitute(Unifier.Term left, Unifier.Term right,\n        Unifier.Term left2, Unifier.Term right2) { }\n  }\n\n  /** Implementation of {@link Unifier.Tracer} that writes to a given\n   * {@link PrintWriter}. */\n  private static class PrintTracer implements Unifier.Tracer {\n    private final StringBuilder b = new StringBuilder();\n    private final PrintWriter w;\n\n    PrintTracer(PrintWriter w) {\n      this.w = requireNonNull(w);\n    }\n\n    private void flush() {\n      w.println(str(b));\n      w.flush();\n    }\n\n    public void onDelete(Unifier.Term left, Unifier.Term right) {\n      b.append(\"delete \").append(left).append(' ').append(right);\n      flush();\n    }\n\n    public void onConflict(Unifier.Sequence left, Unifier.Sequence right) {\n      b.append(\"conflict \").append(left).append(' ').append(right);\n      flush();\n    }\n\n    public void onSequence(Unifier.Sequence left, Unifier.Sequence right) {\n      b.append(\"sequence \").append(left).append(' ').append(right);\n      flush();\n    }\n\n    public void onSwap(Unifier.Term left, Unifier.Term right) {\n      b.append(\"swap \").append(left).append(' ').append(right);\n      flush();\n    }\n\n    public void onCycle(Unifier.Variable variable, Unifier.Term term) {\n      b.append(\"cycle \").append(variable).append(' ').append(term);\n      flush();\n    }\n\n    public void onVariable(Unifier.Variable variable, Unifier.Term term) {\n      b.append(\"variable \").append(variable).append(' ').append(term);\n      flush();\n    }\n\n    public void onSubstitute(Unifier.Term left, Unifier.Term right,\n        Unifier.Term left2, Unifier.Term right2) {\n      b.append(\"substitute \").append(left).append(' ').append(right);\n      if (left2 != left) {\n        b.append(\"; \").append(left).append(\" -> \").append(left2);\n      }\n      if (right2 != right) {\n        b.append(\"; \").append(right).append(\" -> \").append(right2);\n      }\n      flush();\n    }\n  }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final NullTracer NULL_TRACER = new NullTracer();", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "NullTracer", "name": "NULL_TRACER = new NullTracer()", "syntax_pass": true}]}, {"uris": "src/main/java/net/hydromatic/morel/util/RobinsonUnifier.java.RobinsonUnifier", "name": "RobinsonUnifier", "file_path": "src/main/java/net/hydromatic/morel/util/RobinsonUnifier.java", "superclasses": "Unifier", "methods": ["[Map<Variable, Term>]compose(Map<Variable, Term>,Map<Variable, Term>)", "[Result]sequenceUnify(Sequence,Sequence)", "[Result]unify(List<TermTerm>,Map<Variable, Action>,Tracer)", "[Result]unify(Term,Term)"], "method_uris": ["src/main/java/net/hydromatic/morel/util/RobinsonUnifier.java.RobinsonUnifier.[Map<Variable, Term>]compose(Map<Variable, Term>,Map<Variable, Term>)", "src/main/java/net/hydromatic/morel/util/RobinsonUnifier.java.RobinsonUnifier.[Result]sequenceUnify(Sequence,Sequence)", "src/main/java/net/hydromatic/morel/util/RobinsonUnifier.java.RobinsonUnifier.[Result]unify(List<TermTerm>,Map<Variable, Action>,Tracer)", "src/main/java/net/hydromatic/morel/util/RobinsonUnifier.java.RobinsonUnifier.[Result]unify(Term,Term)"], "overrides": null, "attributes": [], "class_docstring": " Robinson's unification algorithm.", "original_string": "public class RobinsonUnifier extends Unifier {\n  /**\n   * Applies s1 to the elements of s2 and adds them into a single list.\n   */\n  static Map<Variable, Term> compose(Map<Variable, Term> s1,\n      Map<Variable, Term> s2) {\n    Map<Variable, Term> composed = new HashMap<>(s1);\n    s2.forEach((key, value) -> composed.put(key, value.apply(s1)));\n    return composed;\n  }\n\n  private @NonNull Result sequenceUnify(Sequence lhs,\n      Sequence rhs) {\n    if (lhs.terms.size() != rhs.terms.size()) {\n      return failure(\"sequences have different length: \" + lhs + \", \" + rhs);\n    }\n    if (!lhs.operator.equals(rhs.operator)) {\n      return failure(\"sequences have different operator: \" + lhs + \", \" + rhs);\n    }\n    if (lhs.terms.isEmpty()) {\n      return SubstitutionResult.EMPTY;\n    }\n    Term firstLhs = lhs.terms.get(0);\n    Term firstRhs = rhs.terms.get(0);\n    final Result r1 = unify(firstLhs, firstRhs);\n    if (!(r1 instanceof Substitution)) {\n      return r1;\n    }\n    final Substitution subs1 = (Substitution) r1;\n    Sequence restLhs =\n        sequenceApply(lhs.operator, subs1.resultMap, skip(lhs.terms));\n    Sequence restRhs =\n        sequenceApply(rhs.operator, subs1.resultMap, skip(rhs.terms));\n    final Result r2 = sequenceUnify(restLhs, restRhs);\n    if (!(r2 instanceof Substitution)) {\n      return r2;\n    }\n    final Substitution subs2 = (Substitution) r2;\n    final Map<Variable, Term> joined =\n        ImmutableSortedMap.<Variable, Term>naturalOrder()\n            .putAll(subs1.resultMap)\n            .putAll(subs2.resultMap)\n            .build();\n    return SubstitutionResult.create(joined);\n  }\n\n  public @NonNull Result unify(List<TermTerm> termPairs,\n      Map<Variable, Action> termActions, Tracer tracer) {\n    switch (termPairs.size()) {\n    case 1:\n      return unify(termPairs.get(0).left, termPairs.get(0).right);\n    default:\n      throw new AssertionError();\n    }\n  }\n\n  public @NonNull Result unify(Term lhs, Term rhs) {\n    if (lhs instanceof Variable) {\n      return SubstitutionResult.create((Variable) lhs, rhs);\n    }\n    if (rhs instanceof Variable) {\n      return SubstitutionResult.create((Variable) rhs, lhs);\n    }\n    if (lhs instanceof Sequence && rhs instanceof Sequence) {\n      return sequenceUnify((Sequence) lhs, (Sequence) rhs);\n    }\n    return failure(\"terms have different types: \" + lhs + \", \" + rhs);\n  }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/main/java/net/hydromatic/morel/util/Pair.java.Pair", "name": "Pair", "file_path": "src/main/java/net/hydromatic/morel/util/Pair.java", "superclasses": "", "methods": ["[]Pair(T1,T2)", "[Pair<T1, T2>]of(T1,T2)", "[Pair<K, V>]of(Map.Entry<K, V>)", "[boolean]equals(Object)", "[int]hashCode()", "[int]compareTo(Pair<T1, T2>)", "[String]toString()", "[T1]getKey()", "[T2]getValue()", "[T2]setValue(T2)", "[int]compare(C,C)", "[Map<K, V>]toMap(Iterable<Pair<K, V>>)", "[List<Pair<K, V>>]zip(List<K>,List<V>)", "[List<Pair<K, V>>]zip(List<K>,List<V>,boolean)", "[boolean]allMatch(Iterable<K>,Iterable<V>,BiPredicate<K, V>)", "[boolean]noneMatch(Iterable<K>,Iterable<V>,BiPredicate<K, V>)", "[boolean]anyMatch(Iterable<K>,Iterable<V>,BiPredicate<K, V>)", "[void]forEach(Iterable<K>,Iterable<V>,BiConsumer<K, V>)", "[void]forEachIndexed(Iterable<? extends K>,Iterable<? extends V>,PairWithOrdinalConsumer<K, V>)", "[void]forEachIndexed(List<? extends K>,List<? extends V>,PairWithOrdinalConsumer<K, V>)", "[void]forEachIndexed(Iterable<? extends Map.Entry<K, V>>,PairWithOrdinalConsumer<K, V>)", "[void]forEachIndexed(Map<K, V>,PairWithOrdinalConsumer<K, V>)", "[Iterable<Pair<K, V>>]zip(Iterable<? extends K>,Iterable<? extends V>)", "[List<Pair<K, V>>]zip(K[],V[])", "[List<Pair<K, V>>]zipMutable(List<K>,List<V>)", "[void]forEach(Iterable<? extends Map.Entry<? extends K, ? extends V>>,BiConsumer<K, V>)", "[Iterable<L>]left(Iterable<? extends Map.Entry<L, R>>)", "[Iterable<R>]right(Iterable<? extends Map.Entry<L, R>>)", "[List<K>]left(List<? extends Map.Entry<K, V>>)", "[List<V>]right(List<? extends Map.Entry<K, V>>)", "[Iterable<Pair<T, T>>]adjacents(Iterable<T>)", "[Iterable<Pair<T, T>>]firstAnd(Iterable<T>)"], "method_uris": ["src/main/java/net/hydromatic/morel/util/Pair.java.Pair.[]Pair(T1,T2)", "src/main/java/net/hydromatic/morel/util/Pair.java.Pair.[Pair<T1, T2>]of(T1,T2)", "src/main/java/net/hydromatic/morel/util/Pair.java.Pair.[Pair<K, V>]of(Map.Entry<K, V>)", "src/main/java/net/hydromatic/morel/util/Pair.java.Pair.[boolean]equals(Object)", "src/main/java/net/hydromatic/morel/util/Pair.java.Pair.[int]hashCode()", "src/main/java/net/hydromatic/morel/util/Pair.java.Pair.[int]compareTo(Pair<T1, T2>)", "src/main/java/net/hydromatic/morel/util/Pair.java.Pair.[String]toString()", "src/main/java/net/hydromatic/morel/util/Pair.java.Pair.[T1]getKey()", "src/main/java/net/hydromatic/morel/util/Pair.java.Pair.[T2]getValue()", "src/main/java/net/hydromatic/morel/util/Pair.java.Pair.[T2]setValue(T2)", "src/main/java/net/hydromatic/morel/util/Pair.java.Pair.[int]compare(C,C)", "src/main/java/net/hydromatic/morel/util/Pair.java.Pair.[Map<K, V>]toMap(Iterable<Pair<K, V>>)", "src/main/java/net/hydromatic/morel/util/Pair.java.Pair.[List<Pair<K, V>>]zip(List<K>,List<V>)", "src/main/java/net/hydromatic/morel/util/Pair.java.Pair.[List<Pair<K, V>>]zip(List<K>,List<V>,boolean)", "src/main/java/net/hydromatic/morel/util/Pair.java.Pair.[boolean]allMatch(Iterable<K>,Iterable<V>,BiPredicate<K, V>)", "src/main/java/net/hydromatic/morel/util/Pair.java.Pair.[boolean]noneMatch(Iterable<K>,Iterable<V>,BiPredicate<K, V>)", "src/main/java/net/hydromatic/morel/util/Pair.java.Pair.[boolean]anyMatch(Iterable<K>,Iterable<V>,BiPredicate<K, V>)", "src/main/java/net/hydromatic/morel/util/Pair.java.Pair.[void]forEach(Iterable<K>,Iterable<V>,BiConsumer<K, V>)", "src/main/java/net/hydromatic/morel/util/Pair.java.Pair.[void]forEachIndexed(Iterable<? extends K>,Iterable<? extends V>,PairWithOrdinalConsumer<K, V>)", "src/main/java/net/hydromatic/morel/util/Pair.java.Pair.[void]forEachIndexed(List<? extends K>,List<? extends V>,PairWithOrdinalConsumer<K, V>)", "src/main/java/net/hydromatic/morel/util/Pair.java.Pair.[void]forEachIndexed(Iterable<? extends Map.Entry<K, V>>,PairWithOrdinalConsumer<K, V>)", "src/main/java/net/hydromatic/morel/util/Pair.java.Pair.[void]forEachIndexed(Map<K, V>,PairWithOrdinalConsumer<K, V>)", "src/main/java/net/hydromatic/morel/util/Pair.java.Pair.[Iterable<Pair<K, V>>]zip(Iterable<? extends K>,Iterable<? extends V>)", "src/main/java/net/hydromatic/morel/util/Pair.java.Pair.[List<Pair<K, V>>]zip(K[],V[])", "src/main/java/net/hydromatic/morel/util/Pair.java.Pair.[List<Pair<K, V>>]zipMutable(List<K>,List<V>)", "src/main/java/net/hydromatic/morel/util/Pair.java.Pair.[void]forEach(Iterable<? extends Map.Entry<? extends K, ? extends V>>,BiConsumer<K, V>)", "src/main/java/net/hydromatic/morel/util/Pair.java.Pair.[Iterable<L>]left(Iterable<? extends Map.Entry<L, R>>)", "src/main/java/net/hydromatic/morel/util/Pair.java.Pair.[Iterable<R>]right(Iterable<? extends Map.Entry<L, R>>)", "src/main/java/net/hydromatic/morel/util/Pair.java.Pair.[List<K>]left(List<? extends Map.Entry<K, V>>)", "src/main/java/net/hydromatic/morel/util/Pair.java.Pair.[List<V>]right(List<? extends Map.Entry<K, V>>)", "src/main/java/net/hydromatic/morel/util/Pair.java.Pair.[Iterable<Pair<T, T>>]adjacents(Iterable<T>)", "src/main/java/net/hydromatic/morel/util/Pair.java.Pair.[Iterable<Pair<T, T>>]firstAnd(Iterable<T>)"], "overrides": null, "attributes": [{"original_string": "  private static class LeftIterator<L, R> implements Iterator<L> {\n    private final Iterator<? extends Map.Entry<L, R>> iterator;\n\n    LeftIterator(Iterator<? extends Map.Entry<L, R>> iterator) {\n      this.iterator = requireNonNull(iterator);\n    }\n\n    public boolean hasNext() {\n      return iterator.hasNext();\n    }\n\n    public L next() {\n      return iterator.next().getKey();\n    }\n\n    public void remove() {\n      iterator.remove();\n    }\n  }", "definition": "  private static class LeftIterator<L, R> implements Iterator<L>", "class_docstring": " Iterator that returns the left field of each pair.\n\n@param <L> Left-hand type\n@param <R> Right-hand type", "name": "LeftIterator", "super_interfaces": ["Iterator<L>"], "superclasses": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "fields": [{"attribute_expression": "private final Iterator<? extends Map.Entry<L, R>> iterator;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Iterator<? extends Map.Entry<L, R>>", "name": "iterator", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    LeftIterator(Iterator<? extends Map.Entry<L, R>> iterator) {\n      this.iterator = requireNonNull(iterator);\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "LeftIterator", "params": [{"name": "iterator", "type": "Iterator<? extends Map.Entry<L, R>>"}], "body": "                                                               {\n      this.iterator = requireNonNull(iterator);\n    }", "signature": "LeftIterator(Iterator<? extends Map.Entry<L, R>> iterator)"}, {"syntax_pass": true, "original_string": "    public boolean hasNext() {\n      return iterator.hasNext();\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "hasNext", "params": [], "body": "                             {\n      return iterator.hasNext();\n    }", "signature": "public boolean hasNext()"}, {"syntax_pass": true, "original_string": "    public L next() {\n      return iterator.next().getKey();\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "L", "classes": []}, "name": "next", "params": [], "body": "                    {\n      return iterator.next().getKey();\n    }", "signature": "public L next()"}, {"syntax_pass": true, "original_string": "    public void remove() {\n      iterator.remove();\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "remove", "params": [], "body": "                         {\n      iterator.remove();\n    }", "signature": "public void remove()"}]}, {"original_string": "  private static class RightIterator<L, R> implements Iterator<R> {\n    private final Iterator<? extends Map.Entry<L, R>> iterator;\n\n    RightIterator(Iterator<? extends Map.Entry<L, R>> iterator) {\n      this.iterator = requireNonNull(iterator);\n    }\n\n    public boolean hasNext() {\n      return iterator.hasNext();\n    }\n\n    public R next() {\n      return iterator.next().getValue();\n    }\n\n    public void remove() {\n      iterator.remove();\n    }\n  }", "definition": "  private static class RightIterator<L, R> implements Iterator<R>", "class_docstring": " Iterator that returns the right field of each pair.\n\n@param <L> Left-hand type\n@param <R> Right-hand type", "name": "RightIterator", "super_interfaces": ["Iterator<R>"], "superclasses": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "fields": [{"attribute_expression": "private final Iterator<? extends Map.Entry<L, R>> iterator;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Iterator<? extends Map.Entry<L, R>>", "name": "iterator", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    RightIterator(Iterator<? extends Map.Entry<L, R>> iterator) {\n      this.iterator = requireNonNull(iterator);\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "RightIterator", "params": [{"name": "iterator", "type": "Iterator<? extends Map.Entry<L, R>>"}], "body": "                                                                {\n      this.iterator = requireNonNull(iterator);\n    }", "signature": "RightIterator(Iterator<? extends Map.Entry<L, R>> iterator)"}, {"syntax_pass": true, "original_string": "    public boolean hasNext() {\n      return iterator.hasNext();\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "hasNext", "params": [], "body": "                             {\n      return iterator.hasNext();\n    }", "signature": "public boolean hasNext()"}, {"syntax_pass": true, "original_string": "    public R next() {\n      return iterator.next().getValue();\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "R", "classes": []}, "name": "next", "params": [], "body": "                    {\n      return iterator.next().getValue();\n    }", "signature": "public R next()"}, {"syntax_pass": true, "original_string": "    public void remove() {\n      iterator.remove();\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "remove", "params": [], "body": "                         {\n      iterator.remove();\n    }", "signature": "public void remove()"}]}, {"original_string": "  private static class FirstAndIterator<E> implements Iterator<Pair<E, E>> {\n    private final Iterator<E> iterator;\n    private final E first;\n\n    FirstAndIterator(Iterator<E> iterator, E first) {\n      this.iterator = requireNonNull(iterator);\n      this.first = first;\n    }\n\n    public boolean hasNext() {\n      return iterator.hasNext();\n    }\n\n    public Pair<E, E> next() {\n      return of(first, iterator.next());\n    }\n\n    public void remove() {\n      throw new UnsupportedOperationException(\"remove\");\n    }\n  }", "definition": "  private static class FirstAndIterator<E> implements Iterator<Pair<E, E>>", "class_docstring": " Iterator that returns the first element of a collection paired with every\nother element.\n\n@param <E> Element type", "name": "FirstAndIterator", "super_interfaces": ["Iterator<Pair<E, E>>"], "superclasses": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "fields": [{"attribute_expression": "private final Iterator<E> iterator;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Iterator<E>", "name": "iterator", "syntax_pass": true}, {"attribute_expression": "private final E first;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "E", "name": "first", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    FirstAndIterator(Iterator<E> iterator, E first) {\n      this.iterator = requireNonNull(iterator);\n      this.first = first;\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "FirstAndIterator", "params": [{"name": "iterator", "type": "Iterator<E>"}, {"name": "first", "type": "E"}], "body": "                                                    {\n      this.iterator = requireNonNull(iterator);\n      this.first = first;\n    }", "signature": "FirstAndIterator(Iterator<E> iterator, E first)"}, {"syntax_pass": true, "original_string": "    public boolean hasNext() {\n      return iterator.hasNext();\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "hasNext", "params": [], "body": "                             {\n      return iterator.hasNext();\n    }", "signature": "public boolean hasNext()"}, {"syntax_pass": true, "original_string": "    public Pair<E, E> next() {\n      return of(first, iterator.next());\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Pair<E, E>", "classes": []}, "name": "next", "params": [], "body": "                             {\n      return of(first, iterator.next());\n    }", "signature": "public Pair<E, E> next()"}, {"syntax_pass": true, "original_string": "    public void remove() {\n      throw new UnsupportedOperationException(\"remove\");\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "remove", "params": [], "body": "                         {\n      throw new UnsupportedOperationException(\"remove\");\n    }", "signature": "public void remove()"}]}, {"original_string": "  private static class ZipIterator<L, R> implements Iterator<Pair<L, R>> {\n    private final Iterator<? extends L> leftIterator;\n    private final Iterator<? extends R> rightIterator;\n\n    ZipIterator(Iterator<? extends L> leftIterator,\n        Iterator<? extends R> rightIterator) {\n      this.leftIterator = requireNonNull(leftIterator);\n      this.rightIterator = requireNonNull(rightIterator);\n    }\n\n    public boolean hasNext() {\n      return leftIterator.hasNext() && rightIterator.hasNext();\n    }\n\n    public Pair<L, R> next() {\n      return Pair.of(leftIterator.next(), rightIterator.next());\n    }\n\n    public void remove() {\n      leftIterator.remove();\n      rightIterator.remove();\n    }\n  }", "definition": "  private static class ZipIterator<L, R> implements Iterator<Pair<L, R>>", "class_docstring": " Iterator that pairs elements from two iterators.\n\n@param <L> Left-hand type\n@param <R> Right-hand type", "name": "ZipIterator", "super_interfaces": ["Iterator<Pair<L, R>>"], "superclasses": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "fields": [{"attribute_expression": "private final Iterator<? extends L> leftIterator;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Iterator<? extends L>", "name": "leftIterator", "syntax_pass": true}, {"attribute_expression": "private final Iterator<? extends R> rightIterator;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Iterator<? extends R>", "name": "rightIterator", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    ZipIterator(Iterator<? extends L> leftIterator,\n        Iterator<? extends R> rightIterator) {\n      this.leftIterator = requireNonNull(leftIterator);\n      this.rightIterator = requireNonNull(rightIterator);\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "ZipIterator", "params": [{"name": "leftIterator", "type": "Iterator<? extends L>"}, {"name": "rightIterator", "type": "Iterator<? extends R>"}], "body": "                                             {\n      this.leftIterator = requireNonNull(leftIterator);\n      this.rightIterator = requireNonNull(rightIterator);\n    }", "signature": "ZipIterator(Iterator<? extends L> leftIterator,\n        Iterator<? extends R> rightIterator)"}, {"syntax_pass": true, "original_string": "    public boolean hasNext() {\n      return leftIterator.hasNext() && rightIterator.hasNext();\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "hasNext", "params": [], "body": "                             {\n      return leftIterator.hasNext() && rightIterator.hasNext();\n    }", "signature": "public boolean hasNext()"}, {"syntax_pass": true, "original_string": "    public Pair<L, R> next() {\n      return Pair.of(leftIterator.next(), rightIterator.next());\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Pair<L, R>", "classes": []}, "name": "next", "params": [], "body": "                             {\n      return Pair.of(leftIterator.next(), rightIterator.next());\n    }", "signature": "public Pair<L, R> next()"}, {"syntax_pass": true, "original_string": "    public void remove() {\n      leftIterator.remove();\n      rightIterator.remove();\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "remove", "params": [], "body": "                         {\n      leftIterator.remove();\n      rightIterator.remove();\n    }", "signature": "public void remove()"}]}, {"original_string": "  private static class AdjacentIterator<E> implements Iterator<Pair<E, E>> {\n    private final E first;\n    private final Iterator<E> iterator;\n    E previous;\n\n    AdjacentIterator(Iterator<E> iterator) {\n      this.iterator = requireNonNull(iterator);\n      this.first = iterator.next();\n      previous = first;\n    }\n\n    public boolean hasNext() {\n      return iterator.hasNext();\n    }\n\n    public Pair<E, E> next() {\n      final E current = iterator.next();\n      final Pair<E, E> pair = of(previous, current);\n      previous = current;\n      return pair;\n    }\n\n    public void remove() {\n      throw new UnsupportedOperationException(\"remove\");\n    }\n  }", "definition": "  private static class AdjacentIterator<E> implements Iterator<Pair<E, E>>", "class_docstring": " Iterator that returns consecutive pairs of elements from an underlying\niterator.\n\n@param <E> Element type", "name": "AdjacentIterator", "super_interfaces": ["Iterator<Pair<E, E>>"], "superclasses": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "fields": [{"attribute_expression": "private final E first;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "E", "name": "first", "syntax_pass": true}, {"attribute_expression": "private final Iterator<E> iterator;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Iterator<E>", "name": "iterator", "syntax_pass": true}, {"attribute_expression": "E previous;", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "E", "name": "previous", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    AdjacentIterator(Iterator<E> iterator) {\n      this.iterator = requireNonNull(iterator);\n      this.first = iterator.next();\n      previous = first;\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "AdjacentIterator", "params": [{"name": "iterator", "type": "Iterator<E>"}], "body": "                                           {\n      this.iterator = requireNonNull(iterator);\n      this.first = iterator.next();\n      previous = first;\n    }", "signature": "AdjacentIterator(Iterator<E> iterator)"}, {"syntax_pass": true, "original_string": "    public boolean hasNext() {\n      return iterator.hasNext();\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "hasNext", "params": [], "body": "                             {\n      return iterator.hasNext();\n    }", "signature": "public boolean hasNext()"}, {"syntax_pass": true, "original_string": "    public Pair<E, E> next() {\n      final E current = iterator.next();\n      final Pair<E, E> pair = of(previous, current);\n      previous = current;\n      return pair;\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Pair<E, E>", "classes": []}, "name": "next", "params": [], "body": "                             {\n      final E current = iterator.next();\n      final Pair<E, E> pair = of(previous, current);\n      previous = current;\n      return pair;\n    }", "signature": "public Pair<E, E> next()"}, {"syntax_pass": true, "original_string": "    public void remove() {\n      throw new UnsupportedOperationException(\"remove\");\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "remove", "params": [], "body": "                         {\n      throw new UnsupportedOperationException(\"remove\");\n    }", "signature": "public void remove()"}]}, {"original_string": "  private static class ZipList<K, V> extends AbstractList<Pair<K, V>> {\n    private final List<K> ks;\n    private final List<V> vs;\n    private final int size;\n\n    ZipList(List<K> ks, List<V> vs, int size) {\n      this.ks = ks;\n      this.vs = vs;\n      this.size = size;\n    }\n\n    public Pair<K, V> get(int index) {\n      return Pair.of(ks.get(index), vs.get(index));\n    }\n\n    public int size() {\n      return size;\n    }\n  }", "definition": "  private static class ZipList<K, V> extends AbstractList<Pair<K, V>>", "class_docstring": " Unmodifiable list of pairs, backed by a pair of lists.\n\n@param <K> Left-hand type\n@param <V> Right-hand type", "name": "ZipList", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "fields": [{"attribute_expression": "private final List<K> ks;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "List<K>", "name": "ks", "syntax_pass": true}, {"attribute_expression": "private final List<V> vs;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "List<V>", "name": "vs", "syntax_pass": true}, {"attribute_expression": "private final int size;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "int", "name": "size", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    ZipList(List<K> ks, List<V> vs, int size) {\n      this.ks = ks;\n      this.vs = vs;\n      this.size = size;\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "ZipList", "params": [{"name": "ks", "type": "List<K>"}, {"name": "vs", "type": "List<V>"}, {"name": "size", "type": "int"}], "body": "                                              {\n      this.ks = ks;\n      this.vs = vs;\n      this.size = size;\n    }", "signature": "ZipList(List<K> ks, List<V> vs, int size)"}, {"syntax_pass": true, "original_string": "    public Pair<K, V> get(int index) {\n      return Pair.of(ks.get(index), vs.get(index));\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Pair<K, V>", "classes": []}, "name": "get", "params": [{"name": "index", "type": "int"}], "body": "                                     {\n      return Pair.of(ks.get(index), vs.get(index));\n    }", "signature": "public Pair<K, V> get(int index)"}, {"syntax_pass": true, "original_string": "    public int size() {\n      return size;\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "size", "params": [], "body": "                      {\n      return size;\n    }", "signature": "public int size()"}]}, {"original_string": "  private static class MutableZipList<K, V> extends AbstractList<Pair<K, V>> {\n    private final List<K> ks;\n    private final List<V> vs;\n\n    MutableZipList(List<K> ks, List<V> vs) {\n      this.ks = requireNonNull(ks);\n      this.vs = requireNonNull(vs);\n    }\n\n    @Override public Pair<K, V> get(int index) {\n      return Pair.of(ks.get(index), vs.get(index));\n    }\n\n    @Override public int size() {\n      return Math.min(ks.size(), vs.size());\n    }\n\n    @Override public void add(int index, Pair<K, V> pair) {\n      ks.add(index, pair.left);\n      vs.add(index, pair.right);\n    }\n\n    @Override public Pair<K, V> remove(int index) {\n      final K bufferedRow = ks.remove(index);\n      final V stateSet = vs.remove(index);\n      return Pair.of(bufferedRow, stateSet);\n    }\n\n    @Override public Pair<K, V> set(int index, Pair<K, V> pair) {\n      final Pair<K, V> previous = get(index);\n      ks.set(index, pair.left);\n      vs.set(index, pair.right);\n      return previous;\n    }\n  }", "definition": "  private static class MutableZipList<K, V> extends AbstractList<Pair<K, V>>", "class_docstring": " A mutable list of pairs backed by a pair of mutable lists.\n\n<p>Modifications to this list are reflected in the backing lists, and vice\nversa.\n\n@param <K> Key (left) value type\n@param <V> Value (right) value type", "name": "MutableZipList", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "fields": [{"attribute_expression": "private final List<K> ks;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "List<K>", "name": "ks", "syntax_pass": true}, {"attribute_expression": "private final List<V> vs;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "List<V>", "name": "vs", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    MutableZipList(List<K> ks, List<V> vs) {\n      this.ks = requireNonNull(ks);\n      this.vs = requireNonNull(vs);\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "MutableZipList", "params": [{"name": "ks", "type": "List<K>"}, {"name": "vs", "type": "List<V>"}], "body": "                                           {\n      this.ks = requireNonNull(ks);\n      this.vs = requireNonNull(vs);\n    }", "signature": "MutableZipList(List<K> ks, List<V> vs)"}, {"syntax_pass": true, "original_string": "    @Override public Pair<K, V> get(int index) {\n      return Pair.of(ks.get(index), vs.get(index));\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Pair<K, V>", "classes": []}, "name": "get", "params": [{"name": "index", "type": "int"}], "body": "                                               {\n      return Pair.of(ks.get(index), vs.get(index));\n    }", "signature": "@Override public Pair<K, V> get(int index)"}, {"syntax_pass": true, "original_string": "    @Override public int size() {\n      return Math.min(ks.size(), vs.size());\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "size", "params": [], "body": "                                {\n      return Math.min(ks.size(), vs.size());\n    }", "signature": "@Override public int size()"}, {"syntax_pass": true, "original_string": "    @Override public void add(int index, Pair<K, V> pair) {\n      ks.add(index, pair.left);\n      vs.add(index, pair.right);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "add", "params": [{"name": "index", "type": "int"}, {"name": "pair", "type": "Pair<K, V>"}], "body": "                                                          {\n      ks.add(index, pair.left);\n      vs.add(index, pair.right);\n    }", "signature": "@Override public void add(int index, Pair<K, V> pair)"}, {"syntax_pass": true, "original_string": "    @Override public Pair<K, V> remove(int index) {\n      final K bufferedRow = ks.remove(index);\n      final V stateSet = vs.remove(index);\n      return Pair.of(bufferedRow, stateSet);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Pair<K, V>", "classes": []}, "name": "remove", "params": [{"name": "index", "type": "int"}], "body": "                                                  {\n      final K bufferedRow = ks.remove(index);\n      final V stateSet = vs.remove(index);\n      return Pair.of(bufferedRow, stateSet);\n    }", "signature": "@Override public Pair<K, V> remove(int index)"}, {"syntax_pass": true, "original_string": "    @Override public Pair<K, V> set(int index, Pair<K, V> pair) {\n      final Pair<K, V> previous = get(index);\n      ks.set(index, pair.left);\n      vs.set(index, pair.right);\n      return previous;\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Pair<K, V>", "classes": []}, "name": "set", "params": [{"name": "index", "type": "int"}, {"name": "pair", "type": "Pair<K, V>"}], "body": "                                                                {\n      final Pair<K, V> previous = get(index);\n      ks.set(index, pair.left);\n      vs.set(index, pair.right);\n      return previous;\n    }", "signature": "@Override public Pair<K, V> set(int index, Pair<K, V> pair)"}]}], "class_docstring": "\nPair of objects.\n\n<p>Because a pair implements {@link #equals(Object)}, {@link #hashCode()} and\n{@link #compareTo(Pair)}, it can be used in any kind of\n{@link java.util.Collection}.\n\n@param <T1> Left-hand type\n@param <T2> Right-hand type\n", "original_string": "public class Pair<T1, T2> implements Comparable<Pair<T1, T2>>,\n    Map.Entry<T1, T2>, Serializable {\n\n  public final T1 left;\n  public final T2 right;\n\n  /**\n   * Creates a Pair.\n   *\n   * @param left  left value\n   * @param right right value\n   */\n  public Pair(T1 left, T2 right) {\n    this.left = left;\n    this.right = right;\n  }\n\n  /**\n   * Creates a Pair of appropriate type.\n   *\n   * <p>This is a shorthand that allows you to omit implicit types. For\n   * example, you can write:\n   * <blockquote>return Pair.of(s, n);</blockquote>\n   * instead of\n   * <blockquote>return new Pair&lt;String, Integer&gt;(s, n);</blockquote>\n   *\n   * @param left  left value\n   * @param right right value\n   * @return A Pair\n   */\n  public static <T1, T2> Pair<T1, T2> of(T1 left, T2 right) {\n    return new Pair<>(left, right);\n  }\n\n  /** Creates a {@code Pair} from a {@link java.util.Map.Entry}. */\n  public static <K, V> Pair<K, V> of(Map.Entry<K, V> entry) {\n    return of(entry.getKey(), entry.getValue());\n  }\n\n  //~ Methods ----------------------------------------------------------------\n\n  @SuppressWarnings(\"rawtypes\")\n  public boolean equals(Object obj) {\n    return this == obj\n        || obj instanceof Map.Entry\n        && Objects.equals(this.left, ((Map.Entry) obj).getKey())\n        && Objects.equals(this.right, ((Map.Entry) obj).getValue());\n  }\n\n  /** {@inheritDoc}\n   *\n   * <p>Computes hash code consistent with\n   * {@link java.util.Map.Entry#hashCode()}. */\n  @Override public int hashCode() {\n    int keyHash = left == null ? 0 : left.hashCode();\n    int valueHash = right == null ? 0 : right.hashCode();\n    return keyHash ^ valueHash;\n  }\n\n  @SuppressWarnings(\"rawtypes\")\n  public int compareTo(@NonNull Pair<T1, T2> that) {\n    //noinspection unchecked\n    int c = compare((Comparable) this.left, (Comparable) that.left);\n    if (c == 0) {\n      //noinspection unchecked\n      c = compare((Comparable) this.right, (Comparable) that.right);\n    }\n    return c;\n  }\n\n  public String toString() {\n    return left + \"=\" + right;\n  }\n\n  public T1 getKey() {\n    return left;\n  }\n\n  public T2 getValue() {\n    return right;\n  }\n\n  public T2 setValue(T2 value) {\n    throw new UnsupportedOperationException();\n  }\n\n  /**\n   * Compares a pair of comparable values of the same type. Null collates\n   * less than everything else, but equal to itself.\n   *\n   * @param c1 First value\n   * @param c2 Second value\n   * @return a negative integer, zero, or a positive integer if c1\n   * is less than, equal to, or greater than c2.\n   */\n  private static <C extends Comparable<C>> int compare(C c1, C c2) {\n    if (c1 == null) {\n      if (c2 == null) {\n        return 0;\n      } else {\n        return -1;\n      }\n    } else if (c2 == null) {\n      return 1;\n    } else {\n      return c1.compareTo(c2);\n    }\n  }\n\n  /**\n   * Converts a collection of Pairs into a Map.\n   *\n   * <p>This is an obvious thing to do because Pair is similar in structure to\n   * {@link java.util.Map.Entry}.\n   *\n   * <p>The map contains a copy of the collection of Pairs; if you change the\n   * collection, the map does not change.\n   *\n   * @param pairs Collection of Pair objects\n   * @return map with the same contents as the collection\n   */\n  public static <K, V> Map<K, V> toMap(Iterable<Pair<K, V>> pairs) {\n    final Map<K, V> map = new HashMap<>();\n    for (Pair<K, V> pair : pairs) {\n      map.put(pair.left, pair.right);\n    }\n    return map;\n  }\n\n  /**\n   * Converts two lists into a list of {@link Pair}s,\n   * whose length is the lesser of the lengths of the\n   * source lists.\n   *\n   * @param ks Left list\n   * @param vs Right list\n   * @return List of pairs\n   * @see Ord#zip(java.util.List)\n   */\n  public static <K, V> List<Pair<K, V>> zip(List<K> ks, List<V> vs) {\n    return zip(ks, vs, false);\n  }\n\n  /**\n   * Converts two lists into a list of {@link Pair}s.\n   *\n   * <p>The length of the combined list is the lesser of the lengths of the\n   * source lists. But typically the source lists will be the same length.\n   *\n   * @param ks     Left list\n   * @param vs     Right list\n   * @param strict Whether to fail if lists have different size\n   * @return List of pairs\n   * @see Ord#zip(java.util.List)\n   */\n  public static <K, V> List<Pair<K, V>> zip(\n      final List<K> ks,\n      final List<V> vs,\n      boolean strict) {\n    final int size;\n    if (strict) {\n      if (ks.size() != vs.size()) {\n        throw new AssertionError();\n      }\n      size = ks.size();\n    } else {\n      size = Math.min(ks.size(), vs.size());\n    }\n    return new ZipList<>(ks, vs, size);\n  }\n\n  /** Returns whether all pairs match a given predicate. */\n  public static <K, V> boolean allMatch(Iterable<K> ks, Iterable<V> vs,\n      BiPredicate<K, V> predicate) {\n    final Iterator<K> ki = ks.iterator();\n    final Iterator<V> vi = vs.iterator();\n    while (ki.hasNext() && vi.hasNext()) {\n      if (!predicate.test(ki.next(), vi.next())) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /** Returns whether no pair matches a given predicate. */\n  public static <K, V> boolean noneMatch(Iterable<K> ks, Iterable<V> vs,\n      BiPredicate<K, V> predicate) {\n    final Iterator<K> ki = ks.iterator();\n    final Iterator<V> vi = vs.iterator();\n    while (ki.hasNext() && vi.hasNext()) {\n      if (predicate.test(ki.next(), vi.next())) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /** Returns whether any pair matches a given predicate. */\n  public static <K, V> boolean anyMatch(Iterable<K> ks, Iterable<V> vs,\n      BiPredicate<K, V> predicate) {\n    final Iterator<K> ki = ks.iterator();\n    final Iterator<V> vi = vs.iterator();\n    while (ki.hasNext() && vi.hasNext()) {\n      if (predicate.test(ki.next(), vi.next())) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /** Calls a consumer for each pair of items in two iterables. */\n  public static <K, V> void forEach(Iterable<K> ks, Iterable<V> vs,\n      BiConsumer<K, V> consumer) {\n    final Iterator<K> ki = ks.iterator();\n    final Iterator<V> vi = vs.iterator();\n    while (ki.hasNext() && vi.hasNext()) {\n      consumer.accept(ki.next(), vi.next());\n    }\n  }\n\n  /** Calls a consumer with an ordinal for each pair of items in two\n   * iterables. */\n  public static <K, V> void forEachIndexed(Iterable<? extends K> ks,\n      Iterable<? extends V> vs, PairWithOrdinalConsumer<K, V> consumer) {\n    int i = 0;\n    final Iterator<? extends K> ki = ks.iterator();\n    final Iterator<? extends V> vi = vs.iterator();\n    while (ki.hasNext() && vi.hasNext()) {\n      consumer.accept(i++, ki.next(), vi.next());\n    }\n  }\n\n  /** Calls a consumer with an ordinal for each pair of items in two\n   * lists. */\n  public static <K, V> void forEachIndexed(List<? extends K> ks,\n      List<? extends V> vs, PairWithOrdinalConsumer<K, V> consumer) {\n    for (int i = 0, j = Math.min(ks.size(), vs.size()); i < j; i++) {\n      consumer.accept(i, ks.get(i), vs.get(i));\n    }\n  }\n\n  /** Calls a consumer with an ordinal for each pair of items in an iterable\n   * of pairs. */\n  public static <K, V> void forEachIndexed(\n      Iterable<? extends Map.Entry<K, V>> pairs,\n      PairWithOrdinalConsumer<K, V> consumer) {\n    int i = 0;\n    for (Map.Entry<K, V> pair : pairs) {\n      consumer.accept(i++, pair.getKey(), pair.getValue());\n    }\n  }\n\n  /** Calls a consumer for each entry in a map. */\n  public static <K, V> void forEachIndexed(Map<K, V> map,\n      PairWithOrdinalConsumer<K, V> consumer) {\n    forEachIndexed(map.entrySet(), consumer);\n  }\n\n  /**\n   * Converts two iterables into an iterable of {@link Pair}s.\n   *\n   * <p>The resulting iterator ends whenever the first of the input iterators\n   * ends. But typically the source iterators will be the same length.\n   *\n   * @param ks Left iterable\n   * @param vs Right iterable\n   * @return Iterable over pairs\n   */\n  public static <K, V> Iterable<Pair<K, V>> zip(\n      final Iterable<? extends K> ks,\n      final Iterable<? extends V> vs) {\n    return () -> {\n      final Iterator<? extends K> kIterator = ks.iterator();\n      final Iterator<? extends V> vIterator = vs.iterator();\n\n      return new ZipIterator<>(kIterator, vIterator);\n    };\n  }\n\n  /**\n   * Converts two arrays into a list of {@link Pair}s.\n   *\n   * <p>The length of the combined list is the lesser of the lengths of the\n   * source arrays. But typically the source arrays will be the same\n   * length.\n   *\n   * @param ks Left array\n   * @param vs Right array\n   * @return List of pairs\n   */\n  public static <K, V> List<Pair<K, V>> zip(\n      final K[] ks,\n      final V[] vs) {\n    return new AbstractList<Pair<K, V>>() {\n      public Pair<K, V> get(int index) {\n        return Pair.of(ks[index], vs[index]);\n      }\n\n      public int size() {\n        return Math.min(ks.length, vs.length);\n      }\n    };\n  }\n\n  /** Returns a mutable list of pairs backed by a pair of mutable lists.\n   *\n   * <p>Modifications to this list are reflected in the backing lists, and vice\n   * versa.\n   *\n   * @param <K> Key (left) value type\n   * @param <V> Value (right) value type */\n  public static <K, V> List<Pair<K, V>> zipMutable(\n      final List<K> ks,\n      final List<V> vs) {\n    return new MutableZipList<>(ks, vs);\n  }\n\n  /** Applies an action to every element of an iterable of pairs.\n   *\n   * @see Map#forEach(java.util.function.BiConsumer)\n   *\n   * @param entries Pairs\n   * @param consumer The action to be performed for each element\n   *\n   * @param <K> Left type\n   * @param <V> Right type\n   */\n  public static <K, V> void forEach(\n      final Iterable<? extends Map.Entry<? extends K, ? extends V>> entries,\n      BiConsumer<K, V> consumer) {\n    for (Map.Entry<? extends K, ? extends V> entry : entries) {\n      consumer.accept(entry.getKey(), entry.getValue());\n    }\n  }\n\n  /**\n   * Returns an iterable over the left slice of an iterable.\n   *\n   * @param iterable Iterable over pairs\n   * @param <L>      Left type\n   * @param <R>      Right type\n   * @return Iterable over the left elements\n   */\n  public static <L, R> Iterable<L> left(\n      final Iterable<? extends Map.Entry<L, R>> iterable) {\n    return () -> new LeftIterator<>(iterable.iterator());\n  }\n\n  /**\n   * Returns an iterable over the right slice of an iterable.\n   *\n   * @param iterable Iterable over pairs\n   * @param <L>      right type\n   * @param <R>      Right type\n   * @return Iterable over the right elements\n   */\n  public static <L, R> Iterable<R> right(\n      final Iterable<? extends Map.Entry<L, R>> iterable) {\n    return () -> new RightIterator<>(iterable.iterator());\n  }\n\n  public static <K, V> List<K> left(\n      final List<? extends Map.Entry<K, V>> pairs) {\n    return new AbstractList<K>() {\n      public K get(int index) {\n        return pairs.get(index).getKey();\n      }\n\n      public int size() {\n        return pairs.size();\n      }\n    };\n  }\n\n  public static <K, V> List<V> right(\n      final List<? extends Map.Entry<K, V>> pairs) {\n    return new AbstractList<V>() {\n      public V get(int index) {\n        return pairs.get(index).getValue();\n      }\n\n      public int size() {\n        return pairs.size();\n      }\n    };\n  }\n\n  /**\n   * Returns an iterator that iterates over (i, i + 1) pairs in an iterable.\n   *\n   * <p>For example, {@code adjacents([3, 5, 7])} returns [(3, 5), (5, 7)].\n   *\n   * @param iterable Source collection\n   * @param <T> Element type\n   * @return Iterable over adjacent element pairs\n   */\n  public static <T> Iterable<Pair<T, T>> adjacents(final Iterable<T> iterable) {\n    return () -> {\n      final Iterator<T> iterator = iterable.iterator();\n      if (!iterator.hasNext()) {\n        return Collections.emptyIterator();\n      }\n      return new AdjacentIterator<>(iterator);\n    };\n  }\n\n  /**\n   * Returns an iterator that iterates over (0, i) pairs in an iterable for\n   * i &gt; 0.\n   *\n   * <p>For example, {@code firstAnd([3, 5, 7])} returns [(3, 5), (3, 7)].\n   *\n   * @param iterable Source collection\n   * @param <T> Element type\n   * @return Iterable over pairs of the first element and all other elements\n   */\n  public static <T> Iterable<Pair<T, T>> firstAnd(final Iterable<T> iterable) {\n    return () -> {\n      final Iterator<T> iterator = iterable.iterator();\n      if (!iterator.hasNext()) {\n        return Collections.emptyIterator();\n      }\n      final T first = iterator.next();\n      return new FirstAndIterator<>(iterator, first);\n    };\n  }\n\n  /** Iterator that returns the left field of each pair.\n   *\n   * @param <L> Left-hand type\n   * @param <R> Right-hand type */\n  private static class LeftIterator<L, R> implements Iterator<L> {\n    private final Iterator<? extends Map.Entry<L, R>> iterator;\n\n    LeftIterator(Iterator<? extends Map.Entry<L, R>> iterator) {\n      this.iterator = requireNonNull(iterator);\n    }\n\n    public boolean hasNext() {\n      return iterator.hasNext();\n    }\n\n    public L next() {\n      return iterator.next().getKey();\n    }\n\n    public void remove() {\n      iterator.remove();\n    }\n  }\n\n  /** Iterator that returns the right field of each pair.\n   *\n   * @param <L> Left-hand type\n   * @param <R> Right-hand type */\n  private static class RightIterator<L, R> implements Iterator<R> {\n    private final Iterator<? extends Map.Entry<L, R>> iterator;\n\n    RightIterator(Iterator<? extends Map.Entry<L, R>> iterator) {\n      this.iterator = requireNonNull(iterator);\n    }\n\n    public boolean hasNext() {\n      return iterator.hasNext();\n    }\n\n    public R next() {\n      return iterator.next().getValue();\n    }\n\n    public void remove() {\n      iterator.remove();\n    }\n  }\n\n  /** Iterator that returns the first element of a collection paired with every\n   * other element.\n   *\n   * @param <E> Element type */\n  private static class FirstAndIterator<E> implements Iterator<Pair<E, E>> {\n    private final Iterator<E> iterator;\n    private final E first;\n\n    FirstAndIterator(Iterator<E> iterator, E first) {\n      this.iterator = requireNonNull(iterator);\n      this.first = first;\n    }\n\n    public boolean hasNext() {\n      return iterator.hasNext();\n    }\n\n    public Pair<E, E> next() {\n      return of(first, iterator.next());\n    }\n\n    public void remove() {\n      throw new UnsupportedOperationException(\"remove\");\n    }\n  }\n\n  /** Iterator that pairs elements from two iterators.\n   *\n   * @param <L> Left-hand type\n   * @param <R> Right-hand type */\n  private static class ZipIterator<L, R> implements Iterator<Pair<L, R>> {\n    private final Iterator<? extends L> leftIterator;\n    private final Iterator<? extends R> rightIterator;\n\n    ZipIterator(Iterator<? extends L> leftIterator,\n        Iterator<? extends R> rightIterator) {\n      this.leftIterator = requireNonNull(leftIterator);\n      this.rightIterator = requireNonNull(rightIterator);\n    }\n\n    public boolean hasNext() {\n      return leftIterator.hasNext() && rightIterator.hasNext();\n    }\n\n    public Pair<L, R> next() {\n      return Pair.of(leftIterator.next(), rightIterator.next());\n    }\n\n    public void remove() {\n      leftIterator.remove();\n      rightIterator.remove();\n    }\n  }\n\n  /** Iterator that returns consecutive pairs of elements from an underlying\n   * iterator.\n   *\n   * @param <E> Element type */\n  private static class AdjacentIterator<E> implements Iterator<Pair<E, E>> {\n    private final E first;\n    private final Iterator<E> iterator;\n    E previous;\n\n    AdjacentIterator(Iterator<E> iterator) {\n      this.iterator = requireNonNull(iterator);\n      this.first = iterator.next();\n      previous = first;\n    }\n\n    public boolean hasNext() {\n      return iterator.hasNext();\n    }\n\n    public Pair<E, E> next() {\n      final E current = iterator.next();\n      final Pair<E, E> pair = of(previous, current);\n      previous = current;\n      return pair;\n    }\n\n    public void remove() {\n      throw new UnsupportedOperationException(\"remove\");\n    }\n  }\n\n  /** Unmodifiable list of pairs, backed by a pair of lists.\n   *\n   * @param <K> Left-hand type\n   * @param <V> Right-hand type */\n  private static class ZipList<K, V> extends AbstractList<Pair<K, V>> {\n    private final List<K> ks;\n    private final List<V> vs;\n    private final int size;\n\n    ZipList(List<K> ks, List<V> vs, int size) {\n      this.ks = ks;\n      this.vs = vs;\n      this.size = size;\n    }\n\n    public Pair<K, V> get(int index) {\n      return Pair.of(ks.get(index), vs.get(index));\n    }\n\n    public int size() {\n      return size;\n    }\n  }\n\n  /** A mutable list of pairs backed by a pair of mutable lists.\n   *\n   * <p>Modifications to this list are reflected in the backing lists, and vice\n   * versa.\n   *\n   * @param <K> Key (left) value type\n   * @param <V> Value (right) value type */\n  private static class MutableZipList<K, V> extends AbstractList<Pair<K, V>> {\n    private final List<K> ks;\n    private final List<V> vs;\n\n    MutableZipList(List<K> ks, List<V> vs) {\n      this.ks = requireNonNull(ks);\n      this.vs = requireNonNull(vs);\n    }\n\n    @Override public Pair<K, V> get(int index) {\n      return Pair.of(ks.get(index), vs.get(index));\n    }\n\n    @Override public int size() {\n      return Math.min(ks.size(), vs.size());\n    }\n\n    @Override public void add(int index, Pair<K, V> pair) {\n      ks.add(index, pair.left);\n      vs.add(index, pair.right);\n    }\n\n    @Override public Pair<K, V> remove(int index) {\n      final K bufferedRow = ks.remove(index);\n      final V stateSet = vs.remove(index);\n      return Pair.of(bufferedRow, stateSet);\n    }\n\n    @Override public Pair<K, V> set(int index, Pair<K, V> pair) {\n      final Pair<K, V> previous = get(index);\n      ks.set(index, pair.left);\n      vs.set(index, pair.right);\n      return previous;\n    }\n  }\n\n  /**\n   * Represents an operation that accepts two input arguments and an ordinal,\n   * and returns no result.\n   *\n   * <p>This is a specialization of {@link Consumer}, similar to\n   * {@link BiConsumer}.\n   *\n   * @param <K> Key type\n   * @param <V> Value type\n   */\n  @FunctionalInterface\n  public interface PairWithOrdinalConsumer<K, V> {\n    /**\n     * Performs this operation on the given arguments.\n     *\n     * @param ordinal Ordinal\n     * @param k the first input argument\n     * @param v the second input argument\n     */\n    void accept(int ordinal, K k, V v);\n  }\n}", "super_interfaces": ["Comparable<Pair<T1, T2>>", "Map.Entry<T1, T2>", "Serializable"], "fields": [{"attribute_expression": "public final T1 left;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "T1", "name": "left", "syntax_pass": true}, {"attribute_expression": "public final T2 right;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "T2", "name": "right", "syntax_pass": true}]}, {"uris": "src/main/java/net/hydromatic/morel/util/JavaVersion.java.JavaVersion", "name": "JavaVersion", "file_path": "src/main/java/net/hydromatic/morel/util/JavaVersion.java", "superclasses": "", "methods": ["[]JavaVersion(List<Integer>)", "[JavaVersion]of()", "[JavaVersion]of(List<Integer>)", "[int]compareTo(JavaVersion)"], "method_uris": ["src/main/java/net/hydromatic/morel/util/JavaVersion.java.JavaVersion.[]JavaVersion(List<Integer>)", "src/main/java/net/hydromatic/morel/util/JavaVersion.java.JavaVersion.[JavaVersion]of()", "src/main/java/net/hydromatic/morel/util/JavaVersion.java.JavaVersion.[JavaVersion]of(List<Integer>)", "src/main/java/net/hydromatic/morel/util/JavaVersion.java.JavaVersion.[int]compareTo(JavaVersion)"], "overrides": null, "attributes": [], "class_docstring": " Version of the JDK.\n\n<p>The {@link #components} field contains the Java version string,\nparsed into a list of integers. For example,\nJava \"13.0.2\" is the list [13, 0, 2];\nJava \"1.8.0_341\" is the list [8, 0, 341].", "original_string": "public class JavaVersion implements Comparable<JavaVersion> {\n  public final List<Integer> components;\n\n  /** Version of the current JVM. */\n  public static final JavaVersion CURRENT;\n\n  static {\n    String versionString = System.getProperty(\"java.version\");\n    String[] versions = versionString.split(\"[._]\");\n    List<Integer> list = new ArrayList<>();\n    for (String version : versions) {\n      list.add(Integer.parseInt(version));\n    }\n    CURRENT = new JavaVersion(list);\n  }\n\n  private static final Comparator<Iterable<Integer>> COMPARATOR =\n      Ordering.<Integer>natural().lexicographical();\n\n  /** Private constructor. */\n  private JavaVersion(List<Integer> components) {\n    this.components = ImmutableList.copyOf(components);\n  }\n\n  /** Creates a version. */\n  public static JavaVersion of(int... components) {\n    List<Integer> list = new ArrayList<>();\n    for (int component : components) {\n      list.add(component);\n    }\n    return of(list);\n  }\n\n  /** Creates a version. */\n  public static JavaVersion of(List<Integer> componentList) {\n    if (componentList.size() >= 2\n        && componentList.get(0) == 1\n        && componentList.get(1) <= 9) {\n      // JDK 1.8.x -> 8.x\n      componentList = componentList.subList(1, componentList.size());\n    }\n    return new JavaVersion(ImmutableList.copyOf(componentList));\n  }\n\n  @Override public int compareTo(JavaVersion o) {\n    return COMPARATOR.compare(components, o.components);\n  }\n}", "super_interfaces": ["Comparable<JavaVersion>"], "fields": [{"attribute_expression": "public final List<Integer> components;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "List<Integer>", "name": "components", "syntax_pass": true}, {"attribute_expression": "public static final JavaVersion CURRENT;", "docstring": " Version of the current JVM.", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "JavaVersion", "name": "CURRENT", "syntax_pass": true}, {"attribute_expression": "private static final Comparator<Iterable<Integer>> COMPARATOR =\n      Ordering.<Integer>natural().lexicographical();", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Comparator<Iterable<Integer>>", "name": "COMPARATOR =\n      Ordering.<Integer>natural().lexicographical()", "syntax_pass": true}]}, {"uris": "src/main/java/net/hydromatic/morel/util/Static.java.Static", "name": "Static", "file_path": "src/main/java/net/hydromatic/morel/util/Static.java", "superclasses": "", "methods": ["[]Static()", "[boolean]getBooleanProperty(String,boolean)", "[Collector<T, ImmutableList.Builder<T>, ImmutableList<T>>]toImmutableList()", "[boolean]shorterThan(Iterable<E>,int)", "[List<E>]skip(List<E>)", "[List<E>]skip(List<E>,int)", "[List<E>]append(List<E>,E)", "[List<E>]plus(E,List<E>)", "[List<E>]minus(List<E>,E)", "[Map<K, V>]plus(Map<K, V>,K,V)", "[SortedMap<K, V>]plus(SortedMap<K, V>,K,V)", "[int]nextPowerOfTwo(int)", "[List<T>]transform(List<? extends E>,Function<E, T>)", "[Iterable<T>]transform(Iterable<? extends E>,Function<E, T>)", "[ImmutableList<T>]transformEager(Iterable<? extends E>,Function<E, T>)", "[int]find(List<? extends E>,Predicate<E>)", "[List<E>]intersect(List<E>,Iterable<? extends E>)", "[String]str(StringBuilder)"], "method_uris": ["src/main/java/net/hydromatic/morel/util/Static.java.Static.[]Static()", "src/main/java/net/hydromatic/morel/util/Static.java.Static.[boolean]getBooleanProperty(String,boolean)", "src/main/java/net/hydromatic/morel/util/Static.java.Static.[Collector<T, ImmutableList.Builder<T>, ImmutableList<T>>]toImmutableList()", "src/main/java/net/hydromatic/morel/util/Static.java.Static.[boolean]shorterThan(Iterable<E>,int)", "src/main/java/net/hydromatic/morel/util/Static.java.Static.[List<E>]skip(List<E>)", "src/main/java/net/hydromatic/morel/util/Static.java.Static.[List<E>]skip(List<E>,int)", "src/main/java/net/hydromatic/morel/util/Static.java.Static.[List<E>]append(List<E>,E)", "src/main/java/net/hydromatic/morel/util/Static.java.Static.[List<E>]plus(E,List<E>)", "src/main/java/net/hydromatic/morel/util/Static.java.Static.[List<E>]minus(List<E>,E)", "src/main/java/net/hydromatic/morel/util/Static.java.Static.[Map<K, V>]plus(Map<K, V>,K,V)", "src/main/java/net/hydromatic/morel/util/Static.java.Static.[SortedMap<K, V>]plus(SortedMap<K, V>,K,V)", "src/main/java/net/hydromatic/morel/util/Static.java.Static.[int]nextPowerOfTwo(int)", "src/main/java/net/hydromatic/morel/util/Static.java.Static.[List<T>]transform(List<? extends E>,Function<E, T>)", "src/main/java/net/hydromatic/morel/util/Static.java.Static.[Iterable<T>]transform(Iterable<? extends E>,Function<E, T>)", "src/main/java/net/hydromatic/morel/util/Static.java.Static.[ImmutableList<T>]transformEager(Iterable<? extends E>,Function<E, T>)", "src/main/java/net/hydromatic/morel/util/Static.java.Static.[int]find(List<? extends E>,Predicate<E>)", "src/main/java/net/hydromatic/morel/util/Static.java.Static.[List<E>]intersect(List<E>,Iterable<? extends E>)", "src/main/java/net/hydromatic/morel/util/Static.java.Static.[String]str(StringBuilder)"], "overrides": null, "attributes": [], "class_docstring": "\nUtilities.\n", "original_string": "public class Static {\n  private Static() {\n  }\n\n  /** Whether to skip built-in functions.\n   *\n   * <p>To skip built-in functions, add \"-DskipMorelBuiltIns\" java's\n   * command-line arguments. */\n  public static final boolean SKIP =\n      getBooleanProperty(\"skipMorelBuiltIns\", false);\n\n  /** Returns the value of a system property, converted into a boolean value.\n   *\n   * <p>Values \"\", \"true\", \"TRUE\" and \"1\" are treated as true;\n   * \"false\", \"FALSE\" and \"0\" treated as false;\n   * for {@code null} and other values, returns {@code defaultVal}.\n   */\n  @SuppressWarnings(\"SimplifiableConditionalExpression\")\n  private static boolean getBooleanProperty(String prop, boolean defaultVal) {\n    final String value = System.getProperty(prop);\n    if (value == null) {\n      return defaultVal;\n    }\n    final String low = value.toLowerCase(Locale.ROOT);\n    return low.equals(\"true\") || low.equals(\"1\") || low.isEmpty() ? true\n        : low.equals(\"false\") || low.equals(\"0\") ? false\n        : defaultVal;\n  }\n\n  /**\n   * Returns a {@code Collector} that accumulates the input elements into a\n   * Guava {@link ImmutableList} via a {@link ImmutableList.Builder}.\n   *\n   * <p>It will be obsolete when we move to Guava 21.0,\n   * which has {@code ImmutableList.toImmutableList()}.\n   *\n   * @param <T> Type of the input elements\n   *\n   * @return a {@code Collector} that collects all the input elements into an\n   * {@link ImmutableList}, in encounter order\n   */\n  public static <T> Collector<T, ImmutableList.Builder<T>, ImmutableList<T>>\n      toImmutableList() {\n    return Collector.of(ImmutableList::builder, ImmutableList.Builder::add,\n        (t, u) -> {\n          t.addAll(u.build());\n          return t;\n        },\n        ImmutableList.Builder::build);\n  }\n\n  /** Returns whether an {@link Iterable} has fewer than {@code n} elements.\n   *\n   * @param <E> Element type\n   */\n  public static <E> boolean shorterThan(Iterable<E> iterable, int n) {\n    if (iterable instanceof Collection) {\n      return ((Collection<E>) iterable).size() < n;\n    }\n    if (n <= 0) {\n      return false;\n    }\n    int i = 0;\n    for (Iterator<E> iterator = iterable.iterator(); iterator.hasNext();\n         iterator.next()) {\n      if (++i == n) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /** Returns all but the first element of a list. */\n  public static <E> List<E> skip(List<E> list) {\n    return skip(list, 1);\n  }\n\n  /** Returns all but the first {@code count} elements of a list. */\n  public static <E> List<E> skip(List<E> list, int count) {\n    return list.subList(count, list.size());\n  }\n\n  /** Returns a list with one element appended.\n   *\n   * @see ConsList */\n  public static <E> List<E> append(List<E> list, E e) {\n    return ImmutableList.<E>builder().addAll(list).add(e).build();\n  }\n\n  /** Prepends an element to a list. */\n  public static <E> List<E> plus(E e, List<E> list) {\n    return ConsList.of(e, list);\n  }\n\n  /** Removes all occurrences of an element from a list. */\n  public static <E> List<E> minus(List<E> list, E e) {\n    final ImmutableList.Builder<E> builder = ImmutableList.builder();\n    list.forEach(e2 -> {\n      if (!e2.equals(e)) {\n        builder.add(e2);\n      }\n    });\n    return builder.build();\n  }\n\n  /** Adds an element to a map. */\n  public static <K, V> Map<K, V> plus(Map<K, V> map, K k, V v) {\n    return ImmutableMap.<K, V>builder()\n        .putAll(map)\n        .put(k, v)\n        .build();\n  }\n\n  /** Adds an element to a sorted map. */\n  public static <K extends Comparable<K>, V> SortedMap<K, V> plus(\n      SortedMap<K, V> map, K k, V v) {\n    return new ImmutableSortedMap.Builder<K, V>(map.comparator())\n        .putAll(map)\n        .put(k, v)\n        .build();\n  }\n\n  /** Next power of two. */\n  public static int nextPowerOfTwo(int n) {\n    final int p = Integer.numberOfLeadingZeros(n);\n    return 1 << (Integer.SIZE - p);\n  }\n\n  /** Lazily transforms a list, applying a mapping function to each element. */\n  public static <E, T> List<T> transform(List<? extends E> elements,\n      Function<E, T> mapper) {\n    return Util.transform(elements, mapper);\n  }\n\n  /** Lazily transforms an Iterable, applying a mapping function to each\n   * element. */\n  public static <E, T> Iterable<T> transform(Iterable<? extends E> elements,\n      Function<E, T> mapper) {\n    return Iterables.transform(elements, mapper::apply);\n  }\n\n  /** Eagerly converts an Iterable to an ImmutableList, applying a mapping\n   * function to each element. */\n  public static <E, T> ImmutableList<T> transformEager(\n      Iterable<? extends E> elements, Function<E, T> mapper) {\n    if (Iterables.isEmpty(elements)) {\n      // Save ourselves the effort of creating a Builder.\n      return ImmutableList.of();\n    }\n    final ImmutableList.Builder<T> b = ImmutableList.builder();\n    elements.forEach(e -> b.add(mapper.apply(e)));\n    return b.build();\n  }\n\n  /** Returns the first index in a list where a predicate is true, or -1. */\n  public static <E> int find(List<? extends E> list, Predicate<E> predicate) {\n    if (list instanceof RandomAccess) {\n      for (int i = 0; i < list.size(); i++) {\n        if (predicate.test(list.get(i))) {\n          return i;\n        }\n      }\n    } else {\n      int i = 0;\n      for (E e : list) {\n        if (predicate.test(e)) {\n          return i;\n        }\n        ++i;\n      }\n    }\n    return -1;\n  }\n\n  public static <E> List<E> intersect(List<E> list0,\n      Iterable<? extends E> list1) {\n    final ImmutableList.Builder<E> list2 = ImmutableList.builder();\n    final Set<E> set = new HashSet<>(list0);\n    for (E e : list1) {\n      if (set.contains(e)) {\n        list2.add(e);\n      }\n    }\n    return list2.build();\n  }\n\n  /** Flushes a builder and returns its contents. */\n  public static String str(StringBuilder b) {\n    String s = b.toString();\n    b.setLength(0);\n    return s;\n  }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "public static final boolean SKIP =\n      getBooleanProperty(\"skipMorelBuiltIns\", false);", "docstring": " Whether to skip built-in functions.\n\n<p>To skip built-in functions, add \"-DskipMorelBuiltIns\" java's\ncommand-line arguments.", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "boolean", "name": "SKIP =\n      getBooleanProperty(\"skipMorelBuiltIns\", false)", "syntax_pass": true}]}, {"uris": "src/main/java/net/hydromatic/morel/util/Sat.java.Sat", "name": "Sat", "file_path": "src/main/java/net/hydromatic/morel/util/Sat.java", "superclasses": "", "methods": ["[Map<Variable, Boolean>]solve(Term)", "[Variable]variable(String)", "[Term]not(Term)", "[Term]and()", "[Term]and(Iterable<?extends Term>)", "[Term]or()", "[Term]or(Iterable<?extends Term>)"], "method_uris": ["src/main/java/net/hydromatic/morel/util/Sat.java.Sat.[Map<Variable, Boolean>]solve(Term)", "src/main/java/net/hydromatic/morel/util/Sat.java.Sat.[Variable]variable(String)", "src/main/java/net/hydromatic/morel/util/Sat.java.Sat.[Term]not(Term)", "src/main/java/net/hydromatic/morel/util/Sat.java.Sat.[Term]and()", "src/main/java/net/hydromatic/morel/util/Sat.java.Sat.[Term]and(Iterable<?extends Term>)", "src/main/java/net/hydromatic/morel/util/Sat.java.Sat.[Term]or()", "src/main/java/net/hydromatic/morel/util/Sat.java.Sat.[Term]or(Iterable<?extends Term>)"], "overrides": null, "attributes": [{"original_string": "  public abstract static class Term {\n    final Op op;\n\n    Term(Op op) {\n      this.op = requireNonNull(op, \"op\");\n    }\n\n    @Override public String toString() {\n      return unparse(new StringBuilder(), 0, 0).toString();\n    }\n\n    protected abstract StringBuilder unparse(StringBuilder buf, int left,\n        int right);\n\n    public abstract boolean evaluate(boolean[] env);\n  }", "definition": "  public abstract static class Term", "class_docstring": " Base class for all terms (variables, and, or, not).", "name": "Term", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public abstract static", "marker_annotations": [], "non_marker_annotations": ["public", "abstract", "static"], "comments": [], "fields": [{"attribute_expression": "final Op op;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "Op", "name": "op", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    Term(Op op) {\n      this.op = requireNonNull(op, \"op\");\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "Term", "params": [{"name": "op", "type": "Op"}], "body": "                {\n      this.op = requireNonNull(op, \"op\");\n    }", "signature": "Term(Op op)"}, {"syntax_pass": true, "original_string": "    @Override public String toString() {\n      return unparse(new StringBuilder(), 0, 0).toString();\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "toString", "params": [], "body": "                                       {\n      return unparse(new StringBuilder(), 0, 0).toString();\n    }", "signature": "@Override public String toString()"}, {"syntax_pass": true, "original_string": "    protected abstract StringBuilder unparse(StringBuilder buf, int left,\n        int right);", "docstring": "", "attributes": {"modifiers": "protected abstract", "marker_annotations": [], "non_marker_annotations": ["protected", "abstract"], "comments": [], "return_type": "StringBuilder", "classes": []}, "name": "unparse", "params": [{"name": "buf", "type": "StringBuilder"}, {"name": "left", "type": "int"}, {"name": "right", "type": "int"}], "body": "", "signature": "protected abstract StringBuilder unparse(StringBuilder buf, int left,\n        int right)"}, {"syntax_pass": true, "original_string": "    public abstract boolean evaluate(boolean[] env);", "docstring": "", "attributes": {"modifiers": "public abstract", "marker_annotations": [], "non_marker_annotations": ["public", "abstract"], "comments": [], "return_type": "boolean", "classes": []}, "name": "evaluate", "params": [{"name": "env", "type": "boolean[]"}], "body": "", "signature": "public abstract boolean evaluate(boolean[] env)"}]}, {"original_string": "  public static class Variable extends Term {\n    public final int id;\n    public final String name;\n\n    Variable(int id, String name) {\n      super(Op.VARIABLE);\n      this.id = id;\n      this.name = requireNonNull(name, \"name\");\n    }\n\n    @Override protected StringBuilder unparse(StringBuilder buf, int left,\n        int right) {\n      return buf.append(name);\n    }\n\n    @Override public boolean evaluate(boolean[] env) {\n      return env[id];\n    }\n  }", "definition": "  public static class Variable extends Term", "class_docstring": " Variable. Its value can be true or false.", "name": "Variable", "super_interfaces": [], "superclasses": "Term", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [{"attribute_expression": "public final int id;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "int", "name": "id", "syntax_pass": true}, {"attribute_expression": "public final String name;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "String", "name": "name", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    Variable(int id, String name) {\n      super(Op.VARIABLE);\n      this.id = id;\n      this.name = requireNonNull(name, \"name\");\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "Variable", "params": [{"name": "id", "type": "int"}, {"name": "name", "type": "String"}], "body": "                                  {\n      super(Op.VARIABLE);\n      this.id = id;\n      this.name = requireNonNull(name, \"name\");\n    }", "signature": "Variable(int id, String name)"}, {"syntax_pass": true, "original_string": "    @Override protected StringBuilder unparse(StringBuilder buf, int left,\n        int right) {\n      return buf.append(name);\n    }", "docstring": "", "attributes": {"modifiers": "@Override protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "StringBuilder", "classes": []}, "name": "unparse", "params": [{"name": "buf", "type": "StringBuilder"}, {"name": "left", "type": "int"}, {"name": "right", "type": "int"}], "body": "                   {\n      return buf.append(name);\n    }", "signature": "@Override protected StringBuilder unparse(StringBuilder buf, int left,\n        int right)"}, {"syntax_pass": true, "original_string": "    @Override public boolean evaluate(boolean[] env) {\n      return env[id];\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "evaluate", "params": [{"name": "env", "type": "boolean[]"}], "body": "                                                     {\n      return env[id];\n    }", "signature": "@Override public boolean evaluate(boolean[] env)"}]}, {"original_string": "  abstract static class Node extends Term {\n    public final ImmutableList<Term> terms;\n\n    Node(Op op, ImmutableList<Term> terms) {\n      super(op);\n      this.terms = requireNonNull(terms);\n    }\n\n    @Override protected StringBuilder unparse(StringBuilder buf, int left,\n        int right) {\n      switch (terms.size()) {\n      case 0:\n        // empty \"and\" prints as \"true\";\n        // empty \"or\" prints as \"false\"\n        return buf.append(op.emptyName);\n      case 1:\n        // singleton \"and\" and \"or\" print as the sole term\n        return terms.get(0).unparse(buf, left, right);\n      }\n      if (left > op.left || right > op.right) {\n        return unparse(buf.append('('), 0, 0).append(')');\n      }\n      for (int i = 0; i < terms.size(); i++) {\n        final Term term = terms.get(i);\n        if (i > 0) {\n          buf.append(op.str);\n        }\n        term.unparse(buf,\n            i == 0 ? left : op.right,\n            i == terms.size() - 1 ? right : op.left);\n      }\n      return buf;\n    }\n  }", "definition": "  abstract static class Node extends Term", "class_docstring": " Term that has a variable number of arguments (\"and\" or \"or\").", "name": "Node", "super_interfaces": [], "superclasses": "Term", "attributes": {"modifiers": "abstract static", "marker_annotations": [], "non_marker_annotations": ["abstract", "static"], "comments": [], "fields": [{"attribute_expression": "public final ImmutableList<Term> terms;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "ImmutableList<Term>", "name": "terms", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    Node(Op op, ImmutableList<Term> terms) {\n      super(op);\n      this.terms = requireNonNull(terms);\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "Node", "params": [{"name": "op", "type": "Op"}, {"name": "terms", "type": "ImmutableList<Term>"}], "body": "                                           {\n      super(op);\n      this.terms = requireNonNull(terms);\n    }", "signature": "Node(Op op, ImmutableList<Term> terms)"}, {"syntax_pass": true, "original_string": "    @Override protected StringBuilder unparse(StringBuilder buf, int left,\n        int right) {\n      switch (terms.size()) {\n      case 0:\n        // empty \"and\" prints as \"true\";\n        // empty \"or\" prints as \"false\"\n        return buf.append(op.emptyName);\n      case 1:\n        // singleton \"and\" and \"or\" print as the sole term\n        return terms.get(0).unparse(buf, left, right);\n      }\n      if (left > op.left || right > op.right) {\n        return unparse(buf.append('('), 0, 0).append(')');\n      }\n      for (int i = 0; i < terms.size(); i++) {\n        final Term term = terms.get(i);\n        if (i > 0) {\n          buf.append(op.str);\n        }\n        term.unparse(buf,\n            i == 0 ? left : op.right,\n            i == terms.size() - 1 ? right : op.left);\n      }\n      return buf;\n    }", "docstring": "", "attributes": {"modifiers": "@Override protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "StringBuilder", "classes": []}, "name": "unparse", "params": [{"name": "buf", "type": "StringBuilder"}, {"name": "left", "type": "int"}, {"name": "right", "type": "int"}], "body": "                   {\n      switch (terms.size()) {\n      case 0:\n        // empty \"and\" prints as \"true\";\n        // empty \"or\" prints as \"false\"\n        return buf.append(op.emptyName);\n      case 1:\n        // singleton \"and\" and \"or\" print as the sole term\n        return terms.get(0).unparse(buf, left, right);\n      }\n      if (left > op.left || right > op.right) {\n        return unparse(buf.append('('), 0, 0).append(')');\n      }\n      for (int i = 0; i < terms.size(); i++) {\n        final Term term = terms.get(i);\n        if (i > 0) {\n          buf.append(op.str);\n        }\n        term.unparse(buf,\n            i == 0 ? left : op.right,\n            i == terms.size() - 1 ? right : op.left);\n      }\n      return buf;\n    }", "signature": "@Override protected StringBuilder unparse(StringBuilder buf, int left,\n        int right)"}]}, {"original_string": "  static class And extends Node {\n    And(ImmutableList<Term> terms) {\n      super(Op.AND, terms);\n    }\n\n    @Override public boolean evaluate(boolean[] env) {\n      for (Term term : terms) {\n        if (!term.evaluate(env)) {\n          return false;\n        }\n      }\n      return true;\n    }\n  }", "definition": "  static class And extends Node", "class_docstring": " \"And\" term.", "name": "And", "super_interfaces": [], "superclasses": "Node", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    And(ImmutableList<Term> terms) {\n      super(Op.AND, terms);\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "And", "params": [{"name": "terms", "type": "ImmutableList<Term>"}], "body": "                                   {\n      super(Op.AND, terms);\n    }", "signature": "And(ImmutableList<Term> terms)"}, {"syntax_pass": true, "original_string": "    @Override public boolean evaluate(boolean[] env) {\n      for (Term term : terms) {\n        if (!term.evaluate(env)) {\n          return false;\n        }\n      }\n      return true;\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "evaluate", "params": [{"name": "env", "type": "boolean[]"}], "body": "                                                     {\n      for (Term term : terms) {\n        if (!term.evaluate(env)) {\n          return false;\n        }\n      }\n      return true;\n    }", "signature": "@Override public boolean evaluate(boolean[] env)"}]}, {"original_string": "  static class Or extends Node {\n    Or(ImmutableList<Term> terms) {\n      super(Op.OR, terms);\n    }\n\n    @Override public boolean evaluate(boolean[] env) {\n      for (Term term : terms) {\n        if (term.evaluate(env)) {\n          return true;\n        }\n      }\n      return false;\n    }\n  }", "definition": "  static class Or extends Node", "class_docstring": " \"Or\" term.", "name": "Or", "super_interfaces": [], "superclasses": "Node", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    Or(ImmutableList<Term> terms) {\n      super(Op.OR, terms);\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "Or", "params": [{"name": "terms", "type": "ImmutableList<Term>"}], "body": "                                  {\n      super(Op.OR, terms);\n    }", "signature": "Or(ImmutableList<Term> terms)"}, {"syntax_pass": true, "original_string": "    @Override public boolean evaluate(boolean[] env) {\n      for (Term term : terms) {\n        if (term.evaluate(env)) {\n          return true;\n        }\n      }\n      return false;\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "evaluate", "params": [{"name": "env", "type": "boolean[]"}], "body": "                                                     {\n      for (Term term : terms) {\n        if (term.evaluate(env)) {\n          return true;\n        }\n      }\n      return false;\n    }", "signature": "@Override public boolean evaluate(boolean[] env)"}]}, {"original_string": "  static class Not extends Term {\n    public final Term term;\n\n    Not(Term term) {\n      super(Op.NOT);\n      this.term = requireNonNull(term, \"term\");\n    }\n\n    @Override protected StringBuilder unparse(StringBuilder buf, int left,\n        int right) {\n      return term.unparse(buf.append(op.str), op.right, right);\n    }\n\n    @Override public boolean evaluate(boolean[] env) {\n      return !term.evaluate(env);\n    }\n  }", "definition": "  static class Not extends Term", "class_docstring": " \"Not\" term.", "name": "Not", "super_interfaces": [], "superclasses": "Term", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "fields": [{"attribute_expression": "public final Term term;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "Term", "name": "term", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    Not(Term term) {\n      super(Op.NOT);\n      this.term = requireNonNull(term, \"term\");\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "Not", "params": [{"name": "term", "type": "Term"}], "body": "                   {\n      super(Op.NOT);\n      this.term = requireNonNull(term, \"term\");\n    }", "signature": "Not(Term term)"}, {"syntax_pass": true, "original_string": "    @Override protected StringBuilder unparse(StringBuilder buf, int left,\n        int right) {\n      return term.unparse(buf.append(op.str), op.right, right);\n    }", "docstring": "", "attributes": {"modifiers": "@Override protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "StringBuilder", "classes": []}, "name": "unparse", "params": [{"name": "buf", "type": "StringBuilder"}, {"name": "left", "type": "int"}, {"name": "right", "type": "int"}], "body": "                   {\n      return term.unparse(buf.append(op.str), op.right, right);\n    }", "signature": "@Override protected StringBuilder unparse(StringBuilder buf, int left,\n        int right)"}, {"syntax_pass": true, "original_string": "    @Override public boolean evaluate(boolean[] env) {\n      return !term.evaluate(env);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "evaluate", "params": [{"name": "env", "type": "boolean[]"}], "body": "                                                     {\n      return !term.evaluate(env);\n    }", "signature": "@Override public boolean evaluate(boolean[] env)"}]}, {"original_string": "  private static class Assignment {\n    final Variable variable;\n    final boolean value;\n\n    Assignment(Variable variable, boolean value) {\n      this.variable = requireNonNull(variable, \"variable\");\n      this.value = value;\n    }\n  }", "definition": "  private static class Assignment", "class_docstring": " Assignment of a variable to a value.", "name": "Assignment", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "fields": [{"attribute_expression": "final Variable variable;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "Variable", "name": "variable", "syntax_pass": true}, {"attribute_expression": "final boolean value;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "boolean", "name": "value", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    Assignment(Variable variable, boolean value) {\n      this.variable = requireNonNull(variable, \"variable\");\n      this.value = value;\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "Assignment", "params": [{"name": "variable", "type": "Variable"}, {"name": "value", "type": "boolean"}], "body": "                                                 {\n      this.variable = requireNonNull(variable, \"variable\");\n      this.value = value;\n    }", "signature": "Assignment(Variable variable, boolean value)"}]}], "class_docstring": "\nBoolean satisfiability.\n", "original_string": "public class Sat {\n  private final Map<Integer, Variable> variablesById = new HashMap<>();\n  private final Map<String, Variable> variablesByName = new HashMap<>();\n  private int nextVariable = 0;\n\n  /** Finds an assignment of variables such that a term evaluates to true,\n   * or null if there is no solution. */\n  public @Nullable Map<Variable, Boolean> solve(Term term) {\n    final List<List<Assignment>> allAssignments = new ArrayList<>();\n    for (Variable variable : variablesById.values()) {\n      allAssignments.add(\n          ImmutableList.of(new Assignment(variable, false),\n              new Assignment(variable, true)));\n    }\n\n    final boolean[] env = new boolean[nextVariable];\n    for (List<Assignment> assignments\n        : Lists.cartesianProduct(allAssignments)) {\n      assignments.forEach(a -> env[a.variable.id] = a.value);\n      if (term.evaluate(env)) {\n        final ImmutableMap.Builder<Variable, Boolean> builder =\n            ImmutableMap.builder();\n        assignments.forEach(a -> builder.put(a.variable, a.value));\n        return builder.build();\n      }\n    }\n    return null;\n  }\n\n  public Variable variable(String name) {\n    Variable variable = variablesByName.get(name);\n    if (variable != null) {\n      return variable;\n    }\n    int id = nextVariable++;\n    variable = new Variable(id, name);\n    variablesById.put(id, variable);\n    variablesByName.put(name, variable);\n    return variable;\n  }\n\n  public Term not(Term term) {\n    return new Not(term);\n  }\n\n  public Term and(Term... terms) {\n    return new And(ImmutableList.copyOf(terms));\n  }\n\n  public Term and(Iterable<?extends Term> terms) {\n    return new And(ImmutableList.copyOf(terms));\n  }\n\n  public Term or(Term... terms) {\n    return new Or(ImmutableList.copyOf(terms));\n  }\n\n  public Term or(Iterable<?extends Term> terms) {\n    return new Or(ImmutableList.copyOf(terms));\n  }\n\n  /** Base class for all terms (variables, and, or, not). */\n  public abstract static class Term {\n    final Op op;\n\n    Term(Op op) {\n      this.op = requireNonNull(op, \"op\");\n    }\n\n    @Override public String toString() {\n      return unparse(new StringBuilder(), 0, 0).toString();\n    }\n\n    protected abstract StringBuilder unparse(StringBuilder buf, int left,\n        int right);\n\n    public abstract boolean evaluate(boolean[] env);\n  }\n\n  /** Variable. Its value can be true or false. */\n  public static class Variable extends Term {\n    public final int id;\n    public final String name;\n\n    Variable(int id, String name) {\n      super(Op.VARIABLE);\n      this.id = id;\n      this.name = requireNonNull(name, \"name\");\n    }\n\n    @Override protected StringBuilder unparse(StringBuilder buf, int left,\n        int right) {\n      return buf.append(name);\n    }\n\n    @Override public boolean evaluate(boolean[] env) {\n      return env[id];\n    }\n  }\n\n  /** Term that has a variable number of arguments (\"and\" or \"or\"). */\n  abstract static class Node extends Term {\n    public final ImmutableList<Term> terms;\n\n    Node(Op op, ImmutableList<Term> terms) {\n      super(op);\n      this.terms = requireNonNull(terms);\n    }\n\n    @Override protected StringBuilder unparse(StringBuilder buf, int left,\n        int right) {\n      switch (terms.size()) {\n      case 0:\n        // empty \"and\" prints as \"true\";\n        // empty \"or\" prints as \"false\"\n        return buf.append(op.emptyName);\n      case 1:\n        // singleton \"and\" and \"or\" print as the sole term\n        return terms.get(0).unparse(buf, left, right);\n      }\n      if (left > op.left || right > op.right) {\n        return unparse(buf.append('('), 0, 0).append(')');\n      }\n      for (int i = 0; i < terms.size(); i++) {\n        final Term term = terms.get(i);\n        if (i > 0) {\n          buf.append(op.str);\n        }\n        term.unparse(buf,\n            i == 0 ? left : op.right,\n            i == terms.size() - 1 ? right : op.left);\n      }\n      return buf;\n    }\n  }\n\n  /** \"And\" term. */\n  static class And extends Node {\n    And(ImmutableList<Term> terms) {\n      super(Op.AND, terms);\n    }\n\n    @Override public boolean evaluate(boolean[] env) {\n      for (Term term : terms) {\n        if (!term.evaluate(env)) {\n          return false;\n        }\n      }\n      return true;\n    }\n  }\n\n  /** \"Or\" term. */\n  static class Or extends Node {\n    Or(ImmutableList<Term> terms) {\n      super(Op.OR, terms);\n    }\n\n    @Override public boolean evaluate(boolean[] env) {\n      for (Term term : terms) {\n        if (term.evaluate(env)) {\n          return true;\n        }\n      }\n      return false;\n    }\n  }\n\n  /** \"Not\" term. */\n  static class Not extends Term {\n    public final Term term;\n\n    Not(Term term) {\n      super(Op.NOT);\n      this.term = requireNonNull(term, \"term\");\n    }\n\n    @Override protected StringBuilder unparse(StringBuilder buf, int left,\n        int right) {\n      return term.unparse(buf.append(op.str), op.right, right);\n    }\n\n    @Override public boolean evaluate(boolean[] env) {\n      return !term.evaluate(env);\n    }\n  }\n\n  /** Operator (or type of term), with its left and right precedence and print\n   * name. */\n  private enum Op {\n    AND(3, 4, \" \u2227 \", \"true\"),\n    OR(1, 2, \" \u2228 \", \"false\"),\n    NOT(5, 5, \"\u00ac\", \"\"),\n    VARIABLE(0, 0, \"\", \"\");\n\n    final int left;\n    final int right;\n    final String str;\n    final String emptyName;\n\n    Op(int left, int right, String str, String emptyName) {\n      this.left = left;\n      this.right = right;\n      this.str = str;\n      this.emptyName = emptyName;\n    }\n  }\n\n  /** Assignment of a variable to a value. */\n  private static class Assignment {\n    final Variable variable;\n    final boolean value;\n\n    Assignment(Variable variable, boolean value) {\n      this.variable = requireNonNull(variable, \"variable\");\n      this.value = value;\n    }\n  }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private final Map<Integer, Variable> variablesById = new HashMap<>();", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Map<Integer, Variable>", "name": "variablesById = new HashMap<>()", "syntax_pass": true}, {"attribute_expression": "private final Map<String, Variable> variablesByName = new HashMap<>();", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Map<String, Variable>", "name": "variablesByName = new HashMap<>()", "syntax_pass": true}, {"attribute_expression": "private int nextVariable = 0;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "int", "name": "nextVariable = 0", "syntax_pass": true}]}, {"uris": "src/main/java/net/hydromatic/morel/util/PairLists.java.PairLists", "name": "PairLists", "file_path": "src/main/java/net/hydromatic/morel/util/PairLists.java", "superclasses": "", "methods": ["[]PairLists()", "[ImmutablePairList<T, U>]immutableBackedBy(List<Object>)", "[Object[]]checkElementsNotNull()", "[void]checkElementNotNull(int,Object)"], "method_uris": ["src/main/java/net/hydromatic/morel/util/PairLists.java.PairLists.[]PairLists()", "src/main/java/net/hydromatic/morel/util/PairLists.java.PairLists.[ImmutablePairList<T, U>]immutableBackedBy(List<Object>)", "src/main/java/net/hydromatic/morel/util/PairLists.java.PairLists.[Object[]]checkElementsNotNull()", "src/main/java/net/hydromatic/morel/util/PairLists.java.PairLists.[void]checkElementNotNull(int,Object)"], "overrides": null, "attributes": [{"original_string": "  abstract static class AbstractPairList<T, U>\n      extends AbstractList<Map.Entry<T, U>>\n      implements PairList<T, U> {\n    /** Returns a list containing the alternating left and right elements\n     * of each pair. */\n    abstract List<Object> backingList();\n  }", "definition": "  abstract static class AbstractPairList<T, U>\n      extends AbstractList<Map.Entry<T, U>>\n      implements PairList<T, U>", "class_docstring": " Base class for all implementations of PairList.\n\n@param <T> First type\n@param <U> Second type\n", "name": "AbstractPairList", "super_interfaces": ["PairList<T, U>"], "superclasses": "", "attributes": {"modifiers": "abstract static", "marker_annotations": [], "non_marker_annotations": ["abstract", "static"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    abstract List<Object> backingList();", "docstring": " Returns a list containing the alternating left and right elements\nof each pair.", "attributes": {"modifiers": "abstract", "marker_annotations": [], "non_marker_annotations": ["abstract"], "comments": [], "return_type": "List<Object>", "classes": []}, "name": "backingList", "params": [], "body": "", "signature": "abstract List<Object> backingList()"}]}, {"original_string": "  static class MutablePairList<T, U> extends AbstractPairList<T, U> {\n    final List<@Nullable Object> list;\n\n    MutablePairList(List<@Nullable Object> list) {\n      this.list = list;\n    }\n\n    @Override List<Object> backingList() {\n      return list;\n    }\n\n    @Override public void clear() {\n      list.clear();\n    }\n\n    @Override public int size() {\n      return list.size() / 2;\n    }\n\n    @Override public boolean isEmpty() {\n      return list.isEmpty();\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @Override public Map.Entry<T, U> get(int index) {\n      int x = index * 2;\n      return new MapEntry<>((T) list.get(x), (U) list.get(x + 1));\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @Override public T left(int index) {\n      int x = index * 2;\n      return (T) list.get(x);\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @Override public U right(int index) {\n      int x = index * 2;\n      return (U) list.get(x + 1);\n    }\n\n    @Override public Map.Entry<T, U> set(int index, Map.Entry<T, U> entry) {\n      return set(index, entry.getKey(), entry.getValue());\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @Override public Map.Entry<T, U> set(int index, T t, U u) {\n      int x = index * 2;\n      T t0 = (T) list.set(x, t);\n      U u0 = (U) list.set(x + 1, u);\n      return new MapEntry<>(t0, u0);\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @Override public Map.Entry<T, U> remove(int index) {\n      final int x = index * 2;\n      T t = (T) list.remove(x);\n      U u = (U) list.remove(x);\n      return new MapEntry<>(t, u);\n    }\n\n    @SuppressWarnings(\"RedundantCast\")\n    @Override public boolean add(Map.Entry<T, U> entry) {\n      list.add((Object) entry.getKey());\n      list.add((Object) entry.getValue());\n      return true;\n    }\n\n    @SuppressWarnings(\"RedundantCast\")\n    @Override public void add(int index, Map.Entry<T, U> entry) {\n      int x = index * 2;\n      list.add(x, (Object) entry.getKey());\n      list.add(x + 1, (Object) entry.getValue());\n    }\n\n    @SuppressWarnings(\"RedundantCast\")\n    @Override public void add(T t, U u) {\n      list.add((Object) t);\n      list.add((Object) u);\n    }\n\n    @SuppressWarnings(\"RedundantCast\")\n    @Override public void add(int index, T t, U u) {\n      int x = index * 2;\n      list.add(x, (Object) t);\n      list.add(x + 1, (Object) u);\n    }\n\n    @Override public boolean addAll(PairList<T, U> list2) {\n      return list.addAll(((AbstractPairList<T, U>) list2).backingList());\n    }\n\n    @Override public boolean addAll(int index, PairList<T, U> list2) {\n      int x = index * 2;\n      return list.addAll(x, ((AbstractPairList<T, U>) list2).backingList());\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @Override public List<T> leftList() {\n      final int size = list.size() / 2;\n      return new RandomAccessList<T>() {\n        @Override public int size() {\n          return size;\n        }\n\n        @Override public T get(int index) {\n          return (T) list.get(index * 2);\n        }\n      };\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @Override public List<U> rightList() {\n      final int size = list.size() / 2;\n      return new RandomAccessList<U>() {\n        @Override public int size() {\n          return size;\n        }\n\n        @Override public U get(int index) {\n          return (U) list.get(index * 2 + 1);\n        }\n      };\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @Override public void forEach(BiConsumer<T, U> consumer) {\n      requireNonNull(consumer, \"consumer\");\n      for (int i = 0; i < list.size();) {\n        T t = (T) list.get(i++);\n        U u = (U) list.get(i++);\n        consumer.accept(t, u);\n      }\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @Override public void forEachIndexed(IndexedBiConsumer<T, U> consumer) {\n      requireNonNull(consumer, \"consumer\");\n      for (int i = 0, j = 0; i < list.size();) {\n        T t = (T) list.get(i++);\n        U u = (U) list.get(i++);\n        consumer.accept(j++, t, u);\n      }\n    }\n\n    @Override public ImmutableMap<T, U> toImmutableMap() {\n      final ImmutableMap.Builder<T, U> b = ImmutableMap.builder();\n      forEach((t, u) -> b.put(t, u));\n      return b.build();\n    }\n\n    @Override public ImmutablePairList<T, U> immutable() {\n      return immutableBackedBy(list);\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @Override public <R> List<R> transform(BiFunction<T, U, R> function) {\n      return Functions.generate(list.size() / 2, index -> {\n        final int x = index * 2;\n        final T t = (T) list.get(x);\n        final U u = (U) list.get(x + 1);\n        return function.apply(t, u);\n      });\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @Override public <R> ImmutableList<R> transform2(\n        BiFunction<T, U, R> function) {\n      if (list.isEmpty()) {\n        return ImmutableList.of();\n      }\n      final ImmutableList.Builder<R> builder = ImmutableList.builder();\n      for (int i = 0, n = list.size(); i < n;) {\n        final T t = (T) list.get(i++);\n        final U u = (U) list.get(i++);\n        builder.add(function.apply(t, u));\n      }\n      return builder.build();\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @Override public boolean anyMatch(BiPredicate<T, U> predicate) {\n      for (int i = 0; i < list.size();) {\n        final T t = (T) list.get(i++);\n        final U u = (U) list.get(i++);\n        if (predicate.test(t, u)) {\n          return true;\n        }\n      }\n      return false;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @Override public boolean allMatch(BiPredicate<T, U> predicate) {\n      for (int i = 0; i < list.size();) {\n        final T t = (T) list.get(i++);\n        final U u = (U) list.get(i++);\n        if (!predicate.test(t, u)) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @Override public boolean noMatch(BiPredicate<T, U> predicate) {\n      for (int i = 0; i < list.size();) {\n        final T t = (T) list.get(i++);\n        final U u = (U) list.get(i++);\n        if (predicate.test(t, u)) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @Override public int firstMatch(BiPredicate<T, U> predicate) {\n      for (int i = 0, j = 0; i < list.size(); ++j) {\n        final T t = (T) list.get(i++);\n        final U u = (U) list.get(i++);\n        if (predicate.test(t, u)) {\n          return j;\n        }\n      }\n      return -1;\n    }\n  }", "definition": "  static class MutablePairList<T, U> extends AbstractPairList<T, U>", "class_docstring": " Mutable version of {@link PairList}.\n\n@param <T> First type\n@param <U> Second type\n", "name": "MutablePairList", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "fields": [{"attribute_expression": "final List<@Nullable Object> list;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "List<@Nullable Object>", "name": "list", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    MutablePairList(List<@Nullable Object> list) {\n      this.list = list;\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "MutablePairList", "params": [{"name": "list", "type": "List<@Nullable Object>"}], "body": "                                                 {\n      this.list = list;\n    }", "signature": "MutablePairList(List<@Nullable Object> list)"}, {"syntax_pass": true, "original_string": "    @Override List<Object> backingList() {\n      return list;\n    }", "docstring": "", "attributes": {"modifiers": "@Override", "marker_annotations": ["@Override"], "non_marker_annotations": [], "comments": [], "return_type": "List<Object>", "classes": []}, "name": "backingList", "params": [], "body": "                                         {\n      return list;\n    }", "signature": "@Override List<Object> backingList()"}, {"syntax_pass": true, "original_string": "    @Override public void clear() {\n      list.clear();\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "clear", "params": [], "body": "                                  {\n      list.clear();\n    }", "signature": "@Override public void clear()"}, {"syntax_pass": true, "original_string": "    @Override public int size() {\n      return list.size() / 2;\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "size", "params": [], "body": "                                {\n      return list.size() / 2;\n    }", "signature": "@Override public int size()"}, {"syntax_pass": true, "original_string": "    @Override public boolean isEmpty() {\n      return list.isEmpty();\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isEmpty", "params": [], "body": "                                       {\n      return list.isEmpty();\n    }", "signature": "@Override public boolean isEmpty()"}, {"syntax_pass": true, "original_string": "    @SuppressWarnings(\"unchecked\")\n    @Override public Map.Entry<T, U> get(int index) {\n      int x = index * 2;\n      return new MapEntry<>((T) list.get(x), (U) list.get(x + 1));\n    }", "docstring": "", "attributes": {"modifiers": "@SuppressWarnings(\"unchecked\")\n    @Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["@SuppressWarnings(\"unchecked\")", "public"], "comments": [], "return_type": "Map.Entry<T, U>", "classes": []}, "name": "get", "params": [{"name": "index", "type": "int"}], "body": "                                                    {\n      int x = index * 2;\n      return new MapEntry<>((T) list.get(x), (U) list.get(x + 1));\n    }", "signature": "@SuppressWarnings(\"unchecked\")\n    @Override public Map.Entry<T, U> get(int index)"}, {"syntax_pass": true, "original_string": "    @SuppressWarnings(\"unchecked\")\n    @Override public T left(int index) {\n      int x = index * 2;\n      return (T) list.get(x);\n    }", "docstring": "", "attributes": {"modifiers": "@SuppressWarnings(\"unchecked\")\n    @Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["@SuppressWarnings(\"unchecked\")", "public"], "comments": [], "return_type": "T", "classes": []}, "name": "left", "params": [{"name": "index", "type": "int"}], "body": "                                       {\n      int x = index * 2;\n      return (T) list.get(x);\n    }", "signature": "@SuppressWarnings(\"unchecked\")\n    @Override public T left(int index)"}, {"syntax_pass": true, "original_string": "    @SuppressWarnings(\"unchecked\")\n    @Override public U right(int index) {\n      int x = index * 2;\n      return (U) list.get(x + 1);\n    }", "docstring": "", "attributes": {"modifiers": "@SuppressWarnings(\"unchecked\")\n    @Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["@SuppressWarnings(\"unchecked\")", "public"], "comments": [], "return_type": "U", "classes": []}, "name": "right", "params": [{"name": "index", "type": "int"}], "body": "                                        {\n      int x = index * 2;\n      return (U) list.get(x + 1);\n    }", "signature": "@SuppressWarnings(\"unchecked\")\n    @Override public U right(int index)"}, {"syntax_pass": true, "original_string": "    @Override public Map.Entry<T, U> set(int index, Map.Entry<T, U> entry) {\n      return set(index, entry.getKey(), entry.getValue());\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Map.Entry<T, U>", "classes": []}, "name": "set", "params": [{"name": "index", "type": "int"}, {"name": "entry", "type": "Map.Entry<T, U>"}], "body": "                                                                           {\n      return set(index, entry.getKey(), entry.getValue());\n    }", "signature": "@Override public Map.Entry<T, U> set(int index, Map.Entry<T, U> entry)"}, {"syntax_pass": true, "original_string": "    @SuppressWarnings(\"unchecked\")\n    @Override public Map.Entry<T, U> set(int index, T t, U u) {\n      int x = index * 2;\n      T t0 = (T) list.set(x, t);\n      U u0 = (U) list.set(x + 1, u);\n      return new MapEntry<>(t0, u0);\n    }", "docstring": "", "attributes": {"modifiers": "@SuppressWarnings(\"unchecked\")\n    @Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["@SuppressWarnings(\"unchecked\")", "public"], "comments": [], "return_type": "Map.Entry<T, U>", "classes": []}, "name": "set", "params": [{"name": "index", "type": "int"}, {"name": "t", "type": "T"}, {"name": "u", "type": "U"}], "body": "                                                              {\n      int x = index * 2;\n      T t0 = (T) list.set(x, t);\n      U u0 = (U) list.set(x + 1, u);\n      return new MapEntry<>(t0, u0);\n    }", "signature": "@SuppressWarnings(\"unchecked\")\n    @Override public Map.Entry<T, U> set(int index, T t, U u)"}, {"syntax_pass": true, "original_string": "    @SuppressWarnings(\"unchecked\")\n    @Override public Map.Entry<T, U> remove(int index) {\n      final int x = index * 2;\n      T t = (T) list.remove(x);\n      U u = (U) list.remove(x);\n      return new MapEntry<>(t, u);\n    }", "docstring": "", "attributes": {"modifiers": "@SuppressWarnings(\"unchecked\")\n    @Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["@SuppressWarnings(\"unchecked\")", "public"], "comments": [], "return_type": "Map.Entry<T, U>", "classes": []}, "name": "remove", "params": [{"name": "index", "type": "int"}], "body": "                                                       {\n      final int x = index * 2;\n      T t = (T) list.remove(x);\n      U u = (U) list.remove(x);\n      return new MapEntry<>(t, u);\n    }", "signature": "@SuppressWarnings(\"unchecked\")\n    @Override public Map.Entry<T, U> remove(int index)"}, {"syntax_pass": true, "original_string": "    @SuppressWarnings(\"RedundantCast\")\n    @Override public boolean add(Map.Entry<T, U> entry) {\n      list.add((Object) entry.getKey());\n      list.add((Object) entry.getValue());\n      return true;\n    }", "docstring": "", "attributes": {"modifiers": "@SuppressWarnings(\"RedundantCast\")\n    @Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["@SuppressWarnings(\"RedundantCast\")", "public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "add", "params": [{"name": "entry", "type": "Map.Entry<T, U>"}], "body": "                                                        {\n      list.add((Object) entry.getKey());\n      list.add((Object) entry.getValue());\n      return true;\n    }", "signature": "@SuppressWarnings(\"RedundantCast\")\n    @Override public boolean add(Map.Entry<T, U> entry)"}, {"syntax_pass": true, "original_string": "    @SuppressWarnings(\"RedundantCast\")\n    @Override public void add(int index, Map.Entry<T, U> entry) {\n      int x = index * 2;\n      list.add(x, (Object) entry.getKey());\n      list.add(x + 1, (Object) entry.getValue());\n    }", "docstring": "", "attributes": {"modifiers": "@SuppressWarnings(\"RedundantCast\")\n    @Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["@SuppressWarnings(\"RedundantCast\")", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "add", "params": [{"name": "index", "type": "int"}, {"name": "entry", "type": "Map.Entry<T, U>"}], "body": "                                                                {\n      int x = index * 2;\n      list.add(x, (Object) entry.getKey());\n      list.add(x + 1, (Object) entry.getValue());\n    }", "signature": "@SuppressWarnings(\"RedundantCast\")\n    @Override public void add(int index, Map.Entry<T, U> entry)"}, {"syntax_pass": true, "original_string": "    @SuppressWarnings(\"RedundantCast\")\n    @Override public void add(T t, U u) {\n      list.add((Object) t);\n      list.add((Object) u);\n    }", "docstring": "", "attributes": {"modifiers": "@SuppressWarnings(\"RedundantCast\")\n    @Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["@SuppressWarnings(\"RedundantCast\")", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "add", "params": [{"name": "t", "type": "T"}, {"name": "u", "type": "U"}], "body": "                                        {\n      list.add((Object) t);\n      list.add((Object) u);\n    }", "signature": "@SuppressWarnings(\"RedundantCast\")\n    @Override public void add(T t, U u)"}, {"syntax_pass": true, "original_string": "    @SuppressWarnings(\"RedundantCast\")\n    @Override public void add(int index, T t, U u) {\n      int x = index * 2;\n      list.add(x, (Object) t);\n      list.add(x + 1, (Object) u);\n    }", "docstring": "", "attributes": {"modifiers": "@SuppressWarnings(\"RedundantCast\")\n    @Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["@SuppressWarnings(\"RedundantCast\")", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "add", "params": [{"name": "index", "type": "int"}, {"name": "t", "type": "T"}, {"name": "u", "type": "U"}], "body": "                                                   {\n      int x = index * 2;\n      list.add(x, (Object) t);\n      list.add(x + 1, (Object) u);\n    }", "signature": "@SuppressWarnings(\"RedundantCast\")\n    @Override public void add(int index, T t, U u)"}, {"syntax_pass": true, "original_string": "    @Override public boolean addAll(PairList<T, U> list2) {\n      return list.addAll(((AbstractPairList<T, U>) list2).backingList());\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "addAll", "params": [{"name": "list2", "type": "PairList<T, U>"}], "body": "                                                          {\n      return list.addAll(((AbstractPairList<T, U>) list2).backingList());\n    }", "signature": "@Override public boolean addAll(PairList<T, U> list2)"}, {"syntax_pass": true, "original_string": "    @Override public boolean addAll(int index, PairList<T, U> list2) {\n      int x = index * 2;\n      return list.addAll(x, ((AbstractPairList<T, U>) list2).backingList());\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "addAll", "params": [{"name": "index", "type": "int"}, {"name": "list2", "type": "PairList<T, U>"}], "body": "                                                                     {\n      int x = index * 2;\n      return list.addAll(x, ((AbstractPairList<T, U>) list2).backingList());\n    }", "signature": "@Override public boolean addAll(int index, PairList<T, U> list2)"}, {"syntax_pass": true, "original_string": "    @SuppressWarnings(\"unchecked\")\n    @Override public List<T> leftList() {\n      final int size = list.size() / 2;\n      return new RandomAccessList<T>() {\n        @Override public int size() {\n          return size;\n        }\n\n        @Override public T get(int index) {\n          return (T) list.get(index * 2);\n        }\n      };\n    }", "docstring": "", "attributes": {"modifiers": "@SuppressWarnings(\"unchecked\")\n    @Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["@SuppressWarnings(\"unchecked\")", "public"], "comments": [], "return_type": "List<T>", "classes": []}, "name": "leftList", "params": [], "body": "                                        {\n      final int size = list.size() / 2;\n      return new RandomAccessList<T>() {\n        @Override public int size() {\n          return size;\n        }\n\n        @Override public T get(int index) {\n          return (T) list.get(index * 2);\n        }\n      };\n    }", "signature": "@SuppressWarnings(\"unchecked\")\n    @Override public List<T> leftList()"}, {"syntax_pass": true, "original_string": "    @SuppressWarnings(\"unchecked\")\n    @Override public List<U> rightList() {\n      final int size = list.size() / 2;\n      return new RandomAccessList<U>() {\n        @Override public int size() {\n          return size;\n        }\n\n        @Override public U get(int index) {\n          return (U) list.get(index * 2 + 1);\n        }\n      };\n    }", "docstring": "", "attributes": {"modifiers": "@SuppressWarnings(\"unchecked\")\n    @Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["@SuppressWarnings(\"unchecked\")", "public"], "comments": [], "return_type": "List<U>", "classes": []}, "name": "rightList", "params": [], "body": "                                         {\n      final int size = list.size() / 2;\n      return new RandomAccessList<U>() {\n        @Override public int size() {\n          return size;\n        }\n\n        @Override public U get(int index) {\n          return (U) list.get(index * 2 + 1);\n        }\n      };\n    }", "signature": "@SuppressWarnings(\"unchecked\")\n    @Override public List<U> rightList()"}, {"syntax_pass": true, "original_string": "    @SuppressWarnings(\"unchecked\")\n    @Override public void forEach(BiConsumer<T, U> consumer) {\n      requireNonNull(consumer, \"consumer\");\n      for (int i = 0; i < list.size();) {\n        T t = (T) list.get(i++);\n        U u = (U) list.get(i++);\n        consumer.accept(t, u);\n      }\n    }", "docstring": "", "attributes": {"modifiers": "@SuppressWarnings(\"unchecked\")\n    @Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["@SuppressWarnings(\"unchecked\")", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "forEach", "params": [{"name": "consumer", "type": "BiConsumer<T, U>"}], "body": "                                                             {\n      requireNonNull(consumer, \"consumer\");\n      for (int i = 0; i < list.size();) {\n        T t = (T) list.get(i++);\n        U u = (U) list.get(i++);\n        consumer.accept(t, u);\n      }\n    }", "signature": "@SuppressWarnings(\"unchecked\")\n    @Override public void forEach(BiConsumer<T, U> consumer)"}, {"syntax_pass": true, "original_string": "    @SuppressWarnings(\"unchecked\")\n    @Override public void forEachIndexed(IndexedBiConsumer<T, U> consumer) {\n      requireNonNull(consumer, \"consumer\");\n      for (int i = 0, j = 0; i < list.size();) {\n        T t = (T) list.get(i++);\n        U u = (U) list.get(i++);\n        consumer.accept(j++, t, u);\n      }\n    }", "docstring": "", "attributes": {"modifiers": "@SuppressWarnings(\"unchecked\")\n    @Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["@SuppressWarnings(\"unchecked\")", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "forEachIndexed", "params": [{"name": "consumer", "type": "IndexedBiConsumer<T, U>"}], "body": "                                                                           {\n      requireNonNull(consumer, \"consumer\");\n      for (int i = 0, j = 0; i < list.size();) {\n        T t = (T) list.get(i++);\n        U u = (U) list.get(i++);\n        consumer.accept(j++, t, u);\n      }\n    }", "signature": "@SuppressWarnings(\"unchecked\")\n    @Override public void forEachIndexed(IndexedBiConsumer<T, U> consumer)"}, {"syntax_pass": true, "original_string": "    @Override public ImmutableMap<T, U> toImmutableMap() {\n      final ImmutableMap.Builder<T, U> b = ImmutableMap.builder();\n      forEach((t, u) -> b.put(t, u));\n      return b.build();\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "ImmutableMap<T, U>", "classes": []}, "name": "toImmutableMap", "params": [], "body": "                                                         {\n      final ImmutableMap.Builder<T, U> b = ImmutableMap.builder();\n      forEach((t, u) -> b.put(t, u));\n      return b.build();\n    }", "signature": "@Override public ImmutableMap<T, U> toImmutableMap()"}, {"syntax_pass": true, "original_string": "    @Override public ImmutablePairList<T, U> immutable() {\n      return immutableBackedBy(list);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "ImmutablePairList<T, U>", "classes": []}, "name": "immutable", "params": [], "body": "                                                         {\n      return immutableBackedBy(list);\n    }", "signature": "@Override public ImmutablePairList<T, U> immutable()"}, {"syntax_pass": true, "original_string": "    @SuppressWarnings(\"unchecked\")\n    @Override public <R> List<R> transform(BiFunction<T, U, R> function) {\n      return Functions.generate(list.size() / 2, index -> {\n        final int x = index * 2;\n        final T t = (T) list.get(x);\n        final U u = (U) list.get(x + 1);\n        return function.apply(t, u);\n      });\n    }", "docstring": "", "attributes": {"modifiers": "@SuppressWarnings(\"unchecked\")\n    @Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["@SuppressWarnings(\"unchecked\")", "public"], "comments": [], "return_type": "List<R>", "classes": []}, "name": "transform", "params": [{"name": "function", "type": "BiFunction<T, U, R>"}], "body": "                                                                         {\n      return Functions.generate(list.size() / 2, index -> {\n        final int x = index * 2;\n        final T t = (T) list.get(x);\n        final U u = (U) list.get(x + 1);\n        return function.apply(t, u);\n      });\n    }", "signature": "@SuppressWarnings(\"unchecked\")\n    @Override public <R> List<R> transform(BiFunction<T, U, R> function)"}, {"syntax_pass": true, "original_string": "    @SuppressWarnings(\"unchecked\")\n    @Override public <R> ImmutableList<R> transform2(\n        BiFunction<T, U, R> function) {\n      if (list.isEmpty()) {\n        return ImmutableList.of();\n      }\n      final ImmutableList.Builder<R> builder = ImmutableList.builder();\n      for (int i = 0, n = list.size(); i < n;) {\n        final T t = (T) list.get(i++);\n        final U u = (U) list.get(i++);\n        builder.add(function.apply(t, u));\n      }\n      return builder.build();\n    }", "docstring": "", "attributes": {"modifiers": "@SuppressWarnings(\"unchecked\")\n    @Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["@SuppressWarnings(\"unchecked\")", "public"], "comments": [], "return_type": "ImmutableList<R>", "classes": []}, "name": "transform2", "params": [{"name": "function", "type": "BiFunction<T, U, R>"}], "body": "                                      {\n      if (list.isEmpty()) {\n        return ImmutableList.of();\n      }\n      final ImmutableList.Builder<R> builder = ImmutableList.builder();\n      for (int i = 0, n = list.size(); i < n;) {\n        final T t = (T) list.get(i++);\n        final U u = (U) list.get(i++);\n        builder.add(function.apply(t, u));\n      }\n      return builder.build();\n    }", "signature": "@SuppressWarnings(\"unchecked\")\n    @Override public <R> ImmutableList<R> transform2(\n        BiFunction<T, U, R> function)"}, {"syntax_pass": true, "original_string": "    @SuppressWarnings(\"unchecked\")\n    @Override public boolean anyMatch(BiPredicate<T, U> predicate) {\n      for (int i = 0; i < list.size();) {\n        final T t = (T) list.get(i++);\n        final U u = (U) list.get(i++);\n        if (predicate.test(t, u)) {\n          return true;\n        }\n      }\n      return false;\n    }", "docstring": "", "attributes": {"modifiers": "@SuppressWarnings(\"unchecked\")\n    @Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["@SuppressWarnings(\"unchecked\")", "public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "anyMatch", "params": [{"name": "predicate", "type": "BiPredicate<T, U>"}], "body": "                                                                   {\n      for (int i = 0; i < list.size();) {\n        final T t = (T) list.get(i++);\n        final U u = (U) list.get(i++);\n        if (predicate.test(t, u)) {\n          return true;\n        }\n      }\n      return false;\n    }", "signature": "@SuppressWarnings(\"unchecked\")\n    @Override public boolean anyMatch(BiPredicate<T, U> predicate)"}, {"syntax_pass": true, "original_string": "    @SuppressWarnings(\"unchecked\")\n    @Override public boolean allMatch(BiPredicate<T, U> predicate) {\n      for (int i = 0; i < list.size();) {\n        final T t = (T) list.get(i++);\n        final U u = (U) list.get(i++);\n        if (!predicate.test(t, u)) {\n          return false;\n        }\n      }\n      return true;\n    }", "docstring": "", "attributes": {"modifiers": "@SuppressWarnings(\"unchecked\")\n    @Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["@SuppressWarnings(\"unchecked\")", "public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "allMatch", "params": [{"name": "predicate", "type": "BiPredicate<T, U>"}], "body": "                                                                   {\n      for (int i = 0; i < list.size();) {\n        final T t = (T) list.get(i++);\n        final U u = (U) list.get(i++);\n        if (!predicate.test(t, u)) {\n          return false;\n        }\n      }\n      return true;\n    }", "signature": "@SuppressWarnings(\"unchecked\")\n    @Override public boolean allMatch(BiPredicate<T, U> predicate)"}, {"syntax_pass": true, "original_string": "    @SuppressWarnings(\"unchecked\")\n    @Override public boolean noMatch(BiPredicate<T, U> predicate) {\n      for (int i = 0; i < list.size();) {\n        final T t = (T) list.get(i++);\n        final U u = (U) list.get(i++);\n        if (predicate.test(t, u)) {\n          return false;\n        }\n      }\n      return true;\n    }", "docstring": "", "attributes": {"modifiers": "@SuppressWarnings(\"unchecked\")\n    @Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["@SuppressWarnings(\"unchecked\")", "public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "noMatch", "params": [{"name": "predicate", "type": "BiPredicate<T, U>"}], "body": "                                                                  {\n      for (int i = 0; i < list.size();) {\n        final T t = (T) list.get(i++);\n        final U u = (U) list.get(i++);\n        if (predicate.test(t, u)) {\n          return false;\n        }\n      }\n      return true;\n    }", "signature": "@SuppressWarnings(\"unchecked\")\n    @Override public boolean noMatch(BiPredicate<T, U> predicate)"}, {"syntax_pass": true, "original_string": "    @SuppressWarnings(\"unchecked\")\n    @Override public int firstMatch(BiPredicate<T, U> predicate) {\n      for (int i = 0, j = 0; i < list.size(); ++j) {\n        final T t = (T) list.get(i++);\n        final U u = (U) list.get(i++);\n        if (predicate.test(t, u)) {\n          return j;\n        }\n      }\n      return -1;\n    }", "docstring": "", "attributes": {"modifiers": "@SuppressWarnings(\"unchecked\")\n    @Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["@SuppressWarnings(\"unchecked\")", "public"], "comments": [], "return_type": "int", "classes": []}, "name": "firstMatch", "params": [{"name": "predicate", "type": "BiPredicate<T, U>"}], "body": "                                                                 {\n      for (int i = 0, j = 0; i < list.size(); ++j) {\n        final T t = (T) list.get(i++);\n        final U u = (U) list.get(i++);\n        if (predicate.test(t, u)) {\n          return j;\n        }\n      }\n      return -1;\n    }", "signature": "@SuppressWarnings(\"unchecked\")\n    @Override public int firstMatch(BiPredicate<T, U> predicate)"}]}, {"original_string": "  static class EmptyImmutablePairList<T, U>\n      extends AbstractPairList<T, U>\n      implements ImmutablePairList<T, U> {\n    @Override List<Object> backingList() {\n      return ImmutableList.of();\n    }\n\n    @Override public Map.Entry<T, U> get(int index) {\n      throw new IndexOutOfBoundsException(\"Index out of range: \" + index);\n    }\n\n    @Override public T left(int index) {\n      throw new IndexOutOfBoundsException(\"Index out of range: \" + index);\n    }\n\n    @Override public U right(int index) {\n      throw new IndexOutOfBoundsException(\"Index out of range: \" + index);\n    }\n\n    @Override public int size() {\n      return 0;\n    }\n\n    @Override public List<T> leftList() {\n      return ImmutableList.of();\n    }\n\n    @Override public List<U> rightList() {\n      return ImmutableList.of();\n    }\n\n    @Override public void forEach(BiConsumer<T, U> consumer) {\n    }\n\n    @Override public void forEachIndexed(IndexedBiConsumer<T, U> consumer) {\n    }\n\n    @Override public <R> List<R> transform(BiFunction<T, U, R> function) {\n      return ImmutableList.of();\n    }\n\n    @Override public <R> ImmutableList<R> transform2(\n        BiFunction<T, U, R> function) {\n      return ImmutableList.of();\n    }\n\n    @Override public boolean anyMatch(BiPredicate<T, U> predicate) {\n      return false;\n    }\n\n    @Override public boolean allMatch(BiPredicate<T, U> predicate) {\n      return true;\n    }\n\n    @Override public boolean noMatch(BiPredicate<T, U> predicate) {\n      return true;\n    }\n\n    @Override public int firstMatch(BiPredicate<T, U> predicate) {\n      return -1;\n    }\n  }", "definition": "  static class EmptyImmutablePairList<T, U>\n      extends AbstractPairList<T, U>\n      implements ImmutablePairList<T, U>", "class_docstring": " Empty immutable list of pairs.\n\n@param <T> First type\n@param <U> Second type\n", "name": "EmptyImmutablePairList", "super_interfaces": ["ImmutablePairList<T, U>"], "superclasses": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @Override List<Object> backingList() {\n      return ImmutableList.of();\n    }", "docstring": "", "attributes": {"modifiers": "@Override", "marker_annotations": ["@Override"], "non_marker_annotations": [], "comments": [], "return_type": "List<Object>", "classes": []}, "name": "backingList", "params": [], "body": "                                         {\n      return ImmutableList.of();\n    }", "signature": "@Override List<Object> backingList()"}, {"syntax_pass": true, "original_string": "    @Override public Map.Entry<T, U> get(int index) {\n      throw new IndexOutOfBoundsException(\"Index out of range: \" + index);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Map.Entry<T, U>", "classes": []}, "name": "get", "params": [{"name": "index", "type": "int"}], "body": "                                                    {\n      throw new IndexOutOfBoundsException(\"Index out of range: \" + index);\n    }", "signature": "@Override public Map.Entry<T, U> get(int index)"}, {"syntax_pass": true, "original_string": "    @Override public T left(int index) {\n      throw new IndexOutOfBoundsException(\"Index out of range: \" + index);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "T", "classes": []}, "name": "left", "params": [{"name": "index", "type": "int"}], "body": "                                       {\n      throw new IndexOutOfBoundsException(\"Index out of range: \" + index);\n    }", "signature": "@Override public T left(int index)"}, {"syntax_pass": true, "original_string": "    @Override public U right(int index) {\n      throw new IndexOutOfBoundsException(\"Index out of range: \" + index);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "U", "classes": []}, "name": "right", "params": [{"name": "index", "type": "int"}], "body": "                                        {\n      throw new IndexOutOfBoundsException(\"Index out of range: \" + index);\n    }", "signature": "@Override public U right(int index)"}, {"syntax_pass": true, "original_string": "    @Override public int size() {\n      return 0;\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "size", "params": [], "body": "                                {\n      return 0;\n    }", "signature": "@Override public int size()"}, {"syntax_pass": true, "original_string": "    @Override public List<T> leftList() {\n      return ImmutableList.of();\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "List<T>", "classes": []}, "name": "leftList", "params": [], "body": "                                        {\n      return ImmutableList.of();\n    }", "signature": "@Override public List<T> leftList()"}, {"syntax_pass": true, "original_string": "    @Override public List<U> rightList() {\n      return ImmutableList.of();\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "List<U>", "classes": []}, "name": "rightList", "params": [], "body": "                                         {\n      return ImmutableList.of();\n    }", "signature": "@Override public List<U> rightList()"}, {"syntax_pass": true, "original_string": "    @Override public void forEach(BiConsumer<T, U> consumer) {\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "forEach", "params": [{"name": "consumer", "type": "BiConsumer<T, U>"}], "body": "                                                             {\n    }", "signature": "@Override public void forEach(BiConsumer<T, U> consumer)"}, {"syntax_pass": true, "original_string": "    @Override public void forEachIndexed(IndexedBiConsumer<T, U> consumer) {\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "forEachIndexed", "params": [{"name": "consumer", "type": "IndexedBiConsumer<T, U>"}], "body": "                                                                           {\n    }", "signature": "@Override public void forEachIndexed(IndexedBiConsumer<T, U> consumer)"}, {"syntax_pass": true, "original_string": "    @Override public <R> List<R> transform(BiFunction<T, U, R> function) {\n      return ImmutableList.of();\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "List<R>", "classes": []}, "name": "transform", "params": [{"name": "function", "type": "BiFunction<T, U, R>"}], "body": "                                                                         {\n      return ImmutableList.of();\n    }", "signature": "@Override public <R> List<R> transform(BiFunction<T, U, R> function)"}, {"syntax_pass": true, "original_string": "    @Override public <R> ImmutableList<R> transform2(\n        BiFunction<T, U, R> function) {\n      return ImmutableList.of();\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "ImmutableList<R>", "classes": []}, "name": "transform2", "params": [{"name": "function", "type": "BiFunction<T, U, R>"}], "body": "                                      {\n      return ImmutableList.of();\n    }", "signature": "@Override public <R> ImmutableList<R> transform2(\n        BiFunction<T, U, R> function)"}, {"syntax_pass": true, "original_string": "    @Override public boolean anyMatch(BiPredicate<T, U> predicate) {\n      return false;\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "anyMatch", "params": [{"name": "predicate", "type": "BiPredicate<T, U>"}], "body": "                                                                   {\n      return false;\n    }", "signature": "@Override public boolean anyMatch(BiPredicate<T, U> predicate)"}, {"syntax_pass": true, "original_string": "    @Override public boolean allMatch(BiPredicate<T, U> predicate) {\n      return true;\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "allMatch", "params": [{"name": "predicate", "type": "BiPredicate<T, U>"}], "body": "                                                                   {\n      return true;\n    }", "signature": "@Override public boolean allMatch(BiPredicate<T, U> predicate)"}, {"syntax_pass": true, "original_string": "    @Override public boolean noMatch(BiPredicate<T, U> predicate) {\n      return true;\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "noMatch", "params": [{"name": "predicate", "type": "BiPredicate<T, U>"}], "body": "                                                                  {\n      return true;\n    }", "signature": "@Override public boolean noMatch(BiPredicate<T, U> predicate)"}, {"syntax_pass": true, "original_string": "    @Override public int firstMatch(BiPredicate<T, U> predicate) {\n      return -1;\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "firstMatch", "params": [{"name": "predicate", "type": "BiPredicate<T, U>"}], "body": "                                                                 {\n      return -1;\n    }", "signature": "@Override public int firstMatch(BiPredicate<T, U> predicate)"}]}, {"original_string": "  static class SingletonImmutablePairList<T, U>\n      extends AbstractPairList<T, U>\n      implements ImmutablePairList<T, U> {\n    private final T t;\n    private final U u;\n\n    SingletonImmutablePairList(T t, U u) {\n      this.t = t;\n      this.u = u;\n      checkElementNotNull(0, t);\n      checkElementNotNull(1, u);\n    }\n\n    @Override List<Object> backingList() {\n      return ImmutableList.of(t, u);\n    }\n\n    @Override public Map.Entry<T, U> get(int index) {\n      if (index != 0) {\n        throw new IndexOutOfBoundsException(\"Index out of range: \" + index);\n      }\n      return new MapEntry<>(t, u);\n    }\n\n    @Override public T left(int index) {\n      if (index != 0) {\n        throw new IndexOutOfBoundsException(\"Index out of range: \" + index);\n      }\n      return t;\n    }\n\n    @Override public U right(int index) {\n      if (index != 0) {\n        throw new IndexOutOfBoundsException(\"Index out of range: \" + index);\n      }\n      return u;\n    }\n\n    @Override public int size() {\n      return 1;\n    }\n\n    @Override public List<T> leftList() {\n      return ImmutableList.of(t);\n    }\n\n    @Override public List<U> rightList() {\n      return ImmutableList.of(u);\n    }\n\n    @Override public void forEach(BiConsumer<T, U> consumer) {\n      consumer.accept(t, u);\n    }\n\n    @Override public void forEachIndexed(IndexedBiConsumer<T, U> consumer) {\n      consumer.accept(0, t, u);\n    }\n\n    @Override public <R> List<R> transform(BiFunction<T, U, R> function) {\n      return ImmutableList.of(function.apply(t, u));\n    }\n\n    @Override public <R> ImmutableList<R> transform2(\n        BiFunction<T, U, R> function) {\n      return ImmutableList.of(function.apply(t, u));\n    }\n\n    @Override public boolean anyMatch(BiPredicate<T, U> predicate) {\n      return predicate.test(t, u);\n    }\n\n    @Override public boolean allMatch(BiPredicate<T, U> predicate) {\n      return predicate.test(t, u);\n    }\n\n    @Override public boolean noMatch(BiPredicate<T, U> predicate) {\n      return !predicate.test(t, u);\n    }\n\n    @Override public int firstMatch(BiPredicate<T, U> predicate) {\n      return predicate.test(t, u) ? 0 : -1;\n    }\n  }", "definition": "  static class SingletonImmutablePairList<T, U>\n      extends AbstractPairList<T, U>\n      implements ImmutablePairList<T, U>", "class_docstring": " Immutable list that contains one pair.\n\n@param <T> First type\n@param <U> Second type\n", "name": "SingletonImmutablePairList", "super_interfaces": ["ImmutablePairList<T, U>"], "superclasses": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "fields": [{"attribute_expression": "private final T t;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "T", "name": "t", "syntax_pass": true}, {"attribute_expression": "private final U u;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "U", "name": "u", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    SingletonImmutablePairList(T t, U u) {\n      this.t = t;\n      this.u = u;\n      checkElementNotNull(0, t);\n      checkElementNotNull(1, u);\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "SingletonImmutablePairList", "params": [{"name": "t", "type": "T"}, {"name": "u", "type": "U"}], "body": "                                         {\n      this.t = t;\n      this.u = u;\n      checkElementNotNull(0, t);\n      checkElementNotNull(1, u);\n    }", "signature": "SingletonImmutablePairList(T t, U u)"}, {"syntax_pass": true, "original_string": "    @Override List<Object> backingList() {\n      return ImmutableList.of(t, u);\n    }", "docstring": "", "attributes": {"modifiers": "@Override", "marker_annotations": ["@Override"], "non_marker_annotations": [], "comments": [], "return_type": "List<Object>", "classes": []}, "name": "backingList", "params": [], "body": "                                         {\n      return ImmutableList.of(t, u);\n    }", "signature": "@Override List<Object> backingList()"}, {"syntax_pass": true, "original_string": "    @Override public Map.Entry<T, U> get(int index) {\n      if (index != 0) {\n        throw new IndexOutOfBoundsException(\"Index out of range: \" + index);\n      }\n      return new MapEntry<>(t, u);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Map.Entry<T, U>", "classes": []}, "name": "get", "params": [{"name": "index", "type": "int"}], "body": "                                                    {\n      if (index != 0) {\n        throw new IndexOutOfBoundsException(\"Index out of range: \" + index);\n      }\n      return new MapEntry<>(t, u);\n    }", "signature": "@Override public Map.Entry<T, U> get(int index)"}, {"syntax_pass": true, "original_string": "    @Override public T left(int index) {\n      if (index != 0) {\n        throw new IndexOutOfBoundsException(\"Index out of range: \" + index);\n      }\n      return t;\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "T", "classes": []}, "name": "left", "params": [{"name": "index", "type": "int"}], "body": "                                       {\n      if (index != 0) {\n        throw new IndexOutOfBoundsException(\"Index out of range: \" + index);\n      }\n      return t;\n    }", "signature": "@Override public T left(int index)"}, {"syntax_pass": true, "original_string": "    @Override public U right(int index) {\n      if (index != 0) {\n        throw new IndexOutOfBoundsException(\"Index out of range: \" + index);\n      }\n      return u;\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "U", "classes": []}, "name": "right", "params": [{"name": "index", "type": "int"}], "body": "                                        {\n      if (index != 0) {\n        throw new IndexOutOfBoundsException(\"Index out of range: \" + index);\n      }\n      return u;\n    }", "signature": "@Override public U right(int index)"}, {"syntax_pass": true, "original_string": "    @Override public int size() {\n      return 1;\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "size", "params": [], "body": "                                {\n      return 1;\n    }", "signature": "@Override public int size()"}, {"syntax_pass": true, "original_string": "    @Override public List<T> leftList() {\n      return ImmutableList.of(t);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "List<T>", "classes": []}, "name": "leftList", "params": [], "body": "                                        {\n      return ImmutableList.of(t);\n    }", "signature": "@Override public List<T> leftList()"}, {"syntax_pass": true, "original_string": "    @Override public List<U> rightList() {\n      return ImmutableList.of(u);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "List<U>", "classes": []}, "name": "rightList", "params": [], "body": "                                         {\n      return ImmutableList.of(u);\n    }", "signature": "@Override public List<U> rightList()"}, {"syntax_pass": true, "original_string": "    @Override public void forEach(BiConsumer<T, U> consumer) {\n      consumer.accept(t, u);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "forEach", "params": [{"name": "consumer", "type": "BiConsumer<T, U>"}], "body": "                                                             {\n      consumer.accept(t, u);\n    }", "signature": "@Override public void forEach(BiConsumer<T, U> consumer)"}, {"syntax_pass": true, "original_string": "    @Override public void forEachIndexed(IndexedBiConsumer<T, U> consumer) {\n      consumer.accept(0, t, u);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "forEachIndexed", "params": [{"name": "consumer", "type": "IndexedBiConsumer<T, U>"}], "body": "                                                                           {\n      consumer.accept(0, t, u);\n    }", "signature": "@Override public void forEachIndexed(IndexedBiConsumer<T, U> consumer)"}, {"syntax_pass": true, "original_string": "    @Override public <R> List<R> transform(BiFunction<T, U, R> function) {\n      return ImmutableList.of(function.apply(t, u));\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "List<R>", "classes": []}, "name": "transform", "params": [{"name": "function", "type": "BiFunction<T, U, R>"}], "body": "                                                                         {\n      return ImmutableList.of(function.apply(t, u));\n    }", "signature": "@Override public <R> List<R> transform(BiFunction<T, U, R> function)"}, {"syntax_pass": true, "original_string": "    @Override public <R> ImmutableList<R> transform2(\n        BiFunction<T, U, R> function) {\n      return ImmutableList.of(function.apply(t, u));\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "ImmutableList<R>", "classes": []}, "name": "transform2", "params": [{"name": "function", "type": "BiFunction<T, U, R>"}], "body": "                                      {\n      return ImmutableList.of(function.apply(t, u));\n    }", "signature": "@Override public <R> ImmutableList<R> transform2(\n        BiFunction<T, U, R> function)"}, {"syntax_pass": true, "original_string": "    @Override public boolean anyMatch(BiPredicate<T, U> predicate) {\n      return predicate.test(t, u);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "anyMatch", "params": [{"name": "predicate", "type": "BiPredicate<T, U>"}], "body": "                                                                   {\n      return predicate.test(t, u);\n    }", "signature": "@Override public boolean anyMatch(BiPredicate<T, U> predicate)"}, {"syntax_pass": true, "original_string": "    @Override public boolean allMatch(BiPredicate<T, U> predicate) {\n      return predicate.test(t, u);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "allMatch", "params": [{"name": "predicate", "type": "BiPredicate<T, U>"}], "body": "                                                                   {\n      return predicate.test(t, u);\n    }", "signature": "@Override public boolean allMatch(BiPredicate<T, U> predicate)"}, {"syntax_pass": true, "original_string": "    @Override public boolean noMatch(BiPredicate<T, U> predicate) {\n      return !predicate.test(t, u);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "noMatch", "params": [{"name": "predicate", "type": "BiPredicate<T, U>"}], "body": "                                                                  {\n      return !predicate.test(t, u);\n    }", "signature": "@Override public boolean noMatch(BiPredicate<T, U> predicate)"}, {"syntax_pass": true, "original_string": "    @Override public int firstMatch(BiPredicate<T, U> predicate) {\n      return predicate.test(t, u) ? 0 : -1;\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "firstMatch", "params": [{"name": "predicate", "type": "BiPredicate<T, U>"}], "body": "                                                                 {\n      return predicate.test(t, u) ? 0 : -1;\n    }", "signature": "@Override public int firstMatch(BiPredicate<T, U> predicate)"}]}, {"original_string": "  abstract static class RandomAccessList<E>\n      extends AbstractList<E> implements RandomAccess {\n  }", "definition": "  abstract static class RandomAccessList<E>\n      extends AbstractList<E> implements RandomAccess", "class_docstring": " Base class for a list that implements {@link RandomAccess}.\n\n@param <E> Element type", "name": "RandomAccessList", "super_interfaces": ["RandomAccess"], "superclasses": "", "attributes": {"modifiers": "abstract static", "marker_annotations": [], "non_marker_annotations": ["abstract", "static"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": []}, {"original_string": "  static class ArrayImmutablePairList<T, U>\n      extends AbstractPairList<T, U>\n      implements ImmutablePairList<T, U> {\n    private final Object[] elements;\n\n    /** Creates an ArrayImmutablePairList.\n     *\n     * <p>Does not copy the {@code elements} array. Assumes that the caller has\n     * made a copy, and will never modify the contents.\n     *\n     * <p>Assumes that {@code elements} is not null, but checks that none of\n     * its elements are null. */\n    ArrayImmutablePairList(Object[] elements) {\n      this.elements = checkElementsNotNull(elements);\n    }\n\n    @Override List<Object> backingList() {\n      return Arrays.asList(elements);\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @Override public Map.Entry<T, U> get(int index) {\n      int x = index * 2;\n      return new MapEntry<>((T) elements[x], (U) elements[x + 1]);\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @Override public T left(int index) {\n      int x = index * 2;\n      return (T) elements[x];\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @Override public U right(int index) {\n      int x = index * 2;\n      return (U) elements[x + 1];\n    }\n\n    @Override public int size() {\n      return elements.length / 2;\n    }\n\n    @Override public List<T> leftList() {\n      return new RandomAccessList<T>() {\n        @Override public int size() {\n          return elements.length / 2;\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        @Override public T get(int index) {\n          return (T) elements[index * 2];\n        }\n      };\n    }\n\n    @Override public List<U> rightList() {\n      return new RandomAccessList<U>() {\n        @Override public int size() {\n          return elements.length / 2;\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        @Override public U get(int index) {\n          return (U) elements[index * 2 + 1];\n        }\n      };\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @Override public void forEach(BiConsumer<T, U> consumer) {\n      for (int x = 0; x < elements.length;) {\n        T t = (T) elements[x++];\n        U u = (U) elements[x++];\n        consumer.accept(t, u);\n      }\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @Override public void forEachIndexed(IndexedBiConsumer<T, U> consumer) {\n      for (int x = 0, i = 0; x < elements.length;) {\n        T t = (T) elements[x++];\n        U u = (U) elements[x++];\n        consumer.accept(i++, t, u);\n      }\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @Override public <R> List<R> transform(BiFunction<T, U, R> function) {\n      return Functions.generate(elements.length / 2, index -> {\n        final int x = index * 2;\n        final T t = (T) elements[x];\n        final U u = (U) elements[x + 1];\n        return function.apply(t, u);\n      });\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @Override public <R> ImmutableList<R> transform2(\n        BiFunction<T, U, R> function) {\n      final ImmutableList.Builder<R> builder = ImmutableList.builder();\n      for (int i = 0; i < elements.length;) {\n        final T t = (T) elements[i++];\n        final U u = (U) elements[i++];\n        builder.add(function.apply(t, u));\n      }\n      return builder.build();\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @Override public boolean anyMatch(BiPredicate<T, U> predicate) {\n      for (int i = 0; i < elements.length;) {\n        final T t = (T) elements[i++];\n        final U u = (U) elements[i++];\n        if (predicate.test(t, u)) {\n          return true;\n        }\n      }\n      return false;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @Override public boolean allMatch(BiPredicate<T, U> predicate) {\n      for (int i = 0; i < elements.length;) {\n        final T t = (T) elements[i++];\n        final U u = (U) elements[i++];\n        if (!predicate.test(t, u)) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @Override public boolean noMatch(BiPredicate<T, U> predicate) {\n      for (int i = 0; i < elements.length;) {\n        final T t = (T) elements[i++];\n        final U u = (U) elements[i++];\n        if (predicate.test(t, u)) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @Override public int firstMatch(BiPredicate<T, U> predicate) {\n      for (int i = 0, j = 0; i < elements.length; ++j) {\n        final T t = (T) elements[i++];\n        final U u = (U) elements[i++];\n        if (predicate.test(t, u)) {\n          return j;\n        }\n      }\n      return -1;\n    }\n  }", "definition": "  static class ArrayImmutablePairList<T, U>\n      extends AbstractPairList<T, U>\n      implements ImmutablePairList<T, U>", "class_docstring": " Immutable list of pairs backed by an array.\n\n@param <T> First type\n@param <U> Second type\n", "name": "ArrayImmutablePairList", "super_interfaces": ["ImmutablePairList<T, U>"], "superclasses": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "fields": [{"attribute_expression": "private final Object[] elements;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Object[]", "name": "elements", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    ArrayImmutablePairList(Object[] elements) {\n      this.elements = checkElementsNotNull(elements);\n    }", "docstring": " Creates an ArrayImmutablePairList.\n\n<p>Does not copy the {@code elements} array. Assumes that the caller has\nmade a copy, and will never modify the contents.\n\n<p>Assumes that {@code elements} is not null, but checks that none of\nits elements are null.", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "ArrayImmutablePairList", "params": [{"name": "elements", "type": "Object[]"}], "body": "                                              {\n      this.elements = checkElementsNotNull(elements);\n    }", "signature": "ArrayImmutablePairList(Object[] elements)"}, {"syntax_pass": true, "original_string": "    @Override List<Object> backingList() {\n      return Arrays.asList(elements);\n    }", "docstring": "", "attributes": {"modifiers": "@Override", "marker_annotations": ["@Override"], "non_marker_annotations": [], "comments": [], "return_type": "List<Object>", "classes": []}, "name": "backingList", "params": [], "body": "                                         {\n      return Arrays.asList(elements);\n    }", "signature": "@Override List<Object> backingList()"}, {"syntax_pass": true, "original_string": "    @SuppressWarnings(\"unchecked\")\n    @Override public Map.Entry<T, U> get(int index) {\n      int x = index * 2;\n      return new MapEntry<>((T) elements[x], (U) elements[x + 1]);\n    }", "docstring": "", "attributes": {"modifiers": "@SuppressWarnings(\"unchecked\")\n    @Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["@SuppressWarnings(\"unchecked\")", "public"], "comments": [], "return_type": "Map.Entry<T, U>", "classes": []}, "name": "get", "params": [{"name": "index", "type": "int"}], "body": "                                                    {\n      int x = index * 2;\n      return new MapEntry<>((T) elements[x], (U) elements[x + 1]);\n    }", "signature": "@SuppressWarnings(\"unchecked\")\n    @Override public Map.Entry<T, U> get(int index)"}, {"syntax_pass": true, "original_string": "    @SuppressWarnings(\"unchecked\")\n    @Override public T left(int index) {\n      int x = index * 2;\n      return (T) elements[x];\n    }", "docstring": "", "attributes": {"modifiers": "@SuppressWarnings(\"unchecked\")\n    @Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["@SuppressWarnings(\"unchecked\")", "public"], "comments": [], "return_type": "T", "classes": []}, "name": "left", "params": [{"name": "index", "type": "int"}], "body": "                                       {\n      int x = index * 2;\n      return (T) elements[x];\n    }", "signature": "@SuppressWarnings(\"unchecked\")\n    @Override public T left(int index)"}, {"syntax_pass": true, "original_string": "    @SuppressWarnings(\"unchecked\")\n    @Override public U right(int index) {\n      int x = index * 2;\n      return (U) elements[x + 1];\n    }", "docstring": "", "attributes": {"modifiers": "@SuppressWarnings(\"unchecked\")\n    @Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["@SuppressWarnings(\"unchecked\")", "public"], "comments": [], "return_type": "U", "classes": []}, "name": "right", "params": [{"name": "index", "type": "int"}], "body": "                                        {\n      int x = index * 2;\n      return (U) elements[x + 1];\n    }", "signature": "@SuppressWarnings(\"unchecked\")\n    @Override public U right(int index)"}, {"syntax_pass": true, "original_string": "    @Override public int size() {\n      return elements.length / 2;\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "size", "params": [], "body": "                                {\n      return elements.length / 2;\n    }", "signature": "@Override public int size()"}, {"syntax_pass": true, "original_string": "    @Override public List<T> leftList() {\n      return new RandomAccessList<T>() {\n        @Override public int size() {\n          return elements.length / 2;\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        @Override public T get(int index) {\n          return (T) elements[index * 2];\n        }\n      };\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "List<T>", "classes": []}, "name": "leftList", "params": [], "body": "                                        {\n      return new RandomAccessList<T>() {\n        @Override public int size() {\n          return elements.length / 2;\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        @Override public T get(int index) {\n          return (T) elements[index * 2];\n        }\n      };\n    }", "signature": "@Override public List<T> leftList()"}, {"syntax_pass": true, "original_string": "    @Override public List<U> rightList() {\n      return new RandomAccessList<U>() {\n        @Override public int size() {\n          return elements.length / 2;\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        @Override public U get(int index) {\n          return (U) elements[index * 2 + 1];\n        }\n      };\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "List<U>", "classes": []}, "name": "rightList", "params": [], "body": "                                         {\n      return new RandomAccessList<U>() {\n        @Override public int size() {\n          return elements.length / 2;\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        @Override public U get(int index) {\n          return (U) elements[index * 2 + 1];\n        }\n      };\n    }", "signature": "@Override public List<U> rightList()"}, {"syntax_pass": true, "original_string": "    @SuppressWarnings(\"unchecked\")\n    @Override public void forEach(BiConsumer<T, U> consumer) {\n      for (int x = 0; x < elements.length;) {\n        T t = (T) elements[x++];\n        U u = (U) elements[x++];\n        consumer.accept(t, u);\n      }\n    }", "docstring": "", "attributes": {"modifiers": "@SuppressWarnings(\"unchecked\")\n    @Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["@SuppressWarnings(\"unchecked\")", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "forEach", "params": [{"name": "consumer", "type": "BiConsumer<T, U>"}], "body": "                                                             {\n      for (int x = 0; x < elements.length;) {\n        T t = (T) elements[x++];\n        U u = (U) elements[x++];\n        consumer.accept(t, u);\n      }\n    }", "signature": "@SuppressWarnings(\"unchecked\")\n    @Override public void forEach(BiConsumer<T, U> consumer)"}, {"syntax_pass": true, "original_string": "    @SuppressWarnings(\"unchecked\")\n    @Override public void forEachIndexed(IndexedBiConsumer<T, U> consumer) {\n      for (int x = 0, i = 0; x < elements.length;) {\n        T t = (T) elements[x++];\n        U u = (U) elements[x++];\n        consumer.accept(i++, t, u);\n      }\n    }", "docstring": "", "attributes": {"modifiers": "@SuppressWarnings(\"unchecked\")\n    @Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["@SuppressWarnings(\"unchecked\")", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "forEachIndexed", "params": [{"name": "consumer", "type": "IndexedBiConsumer<T, U>"}], "body": "                                                                           {\n      for (int x = 0, i = 0; x < elements.length;) {\n        T t = (T) elements[x++];\n        U u = (U) elements[x++];\n        consumer.accept(i++, t, u);\n      }\n    }", "signature": "@SuppressWarnings(\"unchecked\")\n    @Override public void forEachIndexed(IndexedBiConsumer<T, U> consumer)"}, {"syntax_pass": true, "original_string": "    @SuppressWarnings(\"unchecked\")\n    @Override public <R> List<R> transform(BiFunction<T, U, R> function) {\n      return Functions.generate(elements.length / 2, index -> {\n        final int x = index * 2;\n        final T t = (T) elements[x];\n        final U u = (U) elements[x + 1];\n        return function.apply(t, u);\n      });\n    }", "docstring": "", "attributes": {"modifiers": "@SuppressWarnings(\"unchecked\")\n    @Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["@SuppressWarnings(\"unchecked\")", "public"], "comments": [], "return_type": "List<R>", "classes": []}, "name": "transform", "params": [{"name": "function", "type": "BiFunction<T, U, R>"}], "body": "                                                                         {\n      return Functions.generate(elements.length / 2, index -> {\n        final int x = index * 2;\n        final T t = (T) elements[x];\n        final U u = (U) elements[x + 1];\n        return function.apply(t, u);\n      });\n    }", "signature": "@SuppressWarnings(\"unchecked\")\n    @Override public <R> List<R> transform(BiFunction<T, U, R> function)"}, {"syntax_pass": true, "original_string": "    @SuppressWarnings(\"unchecked\")\n    @Override public <R> ImmutableList<R> transform2(\n        BiFunction<T, U, R> function) {\n      final ImmutableList.Builder<R> builder = ImmutableList.builder();\n      for (int i = 0; i < elements.length;) {\n        final T t = (T) elements[i++];\n        final U u = (U) elements[i++];\n        builder.add(function.apply(t, u));\n      }\n      return builder.build();\n    }", "docstring": "", "attributes": {"modifiers": "@SuppressWarnings(\"unchecked\")\n    @Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["@SuppressWarnings(\"unchecked\")", "public"], "comments": [], "return_type": "ImmutableList<R>", "classes": []}, "name": "transform2", "params": [{"name": "function", "type": "BiFunction<T, U, R>"}], "body": "                                      {\n      final ImmutableList.Builder<R> builder = ImmutableList.builder();\n      for (int i = 0; i < elements.length;) {\n        final T t = (T) elements[i++];\n        final U u = (U) elements[i++];\n        builder.add(function.apply(t, u));\n      }\n      return builder.build();\n    }", "signature": "@SuppressWarnings(\"unchecked\")\n    @Override public <R> ImmutableList<R> transform2(\n        BiFunction<T, U, R> function)"}, {"syntax_pass": true, "original_string": "    @SuppressWarnings(\"unchecked\")\n    @Override public boolean anyMatch(BiPredicate<T, U> predicate) {\n      for (int i = 0; i < elements.length;) {\n        final T t = (T) elements[i++];\n        final U u = (U) elements[i++];\n        if (predicate.test(t, u)) {\n          return true;\n        }\n      }\n      return false;\n    }", "docstring": "", "attributes": {"modifiers": "@SuppressWarnings(\"unchecked\")\n    @Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["@SuppressWarnings(\"unchecked\")", "public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "anyMatch", "params": [{"name": "predicate", "type": "BiPredicate<T, U>"}], "body": "                                                                   {\n      for (int i = 0; i < elements.length;) {\n        final T t = (T) elements[i++];\n        final U u = (U) elements[i++];\n        if (predicate.test(t, u)) {\n          return true;\n        }\n      }\n      return false;\n    }", "signature": "@SuppressWarnings(\"unchecked\")\n    @Override public boolean anyMatch(BiPredicate<T, U> predicate)"}, {"syntax_pass": true, "original_string": "    @SuppressWarnings(\"unchecked\")\n    @Override public boolean allMatch(BiPredicate<T, U> predicate) {\n      for (int i = 0; i < elements.length;) {\n        final T t = (T) elements[i++];\n        final U u = (U) elements[i++];\n        if (!predicate.test(t, u)) {\n          return false;\n        }\n      }\n      return true;\n    }", "docstring": "", "attributes": {"modifiers": "@SuppressWarnings(\"unchecked\")\n    @Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["@SuppressWarnings(\"unchecked\")", "public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "allMatch", "params": [{"name": "predicate", "type": "BiPredicate<T, U>"}], "body": "                                                                   {\n      for (int i = 0; i < elements.length;) {\n        final T t = (T) elements[i++];\n        final U u = (U) elements[i++];\n        if (!predicate.test(t, u)) {\n          return false;\n        }\n      }\n      return true;\n    }", "signature": "@SuppressWarnings(\"unchecked\")\n    @Override public boolean allMatch(BiPredicate<T, U> predicate)"}, {"syntax_pass": true, "original_string": "    @SuppressWarnings(\"unchecked\")\n    @Override public boolean noMatch(BiPredicate<T, U> predicate) {\n      for (int i = 0; i < elements.length;) {\n        final T t = (T) elements[i++];\n        final U u = (U) elements[i++];\n        if (predicate.test(t, u)) {\n          return false;\n        }\n      }\n      return true;\n    }", "docstring": "", "attributes": {"modifiers": "@SuppressWarnings(\"unchecked\")\n    @Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["@SuppressWarnings(\"unchecked\")", "public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "noMatch", "params": [{"name": "predicate", "type": "BiPredicate<T, U>"}], "body": "                                                                  {\n      for (int i = 0; i < elements.length;) {\n        final T t = (T) elements[i++];\n        final U u = (U) elements[i++];\n        if (predicate.test(t, u)) {\n          return false;\n        }\n      }\n      return true;\n    }", "signature": "@SuppressWarnings(\"unchecked\")\n    @Override public boolean noMatch(BiPredicate<T, U> predicate)"}, {"syntax_pass": true, "original_string": "    @SuppressWarnings(\"unchecked\")\n    @Override public int firstMatch(BiPredicate<T, U> predicate) {\n      for (int i = 0, j = 0; i < elements.length; ++j) {\n        final T t = (T) elements[i++];\n        final U u = (U) elements[i++];\n        if (predicate.test(t, u)) {\n          return j;\n        }\n      }\n      return -1;\n    }", "docstring": "", "attributes": {"modifiers": "@SuppressWarnings(\"unchecked\")\n    @Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["@SuppressWarnings(\"unchecked\")", "public"], "comments": [], "return_type": "int", "classes": []}, "name": "firstMatch", "params": [{"name": "predicate", "type": "BiPredicate<T, U>"}], "body": "                                                                 {\n      for (int i = 0, j = 0; i < elements.length; ++j) {\n        final T t = (T) elements[i++];\n        final U u = (U) elements[i++];\n        if (predicate.test(t, u)) {\n          return j;\n        }\n      }\n      return -1;\n    }", "signature": "@SuppressWarnings(\"unchecked\")\n    @Override public int firstMatch(BiPredicate<T, U> predicate)"}]}], "class_docstring": " Various implementations of {@link PairList}.", "original_string": "class PairLists {\n  static final ImmutablePairList<Object, Object> EMPTY =\n      new EmptyImmutablePairList<>();\n\n  private PairLists() {\n  }\n\n  @SuppressWarnings(\"unchecked\")\n  static <T, U> ImmutablePairList<T, U> immutableBackedBy(List<Object> list) {\n    switch (list.size()) {\n    case 0:\n      return ImmutablePairList.of();\n    case 2:\n      return new SingletonImmutablePairList<>((T) list.get(0), (U) list.get(1));\n    default:\n      return new ArrayImmutablePairList<>(list.toArray());\n    }\n  }\n\n  @CanIgnoreReturnValue\n  static Object[] checkElementsNotNull(Object... elements) {\n    for (int i = 0; i < elements.length; i++) {\n      checkElementNotNull(i, elements[i]);\n    }\n    return elements;\n  }\n\n  static void checkElementNotNull(int i, Object element) {\n    if (element == null) {\n      throw new NullPointerException((i % 2 == 0 ? \"key\" : \"value\")\n          + \" at index \" + (i / 2));\n    }\n  }\n\n  /** Base class for all implementations of PairList.\n   *\n   * @param <T> First type\n   * @param <U> Second type\n   */\n  abstract static class AbstractPairList<T, U>\n      extends AbstractList<Map.Entry<T, U>>\n      implements PairList<T, U> {\n    /** Returns a list containing the alternating left and right elements\n     * of each pair. */\n    abstract List<Object> backingList();\n  }\n\n  /** Mutable version of {@link PairList}.\n   *\n   * @param <T> First type\n   * @param <U> Second type\n   */\n  static class MutablePairList<T, U> extends AbstractPairList<T, U> {\n    final List<@Nullable Object> list;\n\n    MutablePairList(List<@Nullable Object> list) {\n      this.list = list;\n    }\n\n    @Override List<Object> backingList() {\n      return list;\n    }\n\n    @Override public void clear() {\n      list.clear();\n    }\n\n    @Override public int size() {\n      return list.size() / 2;\n    }\n\n    @Override public boolean isEmpty() {\n      return list.isEmpty();\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @Override public Map.Entry<T, U> get(int index) {\n      int x = index * 2;\n      return new MapEntry<>((T) list.get(x), (U) list.get(x + 1));\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @Override public T left(int index) {\n      int x = index * 2;\n      return (T) list.get(x);\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @Override public U right(int index) {\n      int x = index * 2;\n      return (U) list.get(x + 1);\n    }\n\n    @Override public Map.Entry<T, U> set(int index, Map.Entry<T, U> entry) {\n      return set(index, entry.getKey(), entry.getValue());\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @Override public Map.Entry<T, U> set(int index, T t, U u) {\n      int x = index * 2;\n      T t0 = (T) list.set(x, t);\n      U u0 = (U) list.set(x + 1, u);\n      return new MapEntry<>(t0, u0);\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @Override public Map.Entry<T, U> remove(int index) {\n      final int x = index * 2;\n      T t = (T) list.remove(x);\n      U u = (U) list.remove(x);\n      return new MapEntry<>(t, u);\n    }\n\n    @SuppressWarnings(\"RedundantCast\")\n    @Override public boolean add(Map.Entry<T, U> entry) {\n      list.add((Object) entry.getKey());\n      list.add((Object) entry.getValue());\n      return true;\n    }\n\n    @SuppressWarnings(\"RedundantCast\")\n    @Override public void add(int index, Map.Entry<T, U> entry) {\n      int x = index * 2;\n      list.add(x, (Object) entry.getKey());\n      list.add(x + 1, (Object) entry.getValue());\n    }\n\n    @SuppressWarnings(\"RedundantCast\")\n    @Override public void add(T t, U u) {\n      list.add((Object) t);\n      list.add((Object) u);\n    }\n\n    @SuppressWarnings(\"RedundantCast\")\n    @Override public void add(int index, T t, U u) {\n      int x = index * 2;\n      list.add(x, (Object) t);\n      list.add(x + 1, (Object) u);\n    }\n\n    @Override public boolean addAll(PairList<T, U> list2) {\n      return list.addAll(((AbstractPairList<T, U>) list2).backingList());\n    }\n\n    @Override public boolean addAll(int index, PairList<T, U> list2) {\n      int x = index * 2;\n      return list.addAll(x, ((AbstractPairList<T, U>) list2).backingList());\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @Override public List<T> leftList() {\n      final int size = list.size() / 2;\n      return new RandomAccessList<T>() {\n        @Override public int size() {\n          return size;\n        }\n\n        @Override public T get(int index) {\n          return (T) list.get(index * 2);\n        }\n      };\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @Override public List<U> rightList() {\n      final int size = list.size() / 2;\n      return new RandomAccessList<U>() {\n        @Override public int size() {\n          return size;\n        }\n\n        @Override public U get(int index) {\n          return (U) list.get(index * 2 + 1);\n        }\n      };\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @Override public void forEach(BiConsumer<T, U> consumer) {\n      requireNonNull(consumer, \"consumer\");\n      for (int i = 0; i < list.size();) {\n        T t = (T) list.get(i++);\n        U u = (U) list.get(i++);\n        consumer.accept(t, u);\n      }\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @Override public void forEachIndexed(IndexedBiConsumer<T, U> consumer) {\n      requireNonNull(consumer, \"consumer\");\n      for (int i = 0, j = 0; i < list.size();) {\n        T t = (T) list.get(i++);\n        U u = (U) list.get(i++);\n        consumer.accept(j++, t, u);\n      }\n    }\n\n    @Override public ImmutableMap<T, U> toImmutableMap() {\n      final ImmutableMap.Builder<T, U> b = ImmutableMap.builder();\n      forEach((t, u) -> b.put(t, u));\n      return b.build();\n    }\n\n    @Override public ImmutablePairList<T, U> immutable() {\n      return immutableBackedBy(list);\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @Override public <R> List<R> transform(BiFunction<T, U, R> function) {\n      return Functions.generate(list.size() / 2, index -> {\n        final int x = index * 2;\n        final T t = (T) list.get(x);\n        final U u = (U) list.get(x + 1);\n        return function.apply(t, u);\n      });\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @Override public <R> ImmutableList<R> transform2(\n        BiFunction<T, U, R> function) {\n      if (list.isEmpty()) {\n        return ImmutableList.of();\n      }\n      final ImmutableList.Builder<R> builder = ImmutableList.builder();\n      for (int i = 0, n = list.size(); i < n;) {\n        final T t = (T) list.get(i++);\n        final U u = (U) list.get(i++);\n        builder.add(function.apply(t, u));\n      }\n      return builder.build();\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @Override public boolean anyMatch(BiPredicate<T, U> predicate) {\n      for (int i = 0; i < list.size();) {\n        final T t = (T) list.get(i++);\n        final U u = (U) list.get(i++);\n        if (predicate.test(t, u)) {\n          return true;\n        }\n      }\n      return false;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @Override public boolean allMatch(BiPredicate<T, U> predicate) {\n      for (int i = 0; i < list.size();) {\n        final T t = (T) list.get(i++);\n        final U u = (U) list.get(i++);\n        if (!predicate.test(t, u)) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @Override public boolean noMatch(BiPredicate<T, U> predicate) {\n      for (int i = 0; i < list.size();) {\n        final T t = (T) list.get(i++);\n        final U u = (U) list.get(i++);\n        if (predicate.test(t, u)) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @Override public int firstMatch(BiPredicate<T, U> predicate) {\n      for (int i = 0, j = 0; i < list.size(); ++j) {\n        final T t = (T) list.get(i++);\n        final U u = (U) list.get(i++);\n        if (predicate.test(t, u)) {\n          return j;\n        }\n      }\n      return -1;\n    }\n  }\n\n  /** Empty immutable list of pairs.\n   *\n   * @param <T> First type\n   * @param <U> Second type\n   */\n  static class EmptyImmutablePairList<T, U>\n      extends AbstractPairList<T, U>\n      implements ImmutablePairList<T, U> {\n    @Override List<Object> backingList() {\n      return ImmutableList.of();\n    }\n\n    @Override public Map.Entry<T, U> get(int index) {\n      throw new IndexOutOfBoundsException(\"Index out of range: \" + index);\n    }\n\n    @Override public T left(int index) {\n      throw new IndexOutOfBoundsException(\"Index out of range: \" + index);\n    }\n\n    @Override public U right(int index) {\n      throw new IndexOutOfBoundsException(\"Index out of range: \" + index);\n    }\n\n    @Override public int size() {\n      return 0;\n    }\n\n    @Override public List<T> leftList() {\n      return ImmutableList.of();\n    }\n\n    @Override public List<U> rightList() {\n      return ImmutableList.of();\n    }\n\n    @Override public void forEach(BiConsumer<T, U> consumer) {\n    }\n\n    @Override public void forEachIndexed(IndexedBiConsumer<T, U> consumer) {\n    }\n\n    @Override public <R> List<R> transform(BiFunction<T, U, R> function) {\n      return ImmutableList.of();\n    }\n\n    @Override public <R> ImmutableList<R> transform2(\n        BiFunction<T, U, R> function) {\n      return ImmutableList.of();\n    }\n\n    @Override public boolean anyMatch(BiPredicate<T, U> predicate) {\n      return false;\n    }\n\n    @Override public boolean allMatch(BiPredicate<T, U> predicate) {\n      return true;\n    }\n\n    @Override public boolean noMatch(BiPredicate<T, U> predicate) {\n      return true;\n    }\n\n    @Override public int firstMatch(BiPredicate<T, U> predicate) {\n      return -1;\n    }\n  }\n\n  /** Immutable list that contains one pair.\n   *\n   * @param <T> First type\n   * @param <U> Second type\n   */\n  static class SingletonImmutablePairList<T, U>\n      extends AbstractPairList<T, U>\n      implements ImmutablePairList<T, U> {\n    private final T t;\n    private final U u;\n\n    SingletonImmutablePairList(T t, U u) {\n      this.t = t;\n      this.u = u;\n      checkElementNotNull(0, t);\n      checkElementNotNull(1, u);\n    }\n\n    @Override List<Object> backingList() {\n      return ImmutableList.of(t, u);\n    }\n\n    @Override public Map.Entry<T, U> get(int index) {\n      if (index != 0) {\n        throw new IndexOutOfBoundsException(\"Index out of range: \" + index);\n      }\n      return new MapEntry<>(t, u);\n    }\n\n    @Override public T left(int index) {\n      if (index != 0) {\n        throw new IndexOutOfBoundsException(\"Index out of range: \" + index);\n      }\n      return t;\n    }\n\n    @Override public U right(int index) {\n      if (index != 0) {\n        throw new IndexOutOfBoundsException(\"Index out of range: \" + index);\n      }\n      return u;\n    }\n\n    @Override public int size() {\n      return 1;\n    }\n\n    @Override public List<T> leftList() {\n      return ImmutableList.of(t);\n    }\n\n    @Override public List<U> rightList() {\n      return ImmutableList.of(u);\n    }\n\n    @Override public void forEach(BiConsumer<T, U> consumer) {\n      consumer.accept(t, u);\n    }\n\n    @Override public void forEachIndexed(IndexedBiConsumer<T, U> consumer) {\n      consumer.accept(0, t, u);\n    }\n\n    @Override public <R> List<R> transform(BiFunction<T, U, R> function) {\n      return ImmutableList.of(function.apply(t, u));\n    }\n\n    @Override public <R> ImmutableList<R> transform2(\n        BiFunction<T, U, R> function) {\n      return ImmutableList.of(function.apply(t, u));\n    }\n\n    @Override public boolean anyMatch(BiPredicate<T, U> predicate) {\n      return predicate.test(t, u);\n    }\n\n    @Override public boolean allMatch(BiPredicate<T, U> predicate) {\n      return predicate.test(t, u);\n    }\n\n    @Override public boolean noMatch(BiPredicate<T, U> predicate) {\n      return !predicate.test(t, u);\n    }\n\n    @Override public int firstMatch(BiPredicate<T, U> predicate) {\n      return predicate.test(t, u) ? 0 : -1;\n    }\n  }\n\n  /** Base class for a list that implements {@link RandomAccess}.\n   *\n   * @param <E> Element type */\n  abstract static class RandomAccessList<E>\n      extends AbstractList<E> implements RandomAccess {\n  }\n\n  /** Immutable list of pairs backed by an array.\n   *\n   * @param <T> First type\n   * @param <U> Second type\n   */\n  static class ArrayImmutablePairList<T, U>\n      extends AbstractPairList<T, U>\n      implements ImmutablePairList<T, U> {\n    private final Object[] elements;\n\n    /** Creates an ArrayImmutablePairList.\n     *\n     * <p>Does not copy the {@code elements} array. Assumes that the caller has\n     * made a copy, and will never modify the contents.\n     *\n     * <p>Assumes that {@code elements} is not null, but checks that none of\n     * its elements are null. */\n    ArrayImmutablePairList(Object[] elements) {\n      this.elements = checkElementsNotNull(elements);\n    }\n\n    @Override List<Object> backingList() {\n      return Arrays.asList(elements);\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @Override public Map.Entry<T, U> get(int index) {\n      int x = index * 2;\n      return new MapEntry<>((T) elements[x], (U) elements[x + 1]);\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @Override public T left(int index) {\n      int x = index * 2;\n      return (T) elements[x];\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @Override public U right(int index) {\n      int x = index * 2;\n      return (U) elements[x + 1];\n    }\n\n    @Override public int size() {\n      return elements.length / 2;\n    }\n\n    @Override public List<T> leftList() {\n      return new RandomAccessList<T>() {\n        @Override public int size() {\n          return elements.length / 2;\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        @Override public T get(int index) {\n          return (T) elements[index * 2];\n        }\n      };\n    }\n\n    @Override public List<U> rightList() {\n      return new RandomAccessList<U>() {\n        @Override public int size() {\n          return elements.length / 2;\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        @Override public U get(int index) {\n          return (U) elements[index * 2 + 1];\n        }\n      };\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @Override public void forEach(BiConsumer<T, U> consumer) {\n      for (int x = 0; x < elements.length;) {\n        T t = (T) elements[x++];\n        U u = (U) elements[x++];\n        consumer.accept(t, u);\n      }\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @Override public void forEachIndexed(IndexedBiConsumer<T, U> consumer) {\n      for (int x = 0, i = 0; x < elements.length;) {\n        T t = (T) elements[x++];\n        U u = (U) elements[x++];\n        consumer.accept(i++, t, u);\n      }\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @Override public <R> List<R> transform(BiFunction<T, U, R> function) {\n      return Functions.generate(elements.length / 2, index -> {\n        final int x = index * 2;\n        final T t = (T) elements[x];\n        final U u = (U) elements[x + 1];\n        return function.apply(t, u);\n      });\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @Override public <R> ImmutableList<R> transform2(\n        BiFunction<T, U, R> function) {\n      final ImmutableList.Builder<R> builder = ImmutableList.builder();\n      for (int i = 0; i < elements.length;) {\n        final T t = (T) elements[i++];\n        final U u = (U) elements[i++];\n        builder.add(function.apply(t, u));\n      }\n      return builder.build();\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @Override public boolean anyMatch(BiPredicate<T, U> predicate) {\n      for (int i = 0; i < elements.length;) {\n        final T t = (T) elements[i++];\n        final U u = (U) elements[i++];\n        if (predicate.test(t, u)) {\n          return true;\n        }\n      }\n      return false;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @Override public boolean allMatch(BiPredicate<T, U> predicate) {\n      for (int i = 0; i < elements.length;) {\n        final T t = (T) elements[i++];\n        final U u = (U) elements[i++];\n        if (!predicate.test(t, u)) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @Override public boolean noMatch(BiPredicate<T, U> predicate) {\n      for (int i = 0; i < elements.length;) {\n        final T t = (T) elements[i++];\n        final U u = (U) elements[i++];\n        if (predicate.test(t, u)) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @Override public int firstMatch(BiPredicate<T, U> predicate) {\n      for (int i = 0, j = 0; i < elements.length; ++j) {\n        final T t = (T) elements[i++];\n        final U u = (U) elements[i++];\n        if (predicate.test(t, u)) {\n          return j;\n        }\n      }\n      return -1;\n    }\n  }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "static final ImmutablePairList<Object, Object> EMPTY =\n      new EmptyImmutablePairList<>();", "docstring": "", "modifiers": "static final", "marker_annotations": [], "non_marker_annotations": ["static", "final"], "comments": [], "type": "ImmutablePairList<Object, Object>", "name": "EMPTY =\n      new EmptyImmutablePairList<>()", "syntax_pass": true}]}, {"uris": "src/main/java/net/hydromatic/morel/util/ComparableSingletonList.java.ComparableSingletonList", "name": "ComparableSingletonList", "file_path": "src/main/java/net/hydromatic/morel/util/ComparableSingletonList.java", "superclasses": "", "methods": ["[]ComparableSingletonList(E)", "[ComparableSingletonList<E>]of(E)", "[E]get(int)", "[int]size()", "[int]compareTo(ComparableSingletonList<E>)"], "method_uris": ["src/main/java/net/hydromatic/morel/util/ComparableSingletonList.java.ComparableSingletonList.[]ComparableSingletonList(E)", "src/main/java/net/hydromatic/morel/util/ComparableSingletonList.java.ComparableSingletonList.[ComparableSingletonList<E>]of(E)", "src/main/java/net/hydromatic/morel/util/ComparableSingletonList.java.ComparableSingletonList.[E]get(int)", "src/main/java/net/hydromatic/morel/util/ComparableSingletonList.java.ComparableSingletonList.[int]size()", "src/main/java/net/hydromatic/morel/util/ComparableSingletonList.java.ComparableSingletonList.[int]compareTo(ComparableSingletonList<E>)"], "overrides": null, "attributes": [], "class_docstring": " A comparable singleton list.\n\n@param <E> Element type", "original_string": "public class ComparableSingletonList<E extends Comparable<E>>\n    extends AbstractList<E>\n    implements Comparable<ComparableSingletonList<E>> {\n  private final E element;\n\n  ComparableSingletonList(E element) {\n    this.element = requireNonNull(element);\n  }\n\n  /** Creates a ComparableSingletonList. */\n  public static <E extends Comparable<E>> ComparableSingletonList<E> of(E e) {\n    return new ComparableSingletonList<>(e);\n  }\n\n  @Override public E get(int index) {\n    assert index == 0;\n    return element;\n  }\n\n  @Override public int size() {\n    return 1;\n  }\n\n  @Override public int compareTo(ComparableSingletonList<E> o) {\n    return element.compareTo(o.element);\n  }\n}", "super_interfaces": ["Comparable<ComparableSingletonList<E>>"], "fields": [{"attribute_expression": "private final E element;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "E", "name": "element", "syntax_pass": true}]}, {"uris": "src/main/java/net/hydromatic/morel/util/ThreadLocals.java.ThreadLocals", "name": "ThreadLocals", "file_path": "src/main/java/net/hydromatic/morel/util/ThreadLocals.java", "superclasses": "", "methods": ["[]ThreadLocals()", "[void]let(ThreadLocal<T>,T,Runnable)", "[R]let(ThreadLocal<T>,T,Supplier<R>)", "[void]mutate(ThreadLocal<T>,UnaryOperator<T>,Runnable)", "[R]mutate(ThreadLocal<T>,UnaryOperator<T>,Supplier<R>)"], "method_uris": ["src/main/java/net/hydromatic/morel/util/ThreadLocals.java.ThreadLocals.[]ThreadLocals()", "src/main/java/net/hydromatic/morel/util/ThreadLocals.java.ThreadLocals.[void]let(ThreadLocal<T>,T,Runnable)", "src/main/java/net/hydromatic/morel/util/ThreadLocals.java.ThreadLocals.[R]let(ThreadLocal<T>,T,Supplier<R>)", "src/main/java/net/hydromatic/morel/util/ThreadLocals.java.ThreadLocals.[void]mutate(ThreadLocal<T>,UnaryOperator<T>,Runnable)", "src/main/java/net/hydromatic/morel/util/ThreadLocals.java.ThreadLocals.[R]mutate(ThreadLocal<T>,UnaryOperator<T>,Supplier<R>)"], "overrides": null, "attributes": [], "class_docstring": "\nUtilities for {@link ThreadLocal}.\n", "original_string": "public class ThreadLocals {\n  private ThreadLocals() {\n  }\n\n  /** Performs an action with a thread-local set to a particular value. */\n  public static <T> void let(ThreadLocal<T> threadLocal, T value,\n      Runnable runnable) {\n    final T originalValue = threadLocal.get();\n    threadLocal.set(value);\n    try {\n      runnable.run();\n    } finally {\n      // Restore the original value. I wish there were a way to know that the\n      // original value was present because threadLocal was initially not set.\n      threadLocal.set(originalValue);\n    }\n  }\n\n  /** Performs an action with a thread-local set to a particular value,\n   * and returns the result. */\n  public static <T, R> R let(ThreadLocal<T> threadLocal, T value,\n      Supplier<R> supplier) {\n    final T originalValue = threadLocal.get();\n    threadLocal.set(value);\n    try {\n      return supplier.get();\n    } finally {\n      // Restore the original value. I wish there were a way to know that the\n      // original value was present because threadLocal was initially not set.\n      threadLocal.set(originalValue);\n    }\n  }\n\n  /** Performs an action with a thread-local set to a value derived from its\n   * current value via a transformer. */\n  public static <T> void mutate(ThreadLocal<T> threadLocal,\n      UnaryOperator<T> transform, Runnable runnable) {\n    let(threadLocal, transform.apply(threadLocal.get()), runnable);\n  }\n\n  /** Performs an action with a thread-local set to a value derived from its\n   * current value via a transformer,\n   * and returns the result. */\n  public static <T, R> R mutate(ThreadLocal<T> threadLocal,\n      UnaryOperator<T> transform, Supplier<R> supplier) {\n    return let(threadLocal, transform.apply(threadLocal.get()), supplier);\n  }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/main/java/net/hydromatic/morel/type/TypeVar.java.TypeVar", "name": "TypeVar", "file_path": "src/main/java/net/hydromatic/morel/type/TypeVar.java", "superclasses": "", "methods": ["[]TypeVar(int)", "[int]hashCode()", "[boolean]equals(Object)", "[String]toString()", "[R]accept(TypeVisitor<R>)", "[String]name(int)", "[Key]key()", "[Op]op()", "[Type]copy(TypeSystem,UnaryOperator<Type>)", "[Type]substitute(TypeSystem,List<? extends Type>)"], "method_uris": ["src/main/java/net/hydromatic/morel/type/TypeVar.java.TypeVar.[]TypeVar(int)", "src/main/java/net/hydromatic/morel/type/TypeVar.java.TypeVar.[int]hashCode()", "src/main/java/net/hydromatic/morel/type/TypeVar.java.TypeVar.[boolean]equals(Object)", "src/main/java/net/hydromatic/morel/type/TypeVar.java.TypeVar.[String]toString()", "src/main/java/net/hydromatic/morel/type/TypeVar.java.TypeVar.[R]accept(TypeVisitor<R>)", "src/main/java/net/hydromatic/morel/type/TypeVar.java.TypeVar.[String]name(int)", "src/main/java/net/hydromatic/morel/type/TypeVar.java.TypeVar.[Key]key()", "src/main/java/net/hydromatic/morel/type/TypeVar.java.TypeVar.[Op]op()", "src/main/java/net/hydromatic/morel/type/TypeVar.java.TypeVar.[Type]copy(TypeSystem,UnaryOperator<Type>)", "src/main/java/net/hydromatic/morel/type/TypeVar.java.TypeVar.[Type]substitute(TypeSystem,List<? extends Type>)"], "overrides": null, "attributes": [], "class_docstring": " Type variable (e.g. {@code 'a}).", "original_string": "public class TypeVar implements Type {\n  private static final char[] ALPHAS =\n      \"abcdefghijklmnopqrstuvwxyz\".toCharArray();\n\n  private static final LoadingCache<Integer, String> NAME_CACHE =\n      CacheBuilder.newBuilder().build(CacheLoader.from(TypeVar::name));\n\n  public final int ordinal;\n  private final String name;\n\n  /** Creates a type variable with a given ordinal.\n   *\n   * <p>TypeVar.of(0) returns \"'a\"; TypeVar.of(1) returns \"'b\", etc. */\n  public TypeVar(int ordinal) {\n    checkArgument(ordinal >= 0);\n    this.ordinal = ordinal;\n    try {\n      this.name = requireNonNull(NAME_CACHE.get(ordinal));\n    } catch (ExecutionException e) {\n      throw new RuntimeException(e.getCause());\n    }\n  }\n\n  @Override public int hashCode() {\n    return ordinal + 6563;\n  }\n\n  @Override public boolean equals(Object obj) {\n    return obj == this\n        || obj instanceof TypeVar\n        && this.ordinal == ((TypeVar) obj).ordinal;\n  }\n\n  /** Returns a string for debugging. */\n  @Override public String toString() {\n    return name;\n  }\n\n  public <R> R accept(TypeVisitor<R> typeVisitor) {\n    return typeVisitor.visit(this);\n  }\n\n  /** Generates a name for a type variable.\n   *\n   * <p>0 &rarr; 'a, 1 &rarr; 'b, 26 &rarr; 'z, 27 &rarr; 'ba, 28 &rarr; 'bb,\n   * 675 &rarr; 'zz, 676 &rarr; 'baa, etc. (Think of it is a base 26 number,\n   * with \"a\" as 0, \"z\" as 25.) */\n  static String name(int i) {\n    if (i < 0) {\n      throw new IllegalArgumentException();\n    }\n    final StringBuilder s = new StringBuilder();\n    for (;;) {\n      final int mod = i % 26;\n      s.append(ALPHAS[mod]);\n      i /= 26;\n      if (i == 0) {\n        return s.append(\"'\").reverse().toString();\n      }\n    }\n  }\n\n  @Override public Key key() {\n    return Keys.ordinal(ordinal);\n  }\n\n  @Override public Op op() {\n    return Op.TY_VAR;\n  }\n\n  @Override public Type copy(TypeSystem typeSystem,\n      UnaryOperator<Type> transform) {\n    return transform.apply(this);\n  }\n\n  @Override public Type substitute(TypeSystem typeSystem,\n      List<? extends Type> types) {\n    return types.get(ordinal);\n  }\n}", "super_interfaces": ["Type"], "fields": [{"attribute_expression": "private static final char[] ALPHAS =\n      \"abcdefghijklmnopqrstuvwxyz\".toCharArray();", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "char[]", "name": "ALPHAS =\n      \"abcdefghijklmnopqrstuvwxyz\".toCharArray()", "syntax_pass": true}, {"attribute_expression": "private static final LoadingCache<Integer, String> NAME_CACHE =\n      CacheBuilder.newBuilder().build(CacheLoader.from(TypeVar::name));", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "LoadingCache<Integer, String>", "name": "NAME_CACHE =\n      CacheBuilder.newBuilder().build(CacheLoader.from(TypeVar::name))", "syntax_pass": true}, {"attribute_expression": "public final int ordinal;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "int", "name": "ordinal", "syntax_pass": true}, {"attribute_expression": "private final String name;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "name", "syntax_pass": true}]}, {"uris": "src/main/java/net/hydromatic/morel/type/Binding.java.Binding", "name": "Binding", "file_path": "src/main/java/net/hydromatic/morel/type/Binding.java", "superclasses": "", "methods": ["[]Binding(Core.NamedPat,Core.Exp,Object,boolean)", "[Binding]of(Core.NamedPat)", "[Binding]of(Core.NamedPat,Core.Exp)", "[Binding]of(Core.NamedPat,Object)", "[int]hashCode()", "[boolean]equals(Object)", "[Binding]withParameter(boolean)", "[String]toString()"], "method_uris": ["src/main/java/net/hydromatic/morel/type/Binding.java.Binding.[]Binding(Core.NamedPat,Core.Exp,Object,boolean)", "src/main/java/net/hydromatic/morel/type/Binding.java.Binding.[Binding]of(Core.NamedPat)", "src/main/java/net/hydromatic/morel/type/Binding.java.Binding.[Binding]of(Core.NamedPat,Core.Exp)", "src/main/java/net/hydromatic/morel/type/Binding.java.Binding.[Binding]of(Core.NamedPat,Object)", "src/main/java/net/hydromatic/morel/type/Binding.java.Binding.[int]hashCode()", "src/main/java/net/hydromatic/morel/type/Binding.java.Binding.[boolean]equals(Object)", "src/main/java/net/hydromatic/morel/type/Binding.java.Binding.[Binding]withParameter(boolean)", "src/main/java/net/hydromatic/morel/type/Binding.java.Binding.[String]toString()"], "overrides": null, "attributes": [], "class_docstring": " Binding of a name to a type and a value.\n\n<p>Used in {@link net.hydromatic.morel.compile.Environment}.", "original_string": "public class Binding {\n  public final Core.NamedPat id;\n  public final Core.Exp exp;\n  public final Object value;\n  /** If true, the binding is ignored by inlining. */\n  public final boolean parameter;\n\n  private Binding(Core.NamedPat id, Core.Exp exp, Object value,\n      boolean parameter) {\n    this.id = requireNonNull(id);\n    this.exp = exp;\n    this.value = requireNonNull(value);\n    assert !(value instanceof Core.IdPat);\n    this.parameter = parameter;\n  }\n\n  public static Binding of(Core.NamedPat id) {\n    return new Binding(id, null, Unit.INSTANCE, false);\n  }\n\n  public static Binding of(Core.NamedPat id, Core.Exp exp) {\n    return new Binding(id, exp, Unit.INSTANCE, false);\n  }\n\n  public static Binding of(Core.NamedPat id, Object value) {\n    return new Binding(id, null, value, false);\n  }\n\n  @Override public int hashCode() {\n    return Objects.hash(id, exp, value);\n  }\n\n  @Override public boolean equals(Object o) {\n    return this == o\n        || o instanceof Binding\n        && id.equals(((Binding) o).id)\n        && Objects.equals(exp, ((Binding) o).exp)\n        && value.equals(((Binding) o).value);\n  }\n\n  public Binding withParameter(boolean parameter) {\n    return new Binding(id, exp, value, parameter);\n  }\n\n  @Override public String toString() {\n    if (exp != null) {\n      return id + \" = \" + exp;\n    } else if (value == Unit.INSTANCE) {\n      return id + \" : \" + id.type.moniker();\n    } else {\n      return id + \" = \" + value + \" : \" + id.type.moniker();\n    }\n  }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "public final Core.NamedPat id;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "Core.NamedPat", "name": "id", "syntax_pass": true}, {"attribute_expression": "public final Core.Exp exp;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "Core.Exp", "name": "exp", "syntax_pass": true}, {"attribute_expression": "public final Object value;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "Object", "name": "value", "syntax_pass": true}, {"attribute_expression": "public final boolean parameter;", "docstring": " If true, the binding is ignored by inlining.", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "boolean", "name": "parameter", "syntax_pass": true}]}, {"uris": "src/main/java/net/hydromatic/morel/type/TypeSystem.java.TypeSystem", "name": "TypeSystem", "file_path": "src/main/java/net/hydromatic/morel/type/TypeSystem.java", "superclasses": "", "methods": ["[]TypeSystem()", "[Binding]bindTyCon(DataType,String)", "[Type]wrap(DataType,Type)", "[Type]lookupInternal(String)", "[Type]lookup(String)", "[Type]lookupOpt(String)", "[Type]typeFor(Key)", "[List<Type>]typesFor(Iterable<? extends Key>)", "[SortedMap<String, Type>]typesFor(Map<String, ? extends Key>)", "[Type]fnType(Type,Type,Type)", "[FnType]fnType(Type,Type)", "[TupleType]tupleType(Type)", "[RecordLikeType]tupleType(List<? extends Type>)", "[ListType]listType(Type)", "[List<Type>]dataTypes(List<Keys.DataTypeKey>)", "[DataType]dataType(String,List<? extends Type>,SortedMap<String, Key>)", "[void]setInternal(String)", "[Type]dataTypeScheme(String,List<TypeVar>,SortedMap<String, Type.Key>)", "[Type]recordOrScalarType(Collection<Map.Entry<String, Type>>)", "[RecordLikeType]recordType(Collection<Map.Entry<String, Type>>)", "[RecordLikeType]recordType(SortedMap<String, ? extends Type>)", "[boolean]areContiguousIntegers(Iterable<String>)", "[ProgressiveRecordType]progressiveRecordType(Collection<Map.Entry<String, Type>>)", "[ProgressiveRecordType]progressiveRecordType(SortedMap<String, Type>)", "[Type]forallType(int,Function<ForallHelper, Type>)", "[ForallType]forallType(int,Type)", "[StringBuilder]unparseList(StringBuilder,Op,int,int,Collection<? extends Type.Key>)", "[StringBuilder]unparse(StringBuilder,Type.Key,int,int)", "[List<TypeVar>]typeVariables(int)", "[Pair<DataType, Type.Key>]lookupTyCon(String)", "[Type]apply(Type)", "[Type]apply(Type,List<Type>)", "[TypeVar]typeVariable(int)", "[Type]option(Type)", "[Type]vector(Type)", "[Type]ensureClosed(Type)"], "method_uris": ["src/main/java/net/hydromatic/morel/type/TypeSystem.java.TypeSystem.[]TypeSystem()", "src/main/java/net/hydromatic/morel/type/TypeSystem.java.TypeSystem.[Binding]bindTyCon(DataType,String)", "src/main/java/net/hydromatic/morel/type/TypeSystem.java.TypeSystem.[Type]wrap(DataType,Type)", "src/main/java/net/hydromatic/morel/type/TypeSystem.java.TypeSystem.[Type]lookupInternal(String)", "src/main/java/net/hydromatic/morel/type/TypeSystem.java.TypeSystem.[Type]lookup(String)", "src/main/java/net/hydromatic/morel/type/TypeSystem.java.TypeSystem.[Type]lookupOpt(String)", "src/main/java/net/hydromatic/morel/type/TypeSystem.java.TypeSystem.[Type]typeFor(Key)", "src/main/java/net/hydromatic/morel/type/TypeSystem.java.TypeSystem.[List<Type>]typesFor(Iterable<? extends Key>)", "src/main/java/net/hydromatic/morel/type/TypeSystem.java.TypeSystem.[SortedMap<String, Type>]typesFor(Map<String, ? extends Key>)", "src/main/java/net/hydromatic/morel/type/TypeSystem.java.TypeSystem.[Type]fnType(Type,Type,Type)", "src/main/java/net/hydromatic/morel/type/TypeSystem.java.TypeSystem.[FnType]fnType(Type,Type)", "src/main/java/net/hydromatic/morel/type/TypeSystem.java.TypeSystem.[TupleType]tupleType(Type)", "src/main/java/net/hydromatic/morel/type/TypeSystem.java.TypeSystem.[RecordLikeType]tupleType(List<? extends Type>)", "src/main/java/net/hydromatic/morel/type/TypeSystem.java.TypeSystem.[ListType]listType(Type)", "src/main/java/net/hydromatic/morel/type/TypeSystem.java.TypeSystem.[List<Type>]dataTypes(List<Keys.DataTypeKey>)", "src/main/java/net/hydromatic/morel/type/TypeSystem.java.TypeSystem.[DataType]dataType(String,List<? extends Type>,SortedMap<String, Key>)", "src/main/java/net/hydromatic/morel/type/TypeSystem.java.TypeSystem.[void]setInternal(String)", "src/main/java/net/hydromatic/morel/type/TypeSystem.java.TypeSystem.[Type]dataTypeScheme(String,List<TypeVar>,SortedMap<String, Type.Key>)", "src/main/java/net/hydromatic/morel/type/TypeSystem.java.TypeSystem.[Type]recordOrScalarType(Collection<Map.Entry<String, Type>>)", "src/main/java/net/hydromatic/morel/type/TypeSystem.java.TypeSystem.[RecordLikeType]recordType(Collection<Map.Entry<String, Type>>)", "src/main/java/net/hydromatic/morel/type/TypeSystem.java.TypeSystem.[RecordLikeType]recordType(SortedMap<String, ? extends Type>)", "src/main/java/net/hydromatic/morel/type/TypeSystem.java.TypeSystem.[boolean]areContiguousIntegers(Iterable<String>)", "src/main/java/net/hydromatic/morel/type/TypeSystem.java.TypeSystem.[ProgressiveRecordType]progressiveRecordType(Collection<Map.Entry<String, Type>>)", "src/main/java/net/hydromatic/morel/type/TypeSystem.java.TypeSystem.[ProgressiveRecordType]progressiveRecordType(SortedMap<String, Type>)", "src/main/java/net/hydromatic/morel/type/TypeSystem.java.TypeSystem.[Type]forallType(int,Function<ForallHelper, Type>)", "src/main/java/net/hydromatic/morel/type/TypeSystem.java.TypeSystem.[ForallType]forallType(int,Type)", "src/main/java/net/hydromatic/morel/type/TypeSystem.java.TypeSystem.[StringBuilder]unparseList(StringBuilder,Op,int,int,Collection<? extends Type.Key>)", "src/main/java/net/hydromatic/morel/type/TypeSystem.java.TypeSystem.[StringBuilder]unparse(StringBuilder,Type.Key,int,int)", "src/main/java/net/hydromatic/morel/type/TypeSystem.java.TypeSystem.[List<TypeVar>]typeVariables(int)", "src/main/java/net/hydromatic/morel/type/TypeSystem.java.TypeSystem.[Pair<DataType, Type.Key>]lookupTyCon(String)", "src/main/java/net/hydromatic/morel/type/TypeSystem.java.TypeSystem.[Type]apply(Type)", "src/main/java/net/hydromatic/morel/type/TypeSystem.java.TypeSystem.[Type]apply(Type,List<Type>)", "src/main/java/net/hydromatic/morel/type/TypeSystem.java.TypeSystem.[TypeVar]typeVariable(int)", "src/main/java/net/hydromatic/morel/type/TypeSystem.java.TypeSystem.[Type]option(Type)", "src/main/java/net/hydromatic/morel/type/TypeSystem.java.TypeSystem.[Type]vector(Type)", "src/main/java/net/hydromatic/morel/type/TypeSystem.java.TypeSystem.[Type]ensureClosed(Type)"], "overrides": null, "attributes": [{"original_string": "  private static class VariableCollector extends TypeVisitor<Void> {\n    final Set<TypeVar> vars = new LinkedHashSet<>();\n\n    @Override public Void visit(DataType dataType) {\n      return null; // ignore type variables in the datatype\n    }\n\n    @Override public Void visit(TypeVar typeVar) {\n      vars.add(typeVar);\n      return super.visit(typeVar);\n    }\n  }", "definition": "  private static class VariableCollector extends TypeVisitor<Void>", "class_docstring": " Visitor that finds all {@link TypeVar} instances within a {@link Type}.", "name": "VariableCollector", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "fields": [{"attribute_expression": "final Set<TypeVar> vars = new LinkedHashSet<>();", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "Set<TypeVar>", "name": "vars = new LinkedHashSet<>()", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @Override public Void visit(DataType dataType) {\n      return null; // ignore type variables in the datatype\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Void", "classes": []}, "name": "visit", "params": [{"name": "dataType", "type": "DataType"}], "body": "                                                   {\n      return null; // ignore type variables in the datatype\n    }", "signature": "@Override public Void visit(DataType dataType)"}, {"syntax_pass": true, "original_string": "    @Override public Void visit(TypeVar typeVar) {\n      vars.add(typeVar);\n      return super.visit(typeVar);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Void", "classes": []}, "name": "visit", "params": [{"name": "typeVar", "type": "TypeVar"}], "body": "                                                 {\n      vars.add(typeVar);\n      return super.visit(typeVar);\n    }", "signature": "@Override public Void visit(TypeVar typeVar)"}]}], "class_docstring": " A table that contains all types in use, indexed by their description (e.g.\n\"{@code int -> int}\").", "original_string": "public class TypeSystem {\n  final Map<String, Type> typeByName = new HashMap<>();\n  final Map<String, Type> internalTypeByName = new HashMap<>();\n  final Map<Key, Type> typeByKey = new HashMap<>();\n\n  private final Map<String, Pair<DataType, Type.Key>> typeConstructorByName =\n      new HashMap<>();\n\n  public final NameGenerator nameGenerator = new NameGenerator();\n\n  /** Number of times that\n   * {@link TypedValue#discoverField(TypeSystem, String)} has caused a\n   * type to change. */\n  public final AtomicInteger expandCount = new AtomicInteger();\n\n  public TypeSystem() {\n    for (PrimitiveType primitiveType : PrimitiveType.values()) {\n      typeByName.put(primitiveType.moniker, primitiveType);\n    }\n  }\n\n  /** Creates a binding of a type constructor value. */\n  public Binding bindTyCon(DataType dataType, String tyConName) {\n    final Type type = dataType.typeConstructors(this).get(tyConName);\n    if (type == DummyType.INSTANCE) {\n      return Binding.of(core.idPat(dataType, tyConName, 0),\n          Codes.constant(ComparableSingletonList.of(tyConName)));\n    } else {\n      final Type type2 = wrap(dataType, fnType(type, dataType));\n      return Binding.of(core.idPat(type2, tyConName, 0),\n          Codes.tyCon(dataType, tyConName));\n    }\n  }\n\n  private Type wrap(DataType dataType, Type type) {\n    final List<TypeVar> typeVars =\n        dataType.parameterTypes.stream().filter(t -> t instanceof TypeVar)\n            .map(t -> (TypeVar) t)\n            .collect(toImmutableList());\n    return typeVars.isEmpty() ? type : forallType(typeVars.size(), type);\n  }\n\n  /** Looks up an internal type by name. */\n  public Type lookupInternal(String name) {\n    final Type type = internalTypeByName.get(name);\n    if (type == null) {\n      throw new AssertionError(\"unknown type: \" + name);\n    }\n    return type;\n  }\n\n  /** Looks up a type by name. */\n  public Type lookup(String name) {\n    final Type type = typeByName.get(name);\n    if (type == null) {\n      throw new AssertionError(\"unknown type: \" + name);\n    }\n    return type;\n  }\n\n  /** Looks up a type by name, returning null if not found. */\n  public Type lookupOpt(String name) {\n    // TODO: only use this for names, e.g. 'option',\n    // not monikers e.g. 'int option';\n    // assert !name.contains(\" \") : name;\n    return typeByName.get(name);\n  }\n\n  /** Gets a type that matches a key, creating if necessary. */\n  public Type typeFor(Key key) {\n    Type type = typeByKey.get(key);\n    if (type == null) {\n      type = key.toType(this);\n      typeByKey.putIfAbsent(key, type);\n    }\n    return type;\n  }\n\n  /** Converts a list of keys to a list of types. */\n  public List<Type> typesFor(Iterable<? extends Key> keys) {\n    return transformEager(keys, key -> key.toType(this));\n  }\n\n  /** Converts a map of keys to a map of types. */\n  public SortedMap<String, Type> typesFor(Map<String, ? extends Key> keys) {\n    final ImmutableSortedMap.Builder<String, Type> types =\n        ImmutableSortedMap.orderedBy(RecordType.ORDERING);\n    keys.forEach((name, key) -> types.put(name, typeFor(key)));\n    return types.build();\n  }\n\n  /** Creates a multi-step function type.\n   *\n   * <p>For example, {@code fnType(a, b, c, d)} returns the same as\n   * {@code fnType(a, fnType(b, fnType(c, d)))},\n   * viz <code>a &rarr; b &rarr; c &rarr; d</code>. */\n  public Type fnType(Type paramType, Type type1, Type type2,\n      Type... moreTypes) {\n    final List<Type> types = ImmutableList.<Type>builder()\n        .add(paramType).add(type1).add(type2).add(moreTypes).build();\n    Type t = null;\n    for (Type type : Lists.reverse(types)) {\n      if (t == null) {\n        t = type;\n      } else {\n        t = fnType(type, t);\n      }\n    }\n    return requireNonNull(t);\n  }\n\n  /** Creates a function type. */\n  public FnType fnType(Type paramType, Type resultType) {\n    return (FnType) typeFor(Keys.fn(paramType.key(), resultType.key()));\n  }\n\n  /** Creates a tuple type from an array of types. */\n  public TupleType tupleType(Type argType0, Type... argTypes) {\n    return (TupleType) tupleType(Lists.asList(argType0, argTypes));\n  }\n\n  /** Creates a tuple type. */\n  public RecordLikeType tupleType(List<? extends Type> argTypes) {\n    return (RecordLikeType) typeFor(Keys.tuple(Keys.toKeys(argTypes)));\n  }\n\n  /** Creates a list type. */\n  public ListType listType(Type elementType) {\n    return (ListType) typeFor(Keys.list(elementType.key()));\n  }\n\n  /** Creates several data types simultaneously. */\n  public List<Type> dataTypes(List<Keys.DataTypeKey> keys) {\n    final Map<Type.Key, DataType> dataTypeMap = new LinkedHashMap<>();\n    keys.forEach(key -> {\n      final DataType dataType = key.toType(this);\n      final Key nameKey = Keys.name(dataType.name);\n      typeByKey.put(nameKey, dataType);\n\n      dataType.typeConstructors.forEach((name, typeKey) ->\n          typeConstructorByName.put(name, Pair.of(dataType, typeKey)));\n      dataTypeMap.put(nameKey, dataType);\n    });\n\n    final ImmutableList.Builder<Type> types = ImmutableList.builder();\n    dataTypeMap.values().forEach(dataType -> {\n      // We have just created an entry for the moniker (e.g. \"'a option\"),\n      // so now create an entry for the name (e.g. \"option\").\n      Type t =\n          dataType.arguments.isEmpty() ? dataType\n              : forallType(dataType.arguments.size(), dataType);\n      typeByName.put(dataType.name, t);\n      types.add(t);\n    });\n    return types.build();\n  }\n\n  /** Creates an algebraic type.\n   *\n   * <p>Parameter types is empty unless this is a type scheme.\n   * For example,\n   *\n   * <ul>\n   *   <li>{@code datatype 'a option = NONE | SOME of 'a} has\n   *   parameter types and argument types {@code ['a]},\n   *   type constructors {@code [NONE: dummy, SOME: 'a]};\n   *   <li>{@code int option} has empty parameter types,\n   *   argument types {@code [int]},\n   *   type constructors {@code [NONE: dummy, SOME: int]};\n   *   <li>{@code datatype color = RED | GREEN} has\n   *   empty parameter types and argument types,\n   *   type constructors {@code [RED: dummy, GREEN: dummy]}.\n   * </ul>\n   *\n   * @param name Name (e.g. \"option\")\n   * @param argumentTypes Argument types\n   * @param tyCons Type constructors\n   */\n  DataType dataType(String name, List<? extends Type> argumentTypes,\n      SortedMap<String, Key> tyCons) {\n    final String moniker = DataType.computeMoniker(name, argumentTypes);\n    final DataType dataType =\n        new DataType(Op.DATA_TYPE, name, moniker, argumentTypes, tyCons);\n    if (argumentTypes.isEmpty()) {\n      // There are no type parameters, therefore there will be no ForallType to\n      // register its type constructors, so this DataType needs to register.\n      tyCons.forEach((name3, typeKey) ->\n          typeConstructorByName.put(name3, Pair.of(dataType, typeKey)));\n    }\n    return dataType;\n  }\n\n  /** Converts a regular type to an internal type. Throws if the type is not\n   * known. */\n  public void setInternal(String name) {\n    final Type type = typeByName.remove(name);\n    internalTypeByName.put(name, type);\n  }\n\n  /** Creates a data type scheme: a datatype if there are no type arguments\n   * (e.g. \"{@code ordering}\"), or a forall type if there are type arguments\n   * (e.g. \"{@code forall 'a . 'a option}\"). */\n  public Type dataTypeScheme(String name, List<TypeVar> parameters,\n      SortedMap<String, Type.Key> tyCons) {\n    final List<Key> keys = Keys.toKeys(parameters);\n    final Keys.DataTypeKey key = Keys.datatype(name, keys, tyCons);\n    return dataTypes(ImmutableList.of(key)).get(0);\n  }\n\n  /** Creates a record type, or returns a scalar type if {@code argNameTypes}\n   * has one entry. */\n  public Type recordOrScalarType(\n      Collection<Map.Entry<String, Type>> argNameTypes) {\n    switch (argNameTypes.size()) {\n    case 1:\n      return Iterables.getOnlyElement(argNameTypes).getValue();\n    default:\n      return recordType(argNameTypes);\n    }\n  }\n\n  /** Creates a record type. (Or a tuple type if the fields are named \"1\", \"2\"\n   * etc.; or \"unit\" if the field list is empty.) */\n  public RecordLikeType recordType(\n      Collection<Map.Entry<String, Type>> argNameTypes) {\n    return recordType(\n        ImmutableSortedMap.copyOf(argNameTypes, RecordType.ORDERING));\n  }\n\n  /** Creates a record type. (Or a tuple type if the fields are named \"1\", \"2\"\n   * etc.; or \"unit\" if the field list is empty.) */\n  public RecordLikeType recordType(\n      SortedMap<String, ? extends Type> argNameTypes) {\n    final ImmutableSortedMap<String, Type> argNameTypes2 =\n        ImmutableSortedMap.copyOf(argNameTypes, RecordType.ORDERING);\n    if (argNameTypes2.isEmpty()) {\n      return PrimitiveType.UNIT;\n    }\n    if (areContiguousIntegers(argNameTypes2.keySet())\n        && argNameTypes2.size() != 1) {\n      return tupleType(ImmutableList.copyOf(argNameTypes2.values()));\n    }\n    return (RecordLikeType) typeFor(Keys.record(Keys.toKeys(argNameTypes2)));\n  }\n\n  /** Returns whether the collection is [\"1\", \"2\", ... n]. */\n  public static boolean areContiguousIntegers(Iterable<String> strings) {\n    int i = 1;\n    for (String string : strings) {\n      if (!string.equals(Integer.toString(i++))) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /** Creates a progressive record type. */\n  public ProgressiveRecordType progressiveRecordType(\n      Collection<Map.Entry<String, Type>> argNameTypes) {\n    return progressiveRecordType(\n        ImmutableSortedMap.copyOf(argNameTypes, RecordType.ORDERING));\n  }\n\n  /** Creates a progressive record type. */\n  public ProgressiveRecordType progressiveRecordType(\n      SortedMap<String, Type> argNameTypes) {\n    final ImmutableSortedMap<String, Type> argNameTypes2 =\n        ImmutableSortedMap.copyOf(argNameTypes, RecordType.ORDERING);\n    Key key = Keys.progressiveRecord(Keys.toKeys(argNameTypes2));\n    return (ProgressiveRecordType) typeFor(key);\n  }\n\n  /** Creates a \"forall\" type. */\n  public Type forallType(int typeCount, Function<ForallHelper, Type> builder) {\n    final ForallHelper helper = new ForallHelper() {\n      public TypeVar get(int i) {\n        return typeVariable(i);\n      }\n\n      public ListType list(int i) {\n        return listType(get(i));\n      }\n\n      public Type vector(int i) {\n        return TypeSystem.this.vector(get(i));\n      }\n\n      public Type option(int i) {\n        return TypeSystem.this.option(get(i));\n      }\n\n      public FnType predicate(int i) {\n        return fnType(get(i), PrimitiveType.BOOL);\n      }\n    };\n    final Type type = builder.apply(helper);\n    return forallType(typeCount, type);\n  }\n\n  /** Creates a \"for all\" type. */\n  public ForallType forallType(int typeCount, Type type) {\n    final Key key = Keys.forall(type, typeCount);\n    return (ForallType) typeFor(key);\n  }\n\n  static StringBuilder unparseList(StringBuilder builder, Op op, int left,\n      int right, Collection<? extends Type.Key> argTypes) {\n    if (op == Op.COMMA && argTypes.size() != 1 && !(left == 0 && right == 0)) {\n      builder.append('(');\n      unparseList(builder, op, 0, 0, argTypes);\n      builder.append(')');\n    } else {\n      forEachIndexed(argTypes, (type, i) -> {\n        if (i > 0) {\n          builder.append(op.padded);\n        }\n        unparse(builder, type,\n            i == 0 ? left : op.right,\n            i == argTypes.size() - 1 ? right : op.left);\n      });\n    }\n    return builder;\n  }\n\n  static StringBuilder unparse(StringBuilder builder, Type.Key type, int left,\n      int right) {\n    if (left > type.op.left || type.op.right < right) {\n      builder.append(\"(\");\n      unparse(builder, type, 0, 0);\n      return builder.append(\")\");\n    } else {\n      return type.describe(builder, left, right);\n    }\n  }\n\n  public List<TypeVar> typeVariables(int size) {\n    return new AbstractList<TypeVar>() {\n      public int size() {\n        return size;\n      }\n\n      public TypeVar get(int index) {\n        return typeVariable(index);\n      }\n    };\n  }\n\n  public Pair<DataType, Type.Key> lookupTyCon(String tyConName) {\n    return typeConstructorByName.get(tyConName);\n  }\n\n  public Type apply(Type type, Type... types) {\n    return apply(type, ImmutableList.copyOf(types));\n  }\n\n  public Type apply(Type type, List<Type> types) {\n    if (type instanceof ForallType) {\n      final ForallType forallType = (ForallType) type;\n      return forallType.substitute(this, types);\n    }\n    if (type instanceof DataType) {\n      final DataType dataType = (DataType) type;\n      return dataType.substitute(this, types);\n    }\n    throw new AssertionError();\n  }\n\n  /** Creates a type variable. */\n  public TypeVar typeVariable(int ordinal) {\n    return (TypeVar) typeFor(Keys.ordinal(ordinal));\n  }\n\n  /** Creates an \"option\" type.\n   *\n   * <p>\"option(type)\" is shorthand for \"apply(lookup(\"option\"), type)\". */\n  public Type option(Type type) {\n    final Type optionType = lookup(\"option\");\n    return apply(optionType, type);\n  }\n\n  /** Creates a \"vector\" type.\n   *\n   * <p>\"vector(type)\" is shorthand for \"apply(lookup(\"vector\"), type)\". */\n  public Type vector(Type type) {\n    final Type vectorType = lookup(\"vector\");\n    return apply(vectorType, type);\n  }\n\n  /** Converts a type into a {@link ForallType} if it has free type\n   * variables. */\n  public Type ensureClosed(Type type) {\n    final VariableCollector collector = new VariableCollector();\n    type.accept(collector);\n    if (collector.vars.isEmpty()) {\n      return type;\n    }\n    final TypeSystem ts = this;\n    return forallType(collector.vars.size(), h ->\n        type.copy(ts, t ->\n            t instanceof TypeVar ? h.get(((TypeVar) t).ordinal) : t));\n  }\n\n  /** Visitor that finds all {@link TypeVar} instances within a {@link Type}. */\n  private static class VariableCollector extends TypeVisitor<Void> {\n    final Set<TypeVar> vars = new LinkedHashSet<>();\n\n    @Override public Void visit(DataType dataType) {\n      return null; // ignore type variables in the datatype\n    }\n\n    @Override public Void visit(TypeVar typeVar) {\n      vars.add(typeVar);\n      return super.visit(typeVar);\n    }\n  }\n\n  /** Provides access to type variables from within a call to\n   * {@link TypeSystem#forallType(int, Function)}. */\n  public interface ForallHelper {\n    /** Creates type {@code `i}. */\n    TypeVar get(int i);\n    /** Creates type {@code `i list}. */\n    ListType list(int i);\n    /** Creates type {@code `i vector}. */\n    Type vector(int i);\n    /** Creates type {@code `i option}. */\n    Type option(int i);\n    /** Creates type <code>`i &rarr; bool</code>. */\n    FnType predicate(int i);\n  }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "final Map<String, Type> typeByName = new HashMap<>();", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "Map<String, Type>", "name": "typeByName = new HashMap<>()", "syntax_pass": true}, {"attribute_expression": "final Map<String, Type> internalTypeByName = new HashMap<>();", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "Map<String, Type>", "name": "internalTypeByName = new HashMap<>()", "syntax_pass": true}, {"attribute_expression": "final Map<Key, Type> typeByKey = new HashMap<>();", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "Map<Key, Type>", "name": "typeByKey = new HashMap<>()", "syntax_pass": true}, {"attribute_expression": "private final Map<String, Pair<DataType, Type.Key>> typeConstructorByName =\n      new HashMap<>();", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Map<String, Pair<DataType, Type.Key>>", "name": "typeConstructorByName =\n      new HashMap<>()", "syntax_pass": true}, {"attribute_expression": "public final NameGenerator nameGenerator = new NameGenerator();", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "NameGenerator", "name": "nameGenerator = new NameGenerator()", "syntax_pass": true}, {"attribute_expression": "public final AtomicInteger expandCount = new AtomicInteger();", "docstring": " Number of times that\n{@link TypedValue#discoverField(TypeSystem, String)} has caused a\ntype to change.", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "AtomicInteger", "name": "expandCount = new AtomicInteger()", "syntax_pass": true}]}, {"uris": "src/main/java/net/hydromatic/morel/type/TupleType.java.TupleType", "name": "TupleType", "file_path": "src/main/java/net/hydromatic/morel/type/TupleType.java", "superclasses": "BaseType", "methods": ["[]TupleType(List<? extends Type>)", "[SortedMap<String, Type>]argNameTypes()", "[List<Type>]argTypes()", "[Type]argType(int)", "[R]accept(TypeVisitor<R>)", "[Key]key()", "[TupleType]copy(TypeSystem,UnaryOperator<Type>)", "[String]str(int)", "[List<String>]ordinalNames(int)", "[ImmutableSortedMap<String, E>]recordMap(List<? extends E>)", "[ImmutableSortedMap<String, Type.Key>]toArgNameTypeKeys(List<? extends Type>)"], "method_uris": ["src/main/java/net/hydromatic/morel/type/TupleType.java.TupleType.[]TupleType(List<? extends Type>)", "src/main/java/net/hydromatic/morel/type/TupleType.java.TupleType.[SortedMap<String, Type>]argNameTypes()", "src/main/java/net/hydromatic/morel/type/TupleType.java.TupleType.[List<Type>]argTypes()", "src/main/java/net/hydromatic/morel/type/TupleType.java.TupleType.[Type]argType(int)", "src/main/java/net/hydromatic/morel/type/TupleType.java.TupleType.[R]accept(TypeVisitor<R>)", "src/main/java/net/hydromatic/morel/type/TupleType.java.TupleType.[Key]key()", "src/main/java/net/hydromatic/morel/type/TupleType.java.TupleType.[TupleType]copy(TypeSystem,UnaryOperator<Type>)", "src/main/java/net/hydromatic/morel/type/TupleType.java.TupleType.[String]str(int)", "src/main/java/net/hydromatic/morel/type/TupleType.java.TupleType.[List<String>]ordinalNames(int)", "src/main/java/net/hydromatic/morel/type/TupleType.java.TupleType.[ImmutableSortedMap<String, E>]recordMap(List<? extends E>)", "src/main/java/net/hydromatic/morel/type/TupleType.java.TupleType.[ImmutableSortedMap<String, Type.Key>]toArgNameTypeKeys(List<? extends Type>)"], "overrides": null, "attributes": [], "class_docstring": " The type of a tuple value.", "original_string": "public class TupleType extends BaseType implements RecordLikeType {\n  private static final String[] INT_STRINGS =\n      {\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\"};\n\n  public final List<Type> argTypes;\n\n  TupleType(List<? extends Type> argTypes) {\n    super(Op.TUPLE_TYPE);\n    this.argTypes = ImmutableList.copyOf(argTypes);\n  }\n\n  @Override public SortedMap<String, Type> argNameTypes() {\n    final ImmutableSortedMap.Builder<String, Type> map =\n        ImmutableSortedMap.orderedBy(RecordType.ORDERING);\n    forEachIndexed(argTypes, (t, i) -> map.put(Integer.toString(i + 1), t));\n    return map.build();\n  }\n\n  @Override public List<Type> argTypes() {\n    return argTypes;\n  }\n\n  @Override public Type argType(int i) {\n    return argTypes.get(i);\n  }\n\n  public <R> R accept(TypeVisitor<R> typeVisitor) {\n    return typeVisitor.visit(this);\n  }\n\n  public Key key() {\n    return Keys.record(toArgNameTypeKeys(argTypes));\n  }\n\n  @Override public TupleType copy(TypeSystem typeSystem,\n      UnaryOperator<Type> transform) {\n    int differenceCount = 0;\n    final ImmutableList.Builder<Type> argTypes2 = ImmutableList.builder();\n    for (Type argType : argTypes) {\n      final Type argType2 = transform.apply(argType);\n      if (argType != argType2) {\n        ++differenceCount;\n      }\n      argTypes2.add(argType2);\n    }\n    return differenceCount == 0\n        ? this\n        : new TupleType(argTypes2.build());\n  }\n\n  /** Converts an integer to its string representation, using a cached value\n   * if possible. */\n  private static String str(int i) {\n    return i >= 0 && i < INT_STRINGS.length ? INT_STRINGS[i]\n        : Integer.toString(i);\n  }\n\n  /** Returns a list of strings [\"1\", ..., \"size\"]. */\n  public static List<String> ordinalNames(int size) {\n    return new AbstractList<String>() {\n      public int size() {\n        return size;\n      }\n\n      public String get(int index) {\n        return str(index + 1);\n      }\n    };\n  }\n\n  /** Given a list of types [t1, t2, ..., tn] returns a sorted map [\"1\" : t1,\n   * \"2\" : t2, ... \"n\" : tn]. */\n  static <E> ImmutableSortedMap<String, E> recordMap(\n      List<? extends E> argTypes) {\n    final ImmutableSortedMap.Builder<String, E> b =\n        ImmutableSortedMap.orderedBy(RecordType.ORDERING);\n    forEachIndexed(argTypes, (t, i) ->\n        b.put(Integer.toString(i + 1), t));\n    return b.build();\n  }\n\n  /** Given a list of types [t1, t2, ..., tn] returns a sorted map\n   * [\"1\" : t1.key, \"2\" : t2.key, ... \"n\" : tn.key]. */\n  static ImmutableSortedMap<String, Type.Key> toArgNameTypeKeys(\n      List<? extends Type> argTypes) {\n    return recordMap(transform(argTypes, Type::key));\n  }\n}", "super_interfaces": ["RecordLikeType"], "fields": [{"attribute_expression": "private static final String[] INT_STRINGS =\n      {\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\"};", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String[]", "name": "INT_STRINGS =\n      {\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\"}", "syntax_pass": true}, {"attribute_expression": "public final List<Type> argTypes;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "List<Type>", "name": "argTypes", "syntax_pass": true}]}, {"uris": "src/main/java/net/hydromatic/morel/type/DataType.java.DataType", "name": "DataType", "file_path": "src/main/java/net/hydromatic/morel/type/DataType.java", "superclasses": "ParameterizedType", "methods": ["[]DataType(String,String,List<? extends Type>,SortedMap<String, Key>)", "[]DataType(Op,String,String,List<? extends Type>,SortedMap<String, Key>)", "[Key]key()", "[R]accept(TypeVisitor<R>)", "[SortedMap<String, Type>]typeConstructors(TypeSystem)", "[DataType]copy(TypeSystem,UnaryOperator<Type>)", "[StringBuilder]describe(StringBuilder)"], "method_uris": ["src/main/java/net/hydromatic/morel/type/DataType.java.DataType.[]DataType(String,String,List<? extends Type>,SortedMap<String, Key>)", "src/main/java/net/hydromatic/morel/type/DataType.java.DataType.[]DataType(Op,String,String,List<? extends Type>,SortedMap<String, Key>)", "src/main/java/net/hydromatic/morel/type/DataType.java.DataType.[Key]key()", "src/main/java/net/hydromatic/morel/type/DataType.java.DataType.[R]accept(TypeVisitor<R>)", "src/main/java/net/hydromatic/morel/type/DataType.java.DataType.[SortedMap<String, Type>]typeConstructors(TypeSystem)", "src/main/java/net/hydromatic/morel/type/DataType.java.DataType.[DataType]copy(TypeSystem,UnaryOperator<Type>)", "src/main/java/net/hydromatic/morel/type/DataType.java.DataType.[StringBuilder]describe(StringBuilder)"], "overrides": null, "attributes": [], "class_docstring": " Algebraic type.", "original_string": "public class DataType extends ParameterizedType {\n  public final List<Type> arguments;\n  public final SortedMap<String, Key> typeConstructors;\n\n  /** Creates a DataType.\n   *\n   * <p>Called only from {@link TypeSystem#dataTypes(List)}.\n   *\n   * <p>If the {@code typeSystem} argument is specified, canonizes the types\n   * inside type-constructors. This also allows temporary types (necessary while\n   * creating self-referential data types) to be replaced with real DataType\n   * instances.\n   *\n   * <p>During replacement, if a type matches {@code placeholderType} it is\n   * replaced with {@code this}. This allows cyclic graphs to be copied. */\n  DataType(String name, String moniker, List<? extends Type> arguments,\n      SortedMap<String, Key> typeConstructors) {\n    this(Op.DATA_TYPE, name, moniker, arguments, typeConstructors);\n  }\n\n  /** Called only from DataType constructor. */\n  protected DataType(Op op, String name, String moniker,\n      List<? extends Type> arguments, SortedMap<String, Key> typeConstructors) {\n    super(op, name, moniker, arguments.size());\n    this.arguments = ImmutableList.copyOf(arguments);\n    this.typeConstructors = ImmutableSortedMap.copyOf(typeConstructors);\n    checkArgument(typeConstructors.comparator() == null\n        || typeConstructors.comparator() == Ordering.natural());\n  }\n\n  @Override public Key key() {\n    return Keys.datatype(name, Keys.toKeys(arguments), typeConstructors);\n  }\n\n  public <R> R accept(TypeVisitor<R> typeVisitor) {\n    return typeVisitor.visit(this);\n  }\n\n  public SortedMap<String, Type> typeConstructors(TypeSystem typeSystem) {\n    return Maps.transformValues(typeConstructors,\n        k -> k.copy(t -> t.substitute(arguments)).toType(typeSystem));\n  }\n\n  @Override public DataType copy(TypeSystem typeSystem,\n      UnaryOperator<Type> transform) {\n    final List<Type> arguments = transformEager(this.arguments, transform);\n    if (arguments.equals(this.arguments)) {\n      return this;\n    }\n    return new DataType(name, moniker, arguments, typeConstructors);\n  }\n\n  /** Writes out the definition of the datatype. For example,\n   *\n   * <blockquote>{@code\n   * datatype ('a,'b) tree =\n   *     Empty\n   *   | Node of ('a,'b) tree * 'b * 'a * ('a,'b) tree\n   * }</blockquote>\n   */\n  public StringBuilder describe(StringBuilder buf) {\n    buf.append(\"datatype \")\n        .append(moniker)\n        .append(\" = \");\n    final int initialSize = buf.length();\n    typeConstructors.forEach((name, typeKey) -> {\n      if (buf.length() > initialSize) {\n        buf.append(\" | \");\n      }\n      buf.append(name);\n      if (typeKey.op != Op.DUMMY_TYPE) {\n        buf.append(\" of \");\n        typeKey.describe(buf, 0, 0);\n      }\n    });\n    return buf;\n  }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "public final List<Type> arguments;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "List<Type>", "name": "arguments", "syntax_pass": true}, {"attribute_expression": "public final SortedMap<String, Key> typeConstructors;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "SortedMap<String, Key>", "name": "typeConstructors", "syntax_pass": true}]}, {"uris": "src/main/java/net/hydromatic/morel/type/ForallType.java.ForallType", "name": "ForallType", "file_path": "src/main/java/net/hydromatic/morel/type/ForallType.java", "superclasses": "BaseType", "methods": ["[]ForallType(int,Type)", "[Key]key()", "[R]accept(TypeVisitor<R>)", "[ForallType]copy(TypeSystem,UnaryOperator<Type>)", "[Type]substitute(TypeSystem,List<? extends Type>)"], "method_uris": ["src/main/java/net/hydromatic/morel/type/ForallType.java.ForallType.[]ForallType(int,Type)", "src/main/java/net/hydromatic/morel/type/ForallType.java.ForallType.[Key]key()", "src/main/java/net/hydromatic/morel/type/ForallType.java.ForallType.[R]accept(TypeVisitor<R>)", "src/main/java/net/hydromatic/morel/type/ForallType.java.ForallType.[ForallType]copy(TypeSystem,UnaryOperator<Type>)", "src/main/java/net/hydromatic/morel/type/ForallType.java.ForallType.[Type]substitute(TypeSystem,List<? extends Type>)"], "overrides": null, "attributes": [], "class_docstring": " Universally quantified type.", "original_string": "public class ForallType extends BaseType {\n  public final int parameterCount;\n  public final Type type;\n\n  ForallType(int parameterCount, Type type) {\n    super(Op.FORALL_TYPE);\n    this.parameterCount = parameterCount;\n    this.type = requireNonNull(type);\n  }\n\n  public Key key() {\n    return Keys.forall(type, parameterCount);\n  }\n\n  public <R> R accept(TypeVisitor<R> typeVisitor) {\n    return typeVisitor.visit(this);\n  }\n\n  @Override public ForallType copy(TypeSystem typeSystem,\n      UnaryOperator<Type> transform) {\n    final Type type2 = type.copy(typeSystem, transform);\n    return type2 == type\n        ? this\n        : typeSystem.forallType(parameterCount, type2);\n  }\n\n  @Override public Type substitute(TypeSystem typeSystem,\n      List<? extends Type> types) {\n    switch (type.op()) {\n    case DATA_TYPE:\n      final DataType dataType = (DataType) type;\n      Key key =\n          Keys.datatype(dataType.name, Keys.toKeys(types),\n              Maps.transformValues(dataType.typeConstructors,\n                  k -> k.substitute(types)));\n      return typeSystem.typeFor(key);\n\n    case FUNCTION_TYPE:\n      return type.substitute(typeSystem, types);\n\n    default:\n      throw new AssertionError(type.op() + \": \" + type);\n    }\n  }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "public final int parameterCount;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "int", "name": "parameterCount", "syntax_pass": true}, {"attribute_expression": "public final Type type;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "Type", "name": "type", "syntax_pass": true}]}, {"uris": "src/main/java/net/hydromatic/morel/type/Keys.java.Keys", "name": "Keys", "file_path": "src/main/java/net/hydromatic/morel/type/Keys.java", "superclasses": "", "methods": ["[]Keys()", "[Type.Key]name(String)", "[Type.Key]dummy()", "[Type.Key]ordinal(int)", "[List<Type.Key>]ordinals(int)", "[Type.Key]apply(Type.Key,Iterable<? extends Type.Key>)", "[Type.Key]record(SortedMap<String, ? extends Type.Key>)", "[Type.Key]record(Iterable<Map.Entry<String, ? extends Type.Key>>)", "[Type.Key]tuple(List<? extends Type.Key>)", "[Type.Key]progressiveRecord(SortedMap<String, ? extends Type.Key>)", "[Type.Key]fn(Type.Key,Type.Key)", "[Type.Key]list(Type.Key)", "[Type.Key]forall(Type,int)", "[DataTypeKey]datatype(String,List<? extends Type.Key>,SortedMap<String, Type.Key>)", "[SortedMap<String, Type.Key>]toKeys(SortedMap<String, ? extends Type>)", "[List<Type.Key>]toKeys(List<? extends Type>)", "[StringBuilder]describeRecordType(StringBuilder,int,int,SortedMap<String, Type.Key>,Op)", "[Type.Key]toProgressive(Type.Key)"], "method_uris": ["src/main/java/net/hydromatic/morel/type/Keys.java.Keys.[]Keys()", "src/main/java/net/hydromatic/morel/type/Keys.java.Keys.[Type.Key]name(String)", "src/main/java/net/hydromatic/morel/type/Keys.java.Keys.[Type.Key]dummy()", "src/main/java/net/hydromatic/morel/type/Keys.java.Keys.[Type.Key]ordinal(int)", "src/main/java/net/hydromatic/morel/type/Keys.java.Keys.[List<Type.Key>]ordinals(int)", "src/main/java/net/hydromatic/morel/type/Keys.java.Keys.[Type.Key]apply(Type.Key,Iterable<? extends Type.Key>)", "src/main/java/net/hydromatic/morel/type/Keys.java.Keys.[Type.Key]record(SortedMap<String, ? extends Type.Key>)", "src/main/java/net/hydromatic/morel/type/Keys.java.Keys.[Type.Key]record(Iterable<Map.Entry<String, ? extends Type.Key>>)", "src/main/java/net/hydromatic/morel/type/Keys.java.Keys.[Type.Key]tuple(List<? extends Type.Key>)", "src/main/java/net/hydromatic/morel/type/Keys.java.Keys.[Type.Key]progressiveRecord(SortedMap<String, ? extends Type.Key>)", "src/main/java/net/hydromatic/morel/type/Keys.java.Keys.[Type.Key]fn(Type.Key,Type.Key)", "src/main/java/net/hydromatic/morel/type/Keys.java.Keys.[Type.Key]list(Type.Key)", "src/main/java/net/hydromatic/morel/type/Keys.java.Keys.[Type.Key]forall(Type,int)", "src/main/java/net/hydromatic/morel/type/Keys.java.Keys.[DataTypeKey]datatype(String,List<? extends Type.Key>,SortedMap<String, Type.Key>)", "src/main/java/net/hydromatic/morel/type/Keys.java.Keys.[SortedMap<String, Type.Key>]toKeys(SortedMap<String, ? extends Type>)", "src/main/java/net/hydromatic/morel/type/Keys.java.Keys.[List<Type.Key>]toKeys(List<? extends Type>)", "src/main/java/net/hydromatic/morel/type/Keys.java.Keys.[StringBuilder]describeRecordType(StringBuilder,int,int,SortedMap<String, Type.Key>,Op)", "src/main/java/net/hydromatic/morel/type/Keys.java.Keys.[Type.Key]toProgressive(Type.Key)"], "overrides": null, "attributes": [{"original_string": "  private static class NameKey extends Type.Key {\n    private final String name;\n\n    NameKey(String name) {\n      super(name.isEmpty() ? Op.DUMMY_TYPE : Op.DATA_TYPE);\n      this.name = requireNonNull(name);\n    }\n\n    @Override public String toString() {\n      return name;\n    }\n\n    @Override public StringBuilder describe(StringBuilder buf, int left,\n        int right) {\n      return buf.append(name);\n    }\n\n    @Override public int hashCode() {\n      return name.hashCode();\n    }\n\n    @Override public boolean equals(Object obj) {\n      return obj == this\n          || obj instanceof NameKey\n          && ((NameKey) obj).name.equals(name);\n    }\n\n    public Type toType(TypeSystem typeSystem) {\n      if (name.isEmpty()) {\n        return DummyType.INSTANCE;\n      }\n      return typeSystem.lookup(name);\n    }\n  }", "definition": "  private static class NameKey extends Type.Key", "class_docstring": " Key that identifies a type by name.", "name": "NameKey", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "fields": [{"attribute_expression": "private final String name;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "name", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    NameKey(String name) {\n      super(name.isEmpty() ? Op.DUMMY_TYPE : Op.DATA_TYPE);\n      this.name = requireNonNull(name);\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "NameKey", "params": [{"name": "name", "type": "String"}], "body": "                         {\n      super(name.isEmpty() ? Op.DUMMY_TYPE : Op.DATA_TYPE);\n      this.name = requireNonNull(name);\n    }", "signature": "NameKey(String name)"}, {"syntax_pass": true, "original_string": "    @Override public String toString() {\n      return name;\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "toString", "params": [], "body": "                                       {\n      return name;\n    }", "signature": "@Override public String toString()"}, {"syntax_pass": true, "original_string": "    @Override public StringBuilder describe(StringBuilder buf, int left,\n        int right) {\n      return buf.append(name);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "StringBuilder", "classes": []}, "name": "describe", "params": [{"name": "buf", "type": "StringBuilder"}, {"name": "left", "type": "int"}, {"name": "right", "type": "int"}], "body": "                   {\n      return buf.append(name);\n    }", "signature": "@Override public StringBuilder describe(StringBuilder buf, int left,\n        int right)"}, {"syntax_pass": true, "original_string": "    @Override public int hashCode() {\n      return name.hashCode();\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "hashCode", "params": [], "body": "                                    {\n      return name.hashCode();\n    }", "signature": "@Override public int hashCode()"}, {"syntax_pass": true, "original_string": "    @Override public boolean equals(Object obj) {\n      return obj == this\n          || obj instanceof NameKey\n          && ((NameKey) obj).name.equals(name);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "equals", "params": [{"name": "obj", "type": "Object"}], "body": "                                                {\n      return obj == this\n          || obj instanceof NameKey\n          && ((NameKey) obj).name.equals(name);\n    }", "signature": "@Override public boolean equals(Object obj)"}, {"syntax_pass": true, "original_string": "    public Type toType(TypeSystem typeSystem) {\n      if (name.isEmpty()) {\n        return DummyType.INSTANCE;\n      }\n      return typeSystem.lookup(name);\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Type", "classes": []}, "name": "toType", "params": [{"name": "typeSystem", "type": "TypeSystem"}], "body": "                                              {\n      if (name.isEmpty()) {\n        return DummyType.INSTANCE;\n      }\n      return typeSystem.lookup(name);\n    }", "signature": "public Type toType(TypeSystem typeSystem)"}]}, {"original_string": "  private static class OrdinalKey extends Type.Key {\n    final int ordinal;\n\n    OrdinalKey(int ordinal) {\n      super(Op.TY_VAR);\n      this.ordinal = ordinal;\n    }\n\n    @Override public String toString() {\n      return TypeVar.name(ordinal);\n    }\n\n    @Override public StringBuilder describe(StringBuilder buf, int left,\n        int right) {\n      return buf.append(TypeVar.name(ordinal));\n    }\n\n    @Override public int hashCode() {\n      return ordinal;\n    }\n\n    @Override public boolean equals(Object obj) {\n      return obj == this\n          || obj instanceof OrdinalKey\n          && ((OrdinalKey) obj).ordinal == ordinal;\n    }\n\n    @Override public Type.Key substitute(List<? extends Type> types) {\n      return types.get(ordinal).key();\n    }\n\n    public Type toType(TypeSystem typeSystem) {\n      return new TypeVar(ordinal);\n    }\n  }", "definition": "  private static class OrdinalKey extends Type.Key", "class_docstring": " Key that identifies a type by ordinal.", "name": "OrdinalKey", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "fields": [{"attribute_expression": "final int ordinal;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "int", "name": "ordinal", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    OrdinalKey(int ordinal) {\n      super(Op.TY_VAR);\n      this.ordinal = ordinal;\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "OrdinalKey", "params": [{"name": "ordinal", "type": "int"}], "body": "                            {\n      super(Op.TY_VAR);\n      this.ordinal = ordinal;\n    }", "signature": "OrdinalKey(int ordinal)"}, {"syntax_pass": true, "original_string": "    @Override public String toString() {\n      return TypeVar.name(ordinal);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "toString", "params": [], "body": "                                       {\n      return TypeVar.name(ordinal);\n    }", "signature": "@Override public String toString()"}, {"syntax_pass": true, "original_string": "    @Override public StringBuilder describe(StringBuilder buf, int left,\n        int right) {\n      return buf.append(TypeVar.name(ordinal));\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "StringBuilder", "classes": []}, "name": "describe", "params": [{"name": "buf", "type": "StringBuilder"}, {"name": "left", "type": "int"}, {"name": "right", "type": "int"}], "body": "                   {\n      return buf.append(TypeVar.name(ordinal));\n    }", "signature": "@Override public StringBuilder describe(StringBuilder buf, int left,\n        int right)"}, {"syntax_pass": true, "original_string": "    @Override public int hashCode() {\n      return ordinal;\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "hashCode", "params": [], "body": "                                    {\n      return ordinal;\n    }", "signature": "@Override public int hashCode()"}, {"syntax_pass": true, "original_string": "    @Override public boolean equals(Object obj) {\n      return obj == this\n          || obj instanceof OrdinalKey\n          && ((OrdinalKey) obj).ordinal == ordinal;\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "equals", "params": [{"name": "obj", "type": "Object"}], "body": "                                                {\n      return obj == this\n          || obj instanceof OrdinalKey\n          && ((OrdinalKey) obj).ordinal == ordinal;\n    }", "signature": "@Override public boolean equals(Object obj)"}, {"syntax_pass": true, "original_string": "    @Override public Type.Key substitute(List<? extends Type> types) {\n      return types.get(ordinal).key();\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Type.Key", "classes": []}, "name": "substitute", "params": [{"name": "types", "type": "List<? extends Type>"}], "body": "                                                                     {\n      return types.get(ordinal).key();\n    }", "signature": "@Override public Type.Key substitute(List<? extends Type> types)"}, {"syntax_pass": true, "original_string": "    public Type toType(TypeSystem typeSystem) {\n      return new TypeVar(ordinal);\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Type", "classes": []}, "name": "toType", "params": [{"name": "typeSystem", "type": "TypeSystem"}], "body": "                                              {\n      return new TypeVar(ordinal);\n    }", "signature": "public Type toType(TypeSystem typeSystem)"}]}, {"original_string": "  private static class ApplyKey extends Type.Key {\n    final Type.Key key;\n    final ImmutableList<Type.Key> args;\n\n    ApplyKey(Type.Key key, List<Type.Key> args) {\n      super(Op.APPLY_TYPE);\n      this.key = requireNonNull(key);\n      this.args = ImmutableList.copyOf(args);\n    }\n\n    @Override public StringBuilder describe(StringBuilder buf, int left,\n        int right) {\n      if (!args.isEmpty()) {\n        TypeSystem.unparseList(buf, Op.COMMA, left, Op.APPLY.left, args);\n        buf.append(Op.APPLY.padded);\n      }\n      return buf.append(key);\n    }\n\n    @Override public int hashCode() {\n      return hash(key, args);\n    }\n\n    @Override public boolean equals(Object obj) {\n      return obj == this\n          || obj instanceof ApplyKey\n          && ((ApplyKey) obj).key.equals(key)\n          && ((ApplyKey) obj).args.equals(args);\n    }\n\n    @Override public Type toType(TypeSystem typeSystem) {\n      final Type type = key.toType(typeSystem);\n      if (type instanceof ForallType) {\n        return type.substitute(typeSystem, typeSystem.typesFor(args));\n      }\n      throw new AssertionError();\n    }\n\n    @Override public Type.Key copy(UnaryOperator<Type.Key> transform) {\n      return new ApplyKey(key.copy(transform),\n          transformEager(args, arg -> arg.copy(transform)));\n    }\n  }", "definition": "  private static class ApplyKey extends Type.Key", "class_docstring": " Key of a type that applies a parameterized type to specific type\narguments.", "name": "ApplyKey", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "fields": [{"attribute_expression": "final Type.Key key;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "Type.Key", "name": "key", "syntax_pass": true}, {"attribute_expression": "final ImmutableList<Type.Key> args;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "ImmutableList<Type.Key>", "name": "args", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    ApplyKey(Type.Key key, List<Type.Key> args) {\n      super(Op.APPLY_TYPE);\n      this.key = requireNonNull(key);\n      this.args = ImmutableList.copyOf(args);\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "ApplyKey", "params": [{"name": "key", "type": "Type.Key"}, {"name": "args", "type": "List<Type.Key>"}], "body": "                                                {\n      super(Op.APPLY_TYPE);\n      this.key = requireNonNull(key);\n      this.args = ImmutableList.copyOf(args);\n    }", "signature": "ApplyKey(Type.Key key, List<Type.Key> args)"}, {"syntax_pass": true, "original_string": "    @Override public StringBuilder describe(StringBuilder buf, int left,\n        int right) {\n      if (!args.isEmpty()) {\n        TypeSystem.unparseList(buf, Op.COMMA, left, Op.APPLY.left, args);\n        buf.append(Op.APPLY.padded);\n      }\n      return buf.append(key);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "StringBuilder", "classes": []}, "name": "describe", "params": [{"name": "buf", "type": "StringBuilder"}, {"name": "left", "type": "int"}, {"name": "right", "type": "int"}], "body": "                   {\n      if (!args.isEmpty()) {\n        TypeSystem.unparseList(buf, Op.COMMA, left, Op.APPLY.left, args);\n        buf.append(Op.APPLY.padded);\n      }\n      return buf.append(key);\n    }", "signature": "@Override public StringBuilder describe(StringBuilder buf, int left,\n        int right)"}, {"syntax_pass": true, "original_string": "    @Override public int hashCode() {\n      return hash(key, args);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "hashCode", "params": [], "body": "                                    {\n      return hash(key, args);\n    }", "signature": "@Override public int hashCode()"}, {"syntax_pass": true, "original_string": "    @Override public boolean equals(Object obj) {\n      return obj == this\n          || obj instanceof ApplyKey\n          && ((ApplyKey) obj).key.equals(key)\n          && ((ApplyKey) obj).args.equals(args);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "equals", "params": [{"name": "obj", "type": "Object"}], "body": "                                                {\n      return obj == this\n          || obj instanceof ApplyKey\n          && ((ApplyKey) obj).key.equals(key)\n          && ((ApplyKey) obj).args.equals(args);\n    }", "signature": "@Override public boolean equals(Object obj)"}, {"syntax_pass": true, "original_string": "    @Override public Type toType(TypeSystem typeSystem) {\n      final Type type = key.toType(typeSystem);\n      if (type instanceof ForallType) {\n        return type.substitute(typeSystem, typeSystem.typesFor(args));\n      }\n      throw new AssertionError();\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Type", "classes": []}, "name": "toType", "params": [{"name": "typeSystem", "type": "TypeSystem"}], "body": "                                                        {\n      final Type type = key.toType(typeSystem);\n      if (type instanceof ForallType) {\n        return type.substitute(typeSystem, typeSystem.typesFor(args));\n      }\n      throw new AssertionError();\n    }", "signature": "@Override public Type toType(TypeSystem typeSystem)"}, {"syntax_pass": true, "original_string": "    @Override public Type.Key copy(UnaryOperator<Type.Key> transform) {\n      return new ApplyKey(key.copy(transform),\n          transformEager(args, arg -> arg.copy(transform)));\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Type.Key", "classes": []}, "name": "copy", "params": [{"name": "transform", "type": "UnaryOperator<Type.Key>"}], "body": "                                                                      {\n      return new ApplyKey(key.copy(transform),\n          transformEager(args, arg -> arg.copy(transform)));\n    }", "signature": "@Override public Type.Key copy(UnaryOperator<Type.Key> transform)"}]}, {"original_string": "  private static class OpKey extends Type.Key {\n    final ImmutableList<Type.Key> args;\n\n    OpKey(Op op, List<Type.Key> args) {\n      super(op);\n      this.args = ImmutableList.copyOf(args);\n    }\n\n    @Override public StringBuilder describe(StringBuilder buf, int left,\n        int right) {\n      switch (op) {\n      case LIST:\n        return TypeSystem.unparse(buf, args.get(0), 0, Op.LIST.right)\n            .append(\" list\");\n      default:\n        return TypeSystem.unparseList(buf, op, left, right, args);\n      }\n    }\n\n    @Override public int hashCode() {\n      return hash(op, args);\n    }\n\n    @Override public boolean equals(Object obj) {\n      return obj == this\n          || obj instanceof OpKey\n          && ((OpKey) obj).op.equals(op)\n          && ((OpKey) obj).args.equals(args);\n    }\n\n    public Type toType(TypeSystem typeSystem) {\n      switch (op) {\n      case FN:\n        assert args.size() == 2;\n        return new FnType(typeSystem.typeFor(args.get(0)),\n            typeSystem.typeFor(args.get(1)));\n      case LIST:\n        assert args.size() == 1;\n        return new ListType(typeSystem.typeFor(args.get(0)));\n      default:\n        throw new AssertionError(op);\n      }\n    }\n\n    @Override public Type.Key copy(UnaryOperator<Type.Key> transform) {\n      return new OpKey(op, transform(args, arg -> arg.copy(transform)));\n    }\n  }", "definition": "  private static class OpKey extends Type.Key", "class_docstring": " Key of a type that applies a built-in type constructor to specific type\narguments.", "name": "OpKey", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "fields": [{"attribute_expression": "final ImmutableList<Type.Key> args;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "ImmutableList<Type.Key>", "name": "args", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    OpKey(Op op, List<Type.Key> args) {\n      super(op);\n      this.args = ImmutableList.copyOf(args);\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "OpKey", "params": [{"name": "op", "type": "Op"}, {"name": "args", "type": "List<Type.Key>"}], "body": "                                      {\n      super(op);\n      this.args = ImmutableList.copyOf(args);\n    }", "signature": "OpKey(Op op, List<Type.Key> args)"}, {"syntax_pass": true, "original_string": "    @Override public StringBuilder describe(StringBuilder buf, int left,\n        int right) {\n      switch (op) {\n      case LIST:\n        return TypeSystem.unparse(buf, args.get(0), 0, Op.LIST.right)\n            .append(\" list\");\n      default:\n        return TypeSystem.unparseList(buf, op, left, right, args);\n      }\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "StringBuilder", "classes": []}, "name": "describe", "params": [{"name": "buf", "type": "StringBuilder"}, {"name": "left", "type": "int"}, {"name": "right", "type": "int"}], "body": "                   {\n      switch (op) {\n      case LIST:\n        return TypeSystem.unparse(buf, args.get(0), 0, Op.LIST.right)\n            .append(\" list\");\n      default:\n        return TypeSystem.unparseList(buf, op, left, right, args);\n      }\n    }", "signature": "@Override public StringBuilder describe(StringBuilder buf, int left,\n        int right)"}, {"syntax_pass": true, "original_string": "    @Override public int hashCode() {\n      return hash(op, args);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "hashCode", "params": [], "body": "                                    {\n      return hash(op, args);\n    }", "signature": "@Override public int hashCode()"}, {"syntax_pass": true, "original_string": "    @Override public boolean equals(Object obj) {\n      return obj == this\n          || obj instanceof OpKey\n          && ((OpKey) obj).op.equals(op)\n          && ((OpKey) obj).args.equals(args);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "equals", "params": [{"name": "obj", "type": "Object"}], "body": "                                                {\n      return obj == this\n          || obj instanceof OpKey\n          && ((OpKey) obj).op.equals(op)\n          && ((OpKey) obj).args.equals(args);\n    }", "signature": "@Override public boolean equals(Object obj)"}, {"syntax_pass": true, "original_string": "    public Type toType(TypeSystem typeSystem) {\n      switch (op) {\n      case FN:\n        assert args.size() == 2;\n        return new FnType(typeSystem.typeFor(args.get(0)),\n            typeSystem.typeFor(args.get(1)));\n      case LIST:\n        assert args.size() == 1;\n        return new ListType(typeSystem.typeFor(args.get(0)));\n      default:\n        throw new AssertionError(op);\n      }\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Type", "classes": []}, "name": "toType", "params": [{"name": "typeSystem", "type": "TypeSystem"}], "body": "                                              {\n      switch (op) {\n      case FN:\n        assert args.size() == 2;\n        return new FnType(typeSystem.typeFor(args.get(0)),\n            typeSystem.typeFor(args.get(1)));\n      case LIST:\n        assert args.size() == 1;\n        return new ListType(typeSystem.typeFor(args.get(0)));\n      default:\n        throw new AssertionError(op);\n      }\n    }", "signature": "public Type toType(TypeSystem typeSystem)"}, {"syntax_pass": true, "original_string": "    @Override public Type.Key copy(UnaryOperator<Type.Key> transform) {\n      return new OpKey(op, transform(args, arg -> arg.copy(transform)));\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Type.Key", "classes": []}, "name": "copy", "params": [{"name": "transform", "type": "UnaryOperator<Type.Key>"}], "body": "                                                                      {\n      return new OpKey(op, transform(args, arg -> arg.copy(transform)));\n    }", "signature": "@Override public Type.Key copy(UnaryOperator<Type.Key> transform)"}]}, {"original_string": "  private static class ForallKey extends Type.Key {\n    final Type type;\n    final int parameterCount;\n\n    ForallKey(Type type, int parameterCount) {\n      super(Op.FORALL_TYPE);\n      this.type = requireNonNull(type);\n      this.parameterCount = parameterCount;\n      checkArgument(parameterCount >= 0);\n    }\n\n    @Override public int hashCode() {\n      return hash(type, parameterCount);\n    }\n\n    @Override public boolean equals(Object obj) {\n      return obj == this\n          || obj instanceof ForallKey\n          && ((ForallKey) obj).type.equals(type)\n          && ((ForallKey) obj).parameterCount == parameterCount;\n    }\n\n    @Override public StringBuilder describe(StringBuilder buf, int left,\n        int right) {\n      buf.append(\"forall\");\n      for (int i = 0; i < parameterCount; i++) {\n        buf.append(' ').append(TypeVar.name(i));\n      }\n      buf.append(\". \");\n      return TypeSystem.unparse(buf, type.key(), 0, 0);\n    }\n\n    public Type toType(TypeSystem typeSystem) {\n      return new ForallType(parameterCount, type);\n    }\n  }", "definition": "  private static class ForallKey extends Type.Key", "class_docstring": " Key of a forall type.", "name": "ForallKey", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "fields": [{"attribute_expression": "final Type type;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "Type", "name": "type", "syntax_pass": true}, {"attribute_expression": "final int parameterCount;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "int", "name": "parameterCount", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    ForallKey(Type type, int parameterCount) {\n      super(Op.FORALL_TYPE);\n      this.type = requireNonNull(type);\n      this.parameterCount = parameterCount;\n      checkArgument(parameterCount >= 0);\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "ForallKey", "params": [{"name": "type", "type": "Type"}, {"name": "parameterCount", "type": "int"}], "body": "                                             {\n      super(Op.FORALL_TYPE);\n      this.type = requireNonNull(type);\n      this.parameterCount = parameterCount;\n      checkArgument(parameterCount >= 0);\n    }", "signature": "ForallKey(Type type, int parameterCount)"}, {"syntax_pass": true, "original_string": "    @Override public int hashCode() {\n      return hash(type, parameterCount);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "hashCode", "params": [], "body": "                                    {\n      return hash(type, parameterCount);\n    }", "signature": "@Override public int hashCode()"}, {"syntax_pass": true, "original_string": "    @Override public boolean equals(Object obj) {\n      return obj == this\n          || obj instanceof ForallKey\n          && ((ForallKey) obj).type.equals(type)\n          && ((ForallKey) obj).parameterCount == parameterCount;\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "equals", "params": [{"name": "obj", "type": "Object"}], "body": "                                                {\n      return obj == this\n          || obj instanceof ForallKey\n          && ((ForallKey) obj).type.equals(type)\n          && ((ForallKey) obj).parameterCount == parameterCount;\n    }", "signature": "@Override public boolean equals(Object obj)"}, {"syntax_pass": true, "original_string": "    @Override public StringBuilder describe(StringBuilder buf, int left,\n        int right) {\n      buf.append(\"forall\");\n      for (int i = 0; i < parameterCount; i++) {\n        buf.append(' ').append(TypeVar.name(i));\n      }\n      buf.append(\". \");\n      return TypeSystem.unparse(buf, type.key(), 0, 0);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "StringBuilder", "classes": []}, "name": "describe", "params": [{"name": "buf", "type": "StringBuilder"}, {"name": "left", "type": "int"}, {"name": "right", "type": "int"}], "body": "                   {\n      buf.append(\"forall\");\n      for (int i = 0; i < parameterCount; i++) {\n        buf.append(' ').append(TypeVar.name(i));\n      }\n      buf.append(\". \");\n      return TypeSystem.unparse(buf, type.key(), 0, 0);\n    }", "signature": "@Override public StringBuilder describe(StringBuilder buf, int left,\n        int right)"}, {"syntax_pass": true, "original_string": "    public Type toType(TypeSystem typeSystem) {\n      return new ForallType(parameterCount, type);\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Type", "classes": []}, "name": "toType", "params": [{"name": "typeSystem", "type": "TypeSystem"}], "body": "                                              {\n      return new ForallType(parameterCount, type);\n    }", "signature": "public Type toType(TypeSystem typeSystem)"}]}, {"original_string": "  private static class RecordKey extends Type.Key {\n    final ImmutableSortedMap<String, Type.Key> argNameTypes;\n\n    RecordKey(ImmutableSortedMap<String, Type.Key> argNameTypes) {\n      super(TypeSystem.areContiguousIntegers(argNameTypes.keySet())\n          ? Op.TUPLE_TYPE\n          : Op.RECORD_TYPE);\n      this.argNameTypes = requireNonNull(argNameTypes);\n      checkArgument(argNameTypes.comparator() == RecordType.ORDERING);\n    }\n\n    @Override public Type.Key copy(UnaryOperator<Type.Key> transform) {\n      return record(Maps.transformValues(argNameTypes, transform::apply));\n    }\n\n    @Override public StringBuilder describe(StringBuilder buf, int left,\n        int right) {\n      return describeRecordType(buf, left, right, argNameTypes, op);\n    }\n\n    @Override public int hashCode() {\n      return argNameTypes.hashCode();\n    }\n\n    @Override public boolean equals(Object obj) {\n      return obj == this\n          || obj instanceof RecordKey\n          && ((RecordKey) obj).argNameTypes.equals(argNameTypes);\n    }\n\n    public Type toType(TypeSystem typeSystem) {\n      switch (argNameTypes.size()) {\n      case 0:\n        return PrimitiveType.UNIT;\n      default:\n        if (op == Op.TUPLE_TYPE) {\n          return new TupleType(typeSystem.typesFor(argNameTypes.values()));\n        }\n        // fall through\n      case 1:\n        return new RecordType(typeSystem.typesFor(argNameTypes));\n      }\n    }\n  }", "definition": "  private static class RecordKey extends Type.Key", "class_docstring": " Key of a record type.", "name": "RecordKey", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "fields": [{"attribute_expression": "final ImmutableSortedMap<String, Type.Key> argNameTypes;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "ImmutableSortedMap<String, Type.Key>", "name": "argNameTypes", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    RecordKey(ImmutableSortedMap<String, Type.Key> argNameTypes) {\n      super(TypeSystem.areContiguousIntegers(argNameTypes.keySet())\n          ? Op.TUPLE_TYPE\n          : Op.RECORD_TYPE);\n      this.argNameTypes = requireNonNull(argNameTypes);\n      checkArgument(argNameTypes.comparator() == RecordType.ORDERING);\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "RecordKey", "params": [{"name": "argNameTypes", "type": "ImmutableSortedMap<String, Type.Key>"}], "body": "                                                                 {\n      super(TypeSystem.areContiguousIntegers(argNameTypes.keySet())\n          ? Op.TUPLE_TYPE\n          : Op.RECORD_TYPE);\n      this.argNameTypes = requireNonNull(argNameTypes);\n      checkArgument(argNameTypes.comparator() == RecordType.ORDERING);\n    }", "signature": "RecordKey(ImmutableSortedMap<String, Type.Key> argNameTypes)"}, {"syntax_pass": true, "original_string": "    @Override public Type.Key copy(UnaryOperator<Type.Key> transform) {\n      return record(Maps.transformValues(argNameTypes, transform::apply));\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Type.Key", "classes": []}, "name": "copy", "params": [{"name": "transform", "type": "UnaryOperator<Type.Key>"}], "body": "                                                                      {\n      return record(Maps.transformValues(argNameTypes, transform::apply));\n    }", "signature": "@Override public Type.Key copy(UnaryOperator<Type.Key> transform)"}, {"syntax_pass": true, "original_string": "    @Override public StringBuilder describe(StringBuilder buf, int left,\n        int right) {\n      return describeRecordType(buf, left, right, argNameTypes, op);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "StringBuilder", "classes": []}, "name": "describe", "params": [{"name": "buf", "type": "StringBuilder"}, {"name": "left", "type": "int"}, {"name": "right", "type": "int"}], "body": "                   {\n      return describeRecordType(buf, left, right, argNameTypes, op);\n    }", "signature": "@Override public StringBuilder describe(StringBuilder buf, int left,\n        int right)"}, {"syntax_pass": true, "original_string": "    @Override public int hashCode() {\n      return argNameTypes.hashCode();\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "hashCode", "params": [], "body": "                                    {\n      return argNameTypes.hashCode();\n    }", "signature": "@Override public int hashCode()"}, {"syntax_pass": true, "original_string": "    @Override public boolean equals(Object obj) {\n      return obj == this\n          || obj instanceof RecordKey\n          && ((RecordKey) obj).argNameTypes.equals(argNameTypes);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "equals", "params": [{"name": "obj", "type": "Object"}], "body": "                                                {\n      return obj == this\n          || obj instanceof RecordKey\n          && ((RecordKey) obj).argNameTypes.equals(argNameTypes);\n    }", "signature": "@Override public boolean equals(Object obj)"}, {"syntax_pass": true, "original_string": "    public Type toType(TypeSystem typeSystem) {\n      switch (argNameTypes.size()) {\n      case 0:\n        return PrimitiveType.UNIT;\n      default:\n        if (op == Op.TUPLE_TYPE) {\n          return new TupleType(typeSystem.typesFor(argNameTypes.values()));\n        }\n        // fall through\n      case 1:\n        return new RecordType(typeSystem.typesFor(argNameTypes));\n      }\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Type", "classes": []}, "name": "toType", "params": [{"name": "typeSystem", "type": "TypeSystem"}], "body": "                                              {\n      switch (argNameTypes.size()) {\n      case 0:\n        return PrimitiveType.UNIT;\n      default:\n        if (op == Op.TUPLE_TYPE) {\n          return new TupleType(typeSystem.typesFor(argNameTypes.values()));\n        }\n        // fall through\n      case 1:\n        return new RecordType(typeSystem.typesFor(argNameTypes));\n      }\n    }", "signature": "public Type toType(TypeSystem typeSystem)"}]}, {"original_string": "  private static class ProgressiveRecordKey extends Type.Key {\n    final ImmutableSortedMap<String, Type.Key> argNameTypes;\n\n    ProgressiveRecordKey(ImmutableSortedMap<String, Type.Key> argNameTypes) {\n      super(Op.PROGRESSIVE_RECORD_TYPE);\n      this.argNameTypes = requireNonNull(argNameTypes);\n    }\n\n    @Override public Type.Key copy(UnaryOperator<Type.Key> transform) {\n      return progressiveRecord(\n          Maps.transformValues(argNameTypes, transform::apply));\n    }\n\n    @Override public StringBuilder describe(StringBuilder buf, int left,\n        int right) {\n      return describeRecordType(buf, left, right, argNameTypes, op);\n    }\n\n    @Override public int hashCode() {\n      return argNameTypes.hashCode();\n    }\n\n    @Override public boolean equals(Object obj) {\n      return obj == this\n          || obj instanceof ProgressiveRecordKey\n          && ((ProgressiveRecordKey) obj).argNameTypes.equals(argNameTypes);\n    }\n\n    @Override public Type toType(TypeSystem typeSystem) {\n      return new ProgressiveRecordType(typeSystem.typesFor(this.argNameTypes));\n    }\n  }", "definition": "  private static class ProgressiveRecordKey extends Type.Key", "class_docstring": "", "name": "ProgressiveRecordKey", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "fields": [{"attribute_expression": "final ImmutableSortedMap<String, Type.Key> argNameTypes;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "ImmutableSortedMap<String, Type.Key>", "name": "argNameTypes", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    ProgressiveRecordKey(ImmutableSortedMap<String, Type.Key> argNameTypes) {\n      super(Op.PROGRESSIVE_RECORD_TYPE);\n      this.argNameTypes = requireNonNull(argNameTypes);\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "ProgressiveRecordKey", "params": [{"name": "argNameTypes", "type": "ImmutableSortedMap<String, Type.Key>"}], "body": "                                                                            {\n      super(Op.PROGRESSIVE_RECORD_TYPE);\n      this.argNameTypes = requireNonNull(argNameTypes);\n    }", "signature": "ProgressiveRecordKey(ImmutableSortedMap<String, Type.Key> argNameTypes)"}, {"syntax_pass": true, "original_string": "    @Override public Type.Key copy(UnaryOperator<Type.Key> transform) {\n      return progressiveRecord(\n          Maps.transformValues(argNameTypes, transform::apply));\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Type.Key", "classes": []}, "name": "copy", "params": [{"name": "transform", "type": "UnaryOperator<Type.Key>"}], "body": "                                                                      {\n      return progressiveRecord(\n          Maps.transformValues(argNameTypes, transform::apply));\n    }", "signature": "@Override public Type.Key copy(UnaryOperator<Type.Key> transform)"}, {"syntax_pass": true, "original_string": "    @Override public StringBuilder describe(StringBuilder buf, int left,\n        int right) {\n      return describeRecordType(buf, left, right, argNameTypes, op);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "StringBuilder", "classes": []}, "name": "describe", "params": [{"name": "buf", "type": "StringBuilder"}, {"name": "left", "type": "int"}, {"name": "right", "type": "int"}], "body": "                   {\n      return describeRecordType(buf, left, right, argNameTypes, op);\n    }", "signature": "@Override public StringBuilder describe(StringBuilder buf, int left,\n        int right)"}, {"syntax_pass": true, "original_string": "    @Override public int hashCode() {\n      return argNameTypes.hashCode();\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "hashCode", "params": [], "body": "                                    {\n      return argNameTypes.hashCode();\n    }", "signature": "@Override public int hashCode()"}, {"syntax_pass": true, "original_string": "    @Override public boolean equals(Object obj) {\n      return obj == this\n          || obj instanceof ProgressiveRecordKey\n          && ((ProgressiveRecordKey) obj).argNameTypes.equals(argNameTypes);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "equals", "params": [{"name": "obj", "type": "Object"}], "body": "                                                {\n      return obj == this\n          || obj instanceof ProgressiveRecordKey\n          && ((ProgressiveRecordKey) obj).argNameTypes.equals(argNameTypes);\n    }", "signature": "@Override public boolean equals(Object obj)"}, {"syntax_pass": true, "original_string": "    @Override public Type toType(TypeSystem typeSystem) {\n      return new ProgressiveRecordType(typeSystem.typesFor(this.argNameTypes));\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Type", "classes": []}, "name": "toType", "params": [{"name": "typeSystem", "type": "TypeSystem"}], "body": "                                                        {\n      return new ProgressiveRecordType(typeSystem.typesFor(this.argNameTypes));\n    }", "signature": "@Override public Type toType(TypeSystem typeSystem)"}]}, {"original_string": "  public static class DataTypeKey extends Type.Key {\n    /** Ideally, a datatype would not have a name, just a list of named type\n     * constructors, and the name would be associated later. When that happens,\n     * we can remove the {@code name} field from this key. */\n    private final String name;\n    private final List<? extends Type.Key> arguments;\n    private final SortedMap<String, Type.Key> typeConstructors;\n\n    DataTypeKey(String name, List<? extends Type.Key> arguments,\n        SortedMap<String, Type.Key> typeConstructors) {\n      super(Op.DATA_TYPE);\n      this.name = requireNonNull(name);\n      this.arguments = ImmutableList.copyOf(arguments);\n      this.typeConstructors = ImmutableSortedMap.copyOfSorted(typeConstructors);\n    }\n\n    @Override public int hashCode() {\n      return hash(name, arguments, typeConstructors);\n    }\n\n    @Override public boolean equals(Object obj) {\n      return obj == this\n          || obj instanceof DataTypeKey\n          && ((DataTypeKey) obj).name.equals(name)\n          && ((DataTypeKey) obj).arguments.equals(arguments)\n          && ((DataTypeKey) obj).typeConstructors.equals(typeConstructors);\n    }\n\n    /** {@inheritDoc}\n     *\n     * <p>Prints the name of this datatype along with any type arguments.\n     * Examples:\n     *\n     * <ul>\n     *   <li>{@code order}\n     *   <li>{@code 'a option}\n     *   <li>{@code (int * int) option}\n     *   <li>{@code bool option option}\n     *   <li>{@code ('a,'b) tree}\n     * </ul>\n     *\n     * @see ParameterizedType#computeMoniker(String, List)\n     */\n    @Override public StringBuilder describe(StringBuilder buf, int left,\n        int right) {\n      if (arguments.isEmpty()) {\n        return buf.append(name);\n      }\n      if (arguments.size() > 1) {\n        buf.append('(');\n      }\n      final int length = buf.length();\n      for (Type.Key key : arguments) {\n        if (buf.length() > length) {\n          buf.append(\",\");\n        }\n        if (key.op == Op.TUPLE_TYPE) {\n          buf.append('(');\n        }\n        key.describe(buf, 0, 0);\n        if (key.op == Op.TUPLE_TYPE) {\n          buf.append(')');\n        }\n      }\n      if (arguments.size() > 1) {\n        buf.append(')');\n      }\n      return buf.append(' ').append(name);\n    }\n\n    @Override public DataType toType(TypeSystem typeSystem) {\n      return typeSystem.dataType(name,\n          typeSystem.typesFor(arguments), typeConstructors);\n    }\n  }", "definition": "  public static class DataTypeKey extends Type.Key", "class_docstring": " Key that identifies a {@code datatype} scheme.", "name": "DataTypeKey", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [{"attribute_expression": "private final String name;", "docstring": " Ideally, a datatype would not have a name, just a list of named type\nconstructors, and the name would be associated later. When that happens,\nwe can remove the {@code name} field from this key.", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "name", "syntax_pass": true}, {"attribute_expression": "private final List<? extends Type.Key> arguments;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "List<? extends Type.Key>", "name": "arguments", "syntax_pass": true}, {"attribute_expression": "private final SortedMap<String, Type.Key> typeConstructors;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "SortedMap<String, Type.Key>", "name": "typeConstructors", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    DataTypeKey(String name, List<? extends Type.Key> arguments,\n        SortedMap<String, Type.Key> typeConstructors) {\n      super(Op.DATA_TYPE);\n      this.name = requireNonNull(name);\n      this.arguments = ImmutableList.copyOf(arguments);\n      this.typeConstructors = ImmutableSortedMap.copyOfSorted(typeConstructors);\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "DataTypeKey", "params": [{"name": "name", "type": "String"}, {"name": "arguments", "type": "List<? extends Type.Key>"}, {"name": "typeConstructors", "type": "SortedMap<String, Type.Key>"}], "body": "                                                      {\n      super(Op.DATA_TYPE);\n      this.name = requireNonNull(name);\n      this.arguments = ImmutableList.copyOf(arguments);\n      this.typeConstructors = ImmutableSortedMap.copyOfSorted(typeConstructors);\n    }", "signature": "DataTypeKey(String name, List<? extends Type.Key> arguments,\n        SortedMap<String, Type.Key> typeConstructors)"}, {"syntax_pass": true, "original_string": "    @Override public int hashCode() {\n      return hash(name, arguments, typeConstructors);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "hashCode", "params": [], "body": "                                    {\n      return hash(name, arguments, typeConstructors);\n    }", "signature": "@Override public int hashCode()"}, {"syntax_pass": true, "original_string": "    @Override public boolean equals(Object obj) {\n      return obj == this\n          || obj instanceof DataTypeKey\n          && ((DataTypeKey) obj).name.equals(name)\n          && ((DataTypeKey) obj).arguments.equals(arguments)\n          && ((DataTypeKey) obj).typeConstructors.equals(typeConstructors);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "equals", "params": [{"name": "obj", "type": "Object"}], "body": "                                                {\n      return obj == this\n          || obj instanceof DataTypeKey\n          && ((DataTypeKey) obj).name.equals(name)\n          && ((DataTypeKey) obj).arguments.equals(arguments)\n          && ((DataTypeKey) obj).typeConstructors.equals(typeConstructors);\n    }", "signature": "@Override public boolean equals(Object obj)"}, {"syntax_pass": true, "original_string": "    @Override public StringBuilder describe(StringBuilder buf, int left,\n        int right) {\n      if (arguments.isEmpty()) {\n        return buf.append(name);\n      }\n      if (arguments.size() > 1) {\n        buf.append('(');\n      }\n      final int length = buf.length();\n      for (Type.Key key : arguments) {\n        if (buf.length() > length) {\n          buf.append(\",\");\n        }\n        if (key.op == Op.TUPLE_TYPE) {\n          buf.append('(');\n        }\n        key.describe(buf, 0, 0);\n        if (key.op == Op.TUPLE_TYPE) {\n          buf.append(')');\n        }\n      }\n      if (arguments.size() > 1) {\n        buf.append(')');\n      }\n      return buf.append(' ').append(name);\n    }", "docstring": " {@inheritDoc}\n\n<p>Prints the name of this datatype along with any type arguments.\nExamples:\n\n<ul>\n  <li>{@code order}\n  <li>{@code 'a option}\n  <li>{@code (int * int) option}\n  <li>{@code bool option option}\n  <li>{@code ('a,'b) tree}\n</ul>\n\n@see ParameterizedType#computeMoniker(String, List)\n", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "StringBuilder", "classes": []}, "name": "describe", "params": [{"name": "buf", "type": "StringBuilder"}, {"name": "left", "type": "int"}, {"name": "right", "type": "int"}], "body": "                   {\n      if (arguments.isEmpty()) {\n        return buf.append(name);\n      }\n      if (arguments.size() > 1) {\n        buf.append('(');\n      }\n      final int length = buf.length();\n      for (Type.Key key : arguments) {\n        if (buf.length() > length) {\n          buf.append(\",\");\n        }\n        if (key.op == Op.TUPLE_TYPE) {\n          buf.append('(');\n        }\n        key.describe(buf, 0, 0);\n        if (key.op == Op.TUPLE_TYPE) {\n          buf.append(')');\n        }\n      }\n      if (arguments.size() > 1) {\n        buf.append(')');\n      }\n      return buf.append(' ').append(name);\n    }", "signature": "@Override public StringBuilder describe(StringBuilder buf, int left,\n        int right)"}, {"syntax_pass": true, "original_string": "    @Override public DataType toType(TypeSystem typeSystem) {\n      return typeSystem.dataType(name,\n          typeSystem.typesFor(arguments), typeConstructors);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "DataType", "classes": []}, "name": "toType", "params": [{"name": "typeSystem", "type": "TypeSystem"}], "body": "                                                            {\n      return typeSystem.dataType(name,\n          typeSystem.typesFor(arguments), typeConstructors);\n    }", "signature": "@Override public DataType toType(TypeSystem typeSystem)"}]}], "class_docstring": " Type keys.", "original_string": "public class Keys {\n  private Keys() {}\n\n  /** Returns a key that identifies types by name. */\n  public static Type.Key name(String name) {\n    return new NameKey(name);\n  }\n\n  /** Returns a key to the dummy type. */\n  public static Type.Key dummy() {\n    return name(\"\");\n  }\n\n  /** Returns a key that identifies types (especially\n   * {@link TypeVar type variables}) by ordinal. */\n  public static Type.Key ordinal(int ordinal) {\n    return new OrdinalKey(ordinal);\n  }\n\n  /** Returns a list of keys for type variables 0 through size - 1.\n   *\n   * @see TypeSystem#typeVariables(int) */\n  public static List<Type.Key> ordinals(int size) {\n    return new AbstractList<Type.Key>() {\n      public int size() {\n        return size;\n      }\n\n      public Type.Key get(int index) {\n        return new OrdinalKey(index);\n      }\n    };\n  }\n\n  /** Returns a key that applies a polymorphic type to arguments. */\n  public static Type.Key apply(Type.Key type,\n      Iterable<? extends Type.Key> args) {\n    return new ApplyKey(type, ImmutableList.copyOf(args));\n  }\n\n  /** Returns a key that identifies a {@link RecordType}\n   * (or a {@link TupleType} if the field names are ascending integers,\n   * or {@link PrimitiveType#UNIT unit} if the fields are empty). */\n  public static Type.Key record(SortedMap<String, ? extends Type.Key> argNameTypes) {\n    return new RecordKey(ImmutableSortedMap.copyOfSorted(argNameTypes));\n  }\n\n  /** As {@link #record(SortedMap)} but an {@link Iterable} argument. */\n  public static Type.Key record(\n      Iterable<Map.Entry<String, ? extends Type.Key>> argNameTypes) {\n    return record(ImmutableSortedMap.copyOf(argNameTypes, RecordType.ORDERING));\n  }\n\n  /** Returns a key that identifies a {@link TupleType}. */\n  public static Type.Key tuple(List<? extends Type.Key> args) {\n    return new RecordKey(TupleType.recordMap(args));\n  }\n\n  /** Returns a key that identifies a {@link ProgressiveRecordType}. */\n  public static Type.Key progressiveRecord(\n      SortedMap<String, ? extends Type.Key> argNameTypes) {\n    return new ProgressiveRecordKey(\n        ImmutableSortedMap.copyOfSorted(argNameTypes));\n  }\n\n  /** Returns a key that identifies a {@link FnType}. */\n  public static Type.Key fn(Type.Key paramType, Type.Key resultType) {\n    return new OpKey(Op.FN, ImmutableList.of(paramType, resultType));\n  }\n\n  /** Returns a key that identifies a {@link ListType}. */\n  public static Type.Key list(Type.Key elementType) {\n    return new OpKey(Op.LIST, ImmutableList.of(elementType));\n  }\n\n  /** Returns a key that identifies a {@link ForallType}. */\n  public static Type.Key forall(Type type, int parameterCount) {\n    return new ForallKey(type, parameterCount);\n  }\n\n  /** Returns a key that identifies a {@link DataType}. */\n  public static DataTypeKey datatype(String name,\n      List<? extends Type.Key> arguments,\n      SortedMap<String, Type.Key> typeConstructors) {\n    return new DataTypeKey(name, arguments, typeConstructors);\n  }\n\n  /** Converts a map of types to a map of keys. */\n  public static SortedMap<String, Type.Key> toKeys(\n      SortedMap<String, ? extends Type> nameTypes) {\n    final ImmutableSortedMap.Builder<String, Type.Key> keys =\n        ImmutableSortedMap.orderedBy(RecordType.ORDERING);\n    nameTypes.forEach((name, t) -> keys.put(name, t.key()));\n    return keys.build();\n  }\n\n  /** Converts a list of types to a list of keys. */\n  public static List<Type.Key> toKeys(List<? extends Type> types) {\n    return transformEager(types, Type::key);\n  }\n\n  /** Describes a record, progressive record, or tuple type. */\n  static StringBuilder describeRecordType(StringBuilder buf, int left,\n      int right, SortedMap<String, Type.Key> argNameTypes, Op op) {\n    switch (argNameTypes.size()) {\n    case 0:\n      return buf.append(op == Op.PROGRESSIVE_RECORD_TYPE ? \"{...}\" : \"()\");\n\n    default:\n      if (op == Op.TUPLE_TYPE) {\n        return TypeSystem.unparseList(buf, Op.TIMES, left, right,\n            argNameTypes.values());\n      }\n      // fall through\n    case 1:\n      buf.append('{');\n      int i = 0;\n      for (Map.Entry<String, Type.Key> entry : argNameTypes.entrySet()) {\n        String name = entry.getKey();\n        Type.Key typeKey = entry.getValue();\n        if (i++ > 0) {\n          buf.append(\", \");\n        }\n        appendId(buf, name)\n            .append(':')\n            .append(typeKey);\n      }\n      if (op == Op.PROGRESSIVE_RECORD_TYPE) {\n        if (i > 0) {\n          buf.append(\", \");\n        }\n        buf.append(\"...\");\n      }\n      return buf.append('}');\n    }\n  }\n\n  /** Converts a record key to a progressive record key,\n   * leaves other keys unchanged. */\n  public static Type.Key toProgressive(Type.Key key) {\n    if (key instanceof RecordKey) {\n      return progressiveRecord(\n          ((RecordKey) key).argNameTypes);\n    }\n    return key;\n  }\n\n  /** Key that identifies a type by name. */\n  private static class NameKey extends Type.Key {\n    private final String name;\n\n    NameKey(String name) {\n      super(name.isEmpty() ? Op.DUMMY_TYPE : Op.DATA_TYPE);\n      this.name = requireNonNull(name);\n    }\n\n    @Override public String toString() {\n      return name;\n    }\n\n    @Override public StringBuilder describe(StringBuilder buf, int left,\n        int right) {\n      return buf.append(name);\n    }\n\n    @Override public int hashCode() {\n      return name.hashCode();\n    }\n\n    @Override public boolean equals(Object obj) {\n      return obj == this\n          || obj instanceof NameKey\n          && ((NameKey) obj).name.equals(name);\n    }\n\n    public Type toType(TypeSystem typeSystem) {\n      if (name.isEmpty()) {\n        return DummyType.INSTANCE;\n      }\n      return typeSystem.lookup(name);\n    }\n  }\n\n  /** Key that identifies a type by ordinal. */\n  private static class OrdinalKey extends Type.Key {\n    final int ordinal;\n\n    OrdinalKey(int ordinal) {\n      super(Op.TY_VAR);\n      this.ordinal = ordinal;\n    }\n\n    @Override public String toString() {\n      return TypeVar.name(ordinal);\n    }\n\n    @Override public StringBuilder describe(StringBuilder buf, int left,\n        int right) {\n      return buf.append(TypeVar.name(ordinal));\n    }\n\n    @Override public int hashCode() {\n      return ordinal;\n    }\n\n    @Override public boolean equals(Object obj) {\n      return obj == this\n          || obj instanceof OrdinalKey\n          && ((OrdinalKey) obj).ordinal == ordinal;\n    }\n\n    @Override public Type.Key substitute(List<? extends Type> types) {\n      return types.get(ordinal).key();\n    }\n\n    public Type toType(TypeSystem typeSystem) {\n      return new TypeVar(ordinal);\n    }\n  }\n\n  /** Key of a type that applies a parameterized type to specific type\n   * arguments. */\n  private static class ApplyKey extends Type.Key {\n    final Type.Key key;\n    final ImmutableList<Type.Key> args;\n\n    ApplyKey(Type.Key key, List<Type.Key> args) {\n      super(Op.APPLY_TYPE);\n      this.key = requireNonNull(key);\n      this.args = ImmutableList.copyOf(args);\n    }\n\n    @Override public StringBuilder describe(StringBuilder buf, int left,\n        int right) {\n      if (!args.isEmpty()) {\n        TypeSystem.unparseList(buf, Op.COMMA, left, Op.APPLY.left, args);\n        buf.append(Op.APPLY.padded);\n      }\n      return buf.append(key);\n    }\n\n    @Override public int hashCode() {\n      return hash(key, args);\n    }\n\n    @Override public boolean equals(Object obj) {\n      return obj == this\n          || obj instanceof ApplyKey\n          && ((ApplyKey) obj).key.equals(key)\n          && ((ApplyKey) obj).args.equals(args);\n    }\n\n    @Override public Type toType(TypeSystem typeSystem) {\n      final Type type = key.toType(typeSystem);\n      if (type instanceof ForallType) {\n        return type.substitute(typeSystem, typeSystem.typesFor(args));\n      }\n      throw new AssertionError();\n    }\n\n    @Override public Type.Key copy(UnaryOperator<Type.Key> transform) {\n      return new ApplyKey(key.copy(transform),\n          transformEager(args, arg -> arg.copy(transform)));\n    }\n  }\n\n  /** Key of a type that applies a built-in type constructor to specific type\n   * arguments. */\n  private static class OpKey extends Type.Key {\n    final ImmutableList<Type.Key> args;\n\n    OpKey(Op op, List<Type.Key> args) {\n      super(op);\n      this.args = ImmutableList.copyOf(args);\n    }\n\n    @Override public StringBuilder describe(StringBuilder buf, int left,\n        int right) {\n      switch (op) {\n      case LIST:\n        return TypeSystem.unparse(buf, args.get(0), 0, Op.LIST.right)\n            .append(\" list\");\n      default:\n        return TypeSystem.unparseList(buf, op, left, right, args);\n      }\n    }\n\n    @Override public int hashCode() {\n      return hash(op, args);\n    }\n\n    @Override public boolean equals(Object obj) {\n      return obj == this\n          || obj instanceof OpKey\n          && ((OpKey) obj).op.equals(op)\n          && ((OpKey) obj).args.equals(args);\n    }\n\n    public Type toType(TypeSystem typeSystem) {\n      switch (op) {\n      case FN:\n        assert args.size() == 2;\n        return new FnType(typeSystem.typeFor(args.get(0)),\n            typeSystem.typeFor(args.get(1)));\n      case LIST:\n        assert args.size() == 1;\n        return new ListType(typeSystem.typeFor(args.get(0)));\n      default:\n        throw new AssertionError(op);\n      }\n    }\n\n    @Override public Type.Key copy(UnaryOperator<Type.Key> transform) {\n      return new OpKey(op, transform(args, arg -> arg.copy(transform)));\n    }\n  }\n\n  /** Key of a forall type. */\n  private static class ForallKey extends Type.Key {\n    final Type type;\n    final int parameterCount;\n\n    ForallKey(Type type, int parameterCount) {\n      super(Op.FORALL_TYPE);\n      this.type = requireNonNull(type);\n      this.parameterCount = parameterCount;\n      checkArgument(parameterCount >= 0);\n    }\n\n    @Override public int hashCode() {\n      return hash(type, parameterCount);\n    }\n\n    @Override public boolean equals(Object obj) {\n      return obj == this\n          || obj instanceof ForallKey\n          && ((ForallKey) obj).type.equals(type)\n          && ((ForallKey) obj).parameterCount == parameterCount;\n    }\n\n    @Override public StringBuilder describe(StringBuilder buf, int left,\n        int right) {\n      buf.append(\"forall\");\n      for (int i = 0; i < parameterCount; i++) {\n        buf.append(' ').append(TypeVar.name(i));\n      }\n      buf.append(\". \");\n      return TypeSystem.unparse(buf, type.key(), 0, 0);\n    }\n\n    public Type toType(TypeSystem typeSystem) {\n      return new ForallType(parameterCount, type);\n    }\n  }\n\n  /** Key of a record type. */\n  private static class RecordKey extends Type.Key {\n    final ImmutableSortedMap<String, Type.Key> argNameTypes;\n\n    RecordKey(ImmutableSortedMap<String, Type.Key> argNameTypes) {\n      super(TypeSystem.areContiguousIntegers(argNameTypes.keySet())\n          ? Op.TUPLE_TYPE\n          : Op.RECORD_TYPE);\n      this.argNameTypes = requireNonNull(argNameTypes);\n      checkArgument(argNameTypes.comparator() == RecordType.ORDERING);\n    }\n\n    @Override public Type.Key copy(UnaryOperator<Type.Key> transform) {\n      return record(Maps.transformValues(argNameTypes, transform::apply));\n    }\n\n    @Override public StringBuilder describe(StringBuilder buf, int left,\n        int right) {\n      return describeRecordType(buf, left, right, argNameTypes, op);\n    }\n\n    @Override public int hashCode() {\n      return argNameTypes.hashCode();\n    }\n\n    @Override public boolean equals(Object obj) {\n      return obj == this\n          || obj instanceof RecordKey\n          && ((RecordKey) obj).argNameTypes.equals(argNameTypes);\n    }\n\n    public Type toType(TypeSystem typeSystem) {\n      switch (argNameTypes.size()) {\n      case 0:\n        return PrimitiveType.UNIT;\n      default:\n        if (op == Op.TUPLE_TYPE) {\n          return new TupleType(typeSystem.typesFor(argNameTypes.values()));\n        }\n        // fall through\n      case 1:\n        return new RecordType(typeSystem.typesFor(argNameTypes));\n      }\n    }\n  }\n\n  private static class ProgressiveRecordKey extends Type.Key {\n    final ImmutableSortedMap<String, Type.Key> argNameTypes;\n\n    ProgressiveRecordKey(ImmutableSortedMap<String, Type.Key> argNameTypes) {\n      super(Op.PROGRESSIVE_RECORD_TYPE);\n      this.argNameTypes = requireNonNull(argNameTypes);\n    }\n\n    @Override public Type.Key copy(UnaryOperator<Type.Key> transform) {\n      return progressiveRecord(\n          Maps.transformValues(argNameTypes, transform::apply));\n    }\n\n    @Override public StringBuilder describe(StringBuilder buf, int left,\n        int right) {\n      return describeRecordType(buf, left, right, argNameTypes, op);\n    }\n\n    @Override public int hashCode() {\n      return argNameTypes.hashCode();\n    }\n\n    @Override public boolean equals(Object obj) {\n      return obj == this\n          || obj instanceof ProgressiveRecordKey\n          && ((ProgressiveRecordKey) obj).argNameTypes.equals(argNameTypes);\n    }\n\n    @Override public Type toType(TypeSystem typeSystem) {\n      return new ProgressiveRecordType(typeSystem.typesFor(this.argNameTypes));\n    }\n  }\n\n  /** Key that identifies a {@code datatype} scheme. */\n  public static class DataTypeKey extends Type.Key {\n    /** Ideally, a datatype would not have a name, just a list of named type\n     * constructors, and the name would be associated later. When that happens,\n     * we can remove the {@code name} field from this key. */\n    private final String name;\n    private final List<? extends Type.Key> arguments;\n    private final SortedMap<String, Type.Key> typeConstructors;\n\n    DataTypeKey(String name, List<? extends Type.Key> arguments,\n        SortedMap<String, Type.Key> typeConstructors) {\n      super(Op.DATA_TYPE);\n      this.name = requireNonNull(name);\n      this.arguments = ImmutableList.copyOf(arguments);\n      this.typeConstructors = ImmutableSortedMap.copyOfSorted(typeConstructors);\n    }\n\n    @Override public int hashCode() {\n      return hash(name, arguments, typeConstructors);\n    }\n\n    @Override public boolean equals(Object obj) {\n      return obj == this\n          || obj instanceof DataTypeKey\n          && ((DataTypeKey) obj).name.equals(name)\n          && ((DataTypeKey) obj).arguments.equals(arguments)\n          && ((DataTypeKey) obj).typeConstructors.equals(typeConstructors);\n    }\n\n    /** {@inheritDoc}\n     *\n     * <p>Prints the name of this datatype along with any type arguments.\n     * Examples:\n     *\n     * <ul>\n     *   <li>{@code order}\n     *   <li>{@code 'a option}\n     *   <li>{@code (int * int) option}\n     *   <li>{@code bool option option}\n     *   <li>{@code ('a,'b) tree}\n     * </ul>\n     *\n     * @see ParameterizedType#computeMoniker(String, List)\n     */\n    @Override public StringBuilder describe(StringBuilder buf, int left,\n        int right) {\n      if (arguments.isEmpty()) {\n        return buf.append(name);\n      }\n      if (arguments.size() > 1) {\n        buf.append('(');\n      }\n      final int length = buf.length();\n      for (Type.Key key : arguments) {\n        if (buf.length() > length) {\n          buf.append(\",\");\n        }\n        if (key.op == Op.TUPLE_TYPE) {\n          buf.append('(');\n        }\n        key.describe(buf, 0, 0);\n        if (key.op == Op.TUPLE_TYPE) {\n          buf.append(')');\n        }\n      }\n      if (arguments.size() > 1) {\n        buf.append(')');\n      }\n      return buf.append(' ').append(name);\n    }\n\n    @Override public DataType toType(TypeSystem typeSystem) {\n      return typeSystem.dataType(name,\n          typeSystem.typesFor(arguments), typeConstructors);\n    }\n  }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/main/java/net/hydromatic/morel/type/ListType.java.ListType", "name": "ListType", "file_path": "src/main/java/net/hydromatic/morel/type/ListType.java", "superclasses": "BaseType", "methods": ["[]ListType(Type)", "[Key]key()", "[R]accept(TypeVisitor<R>)", "[ListType]copy(TypeSystem,UnaryOperator<Type>)"], "method_uris": ["src/main/java/net/hydromatic/morel/type/ListType.java.ListType.[]ListType(Type)", "src/main/java/net/hydromatic/morel/type/ListType.java.ListType.[Key]key()", "src/main/java/net/hydromatic/morel/type/ListType.java.ListType.[R]accept(TypeVisitor<R>)", "src/main/java/net/hydromatic/morel/type/ListType.java.ListType.[ListType]copy(TypeSystem,UnaryOperator<Type>)"], "overrides": null, "attributes": [], "class_docstring": " TODO: remove this, and use datatype?", "original_string": "public class ListType extends BaseType {\n  public final Type elementType;\n\n  ListType(Type elementType) {\n    super(Op.LIST);\n    this.elementType = requireNonNull(elementType);\n  }\n\n  @Override public Key key() {\n    return Keys.list(elementType.key());\n  }\n\n  public <R> R accept(TypeVisitor<R> typeVisitor) {\n    return typeVisitor.visit(this);\n  }\n\n  @Override public ListType copy(TypeSystem typeSystem,\n      UnaryOperator<Type> transform) {\n    final Type elementType2 = elementType.copy(typeSystem, transform);\n    return elementType2 == elementType\n        ? this\n        : typeSystem.listType(elementType2);\n  }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "public final Type elementType;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "Type", "name": "elementType", "syntax_pass": true}]}, {"uris": "src/main/java/net/hydromatic/morel/type/TypeShuttle.java.TypeShuttle", "name": "TypeShuttle", "file_path": "src/main/java/net/hydromatic/morel/type/TypeShuttle.java", "superclasses": "", "methods": ["[]TypeShuttle(TypeSystem)", "[Type]visit(TypeVar)", "[ListType]visit(ListType)", "[FnType]visit(FnType)", "[TupleType]visit(TupleType)", "[RecordType]visit(RecordType)", "[Type]visit(DataType)", "[PrimitiveType]visit(PrimitiveType)", "[ForallType]visit(ForallType)", "[DummyType]visit(DummyType)"], "method_uris": ["src/main/java/net/hydromatic/morel/type/TypeShuttle.java.TypeShuttle.[]TypeShuttle(TypeSystem)", "src/main/java/net/hydromatic/morel/type/TypeShuttle.java.TypeShuttle.[Type]visit(TypeVar)", "src/main/java/net/hydromatic/morel/type/TypeShuttle.java.TypeShuttle.[ListType]visit(ListType)", "src/main/java/net/hydromatic/morel/type/TypeShuttle.java.TypeShuttle.[FnType]visit(FnType)", "src/main/java/net/hydromatic/morel/type/TypeShuttle.java.TypeShuttle.[TupleType]visit(TupleType)", "src/main/java/net/hydromatic/morel/type/TypeShuttle.java.TypeShuttle.[RecordType]visit(RecordType)", "src/main/java/net/hydromatic/morel/type/TypeShuttle.java.TypeShuttle.[Type]visit(DataType)", "src/main/java/net/hydromatic/morel/type/TypeShuttle.java.TypeShuttle.[PrimitiveType]visit(PrimitiveType)", "src/main/java/net/hydromatic/morel/type/TypeShuttle.java.TypeShuttle.[ForallType]visit(ForallType)", "src/main/java/net/hydromatic/morel/type/TypeShuttle.java.TypeShuttle.[DummyType]visit(DummyType)"], "overrides": null, "attributes": [], "class_docstring": " Visitor over {@link Type} objects that returns types.", "original_string": "public class TypeShuttle extends TypeVisitor<Type> {\n  private final TypeSystem typeSystem;\n\n  protected TypeShuttle(TypeSystem typeSystem) {\n    this.typeSystem = typeSystem;\n  }\n\n  @Override public Type visit(TypeVar typeVar) {\n    return typeVar.copy(typeSystem, t -> t.accept(this));\n  }\n\n  @Override public ListType visit(ListType listType) {\n    return listType.copy(typeSystem, t -> t.accept(this));\n  }\n\n  @Override public FnType visit(FnType fnType) {\n    return fnType.copy(typeSystem, t -> t.accept(this));\n  }\n\n  @Override public TupleType visit(TupleType tupleType) {\n    return tupleType.copy(typeSystem, t -> t.accept(this));\n  }\n\n  @Override public RecordType visit(RecordType recordType) {\n    return recordType.copy(typeSystem, t -> t.accept(this));\n  }\n\n  @Override public Type visit(DataType dataType) {\n    return dataType.copy(typeSystem, t -> t.accept(this));\n  }\n\n  @Override public PrimitiveType visit(PrimitiveType primitiveType) {\n    return primitiveType.copy(typeSystem, t -> t.accept(this));\n  }\n\n  @Override public ForallType visit(ForallType forallType) {\n    return forallType.copy(typeSystem, t -> t.accept(this));\n  }\n\n  @Override public DummyType visit(DummyType dummyType) {\n    return dummyType.copy(typeSystem, t -> t.accept(this));\n  }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private final TypeSystem typeSystem;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "TypeSystem", "name": "typeSystem", "syntax_pass": true}]}, {"uris": "src/main/java/net/hydromatic/morel/type/TypeVisitor.java.TypeVisitor", "name": "TypeVisitor", "file_path": "src/main/java/net/hydromatic/morel/type/TypeVisitor.java", "superclasses": "", "methods": ["[R]visit(TypeVar)", "[R]visit(ListType)", "[R]visit(FnType)", "[R]visit(TupleType)", "[R]visit(RecordType)", "[R]visit(DataType)", "[R]visit(PrimitiveType)", "[R]visit(ForallType)", "[R]visit(DummyType)"], "method_uris": ["src/main/java/net/hydromatic/morel/type/TypeVisitor.java.TypeVisitor.[R]visit(TypeVar)", "src/main/java/net/hydromatic/morel/type/TypeVisitor.java.TypeVisitor.[R]visit(ListType)", "src/main/java/net/hydromatic/morel/type/TypeVisitor.java.TypeVisitor.[R]visit(FnType)", "src/main/java/net/hydromatic/morel/type/TypeVisitor.java.TypeVisitor.[R]visit(TupleType)", "src/main/java/net/hydromatic/morel/type/TypeVisitor.java.TypeVisitor.[R]visit(RecordType)", "src/main/java/net/hydromatic/morel/type/TypeVisitor.java.TypeVisitor.[R]visit(DataType)", "src/main/java/net/hydromatic/morel/type/TypeVisitor.java.TypeVisitor.[R]visit(PrimitiveType)", "src/main/java/net/hydromatic/morel/type/TypeVisitor.java.TypeVisitor.[R]visit(ForallType)", "src/main/java/net/hydromatic/morel/type/TypeVisitor.java.TypeVisitor.[R]visit(DummyType)"], "overrides": null, "attributes": [], "class_docstring": " Visitor over {@link Type} objects.\n\n@param <R> return type from {@code visit} methods\n\n@see Type#accept(TypeVisitor)\n", "original_string": "public class TypeVisitor<R> {\n  /** Visits a {@link TypeVar}. */\n  public R visit(TypeVar typeVar) {\n    return null;\n  }\n\n  /** Visits a {@link ListType}. */\n  public R visit(ListType listType) {\n    return listType.elementType.accept(this);\n  }\n\n  /** Visits a {@link FnType}. */\n  public R visit(FnType fnType) {\n    R r = fnType.paramType.accept(this);\n    return fnType.resultType.accept(this);\n  }\n\n  /** Visits a {@link TupleType}. */\n  public R visit(TupleType tupleType) {\n    R r = null;\n    for (Type argType : tupleType.argTypes) {\n      r = argType.accept(this);\n    }\n    return r;\n  }\n\n  /** Visits a {@link RecordType}. */\n  public R visit(RecordType recordType) {\n    R r = null;\n    for (Type type : recordType.argNameTypes.values()) {\n      r = type.accept(this);\n    }\n    return r;\n  }\n\n  /** Visits a {@link DataType}. */\n  public R visit(DataType dataType) {\n    dataType.parameterTypes.forEach(t -> t.accept(this));\n    return null;\n  }\n\n  /** Visits a {@link PrimitiveType}. */\n  public R visit(PrimitiveType primitiveType) {\n    return null;\n  }\n\n  /** Visits a {@link ForallType}. */\n  public R visit(ForallType forallType) {\n    return forallType.type.accept(this);\n  }\n\n  /** Visits a {@link DummyType}. */\n  public R visit(DummyType dummyType) {\n    return null;\n  }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/main/java/net/hydromatic/morel/type/FnType.java.FnType", "name": "FnType", "file_path": "src/main/java/net/hydromatic/morel/type/FnType.java", "superclasses": "BaseType", "methods": ["[]FnType(Type,Type)", "[Key]key()", "[R]accept(TypeVisitor<R>)", "[FnType]copy(TypeSystem,UnaryOperator<Type>)"], "method_uris": ["src/main/java/net/hydromatic/morel/type/FnType.java.FnType.[]FnType(Type,Type)", "src/main/java/net/hydromatic/morel/type/FnType.java.FnType.[Key]key()", "src/main/java/net/hydromatic/morel/type/FnType.java.FnType.[R]accept(TypeVisitor<R>)", "src/main/java/net/hydromatic/morel/type/FnType.java.FnType.[FnType]copy(TypeSystem,UnaryOperator<Type>)"], "overrides": null, "attributes": [], "class_docstring": " The type of a function value.", "original_string": "public class FnType extends BaseType {\n  public final Type paramType;\n  public final Type resultType;\n\n  FnType(Type paramType, Type resultType) {\n    super(Op.FUNCTION_TYPE);\n    this.paramType = paramType;\n    this.resultType = resultType;\n  }\n\n  public Key key() {\n    return Keys.fn(paramType.key(), resultType.key());\n  }\n\n  public <R> R accept(TypeVisitor<R> typeVisitor) {\n    return typeVisitor.visit(this);\n  }\n\n  @Override public FnType copy(TypeSystem typeSystem,\n      UnaryOperator<Type> transform) {\n    final Type paramType2 = paramType.copy(typeSystem, transform);\n    final Type resultType2 = resultType.copy(typeSystem, transform);\n    return paramType2 == paramType\n        && resultType2 == resultType\n        ? this\n        : typeSystem.fnType(paramType2, resultType2);\n  }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "public final Type paramType;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "Type", "name": "paramType", "syntax_pass": true}, {"attribute_expression": "public final Type resultType;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "Type", "name": "resultType", "syntax_pass": true}]}, {"uris": "src/main/java/net/hydromatic/morel/type/RecordType.java.RecordType", "name": "RecordType", "file_path": "src/main/java/net/hydromatic/morel/type/RecordType.java", "superclasses": "BaseType", "methods": ["[]RecordType(SortedMap<String, Type>)", "[SortedMap<String, Type>]argNameTypes()", "[Type]argType(int)", "[R]accept(TypeVisitor<R>)", "[Key]key()", "[RecordType]copy(TypeSystem,UnaryOperator<Type>)", "[SortedMap<String, V>]map(String,V)", "[NavigableMap<String, V>]mutableMap()", "[int]compareNames(String,String)", "[int]parseInt(String)"], "method_uris": ["src/main/java/net/hydromatic/morel/type/RecordType.java.RecordType.[]RecordType(SortedMap<String, Type>)", "src/main/java/net/hydromatic/morel/type/RecordType.java.RecordType.[SortedMap<String, Type>]argNameTypes()", "src/main/java/net/hydromatic/morel/type/RecordType.java.RecordType.[Type]argType(int)", "src/main/java/net/hydromatic/morel/type/RecordType.java.RecordType.[R]accept(TypeVisitor<R>)", "src/main/java/net/hydromatic/morel/type/RecordType.java.RecordType.[Key]key()", "src/main/java/net/hydromatic/morel/type/RecordType.java.RecordType.[RecordType]copy(TypeSystem,UnaryOperator<Type>)", "src/main/java/net/hydromatic/morel/type/RecordType.java.RecordType.[SortedMap<String, V>]map(String,V)", "src/main/java/net/hydromatic/morel/type/RecordType.java.RecordType.[NavigableMap<String, V>]mutableMap()", "src/main/java/net/hydromatic/morel/type/RecordType.java.RecordType.[int]compareNames(String,String)", "src/main/java/net/hydromatic/morel/type/RecordType.java.RecordType.[int]parseInt(String)"], "overrides": null, "attributes": [], "class_docstring": " Record type.", "original_string": "public class RecordType extends BaseType implements RecordLikeType {\n  public final SortedMap<String, Type> argNameTypes;\n\n  RecordType(SortedMap<String, Type> argNameTypes) {\n    super(Op.RECORD_TYPE);\n    this.argNameTypes = ImmutableSortedMap.copyOfSorted(argNameTypes);\n    checkArgument(argNameTypes.comparator() == ORDERING);\n  }\n\n  @Override public SortedMap<String, Type> argNameTypes() {\n    return argNameTypes;\n  }\n\n  @Override public Type argType(int i) {\n    // No copy is made: values() is already a list.\n    return ImmutableList.copyOf(argNameTypes.values()).get(i);\n  }\n\n  public <R> R accept(TypeVisitor<R> typeVisitor) {\n    return typeVisitor.visit(this);\n  }\n\n  public Key key() {\n    return Keys.record(Keys.toKeys(argNameTypes));\n  }\n\n  @Override public RecordType copy(TypeSystem typeSystem,\n      UnaryOperator<Type> transform) {\n    int differenceCount = 0;\n    final PairList<String, Type> argNameTypes2 = PairList.of();\n    for (Map.Entry<String, Type> entry : argNameTypes.entrySet()) {\n      final Type type = entry.getValue();\n      final Type type2 = type.copy(typeSystem, transform);\n      if (type != type2) {\n        ++differenceCount;\n      }\n      argNameTypes2.add(entry.getKey(), type2);\n    }\n    return differenceCount == 0\n        ? this\n        : (RecordType) typeSystem.recordType(argNameTypes2);\n  }\n\n  /** Ordering that compares integer values numerically,\n   * string values lexicographically,\n   * and integer values before string values.\n   *\n   * <p>Thus: 2, 22, 202, a, a2, a202, a22. */\n  public static final Ordering<String> ORDERING =\n      Ordering.from(RecordType::compareNames);\n\n  /** Creates a constant map, sorted by {@link #ORDERING}. */\n  @SuppressWarnings(\"unchecked\")\n  public static <V> SortedMap<String, V> map(String name, V v0,\n      Object... entries) {\n    final ImmutableSortedMap.Builder<String, V> builder =\n        ImmutableSortedMap.orderedBy(ORDERING);\n    builder.put(name, v0);\n    for (int i = 0; i < entries.length / 2; i += 2) {\n      builder.put((String) entries[i], (V) entries[i + 1]);\n    }\n    return builder.build();\n  }\n\n  /** Creates a mutable map, sorted by {@link #ORDERING}. */\n  public static <V> NavigableMap<String, V> mutableMap() {\n    return new TreeMap<>(ORDERING);\n  }\n\n  /** Helper for {@link #ORDERING}. */\n  public static int compareNames(String o1, String o2) {\n    int i1 = parseInt(o1);\n    int i2 = parseInt(o2);\n    int c = Integer.compare(i1, i2);\n    if (c != 0) {\n      return c;\n    }\n    return o1.compareTo(o2);\n  }\n\n  /** Parses a string that contains an integer value; returns\n   * {@link Integer#MAX_VALUE} if the string does not contain an integer,\n   * or if the value is less than zero,\n   * or if the value is greater than or equal to 1 billion.\n   *\n   * <p>This approach is much faster for our purposes than\n   * {@link Integer#parseInt(String)}, which has to create and throw an\n   * exception if the value is not an integer. */\n  private static int parseInt(String s) {\n    final int length = s.length();\n    if (length > 9) {\n      // We treat values that are 1 billion (1,000,000,000) or higher as if they\n      // are Integer.MAX_VALUE (2,147,483,648). Therefore, we do not need to\n      // check for overflow in the loop below.\n      return Integer.MAX_VALUE;\n    }\n    int n = 0;\n    for (int i = 0; i < length; i++) {\n      char c = s.charAt(i);\n      if (c < '0' || c > '9') {\n        return Integer.MAX_VALUE;\n      }\n      int digit = c - '0';\n      n = n * 10 + digit;\n    }\n    return n;\n  }\n}", "super_interfaces": ["RecordLikeType"], "fields": [{"attribute_expression": "public final SortedMap<String, Type> argNameTypes;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "SortedMap<String, Type>", "name": "argNameTypes", "syntax_pass": true}, {"attribute_expression": "public static final Ordering<String> ORDERING =\n      Ordering.from(RecordType::compareNames);", "docstring": " Ordering that compares integer values numerically,\nstring values lexicographically,\nand integer values before string values.\n\n<p>Thus: 2, 22, 202, a, a2, a202, a22.", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "Ordering<String>", "name": "ORDERING =\n      Ordering.from(RecordType::compareNames)", "syntax_pass": true}]}, {"uris": "src/main/java/net/hydromatic/morel/type/ProgressiveRecordType.java.ProgressiveRecordType", "name": "ProgressiveRecordType", "file_path": "src/main/java/net/hydromatic/morel/type/ProgressiveRecordType.java", "superclasses": "RecordType", "methods": ["[]ProgressiveRecordType(SortedMap<String, Type>)", "[boolean]isProgressive()", "[Key]key()"], "method_uris": ["src/main/java/net/hydromatic/morel/type/ProgressiveRecordType.java.ProgressiveRecordType.[]ProgressiveRecordType(SortedMap<String, Type>)", "src/main/java/net/hydromatic/morel/type/ProgressiveRecordType.java.ProgressiveRecordType.[boolean]isProgressive()", "src/main/java/net/hydromatic/morel/type/ProgressiveRecordType.java.ProgressiveRecordType.[Key]key()"], "overrides": null, "attributes": [], "class_docstring": " Progressive record type.", "original_string": "public class ProgressiveRecordType extends RecordType {\n  /** Creates a ProgressiveRecordType. */\n  ProgressiveRecordType(SortedMap<String, Type> argNameTypes) {\n    super(argNameTypes);\n  }\n\n  @Override public boolean isProgressive() {\n    return true;\n  }\n\n  @Override public Key key() {\n    return Keys.progressiveRecord(Keys.toKeys(argNameTypes));\n  }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/main/java/net/hydromatic/morel/type/RangeExtent.java.RangeExtent", "name": "RangeExtent", "file_path": "src/main/java/net/hydromatic/morel/type/RangeExtent.java", "superclasses": "", "methods": ["[]RangeExtent(TypeSystem,Type,Map<String, ImmutableRangeSet>)", "[String]toString()", "[boolean]isUnbounded()", "[Iterable<E>]toList(Type,TypeSystem)", "[boolean]populate(TypeSystem,Type,String,Map<String, ImmutableRangeSet>,Consumer<E>)"], "method_uris": ["src/main/java/net/hydromatic/morel/type/RangeExtent.java.RangeExtent.[]RangeExtent(TypeSystem,Type,Map<String, ImmutableRangeSet>)", "src/main/java/net/hydromatic/morel/type/RangeExtent.java.RangeExtent.[String]toString()", "src/main/java/net/hydromatic/morel/type/RangeExtent.java.RangeExtent.[boolean]isUnbounded()", "src/main/java/net/hydromatic/morel/type/RangeExtent.java.RangeExtent.[Iterable<E>]toList(Type,TypeSystem)", "src/main/java/net/hydromatic/morel/type/RangeExtent.java.RangeExtent.[boolean]populate(TypeSystem,Type,String,Map<String, ImmutableRangeSet>,Consumer<E>)"], "overrides": null, "attributes": [], "class_docstring": " A type and a range set.", "original_string": "@SuppressWarnings(\"rawtypes\")\npublic class RangeExtent {\n  /** Map from path to range set.\n   *\n   * <p>The path designates the item within the type.\n   *\n   * <p>For example, consider the type {@code int option list}.\n   *\n   * <ul>\n   * <li>\"/\" relates to the {@code int option list}\n   * <li>\"/0/\" relates to each {@code int option} within the list\n   * <li>\"/0/SOME/\" relates to each {@code int} within a \"SOME\" element of the\n   *       list\n   * <li>\"/0/NONE/\" relates to each \"NONE\" element of the list\n   * </ul>\n   *\n   * <p>Using a map {@code [\"/O/SOME/\" \"[0, 3], [6]\"]} we can generate\n   * {@code SOME 0, SOME 1, SOME 2, SOME 3, SOME 6, NONE}\n   */\n  public final Map<String, ImmutableRangeSet> rangeSetMap;\n  public final Type type;\n  public final @Nullable Iterable iterable;\n\n  /** Creates a RangeExtent. */\n  @SuppressWarnings(\"unchecked\")\n  public RangeExtent(TypeSystem typeSystem, Type type,\n      Map<String, ImmutableRangeSet> rangeSetMap) {\n    this.rangeSetMap =\n        ImmutableMap.copyOf(\n            Maps.transformValues(rangeSetMap,\n                r -> ImmutableRangeSet.copyOf(r)));\n    this.type = type;\n    this.iterable = toList(type, typeSystem);\n  }\n\n  @Override public String toString() {\n    if (isUnbounded()) {\n      return type.toString(); // range set is unconstrained; don't print it\n    }\n    return type + \" \" + rangeSetMap;\n  }\n\n  /** Whether this extent returns all, or an unbounded number of, the values of\n   * its type.\n   *\n   * <p>Examples:\n   * \"(-inf,+inf)\" (true),\n   * \"(-inf,0]\" (x &le; 0),\n   * \"{(-inf,3),(10,+inf)}\" (x &lt; 3 or x &gt; 10) are unbounded;\n   * \"{}\" (false),\n   * \"{3, 10}\" (x in [3, 10]),\n   * \"(3, 10)\" (x &ge; 3 andalso x &le; 10) are bounded. */\n  public boolean isUnbounded() {\n    return rangeSetMap.isEmpty();\n  }\n\n  /** Derives the collection of values in the range, or returns empty if\n   * the range is infinite. */\n  private <E extends Comparable<E>> Iterable<E> toList(Type type,\n      TypeSystem typeSystem) {\n    final List<E> list = new ArrayList<>();\n    if (populate(typeSystem, type, \"/\", rangeSetMap, (Consumer<E>) list::add)) {\n      return list;\n    }\n    return null;\n  }\n\n  /** Populates a list (or other consumer) with all values of this type. Returns\n   * false if this type is not finite and the range is open above or below. */\n  @SuppressWarnings(\"unchecked\")\n  private <E extends Comparable<E>> boolean populate(TypeSystem typeSystem,\n      Type type, String path, Map<String, ImmutableRangeSet> rangeSetMap,\n      Consumer<E> consumer) {\n    final RangeSet<E> rangeSet = rangeSetMap.get(path);\n    final Consumer<E> filteredConsumer;\n    if (rangeSet != null) {\n      filteredConsumer = e -> {\n        if (rangeSet.contains(e)) {\n          consumer.accept(e);\n        }\n      };\n    } else {\n      filteredConsumer = consumer;\n    }\n    switch (type.op()) {\n    case ID:\n      switch ((PrimitiveType) type) {\n      case BOOL:\n        filteredConsumer.accept((E) Boolean.FALSE);\n        filteredConsumer.accept((E) Boolean.TRUE);\n        return true;\n\n      case UNIT:\n        filteredConsumer.accept((E) Unit.INSTANCE);\n        return true;\n\n      case CHAR:\n        for (int i = 0; i < 256; i++) {\n          filteredConsumer.accept((E) Character.valueOf((char) i));\n        }\n        return true;\n\n      case INT:\n        if (rangeSet != null) {\n          for (Range<E> range : rangeSet.asRanges()) {\n            if (!range.hasLowerBound() || !range.hasUpperBound()) {\n              return false;\n            }\n            final int lower =\n                ((BigDecimal) range.lowerEndpoint()).intValue()\n                    + (range.lowerBoundType() == BoundType.OPEN ? 1 : 0);\n            final int upper =\n                ((BigDecimal) range.upperEndpoint()).intValue()\n                - (range.upperBoundType() == BoundType.OPEN ? 1 : 0);\n            for (int i = lower; i <= upper; i++) {\n              consumer.accept((E) Integer.valueOf(i));\n            }\n          }\n          return true;\n        }\n        // fall through\n      }\n      return false;\n\n    case DUMMY_TYPE:\n      assert type == DummyType.INSTANCE;\n      filteredConsumer.accept((E) Unit.INSTANCE);\n      return true;\n\n    case DATA_TYPE:\n      final DataType dataType = (DataType) type;\n      for (Map.Entry<String, Type> entry\n          : dataType.typeConstructors(typeSystem).entrySet()) {\n        final String name = entry.getKey();\n        final Type type2 = entry.getValue();\n        final Consumer<E> consumer2 =\n            type2.op() == Op.DUMMY_TYPE\n                ? v -> filteredConsumer.accept((E) FlatLists.of(name))\n                : v -> filteredConsumer.accept((E) FlatLists.of(name, v));\n        if (!populate(typeSystem, type2, path + name + \"/\", rangeSetMap,\n            consumer2)) {\n          return false;\n        }\n      }\n      return true;\n\n    case RECORD_TYPE:\n    case TUPLE_TYPE:\n      final RecordLikeType recordType = (RecordLikeType) type;\n      final List<List<E>> listList = new ArrayList<>();\n      for (Map.Entry<String, Type> entry\n          : recordType.argNameTypes().entrySet()) {\n        final String name = entry.getKey();\n        final Type type2 = entry.getValue();\n        final List<E> list2 = new ArrayList<>();\n        final Consumer<E> consumer2 = list2::add;\n        if (!populate(typeSystem, type2, path + name + '/', rangeSetMap,\n            consumer2)) {\n          return false;\n        }\n        listList.add(list2);\n      }\n      Lists.cartesianProduct(listList)\n          .forEach(list ->\n              filteredConsumer.accept((E) FlatLists.ofComparable((List) list)));\n      return true;\n\n    default:\n      // All other types are not enumerable\n      return false;\n    }\n  }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "public final Map<String, ImmutableRangeSet> rangeSetMap;", "docstring": " Map from path to range set.\n\n<p>The path designates the item within the type.\n\n<p>For example, consider the type {@code int option list}.\n\n<ul>\n<li>\"/\" relates to the {@code int option list}\n<li>\"/0/\" relates to each {@code int option} within the list\n<li>\"/0/SOME/\" relates to each {@code int} within a \"SOME\" element of the\n      list\n<li>\"/0/NONE/\" relates to each \"NONE\" element of the list\n</ul>\n\n<p>Using a map {@code [\"/O/SOME/\" \"[0, 3], [6]\"]} we can generate\n{@code SOME 0, SOME 1, SOME 2, SOME 3, SOME 6, NONE}\n", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "Map<String, ImmutableRangeSet>", "name": "rangeSetMap", "syntax_pass": true}, {"attribute_expression": "public final Type type;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "Type", "name": "type", "syntax_pass": true}, {"attribute_expression": "public final @Nullable Iterable iterable;", "docstring": "", "modifiers": "public final @Nullable", "marker_annotations": ["@Nullable"], "non_marker_annotations": ["public", "final"], "comments": [], "type": "Iterable", "name": "iterable", "syntax_pass": true}]}, {"uris": "src/main/java/net/hydromatic/morel/foreign/Converters.java.Converters", "name": "Converters", "file_path": "src/main/java/net/hydromatic/morel/foreign/Converters.java", "superclasses": "", "methods": ["[]Converters()", "[Converter<Object[]>]ofRow(RelDataType)", "[Converter<Object[]>]ofRow2(RelDataType,RecordLikeType)", "[Converter<Object[]>]ofRow3(Iterator<RelDataTypeField>,AtomicInteger,Enumerator<Type>)", "[Converter<Object[]>]ofField(RelDataType,int)", "[Converter<Object[]>]ofField2(Iterator<RelDataTypeField>,AtomicInteger,Type)", "[Converter<Object[]>]offset(int,Converter<Object[]>)", "[Converter<Object[]>]ofField3(RelDataTypeField,AtomicInteger,Type)", "[Function<Enumerable<Object[]>, List<Object>>]fromEnumerable(RelNode,Type)", "[Function<E, Object>]forType(RelDataType,Type)", "[Type]fieldType(RelDataTypeField)", "[RelDataType]toCalciteType(Type,RelDataTypeFactory)", "[Function<Object, Enumerable<Object[]>>]toCalciteEnumerable(Type,RelDataTypeFactory)", "[Function<Object, Object>]toCalcite(Type,RelDataTypeFactory)", "[Function<Object, Object>]toMorel(Type,RelDataTypeFactory)"], "method_uris": ["src/main/java/net/hydromatic/morel/foreign/Converters.java.Converters.[]Converters()", "src/main/java/net/hydromatic/morel/foreign/Converters.java.Converters.[Converter<Object[]>]ofRow(RelDataType)", "src/main/java/net/hydromatic/morel/foreign/Converters.java.Converters.[Converter<Object[]>]ofRow2(RelDataType,RecordLikeType)", "src/main/java/net/hydromatic/morel/foreign/Converters.java.Converters.[Converter<Object[]>]ofRow3(Iterator<RelDataTypeField>,AtomicInteger,Enumerator<Type>)", "src/main/java/net/hydromatic/morel/foreign/Converters.java.Converters.[Converter<Object[]>]ofField(RelDataType,int)", "src/main/java/net/hydromatic/morel/foreign/Converters.java.Converters.[Converter<Object[]>]ofField2(Iterator<RelDataTypeField>,AtomicInteger,Type)", "src/main/java/net/hydromatic/morel/foreign/Converters.java.Converters.[Converter<Object[]>]offset(int,Converter<Object[]>)", "src/main/java/net/hydromatic/morel/foreign/Converters.java.Converters.[Converter<Object[]>]ofField3(RelDataTypeField,AtomicInteger,Type)", "src/main/java/net/hydromatic/morel/foreign/Converters.java.Converters.[Function<Enumerable<Object[]>, List<Object>>]fromEnumerable(RelNode,Type)", "src/main/java/net/hydromatic/morel/foreign/Converters.java.Converters.[Function<E, Object>]forType(RelDataType,Type)", "src/main/java/net/hydromatic/morel/foreign/Converters.java.Converters.[Type]fieldType(RelDataTypeField)", "src/main/java/net/hydromatic/morel/foreign/Converters.java.Converters.[RelDataType]toCalciteType(Type,RelDataTypeFactory)", "src/main/java/net/hydromatic/morel/foreign/Converters.java.Converters.[Function<Object, Enumerable<Object[]>>]toCalciteEnumerable(Type,RelDataTypeFactory)", "src/main/java/net/hydromatic/morel/foreign/Converters.java.Converters.[Function<Object, Object>]toCalcite(Type,RelDataTypeFactory)", "src/main/java/net/hydromatic/morel/foreign/Converters.java.Converters.[Function<Object, Object>]toMorel(Type,RelDataTypeFactory)"], "overrides": null, "attributes": [{"original_string": "  private static class C2m {\n    final RelDataType calciteType;\n    final Type morelType;\n\n    C2m(RelDataType calciteType, Type morelType) {\n      this.calciteType = calciteType;\n      this.morelType = morelType;\n    }\n\n    /** Creates a converter for a given Morel type, in the process deducing the\n     * corresponding Calcite type. */\n    static C2m forMorel(Type type, RelDataTypeFactory typeFactory,\n        boolean nullable, boolean recordList) {\n      final RelDataTypeFactory.Builder typeBuilder;\n      switch (type.op()) {\n      case DATA_TYPE:\n        final DataType dataType = (DataType) type;\n        if (dataType.name.equals(\"option\")) {\n          return forMorel(dataType.parameterTypes.get(0), typeFactory, true,\n              false);\n        }\n        throw new AssertionError(\"unknown type \" + type);\n\n      case FUNCTION_TYPE:\n        // Represent Morel functions (and closures) as SQL type ANY. UDFs have a\n        // parameter of type Object, and the value is cast to Closure.\n        return new C2m(typeFactory.createSqlType(SqlTypeName.ANY), type);\n\n      case LIST:\n        final ListType listType = (ListType) type;\n        RelDataType elementType =\n            forMorel(listType.elementType, typeFactory, nullable, false)\n                .calciteType;\n        if (recordList && !elementType.isStruct()) {\n          elementType = typeFactory.builder()\n              .add(\"1\", elementType)\n              .build();\n        }\n        return new C2m(\n            typeFactory.createMultisetType(elementType, -1),\n            type);\n\n      case RECORD_TYPE:\n      case TUPLE_TYPE:\n        typeBuilder = typeFactory.builder();\n        final RecordLikeType recordType = (RecordLikeType) type;\n        recordType.argNameTypes().forEach((name, argType) ->\n            typeBuilder.add(name,\n                forMorel(argType, typeFactory, nullable, recordList)\n                    .calciteType));\n        return new C2m(typeBuilder.build(), type);\n\n      case TY_VAR:\n        // The reason that a type variable is present is because the type\n        // doesn't matter. For example, in 'map (fn x => 1) []' it doesn't\n        // matter what the element type of the empty list is, because the\n        // lambda doesn't look at the elements. So, pretend the type is 'bool'.\n        type = PrimitiveType.BOOL;\n        // fall through\n\n      case ID:\n        final PrimitiveType primitiveType = (PrimitiveType) type;\n        switch (primitiveType) {\n        case BOOL:\n          return new C2m(\n              typeFactory.createTypeWithNullability(\n                  typeFactory.createSqlType(SqlTypeName.BOOLEAN), nullable),\n              type);\n        case INT:\n          return new C2m(\n              typeFactory.createTypeWithNullability(\n                  typeFactory.createSqlType(SqlTypeName.INTEGER), nullable),\n              type);\n        case REAL:\n          return new C2m(\n              typeFactory.createTypeWithNullability(\n                  typeFactory.createSqlType(SqlTypeName.REAL), nullable),\n              type);\n        case CHAR:\n          return new C2m(\n              typeFactory.createTypeWithNullability(\n                  typeFactory.createSqlType(SqlTypeName.SMALLINT), nullable),\n              type);\n        case UNIT:\n          return new C2m(\n              typeFactory.createTypeWithNullability(\n              typeFactory.createSqlType(SqlTypeName.TINYINT), nullable),\n              type);\n        case STRING:\n          return new C2m(\n              typeFactory.createTypeWithNullability(\n                  typeFactory.createSqlType(SqlTypeName.VARCHAR, -1), nullable),\n              type);\n        default:\n          throw new AssertionError(\"unknown type \" + type);\n        }\n\n      default:\n        throw new UnsupportedOperationException(\"cannot convert type \" + type);\n      }\n    }\n\n    public Object toCalciteObject(Object v) {\n      return v;\n    }\n\n    public Enumerable<Object[]> toCalciteEnumerable(Object v) {\n      @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n      final Enumerable<Object> enumerable = Linq4j.asEnumerable((List) v);\n      switch (morelType.op()) {\n      case LIST:\n        final ListType listType = (ListType) morelType;\n        final C2m c =\n            new C2m(calciteType.getComponentType(),\n                listType.elementType);\n        if (c.morelType instanceof PrimitiveType) {\n          if (c.calciteType.isStruct()) {\n            return EnumerableDefaults.select(enumerable, c::scalarToArray);\n          } else {\n            //noinspection unchecked\n            return (Enumerable) enumerable;\n          }\n        } else {\n          return EnumerableDefaults.select(enumerable, c::listToArray);\n        }\n      default:\n        throw new AssertionError(\"cannot convert \" + morelType);\n      }\n    }\n\n    private Object[] listToArray(Object o) {\n      @SuppressWarnings(\"unchecked\")\n      List<Object> list = (List<Object>) o;\n      return list.toArray();\n    }\n\n    private Object[] scalarToArray(Object o) {\n      return new Object[] {o};\n    }\n\n    public Function<Object, Object> toMorelObjectFunction() {\n      switch (morelType.op()) {\n      case TUPLE_TYPE:\n        final ImmutableList.Builder<Function<Object, Object>> b =\n            ImmutableList.builder();\n        forEach(calciteType.getFieldList(),\n            ((TupleType) morelType).argTypes, (field, argType) ->\n                b.add(new C2m(field.getType(), argType)\n                    .toMorelObjectFunction()));\n        final ImmutableList<Function<Object, Object>> converters = b.build();\n        return v -> {\n          final Object[] values = (Object[]) v;\n          return new AbstractList<Object>() {\n            @Override public int size() {\n              return values.length;\n            }\n\n            @Override public Object get(int index) {\n              return converters.get(index).apply(values[index]);\n            }\n          };\n        };\n\n      case ID: // primitive type, e.g. int\n        switch ((PrimitiveType) morelType) {\n        case INT:\n          return v -> ((Number) v).intValue();\n        default:\n          return v -> v;\n        }\n\n      default:\n        throw new AssertionError(\"unknown type \" + morelType);\n      }\n    }\n  }", "definition": "  private static class C2m", "class_docstring": " Converter from Calcite types to Morel types.", "name": "C2m", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "fields": [{"attribute_expression": "final RelDataType calciteType;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "RelDataType", "name": "calciteType", "syntax_pass": true}, {"attribute_expression": "final Type morelType;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "Type", "name": "morelType", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    C2m(RelDataType calciteType, Type morelType) {\n      this.calciteType = calciteType;\n      this.morelType = morelType;\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "C2m", "params": [{"name": "calciteType", "type": "RelDataType"}, {"name": "morelType", "type": "Type"}], "body": "                                                 {\n      this.calciteType = calciteType;\n      this.morelType = morelType;\n    }", "signature": "C2m(RelDataType calciteType, Type morelType)"}, {"syntax_pass": true, "original_string": "    static C2m forMorel(Type type, RelDataTypeFactory typeFactory,\n        boolean nullable, boolean recordList) {\n      final RelDataTypeFactory.Builder typeBuilder;\n      switch (type.op()) {\n      case DATA_TYPE:\n        final DataType dataType = (DataType) type;\n        if (dataType.name.equals(\"option\")) {\n          return forMorel(dataType.parameterTypes.get(0), typeFactory, true,\n              false);\n        }\n        throw new AssertionError(\"unknown type \" + type);\n\n      case FUNCTION_TYPE:\n        // Represent Morel functions (and closures) as SQL type ANY. UDFs have a\n        // parameter of type Object, and the value is cast to Closure.\n        return new C2m(typeFactory.createSqlType(SqlTypeName.ANY), type);\n\n      case LIST:\n        final ListType listType = (ListType) type;\n        RelDataType elementType =\n            forMorel(listType.elementType, typeFactory, nullable, false)\n                .calciteType;\n        if (recordList && !elementType.isStruct()) {\n          elementType = typeFactory.builder()\n              .add(\"1\", elementType)\n              .build();\n        }\n        return new C2m(\n            typeFactory.createMultisetType(elementType, -1),\n            type);\n\n      case RECORD_TYPE:\n      case TUPLE_TYPE:\n        typeBuilder = typeFactory.builder();\n        final RecordLikeType recordType = (RecordLikeType) type;\n        recordType.argNameTypes().forEach((name, argType) ->\n            typeBuilder.add(name,\n                forMorel(argType, typeFactory, nullable, recordList)\n                    .calciteType));\n        return new C2m(typeBuilder.build(), type);\n\n      case TY_VAR:\n        // The reason that a type variable is present is because the type\n        // doesn't matter. For example, in 'map (fn x => 1) []' it doesn't\n        // matter what the element type of the empty list is, because the\n        // lambda doesn't look at the elements. So, pretend the type is 'bool'.\n        type = PrimitiveType.BOOL;\n        // fall through\n\n      case ID:\n        final PrimitiveType primitiveType = (PrimitiveType) type;\n        switch (primitiveType) {\n        case BOOL:\n          return new C2m(\n              typeFactory.createTypeWithNullability(\n                  typeFactory.createSqlType(SqlTypeName.BOOLEAN), nullable),\n              type);\n        case INT:\n          return new C2m(\n              typeFactory.createTypeWithNullability(\n                  typeFactory.createSqlType(SqlTypeName.INTEGER), nullable),\n              type);\n        case REAL:\n          return new C2m(\n              typeFactory.createTypeWithNullability(\n                  typeFactory.createSqlType(SqlTypeName.REAL), nullable),\n              type);\n        case CHAR:\n          return new C2m(\n              typeFactory.createTypeWithNullability(\n                  typeFactory.createSqlType(SqlTypeName.SMALLINT), nullable),\n              type);\n        case UNIT:\n          return new C2m(\n              typeFactory.createTypeWithNullability(\n              typeFactory.createSqlType(SqlTypeName.TINYINT), nullable),\n              type);\n        case STRING:\n          return new C2m(\n              typeFactory.createTypeWithNullability(\n                  typeFactory.createSqlType(SqlTypeName.VARCHAR, -1), nullable),\n              type);\n        default:\n          throw new AssertionError(\"unknown type \" + type);\n        }\n\n      default:\n        throw new UnsupportedOperationException(\"cannot convert type \" + type);\n      }\n    }", "docstring": " Creates a converter for a given Morel type, in the process deducing the\ncorresponding Calcite type.", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "C2m", "classes": []}, "name": "forMorel", "params": [{"name": "type", "type": "Type"}, {"name": "typeFactory", "type": "RelDataTypeFactory"}, {"name": "nullable", "type": "boolean"}, {"name": "recordList", "type": "boolean"}], "body": "                                              {\n      final RelDataTypeFactory.Builder typeBuilder;\n      switch (type.op()) {\n      case DATA_TYPE:\n        final DataType dataType = (DataType) type;\n        if (dataType.name.equals(\"option\")) {\n          return forMorel(dataType.parameterTypes.get(0), typeFactory, true,\n              false);\n        }\n        throw new AssertionError(\"unknown type \" + type);\n\n      case FUNCTION_TYPE:\n        // Represent Morel functions (and closures) as SQL type ANY. UDFs have a\n        // parameter of type Object, and the value is cast to Closure.\n        return new C2m(typeFactory.createSqlType(SqlTypeName.ANY), type);\n\n      case LIST:\n        final ListType listType = (ListType) type;\n        RelDataType elementType =\n            forMorel(listType.elementType, typeFactory, nullable, false)\n                .calciteType;\n        if (recordList && !elementType.isStruct()) {\n          elementType = typeFactory.builder()\n              .add(\"1\", elementType)\n              .build();\n        }\n        return new C2m(\n            typeFactory.createMultisetType(elementType, -1),\n            type);\n\n      case RECORD_TYPE:\n      case TUPLE_TYPE:\n        typeBuilder = typeFactory.builder();\n        final RecordLikeType recordType = (RecordLikeType) type;\n        recordType.argNameTypes().forEach((name, argType) ->\n            typeBuilder.add(name,\n                forMorel(argType, typeFactory, nullable, recordList)\n                    .calciteType));\n        return new C2m(typeBuilder.build(), type);\n\n      case TY_VAR:\n        // The reason that a type variable is present is because the type\n        // doesn't matter. For example, in 'map (fn x => 1) []' it doesn't\n        // matter what the element type of the empty list is, because the\n        // lambda doesn't look at the elements. So, pretend the type is 'bool'.\n        type = PrimitiveType.BOOL;\n        // fall through\n\n      case ID:\n        final PrimitiveType primitiveType = (PrimitiveType) type;\n        switch (primitiveType) {\n        case BOOL:\n          return new C2m(\n              typeFactory.createTypeWithNullability(\n                  typeFactory.createSqlType(SqlTypeName.BOOLEAN), nullable),\n              type);\n        case INT:\n          return new C2m(\n              typeFactory.createTypeWithNullability(\n                  typeFactory.createSqlType(SqlTypeName.INTEGER), nullable),\n              type);\n        case REAL:\n          return new C2m(\n              typeFactory.createTypeWithNullability(\n                  typeFactory.createSqlType(SqlTypeName.REAL), nullable),\n              type);\n        case CHAR:\n          return new C2m(\n              typeFactory.createTypeWithNullability(\n                  typeFactory.createSqlType(SqlTypeName.SMALLINT), nullable),\n              type);\n        case UNIT:\n          return new C2m(\n              typeFactory.createTypeWithNullability(\n              typeFactory.createSqlType(SqlTypeName.TINYINT), nullable),\n              type);\n        case STRING:\n          return new C2m(\n              typeFactory.createTypeWithNullability(\n                  typeFactory.createSqlType(SqlTypeName.VARCHAR, -1), nullable),\n              type);\n        default:\n          throw new AssertionError(\"unknown type \" + type);\n        }\n\n      default:\n        throw new UnsupportedOperationException(\"cannot convert type \" + type);\n      }\n    }", "signature": "static C2m forMorel(Type type, RelDataTypeFactory typeFactory,\n        boolean nullable, boolean recordList)"}, {"syntax_pass": true, "original_string": "    public Object toCalciteObject(Object v) {\n      return v;\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Object", "classes": []}, "name": "toCalciteObject", "params": [{"name": "v", "type": "Object"}], "body": "                                            {\n      return v;\n    }", "signature": "public Object toCalciteObject(Object v)"}, {"syntax_pass": true, "original_string": "    public Enumerable<Object[]> toCalciteEnumerable(Object v) {\n      @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n      final Enumerable<Object> enumerable = Linq4j.asEnumerable((List) v);\n      switch (morelType.op()) {\n      case LIST:\n        final ListType listType = (ListType) morelType;\n        final C2m c =\n            new C2m(calciteType.getComponentType(),\n                listType.elementType);\n        if (c.morelType instanceof PrimitiveType) {\n          if (c.calciteType.isStruct()) {\n            return EnumerableDefaults.select(enumerable, c::scalarToArray);\n          } else {\n            //noinspection unchecked\n            return (Enumerable) enumerable;\n          }\n        } else {\n          return EnumerableDefaults.select(enumerable, c::listToArray);\n        }\n      default:\n        throw new AssertionError(\"cannot convert \" + morelType);\n      }\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Enumerable<Object[]>", "classes": []}, "name": "toCalciteEnumerable", "params": [{"name": "v", "type": "Object"}], "body": "                                                              {\n      @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n      final Enumerable<Object> enumerable = Linq4j.asEnumerable((List) v);\n      switch (morelType.op()) {\n      case LIST:\n        final ListType listType = (ListType) morelType;\n        final C2m c =\n            new C2m(calciteType.getComponentType(),\n                listType.elementType);\n        if (c.morelType instanceof PrimitiveType) {\n          if (c.calciteType.isStruct()) {\n            return EnumerableDefaults.select(enumerable, c::scalarToArray);\n          } else {\n            //noinspection unchecked\n            return (Enumerable) enumerable;\n          }\n        } else {\n          return EnumerableDefaults.select(enumerable, c::listToArray);\n        }\n      default:\n        throw new AssertionError(\"cannot convert \" + morelType);\n      }\n    }", "signature": "public Enumerable<Object[]> toCalciteEnumerable(Object v)"}, {"syntax_pass": true, "original_string": "    private Object[] listToArray(Object o) {\n      @SuppressWarnings(\"unchecked\")\n      List<Object> list = (List<Object>) o;\n      return list.toArray();\n    }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "Object[]", "classes": []}, "name": "listToArray", "params": [{"name": "o", "type": "Object"}], "body": "                                           {\n      @SuppressWarnings(\"unchecked\")\n      List<Object> list = (List<Object>) o;\n      return list.toArray();\n    }", "signature": "private Object[] listToArray(Object o)"}, {"syntax_pass": true, "original_string": "    private Object[] scalarToArray(Object o) {\n      return new Object[] {o};\n    }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "Object[]", "classes": []}, "name": "scalarToArray", "params": [{"name": "o", "type": "Object"}], "body": "                                             {\n      return new Object[] {o};\n    }", "signature": "private Object[] scalarToArray(Object o)"}, {"syntax_pass": true, "original_string": "    public Function<Object, Object> toMorelObjectFunction() {\n      switch (morelType.op()) {\n      case TUPLE_TYPE:\n        final ImmutableList.Builder<Function<Object, Object>> b =\n            ImmutableList.builder();\n        forEach(calciteType.getFieldList(),\n            ((TupleType) morelType).argTypes, (field, argType) ->\n                b.add(new C2m(field.getType(), argType)\n                    .toMorelObjectFunction()));\n        final ImmutableList<Function<Object, Object>> converters = b.build();\n        return v -> {\n          final Object[] values = (Object[]) v;\n          return new AbstractList<Object>() {\n            @Override public int size() {\n              return values.length;\n            }\n\n            @Override public Object get(int index) {\n              return converters.get(index).apply(values[index]);\n            }\n          };\n        };\n\n      case ID: // primitive type, e.g. int\n        switch ((PrimitiveType) morelType) {\n        case INT:\n          return v -> ((Number) v).intValue();\n        default:\n          return v -> v;\n        }\n\n      default:\n        throw new AssertionError(\"unknown type \" + morelType);\n      }\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Function<Object, Object>", "classes": []}, "name": "toMorelObjectFunction", "params": [], "body": "                                                            {\n      switch (morelType.op()) {\n      case TUPLE_TYPE:\n        final ImmutableList.Builder<Function<Object, Object>> b =\n            ImmutableList.builder();\n        forEach(calciteType.getFieldList(),\n            ((TupleType) morelType).argTypes, (field, argType) ->\n                b.add(new C2m(field.getType(), argType)\n                    .toMorelObjectFunction()));\n        final ImmutableList<Function<Object, Object>> converters = b.build();\n        return v -> {\n          final Object[] values = (Object[]) v;\n          return new AbstractList<Object>() {\n            @Override public int size() {\n              return values.length;\n            }\n\n            @Override public Object get(int index) {\n              return converters.get(index).apply(values[index]);\n            }\n          };\n        };\n\n      case ID: // primitive type, e.g. int\n        switch ((PrimitiveType) morelType) {\n        case INT:\n          return v -> ((Number) v).intValue();\n        default:\n          return v -> v;\n        }\n\n      default:\n        throw new AssertionError(\"unknown type \" + morelType);\n      }\n    }", "signature": "public Function<Object, Object> toMorelObjectFunction()"}]}, {"original_string": "  private static class RecordConverter implements Converter<Object[]> {\n    final Object[] tempValues;\n    final ImmutableList<Converter<Object[]>> converterList;\n\n    RecordConverter(ImmutableList<Converter<Object[]>> converterList) {\n      tempValues = new Object[converterList.size()];\n      this.converterList = converterList;\n    }\n\n    @Override public List<Object> apply(Object[] a) {\n      for (int i = 0; i < tempValues.length; i++) {\n        tempValues[i] = converterList.get(i).apply(a);\n      }\n      return ImmutableNullableList.copyOf(tempValues);\n    }\n  }", "definition": "  private static class RecordConverter implements Converter<Object[]>", "class_docstring": " Converter that creates a record. Uses one sub-Converter per output\nfield.", "name": "RecordConverter", "super_interfaces": ["Converter<Object[]>"], "superclasses": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "fields": [{"attribute_expression": "final Object[] tempValues;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "Object[]", "name": "tempValues", "syntax_pass": true}, {"attribute_expression": "final ImmutableList<Converter<Object[]>> converterList;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "ImmutableList<Converter<Object[]>>", "name": "converterList", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    RecordConverter(ImmutableList<Converter<Object[]>> converterList) {\n      tempValues = new Object[converterList.size()];\n      this.converterList = converterList;\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "RecordConverter", "params": [{"name": "converterList", "type": "ImmutableList<Converter<Object[]>>"}], "body": "                                                                      {\n      tempValues = new Object[converterList.size()];\n      this.converterList = converterList;\n    }", "signature": "RecordConverter(ImmutableList<Converter<Object[]>> converterList)"}, {"syntax_pass": true, "original_string": "    @Override public List<Object> apply(Object[] a) {\n      for (int i = 0; i < tempValues.length; i++) {\n        tempValues[i] = converterList.get(i).apply(a);\n      }\n      return ImmutableNullableList.copyOf(tempValues);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "List<Object>", "classes": []}, "name": "apply", "params": [{"name": "a", "type": "Object[]"}], "body": "                                                    {\n      for (int i = 0; i < tempValues.length; i++) {\n        tempValues[i] = converterList.get(i).apply(a);\n      }\n      return ImmutableNullableList.copyOf(tempValues);\n    }", "signature": "@Override public List<Object> apply(Object[] a)"}]}], "class_docstring": " Utilities for Converter.", "original_string": "public class Converters {\n  private Converters() {\n  }\n\n  public static Converter<Object[]> ofRow(RelDataType rowType) {\n    final List<RelDataTypeField> fields = rowType.getFieldList();\n    final ImmutableList.Builder<Converter<Object[]>> converters =\n        ImmutableList.builder();\n    forEachIndexed(fields, (field, i) ->\n        converters.add(ofField(field.getType(), i)));\n    return new RecordConverter(converters.build());\n  }\n\n  public static Converter<Object[]> ofRow2(RelDataType rowType,\n      RecordLikeType type) {\n    return ofRow3(rowType.getFieldList().iterator(),\n        new AtomicInteger(), Linq4j.enumerator(type.argTypes()));\n  }\n\n  static Converter<Object[]> ofRow3(Iterator<RelDataTypeField> fields,\n      AtomicInteger ordinal, Enumerator<Type> types) {\n    final ImmutableList.Builder<Converter<Object[]>> converters =\n        ImmutableList.builder();\n    while (types.moveNext()) {\n      converters.add(ofField2(fields, ordinal, types.current()));\n    }\n    return new RecordConverter(converters.build());\n  }\n\n  public static Converter<Object[]> ofField(RelDataType type, int ordinal) {\n    final FieldConverter fieldConverter = FieldConverter.toType(type);\n    return values -> fieldConverter.convertFrom(values[ordinal]);\n  }\n\n  static Converter<Object[]> ofField2(Iterator<RelDataTypeField> fields,\n      AtomicInteger ordinal, Type type) {\n    final RelDataTypeField field = fields.next();\n    if (type instanceof RecordType) {\n      if (field.getType().isStruct()) {\n        return offset(ordinal.getAndIncrement(),\n            ofRow3(field.getType().getFieldList().iterator(),\n                new AtomicInteger(),\n                Linq4j.enumerator(((RecordType) type).argNameTypes.values())));\n      } else {\n        return ofRow3(fields, ordinal,\n            Linq4j.enumerator(((RecordType) type).argNameTypes.values()));\n      }\n    }\n    return ofField3(field, ordinal, type);\n  }\n\n  /** Creates a converter that applies to the {@code i}th field of the input\n   * array. */\n  static Converter<Object[]> offset(int i, Converter<Object[]> converter) {\n    return values -> converter.apply((Object[]) values[i]);\n  }\n\n  static Converter<Object[]> ofField3(RelDataTypeField field,\n      AtomicInteger ordinal, Type type) {\n    if (field.getType().isStruct()) {\n      return ofRow3(field.getType().getFieldList().iterator(), ordinal,\n          Linq4j.singletonEnumerator(type));\n    }\n    final FieldConverter fieldConverter =\n        FieldConverter.toType(field.getType());\n    final int i = ordinal.getAndIncrement();\n    return values -> fieldConverter.convertFrom(values[i]);\n  }\n\n  @SuppressWarnings(\"unchecked\")\n  public static Function<Enumerable<Object[]>, List<Object>>\n      fromEnumerable(RelNode rel, Type type) {\n    final ListType listType = (ListType) type;\n    final RelDataType rowType = rel.getRowType();\n    final Function<Object[], Object> elementConverter =\n        forType(rowType, listType.elementType);\n    return enumerable -> enumerable.select(elementConverter::apply).toList();\n  }\n\n  @SuppressWarnings(\"unchecked\")\n  public static <E> Function<E, Object> forType(RelDataType fromType, Type type) {\n    if (type == PrimitiveType.UNIT) {\n      return o -> Unit.INSTANCE;\n    }\n    if (type instanceof PrimitiveType) {\n      RelDataTypeField field =\n          Iterables.getOnlyElement(fromType.getFieldList());\n      return (Converter<E>) ofField(field.getType(), 0);\n    }\n    if (type instanceof RecordLikeType) {\n      return (Converter<E>) ofRow2(fromType, (RecordLikeType) type);\n    }\n    if (fromType.isNullable()) {\n      return o -> o == null ? BigDecimal.ZERO : o;\n    }\n    return o -> o;\n  }\n\n  public static Type fieldType(RelDataTypeField field) {\n    return FieldConverter.toType(field.getType()).mlType;\n  }\n\n  public static RelDataType toCalciteType(Type type,\n      RelDataTypeFactory typeFactory) {\n    return C2m.forMorel(type, typeFactory, false, true).calciteType;\n  }\n\n  /** Returns a function that converts from Morel objects to an Enumerable\n   * over Calcite rows. */\n  public static Function<Object, Enumerable<Object[]>> toCalciteEnumerable(\n      Type type, RelDataTypeFactory typeFactory) {\n    final C2m converter =\n        C2m.forMorel(type, typeFactory, false, false);\n    return converter::toCalciteEnumerable;\n  }\n\n  /** Returns a function that converts from Morel objects to Calcite objects. */\n  public static Function<Object, Object> toCalcite(Type type,\n      RelDataTypeFactory typeFactory) {\n    final C2m converter =\n        C2m.forMorel(type, typeFactory, false, true);\n    return converter::toCalciteObject;\n  }\n\n  /** Returns a function that converts from Calcite objects to Morel objects. */\n  public static Function<Object, Object> toMorel(Type type,\n      RelDataTypeFactory typeFactory) {\n    final C2m converter =\n        C2m.forMorel(type, typeFactory, false, true);\n    return converter.toMorelObjectFunction();\n  }\n\n  /** Converts a field from Calcite to Morel format. */\n  enum FieldConverter {\n    FROM_BOOLEAN(PrimitiveType.BOOL) {\n      public Boolean convertFrom(Object o) {\n        return (Boolean) o;\n      }\n    },\n    FROM_INTEGER(PrimitiveType.INT) {\n      public Integer convertFrom(Object o) {\n        return o == null ? 0 : ((Number) o).intValue();\n      }\n    },\n    FROM_FLOAT(PrimitiveType.REAL) {\n      public Float convertFrom(Object o) {\n        return o == null ? 0f : ((Number) o).floatValue();\n      }\n    },\n    FROM_DATE(PrimitiveType.STRING) {\n      public String convertFrom(Object o) {\n        return o == null ? \"\" : new Date(\n            (Integer) o * DateTimeUtils.MILLIS_PER_DAY).toString();\n      }\n    },\n    FROM_TIME(PrimitiveType.STRING) {\n      public String convertFrom(Object o) {\n        return o == null ? \"\" : new Time(\n            (Integer) o % DateTimeUtils.MILLIS_PER_DAY).toString();\n      }\n    },\n    FROM_TIMESTAMP(PrimitiveType.STRING) {\n      public String convertFrom(Object o) {\n        return o == null ? \"\" : new Timestamp((Long) o).toString();\n      }\n    },\n    FROM_STRING(PrimitiveType.STRING) {\n      public String convertFrom(Object o) {\n        return o == null ? \"\" : (String) o;\n      }\n    };\n\n    final Type mlType;\n\n    FieldConverter(Type mlType) {\n      this.mlType = mlType;\n    }\n\n    /** Given a Calcite row, returns the value of this field in SML format. */\n    public abstract Object convertFrom(Object sourceValue);\n\n    static FieldConverter toType(RelDataType type) {\n      switch (type.getSqlTypeName()) {\n      case BOOLEAN:\n        return FROM_BOOLEAN;\n\n      case TINYINT:\n      case SMALLINT:\n      case INTEGER:\n      case BIGINT:\n        return FROM_INTEGER;\n\n      case FLOAT:\n      case REAL:\n      case DOUBLE:\n      case DECIMAL:\n        return FROM_FLOAT;\n\n      case DATE:\n        return FROM_DATE;\n\n      case TIME:\n        return FROM_TIME;\n\n      case TIMESTAMP:\n        return FROM_TIMESTAMP;\n\n      case VARCHAR:\n      case CHAR:\n      default:\n        return FROM_STRING;\n      }\n    }\n  }\n\n  /** Converter from Calcite types to Morel types. */\n  private static class C2m {\n    final RelDataType calciteType;\n    final Type morelType;\n\n    C2m(RelDataType calciteType, Type morelType) {\n      this.calciteType = calciteType;\n      this.morelType = morelType;\n    }\n\n    /** Creates a converter for a given Morel type, in the process deducing the\n     * corresponding Calcite type. */\n    static C2m forMorel(Type type, RelDataTypeFactory typeFactory,\n        boolean nullable, boolean recordList) {\n      final RelDataTypeFactory.Builder typeBuilder;\n      switch (type.op()) {\n      case DATA_TYPE:\n        final DataType dataType = (DataType) type;\n        if (dataType.name.equals(\"option\")) {\n          return forMorel(dataType.parameterTypes.get(0), typeFactory, true,\n              false);\n        }\n        throw new AssertionError(\"unknown type \" + type);\n\n      case FUNCTION_TYPE:\n        // Represent Morel functions (and closures) as SQL type ANY. UDFs have a\n        // parameter of type Object, and the value is cast to Closure.\n        return new C2m(typeFactory.createSqlType(SqlTypeName.ANY), type);\n\n      case LIST:\n        final ListType listType = (ListType) type;\n        RelDataType elementType =\n            forMorel(listType.elementType, typeFactory, nullable, false)\n                .calciteType;\n        if (recordList && !elementType.isStruct()) {\n          elementType = typeFactory.builder()\n              .add(\"1\", elementType)\n              .build();\n        }\n        return new C2m(\n            typeFactory.createMultisetType(elementType, -1),\n            type);\n\n      case RECORD_TYPE:\n      case TUPLE_TYPE:\n        typeBuilder = typeFactory.builder();\n        final RecordLikeType recordType = (RecordLikeType) type;\n        recordType.argNameTypes().forEach((name, argType) ->\n            typeBuilder.add(name,\n                forMorel(argType, typeFactory, nullable, recordList)\n                    .calciteType));\n        return new C2m(typeBuilder.build(), type);\n\n      case TY_VAR:\n        // The reason that a type variable is present is because the type\n        // doesn't matter. For example, in 'map (fn x => 1) []' it doesn't\n        // matter what the element type of the empty list is, because the\n        // lambda doesn't look at the elements. So, pretend the type is 'bool'.\n        type = PrimitiveType.BOOL;\n        // fall through\n\n      case ID:\n        final PrimitiveType primitiveType = (PrimitiveType) type;\n        switch (primitiveType) {\n        case BOOL:\n          return new C2m(\n              typeFactory.createTypeWithNullability(\n                  typeFactory.createSqlType(SqlTypeName.BOOLEAN), nullable),\n              type);\n        case INT:\n          return new C2m(\n              typeFactory.createTypeWithNullability(\n                  typeFactory.createSqlType(SqlTypeName.INTEGER), nullable),\n              type);\n        case REAL:\n          return new C2m(\n              typeFactory.createTypeWithNullability(\n                  typeFactory.createSqlType(SqlTypeName.REAL), nullable),\n              type);\n        case CHAR:\n          return new C2m(\n              typeFactory.createTypeWithNullability(\n                  typeFactory.createSqlType(SqlTypeName.SMALLINT), nullable),\n              type);\n        case UNIT:\n          return new C2m(\n              typeFactory.createTypeWithNullability(\n              typeFactory.createSqlType(SqlTypeName.TINYINT), nullable),\n              type);\n        case STRING:\n          return new C2m(\n              typeFactory.createTypeWithNullability(\n                  typeFactory.createSqlType(SqlTypeName.VARCHAR, -1), nullable),\n              type);\n        default:\n          throw new AssertionError(\"unknown type \" + type);\n        }\n\n      default:\n        throw new UnsupportedOperationException(\"cannot convert type \" + type);\n      }\n    }\n\n    public Object toCalciteObject(Object v) {\n      return v;\n    }\n\n    public Enumerable<Object[]> toCalciteEnumerable(Object v) {\n      @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n      final Enumerable<Object> enumerable = Linq4j.asEnumerable((List) v);\n      switch (morelType.op()) {\n      case LIST:\n        final ListType listType = (ListType) morelType;\n        final C2m c =\n            new C2m(calciteType.getComponentType(),\n                listType.elementType);\n        if (c.morelType instanceof PrimitiveType) {\n          if (c.calciteType.isStruct()) {\n            return EnumerableDefaults.select(enumerable, c::scalarToArray);\n          } else {\n            //noinspection unchecked\n            return (Enumerable) enumerable;\n          }\n        } else {\n          return EnumerableDefaults.select(enumerable, c::listToArray);\n        }\n      default:\n        throw new AssertionError(\"cannot convert \" + morelType);\n      }\n    }\n\n    private Object[] listToArray(Object o) {\n      @SuppressWarnings(\"unchecked\")\n      List<Object> list = (List<Object>) o;\n      return list.toArray();\n    }\n\n    private Object[] scalarToArray(Object o) {\n      return new Object[] {o};\n    }\n\n    public Function<Object, Object> toMorelObjectFunction() {\n      switch (morelType.op()) {\n      case TUPLE_TYPE:\n        final ImmutableList.Builder<Function<Object, Object>> b =\n            ImmutableList.builder();\n        forEach(calciteType.getFieldList(),\n            ((TupleType) morelType).argTypes, (field, argType) ->\n                b.add(new C2m(field.getType(), argType)\n                    .toMorelObjectFunction()));\n        final ImmutableList<Function<Object, Object>> converters = b.build();\n        return v -> {\n          final Object[] values = (Object[]) v;\n          return new AbstractList<Object>() {\n            @Override public int size() {\n              return values.length;\n            }\n\n            @Override public Object get(int index) {\n              return converters.get(index).apply(values[index]);\n            }\n          };\n        };\n\n      case ID: // primitive type, e.g. int\n        switch ((PrimitiveType) morelType) {\n        case INT:\n          return v -> ((Number) v).intValue();\n        default:\n          return v -> v;\n        }\n\n      default:\n        throw new AssertionError(\"unknown type \" + morelType);\n      }\n    }\n  }\n\n  /** Converter that creates a record. Uses one sub-Converter per output\n   * field. */\n  private static class RecordConverter implements Converter<Object[]> {\n    final Object[] tempValues;\n    final ImmutableList<Converter<Object[]>> converterList;\n\n    RecordConverter(ImmutableList<Converter<Object[]>> converterList) {\n      tempValues = new Object[converterList.size()];\n      this.converterList = converterList;\n    }\n\n    @Override public List<Object> apply(Object[] a) {\n      for (int i = 0; i < tempValues.length; i++) {\n        tempValues[i] = converterList.get(i).apply(a);\n      }\n      return ImmutableNullableList.copyOf(tempValues);\n    }\n  }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/main/java/net/hydromatic/morel/foreign/CalciteFunctions.java.CalciteFunctions", "name": "CalciteFunctions", "file_path": "src/main/java/net/hydromatic/morel/foreign/CalciteFunctions.java", "superclasses": "", "methods": ["[]CalciteFunctions()", "[RelDataType]inferReturnType(SqlOperatorBinding)"], "method_uris": ["src/main/java/net/hydromatic/morel/foreign/CalciteFunctions.java.CalciteFunctions.[]CalciteFunctions()", "src/main/java/net/hydromatic/morel/foreign/CalciteFunctions.java.CalciteFunctions.[RelDataType]inferReturnType(SqlOperatorBinding)"], "overrides": null, "attributes": [{"original_string": "  public static class MorelTableFunction {\n    private final Context cx = THREAD_ENV.get();\n    private final Compiled compiled;\n\n    public MorelTableFunction(org.apache.calcite.plan.Context context) {\n      final List<Object> args = context.unwrap(List.class);\n      if (args != null) {\n        String ml = (String) args.get(0);\n        String typeJson = (String) args.get(1);\n        compiled =\n            Compiled.create(ml, typeJson, cx.typeFactory, cx.env, cx.typeSystem,\n                cx.session);\n      } else {\n        compiled = null;\n      }\n    }\n\n    @SuppressWarnings(\"unused\") // called via reflection\n    public MorelTableFunction() {\n      this(Contexts.EMPTY_CONTEXT);\n    }\n\n    @SuppressWarnings(\"unused\") // called via reflection\n    public ScannableTable eval(String ml, String typeJson) {\n      final Compiled compiled =\n          this.compiled != null ? this.compiled\n              : Compiled.create(ml, typeJson, cx.typeFactory, cx.env,\n                  cx.typeSystem, cx.session);\n      return new ScannableTable() {\n        @Override public RelDataType getRowType(RelDataTypeFactory factory) {\n          try {\n            return RelJsonReader.readType(factory, typeJson);\n          } catch (IOException e) {\n            throw new RuntimeException(e);\n          }\n        }\n\n        @Override public Enumerable<Object[]> scan(DataContext root) {\n          Object v = compiled.code.eval(compiled.evalEnv);\n          return compiled.f.apply(v);\n        }\n\n        @Override public Statistic getStatistic() {\n          return Statistics.UNKNOWN;\n        }\n\n        @Override public Schema.TableType getJdbcTableType() {\n          return Schema.TableType.OTHER;\n        }\n\n        @Override public boolean isRolledUp(String column) {\n          return false;\n        }\n\n        @Override public boolean rolledUpColumnValidInsideAgg(String column,\n            SqlCall call, SqlNode parent, CalciteConnectionConfig config) {\n          return false;\n        }\n      };\n    }\n\n    /** Compiled state. */\n    private static class Compiled {\n      final Code code;\n      final EvalEnv evalEnv;\n      final Function<Object, Enumerable<Object[]>> f;\n\n      Compiled(String ml, Code code, EvalEnv evalEnv,\n          Function<Object, Enumerable<Object[]>> f) {\n        this.code = code;\n        this.evalEnv = evalEnv;\n        this.f = f;\n      }\n\n      static Compiled create(String ml, String typeJson,\n          RelDataTypeFactory typeFactory, Environment env,\n          TypeSystem typeSystem, Session session) {\n        final Ast.Exp exp;\n        try {\n          exp = new MorelParserImpl(new StringReader(ml)).expression();\n        } catch (ParseException pe) {\n          throw new RuntimeException(\"Error while parsing\\n\"\n              + ml, pe);\n        }\n        final Ast.ValDecl valDecl = Compiles.toValDecl(exp);\n        final TypeResolver.Resolved resolved =\n            TypeResolver.deduceType(env, valDecl, typeSystem);\n        final Ast.ValDecl valDecl2 = (Ast.ValDecl) resolved.node;\n        final Core.NonRecValDecl valDecl3 =\n            (Core.NonRecValDecl)\n                Resolver.of(resolved.typeMap, env, session)\n                    .toCore(valDecl2);\n        final Core.Exp e3 = Compiles.toExp(valDecl3);\n        final Compiler compiler = new Compiler(typeSystem);\n        return new Compiled(ml, compiler.compile(env, e3),\n            Codes.emptyEnvWith(session, env),\n            Converters.toCalciteEnumerable(e3.type, typeFactory));\n      }\n    }\n  }", "definition": "  public static class MorelTableFunction", "class_docstring": " Calcite user-defined function that evaluates a Morel string and\nreturns a table.", "name": "MorelTableFunction", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [{"attribute_expression": "private final Context cx = THREAD_ENV.get();", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Context", "name": "cx = THREAD_ENV.get()", "syntax_pass": true}, {"attribute_expression": "private final Compiled compiled;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Compiled", "name": "compiled", "syntax_pass": true}], "classes": [{"original_string": "    private static class Compiled {\n      final Code code;\n      final EvalEnv evalEnv;\n      final Function<Object, Enumerable<Object[]>> f;\n\n      Compiled(String ml, Code code, EvalEnv evalEnv,\n          Function<Object, Enumerable<Object[]>> f) {\n        this.code = code;\n        this.evalEnv = evalEnv;\n        this.f = f;\n      }\n\n      static Compiled create(String ml, String typeJson,\n          RelDataTypeFactory typeFactory, Environment env,\n          TypeSystem typeSystem, Session session) {\n        final Ast.Exp exp;\n        try {\n          exp = new MorelParserImpl(new StringReader(ml)).expression();\n        } catch (ParseException pe) {\n          throw new RuntimeException(\"Error while parsing\\n\"\n              + ml, pe);\n        }\n        final Ast.ValDecl valDecl = Compiles.toValDecl(exp);\n        final TypeResolver.Resolved resolved =\n            TypeResolver.deduceType(env, valDecl, typeSystem);\n        final Ast.ValDecl valDecl2 = (Ast.ValDecl) resolved.node;\n        final Core.NonRecValDecl valDecl3 =\n            (Core.NonRecValDecl)\n                Resolver.of(resolved.typeMap, env, session)\n                    .toCore(valDecl2);\n        final Core.Exp e3 = Compiles.toExp(valDecl3);\n        final Compiler compiler = new Compiler(typeSystem);\n        return new Compiled(ml, compiler.compile(env, e3),\n            Codes.emptyEnvWith(session, env),\n            Converters.toCalciteEnumerable(e3.type, typeFactory));\n      }\n    }", "definition": "    private static class Compiled", "class_docstring": " Compiled state.", "name": "Compiled", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "fields": [{"attribute_expression": "final Code code;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "Code", "name": "code", "syntax_pass": true}, {"attribute_expression": "final EvalEnv evalEnv;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "EvalEnv", "name": "evalEnv", "syntax_pass": true}, {"attribute_expression": "final Function<Object, Enumerable<Object[]>> f;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "Function<Object, Enumerable<Object[]>>", "name": "f", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "      Compiled(String ml, Code code, EvalEnv evalEnv,\n          Function<Object, Enumerable<Object[]>> f) {\n        this.code = code;\n        this.evalEnv = evalEnv;\n        this.f = f;\n      }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "Compiled", "params": [{"name": "ml", "type": "String"}, {"name": "code", "type": "Code"}, {"name": "evalEnv", "type": "EvalEnv"}, {"name": "f", "type": "Function<Object, Enumerable<Object[]>>"}], "body": "                                                    {\n        this.code = code;\n        this.evalEnv = evalEnv;\n        this.f = f;\n      }", "signature": "Compiled(String ml, Code code, EvalEnv evalEnv,\n          Function<Object, Enumerable<Object[]>> f)"}, {"syntax_pass": true, "original_string": "      static Compiled create(String ml, String typeJson,\n          RelDataTypeFactory typeFactory, Environment env,\n          TypeSystem typeSystem, Session session) {\n        final Ast.Exp exp;\n        try {\n          exp = new MorelParserImpl(new StringReader(ml)).expression();\n        } catch (ParseException pe) {\n          throw new RuntimeException(\"Error while parsing\\n\"\n              + ml, pe);\n        }\n        final Ast.ValDecl valDecl = Compiles.toValDecl(exp);\n        final TypeResolver.Resolved resolved =\n            TypeResolver.deduceType(env, valDecl, typeSystem);\n        final Ast.ValDecl valDecl2 = (Ast.ValDecl) resolved.node;\n        final Core.NonRecValDecl valDecl3 =\n            (Core.NonRecValDecl)\n                Resolver.of(resolved.typeMap, env, session)\n                    .toCore(valDecl2);\n        final Core.Exp e3 = Compiles.toExp(valDecl3);\n        final Compiler compiler = new Compiler(typeSystem);\n        return new Compiled(ml, compiler.compile(env, e3),\n            Codes.emptyEnvWith(session, env),\n            Converters.toCalciteEnumerable(e3.type, typeFactory));\n      }", "docstring": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "Compiled", "classes": []}, "name": "create", "params": [{"name": "ml", "type": "String"}, {"name": "typeJson", "type": "String"}, {"name": "typeFactory", "type": "RelDataTypeFactory"}, {"name": "env", "type": "Environment"}, {"name": "typeSystem", "type": "TypeSystem"}, {"name": "session", "type": "Session"}], "body": "                                                  {\n        final Ast.Exp exp;\n        try {\n          exp = new MorelParserImpl(new StringReader(ml)).expression();\n        } catch (ParseException pe) {\n          throw new RuntimeException(\"Error while parsing\\n\"\n              + ml, pe);\n        }\n        final Ast.ValDecl valDecl = Compiles.toValDecl(exp);\n        final TypeResolver.Resolved resolved =\n            TypeResolver.deduceType(env, valDecl, typeSystem);\n        final Ast.ValDecl valDecl2 = (Ast.ValDecl) resolved.node;\n        final Core.NonRecValDecl valDecl3 =\n            (Core.NonRecValDecl)\n                Resolver.of(resolved.typeMap, env, session)\n                    .toCore(valDecl2);\n        final Core.Exp e3 = Compiles.toExp(valDecl3);\n        final Compiler compiler = new Compiler(typeSystem);\n        return new Compiled(ml, compiler.compile(env, e3),\n            Codes.emptyEnvWith(session, env),\n            Converters.toCalciteEnumerable(e3.type, typeFactory));\n      }", "signature": "static Compiled create(String ml, String typeJson,\n          RelDataTypeFactory typeFactory, Environment env,\n          TypeSystem typeSystem, Session session)"}]}]}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    public MorelTableFunction(org.apache.calcite.plan.Context context) {\n      final List<Object> args = context.unwrap(List.class);\n      if (args != null) {\n        String ml = (String) args.get(0);\n        String typeJson = (String) args.get(1);\n        compiled =\n            Compiled.create(ml, typeJson, cx.typeFactory, cx.env, cx.typeSystem,\n                cx.session);\n      } else {\n        compiled = null;\n      }\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "MorelTableFunction", "params": [{"name": "context", "type": "org.apache.calcite.plan.Context"}], "body": "                                                                       {\n      final List<Object> args = context.unwrap(List.class);\n      if (args != null) {\n        String ml = (String) args.get(0);\n        String typeJson = (String) args.get(1);\n        compiled =\n            Compiled.create(ml, typeJson, cx.typeFactory, cx.env, cx.typeSystem,\n                cx.session);\n      } else {\n        compiled = null;\n      }\n    }", "signature": "public MorelTableFunction(org.apache.calcite.plan.Context context)"}, {"syntax_pass": true, "original_string": "    @SuppressWarnings(\"unused\") // called via reflection\n    public MorelTableFunction() {\n      this(Contexts.EMPTY_CONTEXT);\n    }", "docstring": "", "attributes": {"modifiers": "@SuppressWarnings(\"unused\") // called via reflection\n    public", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings(\"unused\")", "public"], "comments": ["// called via reflection"], "return_type": "", "classes": []}, "name": "MorelTableFunction", "params": [], "body": "                                {\n      this(Contexts.EMPTY_CONTEXT);\n    }", "signature": "@SuppressWarnings(\"unused\") // called via reflection\n    public MorelTableFunction()"}, {"syntax_pass": true, "original_string": "    @SuppressWarnings(\"unused\") // called via reflection\n    public ScannableTable eval(String ml, String typeJson) {\n      final Compiled compiled =\n          this.compiled != null ? this.compiled\n              : Compiled.create(ml, typeJson, cx.typeFactory, cx.env,\n                  cx.typeSystem, cx.session);\n      return new ScannableTable() {\n        @Override public RelDataType getRowType(RelDataTypeFactory factory) {\n          try {\n            return RelJsonReader.readType(factory, typeJson);\n          } catch (IOException e) {\n            throw new RuntimeException(e);\n          }\n        }\n\n        @Override public Enumerable<Object[]> scan(DataContext root) {\n          Object v = compiled.code.eval(compiled.evalEnv);\n          return compiled.f.apply(v);\n        }\n\n        @Override public Statistic getStatistic() {\n          return Statistics.UNKNOWN;\n        }\n\n        @Override public Schema.TableType getJdbcTableType() {\n          return Schema.TableType.OTHER;\n        }\n\n        @Override public boolean isRolledUp(String column) {\n          return false;\n        }\n\n        @Override public boolean rolledUpColumnValidInsideAgg(String column,\n            SqlCall call, SqlNode parent, CalciteConnectionConfig config) {\n          return false;\n        }\n      };\n    }", "docstring": "", "attributes": {"modifiers": "@SuppressWarnings(\"unused\") // called via reflection\n    public", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings(\"unused\")", "public"], "comments": ["// called via reflection"], "return_type": "ScannableTable", "classes": []}, "name": "eval", "params": [{"name": "ml", "type": "String"}, {"name": "typeJson", "type": "String"}], "body": "                                                           {\n      final Compiled compiled =\n          this.compiled != null ? this.compiled\n              : Compiled.create(ml, typeJson, cx.typeFactory, cx.env,\n                  cx.typeSystem, cx.session);\n      return new ScannableTable() {\n        @Override public RelDataType getRowType(RelDataTypeFactory factory) {\n          try {\n            return RelJsonReader.readType(factory, typeJson);\n          } catch (IOException e) {\n            throw new RuntimeException(e);\n          }\n        }\n\n        @Override public Enumerable<Object[]> scan(DataContext root) {\n          Object v = compiled.code.eval(compiled.evalEnv);\n          return compiled.f.apply(v);\n        }\n\n        @Override public Statistic getStatistic() {\n          return Statistics.UNKNOWN;\n        }\n\n        @Override public Schema.TableType getJdbcTableType() {\n          return Schema.TableType.OTHER;\n        }\n\n        @Override public boolean isRolledUp(String column) {\n          return false;\n        }\n\n        @Override public boolean rolledUpColumnValidInsideAgg(String column,\n            SqlCall call, SqlNode parent, CalciteConnectionConfig config) {\n          return false;\n        }\n      };\n    }", "signature": "@SuppressWarnings(\"unused\") // called via reflection\n    public ScannableTable eval(String ml, String typeJson)"}]}, {"original_string": "  public static class MorelScalarFunction {\n    private final Context cx = THREAD_ENV.get();\n    private final Compiled compiled;\n\n    public MorelScalarFunction(org.apache.calcite.plan.Context context) {\n      final List<Object> args = context.unwrap(List.class);\n      if (args != null) {\n        compiled = new Compiled(cx.env, cx.typeSystem, cx.typeFactory,\n            (String) args.get(0), (String) args.get(1));\n      } else {\n        compiled = null;\n      }\n    }\n\n    @SuppressWarnings(\"unused\") // called via reflection\n    public MorelScalarFunction() {\n      this(Contexts.EMPTY_CONTEXT);\n    }\n\n    @SuppressWarnings(\"unused\") // called via reflection\n    public Object eval(String ml, String typeJson) {\n      final Compiled compiled =\n          this.compiled != null ? this.compiled\n              : new Compiled(cx.env, cx.typeSystem, cx.typeFactory, ml,\n                  typeJson);\n      final EvalEnv evalEnv = THREAD_EVAL_ENV.get();\n      Object v = compiled.code.eval(evalEnv);\n      return compiled.f.apply(v);\n    }\n\n    /** Compiled state. */\n    private static class Compiled {\n      final Code code;\n      final Function<Object, Object> f;\n\n      Compiled(Environment env, TypeSystem typeSystem,\n          RelDataTypeFactory typeFactory, String ml, String typeJson) {\n        final Ast.Exp exp;\n        try {\n          exp = new MorelParserImpl(new StringReader(ml)).expression();\n        } catch (ParseException pe) {\n          throw new RuntimeException(pe);\n        }\n        final Ast.ValDecl valDecl = Compiles.toValDecl(exp);\n        final TypeResolver.Resolved resolved =\n            TypeResolver.deduceType(env, valDecl, typeSystem);\n        final Ast.ValDecl valDecl2 = (Ast.ValDecl) resolved.node;\n        final Core.NonRecValDecl valDecl3 = (Core.NonRecValDecl)\n            Resolver.of(resolved.typeMap, env, null).toCore(valDecl2);\n        final Core.Exp e3 = Compiles.toExp(valDecl3);\n        code = new Compiler(typeSystem).compile(env, e3);\n        f = Converters.toCalcite(e3.type, typeFactory);\n      }\n    }\n  }", "definition": "  public static class MorelScalarFunction", "class_docstring": " Calcite user-defined function that evaluates a Morel string and returns\na scalar value.", "name": "MorelScalarFunction", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [{"attribute_expression": "private final Context cx = THREAD_ENV.get();", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Context", "name": "cx = THREAD_ENV.get()", "syntax_pass": true}, {"attribute_expression": "private final Compiled compiled;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Compiled", "name": "compiled", "syntax_pass": true}], "classes": [{"original_string": "    private static class Compiled {\n      final Code code;\n      final Function<Object, Object> f;\n\n      Compiled(Environment env, TypeSystem typeSystem,\n          RelDataTypeFactory typeFactory, String ml, String typeJson) {\n        final Ast.Exp exp;\n        try {\n          exp = new MorelParserImpl(new StringReader(ml)).expression();\n        } catch (ParseException pe) {\n          throw new RuntimeException(pe);\n        }\n        final Ast.ValDecl valDecl = Compiles.toValDecl(exp);\n        final TypeResolver.Resolved resolved =\n            TypeResolver.deduceType(env, valDecl, typeSystem);\n        final Ast.ValDecl valDecl2 = (Ast.ValDecl) resolved.node;\n        final Core.NonRecValDecl valDecl3 = (Core.NonRecValDecl)\n            Resolver.of(resolved.typeMap, env, null).toCore(valDecl2);\n        final Core.Exp e3 = Compiles.toExp(valDecl3);\n        code = new Compiler(typeSystem).compile(env, e3);\n        f = Converters.toCalcite(e3.type, typeFactory);\n      }\n    }", "definition": "    private static class Compiled", "class_docstring": " Compiled state.", "name": "Compiled", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "fields": [{"attribute_expression": "final Code code;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "Code", "name": "code", "syntax_pass": true}, {"attribute_expression": "final Function<Object, Object> f;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "Function<Object, Object>", "name": "f", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "      Compiled(Environment env, TypeSystem typeSystem,\n          RelDataTypeFactory typeFactory, String ml, String typeJson) {\n        final Ast.Exp exp;\n        try {\n          exp = new MorelParserImpl(new StringReader(ml)).expression();\n        } catch (ParseException pe) {\n          throw new RuntimeException(pe);\n        }\n        final Ast.ValDecl valDecl = Compiles.toValDecl(exp);\n        final TypeResolver.Resolved resolved =\n            TypeResolver.deduceType(env, valDecl, typeSystem);\n        final Ast.ValDecl valDecl2 = (Ast.ValDecl) resolved.node;\n        final Core.NonRecValDecl valDecl3 = (Core.NonRecValDecl)\n            Resolver.of(resolved.typeMap, env, null).toCore(valDecl2);\n        final Core.Exp e3 = Compiles.toExp(valDecl3);\n        code = new Compiler(typeSystem).compile(env, e3);\n        f = Converters.toCalcite(e3.type, typeFactory);\n      }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "Compiled", "params": [{"name": "env", "type": "Environment"}, {"name": "typeSystem", "type": "TypeSystem"}, {"name": "typeFactory", "type": "RelDataTypeFactory"}, {"name": "ml", "type": "String"}, {"name": "typeJson", "type": "String"}], "body": "                                                                      {\n        final Ast.Exp exp;\n        try {\n          exp = new MorelParserImpl(new StringReader(ml)).expression();\n        } catch (ParseException pe) {\n          throw new RuntimeException(pe);\n        }\n        final Ast.ValDecl valDecl = Compiles.toValDecl(exp);\n        final TypeResolver.Resolved resolved =\n            TypeResolver.deduceType(env, valDecl, typeSystem);\n        final Ast.ValDecl valDecl2 = (Ast.ValDecl) resolved.node;\n        final Core.NonRecValDecl valDecl3 = (Core.NonRecValDecl)\n            Resolver.of(resolved.typeMap, env, null).toCore(valDecl2);\n        final Core.Exp e3 = Compiles.toExp(valDecl3);\n        code = new Compiler(typeSystem).compile(env, e3);\n        f = Converters.toCalcite(e3.type, typeFactory);\n      }", "signature": "Compiled(Environment env, TypeSystem typeSystem,\n          RelDataTypeFactory typeFactory, String ml, String typeJson)"}]}]}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    public MorelScalarFunction(org.apache.calcite.plan.Context context) {\n      final List<Object> args = context.unwrap(List.class);\n      if (args != null) {\n        compiled = new Compiled(cx.env, cx.typeSystem, cx.typeFactory,\n            (String) args.get(0), (String) args.get(1));\n      } else {\n        compiled = null;\n      }\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "MorelScalarFunction", "params": [{"name": "context", "type": "org.apache.calcite.plan.Context"}], "body": "                                                                        {\n      final List<Object> args = context.unwrap(List.class);\n      if (args != null) {\n        compiled = new Compiled(cx.env, cx.typeSystem, cx.typeFactory,\n            (String) args.get(0), (String) args.get(1));\n      } else {\n        compiled = null;\n      }\n    }", "signature": "public MorelScalarFunction(org.apache.calcite.plan.Context context)"}, {"syntax_pass": true, "original_string": "    @SuppressWarnings(\"unused\") // called via reflection\n    public MorelScalarFunction() {\n      this(Contexts.EMPTY_CONTEXT);\n    }", "docstring": "", "attributes": {"modifiers": "@SuppressWarnings(\"unused\") // called via reflection\n    public", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings(\"unused\")", "public"], "comments": ["// called via reflection"], "return_type": "", "classes": []}, "name": "MorelScalarFunction", "params": [], "body": "                                 {\n      this(Contexts.EMPTY_CONTEXT);\n    }", "signature": "@SuppressWarnings(\"unused\") // called via reflection\n    public MorelScalarFunction()"}, {"syntax_pass": true, "original_string": "    @SuppressWarnings(\"unused\") // called via reflection\n    public Object eval(String ml, String typeJson) {\n      final Compiled compiled =\n          this.compiled != null ? this.compiled\n              : new Compiled(cx.env, cx.typeSystem, cx.typeFactory, ml,\n                  typeJson);\n      final EvalEnv evalEnv = THREAD_EVAL_ENV.get();\n      Object v = compiled.code.eval(evalEnv);\n      return compiled.f.apply(v);\n    }", "docstring": "", "attributes": {"modifiers": "@SuppressWarnings(\"unused\") // called via reflection\n    public", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings(\"unused\")", "public"], "comments": ["// called via reflection"], "return_type": "Object", "classes": []}, "name": "eval", "params": [{"name": "ml", "type": "String"}, {"name": "typeJson", "type": "String"}], "body": "                                                   {\n      final Compiled compiled =\n          this.compiled != null ? this.compiled\n              : new Compiled(cx.env, cx.typeSystem, cx.typeFactory, ml,\n                  typeJson);\n      final EvalEnv evalEnv = THREAD_EVAL_ENV.get();\n      Object v = compiled.code.eval(evalEnv);\n      return compiled.f.apply(v);\n    }", "signature": "@SuppressWarnings(\"unused\") // called via reflection\n    public Object eval(String ml, String typeJson)"}]}, {"original_string": "  public static class MorelApplyFunction {\n    final Context cx = THREAD_ENV.get();\n    final Compiled compiled;\n\n    public MorelApplyFunction(org.apache.calcite.plan.Context context) {\n      final List<Object> args = context.unwrap(List.class);\n      if (args != null) {\n        final String morelArgTypeJson = (String) args.get(0);\n        compiled = new Compiled(morelArgTypeJson, cx.typeFactory, cx.typeSystem);\n      } else {\n        compiled = null;\n      }\n    }\n\n    @SuppressWarnings(\"unused\") // called via reflection\n    public MorelApplyFunction() {\n      this(Contexts.EMPTY_CONTEXT);\n    }\n\n    @SuppressWarnings(\"unused\") // called via reflection\n    public Object eval(String morelArgTypeJson, Object closure, Object arg) {\n      final Compiled compiled =\n          this.compiled != null ? this.compiled\n              : new Compiled(morelArgTypeJson, cx.typeFactory, cx.typeSystem);\n      final Closure fn = (Closure) closure;\n      final EvalEnv evalEnv = THREAD_EVAL_ENV.get();\n      final Object o = compiled.converter.apply(arg);\n      return fn.apply(evalEnv, o);\n    }\n\n    /** Compiled state. */\n    private static class Compiled {\n      final Function<Object, Object> converter;\n\n      Compiled(String morelArgType, RelDataTypeFactory typeFactory,\n          TypeSystem typeSystem) {\n        Ast.Type typeAst;\n        try {\n          typeAst = new MorelParserImpl(new StringReader(morelArgType)).type();\n        } catch (ParseException pe) {\n          throw new RuntimeException(pe);\n        }\n        final Type argType = TypeResolver.toType(typeAst, typeSystem);\n        converter = Converters.toMorel(argType, typeFactory);\n      }\n    }\n  }", "definition": "  public static class MorelApplyFunction", "class_docstring": " Calcite user-defined function that applies a Morel function (or closure)\nto an argument.", "name": "MorelApplyFunction", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [{"attribute_expression": "final Context cx = THREAD_ENV.get();", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "Context", "name": "cx = THREAD_ENV.get()", "syntax_pass": true}, {"attribute_expression": "final Compiled compiled;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "Compiled", "name": "compiled", "syntax_pass": true}], "classes": [{"original_string": "    private static class Compiled {\n      final Function<Object, Object> converter;\n\n      Compiled(String morelArgType, RelDataTypeFactory typeFactory,\n          TypeSystem typeSystem) {\n        Ast.Type typeAst;\n        try {\n          typeAst = new MorelParserImpl(new StringReader(morelArgType)).type();\n        } catch (ParseException pe) {\n          throw new RuntimeException(pe);\n        }\n        final Type argType = TypeResolver.toType(typeAst, typeSystem);\n        converter = Converters.toMorel(argType, typeFactory);\n      }\n    }", "definition": "    private static class Compiled", "class_docstring": " Compiled state.", "name": "Compiled", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "fields": [{"attribute_expression": "final Function<Object, Object> converter;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "Function<Object, Object>", "name": "converter", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "      Compiled(String morelArgType, RelDataTypeFactory typeFactory,\n          TypeSystem typeSystem) {\n        Ast.Type typeAst;\n        try {\n          typeAst = new MorelParserImpl(new StringReader(morelArgType)).type();\n        } catch (ParseException pe) {\n          throw new RuntimeException(pe);\n        }\n        final Type argType = TypeResolver.toType(typeAst, typeSystem);\n        converter = Converters.toMorel(argType, typeFactory);\n      }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "Compiled", "params": [{"name": "morelArgType", "type": "String"}, {"name": "typeFactory", "type": "RelDataTypeFactory"}, {"name": "typeSystem", "type": "TypeSystem"}], "body": "                                 {\n        Ast.Type typeAst;\n        try {\n          typeAst = new MorelParserImpl(new StringReader(morelArgType)).type();\n        } catch (ParseException pe) {\n          throw new RuntimeException(pe);\n        }\n        final Type argType = TypeResolver.toType(typeAst, typeSystem);\n        converter = Converters.toMorel(argType, typeFactory);\n      }", "signature": "Compiled(String morelArgType, RelDataTypeFactory typeFactory,\n          TypeSystem typeSystem)"}]}]}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    public MorelApplyFunction(org.apache.calcite.plan.Context context) {\n      final List<Object> args = context.unwrap(List.class);\n      if (args != null) {\n        final String morelArgTypeJson = (String) args.get(0);\n        compiled = new Compiled(morelArgTypeJson, cx.typeFactory, cx.typeSystem);\n      } else {\n        compiled = null;\n      }\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "MorelApplyFunction", "params": [{"name": "context", "type": "org.apache.calcite.plan.Context"}], "body": "                                                                       {\n      final List<Object> args = context.unwrap(List.class);\n      if (args != null) {\n        final String morelArgTypeJson = (String) args.get(0);\n        compiled = new Compiled(morelArgTypeJson, cx.typeFactory, cx.typeSystem);\n      } else {\n        compiled = null;\n      }\n    }", "signature": "public MorelApplyFunction(org.apache.calcite.plan.Context context)"}, {"syntax_pass": true, "original_string": "    @SuppressWarnings(\"unused\") // called via reflection\n    public MorelApplyFunction() {\n      this(Contexts.EMPTY_CONTEXT);\n    }", "docstring": "", "attributes": {"modifiers": "@SuppressWarnings(\"unused\") // called via reflection\n    public", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings(\"unused\")", "public"], "comments": ["// called via reflection"], "return_type": "", "classes": []}, "name": "MorelApplyFunction", "params": [], "body": "                                {\n      this(Contexts.EMPTY_CONTEXT);\n    }", "signature": "@SuppressWarnings(\"unused\") // called via reflection\n    public MorelApplyFunction()"}, {"syntax_pass": true, "original_string": "    @SuppressWarnings(\"unused\") // called via reflection\n    public Object eval(String morelArgTypeJson, Object closure, Object arg) {\n      final Compiled compiled =\n          this.compiled != null ? this.compiled\n              : new Compiled(morelArgTypeJson, cx.typeFactory, cx.typeSystem);\n      final Closure fn = (Closure) closure;\n      final EvalEnv evalEnv = THREAD_EVAL_ENV.get();\n      final Object o = compiled.converter.apply(arg);\n      return fn.apply(evalEnv, o);\n    }", "docstring": "", "attributes": {"modifiers": "@SuppressWarnings(\"unused\") // called via reflection\n    public", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings(\"unused\")", "public"], "comments": ["// called via reflection"], "return_type": "Object", "classes": []}, "name": "eval", "params": [{"name": "morelArgTypeJson", "type": "String"}, {"name": "closure", "type": "Object"}, {"name": "arg", "type": "Object"}], "body": "                                                                            {\n      final Compiled compiled =\n          this.compiled != null ? this.compiled\n              : new Compiled(morelArgTypeJson, cx.typeFactory, cx.typeSystem);\n      final Closure fn = (Closure) closure;\n      final EvalEnv evalEnv = THREAD_EVAL_ENV.get();\n      final Object o = compiled.converter.apply(arg);\n      return fn.apply(evalEnv, o);\n    }", "signature": "@SuppressWarnings(\"unused\") // called via reflection\n    public Object eval(String morelArgTypeJson, Object closure, Object arg)"}]}, {"original_string": "  public static class Context {\n    public final Session session;\n    public final Environment env;\n    public final TypeSystem typeSystem;\n    public final RelDataTypeFactory typeFactory;\n\n    public Context(Session session, Environment env, TypeSystem typeSystem,\n        @Nullable RelDataTypeFactory typeFactory) {\n      this.session = session;\n      this.env = env;\n      this.typeSystem = typeSystem;\n      this.typeFactory = typeFactory;\n    }\n\n    public Context withEnv(Environment env) {\n      return new Context(session, env, typeSystem, typeFactory);\n    }\n  }", "definition": "  public static class Context", "class_docstring": " Execution context.", "name": "Context", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [{"attribute_expression": "public final Session session;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "Session", "name": "session", "syntax_pass": true}, {"attribute_expression": "public final Environment env;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "Environment", "name": "env", "syntax_pass": true}, {"attribute_expression": "public final TypeSystem typeSystem;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "TypeSystem", "name": "typeSystem", "syntax_pass": true}, {"attribute_expression": "public final RelDataTypeFactory typeFactory;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "RelDataTypeFactory", "name": "typeFactory", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    public Context(Session session, Environment env, TypeSystem typeSystem,\n        @Nullable RelDataTypeFactory typeFactory) {\n      this.session = session;\n      this.env = env;\n      this.typeSystem = typeSystem;\n      this.typeFactory = typeFactory;\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "Context", "params": [{"name": "session", "type": "Session"}, {"name": "env", "type": "Environment"}, {"name": "typeSystem", "type": "TypeSystem"}, {"name": "typeFactory", "type": "RelDataTypeFactory"}], "body": "                                                  {\n      this.session = session;\n      this.env = env;\n      this.typeSystem = typeSystem;\n      this.typeFactory = typeFactory;\n    }", "signature": "public Context(Session session, Environment env, TypeSystem typeSystem,\n        @Nullable RelDataTypeFactory typeFactory)"}, {"syntax_pass": true, "original_string": "    public Context withEnv(Environment env) {\n      return new Context(session, env, typeSystem, typeFactory);\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Context", "classes": []}, "name": "withEnv", "params": [{"name": "env", "type": "Environment"}], "body": "                                            {\n      return new Context(session, env, typeSystem, typeFactory);\n    }", "signature": "public Context withEnv(Environment env)"}]}], "class_docstring": " Calcite table-valued user-defined function that evaluates a Morel\nexpression and returns the result as a relation.", "original_string": "public class CalciteFunctions {\n  public static final ThreadLocal<Context> THREAD_ENV =\n      new ThreadLocal<>();\n\n  /** Used to pass Morel's evaluation environment into Calcite, so that it is\n   * available if Calcite calls back into Morel.\n   *\n   * <p>It would be better if we passed the environment, or variables we know\n   * are needed, as an argument at the\n   * Calcite-to-Morel (see {@link Calcite#code}) and\n   * Morel-to-Calcite (see {@link #TABLE_OPERATOR} and {@link #SCALAR_OPERATOR})\n   * boundaries. */\n  public static final ThreadLocal<EvalEnv> THREAD_EVAL_ENV =\n      new ThreadLocal<>();\n\n  private CalciteFunctions() {\n  }\n\n  public static final SqlOperator TABLE_OPERATOR =\n      new SqlUserDefinedTableFunction(\n          new SqlIdentifier(\"morelTable\", SqlParserPos.ZERO),\n          SqlKind.OTHER_FUNCTION, ReturnTypes.CURSOR, InferTypes.ANY_NULLABLE,\n          Arg.metadata(\n              Arg.of(\"code\", f -> f.createSqlType(SqlTypeName.VARCHAR),\n                  SqlTypeFamily.STRING, false),\n              Arg.of(\"typeJson\", f -> f.createSqlType(SqlTypeName.VARCHAR),\n                  SqlTypeFamily.STRING, false)),\n          TableFunctionImpl.create(CalciteFunctions.MorelTableFunction.class,\n              \"eval\"));\n\n  public static final SqlOperator SCALAR_OPERATOR =\n      new SqlUserDefinedFunction(\n          new SqlIdentifier(\"morelScalar\", SqlParserPos.ZERO),\n          SqlKind.OTHER_FUNCTION, CalciteFunctions::inferReturnType,\n          InferTypes.ANY_NULLABLE,\n          Arg.metadata(\n              Arg.of(\"code\", f -> f.createSqlType(SqlTypeName.VARCHAR),\n                  SqlTypeFamily.STRING, false),\n              Arg.of(\"typeJson\", f -> f.createSqlType(SqlTypeName.VARCHAR),\n                  SqlTypeFamily.STRING, false)),\n          ScalarFunctionImpl.create(CalciteFunctions.MorelScalarFunction.class,\n              \"eval\"));\n\n  public static final SqlOperator APPLY_OPERATOR =\n      new SqlUserDefinedFunction(\n          new SqlIdentifier(\"morelScalar\", SqlParserPos.ZERO),\n          SqlKind.OTHER_FUNCTION, CalciteFunctions::inferReturnType,\n          InferTypes.ANY_NULLABLE,\n          Arg.metadata(\n              Arg.of(\"typeJson\", f -> f.createSqlType(SqlTypeName.VARCHAR),\n                  SqlTypeFamily.STRING, false),\n              Arg.of(\"fn\", f -> f.createSqlType(SqlTypeName.INTEGER),\n                  SqlTypeFamily.INTEGER, false),\n              Arg.of(\"arg\", f -> f.createSqlType(SqlTypeName.VARCHAR),\n                  SqlTypeFamily.STRING, false)),\n          ScalarFunctionImpl.create(CalciteFunctions.MorelApplyFunction.class,\n              \"eval\"));\n\n  private static RelDataType inferReturnType(SqlOperatorBinding b) {\n    return b.getTypeFactory().createSqlType(SqlTypeName.INTEGER);\n  }\n\n  /** Calcite user-defined function that evaluates a Morel string and\n   * returns a table. */\n  public static class MorelTableFunction {\n    private final Context cx = THREAD_ENV.get();\n    private final Compiled compiled;\n\n    public MorelTableFunction(org.apache.calcite.plan.Context context) {\n      final List<Object> args = context.unwrap(List.class);\n      if (args != null) {\n        String ml = (String) args.get(0);\n        String typeJson = (String) args.get(1);\n        compiled =\n            Compiled.create(ml, typeJson, cx.typeFactory, cx.env, cx.typeSystem,\n                cx.session);\n      } else {\n        compiled = null;\n      }\n    }\n\n    @SuppressWarnings(\"unused\") // called via reflection\n    public MorelTableFunction() {\n      this(Contexts.EMPTY_CONTEXT);\n    }\n\n    @SuppressWarnings(\"unused\") // called via reflection\n    public ScannableTable eval(String ml, String typeJson) {\n      final Compiled compiled =\n          this.compiled != null ? this.compiled\n              : Compiled.create(ml, typeJson, cx.typeFactory, cx.env,\n                  cx.typeSystem, cx.session);\n      return new ScannableTable() {\n        @Override public RelDataType getRowType(RelDataTypeFactory factory) {\n          try {\n            return RelJsonReader.readType(factory, typeJson);\n          } catch (IOException e) {\n            throw new RuntimeException(e);\n          }\n        }\n\n        @Override public Enumerable<Object[]> scan(DataContext root) {\n          Object v = compiled.code.eval(compiled.evalEnv);\n          return compiled.f.apply(v);\n        }\n\n        @Override public Statistic getStatistic() {\n          return Statistics.UNKNOWN;\n        }\n\n        @Override public Schema.TableType getJdbcTableType() {\n          return Schema.TableType.OTHER;\n        }\n\n        @Override public boolean isRolledUp(String column) {\n          return false;\n        }\n\n        @Override public boolean rolledUpColumnValidInsideAgg(String column,\n            SqlCall call, SqlNode parent, CalciteConnectionConfig config) {\n          return false;\n        }\n      };\n    }\n\n    /** Compiled state. */\n    private static class Compiled {\n      final Code code;\n      final EvalEnv evalEnv;\n      final Function<Object, Enumerable<Object[]>> f;\n\n      Compiled(String ml, Code code, EvalEnv evalEnv,\n          Function<Object, Enumerable<Object[]>> f) {\n        this.code = code;\n        this.evalEnv = evalEnv;\n        this.f = f;\n      }\n\n      static Compiled create(String ml, String typeJson,\n          RelDataTypeFactory typeFactory, Environment env,\n          TypeSystem typeSystem, Session session) {\n        final Ast.Exp exp;\n        try {\n          exp = new MorelParserImpl(new StringReader(ml)).expression();\n        } catch (ParseException pe) {\n          throw new RuntimeException(\"Error while parsing\\n\"\n              + ml, pe);\n        }\n        final Ast.ValDecl valDecl = Compiles.toValDecl(exp);\n        final TypeResolver.Resolved resolved =\n            TypeResolver.deduceType(env, valDecl, typeSystem);\n        final Ast.ValDecl valDecl2 = (Ast.ValDecl) resolved.node;\n        final Core.NonRecValDecl valDecl3 =\n            (Core.NonRecValDecl)\n                Resolver.of(resolved.typeMap, env, session)\n                    .toCore(valDecl2);\n        final Core.Exp e3 = Compiles.toExp(valDecl3);\n        final Compiler compiler = new Compiler(typeSystem);\n        return new Compiled(ml, compiler.compile(env, e3),\n            Codes.emptyEnvWith(session, env),\n            Converters.toCalciteEnumerable(e3.type, typeFactory));\n      }\n    }\n  }\n\n  /** Calcite user-defined function that evaluates a Morel string and returns\n   * a scalar value. */\n  public static class MorelScalarFunction {\n    private final Context cx = THREAD_ENV.get();\n    private final Compiled compiled;\n\n    public MorelScalarFunction(org.apache.calcite.plan.Context context) {\n      final List<Object> args = context.unwrap(List.class);\n      if (args != null) {\n        compiled = new Compiled(cx.env, cx.typeSystem, cx.typeFactory,\n            (String) args.get(0), (String) args.get(1));\n      } else {\n        compiled = null;\n      }\n    }\n\n    @SuppressWarnings(\"unused\") // called via reflection\n    public MorelScalarFunction() {\n      this(Contexts.EMPTY_CONTEXT);\n    }\n\n    @SuppressWarnings(\"unused\") // called via reflection\n    public Object eval(String ml, String typeJson) {\n      final Compiled compiled =\n          this.compiled != null ? this.compiled\n              : new Compiled(cx.env, cx.typeSystem, cx.typeFactory, ml,\n                  typeJson);\n      final EvalEnv evalEnv = THREAD_EVAL_ENV.get();\n      Object v = compiled.code.eval(evalEnv);\n      return compiled.f.apply(v);\n    }\n\n    /** Compiled state. */\n    private static class Compiled {\n      final Code code;\n      final Function<Object, Object> f;\n\n      Compiled(Environment env, TypeSystem typeSystem,\n          RelDataTypeFactory typeFactory, String ml, String typeJson) {\n        final Ast.Exp exp;\n        try {\n          exp = new MorelParserImpl(new StringReader(ml)).expression();\n        } catch (ParseException pe) {\n          throw new RuntimeException(pe);\n        }\n        final Ast.ValDecl valDecl = Compiles.toValDecl(exp);\n        final TypeResolver.Resolved resolved =\n            TypeResolver.deduceType(env, valDecl, typeSystem);\n        final Ast.ValDecl valDecl2 = (Ast.ValDecl) resolved.node;\n        final Core.NonRecValDecl valDecl3 = (Core.NonRecValDecl)\n            Resolver.of(resolved.typeMap, env, null).toCore(valDecl2);\n        final Core.Exp e3 = Compiles.toExp(valDecl3);\n        code = new Compiler(typeSystem).compile(env, e3);\n        f = Converters.toCalcite(e3.type, typeFactory);\n      }\n    }\n  }\n\n  /** Calcite user-defined function that applies a Morel function (or closure)\n   * to an argument. */\n  public static class MorelApplyFunction {\n    final Context cx = THREAD_ENV.get();\n    final Compiled compiled;\n\n    public MorelApplyFunction(org.apache.calcite.plan.Context context) {\n      final List<Object> args = context.unwrap(List.class);\n      if (args != null) {\n        final String morelArgTypeJson = (String) args.get(0);\n        compiled = new Compiled(morelArgTypeJson, cx.typeFactory, cx.typeSystem);\n      } else {\n        compiled = null;\n      }\n    }\n\n    @SuppressWarnings(\"unused\") // called via reflection\n    public MorelApplyFunction() {\n      this(Contexts.EMPTY_CONTEXT);\n    }\n\n    @SuppressWarnings(\"unused\") // called via reflection\n    public Object eval(String morelArgTypeJson, Object closure, Object arg) {\n      final Compiled compiled =\n          this.compiled != null ? this.compiled\n              : new Compiled(morelArgTypeJson, cx.typeFactory, cx.typeSystem);\n      final Closure fn = (Closure) closure;\n      final EvalEnv evalEnv = THREAD_EVAL_ENV.get();\n      final Object o = compiled.converter.apply(arg);\n      return fn.apply(evalEnv, o);\n    }\n\n    /** Compiled state. */\n    private static class Compiled {\n      final Function<Object, Object> converter;\n\n      Compiled(String morelArgType, RelDataTypeFactory typeFactory,\n          TypeSystem typeSystem) {\n        Ast.Type typeAst;\n        try {\n          typeAst = new MorelParserImpl(new StringReader(morelArgType)).type();\n        } catch (ParseException pe) {\n          throw new RuntimeException(pe);\n        }\n        final Type argType = TypeResolver.toType(typeAst, typeSystem);\n        converter = Converters.toMorel(argType, typeFactory);\n      }\n    }\n  }\n\n  /** Operand to a user-defined function. */\n  private interface Arg {\n    String name();\n    RelDataType type(RelDataTypeFactory typeFactory);\n    SqlTypeFamily family();\n    boolean optional();\n\n    static SqlOperandMetadata metadata(Arg... args) {\n      final List<Arg> argList = Arrays.asList(args);\n      return OperandTypes.operandMetadata(transform(argList, Arg::family),\n          typeFactory -> transform(argList, arg -> arg.type(typeFactory)),\n          i -> args[i].name(), i -> args[i].optional());\n    }\n\n    static Arg of(String name,\n        Function<RelDataTypeFactory, RelDataType> protoType,\n        SqlTypeFamily family, boolean optional) {\n      return new Arg() {\n        @Override public String name() {\n          return name;\n        }\n\n        @Override public RelDataType type(RelDataTypeFactory typeFactory) {\n          return protoType.apply(typeFactory);\n        }\n\n        @Override public SqlTypeFamily family() {\n          return family;\n        }\n\n        @Override public boolean optional() {\n          return optional;\n        }\n      };\n    }\n  }\n\n  /** Execution context. */\n  public static class Context {\n    public final Session session;\n    public final Environment env;\n    public final TypeSystem typeSystem;\n    public final RelDataTypeFactory typeFactory;\n\n    public Context(Session session, Environment env, TypeSystem typeSystem,\n        @Nullable RelDataTypeFactory typeFactory) {\n      this.session = session;\n      this.env = env;\n      this.typeSystem = typeSystem;\n      this.typeFactory = typeFactory;\n    }\n\n    public Context withEnv(Environment env) {\n      return new Context(session, env, typeSystem, typeFactory);\n    }\n  }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "public static final ThreadLocal<Context> THREAD_ENV =\n      new ThreadLocal<>();", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "ThreadLocal<Context>", "name": "THREAD_ENV =\n      new ThreadLocal<>()", "syntax_pass": true}, {"attribute_expression": "public static final ThreadLocal<EvalEnv> THREAD_EVAL_ENV =\n      new ThreadLocal<>();", "docstring": " Used to pass Morel's evaluation environment into Calcite, so that it is\navailable if Calcite calls back into Morel.\n\n<p>It would be better if we passed the environment, or variables we know\nare needed, as an argument at the\nCalcite-to-Morel (see {@link Calcite#code}) and\nMorel-to-Calcite (see {@link #TABLE_OPERATOR} and {@link #SCALAR_OPERATOR})\nboundaries.", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "ThreadLocal<EvalEnv>", "name": "THREAD_EVAL_ENV =\n      new ThreadLocal<>()", "syntax_pass": true}, {"attribute_expression": "public static final SqlOperator TABLE_OPERATOR =\n      new SqlUserDefinedTableFunction(\n          new SqlIdentifier(\"morelTable\", SqlParserPos.ZERO),\n          SqlKind.OTHER_FUNCTION, ReturnTypes.CURSOR, InferTypes.ANY_NULLABLE,\n          Arg.metadata(\n              Arg.of(\"code\", f -> f.createSqlType(SqlTypeName.VARCHAR),\n                  SqlTypeFamily.STRING, false),\n              Arg.of(\"typeJson\", f -> f.createSqlType(SqlTypeName.VARCHAR),\n                  SqlTypeFamily.STRING, false)),\n          TableFunctionImpl.create(CalciteFunctions.MorelTableFunction.class,\n              \"eval\"));", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "SqlOperator", "name": "TABLE_OPERATOR =\n      new SqlUserDefinedTableFunction(\n          new SqlIdentifier(\"morelTable\", SqlParserPos.ZERO),\n          SqlKind.OTHER_FUNCTION, ReturnTypes.CURSOR, InferTypes.ANY_NULLABLE,\n          Arg.metadata(\n              Arg.of(\"code\", f -> f.createSqlType(SqlTypeName.VARCHAR),\n                  SqlTypeFamily.STRING, false),\n              Arg.of(\"typeJson\", f -> f.createSqlType(SqlTypeName.VARCHAR),\n                  SqlTypeFamily.STRING, false)),\n          TableFunctionImpl.create(CalciteFunctions.MorelTableFunction.class,\n              \"eval\"))", "syntax_pass": true}, {"attribute_expression": "public static final SqlOperator SCALAR_OPERATOR =\n      new SqlUserDefinedFunction(\n          new SqlIdentifier(\"morelScalar\", SqlParserPos.ZERO),\n          SqlKind.OTHER_FUNCTION, CalciteFunctions::inferReturnType,\n          InferTypes.ANY_NULLABLE,\n          Arg.metadata(\n              Arg.of(\"code\", f -> f.createSqlType(SqlTypeName.VARCHAR),\n                  SqlTypeFamily.STRING, false),\n              Arg.of(\"typeJson\", f -> f.createSqlType(SqlTypeName.VARCHAR),\n                  SqlTypeFamily.STRING, false)),\n          ScalarFunctionImpl.create(CalciteFunctions.MorelScalarFunction.class,\n              \"eval\"));", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "SqlOperator", "name": "SCALAR_OPERATOR =\n      new SqlUserDefinedFunction(\n          new SqlIdentifier(\"morelScalar\", SqlParserPos.ZERO),\n          SqlKind.OTHER_FUNCTION, CalciteFunctions::inferReturnType,\n          InferTypes.ANY_NULLABLE,\n          Arg.metadata(\n              Arg.of(\"code\", f -> f.createSqlType(SqlTypeName.VARCHAR),\n                  SqlTypeFamily.STRING, false),\n              Arg.of(\"typeJson\", f -> f.createSqlType(SqlTypeName.VARCHAR),\n                  SqlTypeFamily.STRING, false)),\n          ScalarFunctionImpl.create(CalciteFunctions.MorelScalarFunction.class,\n              \"eval\"))", "syntax_pass": true}, {"attribute_expression": "public static final SqlOperator APPLY_OPERATOR =\n      new SqlUserDefinedFunction(\n          new SqlIdentifier(\"morelScalar\", SqlParserPos.ZERO),\n          SqlKind.OTHER_FUNCTION, CalciteFunctions::inferReturnType,\n          InferTypes.ANY_NULLABLE,\n          Arg.metadata(\n              Arg.of(\"typeJson\", f -> f.createSqlType(SqlTypeName.VARCHAR),\n                  SqlTypeFamily.STRING, false),\n              Arg.of(\"fn\", f -> f.createSqlType(SqlTypeName.INTEGER),\n                  SqlTypeFamily.INTEGER, false),\n              Arg.of(\"arg\", f -> f.createSqlType(SqlTypeName.VARCHAR),\n                  SqlTypeFamily.STRING, false)),\n          ScalarFunctionImpl.create(CalciteFunctions.MorelApplyFunction.class,\n              \"eval\"));", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "SqlOperator", "name": "APPLY_OPERATOR =\n      new SqlUserDefinedFunction(\n          new SqlIdentifier(\"morelScalar\", SqlParserPos.ZERO),\n          SqlKind.OTHER_FUNCTION, CalciteFunctions::inferReturnType,\n          InferTypes.ANY_NULLABLE,\n          Arg.metadata(\n              Arg.of(\"typeJson\", f -> f.createSqlType(SqlTypeName.VARCHAR),\n                  SqlTypeFamily.STRING, false),\n              Arg.of(\"fn\", f -> f.createSqlType(SqlTypeName.INTEGER),\n                  SqlTypeFamily.INTEGER, false),\n              Arg.of(\"arg\", f -> f.createSqlType(SqlTypeName.VARCHAR),\n                  SqlTypeFamily.STRING, false)),\n          ScalarFunctionImpl.create(CalciteFunctions.MorelApplyFunction.class,\n              \"eval\"))", "syntax_pass": true}]}, {"uris": "src/main/java/net/hydromatic/morel/foreign/RelList.java.RelList", "name": "RelList", "file_path": "src/main/java/net/hydromatic/morel/foreign/RelList.java", "superclasses": "", "methods": ["[]RelList(RelNode,DataContext,Function<Object[], Object>)", "[Object]get(int)", "[int]size()"], "method_uris": ["src/main/java/net/hydromatic/morel/foreign/RelList.java.RelList.[]RelList(RelNode,DataContext,Function<Object[], Object>)", "src/main/java/net/hydromatic/morel/foreign/RelList.java.RelList.[Object]get(int)", "src/main/java/net/hydromatic/morel/foreign/RelList.java.RelList.[int]size()"], "overrides": null, "attributes": [], "class_docstring": " A list whose contents are computed by evaluating a relational\nexpression.", "original_string": "public class RelList extends AbstractList<Object> {\n  public final RelNode rel;\n\n  private final Supplier<List<Object>> supplier;\n\n  RelList(RelNode rel, DataContext dataContext,\n      Function<Object[], Object> converter) {\n    this.rel = rel;\n    //noinspection FunctionalExpressionCanBeFolded\n    supplier = Suppliers.memoize(() ->\n        new Interpreter(dataContext, rel)\n            .select(converter::apply)\n            .toList())::get;\n  }\n\n  public Object get(int index) {\n    return supplier.get().get(index);\n  }\n\n  public int size() {\n    return supplier.get().size();\n  }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "public final RelNode rel;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "RelNode", "name": "rel", "syntax_pass": true}, {"attribute_expression": "private final Supplier<List<Object>> supplier;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Supplier<List<Object>>", "name": "supplier", "syntax_pass": true}]}, {"uris": "src/main/java/net/hydromatic/morel/foreign/Calcite.java.Calcite", "name": "Calcite", "file_path": "src/main/java/net/hydromatic/morel/foreign/Calcite.java", "superclasses": "", "methods": ["[]Calcite()", "[Map<String, ForeignValue>]foreignValues()", "[Calcite]withDataSets(Map<String, DataSet>)", "[RelBuilder]relBuilder()", "[Code]code(Environment,RelNode,Type)"], "method_uris": ["src/main/java/net/hydromatic/morel/foreign/Calcite.java.Calcite.[]Calcite()", "src/main/java/net/hydromatic/morel/foreign/Calcite.java.Calcite.[Map<String, ForeignValue>]foreignValues()", "src/main/java/net/hydromatic/morel/foreign/Calcite.java.Calcite.[Calcite]withDataSets(Map<String, DataSet>)", "src/main/java/net/hydromatic/morel/foreign/Calcite.java.Calcite.[RelBuilder]relBuilder()", "src/main/java/net/hydromatic/morel/foreign/Calcite.java.Calcite.[Code]code(Environment,RelNode,Type)"], "overrides": null, "attributes": [{"original_string": "  private static class DecorrelateProgram implements Program {\n    @Override public RelNode run(RelOptPlanner planner, RelNode rel,\n        RelTraitSet requiredOutputTraits,\n        List<RelOptMaterialization> materializations,\n        List<RelOptLattice> lattices) {\n      final CalciteConnectionConfig config =\n          planner.getContext().maybeUnwrap(CalciteConnectionConfig.class)\n              .orElse(CalciteConnectionConfig.DEFAULT);\n      if (config.forceDecorrelate()) {\n        final RelBuilder relBuilder =\n            RelFactories.LOGICAL_BUILDER.create(rel.getCluster(), null);\n        return RelDecorrelator.decorrelateQuery(rel, relBuilder);\n      }\n      return rel;\n    }\n  }", "definition": "  private static class DecorrelateProgram implements Program", "class_docstring": " Copied from {@link Programs}.", "name": "DecorrelateProgram", "super_interfaces": ["Program"], "superclasses": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @Override public RelNode run(RelOptPlanner planner, RelNode rel,\n        RelTraitSet requiredOutputTraits,\n        List<RelOptMaterialization> materializations,\n        List<RelOptLattice> lattices) {\n      final CalciteConnectionConfig config =\n          planner.getContext().maybeUnwrap(CalciteConnectionConfig.class)\n              .orElse(CalciteConnectionConfig.DEFAULT);\n      if (config.forceDecorrelate()) {\n        final RelBuilder relBuilder =\n            RelFactories.LOGICAL_BUILDER.create(rel.getCluster(), null);\n        return RelDecorrelator.decorrelateQuery(rel, relBuilder);\n      }\n      return rel;\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "RelNode", "classes": []}, "name": "run", "params": [{"name": "planner", "type": "RelOptPlanner"}, {"name": "rel", "type": "RelNode"}, {"name": "requiredOutputTraits", "type": "RelTraitSet"}, {"name": "materializations", "type": "List<RelOptMaterialization>"}, {"name": "lattices", "type": "List<RelOptLattice>"}], "body": "                                      {\n      final CalciteConnectionConfig config =\n          planner.getContext().maybeUnwrap(CalciteConnectionConfig.class)\n              .orElse(CalciteConnectionConfig.DEFAULT);\n      if (config.forceDecorrelate()) {\n        final RelBuilder relBuilder =\n            RelFactories.LOGICAL_BUILDER.create(rel.getCluster(), null);\n        return RelDecorrelator.decorrelateQuery(rel, relBuilder);\n      }\n      return rel;\n    }", "signature": "@Override public RelNode run(RelOptPlanner planner, RelNode rel,\n        RelTraitSet requiredOutputTraits,\n        List<RelOptMaterialization> materializations,\n        List<RelOptLattice> lattices)"}]}, {"original_string": "  private static class CalciteMap extends Calcite {\n    final ImmutableMap<String, ForeignValue> valueMap;\n\n    CalciteMap(Map<String, DataSet> dataSetMap) {\n      final ImmutableMap.Builder<String, ForeignValue> b =\n          ImmutableMap.builder();\n      dataSetMap.forEach((name, dataSet) ->\n          b.put(name, dataSet.foreignValue(this)));\n      this.valueMap = b.build();\n    }\n\n    @Override public Map<String, ForeignValue> foreignValues() {\n      return valueMap;\n    }\n  }", "definition": "  private static class CalciteMap extends Calcite", "class_docstring": " Extension to Calcite context that remembers the foreign value\nfor each name.", "name": "CalciteMap", "super_interfaces": [], "superclasses": "Calcite", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "fields": [{"attribute_expression": "final ImmutableMap<String, ForeignValue> valueMap;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "ImmutableMap<String, ForeignValue>", "name": "valueMap", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    CalciteMap(Map<String, DataSet> dataSetMap) {\n      final ImmutableMap.Builder<String, ForeignValue> b =\n          ImmutableMap.builder();\n      dataSetMap.forEach((name, dataSet) ->\n          b.put(name, dataSet.foreignValue(this)));\n      this.valueMap = b.build();\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "CalciteMap", "params": [{"name": "dataSetMap", "type": "Map<String, DataSet>"}], "body": "                                                {\n      final ImmutableMap.Builder<String, ForeignValue> b =\n          ImmutableMap.builder();\n      dataSetMap.forEach((name, dataSet) ->\n          b.put(name, dataSet.foreignValue(this)));\n      this.valueMap = b.build();\n    }", "signature": "CalciteMap(Map<String, DataSet> dataSetMap)"}, {"syntax_pass": true, "original_string": "    @Override public Map<String, ForeignValue> foreignValues() {\n      return valueMap;\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Map<String, ForeignValue>", "classes": []}, "name": "foreignValues", "params": [], "body": "                                                               {\n      return valueMap;\n    }", "signature": "@Override public Map<String, ForeignValue> foreignValues()"}]}, {"original_string": "  private static class EmptyDataContext implements DataContext {\n    private final JavaTypeFactory typeFactory;\n    private final SchemaPlus rootSchema;\n\n    EmptyDataContext(JavaTypeFactory typeFactory, SchemaPlus rootSchema) {\n      this.typeFactory = typeFactory;\n      this.rootSchema = rootSchema;\n    }\n\n    public SchemaPlus getRootSchema() {\n      return rootSchema;\n    }\n\n    public JavaTypeFactory getTypeFactory() {\n      return typeFactory;\n    }\n\n    public QueryProvider getQueryProvider() {\n      throw new UnsupportedOperationException();\n    }\n\n    public Object get(String name) {\n      return null;\n    }\n  }", "definition": "  private static class EmptyDataContext implements DataContext", "class_docstring": " Data context that has no variables.", "name": "EmptyDataContext", "super_interfaces": ["DataContext"], "superclasses": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "fields": [{"attribute_expression": "private final JavaTypeFactory typeFactory;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "JavaTypeFactory", "name": "typeFactory", "syntax_pass": true}, {"attribute_expression": "private final SchemaPlus rootSchema;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "SchemaPlus", "name": "rootSchema", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    EmptyDataContext(JavaTypeFactory typeFactory, SchemaPlus rootSchema) {\n      this.typeFactory = typeFactory;\n      this.rootSchema = rootSchema;\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "EmptyDataContext", "params": [{"name": "typeFactory", "type": "JavaTypeFactory"}, {"name": "rootSchema", "type": "SchemaPlus"}], "body": "                                                                         {\n      this.typeFactory = typeFactory;\n      this.rootSchema = rootSchema;\n    }", "signature": "EmptyDataContext(JavaTypeFactory typeFactory, SchemaPlus rootSchema)"}, {"syntax_pass": true, "original_string": "    public SchemaPlus getRootSchema() {\n      return rootSchema;\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "SchemaPlus", "classes": []}, "name": "getRootSchema", "params": [], "body": "                                      {\n      return rootSchema;\n    }", "signature": "public SchemaPlus getRootSchema()"}, {"syntax_pass": true, "original_string": "    public JavaTypeFactory getTypeFactory() {\n      return typeFactory;\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "JavaTypeFactory", "classes": []}, "name": "getTypeFactory", "params": [], "body": "                                            {\n      return typeFactory;\n    }", "signature": "public JavaTypeFactory getTypeFactory()"}, {"syntax_pass": true, "original_string": "    public QueryProvider getQueryProvider() {\n      throw new UnsupportedOperationException();\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "QueryProvider", "classes": []}, "name": "getQueryProvider", "params": [], "body": "                                            {\n      throw new UnsupportedOperationException();\n    }", "signature": "public QueryProvider getQueryProvider()"}, {"syntax_pass": true, "original_string": "    public Object get(String name) {\n      return null;\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Object", "classes": []}, "name": "get", "params": [{"name": "name", "type": "String"}], "body": "                                   {\n      return null;\n    }", "signature": "public Object get(String name)"}]}, {"original_string": "  private static class CalciteCode implements Code {\n    final DataContext dataContext;\n    final RelNode rel;\n    final Environment env;\n    final Function<Enumerable<Object[]>, List<Object>> converter;\n\n    CalciteCode(DataContext dataContext, RelNode rel, Environment env,\n        Function<Enumerable<Object[]>, List<Object>> converter) {\n      this.dataContext = dataContext;\n      this.rel = rel;\n      this.env = env;\n      this.converter = converter;\n    }\n\n    // to help with debugging\n    @Override public String toString() {\n      return Codes.describe(this);\n    }\n\n    @Override public Describer describe(Describer describer) {\n      return describer.start(\"calcite\", d ->\n          d.arg(\"plan\", RelOptUtil.toString(rel)));\n    }\n\n    @Override public Object eval(EvalEnv evalEnv) {\n      return ThreadLocals.let(CalciteFunctions.THREAD_EVAL_ENV,\n          evalEnv, () ->\n              ThreadLocals.mutate(CalciteFunctions.THREAD_ENV,\n                  c -> c.withEnv(env),\n                  () -> {\n                    final Interpreter interpreter =\n                        new Interpreter(dataContext, rel);\n                    return converter.apply(interpreter);\n                  }));\n    }\n  }", "definition": "  private static class CalciteCode implements Code", "class_docstring": " Evaluates a Calcite relational expression,\nconverting it to Morel list type {@code type}.", "name": "CalciteCode", "super_interfaces": ["Code"], "superclasses": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "fields": [{"attribute_expression": "final DataContext dataContext;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "DataContext", "name": "dataContext", "syntax_pass": true}, {"attribute_expression": "final RelNode rel;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "RelNode", "name": "rel", "syntax_pass": true}, {"attribute_expression": "final Environment env;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "Environment", "name": "env", "syntax_pass": true}, {"attribute_expression": "final Function<Enumerable<Object[]>, List<Object>> converter;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "Function<Enumerable<Object[]>, List<Object>>", "name": "converter", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    CalciteCode(DataContext dataContext, RelNode rel, Environment env,\n        Function<Enumerable<Object[]>, List<Object>> converter) {\n      this.dataContext = dataContext;\n      this.rel = rel;\n      this.env = env;\n      this.converter = converter;\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "CalciteCode", "params": [{"name": "dataContext", "type": "DataContext"}, {"name": "rel", "type": "RelNode"}, {"name": "env", "type": "Environment"}, {"name": "converter", "type": "Function<Enumerable<Object[]>, List<Object>>"}], "body": "                                                                {\n      this.dataContext = dataContext;\n      this.rel = rel;\n      this.env = env;\n      this.converter = converter;\n    }", "signature": "CalciteCode(DataContext dataContext, RelNode rel, Environment env,\n        Function<Enumerable<Object[]>, List<Object>> converter)"}, {"syntax_pass": true, "original_string": "    @Override public String toString() {\n      return Codes.describe(this);\n    }", "docstring": " to help with debugging", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "toString", "params": [], "body": "                                       {\n      return Codes.describe(this);\n    }", "signature": "@Override public String toString()"}, {"syntax_pass": true, "original_string": "    @Override public Describer describe(Describer describer) {\n      return describer.start(\"calcite\", d ->\n          d.arg(\"plan\", RelOptUtil.toString(rel)));\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Describer", "classes": []}, "name": "describe", "params": [{"name": "describer", "type": "Describer"}], "body": "                                                             {\n      return describer.start(\"calcite\", d ->\n          d.arg(\"plan\", RelOptUtil.toString(rel)));\n    }", "signature": "@Override public Describer describe(Describer describer)"}, {"syntax_pass": true, "original_string": "    @Override public Object eval(EvalEnv evalEnv) {\n      return ThreadLocals.let(CalciteFunctions.THREAD_EVAL_ENV,\n          evalEnv, () ->\n              ThreadLocals.mutate(CalciteFunctions.THREAD_ENV,\n                  c -> c.withEnv(env),\n                  () -> {\n                    final Interpreter interpreter =\n                        new Interpreter(dataContext, rel);\n                    return converter.apply(interpreter);\n                  }));\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Object", "classes": []}, "name": "eval", "params": [{"name": "evalEnv", "type": "EvalEnv"}], "body": "                                                  {\n      return ThreadLocals.let(CalciteFunctions.THREAD_EVAL_ENV,\n          evalEnv, () ->\n              ThreadLocals.mutate(CalciteFunctions.THREAD_ENV,\n                  c -> c.withEnv(env),\n                  () -> {\n                    final Interpreter interpreter =\n                        new Interpreter(dataContext, rel);\n                    return converter.apply(interpreter);\n                  }));\n    }", "signature": "@Override public Object eval(EvalEnv evalEnv)"}]}], "class_docstring": " Runtime context.", "original_string": "public class Calcite {\n  final RelBuilder relBuilder;\n  final JavaTypeFactory typeFactory;\n  public final SchemaPlus rootSchema;\n  public final DataContext dataContext;\n\n  protected Calcite() {\n    rootSchema = CalciteSchema.createRootSchema(false).plus();\n    relBuilder = RelBuilder.create(Frameworks.newConfigBuilder()\n        .defaultSchema(rootSchema)\n        .build());\n    typeFactory = (JavaTypeFactory) relBuilder.getTypeFactory();\n    dataContext = new EmptyDataContext(typeFactory, rootSchema);\n  }\n\n  /** Returns foreign values. */\n  public Map<String, ForeignValue> foreignValues() {\n    return ImmutableMap.of();\n  }\n\n  /** Creates a runtime context with the given data sets. */\n  public static Calcite withDataSets(Map<String, DataSet> dataSetMap) {\n    return new CalciteMap(dataSetMap);\n  }\n\n  /** Creates an empty RelBuilder. */\n  public RelBuilder relBuilder() {\n    return relBuilder.transform(c -> c);\n  }\n\n  /** Creates a {@code Code} that evaluates a Calcite relational expression,\n   * converting it to Morel list type {@code type}. */\n  public Code code(Environment env, RelNode rel, Type type) {\n    // Transform the relational expression, converting sub-queries. For example,\n    // RexSubQuery.IN becomes a Join.\n    final Program program =\n        Programs.sequence(\n            Programs.subQuery(DefaultRelMetadataProvider.INSTANCE),\n            new DecorrelateProgram());\n    final RelOptPlanner planner = rel.getCluster().getPlanner();\n    final RelTraitSet traitSet = rel.getCluster().traitSet();\n    final RelNode rel2 = program.run(planner, rel, traitSet,\n        ImmutableList.of(), ImmutableList.of());\n\n    final Function<Enumerable<Object[]>, List<Object>> converter =\n        Converters.fromEnumerable(rel, type);\n    return new CalciteCode(dataContext, rel2, env, converter);\n  }\n\n  /** Copied from {@link Programs}. */\n  private static class DecorrelateProgram implements Program {\n    @Override public RelNode run(RelOptPlanner planner, RelNode rel,\n        RelTraitSet requiredOutputTraits,\n        List<RelOptMaterialization> materializations,\n        List<RelOptLattice> lattices) {\n      final CalciteConnectionConfig config =\n          planner.getContext().maybeUnwrap(CalciteConnectionConfig.class)\n              .orElse(CalciteConnectionConfig.DEFAULT);\n      if (config.forceDecorrelate()) {\n        final RelBuilder relBuilder =\n            RelFactories.LOGICAL_BUILDER.create(rel.getCluster(), null);\n        return RelDecorrelator.decorrelateQuery(rel, relBuilder);\n      }\n      return rel;\n    }\n  }\n\n  /** Extension to Calcite context that remembers the foreign value\n   * for each name. */\n  private static class CalciteMap extends Calcite {\n    final ImmutableMap<String, ForeignValue> valueMap;\n\n    CalciteMap(Map<String, DataSet> dataSetMap) {\n      final ImmutableMap.Builder<String, ForeignValue> b =\n          ImmutableMap.builder();\n      dataSetMap.forEach((name, dataSet) ->\n          b.put(name, dataSet.foreignValue(this)));\n      this.valueMap = b.build();\n    }\n\n    @Override public Map<String, ForeignValue> foreignValues() {\n      return valueMap;\n    }\n  }\n\n  /** Data context that has no variables. */\n  private static class EmptyDataContext implements DataContext {\n    private final JavaTypeFactory typeFactory;\n    private final SchemaPlus rootSchema;\n\n    EmptyDataContext(JavaTypeFactory typeFactory, SchemaPlus rootSchema) {\n      this.typeFactory = typeFactory;\n      this.rootSchema = rootSchema;\n    }\n\n    public SchemaPlus getRootSchema() {\n      return rootSchema;\n    }\n\n    public JavaTypeFactory getTypeFactory() {\n      return typeFactory;\n    }\n\n    public QueryProvider getQueryProvider() {\n      throw new UnsupportedOperationException();\n    }\n\n    public Object get(String name) {\n      return null;\n    }\n  }\n\n  /** Evaluates a Calcite relational expression,\n   * converting it to Morel list type {@code type}. */\n  private static class CalciteCode implements Code {\n    final DataContext dataContext;\n    final RelNode rel;\n    final Environment env;\n    final Function<Enumerable<Object[]>, List<Object>> converter;\n\n    CalciteCode(DataContext dataContext, RelNode rel, Environment env,\n        Function<Enumerable<Object[]>, List<Object>> converter) {\n      this.dataContext = dataContext;\n      this.rel = rel;\n      this.env = env;\n      this.converter = converter;\n    }\n\n    // to help with debugging\n    @Override public String toString() {\n      return Codes.describe(this);\n    }\n\n    @Override public Describer describe(Describer describer) {\n      return describer.start(\"calcite\", d ->\n          d.arg(\"plan\", RelOptUtil.toString(rel)));\n    }\n\n    @Override public Object eval(EvalEnv evalEnv) {\n      return ThreadLocals.let(CalciteFunctions.THREAD_EVAL_ENV,\n          evalEnv, () ->\n              ThreadLocals.mutate(CalciteFunctions.THREAD_ENV,\n                  c -> c.withEnv(env),\n                  () -> {\n                    final Interpreter interpreter =\n                        new Interpreter(dataContext, rel);\n                    return converter.apply(interpreter);\n                  }));\n    }\n  }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "final RelBuilder relBuilder;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "RelBuilder", "name": "relBuilder", "syntax_pass": true}, {"attribute_expression": "final JavaTypeFactory typeFactory;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "JavaTypeFactory", "name": "typeFactory", "syntax_pass": true}, {"attribute_expression": "public final SchemaPlus rootSchema;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "SchemaPlus", "name": "rootSchema", "syntax_pass": true}, {"attribute_expression": "public final DataContext dataContext;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "DataContext", "name": "dataContext", "syntax_pass": true}]}, {"uris": "src/main/java/net/hydromatic/morel/foreign/CalciteForeignValue.java.CalciteForeignValue", "name": "CalciteForeignValue", "file_path": "src/main/java/net/hydromatic/morel/foreign/CalciteForeignValue.java", "superclasses": "", "methods": ["[]CalciteForeignValue(Calcite,SchemaPlus,boolean)", "[Type]type(TypeSystem)", "[Type]toType(SchemaPlus,TypeSystem)", "[Type]toType(Table,TypeSystem)", "[String]convert(String)", "[String]convert(boolean,String)", "[Object]value()", "[ImmutableList<Object>]valueFor(SchemaPlus)", "[List<E>]plus(List<E>,E)"], "method_uris": ["src/main/java/net/hydromatic/morel/foreign/CalciteForeignValue.java.CalciteForeignValue.[]CalciteForeignValue(Calcite,SchemaPlus,boolean)", "src/main/java/net/hydromatic/morel/foreign/CalciteForeignValue.java.CalciteForeignValue.[Type]type(TypeSystem)", "src/main/java/net/hydromatic/morel/foreign/CalciteForeignValue.java.CalciteForeignValue.[Type]toType(SchemaPlus,TypeSystem)", "src/main/java/net/hydromatic/morel/foreign/CalciteForeignValue.java.CalciteForeignValue.[Type]toType(Table,TypeSystem)", "src/main/java/net/hydromatic/morel/foreign/CalciteForeignValue.java.CalciteForeignValue.[String]convert(String)", "src/main/java/net/hydromatic/morel/foreign/CalciteForeignValue.java.CalciteForeignValue.[String]convert(boolean,String)", "src/main/java/net/hydromatic/morel/foreign/CalciteForeignValue.java.CalciteForeignValue.[Object]value()", "src/main/java/net/hydromatic/morel/foreign/CalciteForeignValue.java.CalciteForeignValue.[ImmutableList<Object>]valueFor(SchemaPlus)", "src/main/java/net/hydromatic/morel/foreign/CalciteForeignValue.java.CalciteForeignValue.[List<E>]plus(List<E>,E)"], "overrides": null, "attributes": [], "class_docstring": " Value based on a Calcite schema.\n\n<p>In ML, it appears as a record with a field for each table.\n", "original_string": "public class CalciteForeignValue implements ForeignValue {\n  private final Calcite calcite;\n  private final SchemaPlus schema;\n  private final boolean lower;\n\n  /** Creates a CalciteForeignValue. */\n  public CalciteForeignValue(Calcite calcite, SchemaPlus schema, boolean lower) {\n    this.calcite = requireNonNull(calcite);\n    this.schema = requireNonNull(schema);\n    this.lower = lower;\n  }\n\n  public Type type(TypeSystem typeSystem) {\n    return toType(schema, typeSystem);\n  }\n\n  private Type toType(SchemaPlus schema, TypeSystem typeSystem) {\n    final SortedMap<String, Type> fields = RecordType.mutableMap();\n    schema.getTableNames().forEach(tableName -> {\n      Table table = requireNonNull(schema.getTable(tableName));\n      fields.put(convert(tableName), toType(table, typeSystem));\n    });\n    schema.getSubSchemaNames().forEach(subSchemaName -> {\n      final SchemaPlus subSchema =\n          requireNonNull(schema.getSubSchema(subSchemaName));\n      fields.put(convert(subSchemaName), toType(subSchema, typeSystem));\n    });\n\n    return typeSystem.recordType(fields);\n  }\n\n  private Type toType(Table table, TypeSystem typeSystem) {\n    final PairList<String, Type> fields = PairList.of();\n    table.getRowType(calcite.typeFactory)\n        .getFieldList()\n        .forEach(field ->\n            fields.add(convert(field.getName()), Converters.fieldType(field)));\n    return typeSystem.listType(typeSystem.recordType(fields));\n  }\n\n  private String convert(String name) {\n    return convert(lower, name);\n  }\n\n  private static String convert(boolean lower, String name) {\n    return lower ? name.toLowerCase(Locale.ROOT) : name;\n  }\n\n  public Object value() {\n    return valueFor(schema);\n  }\n\n  private ImmutableList<Object> valueFor(SchemaPlus schema) {\n    final SortedMap<String, Object> fieldValues = RecordType.mutableMap();\n    final List<String> names = Schemas.path(schema).names();\n    schema.getTableNames().forEach(tableName -> {\n      final RelBuilder b = calcite.relBuilder;\n      b.scan(plus(names, tableName));\n      final List<RexNode> exprList = b.peek().getRowType()\n          .getFieldList().stream()\n          .map(f -> Ord.of(f.getIndex(), convert(f.getName())))\n          .sorted(Map.Entry.comparingByValue())\n          .map(p -> b.alias(b.field(p.i), p.e))\n          .collect(Collectors.toList());\n      b.project(exprList, ImmutableList.of(), true);\n      final RelNode rel = b.build();\n      final Converter<Object[]> converter = Converters.ofRow(rel.getRowType());\n      fieldValues.put(convert(tableName),\n          new RelList(rel, calcite.dataContext, converter));\n    });\n\n    // Recursively walk sub-schemas and add their tables to fieldValues\n    schema.getSubSchemaNames().forEach(subSchemaName -> {\n      final SchemaPlus subSchema =\n          requireNonNull(schema.getSubSchema(subSchemaName));\n      fieldValues.put(convert(subSchemaName),\n          valueFor(subSchema));\n    });\n    return ImmutableList.copyOf(fieldValues.values());\n  }\n\n  /** Returns a copy of a list with one element appended. */\n  private static <E> List<E> plus(List<E> list, E e) {\n    return ImmutableList.<E>builder().addAll(list).add(e).build();\n  }\n\n}", "super_interfaces": ["ForeignValue"], "fields": [{"attribute_expression": "private final Calcite calcite;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Calcite", "name": "calcite", "syntax_pass": true}, {"attribute_expression": "private final SchemaPlus schema;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "SchemaPlus", "name": "schema", "syntax_pass": true}, {"attribute_expression": "private final boolean lower;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "boolean", "name": "lower", "syntax_pass": true}]}, {"uris": "src/main/java/net/hydromatic/morel/parse/Parsers.java.Parsers", "name": "Parsers", "file_path": "src/main/java/net/hydromatic/morel/parse/Parsers.java", "superclasses": "", "methods": ["[]Parsers()", "[String]unquoteIdentifier(String)", "[String]unquoteString(String)", "[char]unquoteCharLiteral(String)", "[StringBuilder]appendId(StringBuilder,String)"], "method_uris": ["src/main/java/net/hydromatic/morel/parse/Parsers.java.Parsers.[]Parsers()", "src/main/java/net/hydromatic/morel/parse/Parsers.java.Parsers.[String]unquoteIdentifier(String)", "src/main/java/net/hydromatic/morel/parse/Parsers.java.Parsers.[String]unquoteString(String)", "src/main/java/net/hydromatic/morel/parse/Parsers.java.Parsers.[char]unquoteCharLiteral(String)", "src/main/java/net/hydromatic/morel/parse/Parsers.java.Parsers.[StringBuilder]appendId(StringBuilder,String)"], "overrides": null, "attributes": [], "class_docstring": "\nUtilities for parsing.\n", "original_string": "public final class Parsers {\n  private Parsers() {\n  }\n\n  /** Given quoted identifier {@code `abc`} returns {@code abc}.\n   * Converts any doubled back-ticks to a single back-tick.\n   * Assumes there are no single back-ticks. */\n  public static String unquoteIdentifier(String s) {\n    assert s.charAt(0) == '`';\n    assert s.charAt(s.length() - 1) == '`';\n    return s.substring(1, s.length() - 1)\n        .replace(\"``\", \"`\");\n  }\n\n  /** Given quoted string {@code \"abc\"} returns {@code abc}. */\n  public static String unquoteString(String s) {\n    assert s.charAt(0) == '\"';\n    assert s.charAt(s.length() - 1) == '\"';\n    return s.substring(1, s.length() - 1)\n        .replace(\"\\\\\\\\\", \"\\\\\")\n        .replace(\"\\\\\\\"\", \"\\\"\");\n  }\n\n  /** Given quoted char literal {@code #\"a\"} returns {@code a}. */\n  public static char unquoteCharLiteral(String s) {\n    assert s.charAt(0) == '#';\n    assert s.charAt(1) == '\"';\n    assert s.charAt(s.length() - 1) == '\"';\n    String image = s.substring(2, s.length() - 1)\n        .replace(\"\\\\\\\\\", \"\\\\\")\n        .replace(\"\\\\\\\"\", \"\\\"\");\n    if (image.length() != 1) {\n      throw new RuntimeException(\"Error: character constant not length 1\");\n    }\n    return image.charAt(0);\n  }\n\n  /** Appends an identifier. Encloses it in back-ticks if necessary. */\n  public static StringBuilder appendId(StringBuilder buf, String id) {\n    if (id.contains(\"`\") || id.contains(\" \")) {\n      return buf.append(\"`\")\n          .append(id.replaceAll(\"`\", \"``\"))\n          .append(\"`\");\n    } else {\n      return buf.append(id);\n    }\n  }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/main/java/net/hydromatic/morel/parse/Span.java.Span", "name": "Span", "file_path": "src/main/java/net/hydromatic/morel/parse/Span.java", "superclasses": "", "methods": ["[]Span()", "[Span]of()", "[Span]of(Pos)", "[Span]of(AstNode)", "[Span]of(AstNode,AstNode)", "[Span]of(Collection<? extends AstNode>)", "[Span]add(AstNode)", "[Span]addIf(AstNode)", "[Span]add(Pos)", "[Span]addAll(Iterable<? extends AstNode>)", "[Span]add(MorelParser)", "[Pos]pos()", "[Pos]end(MorelParser)", "[Pos]end(AstNode)", "[Span]clear()"], "method_uris": ["src/main/java/net/hydromatic/morel/parse/Span.java.Span.[]Span()", "src/main/java/net/hydromatic/morel/parse/Span.java.Span.[Span]of()", "src/main/java/net/hydromatic/morel/parse/Span.java.Span.[Span]of(Pos)", "src/main/java/net/hydromatic/morel/parse/Span.java.Span.[Span]of(AstNode)", "src/main/java/net/hydromatic/morel/parse/Span.java.Span.[Span]of(AstNode,AstNode)", "src/main/java/net/hydromatic/morel/parse/Span.java.Span.[Span]of(Collection<? extends AstNode>)", "src/main/java/net/hydromatic/morel/parse/Span.java.Span.[Span]add(AstNode)", "src/main/java/net/hydromatic/morel/parse/Span.java.Span.[Span]addIf(AstNode)", "src/main/java/net/hydromatic/morel/parse/Span.java.Span.[Span]add(Pos)", "src/main/java/net/hydromatic/morel/parse/Span.java.Span.[Span]addAll(Iterable<? extends AstNode>)", "src/main/java/net/hydromatic/morel/parse/Span.java.Span.[Span]add(MorelParser)", "src/main/java/net/hydromatic/morel/parse/Span.java.Span.[Pos]pos()", "src/main/java/net/hydromatic/morel/parse/Span.java.Span.[Pos]end(MorelParser)", "src/main/java/net/hydromatic/morel/parse/Span.java.Span.[Pos]end(AstNode)", "src/main/java/net/hydromatic/morel/parse/Span.java.Span.[Span]clear()"], "overrides": null, "attributes": [], "class_docstring": "\nBuilder for {@link Pos}.\n\n<p>Because it is mutable, it is convenient for keeping track of the\npositions of the tokens that go into a non-terminal. It can be passed\ninto methods, which can add the positions of tokens consumed to it.\n\n<p>Some patterns:\n\n<ul>\n<li>{@code final Span s;} declaration of a Span at the top of a production\n<li>{@code s = span();} initializes s to a Span that includes the token we\n  just saw; very often occurs immediately after the first token in the\n  production\n<li>{@code s.end(this);} adds the most recent token to span s and evaluates\n  to a Position that spans from beginning to end; commonly used\n  when making a call to a function\n<li>{@code s.pos()} returns a position spanning all tokens in the list\n<li>{@code s.add(node);} adds a AstNode's parser position to a span\n<li>{@code s.addAll(nodeList);} adds several AstNodes' parser positions to\n  a span\n<li>{@code s = Span.of();} initializes s to an empty Span, not even\n  including the most recent token; rarely used\n</ul>\n", "original_string": "public final class Span {\n  private final List<Pos> posList = new ArrayList<>();\n\n  /** Use one of the {@link #of} methods. */\n  private Span() {}\n\n  /** Creates an empty Span. */\n  public static Span of() {\n    return new Span();\n  }\n\n  /** Creates a Span with one position. */\n  public static Span of(Pos p) {\n    return new Span().add(p);\n  }\n\n  /** Creates a Span of one node. */\n  public static Span of(AstNode n) {\n    return new Span().add(n);\n  }\n\n  /** Creates a Span between two nodes. */\n  public static Span of(AstNode n0, AstNode n1) {\n    return new Span().add(n0).add(n1);\n  }\n\n  /** Creates a Span of a list of nodes. */\n  public static Span of(Collection<? extends AstNode> nodes) {\n    return new Span().addAll(nodes);\n  }\n\n  /** Adds a node's position to the list,\n   * and returns this Span. */\n  public Span add(AstNode n) {\n    return add(n.pos);\n  }\n\n  /** Adds a node's position to the list if the node is not null,\n   * and returns this Span. */\n  public Span addIf(AstNode n) {\n    return n == null ? this : add(n);\n  }\n\n  /** Adds a position to the list,\n   * and returns this Span. */\n  public Span add(Pos pos) {\n    posList.add(pos);\n    return this;\n  }\n\n  /** Adds the positions of a collection of nodes to the list,\n   * and returns this Span. */\n  public Span addAll(Iterable<? extends AstNode> nodes) {\n    for (AstNode node : nodes) {\n      add(node);\n    }\n    return this;\n  }\n\n  /** Adds the position of the last token emitted by a parser to the list,\n   * and returns this Span. */\n  public Span add(MorelParser parser) {\n    try {\n      final Pos pos = parser.pos();\n      return add(pos);\n    } catch (Exception e) {\n      // getPos does not really throw an exception\n      throw new AssertionError(e);\n    }\n  }\n\n  /** Returns a position spanning the earliest position to the latest.\n   * Does not assume that the positions are sorted.\n   * Throws if the list is empty. */\n  public Pos pos() {\n    switch (posList.size()) {\n    case 0:\n      throw new AssertionError();\n    case 1:\n      return posList.get(0);\n    default:\n      return Pos.sum(posList);\n    }\n  }\n\n  /** Adds the position of the last token emitted by a parser to the list,\n   * and returns a position that covers the whole range. */\n  public Pos end(MorelParser parser) {\n    return add(parser).pos();\n  }\n\n  /** Adds a node's position to the list,\n   * and returns a position that covers the whole range. */\n  public Pos end(AstNode n) {\n    return add(n).pos();\n  }\n\n  /** Clears the contents of this Span, and returns this Span. */\n  public Span clear() {\n    posList.clear();\n    return this;\n  }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private final List<Pos> posList = new ArrayList<>();", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "List<Pos>", "name": "posList = new ArrayList<>()", "syntax_pass": true}]}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl", "name": "MorelParserImpl", "file_path": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java", "superclasses": "", "methods": ["[void]setTabSize(int)", "[Pos]pos()", "[void]zero(String)", "[void]debug_message1()", "[Literal]literal()", "[Literal]literalEof()", "[Literal]numericLiteral()", "[Literal]stringLiteral()", "[Literal]charLiteral()", "[Id]identifier()", "[RecordSelector]recordSelector()", "[TyVar]tyVar()", "[List<TyVar>]tyVarOptionalList()", "[RecordType]recordType()", "[void]fieldType(Map<String, Type>)", "[Exp]ifThenElse()", "[Exp]let()", "[Exp]caseOf()", "[Exp]from()", "[void]fromFirstScan(List<FromStep>)", "[void]fromScan(List<FromStep>)", "[void]fromStep(List<FromStep>)", "[Pair<Pat, Exp>]fromSource()", "[List<Aggregate>]aggregateCommaList()", "[Aggregate]aggregate()", "[List<OrderItem>]orderItemCommaList()", "[OrderItem]orderItem()", "[Exp]fn()", "[List<Match>]matchList()", "[Match]match()", "[Exp]expression9()", "[Exp]expression8()", "[Exp]expression7()", "[Exp]expression6()", "[Exp]expression5()", "[Exp]expression4()", "[Exp]expression3()", "[Exp]expression2()", "[Exp]expression1()", "[Exp]expression()", "[PairList<Id, Exp>]namedExpressionCommaList()", "[void]namedExpression(PairList<Id, Exp>)", "[Exp]atom()", "[void]recordExp(PairList<String, Exp>)", "[void]addValDecl(List)", "[ValDecl]valDecl()", "[void]valBind(List<Ast.ValBind>)", "[Ast.Decl]decl()", "[Ast.Decl]declEof()", "[Ast.DatatypeDecl]datatypeDecl()", "[void]datatypeBind(List<Ast.DatatypeBind>)", "[Ast.TyCon]typeConstructor()", "[Ast.FunDecl]funDecl()", "[void]funBind(List<FunBind>)", "[void]funMatch(List<FunMatch>)", "[Pat]pat()", "[Pat]pat5()", "[Pat]pat4()", "[Pat]atomPat()", "[void]recordPat(Map<String, Pat>)", "[Ast.Type]atomicType()", "[Ast.Type]type7()", "[Ast.Type]type6()", "[Ast.Type]type()", "[Ast.Type]namedType()", "[AstNode]statement()", "[AstNode]statementSemicolon()", "[AstNode]statementSemicolonOrEof()", "[AstNode]statementEof()", "[boolean]jj_2_1(int)", "[boolean]jj_2_2(int)", "[boolean]jj_2_3(int)", "[boolean]jj_2_4(int)", "[boolean]jj_2_5(int)", "[boolean]jj_2_6(int)", "[boolean]jj_2_7(int)", "[boolean]jj_3_3()", "[boolean]jj_3_4()", "[boolean]jj_3R_charLiteral_183_3_83()", "[boolean]jj_3_1()", "[boolean]jj_3_2()", "[boolean]jj_3R_stringLiteral_173_3_82()", "[boolean]jj_3R_fn_546_3_72()", "[boolean]jj_3R_expression7_634_3_53()", "[boolean]jj_3R_expression7_632_3_51()", "[boolean]jj_3R_expression7_632_3_52()", "[boolean]jj_3R_atom_913_3_67()", "[boolean]jj_3R_expression4_716_3_48()", "[boolean]jj_3R_numericLiteral_145_3_86()", "[boolean]jj_3R_recordPat_1283_5_45()", "[boolean]jj_3R_recordPat_1282_5_44()", "[boolean]jj_3R_recordPat_1281_5_43()", "[boolean]jj_3R_from_332_3_75()", "[boolean]jj_3R_expression_807_3_40()", "[boolean]jj_3R_expression8_616_3_54()", "[boolean]jj_3R_recordPat_1281_3_41()", "[boolean]jj_3R_atom_898_3_66()", "[boolean]jj_3R_numericLiteral_131_3_85()", "[boolean]jj_3R_expression5_699_3_49()", "[boolean]jj_3R_caseOf_318_3_74()", "[boolean]jj_3_7()", "[boolean]jj_3R_expression1_792_3_42()", "[boolean]jj_3R_expression9_599_3_55()", "[boolean]jj_3R_numericLiteral_122_3_84()", "[boolean]jj_3R_numericLiteral_122_3_81()", "[boolean]jj_3R_recordSelector_210_3_69()", "[boolean]jj_3R_atom_874_3_65()", "[boolean]jj_3R_let_303_3_71()", "[boolean]jj_3R_atom_872_3_64()", "[boolean]jj_3R_expression2_776_3_46()", "[boolean]jj_3R_atom_870_3_63()", "[boolean]jj_3R_atom_868_3_62()", "[boolean]jj_3R_atom_866_3_61()", "[boolean]jj_3R_literal_104_3_80()", "[boolean]jj_3R_atom_864_3_60()", "[boolean]jj_3R_literal_102_3_79()", "[boolean]jj_3R_atom_862_3_59()", "[boolean]jj_3R_identifier_196_3_77()", "[boolean]jj_3R_literal_100_3_78()", "[boolean]jj_3R_literal_100_3_70()", "[boolean]jj_3R_atom_860_3_58()", "[boolean]jj_3R_identifier_193_3_76()", "[boolean]jj_3R_identifier_193_3_68()", "[boolean]jj_3R_atom_858_3_56()", "[boolean]jj_3R_atom_858_3_57()", "[boolean]jj_3_6()", "[boolean]jj_3R_ifThenElse_287_3_73()", "[boolean]jj_3R_expression6_666_3_50()", "[boolean]jj_3R_expression3_760_3_47()", "[boolean]jj_3_5()", "[void]jj_la1_init_0()", "[void]jj_la1_init_1()", "[void]jj_la1_init_2()", "[]MorelParserImpl(java.io.InputStream)", "[]MorelParserImpl(java.io.InputStream,String)", "[void]ReInit(java.io.InputStream)", "[void]ReInit(java.io.InputStream,String)", "[]MorelParserImpl(java.io.Reader)", "[void]ReInit(java.io.Reader)", "[]MorelParserImpl(MorelParserImplTokenManager)", "[void]ReInit(MorelParserImplTokenManager)", "[Token]jj_consume_token(int)", "[boolean]jj_scan_token(int)", "[Token]getNextToken()", "[Token]getToken(int)", "[int]jj_ntk_f()", "[void]jj_add_error_token(int,int)", "[ParseException]generateParseException()", "[boolean]trace_enabled()", "[void]enable_tracing()", "[void]disable_tracing()", "[void]jj_rescan_token()", "[void]jj_save(int,int)"], "method_uris": ["target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[void]setTabSize(int)", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[Pos]pos()", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[void]zero(String)", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[void]debug_message1()", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[Literal]literal()", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[Literal]literalEof()", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[Literal]numericLiteral()", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[Literal]stringLiteral()", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[Literal]charLiteral()", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[Id]identifier()", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[RecordSelector]recordSelector()", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[TyVar]tyVar()", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[List<TyVar>]tyVarOptionalList()", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[RecordType]recordType()", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[void]fieldType(Map<String, Type>)", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[Exp]ifThenElse()", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[Exp]let()", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[Exp]caseOf()", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[Exp]from()", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[void]fromFirstScan(List<FromStep>)", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[void]fromScan(List<FromStep>)", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[void]fromStep(List<FromStep>)", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[Pair<Pat, Exp>]fromSource()", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[List<Aggregate>]aggregateCommaList()", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[Aggregate]aggregate()", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[List<OrderItem>]orderItemCommaList()", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[OrderItem]orderItem()", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[Exp]fn()", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[List<Match>]matchList()", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[Match]match()", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[Exp]expression9()", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[Exp]expression8()", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[Exp]expression7()", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[Exp]expression6()", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[Exp]expression5()", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[Exp]expression4()", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[Exp]expression3()", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[Exp]expression2()", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[Exp]expression1()", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[Exp]expression()", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[PairList<Id, Exp>]namedExpressionCommaList()", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[void]namedExpression(PairList<Id, Exp>)", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[Exp]atom()", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[void]recordExp(PairList<String, Exp>)", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[void]addValDecl(List)", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[ValDecl]valDecl()", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[void]valBind(List<Ast.ValBind>)", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[Ast.Decl]decl()", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[Ast.Decl]declEof()", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[Ast.DatatypeDecl]datatypeDecl()", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[void]datatypeBind(List<Ast.DatatypeBind>)", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[Ast.TyCon]typeConstructor()", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[Ast.FunDecl]funDecl()", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[void]funBind(List<FunBind>)", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[void]funMatch(List<FunMatch>)", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[Pat]pat()", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[Pat]pat5()", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[Pat]pat4()", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[Pat]atomPat()", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[void]recordPat(Map<String, Pat>)", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[Ast.Type]atomicType()", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[Ast.Type]type7()", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[Ast.Type]type6()", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[Ast.Type]type()", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[Ast.Type]namedType()", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[AstNode]statement()", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[AstNode]statementSemicolon()", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[AstNode]statementSemicolonOrEof()", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[AstNode]statementEof()", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[boolean]jj_2_1(int)", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[boolean]jj_2_2(int)", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[boolean]jj_2_3(int)", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[boolean]jj_2_4(int)", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[boolean]jj_2_5(int)", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[boolean]jj_2_6(int)", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[boolean]jj_2_7(int)", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[boolean]jj_3_3()", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[boolean]jj_3_4()", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[boolean]jj_3R_charLiteral_183_3_83()", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[boolean]jj_3_1()", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[boolean]jj_3_2()", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[boolean]jj_3R_stringLiteral_173_3_82()", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[boolean]jj_3R_fn_546_3_72()", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[boolean]jj_3R_expression7_634_3_53()", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[boolean]jj_3R_expression7_632_3_51()", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[boolean]jj_3R_expression7_632_3_52()", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[boolean]jj_3R_atom_913_3_67()", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[boolean]jj_3R_expression4_716_3_48()", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[boolean]jj_3R_numericLiteral_145_3_86()", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[boolean]jj_3R_recordPat_1283_5_45()", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[boolean]jj_3R_recordPat_1282_5_44()", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[boolean]jj_3R_recordPat_1281_5_43()", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[boolean]jj_3R_from_332_3_75()", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[boolean]jj_3R_expression_807_3_40()", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[boolean]jj_3R_expression8_616_3_54()", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[boolean]jj_3R_recordPat_1281_3_41()", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[boolean]jj_3R_atom_898_3_66()", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[boolean]jj_3R_numericLiteral_131_3_85()", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[boolean]jj_3R_expression5_699_3_49()", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[boolean]jj_3R_caseOf_318_3_74()", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[boolean]jj_3_7()", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[boolean]jj_3R_expression1_792_3_42()", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[boolean]jj_3R_expression9_599_3_55()", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[boolean]jj_3R_numericLiteral_122_3_84()", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[boolean]jj_3R_numericLiteral_122_3_81()", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[boolean]jj_3R_recordSelector_210_3_69()", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[boolean]jj_3R_atom_874_3_65()", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[boolean]jj_3R_let_303_3_71()", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[boolean]jj_3R_atom_872_3_64()", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[boolean]jj_3R_expression2_776_3_46()", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[boolean]jj_3R_atom_870_3_63()", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[boolean]jj_3R_atom_868_3_62()", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[boolean]jj_3R_atom_866_3_61()", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[boolean]jj_3R_literal_104_3_80()", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[boolean]jj_3R_atom_864_3_60()", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[boolean]jj_3R_literal_102_3_79()", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[boolean]jj_3R_atom_862_3_59()", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[boolean]jj_3R_identifier_196_3_77()", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[boolean]jj_3R_literal_100_3_78()", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[boolean]jj_3R_literal_100_3_70()", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[boolean]jj_3R_atom_860_3_58()", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[boolean]jj_3R_identifier_193_3_76()", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[boolean]jj_3R_identifier_193_3_68()", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[boolean]jj_3R_atom_858_3_56()", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[boolean]jj_3R_atom_858_3_57()", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[boolean]jj_3_6()", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[boolean]jj_3R_ifThenElse_287_3_73()", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[boolean]jj_3R_expression6_666_3_50()", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[boolean]jj_3R_expression3_760_3_47()", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[boolean]jj_3_5()", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[void]jj_la1_init_0()", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[void]jj_la1_init_1()", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[void]jj_la1_init_2()", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[]MorelParserImpl(java.io.InputStream)", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[]MorelParserImpl(java.io.InputStream,String)", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[void]ReInit(java.io.InputStream)", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[void]ReInit(java.io.InputStream,String)", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[]MorelParserImpl(java.io.Reader)", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[void]ReInit(java.io.Reader)", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[]MorelParserImpl(MorelParserImplTokenManager)", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[void]ReInit(MorelParserImplTokenManager)", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[Token]jj_consume_token(int)", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[boolean]jj_scan_token(int)", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[Token]getNextToken()", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[Token]getToken(int)", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[int]jj_ntk_f()", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[void]jj_add_error_token(int,int)", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[ParseException]generateParseException()", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[boolean]trace_enabled()", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[void]enable_tracing()", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[void]disable_tracing()", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[void]jj_rescan_token()", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[void]jj_save(int,int)"], "overrides": null, "attributes": [{"original_string": "  @SuppressWarnings(\"serial\")\n  static private final class LookaheadSuccess extends java.lang.Error {\n    @Override\n    public Throwable fillInStackTrace() {\n      return this;\n    }\n  }", "definition": "  @SuppressWarnings(\"serial\")\n  static private final class LookaheadSuccess extends java.lang.Error", "class_docstring": "", "name": "LookaheadSuccess", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "@SuppressWarnings(\"serial\")\n  static private final", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings(\"serial\")", "static", "private", "final"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @Override\n    public Throwable fillInStackTrace() {\n      return this;\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Throwable", "classes": []}, "name": "fillInStackTrace", "params": [], "body": "                                        {\n      return this;\n    }", "signature": "@Override\n    public Throwable fillInStackTrace()"}]}, {"original_string": "  static final class JJCalls {\n\t int gen;\n\t Token first;\n\t int arg;\n\t JJCalls next;\n  }", "definition": "  static final class JJCalls", "class_docstring": "", "name": "JJCalls", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "static final", "marker_annotations": [], "non_marker_annotations": ["static", "final"], "comments": [], "fields": [{"attribute_expression": "int gen;", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "int", "name": "gen", "syntax_pass": true}, {"attribute_expression": "Token first;", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "Token", "name": "first", "syntax_pass": true}, {"attribute_expression": "int arg;", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "int", "name": "arg", "syntax_pass": true}, {"attribute_expression": "JJCalls next;", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "JJCalls", "name": "next", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": []}], "class_docstring": "\nParser for Standard ML, generated from MorelParser.jj by JavaCC.\n", "original_string": "public class MorelParserImpl implements MorelParser, MorelParserImplConstants {\n  private static final Logger LOGGER =\n      LoggerFactory.getLogger(\"net.hydromatic.morel.parse\");\n\n  private int lineOffset;\n  private String file = \"\";\n\n  public void setTabSize(int tabSize) {\n    jj_input_stream.setTabSize(tabSize);\n  }\n\n  public Pos pos() {\n    return new Pos(file,\n        token.beginLine - lineOffset, token.beginColumn,\n        token.endLine - lineOffset, token.endColumn + 1);\n  }\n\n  public void zero(String file) {\n    this.file = file;\n    if (jj_input_stream.bufpos >= 0) {\n      this.lineOffset = jj_input_stream.bufline[jj_input_stream.bufpos];\n    }\n  }\n\n  void debug_message1() throws ParseException {LOGGER.info(\"{} , {}\", getToken(0).image, getToken(1).image);\n  }\n\n/** Parses a literal expression. */\n  final public Literal literal() throws ParseException {final Ast.Literal e;\n    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n    case NON_NEGATIVE_INTEGER_LITERAL:\n    case NEGATIVE_INTEGER_LITERAL:\n    case REAL_LITERAL:\n    case SCIENTIFIC_LITERAL:{\n      e = numericLiteral();\n{if (\"\" != null) return e;}\n      break;\n      }\n    case QUOTED_STRING:{\n      e = stringLiteral();\n{if (\"\" != null) return e;}\n      break;\n      }\n    case CHAR_LITERAL:{\n      e = charLiteral();\n{if (\"\" != null) return e;}\n      break;\n      }\n    default:\n      jj_la1[0] = jj_gen;\n      jj_consume_token(-1);\n      throw new ParseException();\n    }\n    throw new Error(\"Missing return statement in function\");\n}\n\n/** Parses a literal expression followed by end-of-file. */\n  final public Literal literalEof() throws ParseException {final Literal n;\n    n = literal();\n    jj_consume_token(0);\n{if (\"\" != null) return n;}\n    throw new Error(\"Missing return statement in function\");\n}\n\n/** Parses a numeric literal */\n  final public Literal numericLiteral() throws ParseException {final BigDecimal d;\n    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n    case NON_NEGATIVE_INTEGER_LITERAL:\n    case NEGATIVE_INTEGER_LITERAL:{\n      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n      case NON_NEGATIVE_INTEGER_LITERAL:{\n        jj_consume_token(NON_NEGATIVE_INTEGER_LITERAL);\n        break;\n        }\n      case NEGATIVE_INTEGER_LITERAL:{\n        jj_consume_token(NEGATIVE_INTEGER_LITERAL);\n        break;\n        }\n      default:\n        jj_la1[1] = jj_gen;\n        jj_consume_token(-1);\n        throw new ParseException();\n      }\nif (token.image.startsWith(\"~\")) {\n      d = new BigDecimal(token.image.substring(1)).negate();\n    } else {\n      d = new BigDecimal(token.image);\n    }\n    {if (\"\" != null) return ast.intLiteral(pos(), d);}\n      break;\n      }\n    case REAL_LITERAL:{\n      jj_consume_token(REAL_LITERAL);\nif (token.image.startsWith(\"~\")) {\n      d = new BigDecimal(token.image.substring(1)).negate();\n      if (d.compareTo(BigDecimal.ZERO) == 0) {\n        // In IEEE floating point, and ML's 'real' type, negative zero is\n        // different from positive zero.\n        {if (\"\" != null) return ast.realLiteral(pos(), -0.f);}\n      }\n    } else {\n      d = new BigDecimal(token.image);\n    }\n    {if (\"\" != null) return ast.realLiteral(pos(), d);}\n      break;\n      }\n    case SCIENTIFIC_LITERAL:{\n      jj_consume_token(SCIENTIFIC_LITERAL);\nfinal int e = Math.max(token.image.indexOf(\"e\"),\n      token.image.indexOf(\"E\"));\n    if (token.image.startsWith(\"~\")) {\n      d = new BigDecimal(token.image.substring(1, e)).negate();\n      if (d.compareTo(BigDecimal.ZERO) == 0) {\n        // In IEEE floating point, and ML's 'real' type, negative zero is\n        // different from positive zero.\n        {if (\"\" != null) return ast.realLiteral(pos(), -0.f);}\n      }\n    } else {\n      d = new BigDecimal(token.image.substring(0, e));\n    }\n    final int exponent;\n    if (token.image.startsWith(\"~\", e + 1)) {\n      exponent = -Integer.parseInt(token.image.substring(e + 2));\n    } else {\n      exponent = Integer.parseInt(token.image.substring(e + 1));\n    }\n    {if (\"\" != null) return ast.realLiteral(pos(), d.scaleByPowerOfTen(exponent));}\n      break;\n      }\n    default:\n      jj_la1[2] = jj_gen;\n      jj_consume_token(-1);\n      throw new ParseException();\n    }\n    throw new Error(\"Missing return statement in function\");\n}\n\n/** Parses a string literal. */\n  final public Literal stringLiteral() throws ParseException {\n    jj_consume_token(QUOTED_STRING);\n{if (\"\" != null) return ast.stringLiteral(pos(), unquoteString(token.image));}\n    throw new Error(\"Missing return statement in function\");\n}\n\n/** Parses a char literal. */\n  final public Literal charLiteral() throws ParseException {\n    jj_consume_token(CHAR_LITERAL);\n{if (\"\" != null) return ast.charLiteral(pos(), unquoteCharLiteral(token.image));}\n    throw new Error(\"Missing return statement in function\");\n}\n\n/** Parses an identifier. */\n  final public Id identifier() throws ParseException {\n    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n    case IDENTIFIER:{\n      jj_consume_token(IDENTIFIER);\n{if (\"\" != null) return ast.id(pos(), token.image);}\n      break;\n      }\n    case QUOTED_IDENTIFIER:{\n      jj_consume_token(QUOTED_IDENTIFIER);\n{if (\"\" != null) return ast.id(pos(), unquoteIdentifier(token.image));}\n      break;\n      }\n    default:\n      jj_la1[3] = jj_gen;\n      jj_consume_token(-1);\n      throw new ParseException();\n    }\n    throw new Error(\"Missing return statement in function\");\n}\n\n/** Parses a record selector, e.g. \"{@code #empno}\".\n *\n * <p>You use it as a function to extract a field of a record;\n * for example <code>#empno {empno=10, name=\"Fred\"}</code>\n * yields {@code 10}. */\n  final public RecordSelector recordSelector() throws ParseException {\n    jj_consume_token(LABEL);\nassert token.image.startsWith(\"#\");\n    {if (\"\" != null) return ast.recordSelector(pos(), token.image.substring(1));}\n    throw new Error(\"Missing return statement in function\");\n}\n\n/** Parses a type variable, e.g. \"{@code 'a}\". */\n  final public TyVar tyVar() throws ParseException {\n    jj_consume_token(TY_VAR);\nassert token.image.startsWith(\"'\");\n    {if (\"\" != null) return ast.tyVar(pos(), token.image);}\n    throw new Error(\"Missing return statement in function\");\n}\n\n/** Parses a type variable, or a list of 1 or more type variables in\n *  parentheses, or empty. Valid examples: \"\", \"'a\", \"('a)\", \"('a, 'b)\". */\n  final public List<TyVar> tyVarOptionalList() throws ParseException {TyVar tyVar;\n    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n    case TY_VAR:{\n      tyVar = tyVar();\n{if (\"\" != null) return ImmutableList.of(tyVar);}\n      break;\n      }\n    case LPAREN:{\n      jj_consume_token(LPAREN);\nList<TyVar> tyVars = new ArrayList<>();\n      tyVar = tyVar();\ntyVars.add(tyVar);\n      label_1:\n      while (true) {\n        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n        case COMMA:{\n          ;\n          break;\n          }\n        default:\n          jj_la1[4] = jj_gen;\n          break label_1;\n        }\n        jj_consume_token(COMMA);\n        tyVar = tyVar();\ntyVars.add(tyVar);\n      }\n{if (\"\" != null) return tyVars;}\n      break;\n      }\n    default:\n      jj_la1[5] = jj_gen;\n{if (\"\" != null) return ImmutableList.of();}\n    }\n    throw new Error(\"Missing return statement in function\");\n}\n\n/** Parses a record type, e.g. \"{@code {a:int,b:string} }\". */\n  final public RecordType recordType() throws ParseException {final Span span;\n    jj_consume_token(LBRACE);\nspan = Span.of(pos());\n  final Map<String, Type> map = new LinkedHashMap<>();\n    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n    case IDENTIFIER:\n    case QUOTED_IDENTIFIER:{\n      fieldType(map);\n      label_2:\n      while (true) {\n        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n        case COMMA:{\n          ;\n          break;\n          }\n        default:\n          jj_la1[6] = jj_gen;\n          break label_2;\n        }\n        jj_consume_token(COMMA);\n        fieldType(map);\n      }\n      break;\n      }\n    default:\n      jj_la1[7] = jj_gen;\n      ;\n    }\n    jj_consume_token(RBRACE);\n{if (\"\" != null) return ast.recordType(span.end(this), map);}\n    throw new Error(\"Missing return statement in function\");\n}\n\n  final public void fieldType(Map<String, Type> map) throws ParseException {final Id id;\n  final Type type;\n    id = identifier();\n    jj_consume_token(COLON);\n    type = type();\nmap.put(id.name, type);\n}\n\n/** Parses a \"if ... then ... else ...\" expression. */\n  final public Exp ifThenElse() throws ParseException {final Span span;\n  final Exp condition;\n  final Exp ifTrue;\n  final Exp ifFalse;\n    jj_consume_token(IF);\nspan = Span.of(pos());\n    condition = expression();\n    jj_consume_token(THEN);\n    ifTrue = expression();\n    jj_consume_token(ELSE);\n    ifFalse = expression();\n{if (\"\" != null) return ast.ifThenElse(span.end(this), condition, ifTrue, ifFalse);}\n    throw new Error(\"Missing return statement in function\");\n}\n\n/** Parses a \"let ... in expression end\" expression. */\n  final public Exp let() throws ParseException {final Span span;\n  final Exp e;\n  Decl decl;\n  final List<Decl> declList = new ArrayList<>();\n    jj_consume_token(LET);\nspan = Span.of(pos());\n    label_3:\n    while (true) {\n      decl = decl();\n      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n      case SEMICOLON:{\n        jj_consume_token(SEMICOLON);\n        break;\n        }\n      default:\n        jj_la1[8] = jj_gen;\n        ;\n      }\ndeclList.add(decl);\n      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n      case DATATYPE:\n      case FUN:\n      case VAL:{\n        ;\n        break;\n        }\n      default:\n        jj_la1[9] = jj_gen;\n        break label_3;\n      }\n    }\n    jj_consume_token(IN);\n    e = expression();\n    jj_consume_token(END);\n{if (\"\" != null) return ast.let(span.end(this), declList, e);}\n    throw new Error(\"Missing return statement in function\");\n}\n\n/** Parses a \"{@code case exp of pat => exp | pat => exp}\" expression. */\n  final public Exp caseOf() throws ParseException {final Span span;\n  final Exp exp;\n  final List<Match> matchList;\n    jj_consume_token(CASE);\nspan = Span.of(pos());\n    exp = expression();\n    jj_consume_token(OF);\n    matchList = matchList();\n{if (\"\" != null) return ast.caseOf(span.end(this), exp, matchList);}\n    throw new Error(\"Missing return statement in function\");\n}\n\n/** Parses a \"{@code from id in exp yield exp}\" expression. */\n  final public Exp from() throws ParseException {final Span span;\n  Span stepSpan;\n  final List<FromStep> steps = new ArrayList<>();\n    jj_consume_token(FROM);\nspan = Span.of(pos());\n    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n    case 1:\n    case NON_NEGATIVE_INTEGER_LITERAL:\n    case NEGATIVE_INTEGER_LITERAL:\n    case REAL_LITERAL:\n    case SCIENTIFIC_LITERAL:\n    case QUOTED_STRING:\n    case CHAR_LITERAL:\n    case LPAREN:\n    case LBRACE:\n    case LBRACKET:\n    case IDENTIFIER:\n    case QUOTED_IDENTIFIER:{\n      fromFirstScan(steps);\n      label_4:\n      while (true) {\n        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n        case COMMA:{\n          ;\n          break;\n          }\n        default:\n          jj_la1[10] = jj_gen;\n          break label_4;\n        }\n        jj_consume_token(COMMA);\n        fromScan(steps);\n      }\n      break;\n      }\n    default:\n      jj_la1[11] = jj_gen;\n      ;\n    }\n    label_5:\n    while (true) {\n      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n      case COMPUTE:\n      case GROUP:\n      case INTO:\n      case JOIN:\n      case ORDER:\n      case SKIP_:\n      case TAKE:\n      case THROUGH:\n      case WHERE:\n      case YIELD:{\n        ;\n        break;\n        }\n      default:\n        jj_la1[12] = jj_gen;\n        break label_5;\n      }\n      fromStep(steps);\n    }\n{if (\"\" != null) return ast.from(span.end(this), steps);}\n    throw new Error(\"Missing return statement in function\");\n}\n\n  final public void fromFirstScan(List<FromStep> steps) throws ParseException {final Pair<Pat, Exp> patExp;\n    patExp = fromSource();\nfinal Span span =\n        patExp.right != null\n          ? Span.of(patExp.left, patExp.right)\n          : Span.of(patExp.left);\n    steps.add(ast.scan(span.pos(), patExp.left, patExp.right, null));\n}\n\n  final public void fromScan(List<FromStep> steps) throws ParseException {final Pair<Pat, Exp> patExp;\n  final Exp condition;\n    patExp = fromSource();\nfinal Span span =\n        patExp.right != null\n          ? Span.of(patExp.left, patExp.right)\n          : Span.of(patExp.left);\n    if (jj_2_1(2)) {\n      jj_consume_token(ON);\n      condition = expression();\n    } else {\ncondition = null;\n    }\nsteps.add(ast.scan(span.end(this), patExp.left, patExp.right, condition));\n}\n\n  final public void fromStep(List<FromStep> steps) throws ParseException {final Span span;\n  final Op op;\n  final Exp filterExp;\n  final Exp intoExp;\n  final Exp skipExp;\n  final Exp throughExp;\n  final Exp takeExp;\n  final Exp yieldExp;\n  final PairList<Id, Exp> groupExps;\n  final Pat pat;\n  final List<Aggregate> aggregates;\n  final List<OrderItem> orderItems;\n    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n    case JOIN:{\n      jj_consume_token(JOIN);\n      fromScan(steps);\n      label_6:\n      while (true) {\n        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n        case COMMA:{\n          ;\n          break;\n          }\n        default:\n          jj_la1[13] = jj_gen;\n          break label_6;\n        }\n        jj_consume_token(COMMA);\n        fromScan(steps);\n      }\n      break;\n      }\n    case WHERE:{\n      jj_consume_token(WHERE);\nspan = Span.of(pos());\n      filterExp = expression();\nsteps.add(ast.where(span.end(this), filterExp));\n      break;\n      }\n    case GROUP:{\n      jj_consume_token(GROUP);\nspan = Span.of(pos());\n      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n      case CASE:\n      case FN:\n      case IF:\n      case LET:\n      case FROM:\n      case NON_NEGATIVE_INTEGER_LITERAL:\n      case NEGATIVE_INTEGER_LITERAL:\n      case REAL_LITERAL:\n      case SCIENTIFIC_LITERAL:\n      case QUOTED_STRING:\n      case CHAR_LITERAL:\n      case LPAREN:\n      case LBRACE:\n      case LBRACKET:\n      case TILDE:\n      case IDENTIFIER:\n      case QUOTED_IDENTIFIER:\n      case LABEL:{\n        groupExps = namedExpressionCommaList();\n        break;\n        }\n      default:\n        jj_la1[14] = jj_gen;\ngroupExps = ImmutablePairList.of();\n      }\n      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n      case COMPUTE:{\n        jj_consume_token(COMPUTE);\n        aggregates = aggregateCommaList();\n        break;\n        }\n      default:\n        jj_la1[15] = jj_gen;\naggregates = ImmutableList.of();\n      }\nsteps.add(ast.group(span.end(this), groupExps, aggregates));\n      break;\n      }\n    case COMPUTE:{\n      jj_consume_token(COMPUTE);\nspan = Span.of(pos());\n      aggregates = aggregateCommaList();\nsteps.add(ast.compute(span.end(this), aggregates));\n      break;\n      }\n    case INTO:{\n      jj_consume_token(INTO);\nspan = Span.of(pos());\n      intoExp = expression();\nsteps.add(ast.into(span.end(this), intoExp));\n      break;\n      }\n    case ORDER:{\n      jj_consume_token(ORDER);\nspan = Span.of(pos());\n      orderItems = orderItemCommaList();\nsteps.add(ast.order(span.end(this), orderItems));\n      break;\n      }\n    case SKIP_:{\n      jj_consume_token(SKIP_);\nspan = Span.of(pos());\n      skipExp = expression();\nsteps.add(ast.skip(span.end(this), skipExp));\n      break;\n      }\n    case TAKE:{\n      jj_consume_token(TAKE);\nspan = Span.of(pos());\n      takeExp = expression();\nsteps.add(ast.take(span.end(this), takeExp));\n      break;\n      }\n    case THROUGH:{\n      jj_consume_token(THROUGH);\nspan = Span.of(pos());\n      pat = pat();\n      jj_consume_token(IN);\n      throughExp = expression();\nsteps.add(ast.through(span.end(this), pat, throughExp));\n      break;\n      }\n    case YIELD:{\n      jj_consume_token(YIELD);\nspan = Span.of(pos());\n      yieldExp = expression();\nsteps.add(ast.yield(span.end(this), yieldExp));\n      break;\n      }\n    default:\n      jj_la1[16] = jj_gen;\n      jj_consume_token(-1);\n      throw new ParseException();\n    }\n}\n\n  final public Pair<Pat, Exp> fromSource() throws ParseException {final Id id;\n  final Exp exp;\n  final Pat pat;\n    if (jj_2_2(2147483647)) {\n      id = identifier();\n{if (\"\" != null) return Pair.of(ast.idPat(id.pos, id.name), null);}\n    } else {\n      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n      case 1:\n      case NON_NEGATIVE_INTEGER_LITERAL:\n      case NEGATIVE_INTEGER_LITERAL:\n      case REAL_LITERAL:\n      case SCIENTIFIC_LITERAL:\n      case QUOTED_STRING:\n      case CHAR_LITERAL:\n      case LPAREN:\n      case LBRACE:\n      case LBRACKET:\n      case IDENTIFIER:\n      case QUOTED_IDENTIFIER:{\n        pat = pat();\n        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n        case IN:{\n          jj_consume_token(IN);\n          exp = expression();\n{if (\"\" != null) return Pair.of(pat, exp);}\n          break;\n          }\n        case EQ:{\n          jj_consume_token(EQ);\n          exp = expression();\n{if (\"\" != null) return Pair.of(pat, ast.fromEq(exp));}\n          break;\n          }\n        default:\n          jj_la1[17] = jj_gen;\n          jj_consume_token(-1);\n          throw new ParseException();\n        }\n        break;\n        }\n      default:\n        jj_la1[18] = jj_gen;\n        jj_consume_token(-1);\n        throw new ParseException();\n      }\n    }\n    throw new Error(\"Missing return statement in function\");\n}\n\n  final public List<Aggregate> aggregateCommaList() throws ParseException {final List<Aggregate> list = new ArrayList<>();\n  Aggregate e;\n    e = aggregate();\nlist.add(e);\n    label_7:\n    while (true) {\n      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n      case COMMA:{\n        ;\n        break;\n        }\n      default:\n        jj_la1[19] = jj_gen;\n        break label_7;\n      }\n      jj_consume_token(COMMA);\n      e = aggregate();\nlist.add(e);\n    }\n{if (\"\" != null) return list;}\n    throw new Error(\"Missing return statement in function\");\n}\n\n  final public Aggregate aggregate() throws ParseException {final PairList<Id, Exp> aggregateIds = PairList.of();\n  final Exp argument;\n    namedExpression(aggregateIds);\n    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n    case OF:{\n      jj_consume_token(OF);\n      argument = expression();\n      break;\n      }\n    default:\n      jj_la1[20] = jj_gen;\nargument = null;\n    }\nfinal Id id = aggregateIds.get(0).getKey();\n    final Exp aggregate = aggregateIds.get(0).getValue();\n    {if (\"\" != null) return ast.aggregate(id.pos.plus(pos()), aggregate, argument, id);}\n    throw new Error(\"Missing return statement in function\");\n}\n\n/** List of order items \"e1 desc, e2, e3 desc\". */\n  final public List<OrderItem> orderItemCommaList() throws ParseException {final List<OrderItem> list = new ArrayList<>();\n  OrderItem i;\n    i = orderItem();\nlist.add(i);\n    label_8:\n    while (true) {\n      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n      case COMMA:{\n        ;\n        break;\n        }\n      default:\n        jj_la1[21] = jj_gen;\n        break label_8;\n      }\n      jj_consume_token(COMMA);\n      i = orderItem();\nlist.add(i);\n    }\n{if (\"\" != null) return list;}\n    throw new Error(\"Missing return statement in function\");\n}\n\n/** Order item. An expression optionally followed by \"desc\". */\n  final public OrderItem orderItem() throws ParseException {final Span span;\n  final Exp exp;\n    exp = expression();\nspan = Span.of(pos());\n    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n    case DESC:{\n      jj_consume_token(DESC);\n{if (\"\" != null) return ast.orderItem(span.end(this), exp, Ast.Direction.DESC);}\n      break;\n      }\n    default:\n      jj_la1[22] = jj_gen;\n{if (\"\" != null) return ast.orderItem(span.end(this), exp, Ast.Direction.ASC);}\n    }\n    throw new Error(\"Missing return statement in function\");\n}\n\n/** Parses a \"{@code fn arg => expression}\" lambda expression. */\n  final public Exp fn() throws ParseException {final Span span;\n  final Match match;\n    jj_consume_token(FN);\nspan = Span.of(pos());\n    match = match();\n{if (\"\" != null) return ast.fn(span.end(this), match);}\n    throw new Error(\"Missing return statement in function\");\n}\n\n  final public List<Match> matchList() throws ParseException {Match match;\n  final List<Match> matchList = new ArrayList<>();\n    match = match();\nmatchList.add(match);\n    label_9:\n    while (true) {\n      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n      case BAR:{\n        ;\n        break;\n        }\n      default:\n        jj_la1[23] = jj_gen;\n        break label_9;\n      }\n      jj_consume_token(BAR);\n      match = match();\nmatchList.add(match);\n    }\n{if (\"\" != null) return matchList;}\n    throw new Error(\"Missing return statement in function\");\n}\n\n/** Parses a \"{@code pat => expression}\" match. */\n  final public Match match() throws ParseException {final Pat pat;\n  final Exp e;\n    pat = pat();\n    jj_consume_token(RARROW);\n    e = expression();\n{if (\"\" != null) return ast.match(pat.pos.plus(e.pos), pat, e);}\n    throw new Error(\"Missing return statement in function\");\n}\n\n/** Parses an expression.\n *\n * <p>8 is the highest level of precedence in standard ML,\n and the '.field' extension is at level 9.\n The full list is as follows:\n *\n * <ul>\n * <li>infix 9 {@code .}\n * <li>infix 8 (application)\n * <li>infix 7 {@code * / div mod intersect}\n * <li>infix 6 {@code + - ^ union except}\n * <li>infixr 5 {@code :: @}\n * <li>infix 4 {@code = <> > >= < <=}\n * <li>infix 3 {@code := o}\n * <li>infix 0 {@code before}\n * </ul>\n */\n  final public Exp expression9() throws ParseException {Exp e;\n  Id id;\n    e = atom();\n    label_10:\n    while (true) {\n      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n      case DOT:{\n        ;\n        break;\n        }\n      default:\n        jj_la1[24] = jj_gen;\n        break label_10;\n      }\n      jj_consume_token(DOT);\n      id = identifier();\nfinal Exp s = ast.recordSelector(pos(), id.name);\n      e = ast.apply(s, e);\n    }\n{if (\"\" != null) return e;}\n    throw new Error(\"Missing return statement in function\");\n}\n\n/** Parses an expression of precedence level 8 (function application). */\n  final public Exp expression8() throws ParseException {Exp e;\n  Exp e2;\n    e = expression9();\n    label_11:\n    while (true) {\n      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n      case CASE:\n      case FN:\n      case IF:\n      case LET:\n      case FROM:\n      case NON_NEGATIVE_INTEGER_LITERAL:\n      case NEGATIVE_INTEGER_LITERAL:\n      case REAL_LITERAL:\n      case SCIENTIFIC_LITERAL:\n      case QUOTED_STRING:\n      case CHAR_LITERAL:\n      case LPAREN:\n      case LBRACE:\n      case LBRACKET:\n      case IDENTIFIER:\n      case QUOTED_IDENTIFIER:\n      case LABEL:{\n        ;\n        break;\n        }\n      default:\n        jj_la1[25] = jj_gen;\n        break label_11;\n      }\n      e2 = expression9();\ne = ast.apply(e, e2);\n    }\n{if (\"\" != null) return e;}\n    throw new Error(\"Missing return statement in function\");\n}\n\n/** Parses an expression of precedence level 7 (*, /, div, mod). */\n  final public Exp expression7() throws ParseException {Exp e;\n  Exp e2;\n    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n    case TILDE:{\n      jj_consume_token(TILDE);\n      e = expression7();\n{if (\"\" != null) return ast.negate(pos(), e);}\n      break;\n      }\n    case CASE:\n    case FN:\n    case IF:\n    case LET:\n    case FROM:\n    case NON_NEGATIVE_INTEGER_LITERAL:\n    case NEGATIVE_INTEGER_LITERAL:\n    case REAL_LITERAL:\n    case SCIENTIFIC_LITERAL:\n    case QUOTED_STRING:\n    case CHAR_LITERAL:\n    case LPAREN:\n    case LBRACE:\n    case LBRACKET:\n    case IDENTIFIER:\n    case QUOTED_IDENTIFIER:\n    case LABEL:{\n      e = expression8();\n      label_12:\n      while (true) {\n        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n        case DIV:\n        case INTERSECT:\n        case MOD:\n        case STAR:\n        case SLASH:{\n          ;\n          break;\n          }\n        default:\n          jj_la1[26] = jj_gen;\n          break label_12;\n        }\n        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n        case STAR:{\n          jj_consume_token(STAR);\n          e2 = expression8();\ne = ast.times(e, e2);\n          break;\n          }\n        case SLASH:{\n          jj_consume_token(SLASH);\n          e2 = expression8();\ne = ast.divide(e, e2);\n          break;\n          }\n        case DIV:{\n          jj_consume_token(DIV);\n          e2 = expression8();\ne = ast.div(e, e2);\n          break;\n          }\n        case INTERSECT:{\n          jj_consume_token(INTERSECT);\n          e2 = expression8();\ne = ast.intersect(e, e2);\n          break;\n          }\n        case MOD:{\n          jj_consume_token(MOD);\n          e2 = expression8();\ne = ast.mod(e, e2);\n          break;\n          }\n        default:\n          jj_la1[27] = jj_gen;\n          jj_consume_token(-1);\n          throw new ParseException();\n        }\n      }\n{if (\"\" != null) return e;}\n      break;\n      }\n    default:\n      jj_la1[28] = jj_gen;\n      jj_consume_token(-1);\n      throw new ParseException();\n    }\n    throw new Error(\"Missing return statement in function\");\n}\n\n/** Parses an expression of precedence level 6 (+, -, ^, except, union). */\n  final public Exp expression6() throws ParseException {Exp e;\n  Exp e2;\n    e = expression7();\n    label_13:\n    while (true) {\n      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n      case EXCEPT:\n      case UNION:\n      case PLUS:\n      case MINUS:\n      case CARET:{\n        ;\n        break;\n        }\n      default:\n        jj_la1[29] = jj_gen;\n        break label_13;\n      }\n      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n      case PLUS:{\n        jj_consume_token(PLUS);\n        e2 = expression7();\ne = ast.plus(e, e2);\n        break;\n        }\n      case MINUS:{\n        jj_consume_token(MINUS);\n        e2 = expression7();\ne = ast.minus(e, e2);\n        break;\n        }\n      case CARET:{\n        jj_consume_token(CARET);\n        e2 = expression7();\ne = ast.caret(e, e2);\n        break;\n        }\n      case EXCEPT:{\n        jj_consume_token(EXCEPT);\n        e2 = expression7();\ne = ast.except(e, e2);\n        break;\n        }\n      case UNION:{\n        jj_consume_token(UNION);\n        e2 = expression7();\ne = ast.union(e, e2);\n        break;\n        }\n      default:\n        jj_la1[30] = jj_gen;\n        jj_consume_token(-1);\n        throw new ParseException();\n      }\n    }\n{if (\"\" != null) return e;}\n    throw new Error(\"Missing return statement in function\");\n}\n\n/** Parses an expression of precedence level 5 ({@code ::}),\n* right-associative. */\n  final public Exp expression5() throws ParseException {Exp e;\n  final List<Folder<Exp>> list = new ArrayList<>();\n    e = expression6();\nFolder.start(list, e);\n    label_14:\n    while (true) {\n      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n      case CONS:\n      case AT:{\n        ;\n        break;\n        }\n      default:\n        jj_la1[31] = jj_gen;\n        break label_14;\n      }\n      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n      case AT:{\n        jj_consume_token(AT);\n        e = expression6();\nFolder.at(list, e);\n        break;\n        }\n      case CONS:{\n        jj_consume_token(CONS);\n        e = expression6();\nFolder.cons(list, e);\n        break;\n        }\n      default:\n        jj_la1[32] = jj_gen;\n        jj_consume_token(-1);\n        throw new ParseException();\n      }\n    }\n{if (\"\" != null) return Folder.combineAll(list);}\n    throw new Error(\"Missing return statement in function\");\n}\n\n/** Parses an expression of precedence level 4 ({@code =}, {@code <>},\n  * {@code >}, {@code >=}, {@code <}, {@code <=}). */\n  final public Exp expression4() throws ParseException {Exp e;\n  Exp e2;\n    e = expression5();\n    label_15:\n    while (true) {\n      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n      case ELEM:\n      case NOT_ELEM:\n      case EQ:\n      case GT:\n      case LT:\n      case LE:\n      case GE:\n      case NE:{\n        ;\n        break;\n        }\n      default:\n        jj_la1[33] = jj_gen;\n        break label_15;\n      }\n      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n      case EQ:{\n        jj_consume_token(EQ);\n        e2 = expression5();\ne = ast.equal(e, e2);\n        break;\n        }\n      case NE:{\n        jj_consume_token(NE);\n        e2 = expression5();\ne = ast.notEqual(e, e2);\n        break;\n        }\n      case LT:{\n        jj_consume_token(LT);\n        e2 = expression5();\ne = ast.lessThan(e, e2);\n        break;\n        }\n      case GT:{\n        jj_consume_token(GT);\n        e2 = expression5();\ne = ast.greaterThan(e, e2);\n        break;\n        }\n      case LE:{\n        jj_consume_token(LE);\n        e2 = expression5();\ne = ast.lessThanOrEqual(e, e2);\n        break;\n        }\n      case GE:{\n        jj_consume_token(GE);\n        e2 = expression5();\ne = ast.greaterThanOrEqual(e, e2);\n        break;\n        }\n      case ELEM:{\n        jj_consume_token(ELEM);\n        e2 = expression5();\ne = ast.elem(e, e2);\n        break;\n        }\n      case NOT_ELEM:{\n        jj_consume_token(NOT_ELEM);\n        e2 = expression5();\ne = ast.notElem(e, e2);\n        break;\n        }\n      default:\n        jj_la1[34] = jj_gen;\n        jj_consume_token(-1);\n        throw new ParseException();\n      }\n    }\n{if (\"\" != null) return e;}\n    throw new Error(\"Missing return statement in function\");\n}\n\n/** Parses an expression of precedence level 3 (o). */\n  final public Exp expression3() throws ParseException {Exp e;\n  Exp e2;\n    e = expression4();\n    label_16:\n    while (true) {\n      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n      case O:{\n        ;\n        break;\n        }\n      default:\n        jj_la1[35] = jj_gen;\n        break label_16;\n      }\n      jj_consume_token(O);\n      e2 = expression4();\ne = ast.o(e, e2);\n    }\n{if (\"\" != null) return e;}\n    throw new Error(\"Missing return statement in function\");\n}\n\n/** Parses an expression of precedence level 2 (andalso). */\n  final public Exp expression2() throws ParseException {Exp e;\n  Exp e2;\n    e = expression3();\n    label_17:\n    while (true) {\n      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n      case ANDALSO:{\n        ;\n        break;\n        }\n      default:\n        jj_la1[36] = jj_gen;\n        break label_17;\n      }\n      jj_consume_token(ANDALSO);\n      e2 = expression3();\ne = ast.andAlso(e, e2);\n    }\n{if (\"\" != null) return e;}\n    throw new Error(\"Missing return statement in function\");\n}\n\n/** Parses an expression of precedence level 1 (orelse). */\n  final public Exp expression1() throws ParseException {Exp e;\n  Exp e2;\n    e = expression2();\n    label_18:\n    while (true) {\n      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n      case ORELSE:{\n        ;\n        break;\n        }\n      default:\n        jj_la1[37] = jj_gen;\n        break label_18;\n      }\n      jj_consume_token(ORELSE);\n      e2 = expression2();\ne = ast.orElse(e, e2);\n    }\n{if (\"\" != null) return e;}\n    throw new Error(\"Missing return statement in function\");\n}\n\n  final public Exp expression() throws ParseException {Exp e;\n  Type t;\n    e = expression1();\n    label_19:\n    while (true) {\n      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n      case COLON:{\n        ;\n        break;\n        }\n      default:\n        jj_la1[38] = jj_gen;\n        break label_19;\n      }\n      jj_consume_token(COLON);\n      t = type();\ne = ast.annotatedExp(e.pos.plus(t.pos), e, t);\n    }\n{if (\"\" != null) return e;}\n    throw new Error(\"Missing return statement in function\");\n}\n\n/** List of expressions \"e1 as id1, e2 as id2, e3 as id3\". */\n  final public PairList<Id, Exp> namedExpressionCommaList() throws ParseException {final PairList<Id, Exp> list = PairList.of();\n  Pair<Id, Exp> p;\n    namedExpression(list);\n    label_20:\n    while (true) {\n      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n      case COMMA:{\n        ;\n        break;\n        }\n      default:\n        jj_la1[39] = jj_gen;\n        break label_20;\n      }\n      jj_consume_token(COMMA);\n      namedExpression(list);\n    }\n{if (\"\" != null) return list;}\n    throw new Error(\"Missing return statement in function\");\n}\n\n/** Expression with optional \"id =\", e.g. \"id1 = e1\";\n * \"#deptno e\" and \"e.deptno\" are equivalent to \"deptno = e.deptno\";\n * \"x\" is equivalent to \"x = x\". */\n  final public void namedExpression(PairList<Id, Exp> list) throws ParseException {final Exp exp;\n  final Id id;\n    if (jj_2_3(2147483647)) {\n      id = identifier();\n      jj_consume_token(EQ);\n      exp = expression();\nlist.add(id, exp);\n    } else {\n      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n      case CASE:\n      case FN:\n      case IF:\n      case LET:\n      case FROM:\n      case NON_NEGATIVE_INTEGER_LITERAL:\n      case NEGATIVE_INTEGER_LITERAL:\n      case REAL_LITERAL:\n      case SCIENTIFIC_LITERAL:\n      case QUOTED_STRING:\n      case CHAR_LITERAL:\n      case LPAREN:\n      case LBRACE:\n      case LBRACKET:\n      case TILDE:\n      case IDENTIFIER:\n      case QUOTED_IDENTIFIER:\n      case LABEL:{\n        exp = expression();\nfinal String name = ast.implicitLabel(exp);\n    list.add(ast.id(exp.pos, name), exp);\n        break;\n        }\n      default:\n        jj_la1[40] = jj_gen;\n        jj_consume_token(-1);\n        throw new ParseException();\n      }\n    }\n}\n\n/** Parses an atomic expression. */\n  final public Exp atom() throws ParseException {final Exp e;\n  final Span span;\n    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n    case IDENTIFIER:\n    case QUOTED_IDENTIFIER:{\n      e = identifier();\n{if (\"\" != null) return e;}\n      break;\n      }\n    case LABEL:{\n      e = recordSelector();\n{if (\"\" != null) return e;}\n      break;\n      }\n    case NON_NEGATIVE_INTEGER_LITERAL:\n    case NEGATIVE_INTEGER_LITERAL:\n    case REAL_LITERAL:\n    case SCIENTIFIC_LITERAL:\n    case QUOTED_STRING:\n    case CHAR_LITERAL:{\n      e = literal();\n{if (\"\" != null) return e;}\n      break;\n      }\n    case LET:{\n      e = let();\n{if (\"\" != null) return e;}\n      break;\n      }\n    case FN:{\n      e = fn();\n{if (\"\" != null) return e;}\n      break;\n      }\n    case IF:{\n      e = ifThenElse();\n{if (\"\" != null) return e;}\n      break;\n      }\n    case CASE:{\n      e = caseOf();\n{if (\"\" != null) return e;}\n      break;\n      }\n    case FROM:{\n      e = from();\n{if (\"\" != null) return e;}\n      break;\n      }\n    case LPAREN:{\n      jj_consume_token(LPAREN);\nspan = Span.of(pos());\n      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n      case RPAREN:{\n        jj_consume_token(RPAREN);\n{if (\"\" != null) return ast.unitLiteral(span.end(this));}\n        break;\n        }\n      case CASE:\n      case FN:\n      case IF:\n      case LET:\n      case FROM:\n      case NON_NEGATIVE_INTEGER_LITERAL:\n      case NEGATIVE_INTEGER_LITERAL:\n      case REAL_LITERAL:\n      case SCIENTIFIC_LITERAL:\n      case QUOTED_STRING:\n      case CHAR_LITERAL:\n      case LPAREN:\n      case LBRACE:\n      case LBRACKET:\n      case TILDE:\n      case IDENTIFIER:\n      case QUOTED_IDENTIFIER:\n      case LABEL:{\n        e = expression();\n        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n        case RPAREN:{\n          jj_consume_token(RPAREN);\n{if (\"\" != null) return e;}\n          break;\n          }\n        case COMMA:{\nfinal List<Exp> list = new ArrayList<>();\n        list.add(e);\n        Exp e2;\n          label_21:\n          while (true) {\n            jj_consume_token(COMMA);\n            e2 = expression();\nlist.add(e2);\n            switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n            case COMMA:{\n              ;\n              break;\n              }\n            default:\n              jj_la1[41] = jj_gen;\n              break label_21;\n            }\n          }\n          jj_consume_token(RPAREN);\n{if (\"\" != null) return ast.tuple(span.end(this), list);}\n          break;\n          }\n        default:\n          jj_la1[42] = jj_gen;\n          jj_consume_token(-1);\n          throw new ParseException();\n        }\n        break;\n        }\n      default:\n        jj_la1[43] = jj_gen;\n        jj_consume_token(-1);\n        throw new ParseException();\n      }\n      break;\n      }\n    case LBRACKET:{\n      jj_consume_token(LBRACKET);\nspan = Span.of(pos());\n    final List<Exp> list = new ArrayList<>();\n    Exp e2;\n      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n      case CASE:\n      case FN:\n      case IF:\n      case LET:\n      case FROM:\n      case NON_NEGATIVE_INTEGER_LITERAL:\n      case NEGATIVE_INTEGER_LITERAL:\n      case REAL_LITERAL:\n      case SCIENTIFIC_LITERAL:\n      case QUOTED_STRING:\n      case CHAR_LITERAL:\n      case LPAREN:\n      case LBRACE:\n      case LBRACKET:\n      case TILDE:\n      case IDENTIFIER:\n      case QUOTED_IDENTIFIER:\n      case LABEL:{\n        e2 = expression();\nlist.add(e2);\n        label_22:\n        while (true) {\n          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n          case COMMA:{\n            ;\n            break;\n            }\n          default:\n            jj_la1[44] = jj_gen;\n            break label_22;\n          }\n          jj_consume_token(COMMA);\n          e2 = expression();\nlist.add(e2);\n        }\n        break;\n        }\n      default:\n        jj_la1[45] = jj_gen;\n        ;\n      }\n      jj_consume_token(RBRACKET);\n{if (\"\" != null) return ast.list(span.end(this), list);}\n      break;\n      }\n    case LBRACE:{\n      jj_consume_token(LBRACE);\nspan = Span.of(pos());\n    final PairList<String, Exp> nameExps = PairList.of();\n      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n      case CASE:\n      case FN:\n      case IF:\n      case LET:\n      case FROM:\n      case NON_NEGATIVE_INTEGER_LITERAL:\n      case NEGATIVE_INTEGER_LITERAL:\n      case REAL_LITERAL:\n      case SCIENTIFIC_LITERAL:\n      case QUOTED_STRING:\n      case CHAR_LITERAL:\n      case LPAREN:\n      case LBRACE:\n      case LBRACKET:\n      case TILDE:\n      case IDENTIFIER:\n      case QUOTED_IDENTIFIER:\n      case LABEL:{\n        recordExp(nameExps);\n        label_23:\n        while (true) {\n          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n          case COMMA:{\n            ;\n            break;\n            }\n          default:\n            jj_la1[46] = jj_gen;\n            break label_23;\n          }\n          jj_consume_token(COMMA);\n          recordExp(nameExps);\n        }\n        break;\n        }\n      default:\n        jj_la1[47] = jj_gen;\n        ;\n      }\n      jj_consume_token(RBRACE);\n{if (\"\" != null) return ast.record(span.end(this), nameExps);}\n      break;\n      }\n    default:\n      jj_la1[48] = jj_gen;\n      jj_consume_token(-1);\n      throw new ParseException();\n    }\n    throw new Error(\"Missing return statement in function\");\n}\n\n/** Parses a \"label = expression\" inside a record. */\n  final public void recordExp(PairList<String, Exp> nameExps) throws ParseException {final String id;\n  final Ast.Exp exp;\n    if (jj_2_4(2147483647)) {\n      jj_consume_token(NON_NEGATIVE_INTEGER_LITERAL);\nid = token.image;\n      jj_consume_token(EQ);\n      exp = expression();\nnameExps.add(id, exp);\n    } else if (jj_2_5(2147483647)) {\n      jj_consume_token(IDENTIFIER);\nid = token.image;\n      jj_consume_token(EQ);\n      exp = expression();\nnameExps.add(id, exp);\n    } else if (jj_2_6(2147483647)) {\n      jj_consume_token(QUOTED_IDENTIFIER);\nid = unquoteIdentifier(token.image);\n      jj_consume_token(EQ);\n      exp = expression();\nnameExps.add(id, exp);\n    } else {\n      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n      case CASE:\n      case FN:\n      case IF:\n      case LET:\n      case FROM:\n      case NON_NEGATIVE_INTEGER_LITERAL:\n      case NEGATIVE_INTEGER_LITERAL:\n      case REAL_LITERAL:\n      case SCIENTIFIC_LITERAL:\n      case QUOTED_STRING:\n      case CHAR_LITERAL:\n      case LPAREN:\n      case LBRACE:\n      case LBRACKET:\n      case TILDE:\n      case IDENTIFIER:\n      case QUOTED_IDENTIFIER:\n      case LABEL:{\n        exp = expression();\nfinal String label = ast.implicitLabel(exp);\n    nameExps.add(label, exp);\n        break;\n        }\n      default:\n        jj_la1[49] = jj_gen;\n        jj_consume_token(-1);\n        throw new ParseException();\n      }\n    }\n}\n\n/** Parses a value declaration, and adds it to a list. */\n  final public void addValDecl(List decls) throws ParseException {final ValDecl decl;\n    decl = valDecl();\ndecls.add(decl);\n}\n\n/** Parses a value declaration. */\n  final public ValDecl valDecl() throws ParseException {final Span span;\n  boolean rec = false;\n  final List<Ast.ValBind> valBinds = new ArrayList<>();\n    jj_consume_token(VAL);\nspan = Span.of(pos());\n    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n    case REC:{\n      jj_consume_token(REC);\nrec = true;\n      break;\n      }\n    default:\n      jj_la1[50] = jj_gen;\n      ;\n    }\n    valBind(valBinds);\n    label_24:\n    while (true) {\n      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n      case AND:{\n        ;\n        break;\n        }\n      default:\n        jj_la1[51] = jj_gen;\n        break label_24;\n      }\n      jj_consume_token(AND);\n      valBind(valBinds);\n    }\n{if (\"\" != null) return ast.valDecl(span.end(this), rec, valBinds);}\n    throw new Error(\"Missing return statement in function\");\n}\n\n  final public void valBind(List<Ast.ValBind> valBinds) throws ParseException {final Pat pat;\n  final Exp e;\n    pat = pat();\n    jj_consume_token(EQ);\n    e = expression();\nvalBinds.add(ast.valBind(pat.pos.plus(e.pos), pat, e));\n}\n\n/** Parses a declaration. */\n  final public Ast.Decl decl() throws ParseException {final Ast.Decl n;\n    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n    case DATATYPE:{\n      n = datatypeDecl();\n{if (\"\" != null) return n;}\n      break;\n      }\n    case VAL:{\n      n = valDecl();\n{if (\"\" != null) return n;}\n      break;\n      }\n    case FUN:{\n      n = funDecl();\n{if (\"\" != null) return n;}\n      break;\n      }\n    default:\n      jj_la1[52] = jj_gen;\n      jj_consume_token(-1);\n      throw new ParseException();\n    }\n    throw new Error(\"Missing return statement in function\");\n}\n\n/** Parses a declaration followed by end-of-file. */\n  final public Ast.Decl declEof() throws ParseException {Ast.Decl d;\n    d = decl();\n    jj_consume_token(0);\n{if (\"\" != null) return d;}\n    throw new Error(\"Missing return statement in function\");\n}\n\n/** Parses a type declaration, e.g.\n * {@code datatype 'a option = NONE | SOME of 'a}\n */\n  final public Ast.DatatypeDecl datatypeDecl() throws ParseException {final Span span;\n  final List<DatatypeBind> binds = new ArrayList<>();\n    jj_consume_token(DATATYPE);\nspan = Span.of(pos());\n    datatypeBind(binds);\n    label_25:\n    while (true) {\n      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n      case AND:{\n        ;\n        break;\n        }\n      default:\n        jj_la1[53] = jj_gen;\n        break label_25;\n      }\n      jj_consume_token(AND);\n      datatypeBind(binds);\n    }\n{if (\"\" != null) return ast.datatypeDecl(span.end(this), binds);}\n    throw new Error(\"Missing return statement in function\");\n}\n\n  final public void datatypeBind(List<Ast.DatatypeBind> datatypeBinds) throws ParseException {final List<TyVar> tyVars = new ArrayList<>();\n  TyVar tyVar;\n  final Ast.Id id;\n  final List<TyCon> tyCons = new ArrayList<>();\n  TyCon tyCon;\n    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n    case LPAREN:\n    case TY_VAR:{\n      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n      case TY_VAR:{\n        tyVar = tyVar();\ntyVars.add(tyVar);\n        break;\n        }\n      case LPAREN:{\n        jj_consume_token(LPAREN);\n        tyVar = tyVar();\ntyVars.add(tyVar);\n        label_26:\n        while (true) {\n          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n          case COMMA:{\n            ;\n            break;\n            }\n          default:\n            jj_la1[54] = jj_gen;\n            break label_26;\n          }\n          jj_consume_token(COMMA);\n          tyVar = tyVar();\ntyVars.add(tyVar);\n        }\n        jj_consume_token(RPAREN);\n        break;\n        }\n      default:\n        jj_la1[55] = jj_gen;\n        jj_consume_token(-1);\n        throw new ParseException();\n      }\n      break;\n      }\n    default:\n      jj_la1[56] = jj_gen;\n      ;\n    }\n    id = identifier();\n    jj_consume_token(EQ);\n    tyCon = typeConstructor();\ntyCons.add(tyCon);\n    label_27:\n    while (true) {\n      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n      case BAR:{\n        ;\n        break;\n        }\n      default:\n        jj_la1[57] = jj_gen;\n        break label_27;\n      }\n      jj_consume_token(BAR);\n      tyCon = typeConstructor();\ntyCons.add(tyCon);\n    }\nfinal List<AstNode> nodes = ImmutableList.<AstNode>builder().addAll(tyVars)\n        .add(id).addAll(tyCons).build();\n    datatypeBinds.add(ast.datatypeBind(Pos.sum(nodes), id, tyVars, tyCons));\n}\n\n  final public Ast.TyCon typeConstructor() throws ParseException {final Ast.Id tag;\n  final Ast.Type type;\n    tag = identifier();\n    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n    case OF:{\n      jj_consume_token(OF);\n      type = type();\n      break;\n      }\n    default:\n      jj_la1[58] = jj_gen;\ntype = null;\n    }\nfinal Pos pos = type == null ? tag.pos : tag.pos.plus(type.pos);\n    {if (\"\" != null) return ast.typeConstructor(pos, tag, type);}\n    throw new Error(\"Missing return statement in function\");\n}\n\n/** Parses a function declaration, e.g.\n* {@code fun f 1 y = y + 1 | f x y = 0 and g x = 0}. */\n  final public Ast.FunDecl funDecl() throws ParseException {final Span span;\n  final List<FunBind> funBindList = new ArrayList<>();\n    jj_consume_token(FUN);\nspan = Span.of(pos());\n    funBind(funBindList);\n    label_28:\n    while (true) {\n      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n      case AND:{\n        ;\n        break;\n        }\n      default:\n        jj_la1[59] = jj_gen;\n        break label_28;\n      }\n      jj_consume_token(AND);\n      funBind(funBindList);\n    }\n{if (\"\" != null) return ast.funDecl(span.end(this), funBindList);}\n    throw new Error(\"Missing return statement in function\");\n}\n\n/** Parses a function binding, e.g.\n* {@code f 1 y = y + 1 | f x y = 0},\n* and adds it to a list. */\n  final public void funBind(List<FunBind> list) throws ParseException {final List<FunMatch> matchList = new ArrayList<>();\n    funMatch(matchList);\n    label_29:\n    while (true) {\n      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n      case BAR:{\n        ;\n        break;\n        }\n      default:\n        jj_la1[60] = jj_gen;\n        break label_29;\n      }\n      jj_consume_token(BAR);\n      funMatch(matchList);\n    }\nlist.add(ast.funBind(Pos.sum(matchList), matchList));\n}\n\n/** Parses a function match, e.g.\n* {@code f 1 y = y + 1},\n* and adds it to a list. */\n  final public void funMatch(List<FunMatch> list) throws ParseException {final Ast.Id id;\n  Ast.Pat pat;\n  final List<Ast.Pat> patList = new ArrayList<>();\n  final Ast.Exp expression;\n  Ast.Type returnType = null;\n    id = identifier();\n    label_30:\n    while (true) {\n      pat = atomPat();\npatList.add(pat);\n      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n      case 1:\n      case NON_NEGATIVE_INTEGER_LITERAL:\n      case NEGATIVE_INTEGER_LITERAL:\n      case REAL_LITERAL:\n      case SCIENTIFIC_LITERAL:\n      case QUOTED_STRING:\n      case CHAR_LITERAL:\n      case LPAREN:\n      case LBRACE:\n      case LBRACKET:\n      case IDENTIFIER:\n      case QUOTED_IDENTIFIER:{\n        ;\n        break;\n        }\n      default:\n        jj_la1[61] = jj_gen;\n        break label_30;\n      }\n    }\n    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n    case COLON:{\n      jj_consume_token(COLON);\n      returnType = type();\n      break;\n      }\n    default:\n      jj_la1[62] = jj_gen;\n      ;\n    }\n    jj_consume_token(EQ);\n    expression = expression();\nlist.add(\n        ast.funMatch(id.pos.plus(expression.pos), id.name, patList, returnType,\n            expression));\n}\n\n/** Parses a pattern. */\n  final public Pat pat() throws ParseException {Pat pat;\n  Type type;\n    pat = pat5();\n    label_31:\n    while (true) {\n      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n      case COLON:{\n        ;\n        break;\n        }\n      default:\n        jj_la1[63] = jj_gen;\n        break label_31;\n      }\n      jj_consume_token(COLON);\n      type = type();\npat = ast.annotatedPat(pat.pos.plus(type.pos), pat, type);\n    }\n{if (\"\" != null) return pat;}\n    throw new Error(\"Missing return statement in function\");\n}\n\n/** Parses a pattern of precedence level 5 ({@code ::}),\n* right-associative. */\n  final public Pat pat5() throws ParseException {Pat pat;\n  final List<Pat> list = new ArrayList<>();\n    pat = pat4();\nlist.add(pat);\n    label_32:\n    while (true) {\n      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n      case CONS:{\n        ;\n        break;\n        }\n      default:\n        jj_la1[64] = jj_gen;\n        break label_32;\n      }\n      jj_consume_token(CONS);\n      pat = pat4();\nlist.add(pat);\n    }\npat = list.get(list.size() - 1);\n    for (int i = list.size() - 2; i >= 0; i--) {\n      pat = ast.consPat(list.get(i), pat);\n    }\n    {if (\"\" != null) return pat;}\n    throw new Error(\"Missing return statement in function\");\n}\n\n/** Parses a pattern that is a type constructor (an identifier) followed by a\n * pattern. For now, assume that it has precedence level 4. */\n  final public Pat pat4() throws ParseException {final Id id;\n  final Pat pat;\n    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n    case IDENTIFIER:\n    case QUOTED_IDENTIFIER:{\n      id = identifier();\n      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n      case AS:{\n        jj_consume_token(AS);\n        pat = pat();\n{if (\"\" != null) return ast.asPat(id.pos.plus(pat.pos),\n          (Ast.IdPat) ast.idPat(id.pos, id.name), pat);}\n        break;\n        }\n      case 1:\n      case NON_NEGATIVE_INTEGER_LITERAL:\n      case NEGATIVE_INTEGER_LITERAL:\n      case REAL_LITERAL:\n      case SCIENTIFIC_LITERAL:\n      case QUOTED_STRING:\n      case CHAR_LITERAL:\n      case LPAREN:\n      case LBRACE:\n      case LBRACKET:\n      case IDENTIFIER:\n      case QUOTED_IDENTIFIER:{\n        pat = pat();\n{if (\"\" != null) return ast.conPat(id.pos.plus(pat.pos), id, pat);}\n        break;\n        }\n      default:\n        jj_la1[65] = jj_gen;\n{if (\"\" != null) return ast.idPat(id.pos, id.name);}\n      }\n      break;\n      }\n    case 1:\n    case NON_NEGATIVE_INTEGER_LITERAL:\n    case NEGATIVE_INTEGER_LITERAL:\n    case REAL_LITERAL:\n    case SCIENTIFIC_LITERAL:\n    case QUOTED_STRING:\n    case CHAR_LITERAL:\n    case LPAREN:\n    case LBRACE:\n    case LBRACKET:{\n      pat = atomPat();\n{if (\"\" != null) return pat;}\n      break;\n      }\n    default:\n      jj_la1[66] = jj_gen;\n      jj_consume_token(-1);\n      throw new ParseException();\n    }\n    throw new Error(\"Missing return statement in function\");\n}\n\n/** Parses an atomic pattern. */\n  final public Pat atomPat() throws ParseException {final Span span;\n  final Ast.Id id;\n  final Ast.Literal literal;\n  Ast.Pat p;\n  final List<Pat> list = new ArrayList<>();\n    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n    case IDENTIFIER:\n    case QUOTED_IDENTIFIER:{\n      id = identifier();\n{if (\"\" != null) return ast.idPat(id.pos, id.name);}\n      break;\n      }\n    case NON_NEGATIVE_INTEGER_LITERAL:\n    case NEGATIVE_INTEGER_LITERAL:\n    case REAL_LITERAL:\n    case SCIENTIFIC_LITERAL:\n    case QUOTED_STRING:\n    case CHAR_LITERAL:{\n      literal = literal();\n{if (\"\" != null) return ast.literalPat(literal.pos, literal.op.toPat(), literal.value);}\n      break;\n      }\n    case 1:{\n      jj_consume_token(1);\n{if (\"\" != null) return ast.wildcardPat(pos());}\n      break;\n      }\n    case LPAREN:{\n      jj_consume_token(LPAREN);\nspan = Span.of(pos());\n      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n      case 1:\n      case NON_NEGATIVE_INTEGER_LITERAL:\n      case NEGATIVE_INTEGER_LITERAL:\n      case REAL_LITERAL:\n      case SCIENTIFIC_LITERAL:\n      case QUOTED_STRING:\n      case CHAR_LITERAL:\n      case LPAREN:\n      case LBRACE:\n      case LBRACKET:\n      case IDENTIFIER:\n      case QUOTED_IDENTIFIER:{\n        p = pat();\nlist.add(p);\n        label_33:\n        while (true) {\n          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n          case COMMA:{\n            ;\n            break;\n            }\n          default:\n            jj_la1[67] = jj_gen;\n            break label_33;\n          }\n          jj_consume_token(COMMA);\n          p = pat();\nlist.add(p);\n        }\n        break;\n        }\n      default:\n        jj_la1[68] = jj_gen;\n        ;\n      }\n      jj_consume_token(RPAREN);\nif (list.size() == 1) {\n      {if (\"\" != null) return list.get(0);}\n    } else {\n      {if (\"\" != null) return ast.tuplePat(span.end(this), list);}\n    }\n      break;\n      }\n    case LBRACKET:{\n      jj_consume_token(LBRACKET);\nspan = Span.of(pos());\n      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n      case 1:\n      case NON_NEGATIVE_INTEGER_LITERAL:\n      case NEGATIVE_INTEGER_LITERAL:\n      case REAL_LITERAL:\n      case SCIENTIFIC_LITERAL:\n      case QUOTED_STRING:\n      case CHAR_LITERAL:\n      case LPAREN:\n      case LBRACE:\n      case LBRACKET:\n      case IDENTIFIER:\n      case QUOTED_IDENTIFIER:{\n        p = pat();\nlist.add(p);\n        label_34:\n        while (true) {\n          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n          case COMMA:{\n            ;\n            break;\n            }\n          default:\n            jj_la1[69] = jj_gen;\n            break label_34;\n          }\n          jj_consume_token(COMMA);\n          p = pat();\nlist.add(p);\n        }\n        break;\n        }\n      default:\n        jj_la1[70] = jj_gen;\n        ;\n      }\n      jj_consume_token(RBRACKET);\n{if (\"\" != null) return ast.listPat(span.end(this), list);}\n      break;\n      }\n    case LBRACE:{\n      jj_consume_token(LBRACE);\nspan = Span.of(pos());\n    final Map<String, Pat> map = new LinkedHashMap<>();\n    boolean ellipsis = false;\n      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n      case NON_NEGATIVE_INTEGER_LITERAL:\n      case ELLIPSIS:\n      case IDENTIFIER:\n      case QUOTED_IDENTIFIER:{\n        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n        case ELLIPSIS:{\n          jj_consume_token(ELLIPSIS);\nellipsis = true;\n          break;\n          }\n        case NON_NEGATIVE_INTEGER_LITERAL:\n        case IDENTIFIER:\n        case QUOTED_IDENTIFIER:{\n          recordPat(map);\n          label_35:\n          while (true) {\n            if (jj_2_7(2)) {\n              ;\n            } else {\n              break label_35;\n            }\n            jj_consume_token(COMMA);\n            recordPat(map);\n          }\n          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n          case COMMA:{\n            jj_consume_token(COMMA);\n            jj_consume_token(ELLIPSIS);\nellipsis = true;\n            break;\n            }\n          default:\n            jj_la1[71] = jj_gen;\n            ;\n          }\n          break;\n          }\n        default:\n          jj_la1[72] = jj_gen;\n          jj_consume_token(-1);\n          throw new ParseException();\n        }\n        break;\n        }\n      default:\n        jj_la1[73] = jj_gen;\n        ;\n      }\n      jj_consume_token(RBRACE);\n{if (\"\" != null) return ast.recordPat(span.end(this), ellipsis, map);}\n      break;\n      }\n    default:\n      jj_la1[74] = jj_gen;\n      jj_consume_token(-1);\n      throw new ParseException();\n    }\n    throw new Error(\"Missing return statement in function\");\n}\n\n/** Parses a \"label = pat\" inside a record pattern. */\n  final public void recordPat(Map<String, Pat> map) throws ParseException {final String id;\n  final Ast.Pat pat;\n    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n    case NON_NEGATIVE_INTEGER_LITERAL:{\n      jj_consume_token(NON_NEGATIVE_INTEGER_LITERAL);\nid = token.image;\n      break;\n      }\n    case IDENTIFIER:{\n      jj_consume_token(IDENTIFIER);\nid = token.image;\n      break;\n      }\n    case QUOTED_IDENTIFIER:{\n      jj_consume_token(QUOTED_IDENTIFIER);\nid = unquoteIdentifier(token.image);\n      break;\n      }\n    default:\n      jj_la1[75] = jj_gen;\n      jj_consume_token(-1);\n      throw new ParseException();\n    }\n    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n    case EQ:{\n      jj_consume_token(EQ);\n      pat = pat();\nmap.put(id, pat);\n      break;\n      }\n    default:\n      jj_la1[76] = jj_gen;\nmap.put(id, ast.idPat(pos(), id));\n    }\n}\n\n/** Parses a type. */\n  final public Ast.Type atomicType() throws ParseException {final Span span;\n  final Type type;\n    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n    case TY_VAR:{\n      type = tyVar();\n{if (\"\" != null) return type;}\n      break;\n      }\n    case IDENTIFIER:{\n      type = namedType();\n{if (\"\" != null) return type;}\n      break;\n      }\n    case LBRACE:{\n      type = recordType();\n{if (\"\" != null) return type;}\n      break;\n      }\n    case LPAREN:{\n      jj_consume_token(LPAREN);\nspan = Span.of(pos());\n      type = type();\n      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n      case RPAREN:{\n        jj_consume_token(RPAREN);\n{if (\"\" != null) return type;}\n        break;\n        }\n      case COMMA:{\nfinal List<Type> list = new ArrayList<>();\n      list.add(type);\n      Type type2;\n        label_36:\n        while (true) {\n          jj_consume_token(COMMA);\n          type2 = type();\nlist.add(type2);\n          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n          case COMMA:{\n            ;\n            break;\n            }\n          default:\n            jj_la1[77] = jj_gen;\n            break label_36;\n          }\n        }\n        jj_consume_token(RPAREN);\n{if (\"\" != null) return ast.compositeType(span.end(this), list);}\n        break;\n        }\n      default:\n        jj_la1[78] = jj_gen;\n        jj_consume_token(-1);\n        throw new ParseException();\n      }\n      break;\n      }\n    default:\n      jj_la1[79] = jj_gen;\n      jj_consume_token(-1);\n      throw new ParseException();\n    }\n    throw new Error(\"Missing return statement in function\");\n}\n\n  final public Ast.Type type7() throws ParseException {Type t;\n    t = atomicType();\n    label_37:\n    while (true) {\n      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n      case IDENTIFIER:{\n        ;\n        break;\n        }\n      default:\n        jj_la1[80] = jj_gen;\n        break label_37;\n      }\n      jj_consume_token(IDENTIFIER);\nfinal List<Type> types =\n        t instanceof Ast.CompositeType\n          ? ((Ast.CompositeType) t).types\n          : ImmutableList.of(t);\n      t = ast.namedType(t.pos.plus(pos()), types, token.image);\n    }\n{if (\"\" != null) return t;}\n    throw new Error(\"Missing return statement in function\");\n}\n\n  final public Ast.Type type6() throws ParseException {final List<Type> types = new ArrayList<>();\n  Type t;\n    t = type7();\ntypes.add(t);\n    label_38:\n    while (true) {\n      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n      case STAR:{\n        ;\n        break;\n        }\n      default:\n        jj_la1[81] = jj_gen;\n        break label_38;\n      }\n      jj_consume_token(STAR);\n      t = type7();\ntypes.add(t);\n    }\n{if (\"\" != null) return types.size() == 1 ? t\n      : ast.tupleType(Pos.sum(types), types);}\n    throw new Error(\"Missing return statement in function\");\n}\n\n  final public Ast.Type type() throws ParseException {final List<Type> types = new ArrayList<>();\n  Type t;\n    t = type6();\ntypes.add(t);\n    label_39:\n    while (true) {\n      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n      case RTHINARROW:{\n        ;\n        break;\n        }\n      default:\n        jj_la1[82] = jj_gen;\n        break label_39;\n      }\n      jj_consume_token(RTHINARROW);\n      t = type6();\ntypes.add(t);\n    }\n{if (\"\" != null) return types.size() == 1 ? t\n        : ast.foldFunctionType(types);}\n    throw new Error(\"Missing return statement in function\");\n}\n\n  final public Ast.Type namedType() throws ParseException {\n    jj_consume_token(IDENTIFIER);\n{if (\"\" != null) return ast.namedType(pos(), ImmutableList.of(), token.image);}\n    throw new Error(\"Missing return statement in function\");\n}\n\n  final public AstNode statement() throws ParseException {final AstNode n;\n    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n    case CASE:\n    case FN:\n    case IF:\n    case LET:\n    case FROM:\n    case NON_NEGATIVE_INTEGER_LITERAL:\n    case NEGATIVE_INTEGER_LITERAL:\n    case REAL_LITERAL:\n    case SCIENTIFIC_LITERAL:\n    case QUOTED_STRING:\n    case CHAR_LITERAL:\n    case LPAREN:\n    case LBRACE:\n    case LBRACKET:\n    case TILDE:\n    case IDENTIFIER:\n    case QUOTED_IDENTIFIER:\n    case LABEL:{\n      n = expression();\n{if (\"\" != null) return n;}\n      break;\n      }\n    case DATATYPE:\n    case FUN:\n    case VAL:{\n      n = decl();\n{if (\"\" != null) return n;}\n      break;\n      }\n    default:\n      jj_la1[83] = jj_gen;\n      jj_consume_token(-1);\n      throw new ParseException();\n    }\n    throw new Error(\"Missing return statement in function\");\n}\n\n  final public AstNode statementSemicolon() throws ParseException {final AstNode n;\n    n = statement();\n    jj_consume_token(SEMICOLON);\n{if (\"\" != null) return n;}\n    throw new Error(\"Missing return statement in function\");\n}\n\n/** Parses a statement followed by semicolon or end-of-file.\n * Returns null if there is no statement. */\n  final public AstNode statementSemicolonOrEof() throws ParseException {final AstNode n;\n    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n    case 0:{\n      jj_consume_token(0);\n{if (\"\" != null) return null;}\n      break;\n      }\n    case CASE:\n    case DATATYPE:\n    case FN:\n    case FUN:\n    case IF:\n    case LET:\n    case VAL:\n    case FROM:\n    case NON_NEGATIVE_INTEGER_LITERAL:\n    case NEGATIVE_INTEGER_LITERAL:\n    case REAL_LITERAL:\n    case SCIENTIFIC_LITERAL:\n    case QUOTED_STRING:\n    case CHAR_LITERAL:\n    case LPAREN:\n    case LBRACE:\n    case LBRACKET:\n    case TILDE:\n    case IDENTIFIER:\n    case QUOTED_IDENTIFIER:\n    case LABEL:{\n      n = statement();\n      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n      case SEMICOLON:{\n        jj_consume_token(SEMICOLON);\n        break;\n        }\n      case 0:{\n        jj_consume_token(0);\n        break;\n        }\n      default:\n        jj_la1[84] = jj_gen;\n        jj_consume_token(-1);\n        throw new ParseException();\n      }\n{if (\"\" != null) return n;}\n      break;\n      }\n    default:\n      jj_la1[85] = jj_gen;\n      jj_consume_token(-1);\n      throw new ParseException();\n    }\n    throw new Error(\"Missing return statement in function\");\n}\n\n/** Parses a statement followed by end-of-file. */\n  final public AstNode statementEof() throws ParseException {final AstNode n;\n    n = statement();\n    jj_consume_token(0);\n{if (\"\" != null) return n;}\n    throw new Error(\"Missing return statement in function\");\n}\n\n  private boolean jj_2_1(int xla)\n {\n    jj_la = xla; jj_lastpos = jj_scanpos = token;\n    try { return (!jj_3_1()); }\n    catch(LookaheadSuccess ls) { return true; }\n    finally { jj_save(0, xla); }\n  }\n\n  private boolean jj_2_2(int xla)\n {\n    jj_la = xla; jj_lastpos = jj_scanpos = token;\n    try { return (!jj_3_2()); }\n    catch(LookaheadSuccess ls) { return true; }\n    finally { jj_save(1, xla); }\n  }\n\n  private boolean jj_2_3(int xla)\n {\n    jj_la = xla; jj_lastpos = jj_scanpos = token;\n    try { return (!jj_3_3()); }\n    catch(LookaheadSuccess ls) { return true; }\n    finally { jj_save(2, xla); }\n  }\n\n  private boolean jj_2_4(int xla)\n {\n    jj_la = xla; jj_lastpos = jj_scanpos = token;\n    try { return (!jj_3_4()); }\n    catch(LookaheadSuccess ls) { return true; }\n    finally { jj_save(3, xla); }\n  }\n\n  private boolean jj_2_5(int xla)\n {\n    jj_la = xla; jj_lastpos = jj_scanpos = token;\n    try { return (!jj_3_5()); }\n    catch(LookaheadSuccess ls) { return true; }\n    finally { jj_save(4, xla); }\n  }\n\n  private boolean jj_2_6(int xla)\n {\n    jj_la = xla; jj_lastpos = jj_scanpos = token;\n    try { return (!jj_3_6()); }\n    catch(LookaheadSuccess ls) { return true; }\n    finally { jj_save(5, xla); }\n  }\n\n  private boolean jj_2_7(int xla)\n {\n    jj_la = xla; jj_lastpos = jj_scanpos = token;\n    try { return (!jj_3_7()); }\n    catch(LookaheadSuccess ls) { return true; }\n    finally { jj_save(6, xla); }\n  }\n\n  private boolean jj_3_3()\n {\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_scan_token(89)) {\n    jj_scanpos = xsp;\n    if (jj_scan_token(90)) return true;\n    }\n    if (jj_scan_token(EQ)) return true;\n    return false;\n  }\n\n  private boolean jj_3_4()\n {\n    if (jj_scan_token(NON_NEGATIVE_INTEGER_LITERAL)) return true;\n    if (jj_scan_token(EQ)) return true;\n    return false;\n  }\n\n  private boolean jj_3R_charLiteral_183_3_83()\n {\n    if (jj_scan_token(CHAR_LITERAL)) return true;\n    return false;\n  }\n\n  private boolean jj_3_1()\n {\n    if (jj_scan_token(ON)) return true;\n    if (jj_3R_expression_807_3_40()) return true;\n    return false;\n  }\n\n  private boolean jj_3_2()\n {\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_scan_token(89)) {\n    jj_scanpos = xsp;\n    if (jj_scan_token(90)) return true;\n    }\n    xsp = jj_scanpos;\n    if (jj_scan_token(57)) {\n    jj_scanpos = xsp;\n    if (jj_scan_token(32)) {\n    jj_scanpos = xsp;\n    if (jj_scan_token(38)) {\n    jj_scanpos = xsp;\n    if (jj_scan_token(30)) {\n    jj_scanpos = xsp;\n    if (jj_scan_token(27)) {\n    jj_scanpos = xsp;\n    if (jj_scan_token(35)) {\n    jj_scanpos = xsp;\n    if (jj_scan_token(36)) {\n    jj_scanpos = xsp;\n    if (jj_scan_token(39)) {\n    jj_scanpos = xsp;\n    if (jj_scan_token(0)) return true;\n    }\n    }\n    }\n    }\n    }\n    }\n    }\n    }\n    return false;\n  }\n\n  private boolean jj_3R_stringLiteral_173_3_82()\n {\n    if (jj_scan_token(QUOTED_STRING)) return true;\n    return false;\n  }\n\n  private boolean jj_3R_fn_546_3_72()\n {\n    if (jj_scan_token(FN)) return true;\n    return false;\n  }\n\n  private boolean jj_3R_expression7_634_3_53()\n {\n    if (jj_3R_expression8_616_3_54()) return true;\n    return false;\n  }\n\n  private boolean jj_3R_expression7_632_3_51()\n {\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_3R_expression7_632_3_52()) {\n    jj_scanpos = xsp;\n    if (jj_3R_expression7_634_3_53()) return true;\n    }\n    return false;\n  }\n\n  private boolean jj_3R_expression7_632_3_52()\n {\n    if (jj_scan_token(TILDE)) return true;\n    return false;\n  }\n\n  private boolean jj_3R_atom_913_3_67()\n {\n    if (jj_scan_token(LBRACE)) return true;\n    return false;\n  }\n\n  private boolean jj_3R_expression4_716_3_48()\n {\n    if (jj_3R_expression5_699_3_49()) return true;\n    return false;\n  }\n\n  private boolean jj_3R_numericLiteral_145_3_86()\n {\n    if (jj_scan_token(SCIENTIFIC_LITERAL)) return true;\n    return false;\n  }\n\n  private boolean jj_3R_recordPat_1283_5_45()\n {\n    if (jj_scan_token(QUOTED_IDENTIFIER)) return true;\n    return false;\n  }\n\n  private boolean jj_3R_recordPat_1282_5_44()\n {\n    if (jj_scan_token(IDENTIFIER)) return true;\n    return false;\n  }\n\n  private boolean jj_3R_recordPat_1281_5_43()\n {\n    if (jj_scan_token(NON_NEGATIVE_INTEGER_LITERAL)) return true;\n    return false;\n  }\n\n  private boolean jj_3R_from_332_3_75()\n {\n    if (jj_scan_token(FROM)) return true;\n    return false;\n  }\n\n  private boolean jj_3R_expression_807_3_40()\n {\n    if (jj_3R_expression1_792_3_42()) return true;\n    return false;\n  }\n\n  private boolean jj_3R_expression8_616_3_54()\n {\n    if (jj_3R_expression9_599_3_55()) return true;\n    return false;\n  }\n\n  private boolean jj_3R_recordPat_1281_3_41()\n {\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_3R_recordPat_1281_5_43()) {\n    jj_scanpos = xsp;\n    if (jj_3R_recordPat_1282_5_44()) {\n    jj_scanpos = xsp;\n    if (jj_3R_recordPat_1283_5_45()) return true;\n    }\n    }\n    return false;\n  }\n\n  private boolean jj_3R_atom_898_3_66()\n {\n    if (jj_scan_token(LBRACKET)) return true;\n    return false;\n  }\n\n  private boolean jj_3R_numericLiteral_131_3_85()\n {\n    if (jj_scan_token(REAL_LITERAL)) return true;\n    return false;\n  }\n\n  private boolean jj_3R_expression5_699_3_49()\n {\n    if (jj_3R_expression6_666_3_50()) return true;\n    return false;\n  }\n\n  private boolean jj_3R_caseOf_318_3_74()\n {\n    if (jj_scan_token(CASE)) return true;\n    return false;\n  }\n\n  private boolean jj_3_7()\n {\n    if (jj_scan_token(COMMA)) return true;\n    if (jj_3R_recordPat_1281_3_41()) return true;\n    return false;\n  }\n\n  private boolean jj_3R_expression1_792_3_42()\n {\n    if (jj_3R_expression2_776_3_46()) return true;\n    return false;\n  }\n\n  private boolean jj_3R_expression9_599_3_55()\n {\n    if (jj_3R_atom_858_3_56()) return true;\n    return false;\n  }\n\n  private boolean jj_3R_numericLiteral_122_3_84()\n {\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_scan_token(40)) {\n    jj_scanpos = xsp;\n    if (jj_scan_token(41)) return true;\n    }\n    return false;\n  }\n\n  private boolean jj_3R_numericLiteral_122_3_81()\n {\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_3R_numericLiteral_122_3_84()) {\n    jj_scanpos = xsp;\n    if (jj_3R_numericLiteral_131_3_85()) {\n    jj_scanpos = xsp;\n    if (jj_3R_numericLiteral_145_3_86()) return true;\n    }\n    }\n    return false;\n  }\n\n  private boolean jj_3R_recordSelector_210_3_69()\n {\n    if (jj_scan_token(LABEL)) return true;\n    return false;\n  }\n\n  private boolean jj_3R_atom_874_3_65()\n {\n    if (jj_scan_token(LPAREN)) return true;\n    return false;\n  }\n\n  private boolean jj_3R_let_303_3_71()\n {\n    if (jj_scan_token(LET)) return true;\n    return false;\n  }\n\n  private boolean jj_3R_atom_872_3_64()\n {\n    if (jj_3R_from_332_3_75()) return true;\n    return false;\n  }\n\n  private boolean jj_3R_expression2_776_3_46()\n {\n    if (jj_3R_expression3_760_3_47()) return true;\n    return false;\n  }\n\n  private boolean jj_3R_atom_870_3_63()\n {\n    if (jj_3R_caseOf_318_3_74()) return true;\n    return false;\n  }\n\n  private boolean jj_3R_atom_868_3_62()\n {\n    if (jj_3R_ifThenElse_287_3_73()) return true;\n    return false;\n  }\n\n  private boolean jj_3R_atom_866_3_61()\n {\n    if (jj_3R_fn_546_3_72()) return true;\n    return false;\n  }\n\n  private boolean jj_3R_literal_104_3_80()\n {\n    if (jj_3R_charLiteral_183_3_83()) return true;\n    return false;\n  }\n\n  private boolean jj_3R_atom_864_3_60()\n {\n    if (jj_3R_let_303_3_71()) return true;\n    return false;\n  }\n\n  private boolean jj_3R_literal_102_3_79()\n {\n    if (jj_3R_stringLiteral_173_3_82()) return true;\n    return false;\n  }\n\n  private boolean jj_3R_atom_862_3_59()\n {\n    if (jj_3R_literal_100_3_70()) return true;\n    return false;\n  }\n\n  private boolean jj_3R_identifier_196_3_77()\n {\n    if (jj_scan_token(QUOTED_IDENTIFIER)) return true;\n    return false;\n  }\n\n  private boolean jj_3R_literal_100_3_78()\n {\n    if (jj_3R_numericLiteral_122_3_81()) return true;\n    return false;\n  }\n\n  private boolean jj_3R_literal_100_3_70()\n {\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_3R_literal_100_3_78()) {\n    jj_scanpos = xsp;\n    if (jj_3R_literal_102_3_79()) {\n    jj_scanpos = xsp;\n    if (jj_3R_literal_104_3_80()) return true;\n    }\n    }\n    return false;\n  }\n\n  private boolean jj_3R_atom_860_3_58()\n {\n    if (jj_3R_recordSelector_210_3_69()) return true;\n    return false;\n  }\n\n  private boolean jj_3R_identifier_193_3_76()\n {\n    if (jj_scan_token(IDENTIFIER)) return true;\n    return false;\n  }\n\n  private boolean jj_3R_identifier_193_3_68()\n {\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_3R_identifier_193_3_76()) {\n    jj_scanpos = xsp;\n    if (jj_3R_identifier_196_3_77()) return true;\n    }\n    return false;\n  }\n\n  private boolean jj_3R_atom_858_3_56()\n {\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_3R_atom_858_3_57()) {\n    jj_scanpos = xsp;\n    if (jj_3R_atom_860_3_58()) {\n    jj_scanpos = xsp;\n    if (jj_3R_atom_862_3_59()) {\n    jj_scanpos = xsp;\n    if (jj_3R_atom_864_3_60()) {\n    jj_scanpos = xsp;\n    if (jj_3R_atom_866_3_61()) {\n    jj_scanpos = xsp;\n    if (jj_3R_atom_868_3_62()) {\n    jj_scanpos = xsp;\n    if (jj_3R_atom_870_3_63()) {\n    jj_scanpos = xsp;\n    if (jj_3R_atom_872_3_64()) {\n    jj_scanpos = xsp;\n    if (jj_3R_atom_874_3_65()) {\n    jj_scanpos = xsp;\n    if (jj_3R_atom_898_3_66()) {\n    jj_scanpos = xsp;\n    if (jj_3R_atom_913_3_67()) return true;\n    }\n    }\n    }\n    }\n    }\n    }\n    }\n    }\n    }\n    }\n    return false;\n  }\n\n  private boolean jj_3R_atom_858_3_57()\n {\n    if (jj_3R_identifier_193_3_68()) return true;\n    return false;\n  }\n\n  private boolean jj_3_6()\n {\n    if (jj_scan_token(QUOTED_IDENTIFIER)) return true;\n    if (jj_scan_token(EQ)) return true;\n    return false;\n  }\n\n  private boolean jj_3R_ifThenElse_287_3_73()\n {\n    if (jj_scan_token(IF)) return true;\n    return false;\n  }\n\n  private boolean jj_3R_expression6_666_3_50()\n {\n    if (jj_3R_expression7_632_3_51()) return true;\n    return false;\n  }\n\n  private boolean jj_3R_expression3_760_3_47()\n {\n    if (jj_3R_expression4_716_3_48()) return true;\n    return false;\n  }\n\n  private boolean jj_3_5()\n {\n    if (jj_scan_token(IDENTIFIER)) return true;\n    if (jj_scan_token(EQ)) return true;\n    return false;\n  }\n\n  /** Generated Token Manager. */\n  public MorelParserImplTokenManager token_source;\n  SimpleCharStream jj_input_stream;\n  /** Current token. */\n  public Token token;\n  /** Next token. */\n  public Token jj_nt;\n  private int jj_ntk;\n  private Token jj_scanpos, jj_lastpos;\n  private int jj_la;\n  private int jj_gen;\n  final private int[] jj_la1 = new int[86];\n  static private int[] jj_la1_0;\n  static private int[] jj_la1_1;\n  static private int[] jj_la1_2;\n  static {\n\t   jj_la1_init_0();\n\t   jj_la1_init_1();\n\t   jj_la1_init_2();\n\t}\n\tprivate static void jj_la1_init_0() {\n\t   jj_la1_0 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4002040,0x0,0x2,0xc8000000,0x0,0x20025020,0x8000000,0xc8000000,0x8000,0x2,0x0,0x200000,0x0,0x10000000,0x0,0x0,0x20025020,0x50080,0x50080,0x20025020,0x2000400,0x2000400,0x0,0x0,0x80100,0x80100,0x100000,0x8,0x400000,0x0,0x0,0x20025020,0x0,0x0,0x20025020,0x0,0x20025020,0x0,0x20025020,0x20025020,0x20025020,0x800000,0x4,0x4002040,0x4,0x0,0x0,0x0,0x0,0x200000,0x4,0x0,0x2,0x0,0x0,0x0,0x12,0x2,0x0,0x2,0x0,0x2,0x0,0x0,0x0,0x2,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x24027060,0x1,0x24027061,};\n\t}\n\tprivate static void jj_la1_init_1() {\n\t   jj_la1_1 = new int[] {0xcf00,0x300,0xf00,0x0,0x2000000,0x10000,0x2000000,0x0,0x400000,0x0,0x2000000,0x15cf00,0xfd,0x2000000,0x15cf00,0x0,0xfd,0x10000000,0x15cf00,0x2000000,0x0,0x2000000,0x0,0x800000,0x1000000,0x15cf00,0x0,0x0,0x15cf00,0x0,0x0,0x0,0x0,0x70000000,0x70000000,0x0,0x0,0x0,0x80000000,0x2000000,0x15cf00,0x2000000,0x2020000,0x17cf00,0x2000000,0x15cf00,0x2000000,0x15cf00,0x15cf00,0x15cf00,0x0,0x0,0x0,0x0,0x2000000,0x10000,0x10000,0x800000,0x0,0x0,0x800000,0x15cf00,0x80000000,0x80000000,0x0,0x15cf00,0x15cf00,0x2000000,0x15cf00,0x2000000,0x15cf00,0x2000000,0x100,0x100,0x15cf00,0x100,0x10000000,0x2000000,0x2020000,0x50000,0x0,0x0,0x8000000,0x15cf00,0x400000,0x15cf00,};\n\t}\n\tprivate static void jj_la1_init_2() {\n\t   jj_la1_2 = new int[] {0x0,0x0,0x0,0x6000000,0x0,0x8000000,0x0,0x6000000,0x0,0x0,0x0,0x6000000,0x0,0x0,0x16000100,0x0,0x0,0x0,0x6000000,0x0,0x0,0x0,0x0,0x0,0x0,0x16000000,0xc0,0xc0,0x16000100,0x38,0x38,0x600,0x600,0x7,0x7,0x0,0x0,0x0,0x0,0x0,0x16000100,0x0,0x0,0x16000100,0x0,0x16000100,0x0,0x16000100,0x16000000,0x16000100,0x0,0x0,0x0,0x0,0x0,0x8000000,0x8000000,0x0,0x0,0x0,0x0,0x6000000,0x0,0x0,0x200,0x6000000,0x6000000,0x0,0x6000000,0x0,0x6000000,0x0,0x6000800,0x6000800,0x6000000,0x6000000,0x0,0x0,0x0,0xa000000,0x2000000,0x40,0x0,0x16000100,0x0,0x16000100,};\n\t}\n  final private JJCalls[] jj_2_rtns = new JJCalls[7];\n  private boolean jj_rescan = false;\n  private int jj_gc = 0;\n\n  /** Constructor with InputStream. */\n  public MorelParserImpl(java.io.InputStream stream) {\n\t  this(stream, null);\n  }\n  /** Constructor with InputStream and supplied encoding */\n  public MorelParserImpl(java.io.InputStream stream, String encoding) {\n\t try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }\n\t token_source = new MorelParserImplTokenManager(jj_input_stream);\n\t token = new Token();\n\t jj_ntk = -1;\n\t jj_gen = 0;\n\t for (int i = 0; i < 86; i++) jj_la1[i] = -1;\n\t for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();\n  }\n\n  /** Reinitialise. */\n  public void ReInit(java.io.InputStream stream) {\n\t  ReInit(stream, null);\n  }\n  /** Reinitialise. */\n  public void ReInit(java.io.InputStream stream, String encoding) {\n\t try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }\n\t token_source.ReInit(jj_input_stream);\n\t token = new Token();\n\t jj_ntk = -1;\n\t jj_gen = 0;\n\t for (int i = 0; i < 86; i++) jj_la1[i] = -1;\n\t for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();\n  }\n\n  /** Constructor. */\n  public MorelParserImpl(java.io.Reader stream) {\n\t jj_input_stream = new SimpleCharStream(stream, 1, 1);\n\t token_source = new MorelParserImplTokenManager(jj_input_stream);\n\t token = new Token();\n\t jj_ntk = -1;\n\t jj_gen = 0;\n\t for (int i = 0; i < 86; i++) jj_la1[i] = -1;\n\t for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();\n  }\n\n  /** Reinitialise. */\n  public void ReInit(java.io.Reader stream) {\n\tif (jj_input_stream == null) {\n\t   jj_input_stream = new SimpleCharStream(stream, 1, 1);\n\t} else {\n\t   jj_input_stream.ReInit(stream, 1, 1);\n\t}\n\tif (token_source == null) {\n token_source = new MorelParserImplTokenManager(jj_input_stream);\n\t}\n\n\t token_source.ReInit(jj_input_stream);\n\t token = new Token();\n\t jj_ntk = -1;\n\t jj_gen = 0;\n\t for (int i = 0; i < 86; i++) jj_la1[i] = -1;\n\t for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();\n  }\n\n  /** Constructor with generated Token Manager. */\n  public MorelParserImpl(MorelParserImplTokenManager tm) {\n\t token_source = tm;\n\t token = new Token();\n\t jj_ntk = -1;\n\t jj_gen = 0;\n\t for (int i = 0; i < 86; i++) jj_la1[i] = -1;\n\t for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();\n  }\n\n  /** Reinitialise. */\n  public void ReInit(MorelParserImplTokenManager tm) {\n\t token_source = tm;\n\t token = new Token();\n\t jj_ntk = -1;\n\t jj_gen = 0;\n\t for (int i = 0; i < 86; i++) jj_la1[i] = -1;\n\t for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();\n  }\n\n  private Token jj_consume_token(int kind) throws ParseException {\n\t Token oldToken;\n\t if ((oldToken = token).next != null) token = token.next;\n\t else token = token.next = token_source.getNextToken();\n\t jj_ntk = -1;\n\t if (token.kind == kind) {\n\t   jj_gen++;\n\t   if (++jj_gc > 100) {\n\t\t jj_gc = 0;\n\t\t for (int i = 0; i < jj_2_rtns.length; i++) {\n\t\t   JJCalls c = jj_2_rtns[i];\n\t\t   while (c != null) {\n\t\t\t if (c.gen < jj_gen) c.first = null;\n\t\t\t c = c.next;\n\t\t   }\n\t\t }\n\t   }\n\t   return token;\n\t }\n\t token = oldToken;\n\t jj_kind = kind;\n\t throw generateParseException();\n  }\n\n  @SuppressWarnings(\"serial\")\n  static private final class LookaheadSuccess extends java.lang.Error {\n    @Override\n    public Throwable fillInStackTrace() {\n      return this;\n    }\n  }\n  static private final LookaheadSuccess jj_ls = new LookaheadSuccess();\n  private boolean jj_scan_token(int kind) {\n\t if (jj_scanpos == jj_lastpos) {\n\t   jj_la--;\n\t   if (jj_scanpos.next == null) {\n\t\t jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();\n\t   } else {\n\t\t jj_lastpos = jj_scanpos = jj_scanpos.next;\n\t   }\n\t } else {\n\t   jj_scanpos = jj_scanpos.next;\n\t }\n\t if (jj_rescan) {\n\t   int i = 0; Token tok = token;\n\t   while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }\n\t   if (tok != null) jj_add_error_token(kind, i);\n\t }\n\t if (jj_scanpos.kind != kind) return true;\n\t if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;\n\t return false;\n  }\n\n\n/** Get the next Token. */\n  final public Token getNextToken() {\n\t if (token.next != null) token = token.next;\n\t else token = token.next = token_source.getNextToken();\n\t jj_ntk = -1;\n\t jj_gen++;\n\t return token;\n  }\n\n/** Get the specific Token. */\n  final public Token getToken(int index) {\n\t Token t = token;\n\t for (int i = 0; i < index; i++) {\n\t   if (t.next != null) t = t.next;\n\t   else t = t.next = token_source.getNextToken();\n\t }\n\t return t;\n  }\n\n  private int jj_ntk_f() {\n\t if ((jj_nt=token.next) == null)\n\t   return (jj_ntk = (token.next=token_source.getNextToken()).kind);\n\t else\n\t   return (jj_ntk = jj_nt.kind);\n  }\n\n  private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();\n  private int[] jj_expentry;\n  private int jj_kind = -1;\n  private int[] jj_lasttokens = new int[100];\n  private int jj_endpos;\n\n  private void jj_add_error_token(int kind, int pos) {\n\t if (pos >= 100) {\n\t\treturn;\n\t }\n\n\t if (pos == jj_endpos + 1) {\n\t   jj_lasttokens[jj_endpos++] = kind;\n\t } else if (jj_endpos != 0) {\n\t   jj_expentry = new int[jj_endpos];\n\n\t   for (int i = 0; i < jj_endpos; i++) {\n\t\t jj_expentry[i] = jj_lasttokens[i];\n\t   }\n\n\t   for (int[] oldentry : jj_expentries) {\n\t\t if (oldentry.length == jj_expentry.length) {\n\t\t   boolean isMatched = true;\n\n\t\t   for (int i = 0; i < jj_expentry.length; i++) {\n\t\t\t if (oldentry[i] != jj_expentry[i]) {\n\t\t\t   isMatched = false;\n\t\t\t   break;\n\t\t\t }\n\n\t\t   }\n\t\t   if (isMatched) {\n\t\t\t jj_expentries.add(jj_expentry);\n\t\t\t break;\n\t\t   }\n\t\t }\n\t   }\n\n\t   if (pos != 0) {\n\t\t jj_lasttokens[(jj_endpos = pos) - 1] = kind;\n\t   }\n\t }\n  }\n\n  /** Generate ParseException. */\n  public ParseException generateParseException() {\n\t jj_expentries.clear();\n\t boolean[] la1tokens = new boolean[95];\n\t if (jj_kind >= 0) {\n\t   la1tokens[jj_kind] = true;\n\t   jj_kind = -1;\n\t }\n\t for (int i = 0; i < 86; i++) {\n\t   if (jj_la1[i] == jj_gen) {\n\t\t for (int j = 0; j < 32; j++) {\n\t\t   if ((jj_la1_0[i] & (1<<j)) != 0) {\n\t\t\t la1tokens[j] = true;\n\t\t   }\n\t\t   if ((jj_la1_1[i] & (1<<j)) != 0) {\n\t\t\t la1tokens[32+j] = true;\n\t\t   }\n\t\t   if ((jj_la1_2[i] & (1<<j)) != 0) {\n\t\t\t la1tokens[64+j] = true;\n\t\t   }\n\t\t }\n\t   }\n\t }\n\t for (int i = 0; i < 95; i++) {\n\t   if (la1tokens[i]) {\n\t\t jj_expentry = new int[1];\n\t\t jj_expentry[0] = i;\n\t\t jj_expentries.add(jj_expentry);\n\t   }\n\t }\n\t jj_endpos = 0;\n\t jj_rescan_token();\n\t jj_add_error_token(0, 0);\n\t int[][] exptokseq = new int[jj_expentries.size()][];\n\t for (int i = 0; i < jj_expentries.size(); i++) {\n\t   exptokseq[i] = jj_expentries.get(i);\n\t }\n\t return new ParseException(token, exptokseq, tokenImage);\n  }\n\n  private boolean trace_enabled;\n\n/** Trace enabled. */\n  final public boolean trace_enabled() {\n\t return trace_enabled;\n  }\n\n  /** Enable tracing. */\n  final public void enable_tracing() {\n  }\n\n  /** Disable tracing. */\n  final public void disable_tracing() {\n  }\n\n  private void jj_rescan_token() {\n\t jj_rescan = true;\n\t for (int i = 0; i < 7; i++) {\n\t   try {\n\t\t JJCalls p = jj_2_rtns[i];\n\n\t\t do {\n\t\t   if (p.gen > jj_gen) {\n\t\t\t jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;\n\t\t\t switch (i) {\n\t\t\t   case 0: jj_3_1(); break;\n\t\t\t   case 1: jj_3_2(); break;\n\t\t\t   case 2: jj_3_3(); break;\n\t\t\t   case 3: jj_3_4(); break;\n\t\t\t   case 4: jj_3_5(); break;\n\t\t\t   case 5: jj_3_6(); break;\n\t\t\t   case 6: jj_3_7(); break;\n\t\t\t }\n\t\t   }\n\t\t   p = p.next;\n\t\t } while (p != null);\n\n\t\t } catch(LookaheadSuccess ls) { }\n\t }\n\t jj_rescan = false;\n  }\n\n  private void jj_save(int index, int xla) {\n\t JJCalls p = jj_2_rtns[index];\n\t while (p.gen > jj_gen) {\n\t   if (p.next == null) { p = p.next = new JJCalls(); break; }\n\t   p = p.next;\n\t }\n\n\t p.gen = jj_gen + xla - jj_la; \n\t p.first = token;\n\t p.arg = xla;\n  }\n\n  static final class JJCalls {\n\t int gen;\n\t Token first;\n\t int arg;\n\t JJCalls next;\n  }\n\n}", "super_interfaces": ["MorelParser", "MorelParserImplConstants"], "fields": [{"attribute_expression": "private static final Logger LOGGER =\n      LoggerFactory.getLogger(\"net.hydromatic.morel.parse\");", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Logger", "name": "LOGGER =\n      LoggerFactory.getLogger(\"net.hydromatic.morel.parse\")", "syntax_pass": true}, {"attribute_expression": "private int lineOffset;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "int", "name": "lineOffset", "syntax_pass": true}, {"attribute_expression": "private String file = \"\";", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "String", "name": "file = \"\"", "syntax_pass": true}, {"attribute_expression": "public MorelParserImplTokenManager token_source;", "docstring": " Generated Token Manager.", "modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "type": "MorelParserImplTokenManager", "name": "token_source", "syntax_pass": true}, {"attribute_expression": "SimpleCharStream jj_input_stream;", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "SimpleCharStream", "name": "jj_input_stream", "syntax_pass": true}, {"attribute_expression": "public Token token;", "docstring": " Current token.", "modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "type": "Token", "name": "token", "syntax_pass": true}, {"attribute_expression": "public Token jj_nt;", "docstring": " Next token.", "modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "type": "Token", "name": "jj_nt", "syntax_pass": true}, {"attribute_expression": "private int jj_ntk;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "int", "name": "jj_ntk", "syntax_pass": true}, {"attribute_expression": "private Token jj_scanpos, jj_lastpos;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Token", "name": "jj_scanpos", "syntax_pass": true}, {"attribute_expression": "private int jj_la;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "int", "name": "jj_la", "syntax_pass": true}, {"attribute_expression": "private int jj_gen;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "int", "name": "jj_gen", "syntax_pass": true}, {"attribute_expression": "final private int[] jj_la1 = new int[86];", "docstring": "", "modifiers": "final private", "marker_annotations": [], "non_marker_annotations": ["final", "private"], "comments": [], "type": "int[]", "name": "jj_la1 = new int[86]", "syntax_pass": true}, {"attribute_expression": "static private int[] jj_la1_0;", "docstring": "", "modifiers": "static private", "marker_annotations": [], "non_marker_annotations": ["static", "private"], "comments": [], "type": "int[]", "name": "jj_la1_0", "syntax_pass": true}, {"attribute_expression": "static private int[] jj_la1_1;", "docstring": "", "modifiers": "static private", "marker_annotations": [], "non_marker_annotations": ["static", "private"], "comments": [], "type": "int[]", "name": "jj_la1_1", "syntax_pass": true}, {"attribute_expression": "static private int[] jj_la1_2;", "docstring": "", "modifiers": "static private", "marker_annotations": [], "non_marker_annotations": ["static", "private"], "comments": [], "type": "int[]", "name": "jj_la1_2", "syntax_pass": true}, {"attribute_expression": "final private JJCalls[] jj_2_rtns = new JJCalls[7];", "docstring": "", "modifiers": "final private", "marker_annotations": [], "non_marker_annotations": ["final", "private"], "comments": [], "type": "JJCalls[]", "name": "jj_2_rtns = new JJCalls[7]", "syntax_pass": true}, {"attribute_expression": "private boolean jj_rescan = false;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "boolean", "name": "jj_rescan = false", "syntax_pass": true}, {"attribute_expression": "private int jj_gc = 0;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "int", "name": "jj_gc = 0", "syntax_pass": true}, {"attribute_expression": "static private final LookaheadSuccess jj_ls = new LookaheadSuccess();", "docstring": "", "modifiers": "static private final", "marker_annotations": [], "non_marker_annotations": ["static", "private", "final"], "comments": [], "type": "LookaheadSuccess", "name": "jj_ls = new LookaheadSuccess()", "syntax_pass": true}, {"attribute_expression": "private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "java.util.List<int[]>", "name": "jj_expentries = new java.util.ArrayList<int[]>()", "syntax_pass": true}, {"attribute_expression": "private int[] jj_expentry;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "int[]", "name": "jj_expentry", "syntax_pass": true}, {"attribute_expression": "private int jj_kind = -1;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "int", "name": "jj_kind = -1", "syntax_pass": true}, {"attribute_expression": "private int[] jj_lasttokens = new int[100];", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "int[]", "name": "jj_lasttokens = new int[100]", "syntax_pass": true}, {"attribute_expression": "private int jj_endpos;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "int", "name": "jj_endpos", "syntax_pass": true}, {"attribute_expression": "private boolean trace_enabled;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "boolean", "name": "trace_enabled", "syntax_pass": true}]}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/TokenMgrError.java.TokenMgrError", "name": "TokenMgrError", "file_path": "target/generated-sources/javacc/net/hydromatic/morel/parse/TokenMgrError.java", "superclasses": "Error", "methods": ["[String]addEscapes(String)", "[String]LexicalErr(boolean,int,int,int,String,int)", "[String]getMessage()", "[]TokenMgrError()", "[]TokenMgrError(String,int)", "[]TokenMgrError(boolean,int,int,int,String,int,int)"], "method_uris": ["target/generated-sources/javacc/net/hydromatic/morel/parse/TokenMgrError.java.TokenMgrError.[String]addEscapes(String)", "target/generated-sources/javacc/net/hydromatic/morel/parse/TokenMgrError.java.TokenMgrError.[String]LexicalErr(boolean,int,int,int,String,int)", "target/generated-sources/javacc/net/hydromatic/morel/parse/TokenMgrError.java.TokenMgrError.[String]getMessage()", "target/generated-sources/javacc/net/hydromatic/morel/parse/TokenMgrError.java.TokenMgrError.[]TokenMgrError()", "target/generated-sources/javacc/net/hydromatic/morel/parse/TokenMgrError.java.TokenMgrError.[]TokenMgrError(String,int)", "target/generated-sources/javacc/net/hydromatic/morel/parse/TokenMgrError.java.TokenMgrError.[]TokenMgrError(boolean,int,int,int,String,int,int)"], "overrides": null, "attributes": [], "class_docstring": " Token Manager Error.", "original_string": "@SuppressWarnings(\"all\") \npublic class TokenMgrError extends Error\n{\n\n  /**\n   * The version identifier for this Serializable class.\n   * Increment only if the <i>serialized</i> form of the\n   * class changes.\n   */\n  private static final long serialVersionUID = 1L;\n\n  /*\n   * Ordinals for various reasons why an Error of this type can be thrown.\n   */\n\n  /**\n   * Lexical error occurred.\n   */\n  public static final int LEXICAL_ERROR = 0;\n\n  /**\n   * An attempt was made to create a second instance of a static token manager.\n   */\n  public static final int STATIC_LEXER_ERROR = 1;\n\n  /**\n   * Tried to change to an invalid lexical state.\n   */\n  public static final int INVALID_LEXICAL_STATE = 2;\n\n  /**\n   * Detected (and bailed out of) an infinite loop in the token manager.\n   */\n  public static final int LOOP_DETECTED = 3;\n\n  /**\n   * Indicates the reason why the exception is thrown. It will have\n   * one of the above 4 values.\n   */\n  int errorCode;\n\n  /**\n   * Replaces unprintable characters by their escaped (or unicode escaped)\n   * equivalents in the given string\n   */\n  protected static final String addEscapes(String str) {\n    StringBuilder retval = new StringBuilder();\n    char ch;\n    for (int i = 0; i < str.length(); i++) {\n      switch (str.charAt(i))\n      {\n        case '\\b':\n          retval.append(\"\\\\b\");\n          continue;\n        case '\\t':\n          retval.append(\"\\\\t\");\n          continue;\n        case '\\n':\n          retval.append(\"\\\\n\");\n          continue;\n        case '\\f':\n          retval.append(\"\\\\f\");\n          continue;\n        case '\\r':\n          retval.append(\"\\\\r\");\n          continue;\n        case '\\\"':\n          retval.append(\"\\\\\\\"\");\n          continue;\n        case '\\'':\n          retval.append(\"\\\\\\'\");\n          continue;\n        case '\\\\':\n          retval.append(\"\\\\\\\\\");\n          continue;\n        default:\n          if ((ch = str.charAt(i)) < 0x20 || ch > 0x7e) {\n            String s = \"0000\" + Integer.toString(ch, 16);\n            retval.append(\"\\\\u\" + s.substring(s.length() - 4, s.length()));\n          } else {\n            retval.append(ch);\n          }\n          continue;\n      }\n    }\n    return retval.toString();\n  }\n\n  /**\n   * Returns a detailed message for the Error when it is thrown by the\n   * token manager to indicate a lexical error.\n   * Parameters :\n   *    EOFSeen     : indicates if EOF caused the lexical error\n   *    lexState    : lexical state in which this error occurred\n   *    errorLine   : line number when the error occurred\n   *    errorColumn : column number when the error occurred\n   *    errorAfter  : prefix that was seen before this error occurred\n   *    curchar     : the offending character\n   * Note: You can customize the lexical error message by modifying this method.\n   */\n  protected static String LexicalErr(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, int curChar) {\n    return(\"Lexical error at line \" + //\n          errorLine + \", column \" + //\n          errorColumn + \".  Encountered: \" + //\n          (EOFSeen ? \"<EOF>\" : (\"'\" + addEscapes(String.valueOf((char) curChar)) + \"' (\" + curChar + \"),\")) + //\n          (errorAfter == null || errorAfter.length() == 0 ? \"\" : \" after prefix \\\"\" + addEscapes(errorAfter) + \"\\\"\")) + //\n          (lexState == 0 ? \"\" : \" (in lexical state \" + lexState + \")\");\n  }\n\n  /**\n   * You can also modify the body of this method to customize your error messages.\n   * For example, cases like LOOP_DETECTED and INVALID_LEXICAL_STATE are not\n   * of end-users concern, so you can return something like :\n   *\n   *     \"Internal Error : Please file a bug report .... \"\n   *\n   * from this method for such cases in the release version of your parser.\n   */\n  @Override\n  public String getMessage() {\n    return super.getMessage();\n  }\n\n  /*\n   * Constructors of various flavors follow.\n   */\n\n  /** No arg constructor. */\n  public TokenMgrError() {\n  }\n\n  /** Constructor with message and reason. */\n  public TokenMgrError(String message, int reason) {\n    super(message);\n    errorCode = reason;\n  }\n\n  /** Full Constructor. */\n  public TokenMgrError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, int curChar, int reason) {\n    this(LexicalErr(EOFSeen, lexState, errorLine, errorColumn, errorAfter, curChar), reason);\n  }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final long serialVersionUID = 1L;", "docstring": "\nThe version identifier for this Serializable class.\nIncrement only if the <i>serialized</i> form of the\nclass changes.\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = 1L", "syntax_pass": true}, {"attribute_expression": "public static final int LEXICAL_ERROR = 0;", "docstring": "\nLexical error occurred.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "int", "name": "LEXICAL_ERROR = 0", "syntax_pass": true}, {"attribute_expression": "public static final int STATIC_LEXER_ERROR = 1;", "docstring": "\nAn attempt was made to create a second instance of a static token manager.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "int", "name": "STATIC_LEXER_ERROR = 1", "syntax_pass": true}, {"attribute_expression": "public static final int INVALID_LEXICAL_STATE = 2;", "docstring": "\nTried to change to an invalid lexical state.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "int", "name": "INVALID_LEXICAL_STATE = 2", "syntax_pass": true}, {"attribute_expression": "public static final int LOOP_DETECTED = 3;", "docstring": "\nDetected (and bailed out of) an infinite loop in the token manager.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "int", "name": "LOOP_DETECTED = 3", "syntax_pass": true}, {"attribute_expression": "int errorCode;", "docstring": "\nIndicates the reason why the exception is thrown. It will have\none of the above 4 values.\n", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "int", "name": "errorCode", "syntax_pass": true}]}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/ParseException.java.ParseException", "name": "ParseException", "file_path": "target/generated-sources/javacc/net/hydromatic/morel/parse/ParseException.java", "superclasses": "Exception", "methods": ["[]ParseException(Token,int[][],String[])", "[]ParseException()", "[]ParseException(String)", "[String]initialise(Token,int[][],String[])", "[String]add_escapes(String)"], "method_uris": ["target/generated-sources/javacc/net/hydromatic/morel/parse/ParseException.java.ParseException.[]ParseException(Token,int[][],String[])", "target/generated-sources/javacc/net/hydromatic/morel/parse/ParseException.java.ParseException.[]ParseException()", "target/generated-sources/javacc/net/hydromatic/morel/parse/ParseException.java.ParseException.[]ParseException(String)", "target/generated-sources/javacc/net/hydromatic/morel/parse/ParseException.java.ParseException.[String]initialise(Token,int[][],String[])", "target/generated-sources/javacc/net/hydromatic/morel/parse/ParseException.java.ParseException.[String]add_escapes(String)"], "overrides": null, "attributes": [], "class_docstring": "\nThis exception is thrown when parse errors are encountered.\nYou can explicitly create objects of this exception type by\ncalling the method generateParseException in the generated\nparser.\n\nYou can modify this class to customize your error reporting\nmechanisms so long as you retain the public fields.\n", "original_string": "public class ParseException extends Exception {\n\n  /**\n   * The version identifier for this Serializable class.\n   * Increment only if the <i>serialized</i> form of the\n   * class changes.\n   */\n  private static final long serialVersionUID = 1L;\n\n  /**\n   * The end of line string for this machine.\n   */\n  protected static String EOL = System.getProperty(\"line.separator\", \"\\n\");\n\n  /**\n   * This constructor is used by the method \"generateParseException\"\n   * in the generated parser.  Calling this constructor generates\n   * a new object of this type with the fields \"currentToken\",\n   * \"expectedTokenSequences\", and \"tokenImage\" set.\n   */\n  public ParseException(Token currentTokenVal,\n                        int[][] expectedTokenSequencesVal,\n                        String[] tokenImageVal\n                       )\n  {\n    super(initialise(currentTokenVal, expectedTokenSequencesVal, tokenImageVal));\n    currentToken = currentTokenVal;\n    expectedTokenSequences = expectedTokenSequencesVal;\n    tokenImage = tokenImageVal;\n  }\n\n  /**\n   * The following constructors are for use by you for whatever\n   * purpose you can think of.  Constructing the exception in this\n   * manner makes the exception behave in the normal way - i.e., as\n   * documented in the class \"Throwable\".  The fields \"errorToken\",\n   * \"expectedTokenSequences\", and \"tokenImage\" do not contain\n   * relevant information.  The JavaCC generated code does not use\n   * these constructors.\n   */\n\n  public ParseException() {\n    super();\n  }\n\n  /** Constructor with message. */\n  public ParseException(String message) {\n    super(message);\n  }\n\n\n  /**\n   * This is the last token that has been consumed successfully.  If\n   * this object has been created due to a parse error, the token\n   * following this token will (therefore) be the first error token.\n   */\n  public Token currentToken;\n\n  /**\n   * Each entry in this array is an array of integers.  Each array\n   * of integers represents a sequence of tokens (by their ordinal\n   * values) that is expected at this point of the parse.\n   */\n  public int[][] expectedTokenSequences;\n\n  /**\n   * This is a reference to the \"tokenImage\" array of the generated\n   * parser within which the parse error occurred.  This array is\n   * defined in the generated ...Constants interface.\n   */\n  public String[] tokenImage;\n\n  /**\n   * It uses \"currentToken\" and \"expectedTokenSequences\" to generate a parse\n   * error message and returns it.  If this object has been created\n   * due to a parse error, and you do not catch it (it gets thrown\n   * from the parser) the correct error message\n   * gets displayed.\n   */\n  private static String initialise(Token currentToken,\n                           int[][] expectedTokenSequences,\n                           String[] tokenImage) {\n\n    StringBuilder expected = new StringBuilder();\n    int maxSize = 0;\n    for (int i = 0; i < expectedTokenSequences.length; i++) {\n      if (maxSize < expectedTokenSequences[i].length) {\n        maxSize = expectedTokenSequences[i].length;\n      }\n      for (int j = 0; j < expectedTokenSequences[i].length; j++) {\n        expected.append(tokenImage[expectedTokenSequences[i][j]]).append(' ');\n      }\n      if (expectedTokenSequences[i][expectedTokenSequences[i].length - 1] != 0) {\n        expected.append(\"...\");\n      }\n      expected.append(EOL).append(\"    \");\n    }\n    String retval = \"Encountered \\\"\";\n    Token tok = currentToken.next;\n    for (int i = 0; i < maxSize; i++) {\n      if (i != 0) retval += \" \";\n      if (tok.kind == 0) {\n        retval += tokenImage[0];\n        break;\n      }\n      retval += \" \" + tokenImage[tok.kind];\n      retval += \" \\\"\";\n      retval += add_escapes(tok.image);\n      retval += \" \\\"\";\n      tok = tok.next;\n    }\n    if (currentToken.next != null) {\n      retval += \"\\\" at line \" + currentToken.next.beginLine + \", column \" + currentToken.next.beginColumn;\n    }\n    retval += \".\" + EOL;\n    \n    \n    if (expectedTokenSequences.length == 0) {\n        // Nothing to add here\n    } else {\n\t    if (expectedTokenSequences.length == 1) {\n\t      retval += \"Was expecting:\" + EOL + \"    \";\n\t    } else {\n\t      retval += \"Was expecting one of:\" + EOL + \"    \";\n\t    }\n\t    retval += expected.toString();\n    }\n    \n    return retval;\n  }\n\n\n  /**\n   * Used to convert raw characters to their escaped version\n   * when these raw version cannot be used as part of an ASCII\n   * string literal.\n   */\n  static String add_escapes(String str) {\n      StringBuilder retval = new StringBuilder();\n      char ch;\n      for (int i = 0; i < str.length(); i++) {\n        switch (str.charAt(i))\n        {\n           case '\\b':\n              retval.append(\"\\\\b\");\n              continue;\n           case '\\t':\n              retval.append(\"\\\\t\");\n              continue;\n           case '\\n':\n              retval.append(\"\\\\n\");\n              continue;\n           case '\\f':\n              retval.append(\"\\\\f\");\n              continue;\n           case '\\r':\n              retval.append(\"\\\\r\");\n              continue;\n           case '\\\"':\n              retval.append(\"\\\\\\\"\");\n              continue;\n           case '\\'':\n              retval.append(\"\\\\\\'\");\n              continue;\n           case '\\\\':\n              retval.append(\"\\\\\\\\\");\n              continue;\n           default:\n              if ((ch = str.charAt(i)) < 0x20 || ch > 0x7e) {\n                 String s = \"0000\" + Integer.toString(ch, 16);\n                 retval.append(\"\\\\u\" + s.substring(s.length() - 4, s.length()));\n              } else {\n                 retval.append(ch);\n              }\n              continue;\n        }\n      }\n      return retval.toString();\n   }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final long serialVersionUID = 1L;", "docstring": "\nThe version identifier for this Serializable class.\nIncrement only if the <i>serialized</i> form of the\nclass changes.\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = 1L", "syntax_pass": true}, {"attribute_expression": "protected static String EOL = System.getProperty(\"line.separator\", \"\\n\");", "docstring": "\nThe end of line string for this machine.\n", "modifiers": "protected static", "marker_annotations": [], "non_marker_annotations": ["protected", "static"], "comments": [], "type": "String", "name": "EOL = System.getProperty(\"line.separator\", \"\\n\")", "syntax_pass": true}, {"attribute_expression": "public Token currentToken;", "docstring": "\nThis is the last token that has been consumed successfully.  If\nthis object has been created due to a parse error, the token\nfollowing this token will (therefore) be the first error token.\n", "modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "type": "Token", "name": "currentToken", "syntax_pass": true}, {"attribute_expression": "public int[][] expectedTokenSequences;", "docstring": "\nEach entry in this array is an array of integers.  Each array\nof integers represents a sequence of tokens (by their ordinal\nvalues) that is expected at this point of the parse.\n", "modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "type": "int[][]", "name": "expectedTokenSequences", "syntax_pass": true}, {"attribute_expression": "public String[] tokenImage;", "docstring": "\nThis is a reference to the \"tokenImage\" array of the generated\nparser within which the parse error occurred.  This array is\ndefined in the generated ...Constants interface.\n", "modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "type": "String[]", "name": "tokenImage", "syntax_pass": true}]}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/Token.java.Token", "name": "Token", "file_path": "target/generated-sources/javacc/net/hydromatic/morel/parse/Token.java", "superclasses": "", "methods": ["[Object]getValue()", "[]Token()", "[]Token(int)", "[]Token(int,String)", "[String]toString()", "[Token]newToken(int,String)", "[Token]newToken(int)"], "method_uris": ["target/generated-sources/javacc/net/hydromatic/morel/parse/Token.java.Token.[Object]getValue()", "target/generated-sources/javacc/net/hydromatic/morel/parse/Token.java.Token.[]Token()", "target/generated-sources/javacc/net/hydromatic/morel/parse/Token.java.Token.[]Token(int)", "target/generated-sources/javacc/net/hydromatic/morel/parse/Token.java.Token.[]Token(int,String)", "target/generated-sources/javacc/net/hydromatic/morel/parse/Token.java.Token.[String]toString()", "target/generated-sources/javacc/net/hydromatic/morel/parse/Token.java.Token.[Token]newToken(int,String)", "target/generated-sources/javacc/net/hydromatic/morel/parse/Token.java.Token.[Token]newToken(int)"], "overrides": null, "attributes": [], "class_docstring": "\nDescribes the input token stream.\n", "original_string": "public class Token implements java.io.Serializable {\n\n  /**\n   * The version identifier for this Serializable class.\n   * Increment only if the <i>serialized</i> form of the\n   * class changes.\n   */\n  private static final long serialVersionUID = 1L;\n\n  /**\n   * An integer that describes the kind of this token.  This numbering\n   * system is determined by JavaCCParser, and a table of these numbers is\n   * stored in the file ...Constants.java.\n   */\n  public int kind;\n\n  /** The line number of the first character of this Token. */\n  public int beginLine;\n  /** The column number of the first character of this Token. */\n  public int beginColumn;\n  /** The line number of the last character of this Token. */\n  public int endLine;\n  /** The column number of the last character of this Token. */\n  public int endColumn;\n\n  /**\n   * The string image of the token.\n   */\n  public String image;\n\n  /**\n   * A reference to the next regular (non-special) token from the input\n   * stream.  If this is the last token from the input stream, or if the\n   * token manager has not read tokens beyond this one, this field is\n   * set to null.  This is true only if this token is also a regular\n   * token.  Otherwise, see below for a description of the contents of\n   * this field.\n   */\n  public Token next;\n\n  /**\n   * This field is used to access special tokens that occur prior to this\n   * token, but after the immediately preceding regular (non-special) token.\n   * If there are no such special tokens, this field is set to null.\n   * When there are more than one such special token, this field refers\n   * to the last of these special tokens, which in turn refers to the next\n   * previous special token through its specialToken field, and so on\n   * until the first special token (whose specialToken field is null).\n   * The next fields of special tokens refer to other special tokens that\n   * immediately follow it (without an intervening regular token).  If there\n   * is no such token, this field is null.\n   */\n  public Token specialToken;\n\n  /**\n   * An optional attribute value of the Token.\n   * Tokens which are not used as syntactic sugar will often contain\n   * meaningful values that will be used later on by the compiler or\n   * interpreter. This attribute value is often different from the image.\n   * Any subclass of Token that actually wants to return a non-null value can\n   * override this method as appropriate.\n   */\n  public Object getValue() {\n    return null;\n  }\n\n  /**\n   * No-argument constructor\n   */\n  public Token() {}\n\n  /**\n   * Constructs a new token for the specified Image.\n   */\n  public Token(int kind)\n  {\n    this(kind, null);\n  }\n\n  /**\n   * Constructs a new token for the specified Image and Kind.\n   */\n  public Token(int kind, String image)\n  {\n    this.kind = kind;\n    this.image = image;\n  }\n\n  /**\n   * Returns the image.\n   */\n  @Override\n  public String toString()\n  {\n    return image;\n  }\n\n  /**\n   * Returns a new Token object, by default. However, if you want, you\n   * can create and return subclass objects based on the value of ofKind.\n   * Simply add the cases to the switch for all those special cases.\n   * For example, if you have a subclass of Token called IDToken that\n   * you want to create if ofKind is ID, simply add something like :\n   *\n   *    case MyParserConstants.ID : return new IDToken(ofKind, image);\n   *\n   * to the following switch statement. Then you can cast matchedToken\n   * variable to the appropriate type and use sit in your lexical actions.\n   */\n  public static Token newToken(int ofKind, String image)\n  {\n    switch(ofKind)\n    {\n      default : return new Token(ofKind, image);\n    }\n  }\n\n  public static Token newToken(int ofKind)\n  {\n    return newToken(ofKind, null);\n  }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final long serialVersionUID = 1L;", "docstring": "\nThe version identifier for this Serializable class.\nIncrement only if the <i>serialized</i> form of the\nclass changes.\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = 1L", "syntax_pass": true}, {"attribute_expression": "public int kind;", "docstring": "\nAn integer that describes the kind of this token.  This numbering\nsystem is determined by JavaCCParser, and a table of these numbers is\nstored in the file ...Constants.java.\n", "modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "type": "int", "name": "kind", "syntax_pass": true}, {"attribute_expression": "public int beginLine;", "docstring": " The line number of the first character of this Token.", "modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "type": "int", "name": "beginLine", "syntax_pass": true}, {"attribute_expression": "public int beginColumn;", "docstring": " The column number of the first character of this Token.", "modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "type": "int", "name": "beginColumn", "syntax_pass": true}, {"attribute_expression": "public int endLine;", "docstring": " The line number of the last character of this Token.", "modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "type": "int", "name": "endLine", "syntax_pass": true}, {"attribute_expression": "public int endColumn;", "docstring": " The column number of the last character of this Token.", "modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "type": "int", "name": "endColumn", "syntax_pass": true}, {"attribute_expression": "public String image;", "docstring": "\nThe string image of the token.\n", "modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "type": "String", "name": "image", "syntax_pass": true}, {"attribute_expression": "public Token next;", "docstring": "\nA reference to the next regular (non-special) token from the input\nstream.  If this is the last token from the input stream, or if the\ntoken manager has not read tokens beyond this one, this field is\nset to null.  This is true only if this token is also a regular\ntoken.  Otherwise, see below for a description of the contents of\nthis field.\n", "modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "type": "Token", "name": "next", "syntax_pass": true}, {"attribute_expression": "public Token specialToken;", "docstring": "\nThis field is used to access special tokens that occur prior to this\ntoken, but after the immediately preceding regular (non-special) token.\nIf there are no such special tokens, this field is set to null.\nWhen there are more than one such special token, this field refers\nto the last of these special tokens, which in turn refers to the next\nprevious special token through its specialToken field, and so on\nuntil the first special token (whose specialToken field is null).\nThe next fields of special tokens refer to other special tokens that\nimmediately follow it (without an intervening regular token).  If there\nis no such token, this field is null.\n", "modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "type": "Token", "name": "specialToken", "syntax_pass": true}]}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImplTokenManager.java.MorelParserImplTokenManager", "name": "MorelParserImplTokenManager", "file_path": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImplTokenManager.java", "superclasses": "", "methods": ["[void]pushState()", "[void]popState()", "[void]setDebugStream(java.io.PrintStream)", "[int]jjStopStringLiteralDfa_0(int,long,long)", "[int]jjStartNfa_0(int,long,long)", "[int]jjStopAtPos(int,int)", "[int]jjMoveStringLiteralDfa0_0()", "[int]jjMoveStringLiteralDfa1_0(long,long)", "[int]jjMoveStringLiteralDfa2_0(long,long,long,long)", "[int]jjMoveStringLiteralDfa3_0(long,long,long,long)", "[int]jjMoveStringLiteralDfa4_0(long,long)", "[int]jjMoveStringLiteralDfa5_0(long,long)", "[int]jjMoveStringLiteralDfa6_0(long,long)", "[int]jjMoveStringLiteralDfa7_0(long,long)", "[int]jjMoveStringLiteralDfa8_0(long,long)", "[int]jjStartNfaWithStates_0(int,int,int)", "[int]jjMoveNfa_0(int,int)", "[int]jjMoveStringLiteralDfa0_1()", "[int]jjMoveNfa_1(int,int)", "[int]jjMoveStringLiteralDfa0_2()", "[int]jjMoveNfa_2(int,int)", "[Token]jjFillToken()", "[boolean]jjCanMove_0(int,int,int,long,long)", "[boolean]jjCanMove_1(int,int,int,long,long)", "[Token]getNextToken()", "[void]SkipLexicalActions(Token)", "[void]MoreLexicalActions()", "[void]TokenLexicalActions(Token)", "[void]jjCheckNAdd(int)", "[void]jjAddStates(int,int)", "[void]jjCheckNAddTwoStates(int,int)", "[void]jjCheckNAddStates(int,int)", "[]MorelParserImplTokenManager(SimpleCharStream)", "[]MorelParserImplTokenManager(SimpleCharStream,int)", "[void]ReInit(SimpleCharStream)", "[void]ReInitRounds()", "[void]ReInit(SimpleCharStream,int)", "[void]SwitchTo(int)"], "method_uris": ["target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImplTokenManager.java.MorelParserImplTokenManager.[void]pushState()", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImplTokenManager.java.MorelParserImplTokenManager.[void]popState()", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImplTokenManager.java.MorelParserImplTokenManager.[void]setDebugStream(java.io.PrintStream)", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImplTokenManager.java.MorelParserImplTokenManager.[int]jjStopStringLiteralDfa_0(int,long,long)", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImplTokenManager.java.MorelParserImplTokenManager.[int]jjStartNfa_0(int,long,long)", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImplTokenManager.java.MorelParserImplTokenManager.[int]jjStopAtPos(int,int)", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImplTokenManager.java.MorelParserImplTokenManager.[int]jjMoveStringLiteralDfa0_0()", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImplTokenManager.java.MorelParserImplTokenManager.[int]jjMoveStringLiteralDfa1_0(long,long)", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImplTokenManager.java.MorelParserImplTokenManager.[int]jjMoveStringLiteralDfa2_0(long,long,long,long)", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImplTokenManager.java.MorelParserImplTokenManager.[int]jjMoveStringLiteralDfa3_0(long,long,long,long)", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImplTokenManager.java.MorelParserImplTokenManager.[int]jjMoveStringLiteralDfa4_0(long,long)", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImplTokenManager.java.MorelParserImplTokenManager.[int]jjMoveStringLiteralDfa5_0(long,long)", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImplTokenManager.java.MorelParserImplTokenManager.[int]jjMoveStringLiteralDfa6_0(long,long)", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImplTokenManager.java.MorelParserImplTokenManager.[int]jjMoveStringLiteralDfa7_0(long,long)", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImplTokenManager.java.MorelParserImplTokenManager.[int]jjMoveStringLiteralDfa8_0(long,long)", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImplTokenManager.java.MorelParserImplTokenManager.[int]jjStartNfaWithStates_0(int,int,int)", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImplTokenManager.java.MorelParserImplTokenManager.[int]jjMoveNfa_0(int,int)", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImplTokenManager.java.MorelParserImplTokenManager.[int]jjMoveStringLiteralDfa0_1()", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImplTokenManager.java.MorelParserImplTokenManager.[int]jjMoveNfa_1(int,int)", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImplTokenManager.java.MorelParserImplTokenManager.[int]jjMoveStringLiteralDfa0_2()", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImplTokenManager.java.MorelParserImplTokenManager.[int]jjMoveNfa_2(int,int)", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImplTokenManager.java.MorelParserImplTokenManager.[Token]jjFillToken()", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImplTokenManager.java.MorelParserImplTokenManager.[boolean]jjCanMove_0(int,int,int,long,long)", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImplTokenManager.java.MorelParserImplTokenManager.[boolean]jjCanMove_1(int,int,int,long,long)", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImplTokenManager.java.MorelParserImplTokenManager.[Token]getNextToken()", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImplTokenManager.java.MorelParserImplTokenManager.[void]SkipLexicalActions(Token)", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImplTokenManager.java.MorelParserImplTokenManager.[void]MoreLexicalActions()", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImplTokenManager.java.MorelParserImplTokenManager.[void]TokenLexicalActions(Token)", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImplTokenManager.java.MorelParserImplTokenManager.[void]jjCheckNAdd(int)", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImplTokenManager.java.MorelParserImplTokenManager.[void]jjAddStates(int,int)", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImplTokenManager.java.MorelParserImplTokenManager.[void]jjCheckNAddTwoStates(int,int)", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImplTokenManager.java.MorelParserImplTokenManager.[void]jjCheckNAddStates(int,int)", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImplTokenManager.java.MorelParserImplTokenManager.[]MorelParserImplTokenManager(SimpleCharStream)", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImplTokenManager.java.MorelParserImplTokenManager.[]MorelParserImplTokenManager(SimpleCharStream,int)", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImplTokenManager.java.MorelParserImplTokenManager.[void]ReInit(SimpleCharStream)", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImplTokenManager.java.MorelParserImplTokenManager.[void]ReInitRounds()", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImplTokenManager.java.MorelParserImplTokenManager.[void]ReInit(SimpleCharStream,int)", "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImplTokenManager.java.MorelParserImplTokenManager.[void]SwitchTo(int)"], "overrides": null, "attributes": [], "class_docstring": " Token Manager.", "original_string": "@SuppressWarnings (\"unused\")\npublic class MorelParserImplTokenManager implements MorelParserImplConstants {\n    List<Integer> lexicalStateStack = new ArrayList<>();\n\n    void pushState() {\n      lexicalStateStack.add(curLexState);\n    }\n\n    void popState() {\n      SwitchTo(lexicalStateStack.remove(lexicalStateStack.size() - 1));\n    }\n\n  /** Debug output. */\n  public  java.io.PrintStream debugStream = System.out;\n  /** Set debug output. */\n  public  void setDebugStream(java.io.PrintStream ds) { debugStream = ds; }\nprivate final int jjStopStringLiteralDfa_0(int pos, long active0, long active1){\n   switch (pos)\n   {\n      case 0:\n         if ((active1 & 0x2000L) != 0L)\n            return 39;\n         if ((active0 & 0x600700000L) != 0L)\n            return 40;\n         if ((active0 & 0xf9ff8ffffcL) != 0L)\n         {\n            jjmatchedKind = 89;\n            return 40;\n         }\n         if ((active1 & 0x1000L) != 0L)\n            return 17;\n         if ((active1 & 0x100L) != 0L)\n            return 41;\n         return -1;\n      case 1:\n         if ((active0 & 0xfd7fce2fecL) != 0L)\n         {\n            if (jjmatchedPos != 1)\n            {\n               jjmatchedKind = 89;\n               jjmatchedPos = 1;\n            }\n            return 40;\n         }\n         if ((active0 & 0x28021d010L) != 0L)\n            return 40;\n         return -1;\n      case 2:\n         if ((active0 & 0x486288cL) != 0L)\n            return 40;\n         if ((active0 & 0xfdfb490760L) != 0L)\n         {\n            if (jjmatchedPos != 2)\n            {\n               jjmatchedKind = 89;\n               jjmatchedPos = 2;\n            }\n            return 40;\n         }\n         return -1;\n      case 3:\n         if ((active0 & 0xe44a490448L) != 0L)\n         {\n            jjmatchedKind = 89;\n            jjmatchedPos = 3;\n            return 40;\n         }\n         if ((active0 & 0x19b1000320L) != 0L)\n            return 40;\n         return -1;\n      case 4:\n         if ((active0 & 0xc442000000L) != 0L)\n            return 40;\n         if ((active0 & 0x2008490448L) != 0L)\n         {\n            jjmatchedKind = 89;\n            jjmatchedPos = 4;\n            return 40;\n         }\n         return -1;\n      case 5:\n         if ((active0 & 0x400400L) != 0L)\n            return 40;\n         if ((active0 & 0x2008090048L) != 0L)\n         {\n            jjmatchedKind = 89;\n            jjmatchedPos = 5;\n            return 40;\n         }\n         return -1;\n      case 6:\n         if ((active0 & 0x10040L) != 0L)\n         {\n            jjmatchedKind = 89;\n            jjmatchedPos = 6;\n            return 40;\n         }\n         if ((active0 & 0x2008080008L) != 0L)\n            return 40;\n         return -1;\n      case 7:\n         if ((active0 & 0x40L) != 0L)\n            return 40;\n         if ((active0 & 0x10000L) != 0L)\n         {\n            jjmatchedKind = 89;\n            jjmatchedPos = 7;\n            return 40;\n         }\n         return -1;\n      default :\n         return -1;\n   }\n}\nprivate final int jjStartNfa_0(int pos, long active0, long active1){\n   return jjMoveNfa_0(jjStopStringLiteralDfa_0(pos, active0, active1), pos + 1);\n}\nprivate int jjStopAtPos(int pos, int kind)\n{\n   jjmatchedKind = kind;\n   jjmatchedPos = pos;\n   return pos + 1;\n}\nprivate int jjMoveStringLiteralDfa0_0(){\n   switch(curChar)\n   {\n      case 34:\n         return jjStartNfaWithStates_0(0, 77, 39);\n      case 39:\n         return jjStartNfaWithStates_0(0, 76, 17);\n      case 40:\n         jjmatchedKind = 48;\n         return jjMoveStringLiteralDfa1_0(0x0L, 0x180000L);\n      case 41:\n         return jjStopAtPos(0, 49);\n      case 42:\n         return jjStopAtPos(0, 70);\n      case 43:\n         return jjStopAtPos(0, 67);\n      case 44:\n         return jjStopAtPos(0, 57);\n      case 45:\n         jjmatchedKind = 68;\n         return jjMoveStringLiteralDfa1_0(0x800000000000000L, 0x0L);\n      case 46:\n         jjmatchedKind = 56;\n         return jjMoveStringLiteralDfa1_0(0x0L, 0x800L);\n      case 47:\n         return jjStopAtPos(0, 71);\n      case 58:\n         jjmatchedKind = 63;\n         return jjMoveStringLiteralDfa1_0(0x0L, 0x200L);\n      case 59:\n         return jjStopAtPos(0, 54);\n      case 60:\n         jjmatchedKind = 62;\n         return jjMoveStringLiteralDfa1_0(0x0L, 0x5L);\n      case 61:\n         jjmatchedKind = 60;\n         return jjMoveStringLiteralDfa1_0(0x400000000000000L, 0x0L);\n      case 62:\n         jjmatchedKind = 61;\n         return jjMoveStringLiteralDfa1_0(0x0L, 0x2L);\n      case 64:\n         return jjStopAtPos(0, 74);\n      case 91:\n         return jjStopAtPos(0, 52);\n      case 93:\n         return jjStopAtPos(0, 53);\n      case 94:\n         return jjStopAtPos(0, 69);\n      case 95:\n         return jjStopAtPos(0, 1);\n      case 97:\n         return jjMoveStringLiteralDfa1_0(0x1cL, 0x0L);\n      case 99:\n         return jjMoveStringLiteralDfa1_0(0x8000020L, 0x0L);\n      case 100:\n         return jjMoveStringLiteralDfa1_0(0x100000c0L, 0x0L);\n      case 101:\n         return jjMoveStringLiteralDfa1_0(0xf00L, 0x0L);\n      case 102:\n         return jjMoveStringLiteralDfa1_0(0x20003000L, 0x0L);\n      case 103:\n         return jjMoveStringLiteralDfa1_0(0x40000000L, 0x0L);\n      case 105:\n         return jjMoveStringLiteralDfa1_0(0x8001c000L, 0x0L);\n      case 106:\n         return jjMoveStringLiteralDfa1_0(0x100000000L, 0x0L);\n      case 108:\n         return jjMoveStringLiteralDfa1_0(0x20000L, 0x0L);\n      case 109:\n         return jjMoveStringLiteralDfa1_0(0x40000L, 0x0L);\n      case 110:\n         return jjMoveStringLiteralDfa1_0(0x80000L, 0x0L);\n      case 111:\n         jjmatchedKind = 20;\n         return jjMoveStringLiteralDfa1_0(0x600600000L, 0x0L);\n      case 114:\n         return jjMoveStringLiteralDfa1_0(0x800000L, 0x0L);\n      case 115:\n         return jjMoveStringLiteralDfa1_0(0x800000000L, 0x0L);\n      case 116:\n         return jjMoveStringLiteralDfa1_0(0x3001000000L, 0x0L);\n      case 117:\n         return jjMoveStringLiteralDfa1_0(0x2000000L, 0x0L);\n      case 118:\n         return jjMoveStringLiteralDfa1_0(0x4000000L, 0x0L);\n      case 119:\n         return jjMoveStringLiteralDfa1_0(0x4000000000L, 0x0L);\n      case 121:\n         return jjMoveStringLiteralDfa1_0(0x8000000000L, 0x0L);\n      case 123:\n         return jjStopAtPos(0, 50);\n      case 124:\n         return jjStopAtPos(0, 55);\n      case 125:\n         return jjStopAtPos(0, 51);\n      case 126:\n         return jjStartNfaWithStates_0(0, 72, 41);\n      default :\n         return jjMoveNfa_0(11, 0);\n   }\n}\nprivate int jjMoveStringLiteralDfa1_0(long active0, long active1){\n   try { curChar = input_stream.readChar(); }\n   catch(java.io.IOException e) {\n      jjStopStringLiteralDfa_0(0, active0, active1);\n      return 1;\n   }\n   switch(curChar)\n   {\n      case 42:\n         if ((active1 & 0x100000L) != 0L)\n         {\n            jjmatchedKind = 84;\n            jjmatchedPos = 1;\n         }\n         return jjMoveStringLiteralDfa2_0(active0, 0L, active1, 0x80000L);\n      case 46:\n         return jjMoveStringLiteralDfa2_0(active0, 0L, active1, 0x800L);\n      case 58:\n         if ((active1 & 0x200L) != 0L)\n            return jjStopAtPos(1, 73);\n         break;\n      case 61:\n         if ((active1 & 0x1L) != 0L)\n            return jjStopAtPos(1, 64);\n         else if ((active1 & 0x2L) != 0L)\n            return jjStopAtPos(1, 65);\n         break;\n      case 62:\n         if ((active0 & 0x400000000000000L) != 0L)\n            return jjStopAtPos(1, 58);\n         else if ((active0 & 0x800000000000000L) != 0L)\n            return jjStopAtPos(1, 59);\n         else if ((active1 & 0x4L) != 0L)\n            return jjStopAtPos(1, 66);\n         break;\n      case 97:\n         return jjMoveStringLiteralDfa2_0(active0, 0x1004000060L, active1, 0L);\n      case 101:\n         return jjMoveStringLiteralDfa2_0(active0, 0x10820000L, active1, 0L);\n      case 102:\n         if ((active0 & 0x4000L) != 0L)\n            return jjStartNfaWithStates_0(1, 14, 40);\n         else if ((active0 & 0x200000L) != 0L)\n            return jjStartNfaWithStates_0(1, 21, 40);\n         break;\n      case 104:\n         return jjMoveStringLiteralDfa2_0(active0, 0x6001000000L, active1, 0L);\n      case 105:\n         return jjMoveStringLiteralDfa2_0(active0, 0x8000000080L, active1, 0L);\n      case 107:\n         return jjMoveStringLiteralDfa2_0(active0, 0x800000000L, active1, 0L);\n      case 108:\n         return jjMoveStringLiteralDfa2_0(active0, 0x300L, active1, 0L);\n      case 110:\n         if ((active0 & 0x1000L) != 0L)\n            return jjStartNfaWithStates_0(1, 12, 40);\n         else if ((active0 & 0x8000L) != 0L)\n         {\n            jjmatchedKind = 15;\n            jjmatchedPos = 1;\n         }\n         else if ((active0 & 0x200000000L) != 0L)\n            return jjStartNfaWithStates_0(1, 33, 40);\n         return jjMoveStringLiteralDfa2_0(active0, 0x8201080cL, active1, 0L);\n      case 111:\n         return jjMoveStringLiteralDfa2_0(active0, 0x1080c0000L, active1, 0L);\n      case 114:\n         return jjMoveStringLiteralDfa2_0(active0, 0x460400000L, active1, 0L);\n      case 115:\n         if ((active0 & 0x10L) != 0L)\n            return jjStartNfaWithStates_0(1, 4, 40);\n         break;\n      case 117:\n         return jjMoveStringLiteralDfa2_0(active0, 0x2000L, active1, 0L);\n      case 120:\n         return jjMoveStringLiteralDfa2_0(active0, 0x400L, active1, 0L);\n      default :\n         break;\n   }\n   return jjStartNfa_0(0, active0, active1);\n}\nprivate int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1){\n   if (((active0 &= old0) | (active1 &= old1)) == 0L)\n      return jjStartNfa_0(0, old0, old1);\n   try { curChar = input_stream.readChar(); }\n   catch(java.io.IOException e) {\n      jjStopStringLiteralDfa_0(1, active0, active1);\n      return 2;\n   }\n   switch(curChar)\n   {\n      case 41:\n         if ((active1 & 0x80000L) != 0L)\n            return jjStopAtPos(2, 83);\n         break;\n      case 46:\n         if ((active1 & 0x800L) != 0L)\n            return jjStopAtPos(2, 75);\n         break;\n      case 99:\n         if ((active0 & 0x800000L) != 0L)\n            return jjStartNfaWithStates_0(2, 23, 40);\n         return jjMoveStringLiteralDfa3_0(active0, 0x400L, active1, 0L);\n      case 100:\n         if ((active0 & 0x4L) != 0L)\n         {\n            jjmatchedKind = 2;\n            jjmatchedPos = 2;\n         }\n         else if ((active0 & 0x800L) != 0L)\n            return jjStartNfaWithStates_0(2, 11, 40);\n         else if ((active0 & 0x40000L) != 0L)\n            return jjStartNfaWithStates_0(2, 18, 40);\n         return jjMoveStringLiteralDfa3_0(active0, 0x400000008L, active1, 0L);\n      case 101:\n         return jjMoveStringLiteralDfa3_0(active0, 0xc001400100L, active1, 0L);\n      case 105:\n         return jjMoveStringLiteralDfa3_0(active0, 0x902000000L, active1, 0L);\n      case 107:\n         return jjMoveStringLiteralDfa3_0(active0, 0x1000000000L, active1, 0L);\n      case 108:\n         if ((active0 & 0x4000000L) != 0L)\n            return jjStartNfaWithStates_0(2, 26, 40);\n         break;\n      case 109:\n         return jjMoveStringLiteralDfa3_0(active0, 0x8000000L, active1, 0L);\n      case 110:\n         if ((active0 & 0x2000L) != 0L)\n            return jjStartNfaWithStates_0(2, 13, 40);\n         break;\n      case 111:\n         return jjMoveStringLiteralDfa3_0(active0, 0x60000000L, active1, 0L);\n      case 114:\n         return jjMoveStringLiteralDfa3_0(active0, 0x2000000000L, active1, 0L);\n      case 115:\n         return jjMoveStringLiteralDfa3_0(active0, 0x10000220L, active1, 0L);\n      case 116:\n         if ((active0 & 0x20000L) != 0L)\n            return jjStartNfaWithStates_0(2, 17, 40);\n         return jjMoveStringLiteralDfa3_0(active0, 0x80090040L, active1, 0L);\n      case 118:\n         if ((active0 & 0x80L) != 0L)\n            return jjStartNfaWithStates_0(2, 7, 40);\n         break;\n      default :\n         break;\n   }\n   return jjStartNfa_0(1, active0, active1);\n}\nprivate int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1){\n   if (((active0 &= old0) | (active1 &= old1)) == 0L)\n      return jjStartNfa_0(1, old0, old1);\n   try { curChar = input_stream.readChar(); }\n   catch(java.io.IOException e) {\n      jjStopStringLiteralDfa_0(2, active0, 0L);\n      return 3;\n   }\n   switch(curChar)\n   {\n      case 97:\n         return jjMoveStringLiteralDfa4_0(active0, 0x48L);\n      case 99:\n         if ((active0 & 0x10000000L) != 0L)\n            return jjStartNfaWithStates_0(3, 28, 40);\n         break;\n      case 101:\n         if ((active0 & 0x20L) != 0L)\n            return jjStartNfaWithStates_0(3, 5, 40);\n         else if ((active0 & 0x200L) != 0L)\n            return jjStartNfaWithStates_0(3, 9, 40);\n         else if ((active0 & 0x1000000000L) != 0L)\n            return jjStartNfaWithStates_0(3, 36, 40);\n         return jjMoveStringLiteralDfa4_0(active0, 0x400090400L);\n      case 108:\n         return jjMoveStringLiteralDfa4_0(active0, 0x8000400000L);\n      case 109:\n         if ((active0 & 0x100L) != 0L)\n            return jjStartNfaWithStates_0(3, 8, 40);\n         else if ((active0 & 0x20000000L) != 0L)\n            return jjStartNfaWithStates_0(3, 29, 40);\n         break;\n      case 110:\n         if ((active0 & 0x1000000L) != 0L)\n            return jjStartNfaWithStates_0(3, 24, 40);\n         else if ((active0 & 0x100000000L) != 0L)\n            return jjStartNfaWithStates_0(3, 32, 40);\n         break;\n      case 111:\n         if ((active0 & 0x80000000L) != 0L)\n            return jjStartNfaWithStates_0(3, 31, 40);\n         return jjMoveStringLiteralDfa4_0(active0, 0x2002000000L);\n      case 112:\n         if ((active0 & 0x800000000L) != 0L)\n            return jjStartNfaWithStates_0(3, 35, 40);\n         return jjMoveStringLiteralDfa4_0(active0, 0x8000000L);\n      case 114:\n         return jjMoveStringLiteralDfa4_0(active0, 0x4000000000L);\n      case 117:\n         return jjMoveStringLiteralDfa4_0(active0, 0x40000000L);\n      default :\n         break;\n   }\n   return jjStartNfa_0(2, active0, 0L);\n}\nprivate int jjMoveStringLiteralDfa4_0(long old0, long active0){\n   if (((active0 &= old0)) == 0L)\n      return jjStartNfa_0(2, old0, 0L);\n   try { curChar = input_stream.readChar(); }\n   catch(java.io.IOException e) {\n      jjStopStringLiteralDfa_0(3, active0, 0L);\n      return 4;\n   }\n   switch(curChar)\n   {\n      case 100:\n         if ((active0 & 0x8000000000L) != 0L)\n            return jjStartNfaWithStates_0(4, 39, 40);\n         break;\n      case 101:\n         if ((active0 & 0x4000000000L) != 0L)\n            return jjStartNfaWithStates_0(4, 38, 40);\n         break;\n      case 108:\n         return jjMoveStringLiteralDfa5_0(active0, 0x80008L);\n      case 110:\n         if ((active0 & 0x2000000L) != 0L)\n            return jjStartNfaWithStates_0(4, 25, 40);\n         break;\n      case 112:\n         if ((active0 & 0x40000000L) != 0L)\n            return jjStartNfaWithStates_0(4, 30, 40);\n         return jjMoveStringLiteralDfa5_0(active0, 0x400L);\n      case 114:\n         if ((active0 & 0x400000000L) != 0L)\n            return jjStartNfaWithStates_0(4, 34, 40);\n         return jjMoveStringLiteralDfa5_0(active0, 0x10000L);\n      case 115:\n         return jjMoveStringLiteralDfa5_0(active0, 0x400000L);\n      case 116:\n         return jjMoveStringLiteralDfa5_0(active0, 0x40L);\n      case 117:\n         return jjMoveStringLiteralDfa5_0(active0, 0x2008000000L);\n      default :\n         break;\n   }\n   return jjStartNfa_0(3, active0, 0L);\n}\nprivate int jjMoveStringLiteralDfa5_0(long old0, long active0){\n   if (((active0 &= old0)) == 0L)\n      return jjStartNfa_0(3, old0, 0L);\n   try { curChar = input_stream.readChar(); }\n   catch(java.io.IOException e) {\n      jjStopStringLiteralDfa_0(4, active0, 0L);\n      return 5;\n   }\n   switch(curChar)\n   {\n      case 101:\n         if ((active0 & 0x400000L) != 0L)\n            return jjStartNfaWithStates_0(5, 22, 40);\n         return jjMoveStringLiteralDfa6_0(active0, 0x80000L);\n      case 103:\n         return jjMoveStringLiteralDfa6_0(active0, 0x2000000000L);\n      case 115:\n         return jjMoveStringLiteralDfa6_0(active0, 0x10008L);\n      case 116:\n         if ((active0 & 0x400L) != 0L)\n            return jjStartNfaWithStates_0(5, 10, 40);\n         return jjMoveStringLiteralDfa6_0(active0, 0x8000000L);\n      case 121:\n         return jjMoveStringLiteralDfa6_0(active0, 0x40L);\n      default :\n         break;\n   }\n   return jjStartNfa_0(4, active0, 0L);\n}\nprivate int jjMoveStringLiteralDfa6_0(long old0, long active0){\n   if (((active0 &= old0)) == 0L)\n      return jjStartNfa_0(4, old0, 0L);\n   try { curChar = input_stream.readChar(); }\n   catch(java.io.IOException e) {\n      jjStopStringLiteralDfa_0(5, active0, 0L);\n      return 6;\n   }\n   switch(curChar)\n   {\n      case 101:\n         if ((active0 & 0x8000000L) != 0L)\n            return jjStartNfaWithStates_0(6, 27, 40);\n         return jjMoveStringLiteralDfa7_0(active0, 0x10000L);\n      case 104:\n         if ((active0 & 0x2000000000L) != 0L)\n            return jjStartNfaWithStates_0(6, 37, 40);\n         break;\n      case 109:\n         if ((active0 & 0x80000L) != 0L)\n            return jjStartNfaWithStates_0(6, 19, 40);\n         break;\n      case 111:\n         if ((active0 & 0x8L) != 0L)\n            return jjStartNfaWithStates_0(6, 3, 40);\n         break;\n      case 112:\n         return jjMoveStringLiteralDfa7_0(active0, 0x40L);\n      default :\n         break;\n   }\n   return jjStartNfa_0(5, active0, 0L);\n}\nprivate int jjMoveStringLiteralDfa7_0(long old0, long active0){\n   if (((active0 &= old0)) == 0L)\n      return jjStartNfa_0(5, old0, 0L);\n   try { curChar = input_stream.readChar(); }\n   catch(java.io.IOException e) {\n      jjStopStringLiteralDfa_0(6, active0, 0L);\n      return 7;\n   }\n   switch(curChar)\n   {\n      case 99:\n         return jjMoveStringLiteralDfa8_0(active0, 0x10000L);\n      case 101:\n         if ((active0 & 0x40L) != 0L)\n            return jjStartNfaWithStates_0(7, 6, 40);\n         break;\n      default :\n         break;\n   }\n   return jjStartNfa_0(6, active0, 0L);\n}\nprivate int jjMoveStringLiteralDfa8_0(long old0, long active0){\n   if (((active0 &= old0)) == 0L)\n      return jjStartNfa_0(6, old0, 0L);\n   try { curChar = input_stream.readChar(); }\n   catch(java.io.IOException e) {\n      jjStopStringLiteralDfa_0(7, active0, 0L);\n      return 8;\n   }\n   switch(curChar)\n   {\n      case 116:\n         if ((active0 & 0x10000L) != 0L)\n            return jjStartNfaWithStates_0(8, 16, 40);\n         break;\n      default :\n         break;\n   }\n   return jjStartNfa_0(7, active0, 0L);\n}\nprivate int jjStartNfaWithStates_0(int pos, int kind, int state)\n{\n   jjmatchedKind = kind;\n   jjmatchedPos = pos;\n   try { curChar = input_stream.readChar(); }\n   catch(java.io.IOException e) { return pos + 1; }\n   return jjMoveNfa_0(state, pos + 1);\n}\nstatic final long[] jjbitVec0 = {\n   0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL\n};\nstatic final long[] jjbitVec2 = {\n   0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL\n};\nstatic final long[] jjbitVec3 = {\n   0x1ff00000fffffffeL, 0xffffffffffffc000L, 0xffffffffL, 0x600000000000000L\n};\nstatic final long[] jjbitVec4 = {\n   0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL\n};\nstatic final long[] jjbitVec5 = {\n   0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL\n};\nstatic final long[] jjbitVec6 = {\n   0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffL, 0x0L\n};\nstatic final long[] jjbitVec7 = {\n   0xffffffffffffffffL, 0xffffffffffffffffL, 0x0L, 0x0L\n};\nstatic final long[] jjbitVec8 = {\n   0x3fffffffffffL, 0x0L, 0x0L, 0x0L\n};\nprivate int jjMoveNfa_0(int startState, int curPos)\n{\n   int startsAt = 0;\n   jjnewStateCnt = 39;\n   int i = 1;\n   jjstateSet[0] = startState;\n   int kind = 0x7fffffff;\n   for (;;)\n   {\n      if (++jjround == 0x7fffffff)\n         ReInitRounds();\n      if (curChar < 64)\n      {\n         long l = 1L << curChar;\n         do\n         {\n            switch(jjstateSet[--i])\n            {\n               case 40:\n                  if ((0x7ff600000000000L & l) != 0L)\n                     { jjCheckNAddTwoStates(6, 7); }\n                  else if (curChar == 36)\n                     jjstateSet[jjnewStateCnt++] = 8;\n                  if ((0x3ff008000000000L & l) != 0L)\n                  {\n                     if (kind > 89)\n                        kind = 89;\n                     { jjCheckNAdd(12); }\n                  }\n                  if ((0x3ff000000000000L & l) != 0L)\n                     { jjCheckNAddStates(0, 2); }\n                  break;\n               case 39:\n                  if ((0xfffffffbffffffffL & l) != 0L)\n                     { jjCheckNAddStates(3, 5); }\n                  else if (curChar == 34)\n                  {\n                     if (kind > 46)\n                        kind = 46;\n                  }\n                  break;\n               case 41:\n                  if ((0x3ff000000000000L & l) != 0L)\n                     { jjCheckNAddStates(6, 8); }\n                  if ((0x3ff000000000000L & l) != 0L)\n                     { jjCheckNAddTwoStates(21, 22); }\n                  if ((0x3ff000000000000L & l) != 0L)\n                  {\n                     if (kind > 41)\n                        kind = 41;\n                     { jjCheckNAdd(31); }\n                  }\n                  break;\n               case 11:\n                  if ((0x3ff000000000000L & l) != 0L)\n                  {\n                     if (kind > 40)\n                        kind = 40;\n                     { jjCheckNAddStates(9, 14); }\n                  }\n                  else if (curChar == 35)\n                     { jjCheckNAddTwoStates(33, 38); }\n                  else if (curChar == 39)\n                     jjstateSet[jjnewStateCnt++] = 17;\n                  else if (curChar == 34)\n                     { jjCheckNAddStates(3, 5); }\n                  if ((0x3ff000000000000L & l) != 0L)\n                     { jjCheckNAddStates(0, 2); }\n                  break;\n               case 0:\n                  if (curChar == 34)\n                     { jjCheckNAddStates(3, 5); }\n                  break;\n               case 1:\n                  if ((0xfffffffbffffffffL & l) != 0L)\n                     { jjCheckNAddStates(3, 5); }\n                  break;\n               case 2:\n                  if (curChar == 34 && kind > 46)\n                     kind = 46;\n                  break;\n               case 5:\n                  if ((0x3ff000000000000L & l) != 0L)\n                     { jjCheckNAddStates(0, 2); }\n                  break;\n               case 6:\n                  if ((0x7ff600000000000L & l) != 0L)\n                     { jjCheckNAddTwoStates(6, 7); }\n                  break;\n               case 7:\n                  if (curChar == 36)\n                     jjstateSet[jjnewStateCnt++] = 8;\n                  break;\n               case 9:\n                  if (curChar == 36)\n                     { jjCheckNAdd(10); }\n                  break;\n               case 10:\n                  if ((0x3ff000000000000L & l) == 0L)\n                     break;\n                  if (kind > 88)\n                     kind = 88;\n                  { jjCheckNAdd(10); }\n                  break;\n               case 12:\n                  if ((0x3ff008000000000L & l) == 0L)\n                     break;\n                  if (kind > 89)\n                     kind = 89;\n                  { jjCheckNAdd(12); }\n                  break;\n               case 14:\n                  { jjAddStates(15, 16); }\n                  break;\n               case 16:\n                  if (curChar == 39)\n                     jjstateSet[jjnewStateCnt++] = 17;\n                  break;\n               case 18:\n                  if ((0x3ff008000000000L & l) == 0L)\n                     break;\n                  if (kind > 91)\n                     kind = 91;\n                  jjstateSet[jjnewStateCnt++] = 18;\n                  break;\n               case 19:\n                  if ((0x3ff000000000000L & l) == 0L)\n                     break;\n                  if (kind > 40)\n                     kind = 40;\n                  { jjCheckNAddStates(9, 14); }\n                  break;\n               case 20:\n                  if ((0x3ff000000000000L & l) == 0L)\n                     break;\n                  if (kind > 40)\n                     kind = 40;\n                  { jjCheckNAdd(20); }\n                  break;\n               case 21:\n                  if ((0x3ff000000000000L & l) != 0L)\n                     { jjCheckNAddTwoStates(21, 22); }\n                  break;\n               case 22:\n                  if (curChar == 46)\n                     { jjCheckNAdd(23); }\n                  break;\n               case 23:\n                  if ((0x3ff000000000000L & l) == 0L)\n                     break;\n                  if (kind > 42)\n                     kind = 42;\n                  { jjCheckNAdd(23); }\n                  break;\n               case 24:\n                  if ((0x3ff000000000000L & l) != 0L)\n                     { jjCheckNAddStates(6, 8); }\n                  break;\n               case 25:\n                  if (curChar == 46)\n                     { jjCheckNAdd(26); }\n                  break;\n               case 26:\n                  if ((0x3ff000000000000L & l) != 0L)\n                     { jjCheckNAddTwoStates(26, 27); }\n                  break;\n               case 29:\n                  if ((0x3ff000000000000L & l) == 0L)\n                     break;\n                  if (kind > 43)\n                     kind = 43;\n                  jjstateSet[jjnewStateCnt++] = 29;\n                  break;\n               case 31:\n                  if ((0x3ff000000000000L & l) == 0L)\n                     break;\n                  if (kind > 41)\n                     kind = 41;\n                  { jjCheckNAdd(31); }\n                  break;\n               case 32:\n                  if (curChar == 35)\n                     { jjCheckNAddTwoStates(33, 38); }\n                  break;\n               case 33:\n                  if (curChar == 34)\n                     { jjCheckNAddStates(17, 19); }\n                  break;\n               case 34:\n                  if ((0xfffffffbffffffffL & l) != 0L)\n                     { jjCheckNAddStates(17, 19); }\n                  break;\n               case 35:\n                  if (curChar == 34 && kind > 47)\n                     kind = 47;\n                  break;\n               case 38:\n                  if ((0x3ff008000000000L & l) == 0L)\n                     break;\n                  if (kind > 92)\n                     kind = 92;\n                  { jjCheckNAdd(38); }\n                  break;\n               default : break;\n            }\n         } while(i != startsAt);\n      }\n      else if (curChar < 128)\n      {\n         long l = 1L << (curChar & 077);\n         do\n         {\n            switch(jjstateSet[--i])\n            {\n               case 40:\n                  if ((0x7fffffe87fffffeL & l) != 0L)\n                  {\n                     if (kind > 89)\n                        kind = 89;\n                     { jjCheckNAdd(12); }\n                  }\n                  if ((0x7fffffe87fffffeL & l) != 0L)\n                     { jjCheckNAddTwoStates(6, 7); }\n                  if ((0x7fffffe07fffffeL & l) != 0L)\n                     { jjCheckNAddStates(0, 2); }\n                  break;\n               case 39:\n                  if ((0xffffffffefffffffL & l) != 0L)\n                     { jjCheckNAddStates(3, 5); }\n                  else if (curChar == 92)\n                     { jjAddStates(20, 21); }\n                  break;\n               case 11:\n                  if ((0x7fffffe07fffffeL & l) != 0L)\n                  {\n                     if (kind > 89)\n                        kind = 89;\n                     { jjCheckNAdd(12); }\n                  }\n                  else if (curChar == 126)\n                     { jjAddStates(22, 24); }\n                  else if (curChar == 96)\n                     { jjCheckNAddTwoStates(14, 15); }\n                  if ((0x7fffffe07fffffeL & l) != 0L)\n                     { jjCheckNAddStates(0, 2); }\n                  break;\n               case 1:\n                  if ((0xffffffffefffffffL & l) != 0L)\n                     { jjCheckNAddStates(3, 5); }\n                  break;\n               case 3:\n                  if (curChar == 92)\n                     { jjAddStates(20, 21); }\n                  break;\n               case 4:\n                  if (curChar == 92)\n                     { jjCheckNAddStates(3, 5); }\n                  break;\n               case 5:\n                  if ((0x7fffffe07fffffeL & l) != 0L)\n                     { jjCheckNAddStates(0, 2); }\n                  break;\n               case 6:\n                  if ((0x7fffffe87fffffeL & l) != 0L)\n                     { jjCheckNAddTwoStates(6, 7); }\n                  break;\n               case 8:\n                  if ((0x7fffffe87fffffeL & l) == 0L)\n                     break;\n                  if (kind > 88)\n                     kind = 88;\n                  { jjAddStates(25, 26); }\n                  break;\n               case 10:\n                  if ((0x7fffffe87fffffeL & l) == 0L)\n                     break;\n                  if (kind > 88)\n                     kind = 88;\n                  jjstateSet[jjnewStateCnt++] = 10;\n                  break;\n               case 12:\n                  if ((0x7fffffe87fffffeL & l) == 0L)\n                     break;\n                  if (kind > 89)\n                     kind = 89;\n                  { jjCheckNAdd(12); }\n                  break;\n               case 13:\n                  if (curChar == 96)\n                     { jjCheckNAddTwoStates(14, 15); }\n                  break;\n               case 14:\n                  if ((0xfffffffeffffffffL & l) != 0L)\n                     { jjCheckNAddTwoStates(14, 15); }\n                  break;\n               case 15:\n                  if (curChar != 96)\n                     break;\n                  if (kind > 90)\n                     kind = 90;\n                  jjstateSet[jjnewStateCnt++] = 13;\n                  break;\n               case 17:\n                  if ((0x7fffffe07fffffeL & l) == 0L)\n                     break;\n                  if (kind > 91)\n                     kind = 91;\n                  { jjCheckNAdd(18); }\n                  break;\n               case 18:\n                  if ((0x7fffffe87fffffeL & l) == 0L)\n                     break;\n                  if (kind > 91)\n                     kind = 91;\n                  { jjCheckNAdd(18); }\n                  break;\n               case 27:\n                  if ((0x2000000020L & l) != 0L)\n                     { jjCheckNAddTwoStates(28, 29); }\n                  break;\n               case 28:\n                  if (curChar == 126)\n                     { jjCheckNAdd(29); }\n                  break;\n               case 30:\n                  if (curChar == 126)\n                     { jjAddStates(22, 24); }\n                  break;\n               case 34:\n                  if ((0xffffffffefffffffL & l) != 0L)\n                     { jjCheckNAddStates(17, 19); }\n                  break;\n               case 36:\n                  if (curChar == 92)\n                     { jjAddStates(27, 28); }\n                  break;\n               case 37:\n                  if (curChar == 92)\n                     { jjCheckNAddStates(17, 19); }\n                  break;\n               case 38:\n                  if ((0x7fffffe87fffffeL & l) == 0L)\n                     break;\n                  if (kind > 92)\n                     kind = 92;\n                  jjstateSet[jjnewStateCnt++] = 38;\n                  break;\n               default : break;\n            }\n         } while(i != startsAt);\n      }\n      else\n      {\n         int hiByte = (curChar >> 8);\n         int i1 = hiByte >> 6;\n         long l1 = 1L << (hiByte & 077);\n         int i2 = (curChar & 0xff) >> 6;\n         long l2 = 1L << (curChar & 077);\n         do\n         {\n            switch(jjstateSet[--i])\n            {\n               case 40:\n                  if (jjCanMove_1(hiByte, i1, i2, l1, l2))\n                     { jjCheckNAddStates(0, 2); }\n                  if (jjCanMove_1(hiByte, i1, i2, l1, l2))\n                     { jjCheckNAddTwoStates(6, 7); }\n                  if (jjCanMove_1(hiByte, i1, i2, l1, l2))\n                  {\n                     if (kind > 89)\n                        kind = 89;\n                     { jjCheckNAdd(12); }\n                  }\n                  break;\n               case 39:\n               case 1:\n                  if (jjCanMove_0(hiByte, i1, i2, l1, l2))\n                     { jjCheckNAddStates(3, 5); }\n                  break;\n               case 11:\n                  if (jjCanMove_1(hiByte, i1, i2, l1, l2))\n                     { jjCheckNAddStates(0, 2); }\n                  if (jjCanMove_1(hiByte, i1, i2, l1, l2))\n                  {\n                     if (kind > 89)\n                        kind = 89;\n                     { jjCheckNAdd(12); }\n                  }\n                  break;\n               case 5:\n                  if (jjCanMove_1(hiByte, i1, i2, l1, l2))\n                     { jjCheckNAddStates(0, 2); }\n                  break;\n               case 6:\n                  if (jjCanMove_1(hiByte, i1, i2, l1, l2))\n                     { jjCheckNAddTwoStates(6, 7); }\n                  break;\n               case 8:\n                  if (!jjCanMove_1(hiByte, i1, i2, l1, l2))\n                     break;\n                  if (kind > 88)\n                     kind = 88;\n                  { jjAddStates(25, 26); }\n                  break;\n               case 10:\n                  if (!jjCanMove_1(hiByte, i1, i2, l1, l2))\n                     break;\n                  if (kind > 88)\n                     kind = 88;\n                  jjstateSet[jjnewStateCnt++] = 10;\n                  break;\n               case 12:\n                  if (!jjCanMove_1(hiByte, i1, i2, l1, l2))\n                     break;\n                  if (kind > 89)\n                     kind = 89;\n                  { jjCheckNAdd(12); }\n                  break;\n               case 14:\n                  if (jjCanMove_0(hiByte, i1, i2, l1, l2))\n                     { jjAddStates(15, 16); }\n                  break;\n               case 17:\n               case 18:\n                  if (!jjCanMove_1(hiByte, i1, i2, l1, l2))\n                     break;\n                  if (kind > 91)\n                     kind = 91;\n                  { jjCheckNAdd(18); }\n                  break;\n               case 34:\n                  if (jjCanMove_0(hiByte, i1, i2, l1, l2))\n                     { jjAddStates(17, 19); }\n                  break;\n               case 38:\n                  if (!jjCanMove_1(hiByte, i1, i2, l1, l2))\n                     break;\n                  if (kind > 92)\n                     kind = 92;\n                  jjstateSet[jjnewStateCnt++] = 38;\n                  break;\n               default : if (i1 == 0 || l1 == 0 || i2 == 0 ||  l2 == 0) break; else break;\n            }\n         } while(i != startsAt);\n      }\n      if (kind != 0x7fffffff)\n      {\n         jjmatchedKind = kind;\n         jjmatchedPos = curPos;\n         kind = 0x7fffffff;\n      }\n      ++curPos;\n      if ((i = jjnewStateCnt) == (startsAt = 39 - (jjnewStateCnt = startsAt)))\n         return curPos;\n      try { curChar = input_stream.readChar(); }\n      catch(java.io.IOException e) { return curPos; }\n   }\n}\nprivate int jjMoveStringLiteralDfa0_1()\n{\n   return jjMoveNfa_1(0, 0);\n}\nprivate int jjMoveNfa_1(int startState, int curPos)\n{\n   int startsAt = 0;\n   jjnewStateCnt = 3;\n   int i = 1;\n   jjstateSet[0] = startState;\n   int kind = 0x7fffffff;\n   for (;;)\n   {\n      if (++jjround == 0x7fffffff)\n         ReInitRounds();\n      if (curChar < 64)\n      {\n         long l = 1L << curChar;\n         do\n         {\n            switch(jjstateSet[--i])\n            {\n               case 0:\n                  if ((0x2400L & l) != 0L)\n                  {\n                     if (kind > 85)\n                        kind = 85;\n                  }\n                  if (curChar == 13)\n                     jjstateSet[jjnewStateCnt++] = 1;\n                  break;\n               case 1:\n                  if (curChar == 10 && kind > 85)\n                     kind = 85;\n                  break;\n               case 2:\n                  if (curChar == 13)\n                     jjstateSet[jjnewStateCnt++] = 1;\n                  break;\n               default : break;\n            }\n         } while(i != startsAt);\n      }\n      else if (curChar < 128)\n      {\n         long l = 1L << (curChar & 077);\n         do\n         {\n            switch(jjstateSet[--i])\n            {\n               default : break;\n            }\n         } while(i != startsAt);\n      }\n      else\n      {\n         int hiByte = (curChar >> 8);\n         int i1 = hiByte >> 6;\n         long l1 = 1L << (hiByte & 077);\n         int i2 = (curChar & 0xff) >> 6;\n         long l2 = 1L << (curChar & 077);\n         do\n         {\n            switch(jjstateSet[--i])\n            {\n               default : if (i1 == 0 || l1 == 0 || i2 == 0 ||  l2 == 0) break; else break;\n            }\n         } while(i != startsAt);\n      }\n      if (kind != 0x7fffffff)\n      {\n         jjmatchedKind = kind;\n         jjmatchedPos = curPos;\n         kind = 0x7fffffff;\n      }\n      ++curPos;\n      if ((i = jjnewStateCnt) == (startsAt = 3 - (jjnewStateCnt = startsAt)))\n         return curPos;\n      try { curChar = input_stream.readChar(); }\n      catch(java.io.IOException e) { return curPos; }\n   }\n}\nprivate int jjMoveStringLiteralDfa0_2()\n{\n   return jjMoveNfa_2(0, 0);\n}\nprivate int jjMoveNfa_2(int startState, int curPos)\n{\n   int startsAt = 0;\n   jjnewStateCnt = 3;\n   int i = 1;\n   jjstateSet[0] = startState;\n   int kind = 0x7fffffff;\n   for (;;)\n   {\n      if (++jjround == 0x7fffffff)\n         ReInitRounds();\n      if (curChar < 64)\n      {\n         long l = 1L << curChar;\n         do\n         {\n            switch(jjstateSet[--i])\n            {\n               case 0:\n                  if ((0xfffffeffffffffffL & l) != 0L)\n                     jjstateSet[jjnewStateCnt++] = 2;\n                  break;\n               case 1:\n                  if (curChar == 41 && kind > 86)\n                     kind = 86;\n                  break;\n               case 2:\n                  if (curChar == 42)\n                     jjstateSet[jjnewStateCnt++] = 1;\n                  break;\n               default : break;\n            }\n         } while(i != startsAt);\n      }\n      else if (curChar < 128)\n      {\n         long l = 1L << (curChar & 077);\n         do\n         {\n            switch(jjstateSet[--i])\n            {\n               case 0:\n                  jjstateSet[jjnewStateCnt++] = 2;\n                  break;\n               default : break;\n            }\n         } while(i != startsAt);\n      }\n      else\n      {\n         int hiByte = (curChar >> 8);\n         int i1 = hiByte >> 6;\n         long l1 = 1L << (hiByte & 077);\n         int i2 = (curChar & 0xff) >> 6;\n         long l2 = 1L << (curChar & 077);\n         do\n         {\n            switch(jjstateSet[--i])\n            {\n               case 0:\n                  if (jjCanMove_0(hiByte, i1, i2, l1, l2))\n                     jjstateSet[jjnewStateCnt++] = 2;\n                  break;\n               default : if (i1 == 0 || l1 == 0 || i2 == 0 ||  l2 == 0) break; else break;\n            }\n         } while(i != startsAt);\n      }\n      if (kind != 0x7fffffff)\n      {\n         jjmatchedKind = kind;\n         jjmatchedPos = curPos;\n         kind = 0x7fffffff;\n      }\n      ++curPos;\n      if ((i = jjnewStateCnt) == (startsAt = 3 - (jjnewStateCnt = startsAt)))\n         return curPos;\n      try { curChar = input_stream.readChar(); }\n      catch(java.io.IOException e) { return curPos; }\n   }\n}\n\n/** Token literal values. */\npublic static final String[] jjstrLiteralImages = {\n\"\", \"\\137\", \"\\141\\156\\144\", \"\\141\\156\\144\\141\\154\\163\\157\", \"\\141\\163\", \n\"\\143\\141\\163\\145\", \"\\144\\141\\164\\141\\164\\171\\160\\145\", \"\\144\\151\\166\", \"\\145\\154\\145\\155\", \n\"\\145\\154\\163\\145\", \"\\145\\170\\143\\145\\160\\164\", \"\\145\\156\\144\", \"\\146\\156\", \"\\146\\165\\156\", \n\"\\151\\146\", \"\\151\\156\", \"\\151\\156\\164\\145\\162\\163\\145\\143\\164\", \"\\154\\145\\164\", \n\"\\155\\157\\144\", \"\\156\\157\\164\\145\\154\\145\\155\", \"\\157\", \"\\157\\146\", \n\"\\157\\162\\145\\154\\163\\145\", \"\\162\\145\\143\", \"\\164\\150\\145\\156\", \"\\165\\156\\151\\157\\156\", \"\\166\\141\\154\", \n\"\\143\\157\\155\\160\\165\\164\\145\", \"\\144\\145\\163\\143\", \"\\146\\162\\157\\155\", \"\\147\\162\\157\\165\\160\", \n\"\\151\\156\\164\\157\", \"\\152\\157\\151\\156\", \"\\157\\156\", \"\\157\\162\\144\\145\\162\", \"\\163\\153\\151\\160\", \n\"\\164\\141\\153\\145\", \"\\164\\150\\162\\157\\165\\147\\150\", \"\\167\\150\\145\\162\\145\", \n\"\\171\\151\\145\\154\\144\", null, null, null, null, null, null, null, null, \"\\50\", \"\\51\", \"\\173\", \"\\175\", \n\"\\133\", \"\\135\", \"\\73\", \"\\174\", \"\\56\", \"\\54\", \"\\75\\76\", \"\\55\\76\", \"\\75\", \"\\76\", \"\\74\", \n\"\\72\", \"\\74\\75\", \"\\76\\75\", \"\\74\\76\", \"\\53\", \"\\55\", \"\\136\", \"\\52\", \"\\57\", \"\\176\", \n\"\\72\\72\", \"\\100\", \"\\56\\56\\56\", \"\\47\", \"\\42\", null, null, null, null, null, null, null, \nnull, null, null, null, null, null, null, null, null, null, };\nprotected Token jjFillToken()\n{\n   final Token t;\n   final String curTokenImage;\n   final int beginLine;\n   final int endLine;\n   final int beginColumn;\n   final int endColumn;\n   String im = jjstrLiteralImages[jjmatchedKind];\n   curTokenImage = (im == null) ? input_stream.GetImage() : im;\n   beginLine = input_stream.getBeginLine();\n   beginColumn = input_stream.getBeginColumn();\n   endLine = input_stream.getEndLine();\n   endColumn = input_stream.getEndColumn();\n   t = Token.newToken(jjmatchedKind, curTokenImage);\n\n   t.beginLine = beginLine;\n   t.endLine = endLine;\n   t.beginColumn = beginColumn;\n   t.endColumn = endColumn;\n\n   return t;\n}\nstatic final int[] jjnextStates = {\n   5, 6, 7, 1, 2, 3, 24, 25, 27, 20, 21, 22, 24, 25, 27, 14, \n   15, 34, 35, 36, 0, 4, 31, 21, 24, 8, 9, 33, 37, \n};\nprivate static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2)\n{\n   switch(hiByte)\n   {\n      case 0:\n         return ((jjbitVec2[i2] & l2) != 0L);\n      default :\n         if ((jjbitVec0[i1] & l1) != 0L)\n            return true;\n         return false;\n   }\n}\nprivate static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2)\n{\n   switch(hiByte)\n   {\n      case 0:\n         return ((jjbitVec4[i2] & l2) != 0L);\n      case 48:\n         return ((jjbitVec5[i2] & l2) != 0L);\n      case 49:\n         return ((jjbitVec6[i2] & l2) != 0L);\n      case 51:\n         return ((jjbitVec7[i2] & l2) != 0L);\n      case 61:\n         return ((jjbitVec8[i2] & l2) != 0L);\n      default :\n         if ((jjbitVec3[i1] & l1) != 0L)\n            return true;\n         return false;\n   }\n}\n\nint curLexState = 0;\nint defaultLexState = 0;\nint jjnewStateCnt;\nint jjround;\nint jjmatchedPos;\nint jjmatchedKind;\n\n/** Get the next Token. */\npublic Token getNextToken() \n{\n  Token specialToken = null;\n  Token matchedToken;\n  int curPos = 0;\n\n  EOFLoop :\n  for (;;)\n  {\n   try\n   {\n      curChar = input_stream.BeginToken();\n   }\n   catch(Exception e)\n   {\n      jjmatchedKind = 0;\n      jjmatchedPos = -1;\n      matchedToken = jjFillToken();\n      matchedToken.specialToken = specialToken;\n      return matchedToken;\n   }\n   image = jjimage;\n   image.setLength(0);\n   jjimageLen = 0;\n\n   for (;;)\n   {\n     switch(curLexState)\n     {\n       case 0:\n         try { input_stream.backup(0);\n            while (curChar <= 32 && (0x100003600L & (1L << curChar)) != 0L)\n               curChar = input_stream.BeginToken();\n         }\n         catch (java.io.IOException e1) { continue EOFLoop; }\n         jjmatchedKind = 0x7fffffff;\n         jjmatchedPos = 0;\n         curPos = jjMoveStringLiteralDfa0_0();\n         break;\n       case 1:\n         jjmatchedKind = 0x7fffffff;\n         jjmatchedPos = 0;\n         curPos = jjMoveStringLiteralDfa0_1();\n         if (jjmatchedPos == 0 && jjmatchedKind > 87)\n         {\n            jjmatchedKind = 87;\n         }\n         break;\n       case 2:\n         jjmatchedKind = 0x7fffffff;\n         jjmatchedPos = 0;\n         curPos = jjMoveStringLiteralDfa0_2();\n         if (jjmatchedPos == 0 && jjmatchedKind > 87)\n         {\n            jjmatchedKind = 87;\n         }\n         break;\n     }\n     if (jjmatchedKind != 0x7fffffff)\n     {\n        if (jjmatchedPos + 1 < curPos)\n           input_stream.backup(curPos - jjmatchedPos - 1);\n        if ((jjtoToken[jjmatchedKind >> 6] & (1L << (jjmatchedKind & 077))) != 0L)\n        {\n           matchedToken = jjFillToken();\n           matchedToken.specialToken = specialToken;\n       if (jjnewLexState[jjmatchedKind] != -1)\n         curLexState = jjnewLexState[jjmatchedKind];\n           return matchedToken;\n        }\n        else if ((jjtoSkip[jjmatchedKind >> 6] & (1L << (jjmatchedKind & 077))) != 0L)\n        {\n           if ((jjtoSpecial[jjmatchedKind >> 6] & (1L << (jjmatchedKind & 077))) != 0L)\n           {\n              matchedToken = jjFillToken();\n              if (specialToken == null)\n                 specialToken = matchedToken;\n              else\n              {\n                 matchedToken.specialToken = specialToken;\n                 specialToken = (specialToken.next = matchedToken);\n              }\n              SkipLexicalActions(matchedToken);\n           }\n           else\n              SkipLexicalActions(null);\n         if (jjnewLexState[jjmatchedKind] != -1)\n           curLexState = jjnewLexState[jjmatchedKind];\n           continue EOFLoop;\n        }\n        MoreLexicalActions();\n      if (jjnewLexState[jjmatchedKind] != -1)\n        curLexState = jjnewLexState[jjmatchedKind];\n        curPos = 0;\n        jjmatchedKind = 0x7fffffff;\n        try {\n           curChar = input_stream.readChar();\n           continue;\n        }\n        catch (java.io.IOException e1) { }\n     }\n     int error_line = input_stream.getEndLine();\n     int error_column = input_stream.getEndColumn();\n     String error_after = null;\n     boolean EOFSeen = false;\n     try { input_stream.readChar(); input_stream.backup(1); }\n     catch (java.io.IOException e1) {\n        EOFSeen = true;\n        error_after = curPos <= 1 ? \"\" : input_stream.GetImage();\n        if (curChar == '\\n' || curChar == '\\r') {\n           error_line++;\n           error_column = 0;\n        }\n        else\n           error_column++;\n     }\n     if (!EOFSeen) {\n        input_stream.backup(1);\n        error_after = curPos <= 1 ? \"\" : input_stream.GetImage();\n     }\n     throw new TokenMgrError(EOFSeen, curLexState, error_line, error_column, error_after, curChar, TokenMgrError.LEXICAL_ERROR);\n   }\n  }\n}\n\nvoid SkipLexicalActions(Token matchedToken)\n{\n   switch(jjmatchedKind)\n   {\n      case 85 :\n         image.append(input_stream.GetSuffix(jjimageLen + (lengthOfMatch = jjmatchedPos + 1)));\n                                                   popState();\n         break;\n      case 86 :\n         image.append(input_stream.GetSuffix(jjimageLen + (lengthOfMatch = jjmatchedPos + 1)));\n                                   popState();\n         break;\n      default :\n         break;\n   }\n}\nvoid MoreLexicalActions()\n{\n   jjimageLen += (lengthOfMatch = jjmatchedPos + 1);\n   switch(jjmatchedKind)\n   {\n      case 83 :\n         image.append(input_stream.GetSuffix(jjimageLen));\n         jjimageLen = 0;\n            pushState();\n         break;\n      case 84 :\n         image.append(input_stream.GetSuffix(jjimageLen));\n         jjimageLen = 0;\n           pushState();\n         break;\n      default :\n         break;\n   }\n}\nvoid TokenLexicalActions(Token matchedToken)\n{\n   switch(jjmatchedKind)\n   {\n      default :\n         break;\n   }\n}\nprivate void jjCheckNAdd(int state)\n{\n   if (jjrounds[state] != jjround)\n   {\n      jjstateSet[jjnewStateCnt++] = state;\n      jjrounds[state] = jjround;\n   }\n}\nprivate void jjAddStates(int start, int end)\n{\n   do {\n      jjstateSet[jjnewStateCnt++] = jjnextStates[start];\n   } while (start++ != end);\n}\nprivate void jjCheckNAddTwoStates(int state1, int state2)\n{\n   jjCheckNAdd(state1);\n   jjCheckNAdd(state2);\n}\n\nprivate void jjCheckNAddStates(int start, int end)\n{\n   do {\n      jjCheckNAdd(jjnextStates[start]);\n   } while (start++ != end);\n}\n\n    /** Constructor. */\n    public MorelParserImplTokenManager(SimpleCharStream stream){\n\n      if (SimpleCharStream.staticFlag)\n            throw new Error(\"ERROR: Cannot use a static CharStream class with a non-static lexical analyzer.\");\n\n    input_stream = stream;\n  }\n\n  /** Constructor. */\n  public MorelParserImplTokenManager (SimpleCharStream stream, int lexState){\n    ReInit(stream);\n    SwitchTo(lexState);\n  }\n\n  /** Reinitialise parser. */\n  \n  public void ReInit(SimpleCharStream stream)\n  {\n\n\n    jjmatchedPos =\n    jjnewStateCnt =\n    0;\n    curLexState = defaultLexState;\n    input_stream = stream;\n    ReInitRounds();\n  }\n\n  private void ReInitRounds()\n  {\n    int i;\n    jjround = 0x80000001;\n    for (i = 39; i-- > 0;)\n      jjrounds[i] = 0x80000000;\n  }\n\n  /** Reinitialise parser. */\n  public void ReInit(SimpleCharStream stream, int lexState)\n  \n  {\n    ReInit(stream);\n    SwitchTo(lexState);\n  }\n\n  /** Switch to specified lex state. */\n  public void SwitchTo(int lexState)\n  {\n    if (lexState >= 3 || lexState < 0)\n      throw new TokenMgrError(\"Error: Ignoring invalid lexical state : \" + lexState + \". State unchanged.\", TokenMgrError.INVALID_LEXICAL_STATE);\n    else\n      curLexState = lexState;\n  }\n\n\n/** Lexer state names. */\npublic static final String[] lexStateNames = {\n   \"DEFAULT\",\n   \"IN_LINE_COMMENT\",\n   \"IN_COMMENT\",\n};\n\n/** Lex State array. */\npublic static final int[] jjnewLexState = {\n   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, \n   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, \n   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, \n   -1, -1, -1, -1, -1, -1, -1, -1, 1, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, \n};\nstatic final long[] jjtoToken = {\n   0xffffcfffffffffffL, 0x1f003fffL, \n};\nstatic final long[] jjtoSkip = {\n   0x0L, 0x67c000L, \n};\nstatic final long[] jjtoSpecial = {\n   0x0L, 0x600000L, \n};\nstatic final long[] jjtoMore = {\n   0x0L, 0x980000L, \n};\n    protected SimpleCharStream  input_stream;\n\n    private final int[] jjrounds = new int[39];\n    private final int[] jjstateSet = new int[2 * 39];\n    private final StringBuilder jjimage = new StringBuilder();\n    private StringBuilder image = jjimage;\n    private int jjimageLen;\n    private int lengthOfMatch;\n    protected int curChar;\n}", "super_interfaces": ["MorelParserImplConstants"], "fields": [{"attribute_expression": "List<Integer> lexicalStateStack = new ArrayList<>();", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "List<Integer>", "name": "lexicalStateStack = new ArrayList<>()", "syntax_pass": true}, {"attribute_expression": "public  java.io.PrintStream debugStream = System.out;", "docstring": " Debug output.", "modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "type": "java.io.PrintStream", "name": "debugStream = System.out", "syntax_pass": true}, {"attribute_expression": "static final long[] jjbitVec0 = {\n   0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL\n};", "docstring": "", "modifiers": "static final", "marker_annotations": [], "non_marker_annotations": ["static", "final"], "comments": [], "type": "long[]", "name": "jjbitVec0 = {\n   0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL\n}", "syntax_pass": true}, {"attribute_expression": "static final long[] jjbitVec2 = {\n   0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL\n};", "docstring": "", "modifiers": "static final", "marker_annotations": [], "non_marker_annotations": ["static", "final"], "comments": [], "type": "long[]", "name": "jjbitVec2 = {\n   0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL\n}", "syntax_pass": true}, {"attribute_expression": "static final long[] jjbitVec3 = {\n   0x1ff00000fffffffeL, 0xffffffffffffc000L, 0xffffffffL, 0x600000000000000L\n};", "docstring": "", "modifiers": "static final", "marker_annotations": [], "non_marker_annotations": ["static", "final"], "comments": [], "type": "long[]", "name": "jjbitVec3 = {\n   0x1ff00000fffffffeL, 0xffffffffffffc000L, 0xffffffffL, 0x600000000000000L\n}", "syntax_pass": true}, {"attribute_expression": "static final long[] jjbitVec4 = {\n   0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL\n};", "docstring": "", "modifiers": "static final", "marker_annotations": [], "non_marker_annotations": ["static", "final"], "comments": [], "type": "long[]", "name": "jjbitVec4 = {\n   0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL\n}", "syntax_pass": true}, {"attribute_expression": "static final long[] jjbitVec5 = {\n   0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL\n};", "docstring": "", "modifiers": "static final", "marker_annotations": [], "non_marker_annotations": ["static", "final"], "comments": [], "type": "long[]", "name": "jjbitVec5 = {\n   0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL\n}", "syntax_pass": true}, {"attribute_expression": "static final long[] jjbitVec6 = {\n   0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffL, 0x0L\n};", "docstring": "", "modifiers": "static final", "marker_annotations": [], "non_marker_annotations": ["static", "final"], "comments": [], "type": "long[]", "name": "jjbitVec6 = {\n   0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffL, 0x0L\n}", "syntax_pass": true}, {"attribute_expression": "static final long[] jjbitVec7 = {\n   0xffffffffffffffffL, 0xffffffffffffffffL, 0x0L, 0x0L\n};", "docstring": "", "modifiers": "static final", "marker_annotations": [], "non_marker_annotations": ["static", "final"], "comments": [], "type": "long[]", "name": "jjbitVec7 = {\n   0xffffffffffffffffL, 0xffffffffffffffffL, 0x0L, 0x0L\n}", "syntax_pass": true}, {"attribute_expression": "static final long[] jjbitVec8 = {\n   0x3fffffffffffL, 0x0L, 0x0L, 0x0L\n};", "docstring": "", "modifiers": "static final", "marker_annotations": [], "non_marker_annotations": ["static", "final"], "comments": [], "type": "long[]", "name": "jjbitVec8 = {\n   0x3fffffffffffL, 0x0L, 0x0L, 0x0L\n}", "syntax_pass": true}, {"attribute_expression": "public static final String[] jjstrLiteralImages = {\n\"\", \"\\137\", \"\\141\\156\\144\", \"\\141\\156\\144\\141\\154\\163\\157\", \"\\141\\163\", \n\"\\143\\141\\163\\145\", \"\\144\\141\\164\\141\\164\\171\\160\\145\", \"\\144\\151\\166\", \"\\145\\154\\145\\155\", \n\"\\145\\154\\163\\145\", \"\\145\\170\\143\\145\\160\\164\", \"\\145\\156\\144\", \"\\146\\156\", \"\\146\\165\\156\", \n\"\\151\\146\", \"\\151\\156\", \"\\151\\156\\164\\145\\162\\163\\145\\143\\164\", \"\\154\\145\\164\", \n\"\\155\\157\\144\", \"\\156\\157\\164\\145\\154\\145\\155\", \"\\157\", \"\\157\\146\", \n\"\\157\\162\\145\\154\\163\\145\", \"\\162\\145\\143\", \"\\164\\150\\145\\156\", \"\\165\\156\\151\\157\\156\", \"\\166\\141\\154\", \n\"\\143\\157\\155\\160\\165\\164\\145\", \"\\144\\145\\163\\143\", \"\\146\\162\\157\\155\", \"\\147\\162\\157\\165\\160\", \n\"\\151\\156\\164\\157\", \"\\152\\157\\151\\156\", \"\\157\\156\", \"\\157\\162\\144\\145\\162\", \"\\163\\153\\151\\160\", \n\"\\164\\141\\153\\145\", \"\\164\\150\\162\\157\\165\\147\\150\", \"\\167\\150\\145\\162\\145\", \n\"\\171\\151\\145\\154\\144\", null, null, null, null, null, null, null, null, \"\\50\", \"\\51\", \"\\173\", \"\\175\", \n\"\\133\", \"\\135\", \"\\73\", \"\\174\", \"\\56\", \"\\54\", \"\\75\\76\", \"\\55\\76\", \"\\75\", \"\\76\", \"\\74\", \n\"\\72\", \"\\74\\75\", \"\\76\\75\", \"\\74\\76\", \"\\53\", \"\\55\", \"\\136\", \"\\52\", \"\\57\", \"\\176\", \n\"\\72\\72\", \"\\100\", \"\\56\\56\\56\", \"\\47\", \"\\42\", null, null, null, null, null, null, null, \nnull, null, null, null, null, null, null, null, null, null, };", "docstring": " Token literal values.", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "String[]", "name": "jjstrLiteralImages = {\n\"\", \"\\137\", \"\\141\\156\\144\", \"\\141\\156\\144\\141\\154\\163\\157\", \"\\141\\163\", \n\"\\143\\141\\163\\145\", \"\\144\\141\\164\\141\\164\\171\\160\\145\", \"\\144\\151\\166\", \"\\145\\154\\145\\155\", \n\"\\145\\154\\163\\145\", \"\\145\\170\\143\\145\\160\\164\", \"\\145\\156\\144\", \"\\146\\156\", \"\\146\\165\\156\", \n\"\\151\\146\", \"\\151\\156\", \"\\151\\156\\164\\145\\162\\163\\145\\143\\164\", \"\\154\\145\\164\", \n\"\\155\\157\\144\", \"\\156\\157\\164\\145\\154\\145\\155\", \"\\157\", \"\\157\\146\", \n\"\\157\\162\\145\\154\\163\\145\", \"\\162\\145\\143\", \"\\164\\150\\145\\156\", \"\\165\\156\\151\\157\\156\", \"\\166\\141\\154\", \n\"\\143\\157\\155\\160\\165\\164\\145\", \"\\144\\145\\163\\143\", \"\\146\\162\\157\\155\", \"\\147\\162\\157\\165\\160\", \n\"\\151\\156\\164\\157\", \"\\152\\157\\151\\156\", \"\\157\\156\", \"\\157\\162\\144\\145\\162\", \"\\163\\153\\151\\160\", \n\"\\164\\141\\153\\145\", \"\\164\\150\\162\\157\\165\\147\\150\", \"\\167\\150\\145\\162\\145\", \n\"\\171\\151\\145\\154\\144\", null, null, null, null, null, null, null, null, \"\\50\", \"\\51\", \"\\173\", \"\\175\", \n\"\\133\", \"\\135\", \"\\73\", \"\\174\", \"\\56\", \"\\54\", \"\\75\\76\", \"\\55\\76\", \"\\75\", \"\\76\", \"\\74\", \n\"\\72\", \"\\74\\75\", \"\\76\\75\", \"\\74\\76\", \"\\53\", \"\\55\", \"\\136\", \"\\52\", \"\\57\", \"\\176\", \n\"\\72\\72\", \"\\100\", \"\\56\\56\\56\", \"\\47\", \"\\42\", null, null, null, null, null, null, null, \nnull, null, null, null, null, null, null, null, null, null, }", "syntax_pass": true}, {"attribute_expression": "static final int[] jjnextStates = {\n   5, 6, 7, 1, 2, 3, 24, 25, 27, 20, 21, 22, 24, 25, 27, 14, \n   15, 34, 35, 36, 0, 4, 31, 21, 24, 8, 9, 33, 37, \n};", "docstring": "", "modifiers": "static final", "marker_annotations": [], "non_marker_annotations": ["static", "final"], "comments": [], "type": "int[]", "name": "jjnextStates = {\n   5, 6, 7, 1, 2, 3, 24, 25, 27, 20, 21, 22, 24, 25, 27, 14, \n   15, 34, 35, 36, 0, 4, 31, 21, 24, 8, 9, 33, 37, \n}", "syntax_pass": true}, {"attribute_expression": "int curLexState = 0;", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "int", "name": "curLexState = 0", "syntax_pass": true}, {"attribute_expression": "int defaultLexState = 0;", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "int", "name": "defaultLexState = 0", "syntax_pass": true}, {"attribute_expression": "int jjnewStateCnt;", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "int", "name": "jjnewStateCnt", "syntax_pass": true}, {"attribute_expression": "int jjround;", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "int", "name": "jjround", "syntax_pass": true}, {"attribute_expression": "int jjmatchedPos;", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "int", "name": "jjmatchedPos", "syntax_pass": true}, {"attribute_expression": "int jjmatchedKind;", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "int", "name": "jjmatchedKind", "syntax_pass": true}, {"attribute_expression": "public static final String[] lexStateNames = {\n   \"DEFAULT\",\n   \"IN_LINE_COMMENT\",\n   \"IN_COMMENT\",\n};", "docstring": " Lexer state names.", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "String[]", "name": "lexStateNames = {\n   \"DEFAULT\",\n   \"IN_LINE_COMMENT\",\n   \"IN_COMMENT\",\n}", "syntax_pass": true}, {"attribute_expression": "public static final int[] jjnewLexState = {\n   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, \n   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, \n   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, \n   -1, -1, -1, -1, -1, -1, -1, -1, 1, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, \n};", "docstring": " Lex State array.", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "int[]", "name": "jjnewLexState = {\n   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, \n   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, \n   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, \n   -1, -1, -1, -1, -1, -1, -1, -1, 1, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, \n}", "syntax_pass": true}, {"attribute_expression": "static final long[] jjtoToken = {\n   0xffffcfffffffffffL, 0x1f003fffL, \n};", "docstring": "", "modifiers": "static final", "marker_annotations": [], "non_marker_annotations": ["static", "final"], "comments": [], "type": "long[]", "name": "jjtoToken = {\n   0xffffcfffffffffffL, 0x1f003fffL, \n}", "syntax_pass": true}, {"attribute_expression": "static final long[] jjtoSkip = {\n   0x0L, 0x67c000L, \n};", "docstring": "", "modifiers": "static final", "marker_annotations": [], "non_marker_annotations": ["static", "final"], "comments": [], "type": "long[]", "name": "jjtoSkip = {\n   0x0L, 0x67c000L, \n}", "syntax_pass": true}, {"attribute_expression": "static final long[] jjtoSpecial = {\n   0x0L, 0x600000L, \n};", "docstring": "", "modifiers": "static final", "marker_annotations": [], "non_marker_annotations": ["static", "final"], "comments": [], "type": "long[]", "name": "jjtoSpecial = {\n   0x0L, 0x600000L, \n}", "syntax_pass": true}, {"attribute_expression": "static final long[] jjtoMore = {\n   0x0L, 0x980000L, \n};", "docstring": "", "modifiers": "static final", "marker_annotations": [], "non_marker_annotations": ["static", "final"], "comments": [], "type": "long[]", "name": "jjtoMore = {\n   0x0L, 0x980000L, \n}", "syntax_pass": true}, {"attribute_expression": "protected SimpleCharStream  input_stream;", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "SimpleCharStream", "name": "input_stream", "syntax_pass": true}, {"attribute_expression": "private final int[] jjrounds = new int[39];", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "int[]", "name": "jjrounds = new int[39]", "syntax_pass": true}, {"attribute_expression": "private final int[] jjstateSet = new int[2 * 39];", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "int[]", "name": "jjstateSet = new int[2 * 39]", "syntax_pass": true}, {"attribute_expression": "private final StringBuilder jjimage = new StringBuilder();", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "StringBuilder", "name": "jjimage = new StringBuilder()", "syntax_pass": true}, {"attribute_expression": "private StringBuilder image = jjimage;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "StringBuilder", "name": "image = jjimage", "syntax_pass": true}, {"attribute_expression": "private int jjimageLen;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "int", "name": "jjimageLen", "syntax_pass": true}, {"attribute_expression": "private int lengthOfMatch;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "int", "name": "lengthOfMatch", "syntax_pass": true}, {"attribute_expression": "protected int curChar;", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "int", "name": "curChar", "syntax_pass": true}]}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/SimpleCharStream.java.SimpleCharStream", "name": "SimpleCharStream", "file_path": "target/generated-sources/javacc/net/hydromatic/morel/parse/SimpleCharStream.java", "superclasses": "", "methods": ["[void]setTabSize(int)", "[int]getTabSize()", "[void]ExpandBuff(boolean)", "[void]FillBuff()", "[char]BeginToken()", "[void]UpdateLineColumn(char)", "[char]readChar()", "[int]getColumn()", "[int]getLine()", "[int]getEndColumn()", "[int]getEndLine()", "[int]getBeginColumn()", "[int]getBeginLine()", "[void]backup(int)", "[]SimpleCharStream(java.io.Reader,int,int,int)", "[]SimpleCharStream(java.io.Reader,int,int)", "[]SimpleCharStream(java.io.Reader)", "[void]ReInit(java.io.Reader,int,int,int)", "[void]ReInit(java.io.Reader,int,int)", "[void]ReInit(java.io.Reader)", "[]SimpleCharStream(java.io.InputStream,String,int,int,int)", "[]SimpleCharStream(java.io.InputStream,int,int,int)", "[]SimpleCharStream(java.io.InputStream,String,int,int)", "[]SimpleCharStream(java.io.InputStream,int,int)", "[]SimpleCharStream(java.io.InputStream,String)", "[]SimpleCharStream(java.io.InputStream)", "[void]ReInit(java.io.InputStream,String,int,int,int)", "[void]ReInit(java.io.InputStream,int,int,int)", "[void]ReInit(java.io.InputStream,String)", "[void]ReInit(java.io.InputStream)", "[void]ReInit(java.io.InputStream,String,int,int)", "[void]ReInit(java.io.InputStream,int,int)", "[String]GetImage()", "[char[]]GetSuffix(int)", "[void]Done()", "[void]adjustBeginLineColumn(int,int)", "[boolean]getTrackLineColumn()", "[void]setTrackLineColumn(boolean)"], "method_uris": ["target/generated-sources/javacc/net/hydromatic/morel/parse/SimpleCharStream.java.SimpleCharStream.[void]setTabSize(int)", "target/generated-sources/javacc/net/hydromatic/morel/parse/SimpleCharStream.java.SimpleCharStream.[int]getTabSize()", "target/generated-sources/javacc/net/hydromatic/morel/parse/SimpleCharStream.java.SimpleCharStream.[void]ExpandBuff(boolean)", "target/generated-sources/javacc/net/hydromatic/morel/parse/SimpleCharStream.java.SimpleCharStream.[void]FillBuff()", "target/generated-sources/javacc/net/hydromatic/morel/parse/SimpleCharStream.java.SimpleCharStream.[char]BeginToken()", "target/generated-sources/javacc/net/hydromatic/morel/parse/SimpleCharStream.java.SimpleCharStream.[void]UpdateLineColumn(char)", "target/generated-sources/javacc/net/hydromatic/morel/parse/SimpleCharStream.java.SimpleCharStream.[char]readChar()", "target/generated-sources/javacc/net/hydromatic/morel/parse/SimpleCharStream.java.SimpleCharStream.[int]getColumn()", "target/generated-sources/javacc/net/hydromatic/morel/parse/SimpleCharStream.java.SimpleCharStream.[int]getLine()", "target/generated-sources/javacc/net/hydromatic/morel/parse/SimpleCharStream.java.SimpleCharStream.[int]getEndColumn()", "target/generated-sources/javacc/net/hydromatic/morel/parse/SimpleCharStream.java.SimpleCharStream.[int]getEndLine()", "target/generated-sources/javacc/net/hydromatic/morel/parse/SimpleCharStream.java.SimpleCharStream.[int]getBeginColumn()", "target/generated-sources/javacc/net/hydromatic/morel/parse/SimpleCharStream.java.SimpleCharStream.[int]getBeginLine()", "target/generated-sources/javacc/net/hydromatic/morel/parse/SimpleCharStream.java.SimpleCharStream.[void]backup(int)", "target/generated-sources/javacc/net/hydromatic/morel/parse/SimpleCharStream.java.SimpleCharStream.[]SimpleCharStream(java.io.Reader,int,int,int)", "target/generated-sources/javacc/net/hydromatic/morel/parse/SimpleCharStream.java.SimpleCharStream.[]SimpleCharStream(java.io.Reader,int,int)", "target/generated-sources/javacc/net/hydromatic/morel/parse/SimpleCharStream.java.SimpleCharStream.[]SimpleCharStream(java.io.Reader)", "target/generated-sources/javacc/net/hydromatic/morel/parse/SimpleCharStream.java.SimpleCharStream.[void]ReInit(java.io.Reader,int,int,int)", "target/generated-sources/javacc/net/hydromatic/morel/parse/SimpleCharStream.java.SimpleCharStream.[void]ReInit(java.io.Reader,int,int)", "target/generated-sources/javacc/net/hydromatic/morel/parse/SimpleCharStream.java.SimpleCharStream.[void]ReInit(java.io.Reader)", "target/generated-sources/javacc/net/hydromatic/morel/parse/SimpleCharStream.java.SimpleCharStream.[]SimpleCharStream(java.io.InputStream,String,int,int,int)", "target/generated-sources/javacc/net/hydromatic/morel/parse/SimpleCharStream.java.SimpleCharStream.[]SimpleCharStream(java.io.InputStream,int,int,int)", "target/generated-sources/javacc/net/hydromatic/morel/parse/SimpleCharStream.java.SimpleCharStream.[]SimpleCharStream(java.io.InputStream,String,int,int)", "target/generated-sources/javacc/net/hydromatic/morel/parse/SimpleCharStream.java.SimpleCharStream.[]SimpleCharStream(java.io.InputStream,int,int)", "target/generated-sources/javacc/net/hydromatic/morel/parse/SimpleCharStream.java.SimpleCharStream.[]SimpleCharStream(java.io.InputStream,String)", "target/generated-sources/javacc/net/hydromatic/morel/parse/SimpleCharStream.java.SimpleCharStream.[]SimpleCharStream(java.io.InputStream)", "target/generated-sources/javacc/net/hydromatic/morel/parse/SimpleCharStream.java.SimpleCharStream.[void]ReInit(java.io.InputStream,String,int,int,int)", "target/generated-sources/javacc/net/hydromatic/morel/parse/SimpleCharStream.java.SimpleCharStream.[void]ReInit(java.io.InputStream,int,int,int)", "target/generated-sources/javacc/net/hydromatic/morel/parse/SimpleCharStream.java.SimpleCharStream.[void]ReInit(java.io.InputStream,String)", "target/generated-sources/javacc/net/hydromatic/morel/parse/SimpleCharStream.java.SimpleCharStream.[void]ReInit(java.io.InputStream)", "target/generated-sources/javacc/net/hydromatic/morel/parse/SimpleCharStream.java.SimpleCharStream.[void]ReInit(java.io.InputStream,String,int,int)", "target/generated-sources/javacc/net/hydromatic/morel/parse/SimpleCharStream.java.SimpleCharStream.[void]ReInit(java.io.InputStream,int,int)", "target/generated-sources/javacc/net/hydromatic/morel/parse/SimpleCharStream.java.SimpleCharStream.[String]GetImage()", "target/generated-sources/javacc/net/hydromatic/morel/parse/SimpleCharStream.java.SimpleCharStream.[char[]]GetSuffix(int)", "target/generated-sources/javacc/net/hydromatic/morel/parse/SimpleCharStream.java.SimpleCharStream.[void]Done()", "target/generated-sources/javacc/net/hydromatic/morel/parse/SimpleCharStream.java.SimpleCharStream.[void]adjustBeginLineColumn(int,int)", "target/generated-sources/javacc/net/hydromatic/morel/parse/SimpleCharStream.java.SimpleCharStream.[boolean]getTrackLineColumn()", "target/generated-sources/javacc/net/hydromatic/morel/parse/SimpleCharStream.java.SimpleCharStream.[void]setTrackLineColumn(boolean)"], "overrides": null, "attributes": [], "class_docstring": "\nAn implementation of interface CharStream, where the stream is assumed to\ncontain only ASCII characters (without unicode processing).\n", "original_string": "public class SimpleCharStream\n{\n/** Whether parser is static. */\n  public static final boolean staticFlag = false;\n  int bufsize;\n  int available;\n  int tokenBegin;\n/** Position in buffer. */\n  public int bufpos = -1;\n  protected int bufline[];\n  protected int bufcolumn[];\n\n  protected int column = 0;\n  protected int line = 1;\n\n  protected boolean prevCharIsCR = false;\n  protected boolean prevCharIsLF = false;\n\n  protected java.io.Reader inputStream;\n\n  protected char[] buffer;\n  protected int maxNextCharInd = 0;\n  protected int inBuf = 0;\n  protected int tabSize = 1;\n  protected boolean trackLineColumn = true;\n\n  public void setTabSize(int i) { tabSize = i; }\n  public int getTabSize() { return tabSize; }\n\n\n\n  protected void ExpandBuff(boolean wrapAround)\n  {\n    char[] newbuffer = new char[bufsize + 2048];\n    int newbufline[] = new int[bufsize + 2048];\n    int newbufcolumn[] = new int[bufsize + 2048];\n\n    try\n    {\n      if (wrapAround)\n      {\n        System.arraycopy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin);\n        System.arraycopy(buffer, 0, newbuffer, bufsize - tokenBegin, bufpos);\n        buffer = newbuffer;\n\n        System.arraycopy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin);\n        System.arraycopy(bufline, 0, newbufline, bufsize - tokenBegin, bufpos);\n        bufline = newbufline;\n\n        System.arraycopy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin);\n        System.arraycopy(bufcolumn, 0, newbufcolumn, bufsize - tokenBegin, bufpos);\n        bufcolumn = newbufcolumn;\n\n        maxNextCharInd = (bufpos += (bufsize - tokenBegin));\n      }\n      else\n      {\n        System.arraycopy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin);\n        buffer = newbuffer;\n\n        System.arraycopy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin);\n        bufline = newbufline;\n\n        System.arraycopy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin);\n        bufcolumn = newbufcolumn;\n\n        maxNextCharInd = (bufpos -= tokenBegin);\n      }\n    }\n    catch (Throwable t)\n    {\n      throw new Error(t.getMessage());\n    }\n\n\n    bufsize += 2048;\n    available = bufsize;\n    tokenBegin = 0;\n  }\n\n  protected void FillBuff() throws java.io.IOException\n  {\n    if (maxNextCharInd == available)\n    {\n      if (available == bufsize)\n      {\n        if (tokenBegin > 2048)\n        {\n          bufpos = maxNextCharInd = 0;\n          available = tokenBegin;\n        }\n        else if (tokenBegin < 0)\n          bufpos = maxNextCharInd = 0;\n        else\n          ExpandBuff(false);\n      }\n      else if (available > tokenBegin)\n        available = bufsize;\n      else if ((tokenBegin - available) < 2048)\n        ExpandBuff(true);\n      else\n        available = tokenBegin;\n    }\n\n    int i;\n    try {\n      if ((i = inputStream.read(buffer, maxNextCharInd, available - maxNextCharInd)) == -1)\n      {\n        inputStream.close();\n        throw new java.io.IOException();\n      }\n      else\n        maxNextCharInd += i;\n      return;\n    }\n    catch(java.io.IOException e) {\n      --bufpos;\n      backup(0);\n      if (tokenBegin == -1)\n        tokenBegin = bufpos;\n      throw e;\n    }\n  }\n\n/** Start. */\n  public char BeginToken() throws java.io.IOException\n  {\n    tokenBegin = -1;\n    char c = readChar();\n    tokenBegin = bufpos;\n\n    return c;\n  }\n\n  protected void UpdateLineColumn(char c)\n  {\n    column++;\n\n    if (prevCharIsLF)\n    {\n      prevCharIsLF = false;\n      line += (column = 1);\n    }\n    else if (prevCharIsCR)\n    {\n      prevCharIsCR = false;\n      if (c == '\\n')\n      {\n        prevCharIsLF = true;\n      }\n      else\n        line += (column = 1);\n    }\n\n    switch (c)\n    {\n      case '\\r' :\n        prevCharIsCR = true;\n        break;\n      case '\\n' :\n        prevCharIsLF = true;\n        break;\n      case '\\t' :\n        column--;\n        column += (tabSize - (column % tabSize));\n        break;\n      default :\n        break;\n    }\n\n    bufline[bufpos] = line;\n    bufcolumn[bufpos] = column;\n  }\n\n/** Read a character. */\n  public char readChar() throws java.io.IOException\n  {\n    if (inBuf > 0)\n    {\n      --inBuf;\n\n      if (++bufpos == bufsize)\n        bufpos = 0;\n\n      return buffer[bufpos];\n    }\n\n    if (++bufpos >= maxNextCharInd)\n      FillBuff();\n\n    char c = buffer[bufpos];\n\n    UpdateLineColumn(c);\n    return c;\n  }\n\n  /**\n   * @deprecated\n   * @see #getEndColumn\n   */\n  @Deprecated\n  public int getColumn() {\n    return bufcolumn[bufpos];\n  }\n\n  /**\n   * @deprecated\n   * @see #getEndLine\n   */\n  @Deprecated\n  public int getLine() {\n    return bufline[bufpos];\n  }\n\n  /** Get token end column number. */\n  public int getEndColumn() {\n    return bufcolumn[bufpos];\n  }\n\n  /** Get token end line number. */\n  public int getEndLine() {\n     return bufline[bufpos];\n  }\n\n  /** Get token beginning column number. */\n  public int getBeginColumn() {\n    return bufcolumn[tokenBegin];\n  }\n\n  /** Get token beginning line number. */\n  public int getBeginLine() {\n    return bufline[tokenBegin];\n  }\n\n/** Backup a number of characters. */\n  public void backup(int amount) {\n\n    inBuf += amount;\n    if ((bufpos -= amount) < 0)\n      bufpos += bufsize;\n  }\n\n  /** Constructor. */\n  public SimpleCharStream(java.io.Reader dstream, int startline,\n  int startcolumn, int buffersize)\n  {\n    inputStream = dstream;\n    line = startline;\n    column = startcolumn - 1;\n\n    available = bufsize = buffersize;\n    buffer = new char[buffersize];\n    bufline = new int[buffersize];\n    bufcolumn = new int[buffersize];\n  }\n\n  /** Constructor. */\n  public SimpleCharStream(java.io.Reader dstream, int startline,\n                          int startcolumn)\n  {\n    this(dstream, startline, startcolumn, 4096);\n  }\n\n  /** Constructor. */\n  public SimpleCharStream(java.io.Reader dstream)\n  {\n    this(dstream, 1, 1, 4096);\n  }\n\n  /** Reinitialise. */\n  public void ReInit(java.io.Reader dstream, int startline,\n  int startcolumn, int buffersize)\n  {\n    inputStream = dstream;\n    line = startline;\n    column = startcolumn - 1;\n\n    if (buffer == null || buffersize != buffer.length)\n    {\n      available = bufsize = buffersize;\n      buffer = new char[buffersize];\n      bufline = new int[buffersize];\n      bufcolumn = new int[buffersize];\n    }\n    prevCharIsLF = prevCharIsCR = false;\n    tokenBegin = inBuf = maxNextCharInd = 0;\n    bufpos = -1;\n  }\n\n  /** Reinitialise. */\n  public void ReInit(java.io.Reader dstream, int startline,\n                     int startcolumn)\n  {\n    ReInit(dstream, startline, startcolumn, 4096);\n  }\n\n  /** Reinitialise. */\n  public void ReInit(java.io.Reader dstream)\n  {\n    ReInit(dstream, 1, 1, 4096);\n  }\n  /** Constructor. */\n  public SimpleCharStream(java.io.InputStream dstream, String encoding, int startline,\n  int startcolumn, int buffersize) throws java.io.UnsupportedEncodingException\n  {\n    this(encoding == null ? new java.io.InputStreamReader(dstream) : new java.io.InputStreamReader(dstream, encoding), startline, startcolumn, buffersize);\n  }\n\n  /** Constructor. */\n  public SimpleCharStream(java.io.InputStream dstream, int startline,\n  int startcolumn, int buffersize)\n  {\n    this(new java.io.InputStreamReader(dstream), startline, startcolumn, buffersize);\n  }\n\n  /** Constructor. */\n  public SimpleCharStream(java.io.InputStream dstream, String encoding, int startline,\n                          int startcolumn) throws java.io.UnsupportedEncodingException\n  {\n    this(dstream, encoding, startline, startcolumn, 4096);\n  }\n\n  /** Constructor. */\n  public SimpleCharStream(java.io.InputStream dstream, int startline,\n                          int startcolumn)\n  {\n    this(dstream, startline, startcolumn, 4096);\n  }\n\n  /** Constructor. */\n  public SimpleCharStream(java.io.InputStream dstream, String encoding) throws java.io.UnsupportedEncodingException\n  {\n    this(dstream, encoding, 1, 1, 4096);\n  }\n\n  /** Constructor. */\n  public SimpleCharStream(java.io.InputStream dstream)\n  {\n    this(dstream, 1, 1, 4096);\n  }\n\n  /** Reinitialise. */\n  public void ReInit(java.io.InputStream dstream, String encoding, int startline,\n                          int startcolumn, int buffersize) throws java.io.UnsupportedEncodingException\n  {\n    ReInit(encoding == null ? new java.io.InputStreamReader(dstream) : new java.io.InputStreamReader(dstream, encoding), startline, startcolumn, buffersize);\n  }\n\n  /** Reinitialise. */\n  public void ReInit(java.io.InputStream dstream, int startline,\n                          int startcolumn, int buffersize)\n  {\n    ReInit(new java.io.InputStreamReader(dstream), startline, startcolumn, buffersize);\n  }\n\n  /** Reinitialise. */\n  public void ReInit(java.io.InputStream dstream, String encoding) throws java.io.UnsupportedEncodingException\n  {\n    ReInit(dstream, encoding, 1, 1, 4096);\n  }\n\n  /** Reinitialise. */\n  public void ReInit(java.io.InputStream dstream)\n  {\n    ReInit(dstream, 1, 1, 4096);\n  }\n  /** Reinitialise. */\n  public void ReInit(java.io.InputStream dstream, String encoding, int startline,\n                     int startcolumn) throws java.io.UnsupportedEncodingException\n  {\n    ReInit(dstream, encoding, startline, startcolumn, 4096);\n  }\n  /** Reinitialise. */\n  public void ReInit(java.io.InputStream dstream, int startline,\n                     int startcolumn)\n  {\n    ReInit(dstream, startline, startcolumn, 4096);\n  }\n  /** Get token literal value. */\n  public String GetImage()\n  {\n    if (bufpos >= tokenBegin)\n      return new String(buffer, tokenBegin, bufpos - tokenBegin + 1);\n    else\n      return new String(buffer, tokenBegin, bufsize - tokenBegin) +\n                            new String(buffer, 0, bufpos + 1);\n  }\n\n  /** Get the suffix. */\n  public char[] GetSuffix(int len)\n  {\n    char[] ret = new char[len];\n\n    if ((bufpos + 1) >= len)\n      System.arraycopy(buffer, bufpos - len + 1, ret, 0, len);\n    else\n    {\n      System.arraycopy(buffer, bufsize - (len - bufpos - 1), ret, 0,\n                                                        len - bufpos - 1);\n      System.arraycopy(buffer, 0, ret, len - bufpos - 1, bufpos + 1);\n    }\n\n    return ret;\n  }\n\n  /** Reset buffer when finished. */\n  public void Done()\n  {\n    buffer = null;\n    bufline = null;\n    bufcolumn = null;\n  }\n\n  /**\n   * Method to adjust line and column numbers for the start of a token.\n   */\n  public void adjustBeginLineColumn(int newLine, int newCol)\n  {\n    int start = tokenBegin;\n    int len;\n\n    if (bufpos >= tokenBegin)\n    {\n      len = bufpos - tokenBegin + inBuf + 1;\n    }\n    else\n    {\n      len = bufsize - tokenBegin + bufpos + 1 + inBuf;\n    }\n\n    int i = 0, j = 0, k = 0;\n    int nextColDiff = 0, columnDiff = 0;\n\n    while (i < len && bufline[j = start % bufsize] == bufline[k = ++start % bufsize])\n    {\n      bufline[j] = newLine;\n      nextColDiff = columnDiff + bufcolumn[k] - bufcolumn[j];\n      bufcolumn[j] = newCol + columnDiff;\n      columnDiff = nextColDiff;\n      i++;\n    }\n\n    if (i < len)\n    {\n      bufline[j] = newLine++;\n      bufcolumn[j] = newCol + columnDiff;\n\n      while (i++ < len)\n      {\n        if (bufline[j = start % bufsize] != bufline[++start % bufsize])\n          bufline[j] = newLine++;\n        else\n          bufline[j] = newLine;\n      }\n    }\n\n    line = bufline[j];\n    column = bufcolumn[j];\n  }\n  boolean getTrackLineColumn() { return trackLineColumn; }\n  void setTrackLineColumn(boolean tlc) { trackLineColumn = tlc; }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "public static final boolean staticFlag = false;", "docstring": " Whether parser is static.", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "boolean", "name": "staticFlag = false", "syntax_pass": true}, {"attribute_expression": "int bufsize;", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "int", "name": "bufsize", "syntax_pass": true}, {"attribute_expression": "int available;", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "int", "name": "available", "syntax_pass": true}, {"attribute_expression": "int tokenBegin;", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "int", "name": "tokenBegin", "syntax_pass": true}, {"attribute_expression": "public int bufpos = -1;", "docstring": " Position in buffer.", "modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "type": "int", "name": "bufpos = -1", "syntax_pass": true}, {"attribute_expression": "protected int bufline[];", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "int", "name": "bufline[]", "syntax_pass": true}, {"attribute_expression": "protected int bufcolumn[];", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "int", "name": "bufcolumn[]", "syntax_pass": true}, {"attribute_expression": "protected int column = 0;", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "int", "name": "column = 0", "syntax_pass": true}, {"attribute_expression": "protected int line = 1;", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "int", "name": "line = 1", "syntax_pass": true}, {"attribute_expression": "protected boolean prevCharIsCR = false;", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "boolean", "name": "prevCharIsCR = false", "syntax_pass": true}, {"attribute_expression": "protected boolean prevCharIsLF = false;", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "boolean", "name": "prevCharIsLF = false", "syntax_pass": true}, {"attribute_expression": "protected java.io.Reader inputStream;", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "java.io.Reader", "name": "inputStream", "syntax_pass": true}, {"attribute_expression": "protected char[] buffer;", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "char[]", "name": "buffer", "syntax_pass": true}, {"attribute_expression": "protected int maxNextCharInd = 0;", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "int", "name": "maxNextCharInd = 0", "syntax_pass": true}, {"attribute_expression": "protected int inBuf = 0;", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "int", "name": "inBuf = 0", "syntax_pass": true}, {"attribute_expression": "protected int tabSize = 1;", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "int", "name": "tabSize = 1", "syntax_pass": true}, {"attribute_expression": "protected boolean trackLineColumn = true;", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "boolean", "name": "trackLineColumn = true", "syntax_pass": true}]}]