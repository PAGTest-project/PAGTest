[
    {
        "uris": "src/test/java/org/jsoup/TextUtil.java.TextUtil.[String]stripNewlines(String)",
        "name": "stripNewlines",
        "arg_nums": 1,
        "params": [
            {
                "name": "text",
                "type": "String"
            }
        ],
        "return_type": "String",
        "signature": "public static String stripNewlines(String text)",
        "original_string": "    public static String stripNewlines(String text) {\n        return stripper.matcher(text).replaceAll(\"\");\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/TextUtil.java",
        "class_name": "TextUtil",
        "class_uri": "src/test/java/org/jsoup/TextUtil.java.TextUtil",
        "attributes": {
            "modifiers": "public static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public",
                "static"
            ],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/TextUtil.java.TextUtil.[String]normalizeSpaces(String)",
        "name": "normalizeSpaces",
        "arg_nums": 1,
        "params": [
            {
                "name": "text",
                "type": "String"
            }
        ],
        "return_type": "String",
        "signature": "public static String normalizeSpaces(String text)",
        "original_string": "    public static String normalizeSpaces(String text) {\n        text = stripLines.matcher(text).replaceAll(\"\");\n        text = stripper.matcher(text).replaceAll(\"\");\n        text = spaceCollapse.matcher(text).replaceAll(\" \");\n        text = tagSpaceCollapse.matcher(text).replaceAll(\"><\");\n        return text;\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/TextUtil.java",
        "class_name": "TextUtil",
        "class_uri": "src/test/java/org/jsoup/TextUtil.java.TextUtil",
        "attributes": {
            "modifiers": "public static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public",
                "static"
            ],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/TextUtil.java.TextUtil.[String]stripCRs(String)",
        "name": "stripCRs",
        "arg_nums": 1,
        "params": [
            {
                "name": "text",
                "type": "String"
            }
        ],
        "return_type": "String",
        "signature": "public static String stripCRs(String text)",
        "original_string": "    public static String stripCRs(String text) {\n        return stripCRs.matcher(text).replaceAll(\"\");\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/TextUtil.java",
        "class_name": "TextUtil",
        "class_uri": "src/test/java/org/jsoup/TextUtil.java.TextUtil",
        "attributes": {
            "modifiers": "public static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public",
                "static"
            ],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/MultiLocaleExtension.java.MultiLocaleExtension.[void]afterEach(ExtensionContext)",
        "name": "afterEach",
        "arg_nums": 1,
        "params": [
            {
                "name": "context",
                "type": "ExtensionContext"
            }
        ],
        "return_type": "void",
        "signature": "@Override\n    public void afterEach(ExtensionContext context)",
        "original_string": "    @Override\n    public void afterEach(ExtensionContext context) {\n        Locale.setDefault(defaultLocale);\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/MultiLocaleExtension.java",
        "class_name": "MultiLocaleExtension",
        "class_uri": "src/test/java/org/jsoup/MultiLocaleExtension.java.MultiLocaleExtension",
        "attributes": {
            "modifiers": "@Override\n    public",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/MultiLocaleExtension.java.MultiLocaleExtension.[Stream<? extends Arguments>]provideArguments(ExtensionContext)",
        "name": "provideArguments",
        "arg_nums": 1,
        "params": [
            {
                "name": "extensionContext",
                "type": "ExtensionContext"
            }
        ],
        "return_type": "Stream<? extends Arguments>",
        "signature": "@Override\n    public Stream<? extends Arguments> provideArguments(ExtensionContext extensionContext)",
        "original_string": "    @Override\n    public Stream<? extends Arguments> provideArguments(ExtensionContext extensionContext) {\n        return Stream.of(Arguments.of(Locale.ENGLISH), Arguments.arguments(new Locale(\"tr\")));\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/MultiLocaleExtension.java",
        "class_name": "MultiLocaleExtension",
        "class_uri": "src/test/java/org/jsoup/MultiLocaleExtension.java.MultiLocaleExtension",
        "attributes": {
            "modifiers": "@Override\n    public",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Stream<? extends Arguments>",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/helper/DataUtilTest.java.DataUtilTest.[ControllableInputStream]stream(String)",
        "name": "stream",
        "arg_nums": 1,
        "params": [
            {
                "name": "data",
                "type": "String"
            }
        ],
        "return_type": "ControllableInputStream",
        "signature": "private ControllableInputStream stream(String data)",
        "original_string": "    private ControllableInputStream stream(String data) {\n        return ControllableInputStream.wrap(new ByteArrayInputStream(data.getBytes(StandardCharsets.UTF_8)), 0);\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/helper/DataUtilTest.java",
        "class_name": "DataUtilTest",
        "class_uri": "src/test/java/org/jsoup/helper/DataUtilTest.java.DataUtilTest",
        "attributes": {
            "modifiers": "private",
            "marker_annotations": [],
            "non_marker_annotations": [
                "private"
            ],
            "comments": [],
            "return_type": "ControllableInputStream",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/helper/DataUtilTest.java.DataUtilTest.[ControllableInputStream]stream(String,String)",
        "name": "stream",
        "arg_nums": 2,
        "params": [
            {
                "name": "data",
                "type": "String"
            },
            {
                "name": "charset",
                "type": "String"
            }
        ],
        "return_type": "ControllableInputStream",
        "signature": "private ControllableInputStream stream(String data, String charset)",
        "original_string": "    private ControllableInputStream stream(String data, String charset) {\n        return ControllableInputStream.wrap(new ByteArrayInputStream(data.getBytes(Charset.forName(charset))), 0);\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/helper/DataUtilTest.java",
        "class_name": "DataUtilTest",
        "class_uri": "src/test/java/org/jsoup/helper/DataUtilTest.java.DataUtilTest",
        "attributes": {
            "modifiers": "private",
            "marker_annotations": [],
            "non_marker_annotations": [
                "private"
            ],
            "comments": [],
            "return_type": "ControllableInputStream",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/helper/HttpConnectionTest.java.HttpConnectionTest.[void]caseInsensitiveHeaders(Locale)",
        "name": "caseInsensitiveHeaders",
        "arg_nums": 1,
        "params": [
            {
                "name": "locale",
                "type": "Locale"
            }
        ],
        "return_type": "void",
        "signature": "@MultiLocaleTest\n    public void caseInsensitiveHeaders(Locale locale)",
        "original_string": "    @MultiLocaleTest\n    public void caseInsensitiveHeaders(Locale locale) {\n        Locale.setDefault(locale);\n\n        Connection.Response res = new HttpConnection.Response();\n        res.header(\"Accept-Encoding\", \"gzip\");\n        res.header(\"content-type\", \"text/html\");\n        res.header(\"refErrer\", \"http://example.com\");\n\n        assertTrue(res.hasHeader(\"Accept-Encoding\"));\n        assertTrue(res.hasHeader(\"accept-encoding\"));\n        assertTrue(res.hasHeader(\"accept-Encoding\"));\n        assertTrue(res.hasHeader(\"ACCEPT-ENCODING\"));\n\n        assertEquals(\"gzip\", res.header(\"accept-Encoding\"));\n        assertEquals(\"gzip\", res.header(\"ACCEPT-ENCODING\"));\n        assertEquals(\"text/html\", res.header(\"Content-Type\"));\n        assertEquals(\"http://example.com\", res.header(\"Referrer\"));\n\n        res.removeHeader(\"Content-Type\");\n        assertFalse(res.hasHeader(\"content-type\"));\n\n        res.removeHeader(\"ACCEPT-ENCODING\");\n        assertFalse(res.hasHeader(\"Accept-Encoding\"));\n\n        res.header(\"ACCEPT-ENCODING\", \"deflate\");\n        assertEquals(\"deflate\", res.header(\"Accept-Encoding\"));\n        assertEquals(\"deflate\", res.header(\"accept-Encoding\"));\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/helper/HttpConnectionTest.java",
        "class_name": "HttpConnectionTest",
        "class_uri": "src/test/java/org/jsoup/helper/HttpConnectionTest.java.HttpConnectionTest",
        "attributes": {
            "modifiers": "@MultiLocaleTest\n    public",
            "marker_annotations": [
                "@MultiLocaleTest"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/helper/W3CDom_fromJsoupTest.java.W3CDom_fromJsoupTest.[void]setUp()",
        "name": "setUp",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "@BeforeEach\n    public void setUp()",
        "original_string": "    @BeforeEach\n    public void setUp() {\n        w3cDom = new W3CDom();\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/helper/W3CDom_fromJsoupTest.java",
        "class_name": "W3CDom_fromJsoupTest",
        "class_uri": "src/test/java/org/jsoup/helper/W3CDom_fromJsoupTest.java.W3CDom_fromJsoupTest",
        "attributes": {
            "modifiers": "@BeforeEach\n    public",
            "marker_annotations": [
                "@BeforeEach"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/helper/W3CDomTest.java.W3CDomTest.[Document]parseXml(String,boolean)",
        "name": "parseXml",
        "arg_nums": 2,
        "params": [
            {
                "name": "xml",
                "type": "String"
            },
            {
                "name": "nameSpaceAware",
                "type": "boolean"
            }
        ],
        "return_type": "Document",
        "signature": "private static Document parseXml(String xml, boolean nameSpaceAware)",
        "original_string": "    private static Document parseXml(String xml, boolean nameSpaceAware) {\n        try {\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            factory.setNamespaceAware(nameSpaceAware);\n            DocumentBuilder builder = factory.newDocumentBuilder();\n            builder.setEntityResolver((publicId, systemId) -> {\n                if (systemId.contains(\"about:legacy-compat\")) { // <!doctype html>\n                    return new InputSource(new StringReader(\"\"));\n                } else {\n                    return null;\n                }\n            });\n            Document dom = builder.parse(new ByteArrayInputStream(xml.getBytes(StandardCharsets.UTF_8)));\n            dom.normalizeDocument();\n            return dom;\n        } catch (Exception e) {\n            throw new IllegalStateException(e);\n        }\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/helper/W3CDomTest.java",
        "class_name": "W3CDomTest",
        "class_uri": "src/test/java/org/jsoup/helper/W3CDomTest.java.W3CDomTest",
        "attributes": {
            "modifiers": "private static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "private",
                "static"
            ],
            "comments": [],
            "return_type": "Document",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/helper/W3CDomTest.java.W3CDomTest.[NodeList]xpath(Document,String)",
        "name": "xpath",
        "arg_nums": 2,
        "params": [
            {
                "name": "w3cDoc",
                "type": "Document"
            },
            {
                "name": "query",
                "type": "String"
            }
        ],
        "return_type": "NodeList",
        "signature": "private NodeList xpath(Document w3cDoc, String query)",
        "original_string": "    private NodeList xpath(Document w3cDoc, String query) throws XPathExpressionException {\n        XPathExpression xpath = XPathFactory.newInstance().newXPath().compile(query);\n        return ((NodeList) xpath.evaluate(w3cDoc, XPathConstants.NODE));\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/helper/W3CDomTest.java",
        "class_name": "W3CDomTest",
        "class_uri": "src/test/java/org/jsoup/helper/W3CDomTest.java.W3CDomTest",
        "attributes": {
            "modifiers": "private",
            "marker_annotations": [],
            "non_marker_annotations": [
                "private"
            ],
            "comments": [],
            "return_type": "NodeList",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/helper/W3CDomTest.java.W3CDomTest.[String]output(String,boolean)",
        "name": "output",
        "arg_nums": 2,
        "params": [
            {
                "name": "in",
                "type": "String"
            },
            {
                "name": "modeHtml",
                "type": "boolean"
            }
        ],
        "return_type": "String",
        "signature": "private String output(String in, boolean modeHtml)",
        "original_string": "    private String output(String in, boolean modeHtml) {\n        org.jsoup.nodes.Document jdoc = Jsoup.parse(in);\n        Document w3c = W3CDom.convert(jdoc);\n\n        Map<String, String> properties = modeHtml ? W3CDom.OutputHtml() : W3CDom.OutputXml();\n        return TextUtil.normalizeSpaces(W3CDom.asString(w3c, properties));\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/helper/W3CDomTest.java",
        "class_name": "W3CDomTest",
        "class_uri": "src/test/java/org/jsoup/helper/W3CDomTest.java.W3CDomTest",
        "attributes": {
            "modifiers": "private",
            "marker_annotations": [],
            "non_marker_annotations": [
                "private"
            ],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/helper/W3CDomTest.java.W3CDomTest.[void]assertEqualsIgnoreCase(String,String)",
        "name": "assertEqualsIgnoreCase",
        "arg_nums": 2,
        "params": [
            {
                "name": "want",
                "type": "String"
            },
            {
                "name": "have",
                "type": "String"
            }
        ],
        "return_type": "void",
        "signature": "private void assertEqualsIgnoreCase(String want, String have)",
        "original_string": "    private void assertEqualsIgnoreCase(String want, String have) {\n        assertEquals(want.toLowerCase(Locale.ROOT), have.toLowerCase(Locale.ROOT));\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/helper/W3CDomTest.java",
        "class_name": "W3CDomTest",
        "class_uri": "src/test/java/org/jsoup/helper/W3CDomTest.java.W3CDomTest",
        "attributes": {
            "modifiers": "private",
            "marker_annotations": [],
            "non_marker_annotations": [
                "private"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/helper/W3CDom_convertTest.java.W3CDom_convertTest.[void]setUp()",
        "name": "setUp",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "@BeforeEach\n    public void setUp()",
        "original_string": "    @BeforeEach\n    public void setUp() {\n        w3cDom = new W3CDom();\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/helper/W3CDom_convertTest.java",
        "class_name": "W3CDom_convertTest",
        "class_uri": "src/test/java/org/jsoup/helper/W3CDom_convertTest.java.W3CDom_convertTest",
        "attributes": {
            "modifiers": "@BeforeEach\n    public",
            "marker_annotations": [
                "@BeforeEach"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/select/Elements_emptyTest.java.Elements_emptyTest.[void]setUp()",
        "name": "setUp",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "@BeforeEach\n    public void setUp()",
        "original_string": "    @BeforeEach\n    public void setUp() {\n        Document doc = Jsoup.parse(\"<div><p>Text1</p><p>Text2</p></div>\");\n        elements = new Elements(doc.select(\"p\"));\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/select/Elements_emptyTest.java",
        "class_name": "Elements_emptyTest",
        "class_uri": "src/test/java/org/jsoup/select/Elements_emptyTest.java.Elements_emptyTest",
        "attributes": {
            "modifiers": "@BeforeEach\n    public",
            "marker_annotations": [
                "@BeforeEach"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/select/Elements_beforeTest.java.Elements_beforeTest.[void]setUp()",
        "name": "setUp",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "@BeforeEach\n    public void setUp()",
        "original_string": "    @BeforeEach\n    public void setUp() {\n        Document doc = Jsoup.parse(\"<div><p>First</p><p>Second</p></div>\");\n        elements = new Elements(doc.select(\"p\"));\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/select/Elements_beforeTest.java",
        "class_name": "Elements_beforeTest",
        "class_uri": "src/test/java/org/jsoup/select/Elements_beforeTest.java.Elements_beforeTest",
        "attributes": {
            "modifiers": "@BeforeEach\n    public",
            "marker_annotations": [
                "@BeforeEach"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/select/Elements_hasAttrTest.java.Elements_hasAttrTest.[void]setUp()",
        "name": "setUp",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "@BeforeEach\n    public void setUp()",
        "original_string": "    @BeforeEach\n    public void setUp() {\n        Document doc = Jsoup.parse(\"<p><a href='/foo'>Foo</a><a href='/bar'>Bar</a><a>None</a></p>\");\n        elements = new Elements(doc.select(\"a\"));\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/select/Elements_hasAttrTest.java",
        "class_name": "Elements_hasAttrTest",
        "class_uri": "src/test/java/org/jsoup/select/Elements_hasAttrTest.java.Elements_hasAttrTest",
        "attributes": {
            "modifiers": "@BeforeEach\n    public",
            "marker_annotations": [
                "@BeforeEach"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/select/XpathTest.java.XpathTest.[Stream<Arguments>]provideEvaluators()",
        "name": "provideEvaluators",
        "arg_nums": 0,
        "params": [],
        "return_type": "Stream<Arguments>",
        "signature": "private static Stream<Arguments> provideEvaluators()",
        "original_string": "    private static Stream<Arguments> provideEvaluators() {\n        String html = \"<div id=1><div id=2><p class=foo>Hello</p></div></div><DIV id=3>\";\n        Document doc = Jsoup.parse(html);\n\n        return Stream.of(\n           Arguments.of(doc, \"DIV\", \"//div\"),\n           Arguments.of(doc, \"div > p.foo\", \"//div/p[@class]\"),\n           Arguments.of(doc, \"div + div\", \"//div/following-sibling::div[1]\"),\n           Arguments.of(doc, \"p:containsOwn(Hello)\", \"//p[contains(text(),\\\"Hello\\\")]\")\n        );\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/select/XpathTest.java",
        "class_name": "XpathTest",
        "class_uri": "src/test/java/org/jsoup/select/XpathTest.java.XpathTest",
        "attributes": {
            "modifiers": "private static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "private",
                "static"
            ],
            "comments": [],
            "return_type": "Stream<Arguments>",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/select/Elements_htmlTest.java.Elements_htmlTest.[void]setUp()",
        "name": "setUp",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "@BeforeEach\n    public void setUp()",
        "original_string": "    @BeforeEach\n    public void setUp() {\n        Document doc = Jsoup.parse(\"<div><p>First</p><p>Second</p></div>\");\n        elements = new Elements(doc.select(\"p\"));\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/select/Elements_htmlTest.java",
        "class_name": "Elements_htmlTest",
        "class_uri": "src/test/java/org/jsoup/select/Elements_htmlTest.java.Elements_htmlTest",
        "attributes": {
            "modifiers": "@BeforeEach\n    public",
            "marker_annotations": [
                "@BeforeEach"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/select/Elements_removeClassTest.java.Elements_removeClassTest.[void]setUp()",
        "name": "setUp",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "@BeforeEach\n    public void setUp()",
        "original_string": "    @BeforeEach\n    public void setUp() {\n        Document doc = Jsoup.parse(\"<div class='test'>Test</div><div>NoClass</div>\");\n        elements = doc.select(\"div\");\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/select/Elements_removeClassTest.java",
        "class_name": "Elements_removeClassTest",
        "class_uri": "src/test/java/org/jsoup/select/Elements_removeClassTest.java.Elements_removeClassTest",
        "attributes": {
            "modifiers": "@BeforeEach\n    public",
            "marker_annotations": [
                "@BeforeEach"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/select/Elements_notTest.java.Elements_notTest.[void]setUp()",
        "name": "setUp",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "@BeforeEach\n    public void setUp()",
        "original_string": "    @BeforeEach\n    public void setUp() {\n        Document doc = Jsoup.parse(\"<div class='test'><p class='exclude'>Exclude</p><p>Include</p></div>\");\n        elements = new Elements(doc.select(\"div.test p\"));\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/select/Elements_notTest.java",
        "class_name": "Elements_notTest",
        "class_uri": "src/test/java/org/jsoup/select/Elements_notTest.java.Elements_notTest",
        "attributes": {
            "modifiers": "@BeforeEach\n    public",
            "marker_annotations": [
                "@BeforeEach"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/select/NodeTraversor_traverseTest.java.NodeTraversor_traverseTest.[void]setUp()",
        "name": "setUp",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "@BeforeEach\n    public void setUp()",
        "original_string": "    @BeforeEach\n    public void setUp() {\n        doc = Jsoup.parse(\"<div><p>Hello</p><p>World</p></div>\");\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/select/NodeTraversor_traverseTest.java",
        "class_name": "NodeTraversor_traverseTest",
        "class_uri": "src/test/java/org/jsoup/select/NodeTraversor_traverseTest.java.NodeTraversor_traverseTest",
        "attributes": {
            "modifiers": "@BeforeEach\n    public",
            "marker_annotations": [
                "@BeforeEach"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/select/Elements_appendTest.java.Elements_appendTest.[void]setUp()",
        "name": "setUp",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "@BeforeEach\n    public void setUp()",
        "original_string": "    @BeforeEach\n    public void setUp() {\n        Document doc = Jsoup.parse(\"<div><p>First</p><p>Second</p></div>\");\n        elements = doc.select(\"p\");\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/select/Elements_appendTest.java",
        "class_name": "Elements_appendTest",
        "class_uri": "src/test/java/org/jsoup/select/Elements_appendTest.java.Elements_appendTest",
        "attributes": {
            "modifiers": "@BeforeEach\n    public",
            "marker_annotations": [
                "@BeforeEach"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/select/Elements_valTest.java.Elements_valTest.[void]setUp()",
        "name": "setUp",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "@BeforeEach\n    public void setUp()",
        "original_string": "    @BeforeEach\n    public void setUp() {\n        elements = new Elements();\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/select/Elements_valTest.java",
        "class_name": "Elements_valTest",
        "class_uri": "src/test/java/org/jsoup/select/Elements_valTest.java.Elements_valTest",
        "attributes": {
            "modifiers": "@BeforeEach\n    public",
            "marker_annotations": [
                "@BeforeEach"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/select/Elements_traverseTest.java.Elements_traverseTest.[void]setUp()",
        "name": "setUp",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "@BeforeEach\n    public void setUp()",
        "original_string": "    @BeforeEach\n    public void setUp() {\n        Document doc = Jsoup.parse(\"<div><p>One</p><p>Two</p></div>\");\n        elements = new Elements(doc.select(\"p\"));\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/select/Elements_traverseTest.java",
        "class_name": "Elements_traverseTest",
        "class_uri": "src/test/java/org/jsoup/select/Elements_traverseTest.java.Elements_traverseTest",
        "attributes": {
            "modifiers": "@BeforeEach\n    public",
            "marker_annotations": [
                "@BeforeEach"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/select/Elements_hasTextTest.java.Elements_hasTextTest.[void]setUp()",
        "name": "setUp",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "@BeforeEach\n    public void setUp()",
        "original_string": "    @BeforeEach\n    public void setUp() {\n        elements = new Elements();\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/select/Elements_hasTextTest.java",
        "class_name": "Elements_hasTextTest",
        "class_uri": "src/test/java/org/jsoup/select/Elements_hasTextTest.java.Elements_hasTextTest",
        "attributes": {
            "modifiers": "@BeforeEach\n    public",
            "marker_annotations": [
                "@BeforeEach"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/select/Elements_eachTextTest.java.Elements_eachTextTest.[void]setUp()",
        "name": "setUp",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "@BeforeEach\n    public void setUp()",
        "original_string": "    @BeforeEach\n    public void setUp() {\n        Document doc = Jsoup.parse(\"<div><p>Text1</p><p></p><p>Text2</p></div>\");\n        elements = new Elements(doc.select(\"p\"));\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/select/Elements_eachTextTest.java",
        "class_name": "Elements_eachTextTest",
        "class_uri": "src/test/java/org/jsoup/select/Elements_eachTextTest.java.Elements_eachTextTest",
        "attributes": {
            "modifiers": "@BeforeEach\n    public",
            "marker_annotations": [
                "@BeforeEach"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/select/SelectorTest.java.SelectorTest.[void]assertSelectedIds(Elements)",
        "name": "assertSelectedIds",
        "arg_nums": 1,
        "params": [
            {
                "name": "els",
                "type": "Elements"
            }
        ],
        "return_type": "void",
        "signature": "public static void assertSelectedIds(Elements els, String... ids)",
        "original_string": "    public static void assertSelectedIds(Elements els, String... ids) {\n        assertNotNull(els);\n        assertEquals(ids.length, els.size(), \"Incorrect number of selected elements\");\n        for (int i = 0; i < ids.length; i++) {\n            assertEquals(ids[i], els.get(i).id(), \"Incorrect content at index\");\n        }\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/select/SelectorTest.java",
        "class_name": "SelectorTest",
        "class_uri": "src/test/java/org/jsoup/select/SelectorTest.java.SelectorTest",
        "attributes": {
            "modifiers": "public static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public",
                "static"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": " Test that the selected elements match exactly the specified IDs."
    },
    {
        "uris": "src/test/java/org/jsoup/select/SelectorTest.java.SelectorTest.[void]assertSelectedOwnText(Elements)",
        "name": "assertSelectedOwnText",
        "arg_nums": 1,
        "params": [
            {
                "name": "els",
                "type": "Elements"
            }
        ],
        "return_type": "void",
        "signature": "public static void assertSelectedOwnText(Elements els, String... ownTexts)",
        "original_string": "    public static void assertSelectedOwnText(Elements els, String... ownTexts) {\n        assertNotNull(els);\n        assertEquals(ownTexts.length, els.size(), \"Incorrect number of selected elements\");\n        for (int i = 0; i < ownTexts.length; i++) {\n            assertEquals(ownTexts[i], els.get(i).ownText(), \"Incorrect content at index\");\n        }\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/select/SelectorTest.java",
        "class_name": "SelectorTest",
        "class_uri": "src/test/java/org/jsoup/select/SelectorTest.java.SelectorTest",
        "attributes": {
            "modifiers": "public static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public",
                "static"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/select/SelectorTest.java.SelectorTest.[void]testByAttribute(Locale)",
        "name": "testByAttribute",
        "arg_nums": 1,
        "params": [
            {
                "name": "locale",
                "type": "Locale"
            }
        ],
        "return_type": "void",
        "signature": "@MultiLocaleTest\n    public void testByAttribute(Locale locale)",
        "original_string": "    @MultiLocaleTest\n    public void testByAttribute(Locale locale) {\n        Locale.setDefault(locale);\n\n        String h = \"<div Title=Foo /><div Title=Bar /><div Style=Qux /><div title=Balim /><div title=SLIM />\" +\n                \"<div data-name='with spaces'/>\";\n        Document doc = Jsoup.parse(h);\n\n        Elements withTitle = doc.select(\"[title]\");\n        assertEquals(4, withTitle.size());\n\n        Elements foo = doc.select(\"[TITLE=foo]\");\n        assertEquals(1, foo.size());\n\n        Elements foo2 = doc.select(\"[title=\\\"foo\\\"]\");\n        assertEquals(1, foo2.size());\n\n        Elements foo3 = doc.select(\"[title=\\\"Foo\\\"]\");\n        assertEquals(1, foo3.size());\n\n        Elements dataName = doc.select(\"[data-name=\\\"with spaces\\\"]\");\n        assertEquals(1, dataName.size());\n        assertEquals(\"with spaces\", dataName.first().attr(\"data-name\"));\n\n        Elements not = doc.select(\"div[title!=bar]\");\n        assertEquals(5, not.size());\n        assertEquals(\"Foo\", not.first().attr(\"title\"));\n\n        Elements starts = doc.select(\"[title^=ba]\");\n        assertEquals(2, starts.size());\n        assertEquals(\"Bar\", starts.first().attr(\"title\"));\n        assertEquals(\"Balim\", starts.last().attr(\"title\"));\n\n        Elements ends = doc.select(\"[title$=im]\");\n        assertEquals(2, ends.size());\n        assertEquals(\"Balim\", ends.first().attr(\"title\"));\n        assertEquals(\"SLIM\", ends.last().attr(\"title\"));\n\n        Elements contains = doc.select(\"[title*=i]\");\n        assertEquals(2, contains.size());\n        assertEquals(\"Balim\", contains.first().attr(\"title\"));\n        assertEquals(\"SLIM\", contains.last().attr(\"title\"));\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/select/SelectorTest.java",
        "class_name": "SelectorTest",
        "class_uri": "src/test/java/org/jsoup/select/SelectorTest.java.SelectorTest",
        "attributes": {
            "modifiers": "@MultiLocaleTest\n    public",
            "marker_annotations": [
                "@MultiLocaleTest"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/select/SelectorTest.java.SelectorTest.[void]testByAttributeStarting(Locale)",
        "name": "testByAttributeStarting",
        "arg_nums": 1,
        "params": [
            {
                "name": "locale",
                "type": "Locale"
            }
        ],
        "return_type": "void",
        "signature": "@MultiLocaleTest\n    public void testByAttributeStarting(Locale locale)",
        "original_string": "    @MultiLocaleTest\n    public void testByAttributeStarting(Locale locale) {\n        Locale.setDefault(locale);\n\n        Document doc = Jsoup.parse(\"<div id=1 ATTRIBUTE data-name=jsoup>Hello</div><p data-val=5 id=2>There</p><p id=3>No</p>\");\n        Elements withData = doc.select(\"[^data-]\");\n        assertEquals(2, withData.size());\n        assertEquals(\"1\", withData.first().id());\n        assertEquals(\"2\", withData.last().id());\n\n        withData = doc.select(\"p[^data-]\");\n        assertEquals(1, withData.size());\n        assertEquals(\"2\", withData.first().id());\n\n        assertEquals(1, doc.select(\"[^attrib]\").size());\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/select/SelectorTest.java",
        "class_name": "SelectorTest",
        "class_uri": "src/test/java/org/jsoup/select/SelectorTest.java.SelectorTest",
        "attributes": {
            "modifiers": "@MultiLocaleTest\n    public",
            "marker_annotations": [
                "@MultiLocaleTest"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/select/SelectorTest.java.SelectorTest.[void]testPseudoContains(Locale)",
        "name": "testPseudoContains",
        "arg_nums": 1,
        "params": [
            {
                "name": "locale",
                "type": "Locale"
            }
        ],
        "return_type": "void",
        "signature": "@MultiLocaleTest\n    public void testPseudoContains(Locale locale)",
        "original_string": "    @MultiLocaleTest\n    public void testPseudoContains(Locale locale) {\n        Locale.setDefault(locale);\n\n        Document doc = Jsoup.parse(\"<div><p>The Rain.</p> <p class=light>The <i>RAIN</i>.</p> <p>Rain, the.</p></div>\");\n\n        Elements ps1 = doc.select(\"p:contains(Rain)\");\n        assertEquals(3, ps1.size());\n\n        Elements ps2 = doc.select(\"p:contains(the rain)\");\n        assertEquals(2, ps2.size());\n        assertEquals(\"The Rain.\", ps2.first().html());\n        assertEquals(\"The <i>RAIN</i>.\", ps2.last().html());\n\n        Elements ps3 = doc.select(\"p:contains(the Rain):has(i)\");\n        assertEquals(1, ps3.size());\n        assertEquals(\"light\", ps3.first().className());\n\n        Elements ps4 = doc.select(\".light:contains(rain)\");\n        assertEquals(1, ps4.size());\n        assertEquals(\"light\", ps3.first().className());\n\n        Elements ps5 = doc.select(\":contains(rain)\");\n        assertEquals(8, ps5.size()); // html, body, div,...\n\n        Elements ps6 = doc.select(\":contains(RAIN)\");\n        assertEquals(8, ps6.size());\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/select/SelectorTest.java",
        "class_name": "SelectorTest",
        "class_uri": "src/test/java/org/jsoup/select/SelectorTest.java.SelectorTest",
        "attributes": {
            "modifiers": "@MultiLocaleTest\n    public",
            "marker_annotations": [
                "@MultiLocaleTest"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/select/SelectorTest.java.SelectorTest.[void]containsOwn(Locale)",
        "name": "containsOwn",
        "arg_nums": 1,
        "params": [
            {
                "name": "locale",
                "type": "Locale"
            }
        ],
        "return_type": "void",
        "signature": "@MultiLocaleTest\n    public void containsOwn(Locale locale)",
        "original_string": "    @MultiLocaleTest\n    public void containsOwn(Locale locale) {\n        Locale.setDefault(locale);\n\n        Document doc = Jsoup.parse(\"<p id=1>Hello <b>there</b> igor</p>\");\n        Elements ps = doc.select(\"p:containsOwn(Hello IGOR)\");\n        assertEquals(1, ps.size());\n        assertEquals(\"1\", ps.first().id());\n\n        assertEquals(0, doc.select(\"p:containsOwn(there)\").size());\n\n        Document doc2 = Jsoup.parse(\"<p>Hello <b>there</b> IGOR</p>\");\n        assertEquals(1, doc2.select(\"p:containsOwn(igor)\").size());\n\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/select/SelectorTest.java",
        "class_name": "SelectorTest",
        "class_uri": "src/test/java/org/jsoup/select/SelectorTest.java.SelectorTest",
        "attributes": {
            "modifiers": "@MultiLocaleTest\n    public",
            "marker_annotations": [
                "@MultiLocaleTest"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/select/SelectorTest.java.SelectorTest.[void]containsData(Locale)",
        "name": "containsData",
        "arg_nums": 1,
        "params": [
            {
                "name": "locale",
                "type": "Locale"
            }
        ],
        "return_type": "void",
        "signature": "@MultiLocaleTest\n    public void containsData(Locale locale)",
        "original_string": "    @MultiLocaleTest\n    public void containsData(Locale locale) {\n        Locale.setDefault(locale);\n\n        String html = \"<p>function</p><script>FUNCTION</script><style>item</style><span><!-- comments --></span>\";\n        Document doc = Jsoup.parse(html);\n        Element body = doc.body();\n\n        Elements dataEls1 = body.select(\":containsData(function)\");\n        Elements dataEls2 = body.select(\"script:containsData(function)\");\n        Elements dataEls3 = body.select(\"span:containsData(comments)\");\n        Elements dataEls4 = body.select(\":containsData(o)\");\n        Elements dataEls5 = body.select(\"style:containsData(ITEM)\");\n\n        assertEquals(2, dataEls1.size()); // body and script\n        assertEquals(1, dataEls2.size());\n        assertEquals(dataEls1.last(), dataEls2.first());\n        assertEquals(\"<script>FUNCTION</script>\", dataEls2.outerHtml());\n        assertEquals(1, dataEls3.size());\n        assertEquals(\"span\", dataEls3.first().tagName());\n        assertEquals(3, dataEls4.size());\n        assertEquals(\"body\", dataEls4.first().tagName());\n        assertEquals(\"script\", dataEls4.get(1).tagName());\n        assertEquals(\"span\", dataEls4.get(2).tagName());\n        assertEquals(1, dataEls5.size());\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/select/SelectorTest.java",
        "class_name": "SelectorTest",
        "class_uri": "src/test/java/org/jsoup/select/SelectorTest.java.SelectorTest",
        "attributes": {
            "modifiers": "@MultiLocaleTest\n    public",
            "marker_annotations": [
                "@MultiLocaleTest"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/select/Elements_tagNameTest.java.Elements_tagNameTest.[void]setUp()",
        "name": "setUp",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "@BeforeEach\n    public void setUp()",
        "original_string": "    @BeforeEach\n    public void setUp() {\n        Document doc = Jsoup.parse(\"<div><p>One</p><p>Two</p></div>\");\n        elements = new Elements(doc.select(\"p\"));\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/select/Elements_tagNameTest.java",
        "class_name": "Elements_tagNameTest",
        "class_uri": "src/test/java/org/jsoup/select/Elements_tagNameTest.java.Elements_tagNameTest",
        "attributes": {
            "modifiers": "@BeforeEach\n    public",
            "marker_annotations": [
                "@BeforeEach"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/select/Elements_formsTest.java.Elements_formsTest.[void]setUp()",
        "name": "setUp",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "@BeforeEach\n    public void setUp()",
        "original_string": "    @BeforeEach\n    public void setUp() {\n        elements = new Elements();\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/select/Elements_formsTest.java",
        "class_name": "Elements_formsTest",
        "class_uri": "src/test/java/org/jsoup/select/Elements_formsTest.java.Elements_formsTest",
        "attributes": {
            "modifiers": "@BeforeEach\n    public",
            "marker_annotations": [
                "@BeforeEach"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/select/CssTest.java.CssTest.[void]initClass()",
        "name": "initClass",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "@BeforeAll\n\tpublic static void initClass()",
        "original_string": " @BeforeAll\n\tpublic static void initClass() {\n\t\tStringBuilder sb = new StringBuilder(\"<html><head></head><body>\");\n\n\t\tsb.append(\"<div id='pseudo'>\");\n\t\tfor (int i = 1; i <= 10; i++) {\n\t\t\tsb.append(String.format(\"<p>%d</p>\",i));\n\t\t}\n\t\tsb.append(\"</div>\");\n\n\t\tsb.append(\"<div id='type'>\");\n\t\tfor (int i = 1; i <= 10; i++) {\n\t\t\tsb.append(String.format(\"<p>%d</p>\",i));\n\t\t\tsb.append(String.format(\"<span>%d</span>\",i));\n\t\t\tsb.append(String.format(\"<em>%d</em>\",i));\n            sb.append(String.format(\"<svg>%d</svg>\",i));\n\t\t}\n\t\tsb.append(\"</div>\");\n\n\t\tsb.append(\"<span id='onlySpan'><br /></span>\");\n\t\tsb.append(\"<p class='empty'><!-- Comment only is still empty! --></p>\");\n\n\t\tsb.append(\"<div id='only'>\");\n\t\tsb.append(\"Some text before the <em>only</em> child in this div\");\n\t\tsb.append(\"</div>\");\n\n\t\tsb.append(\"</body></html>\");\n\t\thtmlString = sb.toString();\n\t}",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/select/CssTest.java",
        "class_name": "CssTest",
        "class_uri": "src/test/java/org/jsoup/select/CssTest.java.CssTest",
        "attributes": {
            "modifiers": "@BeforeAll\n\tpublic static",
            "marker_annotations": [
                "@BeforeAll"
            ],
            "non_marker_annotations": [
                "public",
                "static"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/select/CssTest.java.CssTest.[void]init()",
        "name": "init",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "@BeforeEach\n\tpublic void init()",
        "original_string": " @BeforeEach\n\tpublic void init() {\n\t\thtml  = Jsoup.parse(htmlString);\n\t}",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/select/CssTest.java",
        "class_name": "CssTest",
        "class_uri": "src/test/java/org/jsoup/select/CssTest.java.CssTest",
        "attributes": {
            "modifiers": "@BeforeEach\n\tpublic",
            "marker_annotations": [
                "@BeforeEach"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/select/CssTest.java.CssTest.[void]check(Elements)",
        "name": "check",
        "arg_nums": 1,
        "params": [
            {
                "name": "result",
                "type": "Elements"
            }
        ],
        "return_type": "void",
        "signature": "protected void check(Elements result, String...expectedContent )",
        "original_string": " protected void check(Elements result, String...expectedContent ) {\n\t\tassertEquals(expectedContent.length, result.size(), \"Number of elements\");\n\t\tfor (int i = 0; i < expectedContent.length; i++) {\n\t\t\tassertNotNull(result.get(i));\n\t\t\tassertEquals(expectedContent[i], result.get(i).ownText(), \"Expected element\");\n\t\t}\n\t}",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/select/CssTest.java",
        "class_name": "CssTest",
        "class_uri": "src/test/java/org/jsoup/select/CssTest.java.CssTest",
        "attributes": {
            "modifiers": "protected",
            "marker_annotations": [],
            "non_marker_annotations": [
                "protected"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/select/Elements_toStringTest.java.Elements_toStringTest.[void]setUp()",
        "name": "setUp",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "@BeforeEach\n    public void setUp()",
        "original_string": "    @BeforeEach\n    public void setUp() {\n        Document doc = Jsoup.parse(\"<div><p>Hello</p><p>World</p></div>\");\n        elements = new Elements(doc.select(\"p\"));\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/select/Elements_toStringTest.java",
        "class_name": "Elements_toStringTest",
        "class_uri": "src/test/java/org/jsoup/select/Elements_toStringTest.java.Elements_toStringTest",
        "attributes": {
            "modifiers": "@BeforeEach\n    public",
            "marker_annotations": [
                "@BeforeEach"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/select/Elements_attrTest.java.Elements_attrTest.[void]setUp()",
        "name": "setUp",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "@BeforeEach\n    public void setUp()",
        "original_string": "    @BeforeEach\n    public void setUp() {\n        Document doc = Jsoup.parse(\"<div id='test' data-attr='value'></div><div></div>\");\n        elements = new Elements(doc.select(\"div\"));\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/select/Elements_attrTest.java",
        "class_name": "Elements_attrTest",
        "class_uri": "src/test/java/org/jsoup/select/Elements_attrTest.java.Elements_attrTest",
        "attributes": {
            "modifiers": "@BeforeEach\n    public",
            "marker_annotations": [
                "@BeforeEach"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/select/EvaluatorDebug.java.EvaluatorDebug.[Document]asDocument(Evaluator)",
        "name": "asDocument",
        "arg_nums": 1,
        "params": [
            {
                "name": "eval",
                "type": "Evaluator"
            }
        ],
        "return_type": "Document",
        "signature": "public static Document asDocument(Evaluator eval)",
        "original_string": "    public static Document asDocument(Evaluator eval) {\n        Document doc = new Document(null);\n        doc.outputSettings().outline(true).indentAmount(2);\n\n        Element el = asElement(eval);\n        doc.appendChild(el);\n\n        return doc;\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/select/EvaluatorDebug.java",
        "class_name": "EvaluatorDebug",
        "class_uri": "src/test/java/org/jsoup/select/EvaluatorDebug.java.EvaluatorDebug",
        "attributes": {
            "modifiers": "public static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public",
                "static"
            ],
            "comments": [],
            "return_type": "Document",
            "classes": []
        },
        "docstring": "\nCast an Evaluator into a pseudo Document, to help visualize the query. Quite coupled to the current impl.\n"
    },
    {
        "uris": "src/test/java/org/jsoup/select/EvaluatorDebug.java.EvaluatorDebug.[Document]asDocument(String)",
        "name": "asDocument",
        "arg_nums": 1,
        "params": [
            {
                "name": "query",
                "type": "String"
            }
        ],
        "return_type": "Document",
        "signature": "public static Document asDocument(String query)",
        "original_string": "    public static Document asDocument(String query) {\n        Evaluator eval = QueryParser.parse(query);\n        return asDocument(eval);\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/select/EvaluatorDebug.java",
        "class_name": "EvaluatorDebug",
        "class_uri": "src/test/java/org/jsoup/select/EvaluatorDebug.java.EvaluatorDebug",
        "attributes": {
            "modifiers": "public static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public",
                "static"
            ],
            "comments": [],
            "return_type": "Document",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/select/EvaluatorDebug.java.EvaluatorDebug.[Element]asElement(Evaluator)",
        "name": "asElement",
        "arg_nums": 1,
        "params": [
            {
                "name": "eval",
                "type": "Evaluator"
            }
        ],
        "return_type": "Element",
        "signature": "public static Element asElement(Evaluator eval)",
        "original_string": "    public static Element asElement(Evaluator eval) {\n        Class<? extends Evaluator> evalClass = eval.getClass();\n        Element el = new Element(evalClass.getSimpleName());\n        el.attr(\"css\", eval.toString());\n        el.attr(\"cost\", Integer.toString(eval.cost()));\n\n        if (eval instanceof CombiningEvaluator) {\n            for (Evaluator inner : ((CombiningEvaluator) eval).sortedEvaluators) {\n                el.appendChild(asElement(inner));\n            }\n        } else if (eval instanceof StructuralEvaluator.ImmediateParentRun) {\n            for (Evaluator inner : ((StructuralEvaluator.ImmediateParentRun) eval).evaluators) {\n                el.appendChild(asElement(inner));\n            }\n        } else if (eval instanceof StructuralEvaluator) {\n            Evaluator inner = ((StructuralEvaluator) eval).evaluator;\n            el.appendChild(asElement(inner));\n        }\n\n        return el;\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/select/EvaluatorDebug.java",
        "class_name": "EvaluatorDebug",
        "class_uri": "src/test/java/org/jsoup/select/EvaluatorDebug.java.EvaluatorDebug",
        "attributes": {
            "modifiers": "public static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public",
                "static"
            ],
            "comments": [],
            "return_type": "Element",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/select/EvaluatorDebug.java.EvaluatorDebug.[String]sexpr(String)",
        "name": "sexpr",
        "arg_nums": 1,
        "params": [
            {
                "name": "query",
                "type": "String"
            }
        ],
        "return_type": "String",
        "signature": "public static String sexpr(String query)",
        "original_string": "    public static String sexpr(String query) {\n        Document doc = asDocument(query);\n\n        SexprVisitor sv = new SexprVisitor();\n        doc.childNode(0).traverse(sv); // skip outer #document\n        return sv.result();\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/select/EvaluatorDebug.java",
        "class_name": "EvaluatorDebug",
        "class_uri": "src/test/java/org/jsoup/select/EvaluatorDebug.java.EvaluatorDebug",
        "attributes": {
            "modifiers": "public static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public",
                "static"
            ],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/select/Elements_addClassTest.java.Elements_addClassTest.[void]setUp()",
        "name": "setUp",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "@BeforeEach\n    public void setUp()",
        "original_string": "    @BeforeEach\n    public void setUp() {\n        Document doc = Jsoup.parse(\"<div class='old'></div><div></div>\");\n        elements = new Elements(doc.select(\"div\"));\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/select/Elements_addClassTest.java",
        "class_name": "Elements_addClassTest",
        "class_uri": "src/test/java/org/jsoup/select/Elements_addClassTest.java.Elements_addClassTest",
        "attributes": {
            "modifiers": "@BeforeEach\n    public",
            "marker_annotations": [
                "@BeforeEach"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/select/Elements_cloneTest.java.Elements_cloneTest.[void]setUp()",
        "name": "setUp",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "@BeforeEach\n    public void setUp()",
        "original_string": "    @BeforeEach\n    public void setUp() {\n        Document doc = Jsoup.parse(\"<div id='test'><p>Hello</p></div>\");\n        elements = new Elements(doc.select(\"div\"));\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/select/Elements_cloneTest.java",
        "class_name": "Elements_cloneTest",
        "class_uri": "src/test/java/org/jsoup/select/Elements_cloneTest.java.Elements_cloneTest",
        "attributes": {
            "modifiers": "@BeforeEach\n    public",
            "marker_annotations": [
                "@BeforeEach"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/select/Elements_prependTest.java.Elements_prependTest.[void]setUp()",
        "name": "setUp",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "@BeforeEach\n    public void setUp()",
        "original_string": "    @BeforeEach\n    public void setUp() {\n        Document doc = Jsoup.parse(\"<div><p>First</p><p>Second</p></div>\");\n        elements = doc.select(\"p\");\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/select/Elements_prependTest.java",
        "class_name": "Elements_prependTest",
        "class_uri": "src/test/java/org/jsoup/select/Elements_prependTest.java.Elements_prependTest",
        "attributes": {
            "modifiers": "@BeforeEach\n    public",
            "marker_annotations": [
                "@BeforeEach"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/select/NodeTraversor_filterTest.java.NodeTraversor_filterTest.[void]setUp()",
        "name": "setUp",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "@BeforeEach\n    public void setUp()",
        "original_string": "    @BeforeEach\n    public void setUp() {\n        doc = Jsoup.parse(\"<div><p>Hello</p></div><div>There</div>\");\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/select/NodeTraversor_filterTest.java",
        "class_name": "NodeTraversor_filterTest",
        "class_uri": "src/test/java/org/jsoup/select/NodeTraversor_filterTest.java.NodeTraversor_filterTest",
        "attributes": {
            "modifiers": "@BeforeEach\n    public",
            "marker_annotations": [
                "@BeforeEach"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/select/Elements_textTest.java.Elements_textTest.[void]setUp()",
        "name": "setUp",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "@BeforeEach\n    public void setUp()",
        "original_string": "    @BeforeEach\n    public void setUp() {\n        Document doc = Jsoup.parse(\"<div><p>Hello</p><p>World</p></div>\");\n        elements = new Elements(doc.select(\"p\"));\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/select/Elements_textTest.java",
        "class_name": "Elements_textTest",
        "class_uri": "src/test/java/org/jsoup/select/Elements_textTest.java.Elements_textTest",
        "attributes": {
            "modifiers": "@BeforeEach\n    public",
            "marker_annotations": [
                "@BeforeEach"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/select/Elements_eachAttrTest.java.Elements_eachAttrTest.[void]setUp()",
        "name": "setUp",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "@BeforeEach\n    public void setUp()",
        "original_string": "    @BeforeEach\n    public void setUp() {\n        String html = \"<div class='test' data-attr='value1'></div><div data-attr='value2'></div>\";\n        Document doc = Jsoup.parse(html);\n        elements = new Elements(doc.select(\"div\"));\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/select/Elements_eachAttrTest.java",
        "class_name": "Elements_eachAttrTest",
        "class_uri": "src/test/java/org/jsoup/select/Elements_eachAttrTest.java.Elements_eachAttrTest",
        "attributes": {
            "modifiers": "@BeforeEach\n    public",
            "marker_annotations": [
                "@BeforeEach"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/integration/TestServer.java.TestServer.[Server]newServer()",
        "name": "newServer",
        "arg_nums": 0,
        "params": [],
        "return_type": "Server",
        "signature": "private static Server newServer()",
        "original_string": "    private static Server newServer() {\n        return new Server(new InetSocketAddress(Localhost, 0));\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/integration/TestServer.java",
        "class_name": "TestServer",
        "class_uri": "src/test/java/org/jsoup/integration/TestServer.java.TestServer",
        "attributes": {
            "modifiers": "private static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "private",
                "static"
            ],
            "comments": [],
            "return_type": "Server",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/integration/TestServer.java.TestServer.[]TestServer()",
        "name": "TestServer",
        "arg_nums": 0,
        "params": [],
        "return_type": "",
        "signature": "private TestServer()",
        "original_string": "    private TestServer() {\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/integration/TestServer.java",
        "class_name": "TestServer",
        "class_uri": "src/test/java/org/jsoup/integration/TestServer.java.TestServer",
        "attributes": {
            "modifiers": "private",
            "marker_annotations": [],
            "non_marker_annotations": [
                "private"
            ],
            "comments": [],
            "return_type": "",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/integration/TestServer.java.TestServer.[void]start()",
        "name": "start",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "public static void start()",
        "original_string": "    public static void start() {\n        synchronized (Jetty) {\n            if (Jetty.isStarted()) return;\n\n            try {\n                Jetty.start();\n                JettyHandler.addFilterWithMapping(new FilterHolder(new AuthFilter(false, false)), \"/*\", FilterMapping.ALL);\n                Connector[] jcons = Jetty.getConnectors();\n                Port = ((ServerConnector) jcons[0]).getLocalPort();\n                TlsPort = ((ServerConnector) jcons[1]).getLocalPort();\n\n                ProxyHandler.setHandler(ProxyServlet.createHandler(false)); // includes proxy, CONNECT proxy, and Auth filters\n                Proxy.start();\n                ProxySettings.port = ((ServerConnector) Proxy.getConnectors()[0]).getLocalPort();\n\n                AuthedProxyHandler.setHandler(ProxyServlet.createHandler(true));\n                AuthedProxy.start();\n                ProxySettings.authedPort = ((ServerConnector) AuthedProxy.getConnectors()[0]).getLocalPort();\n            } catch (Exception e) {\n                throw new IllegalStateException(e);\n            }\n        }\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/integration/TestServer.java",
        "class_name": "TestServer",
        "class_uri": "src/test/java/org/jsoup/integration/TestServer.java.TestServer",
        "attributes": {
            "modifiers": "public static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public",
                "static"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/integration/TestServer.java.TestServer.[int]closeAuthedProxyConnections()",
        "name": "closeAuthedProxyConnections",
        "arg_nums": 0,
        "params": [],
        "return_type": "int",
        "signature": "static int closeAuthedProxyConnections()",
        "original_string": "    static int closeAuthedProxyConnections() {\n        ServerConnector connector = (ServerConnector) AuthedProxy.getConnectors()[0];\n        AtomicInteger count = new AtomicInteger();\n        connector.getConnectedEndPoints().forEach(endPoint -> {\n            endPoint.close();\n            count.getAndIncrement();\n        });\n        return count.get();\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/integration/TestServer.java",
        "class_name": "TestServer",
        "class_uri": "src/test/java/org/jsoup/integration/TestServer.java.TestServer",
        "attributes": {
            "modifiers": "static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "static"
            ],
            "comments": [],
            "return_type": "int",
            "classes": []
        },
        "docstring": "\nClose any current connections to the authed proxy. Tunneled connections only authenticate in their first\nCONNECT, and may be kept alive and reused. So when we want to test unauthed - authed flows, we need to disconnect\nthem first.\n"
    },
    {
        "uris": "src/test/java/org/jsoup/integration/TestServer.java.TestServer.[ServletUrls]map(Class<? extends BaseServlet>)",
        "name": "map",
        "arg_nums": 1,
        "params": [
            {
                "name": "servletClass",
                "type": "Class<? extends BaseServlet>"
            }
        ],
        "return_type": "ServletUrls",
        "signature": "public static ServletUrls map(Class<? extends BaseServlet> servletClass)",
        "original_string": "    public static ServletUrls map(Class<? extends BaseServlet> servletClass) {\n        synchronized (Jetty) {\n            if (!Jetty.isStarted())\n                start(); // if running out of the test cases\n\n            String path = \"/\" + servletClass.getSimpleName();\n            JettyHandler.addServletWithMapping(servletClass, path + \"/*\");\n            String url = \"http://\" + Localhost + \":\" + Port + path;\n            String tlsUrl = \"https://\" + Localhost + \":\" + TlsPort + path;\n\n            return new ServletUrls(url, tlsUrl);\n        }\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/integration/TestServer.java",
        "class_name": "TestServer",
        "class_uri": "src/test/java/org/jsoup/integration/TestServer.java.TestServer",
        "attributes": {
            "modifiers": "public static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public",
                "static"
            ],
            "comments": [],
            "return_type": "ServletUrls",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/integration/TestServer.java.TestServer.[ProxySettings]proxySettings()",
        "name": "proxySettings",
        "arg_nums": 0,
        "params": [],
        "return_type": "ProxySettings",
        "signature": "public static ProxySettings proxySettings()",
        "original_string": "    public static ProxySettings proxySettings() {\n        synchronized (Jetty) {\n            if (!Jetty.isStarted())\n                start();\n\n            return ProxySettings;\n        }\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/integration/TestServer.java",
        "class_name": "TestServer",
        "class_uri": "src/test/java/org/jsoup/integration/TestServer.java.TestServer",
        "attributes": {
            "modifiers": "public static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public",
                "static"
            ],
            "comments": [],
            "return_type": "ProxySettings",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/integration/TestServer.java.TestServer.[void]addHttpsConnector(File,Server)",
        "name": "addHttpsConnector",
        "arg_nums": 2,
        "params": [
            {
                "name": "keystoreFile",
                "type": "File"
            },
            {
                "name": "server",
                "type": "Server"
            }
        ],
        "return_type": "void",
        "signature": "private static void addHttpsConnector(File keystoreFile, Server server)",
        "original_string": "    private static void addHttpsConnector(File keystoreFile, Server server) {\n        // Cribbed from https://github.com/jetty/jetty.project/blob/jetty-9.4.x/examples/embedded/src/main/java/org/eclipse/jetty/embedded/LikeJettyXml.java\n        SslContextFactory sslContextFactory = new SslContextFactory.Server();\n        String path = keystoreFile.getAbsolutePath();\n        sslContextFactory.setKeyStorePath(path);\n        sslContextFactory.setKeyStorePassword(KeystorePassword);\n        sslContextFactory.setKeyManagerPassword(KeystorePassword);\n        sslContextFactory.setTrustStorePath(path);\n        sslContextFactory.setTrustStorePassword(KeystorePassword);\n\n        HttpConfiguration httpConfig = new HttpConfiguration();\n        httpConfig.setSecureScheme(\"https\");\n        HttpConfiguration httpsConfig = new HttpConfiguration(httpConfig);\n        httpsConfig.addCustomizer(new SecureRequestCustomizer());\n\n        ServerConnector sslConnector = new ServerConnector(\n            server,\n            new SslConnectionFactory(sslContextFactory, HttpVersion.HTTP_1_1.asString()),\n            new HttpConnectionFactory(httpsConfig));\n        server.addConnector(sslConnector);\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/integration/TestServer.java",
        "class_name": "TestServer",
        "class_uri": "src/test/java/org/jsoup/integration/TestServer.java.TestServer",
        "attributes": {
            "modifiers": "private static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "private",
                "static"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/integration/TestServer.java.TestServer.[void]setupDefaultTrust(File)",
        "name": "setupDefaultTrust",
        "arg_nums": 1,
        "params": [
            {
                "name": "keystoreFile",
                "type": "File"
            }
        ],
        "return_type": "void",
        "signature": "private static void setupDefaultTrust(File keystoreFile)",
        "original_string": "    private static void setupDefaultTrust(File keystoreFile) throws KeyStoreException, IOException, NoSuchAlgorithmException, CertificateException, KeyManagementException {\n        // Configure HttpsUrlConnection (jsoup) to trust (only) this cert\n        KeyStore trustStore = KeyStore.getInstance(KeyStore.getDefaultType());\n        trustStore.load(Files.newInputStream(keystoreFile.toPath()), KeystorePassword.toCharArray());\n        TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());\n        trustManagerFactory.init(trustStore);\n        TrustManager[] managers = trustManagerFactory.getTrustManagers();\n        SSLContext tls = SSLContext.getInstance(\"TLS\");\n        tls.init(null, managers, null);\n        SSLSocketFactory socketFactory = tls.getSocketFactory();\n        HttpsURLConnection.setDefaultSSLSocketFactory(socketFactory);\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/integration/TestServer.java",
        "class_name": "TestServer",
        "class_uri": "src/test/java/org/jsoup/integration/TestServer.java.TestServer",
        "attributes": {
            "modifiers": "private static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "private",
                "static"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/integration/UrlConnectTest.java.UrlConnectTest.[String]ihVal(String,Document)",
        "name": "ihVal",
        "arg_nums": 2,
        "params": [
            {
                "name": "key",
                "type": "String"
            },
            {
                "name": "doc",
                "type": "Document"
            }
        ],
        "return_type": "String",
        "signature": "private static String ihVal(String key, Document doc)",
        "original_string": "    private static String ihVal(String key, Document doc) {\n        return doc.select(\"th:contains(\"+key+\") + td\").first().text();\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/integration/UrlConnectTest.java",
        "class_name": "UrlConnectTest",
        "class_uri": "src/test/java/org/jsoup/integration/UrlConnectTest.java.UrlConnectTest",
        "attributes": {
            "modifiers": "private static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "private",
                "static"
            ],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/integration/ConnectTest.java.ConnectTest.[void]setUp()",
        "name": "setUp",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "@BeforeAll\n    public static void setUp()",
        "original_string": "    @BeforeAll\n    public static void setUp() {\n        TestServer.start();\n        echoUrl = EchoServlet.Url;\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/integration/ConnectTest.java",
        "class_name": "ConnectTest",
        "class_uri": "src/test/java/org/jsoup/integration/ConnectTest.java.ConnectTest",
        "attributes": {
            "modifiers": "@BeforeAll\n    public static",
            "marker_annotations": [
                "@BeforeAll"
            ],
            "non_marker_annotations": [
                "public",
                "static"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/integration/ConnectTest.java.ConnectTest.[void]emptyCookieJar()",
        "name": "emptyCookieJar",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "@BeforeEach\n    public void emptyCookieJar()",
        "original_string": "    @BeforeEach\n    public void emptyCookieJar() {\n        // empty the cookie jar, so cookie tests are independent.\n        Jsoup.connect(\"http://example.com\").cookieStore().removeAll();\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/integration/ConnectTest.java",
        "class_name": "ConnectTest",
        "class_uri": "src/test/java/org/jsoup/integration/ConnectTest.java.ConnectTest",
        "attributes": {
            "modifiers": "@BeforeEach\n    public",
            "marker_annotations": [
                "@BeforeEach"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/integration/ConnectTest.java.ConnectTest.[String]ihVal(String,Document)",
        "name": "ihVal",
        "arg_nums": 2,
        "params": [
            {
                "name": "key",
                "type": "String"
            },
            {
                "name": "doc",
                "type": "Document"
            }
        ],
        "return_type": "String",
        "signature": "static String ihVal(String key, Document doc)",
        "original_string": "    static String ihVal(String key, Document doc) {\n        final Element first = doc.select(\"th:contains(\" + key + \") + td\").first();\n        return first != null ? first.text() : null;\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/integration/ConnectTest.java",
        "class_name": "ConnectTest",
        "class_uri": "src/test/java/org/jsoup/integration/ConnectTest.java.ConnectTest",
        "attributes": {
            "modifiers": "static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "static"
            ],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/integration/ConnectTest.java.ConnectTest.[String]echoSelect(String)",
        "name": "echoSelect",
        "arg_nums": 1,
        "params": [
            {
                "name": "key",
                "type": "String"
            }
        ],
        "return_type": "String",
        "signature": "static String echoSelect(String key)",
        "original_string": "    static String echoSelect(String key) {\n        return String.format(\"th:contains(%s) + td\", key);\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/integration/ConnectTest.java",
        "class_name": "ConnectTest",
        "class_uri": "src/test/java/org/jsoup/integration/ConnectTest.java.ConnectTest",
        "attributes": {
            "modifiers": "static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "static"
            ],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/integration/ConnectTest.java.ConnectTest.[void]fetchHandlesXml(String)",
        "name": "fetchHandlesXml",
        "arg_nums": 1,
        "params": [
            {
                "name": "contentType",
                "type": "String"
            }
        ],
        "return_type": "void",
        "signature": "void fetchHandlesXml(String contentType)",
        "original_string": "    void fetchHandlesXml(String contentType) throws IOException {\n        // should auto-detect xml and use XML parser, unless explicitly requested the html parser\n        String xmlUrl = FileServlet.urlTo(\"/htmltests/xml-test.xml\");\n        Connection con = Jsoup.connect(xmlUrl);\n        con.data(FileServlet.ContentTypeParam, contentType);\n        Document doc = con.get();\n        Connection.Request req = con.request();\n        assertTrue(req.parser().getTreeBuilder() instanceof XmlTreeBuilder);\n        assertEquals(\"<doc><val>One<val>Two</val>Three</val></doc>\\n\", doc.outerHtml());\n        assertEquals(con.response().contentType(), contentType);\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/integration/ConnectTest.java",
        "class_name": "ConnectTest",
        "class_uri": "src/test/java/org/jsoup/integration/ConnectTest.java.ConnectTest",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/integration/ConnectTest.java.ConnectTest.[Stream<String>]echoUrls()",
        "name": "echoUrls",
        "arg_nums": 0,
        "params": [],
        "return_type": "Stream<String>",
        "signature": "private static Stream<String> echoUrls()",
        "original_string": "    private static Stream<String> echoUrls() {\n        return Stream.of(EchoServlet.Url, EchoServlet.TlsUrl);\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/integration/ConnectTest.java",
        "class_name": "ConnectTest",
        "class_uri": "src/test/java/org/jsoup/integration/ConnectTest.java.ConnectTest",
        "attributes": {
            "modifiers": "private static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "private",
                "static"
            ],
            "comments": [],
            "return_type": "Stream<String>",
            "classes": []
        },
        "docstring": "\nProvides HTTP and HTTPS EchoServlet URLs\n"
    },
    {
        "uris": "src/test/java/org/jsoup/integration/FuzzFixesIT.java.FuzzFixesIT.[Stream<File>]testFiles()",
        "name": "testFiles",
        "arg_nums": 0,
        "params": [],
        "return_type": "Stream<File>",
        "signature": "private static Stream<File> testFiles()",
        "original_string": "    private static Stream<File> testFiles() {\n        File[] files = testDir.listFiles();\n        assertNotNull(files);\n        assertTrue(files.length > 10);\n\n        return Stream.of(files);\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/integration/FuzzFixesIT.java",
        "class_name": "FuzzFixesIT",
        "class_uri": "src/test/java/org/jsoup/integration/FuzzFixesIT.java.FuzzFixesIT",
        "attributes": {
            "modifiers": "private static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "private",
                "static"
            ],
            "comments": [],
            "return_type": "Stream<File>",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/integration/SessionTest.java.SessionTest.[void]setUp()",
        "name": "setUp",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "@BeforeAll\n    public static void setUp()",
        "original_string": "    @BeforeAll\n    public static void setUp() {\n        TestServer.start();\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/integration/SessionTest.java",
        "class_name": "SessionTest",
        "class_uri": "src/test/java/org/jsoup/integration/SessionTest.java.SessionTest",
        "attributes": {
            "modifiers": "@BeforeAll\n    public static",
            "marker_annotations": [
                "@BeforeAll"
            ],
            "non_marker_annotations": [
                "public",
                "static"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/integration/SessionTest.java.SessionTest.[Elements]keyEls(String,Document)",
        "name": "keyEls",
        "arg_nums": 2,
        "params": [
            {
                "name": "key",
                "type": "String"
            },
            {
                "name": "doc",
                "type": "Document"
            }
        ],
        "return_type": "Elements",
        "signature": "private static Elements keyEls(String key, Document doc)",
        "original_string": "    private static Elements keyEls(String key, Document doc) {\n        return doc.select(\"th:contains(\" + key + \") + td\");\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/integration/SessionTest.java",
        "class_name": "SessionTest",
        "class_uri": "src/test/java/org/jsoup/integration/SessionTest.java.SessionTest",
        "attributes": {
            "modifiers": "private static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "private",
                "static"
            ],
            "comments": [],
            "return_type": "Elements",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/integration/SessionTest.java.SessionTest.[String]keyText(String,Document)",
        "name": "keyText",
        "arg_nums": 2,
        "params": [
            {
                "name": "key",
                "type": "String"
            },
            {
                "name": "doc",
                "type": "Document"
            }
        ],
        "return_type": "String",
        "signature": "private static String keyText(String key, Document doc)",
        "original_string": "    private static String keyText(String key, Document doc) {\n        return doc.selectFirst(\"th:contains(\" + key + \") + td\").text();\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/integration/SessionTest.java",
        "class_name": "SessionTest",
        "class_uri": "src/test/java/org/jsoup/integration/SessionTest.java.SessionTest",
        "attributes": {
            "modifiers": "private static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "private",
                "static"
            ],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/integration/SessionTest.java.SessionTest.[void]assertCookieServlet(Document)",
        "name": "assertCookieServlet",
        "arg_nums": 1,
        "params": [
            {
                "name": "doc",
                "type": "Document"
            }
        ],
        "return_type": "void",
        "signature": "private void assertCookieServlet(Document doc)",
        "original_string": "    private void assertCookieServlet(Document doc) {\n        assertEquals(2, doc.select(\"table tr\").size());  // two of three sent to servlet (/ and /CookieServlet)\n        Elements doc3Els = keyEls(\"One\", doc);\n        assertEquals(2, doc3Els.size());\n        assertEquals(\"CookieServlet\", doc3Els.get(0).text()); // ordered by most specific path\n        assertEquals(\"Root\", doc3Els.get(1).text()); // ordered by most specific path\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/integration/SessionTest.java",
        "class_name": "SessionTest",
        "class_uri": "src/test/java/org/jsoup/integration/SessionTest.java.SessionTest",
        "attributes": {
            "modifiers": "private",
            "marker_annotations": [],
            "non_marker_annotations": [
                "private"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": " validate that only cookies set by cookie servlet get to the cookie servlet path"
    },
    {
        "uris": "src/test/java/org/jsoup/integration/SessionTest.java.SessionTest.[void]assertEchoServlet(Document)",
        "name": "assertEchoServlet",
        "arg_nums": 1,
        "params": [
            {
                "name": "doc",
                "type": "Document"
            }
        ],
        "return_type": "void",
        "signature": "private void assertEchoServlet(Document doc)",
        "original_string": "    private void assertEchoServlet(Document doc) {\n        Elements echoEls = keyEls(\"Cookie: One\", doc);  // two of three sent to servlet (/ and /EchoServlet)\n        assertEquals(2, echoEls.size());\n        assertEquals(\"EchoServlet\", echoEls.get(0).text()); // ordered by most specific path - /Echo\n        assertEquals(\"Root\", echoEls.get(1).text()); // ordered by most specific path - /\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/integration/SessionTest.java",
        "class_name": "SessionTest",
        "class_uri": "src/test/java/org/jsoup/integration/SessionTest.java.SessionTest",
        "attributes": {
            "modifiers": "private",
            "marker_annotations": [],
            "non_marker_annotations": [
                "private"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": " validate that only for echo servlet"
    },
    {
        "uris": "src/test/java/org/jsoup/integration/FuzzFixesTest.java.FuzzFixesTest.[Stream<File>]testFiles()",
        "name": "testFiles",
        "arg_nums": 0,
        "params": [],
        "return_type": "Stream<File>",
        "signature": "private static Stream<File> testFiles()",
        "original_string": "    private static Stream<File> testFiles() {\n        File[] files = FuzzFixesIT.testDir.listFiles();\n        assertNotNull(files);\n        assertTrue(files.length > 10);\n\n        return Stream.of(files);\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/integration/FuzzFixesTest.java",
        "class_name": "FuzzFixesTest",
        "class_uri": "src/test/java/org/jsoup/integration/FuzzFixesTest.java.FuzzFixesTest",
        "attributes": {
            "modifiers": "private static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "private",
                "static"
            ],
            "comments": [],
            "return_type": "Stream<File>",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/integration/Benchmark.java.Benchmark.[void]run(Runnable,Runnable,int)",
        "name": "run",
        "arg_nums": 3,
        "params": [
            {
                "name": "a",
                "type": "Runnable"
            },
            {
                "name": "b",
                "type": "Runnable"
            },
            {
                "name": "count",
                "type": "int"
            }
        ],
        "return_type": "void",
        "signature": "public static void run(Runnable a, Runnable b, int count)",
        "original_string": "    public static void run(Runnable a, Runnable b, int count) {\n        long aMillis;\n        long bMillis;\n\n        print(\"Running test A (x%d)\", count);\n        aMillis = time(a, count);\n        print(\"Running test B\");\n        bMillis = time(b, count);\n\n        print(\"\\nResults:\");\n        print(\"A: %.2fs\", aMillis / 1000f);\n        print(\"B: %.2fs\", bMillis / 1000f);\n        print(\"\\nB ran in %.2f %% time of A\\n\", (bMillis *1f / aMillis * 1f) * 100f);\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/integration/Benchmark.java",
        "class_name": "Benchmark",
        "class_uri": "src/test/java/org/jsoup/integration/Benchmark.java.Benchmark",
        "attributes": {
            "modifiers": "public static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public",
                "static"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/integration/Benchmark.java.Benchmark.[long]time(Runnable,int)",
        "name": "time",
        "arg_nums": 2,
        "params": [
            {
                "name": "test",
                "type": "Runnable"
            },
            {
                "name": "count",
                "type": "int"
            }
        ],
        "return_type": "long",
        "signature": "private static long time(Runnable test, int count)",
        "original_string": "    private static long time(Runnable test, int count) {\n        Date start = new Date();\n        for (int i = 0; i < count; i++) {\n            test.run();\n        }\n        Date end = new Date();\n        return end.getTime() - start.getTime();\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/integration/Benchmark.java",
        "class_name": "Benchmark",
        "class_uri": "src/test/java/org/jsoup/integration/Benchmark.java.Benchmark",
        "attributes": {
            "modifiers": "private static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "private",
                "static"
            ],
            "comments": [],
            "return_type": "long",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/integration/Benchmark.java.Benchmark.[void]print(String)",
        "name": "print",
        "arg_nums": 1,
        "params": [
            {
                "name": "msgFormat",
                "type": "String"
            }
        ],
        "return_type": "void",
        "signature": "private static void print(String msgFormat, Object... msgParams)",
        "original_string": "    private static void print(String msgFormat, Object... msgParams) {\n        System.out.println(String.format(msgFormat, msgParams));\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/integration/Benchmark.java",
        "class_name": "Benchmark",
        "class_uri": "src/test/java/org/jsoup/integration/Benchmark.java.Benchmark",
        "attributes": {
            "modifiers": "private static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "private",
                "static"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/integration/SessionIT.java.SessionIT.[void]setUp()",
        "name": "setUp",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "@BeforeAll\n    public static void setUp()",
        "original_string": "    @BeforeAll\n    public static void setUp() {\n        TestServer.start();\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/integration/SessionIT.java",
        "class_name": "SessionIT",
        "class_uri": "src/test/java/org/jsoup/integration/SessionIT.java.SessionIT",
        "attributes": {
            "modifiers": "@BeforeAll\n    public static",
            "marker_annotations": [
                "@BeforeAll"
            ],
            "non_marker_annotations": [
                "public",
                "static"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/integration/ParseTest.java.ParseTest.[File]getFile(String)",
        "name": "getFile",
        "arg_nums": 1,
        "params": [
            {
                "name": "resourceName",
                "type": "String"
            }
        ],
        "return_type": "File",
        "signature": "public static File getFile(String resourceName)",
        "original_string": "    public static File getFile(String resourceName) {\n        try {\n            URL resource = ParseTest.class.getResource(resourceName);\n            return resource != null ? new File(resource.toURI()) : new File(\"/404\");\n        } catch (URISyntaxException e) {\n            throw new IllegalStateException(e);\n        }\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/integration/ParseTest.java",
        "class_name": "ParseTest",
        "class_uri": "src/test/java/org/jsoup/integration/ParseTest.java.ParseTest",
        "attributes": {
            "modifiers": "public static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public",
                "static"
            ],
            "comments": [],
            "return_type": "File",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/integration/ParseTest.java.ParseTest.[Path]getPath(String)",
        "name": "getPath",
        "arg_nums": 1,
        "params": [
            {
                "name": "resourceName",
                "type": "String"
            }
        ],
        "return_type": "Path",
        "signature": "public static Path getPath(String resourceName)",
        "original_string": "    public static Path getPath(String resourceName) {\n        try {\n            URL resource = ParseTest.class.getResource(resourceName);\n            return resource != null ? Paths.get(resource.toURI()) : Paths.get(\"/404\");\n        } catch (URISyntaxException e) {\n            throw new IllegalStateException(e);\n        }\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/integration/ParseTest.java",
        "class_name": "ParseTest",
        "class_uri": "src/test/java/org/jsoup/integration/ParseTest.java.ParseTest",
        "attributes": {
            "modifiers": "public static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public",
                "static"
            ],
            "comments": [],
            "return_type": "Path",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/integration/ParseTest.java.ParseTest.[InputStream]inputStreamFrom(String)",
        "name": "inputStreamFrom",
        "arg_nums": 1,
        "params": [
            {
                "name": "s",
                "type": "String"
            }
        ],
        "return_type": "InputStream",
        "signature": "public static InputStream inputStreamFrom(String s)",
        "original_string": "    public static InputStream inputStreamFrom(String s) {\n        return new ByteArrayInputStream(s.getBytes(StandardCharsets.UTF_8));\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/integration/ParseTest.java",
        "class_name": "ParseTest",
        "class_uri": "src/test/java/org/jsoup/integration/ParseTest.java.ParseTest",
        "attributes": {
            "modifiers": "public static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public",
                "static"
            ],
            "comments": [],
            "return_type": "InputStream",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/integration/ParseTest.java.ParseTest.[String]getFileAsString(File)",
        "name": "getFileAsString",
        "arg_nums": 1,
        "params": [
            {
                "name": "file",
                "type": "File"
            }
        ],
        "return_type": "String",
        "signature": "public static String getFileAsString(File file)",
        "original_string": "    public static String getFileAsString(File file) throws IOException {\n        byte[] bytes;\n        if (file.getName().endsWith(\".gz\")) {\n            InputStream stream = new GZIPInputStream(new FileInputStream(file));\n            ByteBuffer byteBuffer = DataUtil.readToByteBuffer(stream, 0);\n            bytes = new byte[byteBuffer.limit()];\n            System.arraycopy(byteBuffer.array(), 0, bytes, 0, byteBuffer.limit());\n        } else {\n            bytes = Files.readAllBytes(file.toPath());\n        }\n        return new String(bytes);\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/integration/ParseTest.java",
        "class_name": "ParseTest",
        "class_uri": "src/test/java/org/jsoup/integration/ParseTest.java.ParseTest",
        "attributes": {
            "modifiers": "public static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public",
                "static"
            ],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/integration/servlets/DeflateServlet.java.DeflateServlet.[void]doIt(HttpServletRequest,HttpServletResponse)",
        "name": "doIt",
        "arg_nums": 2,
        "params": [
            {
                "name": "req",
                "type": "HttpServletRequest"
            },
            {
                "name": "res",
                "type": "HttpServletResponse"
            }
        ],
        "return_type": "void",
        "signature": "@Override\n    protected void doIt(HttpServletRequest req, HttpServletResponse res)",
        "original_string": "    @Override\n    protected void doIt(HttpServletRequest req, HttpServletResponse res) throws IOException {\n        res.setContentType(TextHtml);\n        res.setStatus(HttpServletResponse.SC_OK);\n        res.setHeader(\"Content-Encoding\", \"deflate\");\n\n        String doc = \"<p>Hello, World!<p>That should be enough, right?<p>Hello, World!<p>That should be enough, right?\";\n\n        DeflaterOutputStream stream = new DeflaterOutputStream(\n            res.getOutputStream(),\n            new Deflater(Deflater.BEST_COMPRESSION, true)); // true = nowrap zlib headers\n\n       stream.write(doc.getBytes(StandardCharsets.UTF_8));\n       stream.close();\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/integration/servlets/DeflateServlet.java",
        "class_name": "DeflateServlet",
        "class_uri": "src/test/java/org/jsoup/integration/servlets/DeflateServlet.java.DeflateServlet",
        "attributes": {
            "modifiers": "@Override\n    protected",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "protected"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/integration/servlets/DeflateServlet.java.DeflateServlet.[void]main(String[])",
        "name": "main",
        "arg_nums": 1,
        "params": [
            {
                "name": "args",
                "type": "String[]"
            }
        ],
        "return_type": "void",
        "signature": "public static void main(String[] args)",
        "original_string": "    public static void main(String[] args) {\n        TestServer.start();\n        System.out.println(Url);\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/integration/servlets/DeflateServlet.java",
        "class_name": "DeflateServlet",
        "class_uri": "src/test/java/org/jsoup/integration/servlets/DeflateServlet.java.DeflateServlet",
        "attributes": {
            "modifiers": "public static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public",
                "static"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": " allow the servlet to run as a main program, for local test"
    },
    {
        "uris": "src/test/java/org/jsoup/integration/servlets/AuthFilter.java.AuthFilter.[]AuthFilter(boolean,boolean)",
        "name": "AuthFilter",
        "arg_nums": 2,
        "params": [
            {
                "name": "alwaysWantsAuth",
                "type": "boolean"
            },
            {
                "name": "forProxy",
                "type": "boolean"
            }
        ],
        "return_type": "",
        "signature": "public AuthFilter(boolean alwaysWantsAuth, boolean forProxy)",
        "original_string": "    public AuthFilter(boolean alwaysWantsAuth, boolean forProxy) {\n        this.alwaysWantsAuth = alwaysWantsAuth;\n        this.forProxy = forProxy;\n\n        wantsHeader = forProxy ? WantsProxyAuthentication : WantsServerAuthentication;\n        authorizationHeader = forProxy ? \"Proxy-Authorization\" : \"Authorization\";\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/integration/servlets/AuthFilter.java",
        "class_name": "AuthFilter",
        "class_uri": "src/test/java/org/jsoup/integration/servlets/AuthFilter.java.AuthFilter",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "",
            "classes": []
        },
        "docstring": "\nCreates an Authentication Filter with hardcoded credential expectations.\n@param alwaysWantsAuth true if this filter should always check for authentication, regardless of the Wants Auth header\n@param forProxy true if this wraps a Proxy and should use Proxy-Authenticate headers, credentials etc. False\nif wrapping the web server.\n"
    },
    {
        "uris": "src/test/java/org/jsoup/integration/servlets/AuthFilter.java.AuthFilter.[String]newPassword()",
        "name": "newPassword",
        "arg_nums": 0,
        "params": [],
        "return_type": "String",
        "signature": "private static String newPassword()",
        "original_string": "    private static String newPassword() {\n        return \"pass-\" + Math.random();\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/integration/servlets/AuthFilter.java",
        "class_name": "AuthFilter",
        "class_uri": "src/test/java/org/jsoup/integration/servlets/AuthFilter.java.AuthFilter",
        "attributes": {
            "modifiers": "private static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "private",
                "static"
            ],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/integration/servlets/AuthFilter.java.AuthFilter.[String]newServerPassword()",
        "name": "newServerPassword",
        "arg_nums": 0,
        "params": [],
        "return_type": "String",
        "signature": "public static String newServerPassword()",
        "original_string": "    public static String newServerPassword() {\n        return ServerPassword = newPassword() + \"-server\";\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/integration/servlets/AuthFilter.java",
        "class_name": "AuthFilter",
        "class_uri": "src/test/java/org/jsoup/integration/servlets/AuthFilter.java.AuthFilter",
        "attributes": {
            "modifiers": "public static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public",
                "static"
            ],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": " requires tests hitting these are called serially."
    },
    {
        "uris": "src/test/java/org/jsoup/integration/servlets/AuthFilter.java.AuthFilter.[String]newProxyPassword()",
        "name": "newProxyPassword",
        "arg_nums": 0,
        "params": [],
        "return_type": "String",
        "signature": "public static String newProxyPassword()",
        "original_string": "    public static String newProxyPassword() {\n        return ProxyPassword = newPassword() + \"-proxy\";\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/integration/servlets/AuthFilter.java",
        "class_name": "AuthFilter",
        "class_uri": "src/test/java/org/jsoup/integration/servlets/AuthFilter.java.AuthFilter",
        "attributes": {
            "modifiers": "public static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public",
                "static"
            ],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/integration/servlets/AuthFilter.java.AuthFilter.[void]init(FilterConfig)",
        "name": "init",
        "arg_nums": 1,
        "params": [
            {
                "name": "filterConfig",
                "type": "FilterConfig"
            }
        ],
        "return_type": "void",
        "signature": "@Override public void init(FilterConfig filterConfig)",
        "original_string": "    @Override public void init(FilterConfig filterConfig) throws ServletException {}",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/integration/servlets/AuthFilter.java",
        "class_name": "AuthFilter",
        "class_uri": "src/test/java/org/jsoup/integration/servlets/AuthFilter.java.AuthFilter",
        "attributes": {
            "modifiers": "@Override public",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/integration/servlets/AuthFilter.java.AuthFilter.[void]doFilter(ServletRequest,ServletResponse,FilterChain)",
        "name": "doFilter",
        "arg_nums": 3,
        "params": [
            {
                "name": "request",
                "type": "ServletRequest"
            },
            {
                "name": "response",
                "type": "ServletResponse"
            },
            {
                "name": "chain",
                "type": "FilterChain"
            }
        ],
        "return_type": "void",
        "signature": "@Override\n    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)",
        "original_string": "    @Override\n    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n        HttpServletRequest req = (HttpServletRequest) request;\n        HttpServletResponse res = (HttpServletResponse) response;\n\n        boolean accessGranted = checkAuth(req);\n        if (accessGranted) {\n            chain.doFilter(request, response);\n            return;\n        }\n\n        // Wants but failed auth - send appropriate header:\n        if (forProxy) {\n            res.setHeader(\"Proxy-Authenticate\", \"Basic realm=\\\"\" + ProxyRealm + \"\\\"\");\n            // ^^ Duped in ProxyServlet for CONNECT\n            res.sendError(HttpServletResponse.SC_PROXY_AUTHENTICATION_REQUIRED);\n        } else {\n            res.setHeader(\"WWW-Authenticate\", \"Basic realm=\\\"\" + ServerRealm + \"\\\"\");\n            res.sendError(HttpServletResponse.SC_UNAUTHORIZED);\n        }\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/integration/servlets/AuthFilter.java",
        "class_name": "AuthFilter",
        "class_uri": "src/test/java/org/jsoup/integration/servlets/AuthFilter.java.AuthFilter",
        "attributes": {
            "modifiers": "@Override\n    public",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/integration/servlets/AuthFilter.java.AuthFilter.[void]destroy()",
        "name": "destroy",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "@Override public void destroy()",
        "original_string": "    @Override public void destroy() {}",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/integration/servlets/AuthFilter.java",
        "class_name": "AuthFilter",
        "class_uri": "src/test/java/org/jsoup/integration/servlets/AuthFilter.java.AuthFilter",
        "attributes": {
            "modifiers": "@Override public",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/integration/servlets/AuthFilter.java.AuthFilter.[boolean]checkAuth(HttpServletRequest)",
        "name": "checkAuth",
        "arg_nums": 1,
        "params": [
            {
                "name": "req",
                "type": "HttpServletRequest"
            }
        ],
        "return_type": "boolean",
        "signature": "public boolean checkAuth(HttpServletRequest req)",
        "original_string": "    public boolean checkAuth(HttpServletRequest req) {\n        if (alwaysWantsAuth || req.getHeader(wantsHeader) != null) {\n            String authHeader = req.getHeader(authorizationHeader);\n            if (authHeader != null) {\n                int space = authHeader.indexOf(' ');\n                if (space > 0) {\n                    String value = authHeader.substring(space + 1);\n                    String expected = forProxy ?\n                        (ProxyUser + \":\" + ProxyPassword) :\n                        (ServerUser + \":\" + ServerPassword);\n                    String base64 = Base64.getEncoder().encodeToString(expected.getBytes(StandardCharsets.UTF_8));\n                    return base64.equals(value); // if passed auth\n                }\n            }\n            return false; // unexpected header value\n        }\n        return true; // auth not required\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/integration/servlets/AuthFilter.java",
        "class_name": "AuthFilter",
        "class_uri": "src/test/java/org/jsoup/integration/servlets/AuthFilter.java.AuthFilter",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/integration/servlets/InterruptedServlet.java.InterruptedServlet.[void]doIt(HttpServletRequest,HttpServletResponse)",
        "name": "doIt",
        "arg_nums": 2,
        "params": [
            {
                "name": "req",
                "type": "HttpServletRequest"
            },
            {
                "name": "res",
                "type": "HttpServletResponse"
            }
        ],
        "return_type": "void",
        "signature": "@Override\n    protected void doIt(HttpServletRequest req, HttpServletResponse res)",
        "original_string": "    @Override\n    protected void doIt(HttpServletRequest req, HttpServletResponse res) throws IOException {\n        String magnitude = req.getParameter(Magnitude);\n        magnitude  = magnitude == null ? \"\" : magnitude;\n        res.setContentType(TextHtml);\n        res.setStatus(HttpServletResponse.SC_OK);\n\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"<title>Something</title>\");\n        while (sb.length() <= 32 * 1024) {\n            sb.append(\"<div>A suitable amount of data.</div>\\n\");\n        }\n        sb.append(\"<p>Finale.</p>\");\n        String data = sb.toString();\n\n        int contentLength = magnitude.equals(Larger) ? data.length() * 2 : data.length() / 2;\n        res.setContentLength(contentLength);\n\n        res.getWriter().write(data);\n\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/integration/servlets/InterruptedServlet.java",
        "class_name": "InterruptedServlet",
        "class_uri": "src/test/java/org/jsoup/integration/servlets/InterruptedServlet.java.InterruptedServlet",
        "attributes": {
            "modifiers": "@Override\n    protected",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "protected"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/integration/servlets/RedirectServlet.java.RedirectServlet.[void]doIt(HttpServletRequest,HttpServletResponse)",
        "name": "doIt",
        "arg_nums": 2,
        "params": [
            {
                "name": "req",
                "type": "HttpServletRequest"
            },
            {
                "name": "res",
                "type": "HttpServletResponse"
            }
        ],
        "return_type": "void",
        "signature": "@Override\n    protected void doIt(HttpServletRequest req, HttpServletResponse res)",
        "original_string": "    @Override\n    protected void doIt(HttpServletRequest req, HttpServletResponse res) throws IOException {\n        String location = req.getParameter(LocationParam);\n        if (location == null)\n            location = \"\";\n\n        int intCode = DefaultCode;\n        String code = req.getParameter(CodeParam);\n        if (code != null)\n            intCode = Integer.parseInt(code);\n\n        if (req.getParameter(SetCookiesParam) != null) {\n            res.addCookie(new Cookie(\"token\", \"asdfg123\"));\n            res.addCookie(new Cookie(\"uid\", \"foobar\"));\n            res.addCookie(new Cookie(\"uid\", \"jhy\")); // dupe, should use latter\n        }\n\n        res.setHeader(\"Location\", location);\n        res.setStatus(intCode);\n        res.flushBuffer();\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/integration/servlets/RedirectServlet.java",
        "class_name": "RedirectServlet",
        "class_uri": "src/test/java/org/jsoup/integration/servlets/RedirectServlet.java.RedirectServlet",
        "attributes": {
            "modifiers": "@Override\n    protected",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "protected"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/integration/servlets/CookieServlet.java.CookieServlet.[void]doIt(HttpServletRequest,HttpServletResponse)",
        "name": "doIt",
        "arg_nums": 2,
        "params": [
            {
                "name": "req",
                "type": "HttpServletRequest"
            },
            {
                "name": "res",
                "type": "HttpServletResponse"
            }
        ],
        "return_type": "void",
        "signature": "@Override\n    protected void doIt(HttpServletRequest req, HttpServletResponse res)",
        "original_string": "    @Override\n    protected void doIt(HttpServletRequest req, HttpServletResponse res) throws IOException {\n        // Do we want to set cookies?\n        if (req.getParameter(SetCookiesParam) != null)\n            setCookies(res);\n\n        // Do we want to redirect elsewhere?\n        String loc = req.getParameter(LocationParam);\n        if (loc != null) {\n            res.sendRedirect(loc);\n            return;\n        }\n\n        // print out the cookies that were received\n        res.setContentType(TextHtml);\n        res.setStatus(200);\n\n        PrintWriter w = res.getWriter();\n        w.println(\"<table>\");\n        final Cookie[] cookies = req.getCookies();\n        if (cookies != null) {\n            for (Cookie cookie : cookies) {\n                EchoServlet.write(w, cookie.getName(), cookie.getValue());\n            }\n        }\n        w.println(\"</table>\");\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/integration/servlets/CookieServlet.java",
        "class_name": "CookieServlet",
        "class_uri": "src/test/java/org/jsoup/integration/servlets/CookieServlet.java.CookieServlet",
        "attributes": {
            "modifiers": "@Override\n    protected",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "protected"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/integration/servlets/CookieServlet.java.CookieServlet.[void]setCookies(HttpServletResponse)",
        "name": "setCookies",
        "arg_nums": 1,
        "params": [
            {
                "name": "res",
                "type": "HttpServletResponse"
            }
        ],
        "return_type": "void",
        "signature": "private void setCookies(HttpServletResponse res)",
        "original_string": "    private void setCookies(HttpServletResponse res) {\n        Cookie one = new Cookie(\"One\", \"Root\");\n        one.setPath(\"/\");\n        res.addCookie(one);\n\n        Cookie two = new Cookie(\"One\", \"CookieServlet\");\n        two.setPath(\"/CookieServlet\");\n        two.setHttpOnly(true);\n        two.setComment(\"Quite nice\");\n        res.addCookie(two);\n\n        Cookie three = new Cookie(\"One\", \"EchoServlet\");\n        three.setPath(\"/EchoServlet\");\n        res.addCookie(three);\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/integration/servlets/CookieServlet.java",
        "class_name": "CookieServlet",
        "class_uri": "src/test/java/org/jsoup/integration/servlets/CookieServlet.java.CookieServlet",
        "attributes": {
            "modifiers": "private",
            "marker_annotations": [],
            "non_marker_annotations": [
                "private"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/integration/servlets/FileServlet.java.FileServlet.[void]doIt(HttpServletRequest,HttpServletResponse)",
        "name": "doIt",
        "arg_nums": 2,
        "params": [
            {
                "name": "req",
                "type": "HttpServletRequest"
            },
            {
                "name": "res",
                "type": "HttpServletResponse"
            }
        ],
        "return_type": "void",
        "signature": "@Override\n    protected void doIt(HttpServletRequest req, HttpServletResponse res)",
        "original_string": "    @Override\n    protected void doIt(HttpServletRequest req, HttpServletResponse res) throws IOException {\n        String contentType = req.getParameter(ContentTypeParam);\n        if (contentType == null)\n            contentType = DefaultType;\n        String location = req.getPathInfo();\n\n        File file = ParseTest.getFile(location);\n        if (file.exists()) {\n            res.setContentType(contentType);\n            if (file.getName().endsWith(\"gz\"))\n                res.addHeader(\"Content-Encoding\", \"gzip\");\n            if (req.getParameter(SuppressContentLength) == null)\n                res.setContentLength((int) file.length());\n            res.setStatus(HttpServletResponse.SC_OK);\n\n            ServletOutputStream out = res.getOutputStream();\n            Files.copy(file.toPath(), out);\n            out.flush();\n        } else {\n            res.sendError(HttpServletResponse.SC_NOT_FOUND);\n        }\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/integration/servlets/FileServlet.java",
        "class_name": "FileServlet",
        "class_uri": "src/test/java/org/jsoup/integration/servlets/FileServlet.java.FileServlet",
        "attributes": {
            "modifiers": "@Override\n    protected",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "protected"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/integration/servlets/FileServlet.java.FileServlet.[String]urlTo(String)",
        "name": "urlTo",
        "arg_nums": 1,
        "params": [
            {
                "name": "path",
                "type": "String"
            }
        ],
        "return_type": "String",
        "signature": "public static String urlTo(String path)",
        "original_string": "    public static String urlTo(String path) {\n        return Url + path;\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/integration/servlets/FileServlet.java",
        "class_name": "FileServlet",
        "class_uri": "src/test/java/org/jsoup/integration/servlets/FileServlet.java.FileServlet",
        "attributes": {
            "modifiers": "public static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public",
                "static"
            ],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/integration/servlets/FileServlet.java.FileServlet.[String]tlsUrlTo(String)",
        "name": "tlsUrlTo",
        "arg_nums": 1,
        "params": [
            {
                "name": "path",
                "type": "String"
            }
        ],
        "return_type": "String",
        "signature": "public static String tlsUrlTo(String path)",
        "original_string": "    public static String tlsUrlTo(String path) {\n        return TlsUrl + path;\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/integration/servlets/FileServlet.java",
        "class_name": "FileServlet",
        "class_uri": "src/test/java/org/jsoup/integration/servlets/FileServlet.java.FileServlet",
        "attributes": {
            "modifiers": "public static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public",
                "static"
            ],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/integration/servlets/ProxyServlet.java.ProxyServlet.[Handler]createHandler(boolean)",
        "name": "createHandler",
        "arg_nums": 1,
        "params": [
            {
                "name": "alwaysAuth",
                "type": "boolean"
            }
        ],
        "return_type": "Handler",
        "signature": "public static Handler createHandler(boolean alwaysAuth)",
        "original_string": "    public static Handler createHandler(boolean alwaysAuth) {\n        // ConnectHandler wraps this ProxyServlet and handles CONNECT, which sets up a tunnel for HTTPS requests and is\n        // opaque to the proxy. The ProxyServlet handles simple HTTP requests.\n        AuthFilter authFilter = new AuthFilter(alwaysAuth, true);\n        ConnectHandler connectHandler = new ConnectProxy(authFilter);\n        ServletHandler proxyHandler = new ServletHandler();\n        proxyHandler.addFilterWithMapping(new FilterHolder(authFilter), \"/*\", FilterMapping.ALL); // auth for HTTP proxy\n        ServletHolder proxyServletHolder = new ServletHolder(ProxyServlet.class); // Holder wraps as it requires maxThreads initialization\n        proxyServletHolder.setAsyncSupported(true);\n        proxyServletHolder.setInitParameter(\"maxThreads\", \"8\");\n        proxyHandler.addServletWithMapping(proxyServletHolder, \"/*\");\n        connectHandler.setHandler(proxyHandler);\n\n        return connectHandler;\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/integration/servlets/ProxyServlet.java",
        "class_name": "ProxyServlet",
        "class_uri": "src/test/java/org/jsoup/integration/servlets/ProxyServlet.java.ProxyServlet",
        "attributes": {
            "modifiers": "public static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public",
                "static"
            ],
            "comments": [],
            "return_type": "Handler",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/integration/servlets/ProxyServlet.java.ProxyServlet.[void]onServerResponseHeaders(HttpServletRequest,HttpServletResponse,Response)",
        "name": "onServerResponseHeaders",
        "arg_nums": 3,
        "params": [
            {
                "name": "clientRequest",
                "type": "HttpServletRequest"
            },
            {
                "name": "proxyResponse",
                "type": "HttpServletResponse"
            },
            {
                "name": "serverResponse",
                "type": "Response"
            }
        ],
        "return_type": "void",
        "signature": "@Override\n    protected void onServerResponseHeaders(HttpServletRequest clientRequest, HttpServletResponse proxyResponse, Response serverResponse)",
        "original_string": "    @Override\n    protected void onServerResponseHeaders(HttpServletRequest clientRequest, HttpServletResponse proxyResponse, Response serverResponse) {\n        super.onServerResponseHeaders(clientRequest, proxyResponse, serverResponse);\n        proxyResponse.addHeader(\"Via\", Via);\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/integration/servlets/ProxyServlet.java",
        "class_name": "ProxyServlet",
        "class_uri": "src/test/java/org/jsoup/integration/servlets/ProxyServlet.java.ProxyServlet",
        "attributes": {
            "modifiers": "@Override\n    protected",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "protected"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/integration/servlets/EchoServlet.java.EchoServlet.[void]doIt(HttpServletRequest,HttpServletResponse)",
        "name": "doIt",
        "arg_nums": 2,
        "params": [
            {
                "name": "req",
                "type": "HttpServletRequest"
            },
            {
                "name": "res",
                "type": "HttpServletResponse"
            }
        ],
        "return_type": "void",
        "signature": "@Override\n    protected void doIt(HttpServletRequest req, HttpServletResponse res)",
        "original_string": "    @Override\n    protected void doIt(HttpServletRequest req, HttpServletResponse res) throws IOException, ServletException {\n        int intCode = DefaultCode;\n        String code = req.getHeader(CodeParam);\n        if (code != null)\n            intCode = Integer.parseInt(code);\n\n        boolean isMulti = maybeEnableMultipart(req);\n\n        res.setContentType(TextHtml);\n        res.setStatus(intCode);\n        // no-cache headers for test\n        res.addHeader(\"Cache-Control\", \"no-cache\");\n        res.addHeader(\"Cache-Control\", \"no-store\");\n\n        PrintWriter w = res.getWriter();\n\n        w.write(\"<title>Webserver Environment Variables</title>\\n\" +\n            \"    <style type=\\\"text/css\\\">\\n\" +\n            \"      body, td, th {font: 10pt Verdana, Arial, sans-serif; text-align: left}\\n\" +\n            \"      th {font-weight: bold}        \\n\" +\n            \"    </style>\\n\" +\n            \"    <body>\\n\" +\n            \"    <table border=\\\"0\\\">\");\n\n        // some get items\n        write(w, \"Method\", req.getMethod());\n        write(w, \"Request URI\", req.getRequestURI());\n        write(w, \"Path Info\", req.getPathInfo());\n        write(w, \"Query String\", req.getQueryString());\n\n        // request headers (why is it an enumeration?)\n        Enumeration<String> headerNames = req.getHeaderNames();\n        while (headerNames.hasMoreElements()) {\n            String header = headerNames.nextElement();\n            Enumeration<String> headers = req.getHeaders(header);\n            while (headers.hasMoreElements()) {\n                write(w, header, headers.nextElement());\n            }\n        }\n\n        // cookies\n        final Cookie[] cookies = req.getCookies();\n        if (cookies != null) {\n            for (Cookie cookie : cookies) {\n                EchoServlet.write(w, \"Cookie: \" + cookie.getName(), cookie.getValue());\n            }\n        }\n\n        // the request params\n        Enumeration<String> parameterNames = req.getParameterNames();\n        while (parameterNames.hasMoreElements()) {\n            String name = parameterNames.nextElement();\n            String[] values = req.getParameterValues(name);\n            write(w, name, StringUtil.join(values, \", \"));\n        }\n\n        // post body\n        ByteBuffer byteBuffer = DataUtil.readToByteBuffer(req.getInputStream(), 0);\n        String postData = new String(byteBuffer.array(), byteBuffer.arrayOffset(), byteBuffer.limit(), StandardCharsets.UTF_8);\n        if (!StringUtil.isBlank(postData)) {\n            write(w, \"Post Data\", postData);\n        }\n\n        // file uploads\n        if (isMulti) {\n            Collection<Part> parts = req.getParts();\n            write(w, \"Parts\", String.valueOf(parts.size()));\n\n            for (Part part : parts) {\n                String name = part.getName();\n                write(w, \"Part \" + name + \" ContentType\", part.getContentType());\n                write(w, \"Part \" + name + \" Name\", name);\n                write(w, \"Part \" + name + \" Filename\", part.getSubmittedFileName());\n                write(w, \"Part \" + name + \" Size\", String.valueOf(part.getSize()));\n                part.delete();\n            }\n        }\n\n        w.println(\"</table>\");\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/integration/servlets/EchoServlet.java",
        "class_name": "EchoServlet",
        "class_uri": "src/test/java/org/jsoup/integration/servlets/EchoServlet.java.EchoServlet",
        "attributes": {
            "modifiers": "@Override\n    protected",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "protected"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/integration/servlets/EchoServlet.java.EchoServlet.[void]write(PrintWriter,String,String)",
        "name": "write",
        "arg_nums": 3,
        "params": [
            {
                "name": "w",
                "type": "PrintWriter"
            },
            {
                "name": "key",
                "type": "String"
            },
            {
                "name": "val",
                "type": "String"
            }
        ],
        "return_type": "void",
        "signature": "static void write(PrintWriter w, String key, String val)",
        "original_string": "    static void write(PrintWriter w, String key, String val) {\n        w.println(\"<tr><th>\" + escape(key) + \"</th><td>\" + escape(val) + \"</td></tr>\");\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/integration/servlets/EchoServlet.java",
        "class_name": "EchoServlet",
        "class_uri": "src/test/java/org/jsoup/integration/servlets/EchoServlet.java.EchoServlet",
        "attributes": {
            "modifiers": "static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "static"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/integration/servlets/EchoServlet.java.EchoServlet.[void]main(String[])",
        "name": "main",
        "arg_nums": 1,
        "params": [
            {
                "name": "args",
                "type": "String[]"
            }
        ],
        "return_type": "void",
        "signature": "public static void main(String[] args)",
        "original_string": "    public static void main(String[] args) {\n        TestServer.start();\n        System.out.println(\"Listening on \" + Url + \" and \" + TlsUrl);\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/integration/servlets/EchoServlet.java",
        "class_name": "EchoServlet",
        "class_uri": "src/test/java/org/jsoup/integration/servlets/EchoServlet.java.EchoServlet",
        "attributes": {
            "modifiers": "public static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public",
                "static"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": " allow the servlet to run as a main program, for local test"
    },
    {
        "uris": "src/test/java/org/jsoup/integration/servlets/EchoServlet.java.EchoServlet.[boolean]maybeEnableMultipart(HttpServletRequest)",
        "name": "maybeEnableMultipart",
        "arg_nums": 1,
        "params": [
            {
                "name": "req",
                "type": "HttpServletRequest"
            }
        ],
        "return_type": "boolean",
        "signature": "private static boolean maybeEnableMultipart(HttpServletRequest req)",
        "original_string": "    private static boolean maybeEnableMultipart(HttpServletRequest req) {\n        boolean isMulti = req.getContentType() != null\n            && req.getContentType().startsWith(\"multipart/form-data\");\n\n        if (isMulti) {\n            req.setAttribute(Request.MULTIPART_CONFIG_ELEMENT, new MultipartConfigElement(\n                System.getProperty(\"java.io.tmpdir\")));\n        }\n        return isMulti;\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/integration/servlets/EchoServlet.java",
        "class_name": "EchoServlet",
        "class_uri": "src/test/java/org/jsoup/integration/servlets/EchoServlet.java.EchoServlet",
        "attributes": {
            "modifiers": "private static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "private",
                "static"
            ],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/integration/servlets/SlowRider.java.SlowRider.[void]doIt(HttpServletRequest,HttpServletResponse)",
        "name": "doIt",
        "arg_nums": 2,
        "params": [
            {
                "name": "req",
                "type": "HttpServletRequest"
            },
            {
                "name": "res",
                "type": "HttpServletResponse"
            }
        ],
        "return_type": "void",
        "signature": "@Override\n    protected void doIt(HttpServletRequest req, HttpServletResponse res)",
        "original_string": "    @Override\n    protected void doIt(HttpServletRequest req, HttpServletResponse res) throws IOException {\n        pause(1000);\n        res.setContentType(TextHtml);\n        res.setStatus(HttpServletResponse.SC_OK);\n        PrintWriter w = res.getWriter();\n\n        int maxTime = -1;\n        String maxTimeP = req.getParameter(MaxTimeParam);\n        if (maxTimeP != null) {\n            maxTime = Integer.parseInt(maxTimeP);\n        }\n\n        int introSize = 0;\n        String introSizeP = req.getParameter(IntroSizeParam);\n        if (introSizeP != null) {\n            introSize = Integer.parseInt(introSizeP);\n        }\n\n        long startTime = System.currentTimeMillis();\n        w.println(\"<title>Slow Rider</title>\");\n\n        // write out a bunch of stuff at the start before interim pauses, gets past some buffers\n        if (introSize != 0) {\n            StringBuilder s = new StringBuilder();\n            while (s.length() < introSize) {\n                s.append(\"<p>Hello and welcome to the Slow Rider!</p>\\n\");\n            }\n            w.println(s);\n            w.flush();\n        }\n\n        while (true) {\n            w.println(\"<p>Are you still there?\");\n            boolean err = w.checkError(); // flush, and check still ok\n            if (err) {\n                log(\"Remote connection lost\");\n                break;\n            }\n            if (pause(SleepTime)) break;\n\n            if (maxTime > 0 && System.currentTimeMillis() > startTime + maxTime) {\n                w.println(\"<h1>outatime</h1>\");\n                break;\n            }\n        }\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/integration/servlets/SlowRider.java",
        "class_name": "SlowRider",
        "class_uri": "src/test/java/org/jsoup/integration/servlets/SlowRider.java.SlowRider",
        "attributes": {
            "modifiers": "@Override\n    protected",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "protected"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/integration/servlets/SlowRider.java.SlowRider.[boolean]pause(int)",
        "name": "pause",
        "arg_nums": 1,
        "params": [
            {
                "name": "sleepTime",
                "type": "int"
            }
        ],
        "return_type": "boolean",
        "signature": "private static boolean pause(int sleepTime)",
        "original_string": "    private static boolean pause(int sleepTime) {\n        try {\n            Thread.sleep(sleepTime);\n        } catch (InterruptedException e) {\n            return true;\n        }\n        return false;\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/integration/servlets/SlowRider.java",
        "class_name": "SlowRider",
        "class_uri": "src/test/java/org/jsoup/integration/servlets/SlowRider.java.SlowRider",
        "attributes": {
            "modifiers": "private static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "private",
                "static"
            ],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/integration/servlets/SlowRider.java.SlowRider.[void]main(String[])",
        "name": "main",
        "arg_nums": 1,
        "params": [
            {
                "name": "args",
                "type": "String[]"
            }
        ],
        "return_type": "void",
        "signature": "public static void main(String[] args)",
        "original_string": "    public static void main(String[] args) {\n        TestServer.start();\n        System.out.println(Url);\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/integration/servlets/SlowRider.java",
        "class_name": "SlowRider",
        "class_uri": "src/test/java/org/jsoup/integration/servlets/SlowRider.java.SlowRider",
        "attributes": {
            "modifiers": "public static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public",
                "static"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": " allow the servlet to run as a main program, for local test"
    },
    {
        "uris": "src/test/java/org/jsoup/integration/servlets/HelloServlet.java.HelloServlet.[void]doIt(HttpServletRequest,HttpServletResponse)",
        "name": "doIt",
        "arg_nums": 2,
        "params": [
            {
                "name": "req",
                "type": "HttpServletRequest"
            },
            {
                "name": "res",
                "type": "HttpServletResponse"
            }
        ],
        "return_type": "void",
        "signature": "@Override\n    protected void doIt(HttpServletRequest req, HttpServletResponse res)",
        "original_string": "    @Override\n    protected void doIt(HttpServletRequest req, HttpServletResponse res) throws IOException {\n        res.setContentType(TextHtml);\n        res.setStatus(HttpServletResponse.SC_OK);\n\n        String doc = \"<p>Hello, World!\";\n        res.getWriter().write(doc);\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/integration/servlets/HelloServlet.java",
        "class_name": "HelloServlet",
        "class_uri": "src/test/java/org/jsoup/integration/servlets/HelloServlet.java.HelloServlet",
        "attributes": {
            "modifiers": "@Override\n    protected",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "protected"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/integration/servlets/BaseServlet.java.BaseServlet.[void]doIt(HttpServletRequest,HttpServletResponse)",
        "name": "doIt",
        "arg_nums": 2,
        "params": [
            {
                "name": "req",
                "type": "HttpServletRequest"
            },
            {
                "name": "res",
                "type": "HttpServletResponse"
            }
        ],
        "return_type": "void",
        "signature": "abstract protected void doIt(HttpServletRequest req, HttpServletResponse res)",
        "original_string": "    abstract protected void doIt(HttpServletRequest req, HttpServletResponse res) throws IOException, ServletException;",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/integration/servlets/BaseServlet.java",
        "class_name": "BaseServlet",
        "class_uri": "src/test/java/org/jsoup/integration/servlets/BaseServlet.java.BaseServlet",
        "attributes": {
            "modifiers": "abstract protected",
            "marker_annotations": [],
            "non_marker_annotations": [
                "abstract",
                "protected"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/integration/servlets/BaseServlet.java.BaseServlet.[void]doGet(HttpServletRequest,HttpServletResponse)",
        "name": "doGet",
        "arg_nums": 2,
        "params": [
            {
                "name": "req",
                "type": "HttpServletRequest"
            },
            {
                "name": "res",
                "type": "HttpServletResponse"
            }
        ],
        "return_type": "void",
        "signature": "@Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse res)",
        "original_string": "    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse res) throws IOException, ServletException {\n        doIt(req, res);\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/integration/servlets/BaseServlet.java",
        "class_name": "BaseServlet",
        "class_uri": "src/test/java/org/jsoup/integration/servlets/BaseServlet.java.BaseServlet",
        "attributes": {
            "modifiers": "@Override\n    protected",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "protected"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/integration/servlets/BaseServlet.java.BaseServlet.[void]doPost(HttpServletRequest,HttpServletResponse)",
        "name": "doPost",
        "arg_nums": 2,
        "params": [
            {
                "name": "req",
                "type": "HttpServletRequest"
            },
            {
                "name": "res",
                "type": "HttpServletResponse"
            }
        ],
        "return_type": "void",
        "signature": "@Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse res)",
        "original_string": "    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse res) throws IOException, ServletException {\n        doIt(req, res);\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/integration/servlets/BaseServlet.java",
        "class_name": "BaseServlet",
        "class_uri": "src/test/java/org/jsoup/integration/servlets/BaseServlet.java.BaseServlet",
        "attributes": {
            "modifiers": "@Override\n    protected",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "protected"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/integration/servlets/BaseServlet.java.BaseServlet.[void]doPut(HttpServletRequest,HttpServletResponse)",
        "name": "doPut",
        "arg_nums": 2,
        "params": [
            {
                "name": "req",
                "type": "HttpServletRequest"
            },
            {
                "name": "res",
                "type": "HttpServletResponse"
            }
        ],
        "return_type": "void",
        "signature": "@Override\n    protected void doPut(HttpServletRequest req, HttpServletResponse res)",
        "original_string": "    @Override\n    protected void doPut(HttpServletRequest req, HttpServletResponse res) throws IOException, ServletException {\n        doIt(req, res);\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/integration/servlets/BaseServlet.java",
        "class_name": "BaseServlet",
        "class_uri": "src/test/java/org/jsoup/integration/servlets/BaseServlet.java.BaseServlet",
        "attributes": {
            "modifiers": "@Override\n    protected",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "protected"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/integration/servlets/BaseServlet.java.BaseServlet.[void]doDelete(HttpServletRequest,HttpServletResponse)",
        "name": "doDelete",
        "arg_nums": 2,
        "params": [
            {
                "name": "req",
                "type": "HttpServletRequest"
            },
            {
                "name": "res",
                "type": "HttpServletResponse"
            }
        ],
        "return_type": "void",
        "signature": "@Override\n    protected void doDelete(HttpServletRequest req, HttpServletResponse res)",
        "original_string": "    @Override\n    protected void doDelete(HttpServletRequest req, HttpServletResponse res) throws IOException, ServletException {\n        doIt(req, res);\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/integration/servlets/BaseServlet.java",
        "class_name": "BaseServlet",
        "class_uri": "src/test/java/org/jsoup/integration/servlets/BaseServlet.java.BaseServlet",
        "attributes": {
            "modifiers": "@Override\n    protected",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "protected"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/parser/HtmlTreeBuilderStateTest.java.HtmlTreeBuilderStateTest.[List<Object[]>]findConstantArrays(Class)",
        "name": "findConstantArrays",
        "arg_nums": 1,
        "params": [
            {
                "name": "aClass",
                "type": "Class"
            }
        ],
        "return_type": "List<Object[]>",
        "signature": "static List<Object[]> findConstantArrays(Class aClass)",
        "original_string": "    static List<Object[]> findConstantArrays(Class aClass) {\n        ArrayList<Object[]> array = new ArrayList<>();\n        Field[] fields = aClass.getDeclaredFields();\n\n        for (Field field : fields) {\n            int modifiers = field.getModifiers();\n            if (Modifier.isStatic(modifiers) && !Modifier.isPrivate(modifiers) && field.getType().isArray()) {\n                try {\n                    array.add((Object[]) field.get(null));\n                } catch (IllegalAccessException e) {\n                    throw new IllegalStateException(e);\n                }\n            }\n        }\n\n        return array;\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/parser/HtmlTreeBuilderStateTest.java",
        "class_name": "HtmlTreeBuilderStateTest",
        "class_uri": "src/test/java/org/jsoup/parser/HtmlTreeBuilderStateTest.java.HtmlTreeBuilderStateTest",
        "attributes": {
            "modifiers": "static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "static"
            ],
            "comments": [],
            "return_type": "List<Object[]>",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/parser/HtmlTreeBuilderStateTest.java.HtmlTreeBuilderStateTest.[void]ensureSorted(List<Object[]>)",
        "name": "ensureSorted",
        "arg_nums": 1,
        "params": [
            {
                "name": "constants",
                "type": "List<Object[]>"
            }
        ],
        "return_type": "void",
        "signature": "static void ensureSorted(List<Object[]> constants)",
        "original_string": "    static void ensureSorted(List<Object[]> constants) {\n        for (Object[] array : constants) {\n            Object[] copy = Arrays.copyOf(array, array.length);\n            Arrays.sort(array);\n            assertArrayEquals(array, copy);\n        }\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/parser/HtmlTreeBuilderStateTest.java",
        "class_name": "HtmlTreeBuilderStateTest",
        "class_uri": "src/test/java/org/jsoup/parser/HtmlTreeBuilderStateTest.java.HtmlTreeBuilderStateTest",
        "attributes": {
            "modifiers": "static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "static"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/parser/TokenQueue_chompBalancedTest.java.TokenQueue_chompBalancedTest.[void]setUp()",
        "name": "setUp",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "@BeforeEach\n    public void setUp()",
        "original_string": "    @BeforeEach\n    public void setUp() {\n        tokenQueue = new TokenQueue(\"\");\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/parser/TokenQueue_chompBalancedTest.java",
        "class_name": "TokenQueue_chompBalancedTest",
        "class_uri": "src/test/java/org/jsoup/parser/TokenQueue_chompBalancedTest.java.TokenQueue_chompBalancedTest",
        "attributes": {
            "modifiers": "@BeforeEach\n    public",
            "marker_annotations": [
                "@BeforeEach"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/parser/ParserSettingsTest.java.ParserSettingsTest.[void]caseSupport(Locale)",
        "name": "caseSupport",
        "arg_nums": 1,
        "params": [
            {
                "name": "locale",
                "type": "Locale"
            }
        ],
        "return_type": "void",
        "signature": "@MultiLocaleTest\n    public void caseSupport(Locale locale)",
        "original_string": "    @MultiLocaleTest\n    public void caseSupport(Locale locale) {\n        Locale.setDefault(locale);\n\n        ParseSettings bothOn = new ParseSettings(true, true);\n        ParseSettings bothOff = new ParseSettings(false, false);\n        ParseSettings tagOn = new ParseSettings(true, false);\n        ParseSettings attrOn = new ParseSettings(false, true);\n\n        assertEquals(\"IMG\", bothOn.normalizeTag(\"IMG\"));\n        assertEquals(\"ID\", bothOn.normalizeAttribute(\"ID\"));\n\n        assertEquals(\"img\", bothOff.normalizeTag(\"IMG\"));\n        assertEquals(\"id\", bothOff.normalizeAttribute(\"ID\"));\n\n        assertEquals(\"IMG\", tagOn.normalizeTag(\"IMG\"));\n        assertEquals(\"id\", tagOn.normalizeAttribute(\"ID\"));\n\n        assertEquals(\"img\", attrOn.normalizeTag(\"IMG\"));\n        assertEquals(\"ID\", attrOn.normalizeAttribute(\"ID\"));\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/parser/ParserSettingsTest.java",
        "class_name": "ParserSettingsTest",
        "class_uri": "src/test/java/org/jsoup/parser/ParserSettingsTest.java.ParserSettingsTest",
        "attributes": {
            "modifiers": "@MultiLocaleTest\n    public",
            "marker_annotations": [
                "@MultiLocaleTest"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/parser/ParserSettingsTest.java.ParserSettingsTest.[void]attributeCaseNormalization(Locale)",
        "name": "attributeCaseNormalization",
        "arg_nums": 1,
        "params": [
            {
                "name": "locale",
                "type": "Locale"
            }
        ],
        "return_type": "void",
        "signature": "@MultiLocaleTest\n    public void attributeCaseNormalization(Locale locale)",
        "original_string": "    @MultiLocaleTest\n    public void attributeCaseNormalization(Locale locale) {\n        Locale.setDefault(locale);\n\n        ParseSettings parseSettings = new ParseSettings(false, false);\n        String normalizedAttribute = parseSettings.normalizeAttribute(\"HIDDEN\");\n\n        assertEquals(\"hidden\", normalizedAttribute);\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/parser/ParserSettingsTest.java",
        "class_name": "ParserSettingsTest",
        "class_uri": "src/test/java/org/jsoup/parser/ParserSettingsTest.java.ParserSettingsTest",
        "attributes": {
            "modifiers": "@MultiLocaleTest\n    public",
            "marker_annotations": [
                "@MultiLocaleTest"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/parser/ParserSettingsTest.java.ParserSettingsTest.[void]attributesCaseNormalization(Locale)",
        "name": "attributesCaseNormalization",
        "arg_nums": 1,
        "params": [
            {
                "name": "locale",
                "type": "Locale"
            }
        ],
        "return_type": "void",
        "signature": "@MultiLocaleTest\n    public void attributesCaseNormalization(Locale locale)",
        "original_string": "    @MultiLocaleTest\n    public void attributesCaseNormalization(Locale locale) {\n        Locale.setDefault(locale);\n\n        ParseSettings parseSettings = new ParseSettings(false, false);\n        Attributes attributes = new Attributes();\n        attributes.put(\"ITEM\", \"1\");\n\n        Attributes normalizedAttributes = parseSettings.normalizeAttributes(attributes);\n\n        assertEquals(\"item\", normalizedAttributes.asList().get(0).getKey());\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/parser/ParserSettingsTest.java",
        "class_name": "ParserSettingsTest",
        "class_uri": "src/test/java/org/jsoup/parser/ParserSettingsTest.java.ParserSettingsTest",
        "attributes": {
            "modifiers": "@MultiLocaleTest\n    public",
            "marker_annotations": [
                "@MultiLocaleTest"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/parser/CharacterReaderTest.java.CharacterReaderTest.[String]BufferBuster(String)",
        "name": "BufferBuster",
        "arg_nums": 1,
        "params": [
            {
                "name": "content",
                "type": "String"
            }
        ],
        "return_type": "String",
        "signature": "static String BufferBuster(String content)",
        "original_string": "    static String BufferBuster(String content) {\n        StringBuilder builder = new StringBuilder();\n        while (builder.length() < maxBufferLen)\n            builder.append(content);\n        return builder.toString();\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/parser/CharacterReaderTest.java",
        "class_name": "CharacterReaderTest",
        "class_uri": "src/test/java/org/jsoup/parser/CharacterReaderTest.java.CharacterReaderTest",
        "attributes": {
            "modifiers": "static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "static"
            ],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/parser/TokenQueue_chompToTest.java.TokenQueue_chompToTest.[void]setUp()",
        "name": "setUp",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "@BeforeEach\n    public void setUp()",
        "original_string": "    @BeforeEach\n    public void setUp() {\n        tokenQueue = new TokenQueue(\"initial data\");\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/parser/TokenQueue_chompToTest.java",
        "class_name": "TokenQueue_chompToTest",
        "class_uri": "src/test/java/org/jsoup/parser/TokenQueue_chompToTest.java.TokenQueue_chompToTest",
        "attributes": {
            "modifiers": "@BeforeEach\n    public",
            "marker_annotations": [
                "@BeforeEach"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/parser/Parser_parseFragmentTest.java.Parser_parseFragmentTest.[void]setUp()",
        "name": "setUp",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "@BeforeEach\n    public void setUp()",
        "original_string": "    @BeforeEach\n    public void setUp() {\n        parser = new Parser(new HtmlTreeBuilder());\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/parser/Parser_parseFragmentTest.java",
        "class_name": "Parser_parseFragmentTest",
        "class_uri": "src/test/java/org/jsoup/parser/Parser_parseFragmentTest.java.Parser_parseFragmentTest",
        "attributes": {
            "modifiers": "@BeforeEach\n    public",
            "marker_annotations": [
                "@BeforeEach"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/parser/TokenQueue_unescapeTest.java.TokenQueue_unescapeTest.[void]setUp()",
        "name": "setUp",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "@BeforeEach\n    public void setUp()",
        "original_string": "    @BeforeEach\n    public void setUp() {\n        // No setup required for static method\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/parser/TokenQueue_unescapeTest.java",
        "class_name": "TokenQueue_unescapeTest",
        "class_uri": "src/test/java/org/jsoup/parser/TokenQueue_unescapeTest.java.TokenQueue_unescapeTest",
        "attributes": {
            "modifiers": "@BeforeEach\n    public",
            "marker_annotations": [
                "@BeforeEach"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/parser/Parser_setTreeBuilderTest.java.Parser_setTreeBuilderTest.[void]setUp()",
        "name": "setUp",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "@BeforeEach\n    void setUp()",
        "original_string": "    @BeforeEach\n    void setUp() {\n        mockTreeBuilder = new HtmlTreeBuilder();\n        parser = new Parser(mockTreeBuilder);\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/parser/Parser_setTreeBuilderTest.java",
        "class_name": "Parser_setTreeBuilderTest",
        "class_uri": "src/test/java/org/jsoup/parser/Parser_setTreeBuilderTest.java.Parser_setTreeBuilderTest",
        "attributes": {
            "modifiers": "@BeforeEach",
            "marker_annotations": [
                "@BeforeEach"
            ],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/parser/TokenQueue_consumeToAnyTest.java.TokenQueue_consumeToAnyTest.[void]setUp()",
        "name": "setUp",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "@BeforeEach\n    public void setUp()",
        "original_string": "    @BeforeEach\n    public void setUp() {\n        tokenQueue = new TokenQueue(\"sample text for testing\");\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/parser/TokenQueue_consumeToAnyTest.java",
        "class_name": "TokenQueue_consumeToAnyTest",
        "class_uri": "src/test/java/org/jsoup/parser/TokenQueue_consumeToAnyTest.java.TokenQueue_consumeToAnyTest",
        "attributes": {
            "modifiers": "@BeforeEach\n    public",
            "marker_annotations": [
                "@BeforeEach"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/parser/HtmlParserTest.java.HtmlParserTest.[Stream<Arguments>]dupeAttributeData()",
        "name": "dupeAttributeData",
        "arg_nums": 0,
        "params": [],
        "return_type": "Stream<Arguments>",
        "signature": "private static Stream<Arguments> dupeAttributeData()",
        "original_string": "    private static Stream<Arguments> dupeAttributeData() {\n        return Stream.of(\n            Arguments.of(\"<p One=One ONE=Two Two=two one=Three One=Four two=Five>Text</p>\", \"<p one=\\\"One\\\" two=\\\"two\\\">Text</p>\"),\n            Arguments.of(\"<img One=One ONE=Two Two=two one=Three One=Four two=Five>\", \"<img one=\\\"One\\\" two=\\\"two\\\">\"),\n            Arguments.of(\"<form One=One ONE=Two Two=two one=Three One=Four two=Five></form>\", \"<form one=\\\"One\\\" two=\\\"two\\\"></form>\")\n        );\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/parser/HtmlParserTest.java",
        "class_name": "HtmlParserTest",
        "class_uri": "src/test/java/org/jsoup/parser/HtmlParserTest.java.HtmlParserTest",
        "attributes": {
            "modifiers": "private static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "private",
                "static"
            ],
            "comments": [],
            "return_type": "Stream<Arguments>",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/parser/HtmlParserTest.java.HtmlParserTest.[boolean]didAddElements(String)",
        "name": "didAddElements",
        "arg_nums": 1,
        "params": [
            {
                "name": "input",
                "type": "String"
            }
        ],
        "return_type": "boolean",
        "signature": "private boolean didAddElements(String input)",
        "original_string": "    private boolean didAddElements(String input) {\n        // two passes, one as XML and one as HTML. XML does not vivify missing/optional tags\n        Document html = Jsoup.parse(input);\n        Document xml = Jsoup.parse(input, \"\", Parser.xmlParser());\n\n        int htmlElementCount = html.getAllElements().size();\n        int xmlElementCount = xml.getAllElements().size();\n        return htmlElementCount > xmlElementCount;\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/parser/HtmlParserTest.java",
        "class_name": "HtmlParserTest",
        "class_uri": "src/test/java/org/jsoup/parser/HtmlParserTest.java.HtmlParserTest",
        "attributes": {
            "modifiers": "private",
            "marker_annotations": [],
            "non_marker_annotations": [
                "private"
            ],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/parser/HtmlParserTest.java.HtmlParserTest.[void]assertHtmlNamespace(Element)",
        "name": "assertHtmlNamespace",
        "arg_nums": 1,
        "params": [
            {
                "name": "el",
                "type": "Element"
            }
        ],
        "return_type": "void",
        "signature": "private static void assertHtmlNamespace(Element el)",
        "original_string": "    private static void assertHtmlNamespace(Element el) {\n        assertEquals(Parser.NamespaceHtml, el.tag().namespace());\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/parser/HtmlParserTest.java",
        "class_name": "HtmlParserTest",
        "class_uri": "src/test/java/org/jsoup/parser/HtmlParserTest.java.HtmlParserTest",
        "attributes": {
            "modifiers": "private static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "private",
                "static"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/parser/HtmlParserTest.java.HtmlParserTest.[void]assertSvgNamespace(Element)",
        "name": "assertSvgNamespace",
        "arg_nums": 1,
        "params": [
            {
                "name": "el",
                "type": "Element"
            }
        ],
        "return_type": "void",
        "signature": "private static void assertSvgNamespace(Element el)",
        "original_string": "    private static void assertSvgNamespace(Element el) {\n        assertEquals(Parser.NamespaceSvg, el.tag().namespace());\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/parser/HtmlParserTest.java",
        "class_name": "HtmlParserTest",
        "class_uri": "src/test/java/org/jsoup/parser/HtmlParserTest.java.HtmlParserTest",
        "attributes": {
            "modifiers": "private static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "private",
                "static"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/parser/HtmlParserTest.java.HtmlParserTest.[void]assertMathNamespace(Element)",
        "name": "assertMathNamespace",
        "arg_nums": 1,
        "params": [
            {
                "name": "el",
                "type": "Element"
            }
        ],
        "return_type": "void",
        "signature": "private static void assertMathNamespace(Element el)",
        "original_string": "    private static void assertMathNamespace(Element el) {\n        assertEquals(Parser.NamespaceMathml, el.tag().namespace());\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/parser/HtmlParserTest.java",
        "class_name": "HtmlParserTest",
        "class_uri": "src/test/java/org/jsoup/parser/HtmlParserTest.java.HtmlParserTest",
        "attributes": {
            "modifiers": "private static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "private",
                "static"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/parser/XmlTreeBuilderTest.java.XmlTreeBuilderTest.[void]assertXmlNamespace(Element)",
        "name": "assertXmlNamespace",
        "arg_nums": 1,
        "params": [
            {
                "name": "el",
                "type": "Element"
            }
        ],
        "return_type": "void",
        "signature": "private static void assertXmlNamespace(Element el)",
        "original_string": "    private static void assertXmlNamespace(Element el) {\n        assertEquals(Parser.NamespaceXml, el.tag().namespace(), String.format(\"Element %s not in XML namespace\", el.tagName()));\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/parser/XmlTreeBuilderTest.java",
        "class_name": "XmlTreeBuilderTest",
        "class_uri": "src/test/java/org/jsoup/parser/XmlTreeBuilderTest.java.XmlTreeBuilderTest",
        "attributes": {
            "modifiers": "private static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "private",
                "static"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/parser/TokenQueue_consumeWhitespaceTest.java.TokenQueue_consumeWhitespaceTest.[void]setUp()",
        "name": "setUp",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "@BeforeEach\n    public void setUp()",
        "original_string": "    @BeforeEach\n    public void setUp() {\n        tokenQueue = new TokenQueue(\"  \\t\\n  test  \");\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/parser/TokenQueue_consumeWhitespaceTest.java",
        "class_name": "TokenQueue_consumeWhitespaceTest",
        "class_uri": "src/test/java/org/jsoup/parser/TokenQueue_consumeWhitespaceTest.java.TokenQueue_consumeWhitespaceTest",
        "attributes": {
            "modifiers": "@BeforeEach\n    public",
            "marker_annotations": [
                "@BeforeEach"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/parser/StreamParserTest.java.StreamParserTest.[void]trackSeen(Element,StringBuilder)",
        "name": "trackSeen",
        "arg_nums": 2,
        "params": [
            {
                "name": "el",
                "type": "Element"
            },
            {
                "name": "actual",
                "type": "StringBuilder"
            }
        ],
        "return_type": "void",
        "signature": "static void trackSeen(Element el, StringBuilder actual)",
        "original_string": "    static void trackSeen(Element el, StringBuilder actual) {\n        actual.append(el.tagName());\n        if (el.hasAttr(\"id\"))\n            actual.append(\"#\").append(el.id());\n        if (!el.ownText().isEmpty())\n            actual.append(\"[\").append(el.ownText()).append(\"]\");\n        if (el.nextElementSibling() != null)\n            actual.append(\"+\");\n\n        actual.append(\";\");\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/parser/StreamParserTest.java",
        "class_name": "StreamParserTest",
        "class_uri": "src/test/java/org/jsoup/parser/StreamParserTest.java.StreamParserTest",
        "attributes": {
            "modifiers": "static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "static"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/parser/StreamParserTest.java.StreamParserTest.[StreamParser]basic()",
        "name": "basic",
        "arg_nums": 0,
        "params": [],
        "return_type": "StreamParser",
        "signature": "static StreamParser basic()",
        "original_string": "    static StreamParser basic() {\n        String html = \"<div>One</div><div><p>Two</div>\";\n        StreamParser parser = new StreamParser(Parser.htmlParser()).parse(html, \"\");\n        parser.parse(html, \"\");\n        return parser;\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/parser/StreamParserTest.java",
        "class_name": "StreamParserTest",
        "class_uri": "src/test/java/org/jsoup/parser/StreamParserTest.java.StreamParserTest",
        "attributes": {
            "modifiers": "static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "static"
            ],
            "comments": [],
            "return_type": "StreamParser",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/parser/StreamParserTest.java.StreamParserTest.[boolean]isClosed(StreamParser)",
        "name": "isClosed",
        "arg_nums": 1,
        "params": [
            {
                "name": "streamer",
                "type": "StreamParser"
            }
        ],
        "return_type": "boolean",
        "signature": "static boolean isClosed(StreamParser streamer)",
        "original_string": "    static boolean isClosed(StreamParser streamer) {\n        // a bit of a back door in!\n        return getReader(streamer) == null;\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/parser/StreamParserTest.java",
        "class_name": "StreamParserTest",
        "class_uri": "src/test/java/org/jsoup/parser/StreamParserTest.java.StreamParserTest",
        "attributes": {
            "modifiers": "static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "static"
            ],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/parser/StreamParserTest.java.StreamParserTest.[CharacterReader]getReader(StreamParser)",
        "name": "getReader",
        "arg_nums": 1,
        "params": [
            {
                "name": "streamer",
                "type": "StreamParser"
            }
        ],
        "return_type": "CharacterReader",
        "signature": "private static CharacterReader getReader(StreamParser streamer)",
        "original_string": "     private static CharacterReader getReader(StreamParser streamer) {\n        return streamer.document().parser().getTreeBuilder().reader;\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/parser/StreamParserTest.java",
        "class_name": "StreamParserTest",
        "class_uri": "src/test/java/org/jsoup/parser/StreamParserTest.java.StreamParserTest",
        "attributes": {
            "modifiers": "private static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "private",
                "static"
            ],
            "comments": [],
            "return_type": "CharacterReader",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/parser/Parser_parseXmlFragmentTest.java.Parser_parseXmlFragmentTest.[void]setUp()",
        "name": "setUp",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "@BeforeEach\n    public void setUp()",
        "original_string": "    @BeforeEach\n    public void setUp() {\n        parser = new Parser(new XmlTreeBuilder());\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/parser/Parser_parseXmlFragmentTest.java",
        "class_name": "Parser_parseXmlFragmentTest",
        "class_uri": "src/test/java/org/jsoup/parser/Parser_parseXmlFragmentTest.java.Parser_parseXmlFragmentTest",
        "attributes": {
            "modifiers": "@BeforeEach\n    public",
            "marker_annotations": [
                "@BeforeEach"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/parser/PositionTest.java.PositionTest.[void]accumulatePositions(Node,StringBuilder)",
        "name": "accumulatePositions",
        "arg_nums": 2,
        "params": [
            {
                "name": "node",
                "type": "Node"
            },
            {
                "name": "sb",
                "type": "StringBuilder"
            }
        ],
        "return_type": "void",
        "signature": "static void accumulatePositions(Node node, StringBuilder sb)",
        "original_string": "    static void accumulatePositions(Node node, StringBuilder sb) {\n        sb\n            .append(node.nodeName())\n            .append(':')\n            .append(node.sourceRange().startPos())\n            .append('-')\n            .append(node.sourceRange().endPos());\n\n        if (node instanceof Element) {\n            Element el = (Element) node;\n            sb\n                .append(\"~\")\n                .append(el.endSourceRange().startPos())\n                .append('-')\n                .append(el.endSourceRange().endPos());\n        }\n        sb.append(\"; \");\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/parser/PositionTest.java",
        "class_name": "PositionTest",
        "class_uri": "src/test/java/org/jsoup/parser/PositionTest.java.PositionTest",
        "attributes": {
            "modifiers": "static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "static"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/parser/PositionTest.java.PositionTest.[void]printRange(Node)",
        "name": "printRange",
        "arg_nums": 1,
        "params": [
            {
                "name": "node",
                "type": "Node"
            }
        ],
        "return_type": "void",
        "signature": "private void printRange(Node node)",
        "original_string": "    private void printRange(Node node) {\n        if (node instanceof Element) {\n            Element el = (Element) node;\n            System.out.println(el.tagName() + \"\\t\"\n                + el.sourceRange().start().pos() + \"-\" + el.sourceRange().end().pos()\n                + \"\\t... \"\n                + el.endSourceRange().start().pos() + \"-\" + el.endSourceRange().end().pos()\n            );\n        } else {\n            System.out.println(node.nodeName() + \"\\t\"\n                + node.sourceRange().start().pos() + \"-\" + node.sourceRange().end().pos()\n            );\n        }\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/parser/PositionTest.java",
        "class_name": "PositionTest",
        "class_uri": "src/test/java/org/jsoup/parser/PositionTest.java.PositionTest",
        "attributes": {
            "modifiers": "private",
            "marker_annotations": [],
            "non_marker_annotations": [
                "private"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/parser/PositionTest.java.PositionTest.[void]accumulateAttributePositions(Node,StringBuilder)",
        "name": "accumulateAttributePositions",
        "arg_nums": 2,
        "params": [
            {
                "name": "node",
                "type": "Node"
            },
            {
                "name": "sb",
                "type": "StringBuilder"
            }
        ],
        "return_type": "void",
        "signature": "static void accumulateAttributePositions(Node node, StringBuilder sb)",
        "original_string": "    static void accumulateAttributePositions(Node node, StringBuilder sb) {\n        if (node instanceof LeafNode) return; // leafnode pseudo attributes are not tracked\n        for (Attribute attribute : node.attributes()) {\n            accumulatePositions(attribute, sb);\n        }\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/parser/PositionTest.java",
        "class_name": "PositionTest",
        "class_uri": "src/test/java/org/jsoup/parser/PositionTest.java.PositionTest",
        "attributes": {
            "modifiers": "static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "static"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/parser/PositionTest.java.PositionTest.[void]accumulatePositions(Attribute,StringBuilder)",
        "name": "accumulatePositions",
        "arg_nums": 2,
        "params": [
            {
                "name": "attr",
                "type": "Attribute"
            },
            {
                "name": "sb",
                "type": "StringBuilder"
            }
        ],
        "return_type": "void",
        "signature": "static void accumulatePositions(Attribute attr, StringBuilder sb)",
        "original_string": "    static void accumulatePositions(Attribute attr, StringBuilder sb) {\n        Range.AttributeRange range = attr.sourceRange();\n\n        sb\n            .append(attr.getKey())\n            .append(':')\n            .append(range.nameRange().startPos())\n            .append('-')\n            .append(range.nameRange().endPos())\n\n            .append('=')\n            .append(range.valueRange().startPos())\n            .append('-')\n            .append(range.valueRange().endPos());\n\n        sb.append(\"; \");\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/parser/PositionTest.java",
        "class_name": "PositionTest",
        "class_uri": "src/test/java/org/jsoup/parser/PositionTest.java.PositionTest",
        "attributes": {
            "modifiers": "static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "static"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/parser/Parser_setTrackPositionTest.java.Parser_setTrackPositionTest.[void]setUp()",
        "name": "setUp",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "@BeforeEach\n    public void setUp()",
        "original_string": "    @BeforeEach\n    public void setUp() {\n        parser = new Parser(new HtmlTreeBuilder());\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/parser/Parser_setTrackPositionTest.java",
        "class_name": "Parser_setTrackPositionTest",
        "class_uri": "src/test/java/org/jsoup/parser/Parser_setTrackPositionTest.java.Parser_setTrackPositionTest",
        "attributes": {
            "modifiers": "@BeforeEach\n    public",
            "marker_annotations": [
                "@BeforeEach"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/parser/TokenQueue_matchChompTest.java.TokenQueue_matchChompTest.[void]setUp()",
        "name": "setUp",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "@BeforeEach\n    public void setUp()",
        "original_string": "    @BeforeEach\n    public void setUp() {\n        tokenQueue = new TokenQueue(\"test sequence\");\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/parser/TokenQueue_matchChompTest.java",
        "class_name": "TokenQueue_matchChompTest",
        "class_uri": "src/test/java/org/jsoup/parser/TokenQueue_matchChompTest.java.TokenQueue_matchChompTest",
        "attributes": {
            "modifiers": "@BeforeEach\n    public",
            "marker_annotations": [
                "@BeforeEach"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/parser/TagTest.java.TagTest.[void]canBeInsensitive(Locale)",
        "name": "canBeInsensitive",
        "arg_nums": 1,
        "params": [
            {
                "name": "locale",
                "type": "Locale"
            }
        ],
        "return_type": "void",
        "signature": "@MultiLocaleTest\n    public void canBeInsensitive(Locale locale)",
        "original_string": "    @MultiLocaleTest\n    public void canBeInsensitive(Locale locale) {\n        Locale.setDefault(locale);\n\n        Tag script1 = Tag.valueOf(\"script\", ParseSettings.htmlDefault);\n        Tag script2 = Tag.valueOf(\"SCRIPT\", ParseSettings.htmlDefault);\n        assertSame(script1, script2);\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/parser/TagTest.java",
        "class_name": "TagTest",
        "class_uri": "src/test/java/org/jsoup/parser/TagTest.java.TagTest",
        "attributes": {
            "modifiers": "@MultiLocaleTest\n    public",
            "marker_annotations": [
                "@MultiLocaleTest"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/parser/Parser_setTrackErrorsTest.java.Parser_setTrackErrorsTest.[void]setUp()",
        "name": "setUp",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "@BeforeEach\n    public void setUp()",
        "original_string": "    @BeforeEach\n    public void setUp() {\n        parser = new Parser(new HtmlTreeBuilder());\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/parser/Parser_setTrackErrorsTest.java",
        "class_name": "Parser_setTrackErrorsTest",
        "class_uri": "src/test/java/org/jsoup/parser/Parser_setTrackErrorsTest.java.Parser_setTrackErrorsTest",
        "attributes": {
            "modifiers": "@BeforeEach\n    public",
            "marker_annotations": [
                "@BeforeEach"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/parser/Tag_valueOfTest.java.Tag_valueOfTest.[void]setUp()",
        "name": "setUp",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "@BeforeEach\n    public void setUp()",
        "original_string": "    @BeforeEach\n    public void setUp() {\n        settings = new ParseSettings(true, true);\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/parser/Tag_valueOfTest.java",
        "class_name": "Tag_valueOfTest",
        "class_uri": "src/test/java/org/jsoup/parser/Tag_valueOfTest.java.Tag_valueOfTest",
        "attributes": {
            "modifiers": "@BeforeEach\n    public",
            "marker_annotations": [
                "@BeforeEach"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/parser/TokenQueue_addFirstTest.java.TokenQueue_addFirstTest.[void]setUp()",
        "name": "setUp",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "@BeforeEach\n    public void setUp()",
        "original_string": "    @BeforeEach\n    public void setUp() {\n        tokenQueue = new TokenQueue(\"initialQueue\");\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/parser/TokenQueue_addFirstTest.java",
        "class_name": "TokenQueue_addFirstTest",
        "class_uri": "src/test/java/org/jsoup/parser/TokenQueue_addFirstTest.java.TokenQueue_addFirstTest",
        "attributes": {
            "modifiers": "@BeforeEach\n    public",
            "marker_annotations": [
                "@BeforeEach"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/parser/TokenQueue_consumeToIgnoreCaseTest.java.TokenQueue_consumeToIgnoreCaseTest.[void]setUp()",
        "name": "setUp",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "@BeforeEach\n    public void setUp()",
        "original_string": "    @BeforeEach\n    public void setUp() {\n        tokenQueue = new TokenQueue(\"TestStringForConsumeToIgnoreCase\");\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/parser/TokenQueue_consumeToIgnoreCaseTest.java",
        "class_name": "TokenQueue_consumeToIgnoreCaseTest",
        "class_uri": "src/test/java/org/jsoup/parser/TokenQueue_consumeToIgnoreCaseTest.java.TokenQueue_consumeToIgnoreCaseTest",
        "attributes": {
            "modifiers": "@BeforeEach\n    public",
            "marker_annotations": [
                "@BeforeEach"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/parser/TokenQueue_consumeToTest.java.TokenQueue_consumeToTest.[void]setUp()",
        "name": "setUp",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "@BeforeEach\n    public void setUp()",
        "original_string": "    @BeforeEach\n    public void setUp() {\n        tokenQueue = new TokenQueue(\"Hello World\");\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/parser/TokenQueue_consumeToTest.java",
        "class_name": "TokenQueue_consumeToTest",
        "class_uri": "src/test/java/org/jsoup/parser/TokenQueue_consumeToTest.java.TokenQueue_consumeToTest",
        "attributes": {
            "modifiers": "@BeforeEach\n    public",
            "marker_annotations": [
                "@BeforeEach"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/parser/TokenQueueTest.java.TokenQueueTest.[void]validateNestedQuotes(String,String)",
        "name": "validateNestedQuotes",
        "arg_nums": 2,
        "params": [
            {
                "name": "html",
                "type": "String"
            },
            {
                "name": "selector",
                "type": "String"
            }
        ],
        "return_type": "void",
        "signature": "private static void validateNestedQuotes(String html, String selector)",
        "original_string": "    private static void validateNestedQuotes(String html, String selector) {\n        assertEquals(\"#identifier\", Jsoup.parse(html).select(selector).first().cssSelector());\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/parser/TokenQueueTest.java",
        "class_name": "TokenQueueTest",
        "class_uri": "src/test/java/org/jsoup/parser/TokenQueueTest.java.TokenQueueTest",
        "attributes": {
            "modifiers": "private static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "private",
                "static"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/parser/TokenQueue_matchesAnyTest.java.TokenQueue_matchesAnyTest.[void]setUp()",
        "name": "setUp",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "@BeforeEach\n    public void setUp()",
        "original_string": "    @BeforeEach\n    public void setUp() {\n        tokenQueue = new TokenQueue(\"abc\");\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/parser/TokenQueue_matchesAnyTest.java",
        "class_name": "TokenQueue_matchesAnyTest",
        "class_uri": "src/test/java/org/jsoup/parser/TokenQueue_matchesAnyTest.java.TokenQueue_matchesAnyTest",
        "attributes": {
            "modifiers": "@BeforeEach\n    public",
            "marker_annotations": [
                "@BeforeEach"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/safety/Safelist_addTagsTest.java.Safelist_addTagsTest.[void]setUp()",
        "name": "setUp",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "@BeforeEach\n    public void setUp()",
        "original_string": "    @BeforeEach\n    public void setUp() {\n        safelist = new Safelist();\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/safety/Safelist_addTagsTest.java",
        "class_name": "Safelist_addTagsTest",
        "class_uri": "src/test/java/org/jsoup/safety/Safelist_addTagsTest.java.Safelist_addTagsTest",
        "attributes": {
            "modifiers": "@BeforeEach\n    public",
            "marker_annotations": [
                "@BeforeEach"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/safety/CleanerTest.java.CleanerTest.[void]safeListedProtocolShouldBeRetained(Locale)",
        "name": "safeListedProtocolShouldBeRetained",
        "arg_nums": 1,
        "params": [
            {
                "name": "locale",
                "type": "Locale"
            }
        ],
        "return_type": "void",
        "signature": "@MultiLocaleTest\n    public void safeListedProtocolShouldBeRetained(Locale locale)",
        "original_string": "    @MultiLocaleTest\n    public void safeListedProtocolShouldBeRetained(Locale locale) {\n        Locale.setDefault(locale);\n\n        Safelist safelist = Safelist.none()\n                .addTags(\"a\")\n                .addAttributes(\"a\", \"href\")\n                .addProtocols(\"a\", \"href\", \"something\");\n\n        String cleanHtml = Jsoup.clean(\"<a href=\\\"SOMETHING://x\\\"></a>\", safelist);\n\n        assertEquals(\"<a href=\\\"SOMETHING://x\\\"></a>\", TextUtil.stripNewlines(cleanHtml));\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/safety/CleanerTest.java",
        "class_name": "CleanerTest",
        "class_uri": "src/test/java/org/jsoup/safety/CleanerTest.java.CleanerTest",
        "attributes": {
            "modifiers": "@MultiLocaleTest\n    public",
            "marker_annotations": [
                "@MultiLocaleTest"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/safety/Safelist_removeAttributesTest.java.Safelist_removeAttributesTest.[void]setUp()",
        "name": "setUp",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "@BeforeEach\n    public void setUp()",
        "original_string": "    @BeforeEach\n    public void setUp() {\n        safelist = new Safelist();\n        safelist.addTags(\"a\", \"img\");\n        safelist.addAttributes(\"a\", \"href\", \"class\");\n        safelist.addAttributes(\"img\", \"src\", \"alt\");\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/safety/Safelist_removeAttributesTest.java",
        "class_name": "Safelist_removeAttributesTest",
        "class_uri": "src/test/java/org/jsoup/safety/Safelist_removeAttributesTest.java.Safelist_removeAttributesTest",
        "attributes": {
            "modifiers": "@BeforeEach\n    public",
            "marker_annotations": [
                "@BeforeEach"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/safety/Safelist_removeTagsTest.java.Safelist_removeTagsTest.[void]setUp()",
        "name": "setUp",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "@BeforeEach\n    public void setUp()",
        "original_string": "    @BeforeEach\n    public void setUp() {\n        safelist = new Safelist();\n        safelist.addTags(\"a\", \"b\", \"blockquote\", \"br\", \"cite\", \"code\", \"dd\", \"dl\", \"dt\", \"em\", \"i\", \"li\", \"ol\", \"p\", \"pre\", \"q\", \"small\", \"span\", \"strike\", \"strong\", \"sub\", \"sup\", \"u\", \"ul\");\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/safety/Safelist_removeTagsTest.java",
        "class_name": "Safelist_removeTagsTest",
        "class_uri": "src/test/java/org/jsoup/safety/Safelist_removeTagsTest.java.Safelist_removeTagsTest",
        "attributes": {
            "modifiers": "@BeforeEach\n    public",
            "marker_annotations": [
                "@BeforeEach"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/safety/Safelist_getEnforcedAttributesTest.java.Safelist_getEnforcedAttributesTest.[void]setUp()",
        "name": "setUp",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "@BeforeEach\n    public void setUp()",
        "original_string": "    @BeforeEach\n    public void setUp() {\n        safelist = new Safelist();\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/safety/Safelist_getEnforcedAttributesTest.java",
        "class_name": "Safelist_getEnforcedAttributesTest",
        "class_uri": "src/test/java/org/jsoup/safety/Safelist_getEnforcedAttributesTest.java.Safelist_getEnforcedAttributesTest",
        "attributes": {
            "modifiers": "@BeforeEach\n    public",
            "marker_annotations": [
                "@BeforeEach"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/safety/Safelist_relaxedTest.java.Safelist_relaxedTest.[void]setUp()",
        "name": "setUp",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "@BeforeEach\n    public void setUp()",
        "original_string": "    @BeforeEach\n    public void setUp() {\n        safelist = Safelist.relaxed();\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/safety/Safelist_relaxedTest.java",
        "class_name": "Safelist_relaxedTest",
        "class_uri": "src/test/java/org/jsoup/safety/Safelist_relaxedTest.java.Safelist_relaxedTest",
        "attributes": {
            "modifiers": "@BeforeEach\n    public",
            "marker_annotations": [
                "@BeforeEach"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/safety/Safelist_isSafeAttributeTest.java.Safelist_isSafeAttributeTest.[void]setUp()",
        "name": "setUp",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "@BeforeEach\n    public void setUp()",
        "original_string": "    @BeforeEach\n    public void setUp() {\n        safelist = new Safelist();\n        safelist.addTags(\"a\");\n        safelist.addAttributes(\"a\", \"href\");\n        safelist.addProtocols(\"a\", \"href\", \"http\", \"https\");\n\n        element = new Element(\"a\");\n        validAttribute = new Attribute(\"href\", \"http://example.com\");\n        invalidAttribute = new Attribute(\"href\", \"javascript:alert('xss')\");\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/safety/Safelist_isSafeAttributeTest.java",
        "class_name": "Safelist_isSafeAttributeTest",
        "class_uri": "src/test/java/org/jsoup/safety/Safelist_isSafeAttributeTest.java.Safelist_isSafeAttributeTest",
        "attributes": {
            "modifiers": "@BeforeEach\n    public",
            "marker_annotations": [
                "@BeforeEach"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/safety/Safelist_removeEnforcedAttributeTest.java.Safelist_removeEnforcedAttributeTest.[void]setUp()",
        "name": "setUp",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "@BeforeEach\n    public void setUp()",
        "original_string": "    @BeforeEach\n    public void setUp() {\n        safelist = new Safelist();\n        safelist.addTags(\"a\");\n        safelist.addEnforcedAttribute(\"a\", \"href\", \"http://example.com\");\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/safety/Safelist_removeEnforcedAttributeTest.java",
        "class_name": "Safelist_removeEnforcedAttributeTest",
        "class_uri": "src/test/java/org/jsoup/safety/Safelist_removeEnforcedAttributeTest.java.Safelist_removeEnforcedAttributeTest",
        "attributes": {
            "modifiers": "@BeforeEach\n    public",
            "marker_annotations": [
                "@BeforeEach"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/internal/SoftPool_borrowTest.java.SoftPool_borrowTest.[void]setUp()",
        "name": "setUp",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "@BeforeEach\n    public void setUp()",
        "original_string": "    @BeforeEach\n    public void setUp() {\n        softPool = new SoftPool<>(() -> new char[BufSize]);\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/internal/SoftPool_borrowTest.java",
        "class_name": "SoftPool_borrowTest",
        "class_uri": "src/test/java/org/jsoup/internal/SoftPool_borrowTest.java.SoftPool_borrowTest",
        "attributes": {
            "modifiers": "@BeforeEach\n    public",
            "marker_annotations": [
                "@BeforeEach"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/internal/SoftPool_releaseTest.java.SoftPool_releaseTest.[void]setUp()",
        "name": "setUp",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "@BeforeEach\n    public void setUp()",
        "original_string": "    @BeforeEach\n    public void setUp() {\n        softPool = new SoftPool<>(() -> new char[BufSize]);\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/internal/SoftPool_releaseTest.java",
        "class_name": "SoftPool_releaseTest",
        "class_uri": "src/test/java/org/jsoup/internal/SoftPool_releaseTest.java.SoftPool_releaseTest",
        "attributes": {
            "modifiers": "@BeforeEach\n    public",
            "marker_annotations": [
                "@BeforeEach"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/internal/StringUtil_joinTest.java.StringUtil_joinTest.[void]setUp()",
        "name": "setUp",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "@BeforeEach\n    public void setUp()",
        "original_string": "    @BeforeEach\n    public void setUp() {\n        // Any setup code if needed\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/internal/StringUtil_joinTest.java",
        "class_name": "StringUtil_joinTest",
        "class_uri": "src/test/java/org/jsoup/internal/StringUtil_joinTest.java.StringUtil_joinTest",
        "attributes": {
            "modifiers": "@BeforeEach\n    public",
            "marker_annotations": [
                "@BeforeEach"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/nodes/Element_removeClassTest.java.Element_removeClassTest.[void]setUp()",
        "name": "setUp",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "@BeforeEach\n    public void setUp()",
        "original_string": "    @BeforeEach\n    public void setUp() {\n        element = new Element(\"div\");\n        element.addClass(\"testClass\");\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/nodes/Element_removeClassTest.java",
        "class_name": "Element_removeClassTest",
        "class_uri": "src/test/java/org/jsoup/nodes/Element_removeClassTest.java.Element_removeClassTest",
        "attributes": {
            "modifiers": "@BeforeEach\n    public",
            "marker_annotations": [
                "@BeforeEach"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/nodes/BuildEntities.java.BuildEntities.[void]main(String[])",
        "name": "main",
        "arg_nums": 1,
        "params": [
            {
                "name": "args",
                "type": "String[]"
            }
        ],
        "return_type": "void",
        "signature": "public static void main(String[] args)",
        "original_string": "    public static void main(String[] args) throws IOException {\n        String url = \"https://www.w3.org/TR/2012/WD-html5-20121025/entities.json\";\n        Connection.Response res = Jsoup.connect(url)\n            .ignoreContentType(true)\n            .userAgent(UrlConnectTest.browserUa)\n            .execute();\n\n        Gson gson = new Gson();\n        Map<String, CharacterRef> input = gson.fromJson(res.body(),\n            new TypeToken<Map<String, CharacterRef>>() {\n            }.getType());\n\n\n        // build name sorted base and full character lists:\n        ArrayList<CharacterRef> base = new ArrayList<>();\n        ArrayList<CharacterRef> full = new ArrayList<>();\n\n        for (Map.Entry<String, CharacterRef> entry : input.entrySet()) {\n            String name = entry.getKey().substring(1); // name is like &acute or &acute; , trim &\n            CharacterRef ref = entry.getValue();\n            if (name.endsWith(\";\")) {\n                name = name.substring(0, name.length() - 1);\n                full.add(ref);\n            } else {\n                base.add(ref);\n            }\n            ref.name = name;\n        }\n        base.sort(byName);\n        full.sort(byName);\n\n        // now determine code point order\n        ArrayList<CharacterRef> baseByCode = new ArrayList<>(base);\n        ArrayList<CharacterRef> fullByCode = new ArrayList<>(full);\n        baseByCode.sort(byCode);\n        fullByCode.sort(byCode);\n\n        // and update their codepoint index.\n        @SuppressWarnings(\"unchecked\") ArrayList<CharacterRef>[] codelists = new ArrayList[]{baseByCode, fullByCode};\n        for (ArrayList<CharacterRef> codelist : codelists) {\n            for (int i = 0; i < codelist.size(); i++) {\n                codelist.get(i).codeIndex = i;\n            }\n        }\n\n        // now write them\n        persist(\"entities-full\", full);\n        persist(\"entities-base\", base);\n\n        System.out.println(\"Full size: \" + full.size() + \", base size: \" + base.size());\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/nodes/BuildEntities.java",
        "class_name": "BuildEntities",
        "class_uri": "src/test/java/org/jsoup/nodes/BuildEntities.java.BuildEntities",
        "attributes": {
            "modifiers": "public static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public",
                "static"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/nodes/BuildEntities.java.BuildEntities.[void]persist(String,ArrayList<CharacterRef>)",
        "name": "persist",
        "arg_nums": 2,
        "params": [
            {
                "name": "name",
                "type": "String"
            },
            {
                "name": "refs",
                "type": "ArrayList<CharacterRef>"
            }
        ],
        "return_type": "void",
        "signature": "private static void persist(String name, ArrayList<CharacterRef> refs)",
        "original_string": "    private static void persist(String name, ArrayList<CharacterRef> refs) throws IOException {\n        File file = Files.createTempFile(name, \".txt\").toFile();\n        FileWriter writer = new FileWriter(file, false);\n        writer.append(\"static final String points = \\\"\");\n        for (CharacterRef ref : refs) {\n            writer.append(ref.toString()).append('&');\n        }\n        writer.append(\"\\\";\\n\");\n        writer.close();\n\n        System.out.println(\"Wrote \" + name + \" to \" + file.getAbsolutePath());\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/nodes/BuildEntities.java",
        "class_name": "BuildEntities",
        "class_uri": "src/test/java/org/jsoup/nodes/BuildEntities.java.BuildEntities",
        "attributes": {
            "modifiers": "private static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "private",
                "static"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/nodes/BuildEntities.java.BuildEntities.[String]d(int)",
        "name": "d",
        "arg_nums": 1,
        "params": [
            {
                "name": "d",
                "type": "int"
            }
        ],
        "return_type": "String",
        "signature": "private static String d(int d)",
        "original_string": "    private static String d(int d) {\n        return Integer.toString(d, Entities.codepointRadix);\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/nodes/BuildEntities.java",
        "class_name": "BuildEntities",
        "class_uri": "src/test/java/org/jsoup/nodes/BuildEntities.java.BuildEntities",
        "attributes": {
            "modifiers": "private static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "private",
                "static"
            ],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/nodes/Attributes_toStringTest.java.Attributes_toStringTest.[void]setUp()",
        "name": "setUp",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "@BeforeEach\n    public void setUp()",
        "original_string": "    @BeforeEach\n    public void setUp() {\n        attributes = new Attributes();\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/nodes/Attributes_toStringTest.java",
        "class_name": "Attributes_toStringTest",
        "class_uri": "src/test/java/org/jsoup/nodes/Attributes_toStringTest.java.Attributes_toStringTest",
        "attributes": {
            "modifiers": "@BeforeEach\n    public",
            "marker_annotations": [
                "@BeforeEach"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/nodes/Document_textTest.java.Document_textTest.[void]setUp()",
        "name": "setUp",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "@BeforeEach\n    public void setUp()",
        "original_string": "    @BeforeEach\n    public void setUp() {\n        document = new Document(\"http://example.com\");\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/nodes/Document_textTest.java",
        "class_name": "Document_textTest",
        "class_uri": "src/test/java/org/jsoup/nodes/Document_textTest.java.Document_textTest",
        "attributes": {
            "modifiers": "@BeforeEach\n    public",
            "marker_annotations": [
                "@BeforeEach"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/nodes/Element_idTest.java.Element_idTest.[void]setUp()",
        "name": "setUp",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "@BeforeEach\n    public void setUp()",
        "original_string": "    @BeforeEach\n    public void setUp() {\n        element = new Element(\"div\");\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/nodes/Element_idTest.java",
        "class_name": "Element_idTest",
        "class_uri": "src/test/java/org/jsoup/nodes/Element_idTest.java.Element_idTest",
        "attributes": {
            "modifiers": "@BeforeEach\n    public",
            "marker_annotations": [
                "@BeforeEach"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/nodes/Comment_isXmlDeclarationTest.java.Comment_isXmlDeclarationTest.[void]setUp()",
        "name": "setUp",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "@BeforeEach\n    public void setUp()",
        "original_string": "    @BeforeEach\n    public void setUp() {\n        comment = new Comment(\"data\");\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/nodes/Comment_isXmlDeclarationTest.java",
        "class_name": "Comment_isXmlDeclarationTest",
        "class_uri": "src/test/java/org/jsoup/nodes/Comment_isXmlDeclarationTest.java.Comment_isXmlDeclarationTest",
        "attributes": {
            "modifiers": "@BeforeEach\n    public",
            "marker_annotations": [
                "@BeforeEach"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/nodes/Element_closestTest.java.Element_closestTest.[void]setUp()",
        "name": "setUp",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "@BeforeEach\n    public void setUp()",
        "original_string": "    @BeforeEach\n    public void setUp() {\n        String html = \"<body><div><p>One</p></div><div><p>Two</p></div><div>Three</div></body>\";\n        Document doc = Jsoup.parse(html);\n        element = doc.selectFirst(\"div\");\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/nodes/Element_closestTest.java",
        "class_name": "Element_closestTest",
        "class_uri": "src/test/java/org/jsoup/nodes/Element_closestTest.java.Element_closestTest",
        "attributes": {
            "modifiers": "@BeforeEach\n    public",
            "marker_annotations": [
                "@BeforeEach"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/nodes/Element_appendTextTest.java.Element_appendTextTest.[void]setUp()",
        "name": "setUp",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "@BeforeEach\n    public void setUp()",
        "original_string": "    @BeforeEach\n    public void setUp() {\n        element = new Element(\"div\");\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/nodes/Element_appendTextTest.java",
        "class_name": "Element_appendTextTest",
        "class_uri": "src/test/java/org/jsoup/nodes/Element_appendTextTest.java.Element_appendTextTest",
        "attributes": {
            "modifiers": "@BeforeEach\n    public",
            "marker_annotations": [
                "@BeforeEach"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/nodes/Attributes_getTest.java.Attributes_getTest.[void]setUp()",
        "name": "setUp",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "@BeforeEach\n    public void setUp()",
        "original_string": "    @BeforeEach\n    public void setUp() {\n        attributes = new Attributes();\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/nodes/Attributes_getTest.java",
        "class_name": "Attributes_getTest",
        "class_uri": "src/test/java/org/jsoup/nodes/Attributes_getTest.java.Attributes_getTest",
        "attributes": {
            "modifiers": "@BeforeEach\n    public",
            "marker_annotations": [
                "@BeforeEach"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/nodes/Attributes_attributeTest.java.Attributes_attributeTest.[void]setUp()",
        "name": "setUp",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "@BeforeEach\n    public void setUp()",
        "original_string": "    @BeforeEach\n    public void setUp() {\n        attributes = new Attributes();\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/nodes/Attributes_attributeTest.java",
        "class_name": "Attributes_attributeTest",
        "class_uri": "src/test/java/org/jsoup/nodes/Attributes_attributeTest.java.Attributes_attributeTest",
        "attributes": {
            "modifiers": "@BeforeEach\n    public",
            "marker_annotations": [
                "@BeforeEach"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/nodes/FormElement_formDataTest.java.FormElement_formDataTest.[void]setUp()",
        "name": "setUp",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "@BeforeEach\n    public void setUp()",
        "original_string": "    @BeforeEach\n    public void setUp() {\n        formElement = new FormElement(org.jsoup.parser.Tag.valueOf(\"form\"), \"http://example.com\", null);\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/nodes/FormElement_formDataTest.java",
        "class_name": "FormElement_formDataTest",
        "class_uri": "src/test/java/org/jsoup/nodes/FormElement_formDataTest.java.FormElement_formDataTest",
        "attributes": {
            "modifiers": "@BeforeEach\n    public",
            "marker_annotations": [
                "@BeforeEach"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/nodes/Document_shallowCloneTest.java.Document_shallowCloneTest.[void]setUp()",
        "name": "setUp",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "@BeforeEach\n    public void setUp()",
        "original_string": "    @BeforeEach\n    public void setUp() {\n        originalDocument = new Document(\"http://example.com\");\n        originalDocument.outputSettings().charset(\"UTF-8\");\n        originalDocument.attributes = new Attributes();\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/nodes/Document_shallowCloneTest.java",
        "class_name": "Document_shallowCloneTest",
        "class_uri": "src/test/java/org/jsoup/nodes/Document_shallowCloneTest.java.Document_shallowCloneTest",
        "attributes": {
            "modifiers": "@BeforeEach\n    public",
            "marker_annotations": [
                "@BeforeEach"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/nodes/Element_removeAttrTest.java.Element_removeAttrTest.[void]setUp()",
        "name": "setUp",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "@BeforeEach\n    public void setUp()",
        "original_string": "    @BeforeEach\n    public void setUp() {\n        element = new Element(\"div\");\n        element.attr(\"testAttr\", \"testValue\");\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/nodes/Element_removeAttrTest.java",
        "class_name": "Element_removeAttrTest",
        "class_uri": "src/test/java/org/jsoup/nodes/Element_removeAttrTest.java.Element_removeAttrTest",
        "attributes": {
            "modifiers": "@BeforeEach\n    public",
            "marker_annotations": [
                "@BeforeEach"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/nodes/NodeIterator_hasNextTest.java.NodeIterator_hasNextTest.[void]setUp()",
        "name": "setUp",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "@BeforeEach\n    public void setUp()",
        "original_string": "    @BeforeEach\n    public void setUp() {\n        String html = \"<div id=out1><div id=1><p>One<p>Two</div><div id=2><p>Three<p>Four</div></div><div id=out2>Out2\";\n        Document doc = Jsoup.parse(html);\n        rootNode = doc;\n        nodeIterator = new NodeIterator<>(rootNode, Node.class);\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/nodes/NodeIterator_hasNextTest.java",
        "class_name": "NodeIterator_hasNextTest",
        "class_uri": "src/test/java/org/jsoup/nodes/NodeIterator_hasNextTest.java.NodeIterator_hasNextTest",
        "attributes": {
            "modifiers": "@BeforeEach\n    public",
            "marker_annotations": [
                "@BeforeEach"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/nodes/Element_traverseTest.java.Element_traverseTest.[void]setUp()",
        "name": "setUp",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "@BeforeEach\n    public void setUp()",
        "original_string": "    @BeforeEach\n    public void setUp() {\n        String html = \"<body><div><p>One</p></div></body>\";\n        Document doc = Jsoup.parse(html);\n        element = doc.selectFirst(\"div\");\n        assertNotNull(element);\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/nodes/Element_traverseTest.java",
        "class_name": "Element_traverseTest",
        "class_uri": "src/test/java/org/jsoup/nodes/Element_traverseTest.java.Element_traverseTest",
        "attributes": {
            "modifiers": "@BeforeEach\n    public",
            "marker_annotations": [
                "@BeforeEach"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/nodes/Entities_getByNameTest.java.Entities_getByNameTest.[void]setUp()",
        "name": "setUp",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "@BeforeEach\n    public void setUp()",
        "original_string": "    @BeforeEach\n    public void setUp() {\n        // Initialize any necessary setup for the tests\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/nodes/Entities_getByNameTest.java",
        "class_name": "Entities_getByNameTest",
        "class_uri": "src/test/java/org/jsoup/nodes/Entities_getByNameTest.java.Entities_getByNameTest",
        "attributes": {
            "modifiers": "@BeforeEach\n    public",
            "marker_annotations": [
                "@BeforeEach"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/nodes/Element_nextElementSiblingTest.java.Element_nextElementSiblingTest.[void]setUp()",
        "name": "setUp",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "@BeforeEach\n    public void setUp()",
        "original_string": "    @BeforeEach\n    public void setUp() {\n        parentElement = new Element(\"div\");\n        element = new Element(\"div\");\n        siblingElement = new Element(\"span\");\n        parentElement.appendChild(element);\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/nodes/Element_nextElementSiblingTest.java",
        "class_name": "Element_nextElementSiblingTest",
        "class_uri": "src/test/java/org/jsoup/nodes/Element_nextElementSiblingTest.java.Element_nextElementSiblingTest",
        "attributes": {
            "modifiers": "@BeforeEach\n    public",
            "marker_annotations": [
                "@BeforeEach"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/nodes/LeafNodeTest.java.LeafNodeTest.[boolean]hasAnyAttributes(Node)",
        "name": "hasAnyAttributes",
        "arg_nums": 1,
        "params": [
            {
                "name": "node",
                "type": "Node"
            }
        ],
        "return_type": "boolean",
        "signature": "private boolean hasAnyAttributes(Node node)",
        "original_string": "    private boolean hasAnyAttributes(Node node) {\n        final boolean[] found = new boolean[1];\n        node.filter(new NodeFilter() {\n            @Override\n            public FilterResult head(Node node, int depth) {\n                if (node.hasAttributes()) {\n                    found[0] = true;\n                    return FilterResult.STOP;\n                } else {\n                    return FilterResult.CONTINUE;\n                }\n            }\n\n            @Override\n            public FilterResult tail(Node node, int depth) {\n                return FilterResult.CONTINUE;\n            }\n        });\n        return found[0];\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/nodes/LeafNodeTest.java",
        "class_name": "LeafNodeTest",
        "class_uri": "src/test/java/org/jsoup/nodes/LeafNodeTest.java.LeafNodeTest",
        "attributes": {
            "modifiers": "private",
            "marker_annotations": [],
            "non_marker_annotations": [
                "private"
            ],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/nodes/TextNode_toStringTest.java.TextNode_toStringTest.[void]setUp()",
        "name": "setUp",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "@BeforeEach\n    public void setUp()",
        "original_string": "    @BeforeEach\n    public void setUp() {\n        textNode = new TextNode(\"Hello &<> \u00c5 \u00e5 \u03c0 \u65b0 there \u00be \u00a9 \u00bb ' \\\"\");\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/nodes/TextNode_toStringTest.java",
        "class_name": "TextNode_toStringTest",
        "class_uri": "src/test/java/org/jsoup/nodes/TextNode_toStringTest.java.TextNode_toStringTest",
        "attributes": {
            "modifiers": "@BeforeEach\n    public",
            "marker_annotations": [
                "@BeforeEach"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/nodes/Element_lastElementSiblingTest.java.Element_lastElementSiblingTest.[void]setUp()",
        "name": "setUp",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "@BeforeEach\n    public void setUp()",
        "original_string": "    @BeforeEach\n    public void setUp() {\n        parent = new Element(\"parent\");\n        child1 = new Element(\"child1\");\n        child2 = new Element(\"child2\");\n        parent.appendChild(child1);\n        parent.appendChild(child2);\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/nodes/Element_lastElementSiblingTest.java",
        "class_name": "Element_lastElementSiblingTest",
        "class_uri": "src/test/java/org/jsoup/nodes/Element_lastElementSiblingTest.java.Element_lastElementSiblingTest",
        "attributes": {
            "modifiers": "@BeforeEach\n    public",
            "marker_annotations": [
                "@BeforeEach"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/nodes/Attributes_sizeTest.java.Attributes_sizeTest.[void]setUp()",
        "name": "setUp",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "@BeforeEach\n    public void setUp()",
        "original_string": "    @BeforeEach\n    public void setUp() {\n        attributes = new Attributes();\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/nodes/Attributes_sizeTest.java",
        "class_name": "Attributes_sizeTest",
        "class_uri": "src/test/java/org/jsoup/nodes/Attributes_sizeTest.java.Attributes_sizeTest",
        "attributes": {
            "modifiers": "@BeforeEach\n    public",
            "marker_annotations": [
                "@BeforeEach"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/nodes/Attributes_removeTest.java.Attributes_removeTest.[void]setUp()",
        "name": "setUp",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "@BeforeEach\n    public void setUp()",
        "original_string": "    @BeforeEach\n    public void setUp() {\n        attributes = new Attributes();\n        attributes.add(\"key1\", \"value1\");\n        attributes.add(\"key2\", \"value2\");\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/nodes/Attributes_removeTest.java",
        "class_name": "Attributes_removeTest",
        "class_uri": "src/test/java/org/jsoup/nodes/Attributes_removeTest.java.Attributes_removeTest",
        "attributes": {
            "modifiers": "@BeforeEach\n    public",
            "marker_annotations": [
                "@BeforeEach"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/nodes/Attributes_putTest.java.Attributes_putTest.[void]setUp()",
        "name": "setUp",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "@BeforeEach\n    public void setUp()",
        "original_string": "    @BeforeEach\n    public void setUp() {\n        attributes = new Attributes();\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/nodes/Attributes_putTest.java",
        "class_name": "Attributes_putTest",
        "class_uri": "src/test/java/org/jsoup/nodes/Attributes_putTest.java.Attributes_putTest",
        "attributes": {
            "modifiers": "@BeforeEach\n    public",
            "marker_annotations": [
                "@BeforeEach"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/nodes/Attributes_normalizeTest.java.Attributes_normalizeTest.[void]setUp()",
        "name": "setUp",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "@BeforeEach\n    public void setUp()",
        "original_string": "    @BeforeEach\n    public void setUp() {\n        attributes = new Attributes();\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/nodes/Attributes_normalizeTest.java",
        "class_name": "Attributes_normalizeTest",
        "class_uri": "src/test/java/org/jsoup/nodes/Attributes_normalizeTest.java.Attributes_normalizeTest",
        "attributes": {
            "modifiers": "@BeforeEach\n    public",
            "marker_annotations": [
                "@BeforeEach"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/nodes/TextNode_textTest.java.TextNode_textTest.[void]setUp()",
        "name": "setUp",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "@BeforeEach\n    public void setUp()",
        "original_string": "    @BeforeEach\n    public void setUp() {\n        textNode = new TextNode(\"\");\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/nodes/TextNode_textTest.java",
        "class_name": "TextNode_textTest",
        "class_uri": "src/test/java/org/jsoup/nodes/TextNode_textTest.java.TextNode_textTest",
        "attributes": {
            "modifiers": "@BeforeEach\n    public",
            "marker_annotations": [
                "@BeforeEach"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/nodes/Element_prependTextTest.java.Element_prependTextTest.[void]setUp()",
        "name": "setUp",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "@BeforeEach\n    public void setUp()",
        "original_string": "    @BeforeEach\n    public void setUp() {\n        element = new Element(\"div\");\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/nodes/Element_prependTextTest.java",
        "class_name": "Element_prependTextTest",
        "class_uri": "src/test/java/org/jsoup/nodes/Element_prependTextTest.java.Element_prependTextTest",
        "attributes": {
            "modifiers": "@BeforeEach\n    public",
            "marker_annotations": [
                "@BeforeEach"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/nodes/Attributes_iteratorTest.java.Attributes_iteratorTest.[void]setUp()",
        "name": "setUp",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "@BeforeEach\n    public void setUp()",
        "original_string": "    @BeforeEach\n    public void setUp() {\n        attributes = new Attributes();\n        attributes.put(\"key1\", \"value1\");\n        attributes.put(\"key2\", \"value2\");\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/nodes/Attributes_iteratorTest.java",
        "class_name": "Attributes_iteratorTest",
        "class_uri": "src/test/java/org/jsoup/nodes/Attributes_iteratorTest.java.Attributes_iteratorTest",
        "attributes": {
            "modifiers": "@BeforeEach\n    public",
            "marker_annotations": [
                "@BeforeEach"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/nodes/Document_documentTypeTest.java.Document_documentTypeTest.[void]setUp()",
        "name": "setUp",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "@BeforeEach\n    public void setUp()",
        "original_string": "    @BeforeEach\n    public void setUp() {\n        document = new Document(\"http://example.com\");\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/nodes/Document_documentTypeTest.java",
        "class_name": "Document_documentTypeTest",
        "class_uri": "src/test/java/org/jsoup/nodes/Document_documentTypeTest.java.Document_documentTypeTest",
        "attributes": {
            "modifiers": "@BeforeEach\n    public",
            "marker_annotations": [
                "@BeforeEach"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/nodes/Element_addClassTest.java.Element_addClassTest.[void]setUp()",
        "name": "setUp",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "@BeforeEach\n    public void setUp()",
        "original_string": "    @BeforeEach\n    public void setUp() {\n        element = new Element(\"div\");\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/nodes/Element_addClassTest.java",
        "class_name": "Element_addClassTest",
        "class_uri": "src/test/java/org/jsoup/nodes/Element_addClassTest.java.Element_addClassTest",
        "attributes": {
            "modifiers": "@BeforeEach\n    public",
            "marker_annotations": [
                "@BeforeEach"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/nodes/Element_appendChildTest.java.Element_appendChildTest.[void]setUp()",
        "name": "setUp",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "@BeforeEach\n    public void setUp()",
        "original_string": "    @BeforeEach\n    public void setUp() {\n        element = new Element(\"div\");\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/nodes/Element_appendChildTest.java",
        "class_name": "Element_appendChildTest",
        "class_uri": "src/test/java/org/jsoup/nodes/Element_appendChildTest.java.Element_appendChildTest",
        "attributes": {
            "modifiers": "@BeforeEach\n    public",
            "marker_annotations": [
                "@BeforeEach"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/nodes/Element_classNamesTest.java.Element_classNamesTest.[void]setUp()",
        "name": "setUp",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "@BeforeEach\n    public void setUp()",
        "original_string": "    @BeforeEach\n    public void setUp() {\n        element = new Element(\"div\");\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/nodes/Element_classNamesTest.java",
        "class_name": "Element_classNamesTest",
        "class_uri": "src/test/java/org/jsoup/nodes/Element_classNamesTest.java.Element_classNamesTest",
        "attributes": {
            "modifiers": "@BeforeEach\n    public",
            "marker_annotations": [
                "@BeforeEach"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/nodes/NodeTest.java.NodeTest.[Attributes]getAttributesCaseInsensitive(Element)",
        "name": "getAttributesCaseInsensitive",
        "arg_nums": 1,
        "params": [
            {
                "name": "element",
                "type": "Element"
            }
        ],
        "return_type": "Attributes",
        "signature": "private Attributes getAttributesCaseInsensitive(Element element)",
        "original_string": "    private Attributes getAttributesCaseInsensitive(Element element) {\n        Attributes matches = new Attributes();\n        for (Attribute attribute : element.attributes()) {\n            if (attribute.getKey().equalsIgnoreCase(\"value\")) {\n                matches.put(attribute);\n            }\n        }\n        return matches;\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/nodes/NodeTest.java",
        "class_name": "NodeTest",
        "class_uri": "src/test/java/org/jsoup/nodes/NodeTest.java.NodeTest",
        "attributes": {
            "modifiers": "private",
            "marker_annotations": [],
            "non_marker_annotations": [
                "private"
            ],
            "comments": [],
            "return_type": "Attributes",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/nodes/NodeTest.java.NodeTest.[Attributes]singletonAttributes()",
        "name": "singletonAttributes",
        "arg_nums": 0,
        "params": [],
        "return_type": "Attributes",
        "signature": "private Attributes singletonAttributes()",
        "original_string": "    private Attributes singletonAttributes() {\n        Attributes attributes = new Attributes();\n        attributes.put(\"value\", \"bar\");\n        return attributes;\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/nodes/NodeTest.java",
        "class_name": "NodeTest",
        "class_uri": "src/test/java/org/jsoup/nodes/NodeTest.java.NodeTest",
        "attributes": {
            "modifiers": "private",
            "marker_annotations": [],
            "non_marker_annotations": [
                "private"
            ],
            "comments": [],
            "return_type": "Attributes",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/nodes/Element_lastElementChildTest.java.Element_lastElementChildTest.[void]setUp()",
        "name": "setUp",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "@BeforeEach\n    public void setUp()",
        "original_string": "    @BeforeEach\n    public void setUp() {\n        element = new Element(\"div\");\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/nodes/Element_lastElementChildTest.java",
        "class_name": "Element_lastElementChildTest",
        "class_uri": "src/test/java/org/jsoup/nodes/Element_lastElementChildTest.java.Element_lastElementChildTest",
        "attributes": {
            "modifiers": "@BeforeEach\n    public",
            "marker_annotations": [
                "@BeforeEach"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/nodes/Element_parentTest.java.Element_parentTest.[void]setUp()",
        "name": "setUp",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "@BeforeEach\n    public void setUp()",
        "original_string": "    @BeforeEach\n    public void setUp() {\n        element = new Element(\"div\");\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/nodes/Element_parentTest.java",
        "class_name": "Element_parentTest",
        "class_uri": "src/test/java/org/jsoup/nodes/Element_parentTest.java.Element_parentTest",
        "attributes": {
            "modifiers": "@BeforeEach\n    public",
            "marker_annotations": [
                "@BeforeEach"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/nodes/Attributes_cloneTest.java.Attributes_cloneTest.[void]setUp()",
        "name": "setUp",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "@BeforeEach\n    public void setUp()",
        "original_string": "    @BeforeEach\n    public void setUp() {\n        attributes = new Attributes();\n        attributes.put(\"key1\", \"value1\");\n        attributes.put(\"key2\", \"value2\");\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/nodes/Attributes_cloneTest.java",
        "class_name": "Attributes_cloneTest",
        "class_uri": "src/test/java/org/jsoup/nodes/Attributes_cloneTest.java.Attributes_cloneTest",
        "attributes": {
            "modifiers": "@BeforeEach\n    public",
            "marker_annotations": [
                "@BeforeEach"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/nodes/Attributes_hasDeclaredValueForKeyTest.java.Attributes_hasDeclaredValueForKeyTest.[void]setUp()",
        "name": "setUp",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "@BeforeEach\n    public void setUp()",
        "original_string": "    @BeforeEach\n    public void setUp() {\n        attributes = new Attributes();\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/nodes/Attributes_hasDeclaredValueForKeyTest.java",
        "class_name": "Attributes_hasDeclaredValueForKeyTest",
        "class_uri": "src/test/java/org/jsoup/nodes/Attributes_hasDeclaredValueForKeyTest.java.Attributes_hasDeclaredValueForKeyTest",
        "attributes": {
            "modifiers": "@BeforeEach\n    public",
            "marker_annotations": [
                "@BeforeEach"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/nodes/DocumentTest.java.DocumentTest.[Document]createHtmlDocument(String)",
        "name": "createHtmlDocument",
        "arg_nums": 1,
        "params": [
            {
                "name": "charset",
                "type": "String"
            }
        ],
        "return_type": "Document",
        "signature": "private Document createHtmlDocument(String charset)",
        "original_string": "    private Document createHtmlDocument(String charset) {\n        final Document doc = Document.createShell(\"\");\n        doc.head().appendElement(\"meta\").attr(\"charset\", charset);\n        doc.head().appendElement(\"meta\").attr(\"name\", \"charset\").attr(\"content\", charset);\n\n        return doc;\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/nodes/DocumentTest.java",
        "class_name": "DocumentTest",
        "class_uri": "src/test/java/org/jsoup/nodes/DocumentTest.java.DocumentTest",
        "attributes": {
            "modifiers": "private",
            "marker_annotations": [],
            "non_marker_annotations": [
                "private"
            ],
            "comments": [],
            "return_type": "Document",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/nodes/DocumentTest.java.DocumentTest.[Document]createXmlDocument(String,String,boolean)",
        "name": "createXmlDocument",
        "arg_nums": 3,
        "params": [
            {
                "name": "version",
                "type": "String"
            },
            {
                "name": "charset",
                "type": "String"
            },
            {
                "name": "addDecl",
                "type": "boolean"
            }
        ],
        "return_type": "Document",
        "signature": "private Document createXmlDocument(String version, String charset, boolean addDecl)",
        "original_string": "    private Document createXmlDocument(String version, String charset, boolean addDecl) {\n        final Document doc = new Document(\"\");\n        doc.appendElement(\"root\").text(\"node\");\n        doc.outputSettings().syntax(Syntax.xml);\n\n        if(addDecl) {\n            XmlDeclaration decl = new XmlDeclaration(\"xml\", false);\n            decl.attr(\"version\", version);\n            decl.attr(\"encoding\", charset);\n            doc.prependChild(decl);\n        }\n\n        return doc;\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/nodes/DocumentTest.java",
        "class_name": "DocumentTest",
        "class_uri": "src/test/java/org/jsoup/nodes/DocumentTest.java.DocumentTest",
        "attributes": {
            "modifiers": "private",
            "marker_annotations": [],
            "non_marker_annotations": [
                "private"
            ],
            "comments": [],
            "return_type": "Document",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/nodes/NodeIteratorTest.java.NodeIteratorTest.[void]assertIterates(NodeIterator<T>,String)",
        "name": "assertIterates",
        "arg_nums": 2,
        "params": [
            {
                "name": "it",
                "type": "NodeIterator<T>"
            },
            {
                "name": "expected",
                "type": "String"
            }
        ],
        "return_type": "void",
        "signature": "static <T extends Node> void assertIterates(NodeIterator<T> it, String expected)",
        "original_string": "    static <T extends Node> void assertIterates(NodeIterator<T> it, String expected) {\n        Node previous = null;\n        StringBuilder actual = new StringBuilder();\n        while (it.hasNext()) {\n            Node node = it.next();\n            assertNotNull(node);\n            assertNotSame(previous, node);\n\n            trackSeen(node, actual);\n            previous = node;\n        }\n        assertEquals(expected, actual.toString());\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/nodes/NodeIteratorTest.java",
        "class_name": "NodeIteratorTest",
        "class_uri": "src/test/java/org/jsoup/nodes/NodeIteratorTest.java.NodeIteratorTest",
        "attributes": {
            "modifiers": "static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "static"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/nodes/NodeIteratorTest.java.NodeIteratorTest.[void]assertContents(Element,String)",
        "name": "assertContents",
        "arg_nums": 2,
        "params": [
            {
                "name": "el",
                "type": "Element"
            },
            {
                "name": "expected",
                "type": "String"
            }
        ],
        "return_type": "void",
        "signature": "static void assertContents(Element el, String expected)",
        "original_string": "    static void assertContents(Element el, String expected) {\n        NodeIterator<Node> it = NodeIterator.from(el);\n        assertIterates(it, expected);\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/nodes/NodeIteratorTest.java",
        "class_name": "NodeIteratorTest",
        "class_uri": "src/test/java/org/jsoup/nodes/NodeIteratorTest.java.NodeIteratorTest",
        "attributes": {
            "modifiers": "static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "static"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/nodes/NodeIteratorTest.java.NodeIteratorTest.[void]trackSeen(Node,StringBuilder)",
        "name": "trackSeen",
        "arg_nums": 2,
        "params": [
            {
                "name": "node",
                "type": "Node"
            },
            {
                "name": "actual",
                "type": "StringBuilder"
            }
        ],
        "return_type": "void",
        "signature": "static void trackSeen(Node node, StringBuilder actual)",
        "original_string": "    static void trackSeen(Node node, StringBuilder actual) {\n        if (node instanceof Element) {\n            Element el = (Element) node;\n            actual.append(el.tagName());\n            if (el.hasAttr(\"id\"))\n                actual.append(\"#\").append(el.id());\n        }\n        else if (node instanceof TextNode)\n            actual.append(((TextNode) node).text());\n        else\n            actual.append(node.nodeName());\n        actual.append(\";\");\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/nodes/NodeIteratorTest.java",
        "class_name": "NodeIteratorTest",
        "class_uri": "src/test/java/org/jsoup/nodes/NodeIteratorTest.java.NodeIteratorTest",
        "attributes": {
            "modifiers": "static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "static"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/nodes/Attributes_addAllTest.java.Attributes_addAllTest.[void]setUp()",
        "name": "setUp",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "@BeforeEach\n    public void setUp()",
        "original_string": "    @BeforeEach\n    public void setUp() {\n        attributes = new Attributes();\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/nodes/Attributes_addAllTest.java",
        "class_name": "Attributes_addAllTest",
        "class_uri": "src/test/java/org/jsoup/nodes/Attributes_addAllTest.java.Attributes_addAllTest",
        "attributes": {
            "modifiers": "@BeforeEach\n    public",
            "marker_annotations": [
                "@BeforeEach"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/nodes/Attribute_setKeyTest.java.Attribute_setKeyTest.[void]setUp()",
        "name": "setUp",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "@BeforeEach\n    public void setUp()",
        "original_string": "    @BeforeEach\n    public void setUp() {\n        parent = new Attributes();\n        attribute = new Attribute(\"oldKey\", \"oldValue\", parent);\n        parent.put(\"oldKey\", \"oldValue\");\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/nodes/Attribute_setKeyTest.java",
        "class_name": "Attribute_setKeyTest",
        "class_uri": "src/test/java/org/jsoup/nodes/Attribute_setKeyTest.java.Attribute_setKeyTest",
        "attributes": {
            "modifiers": "@BeforeEach\n    public",
            "marker_annotations": [
                "@BeforeEach"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/nodes/Element_ownTextTest.java.Element_ownTextTest.[void]setUp()",
        "name": "setUp",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "@BeforeEach\n    public void setUp()",
        "original_string": "    @BeforeEach\n    public void setUp() {\n        element = new Element(\"div\");\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/nodes/Element_ownTextTest.java",
        "class_name": "Element_ownTextTest",
        "class_uri": "src/test/java/org/jsoup/nodes/Element_ownTextTest.java.Element_ownTextTest",
        "attributes": {
            "modifiers": "@BeforeEach\n    public",
            "marker_annotations": [
                "@BeforeEach"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/nodes/Element_getElementsByAttributeTest.java.Element_getElementsByAttributeTest.[void]setUp()",
        "name": "setUp",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "@BeforeEach\n    public void setUp()",
        "original_string": "    @BeforeEach\n    public void setUp() {\n        String html = \"<div id='test' class='test-class' data-attr='test-value'></div>\";\n        Document doc = Jsoup.parse(html);\n        element = doc.body().child(0);\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/nodes/Element_getElementsByAttributeTest.java",
        "class_name": "Element_getElementsByAttributeTest",
        "class_uri": "src/test/java/org/jsoup/nodes/Element_getElementsByAttributeTest.java.Element_getElementsByAttributeTest",
        "attributes": {
            "modifiers": "@BeforeEach\n    public",
            "marker_annotations": [
                "@BeforeEach"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/nodes/Element_forEachNodeTest.java.Element_forEachNodeTest.[void]setUp()",
        "name": "setUp",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "@BeforeEach\n    public void setUp()",
        "original_string": "    @BeforeEach\n    public void setUp() {\n        Document doc = Jsoup.parse(\"<div><p>1<p>2<p>3</div>\");\n        element = doc.body().child(0);\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/nodes/Element_forEachNodeTest.java",
        "class_name": "Element_forEachNodeTest",
        "class_uri": "src/test/java/org/jsoup/nodes/Element_forEachNodeTest.java.Element_forEachNodeTest",
        "attributes": {
            "modifiers": "@BeforeEach\n    public",
            "marker_annotations": [
                "@BeforeEach"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/nodes/Element_normalNameTest.java.Element_normalNameTest.[void]setUp()",
        "name": "setUp",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "@BeforeEach\n    public void setUp()",
        "original_string": "    @BeforeEach\n    public void setUp() {\n        element = new Element(Tag.valueOf(\"div\"), \"\");\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/nodes/Element_normalNameTest.java",
        "class_name": "Element_normalNameTest",
        "class_uri": "src/test/java/org/jsoup/nodes/Element_normalNameTest.java.Element_normalNameTest",
        "attributes": {
            "modifiers": "@BeforeEach\n    public",
            "marker_annotations": [
                "@BeforeEach"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/nodes/Document_headTest.java.Document_headTest.[void]setUp()",
        "name": "setUp",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "@BeforeEach\n    public void setUp()",
        "original_string": "    @BeforeEach\n    public void setUp() {\n        document = new Document(\"http://example.com\");\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/nodes/Document_headTest.java",
        "class_name": "Document_headTest",
        "class_uri": "src/test/java/org/jsoup/nodes/Document_headTest.java.Document_headTest",
        "attributes": {
            "modifiers": "@BeforeEach\n    public",
            "marker_annotations": [
                "@BeforeEach"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/nodes/Attribute_getKeyTest.java.Attribute_getKeyTest.[void]setUp()",
        "name": "setUp",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "@BeforeEach\n    public void setUp()",
        "original_string": "    @BeforeEach\n    public void setUp() {\n        attribute = new Attribute(\"testKey\", \"testValue\");\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/nodes/Attribute_getKeyTest.java",
        "class_name": "Attribute_getKeyTest",
        "class_uri": "src/test/java/org/jsoup/nodes/Attribute_getKeyTest.java.Attribute_getKeyTest",
        "attributes": {
            "modifiers": "@BeforeEach\n    public",
            "marker_annotations": [
                "@BeforeEach"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/nodes/Element_getElementsByAttributeStartingTest.java.Element_getElementsByAttributeStartingTest.[void]setUp()",
        "name": "setUp",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "@BeforeEach\n    public void setUp()",
        "original_string": "    @BeforeEach\n    public void setUp() {\n        String html = \"<div data-prefix-one='value1' data-prefix-two='value2'></div>\";\n        Document doc = Jsoup.parse(html);\n        element = doc.body().child(0);\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/nodes/Element_getElementsByAttributeStartingTest.java",
        "class_name": "Element_getElementsByAttributeStartingTest",
        "class_uri": "src/test/java/org/jsoup/nodes/Element_getElementsByAttributeStartingTest.java.Element_getElementsByAttributeStartingTest",
        "attributes": {
            "modifiers": "@BeforeEach\n    public",
            "marker_annotations": [
                "@BeforeEach"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/nodes/Element_firstElementChildTest.java.Element_firstElementChildTest.[void]setUp()",
        "name": "setUp",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "@BeforeEach\n    public void setUp()",
        "original_string": "    @BeforeEach\n    public void setUp() {\n        element = new Element(\"div\");\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/nodes/Element_firstElementChildTest.java",
        "class_name": "Element_firstElementChildTest",
        "class_uri": "src/test/java/org/jsoup/nodes/Element_firstElementChildTest.java.Element_firstElementChildTest",
        "attributes": {
            "modifiers": "@BeforeEach\n    public",
            "marker_annotations": [
                "@BeforeEach"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/nodes/Element_parentsTest.java.Element_parentsTest.[void]setUp()",
        "name": "setUp",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "@BeforeEach\n    public void setUp()",
        "original_string": "    @BeforeEach\n    public void setUp() {\n        Document doc = Jsoup.parse(\"<div><span></span></div>\");\n        element = doc.body().child(0);\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/nodes/Element_parentsTest.java",
        "class_name": "Element_parentsTest",
        "class_uri": "src/test/java/org/jsoup/nodes/Element_parentsTest.java.Element_parentsTest",
        "attributes": {
            "modifiers": "@BeforeEach\n    public",
            "marker_annotations": [
                "@BeforeEach"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/nodes/Element_prependTest.java.Element_prependTest.[void]setUp()",
        "name": "setUp",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "@BeforeEach\n    public void setUp()",
        "original_string": "    @BeforeEach\n    public void setUp() {\n        element = new Element(\"div\");\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/nodes/Element_prependTest.java",
        "class_name": "Element_prependTest",
        "class_uri": "src/test/java/org/jsoup/nodes/Element_prependTest.java.Element_prependTest",
        "attributes": {
            "modifiers": "@BeforeEach\n    public",
            "marker_annotations": [
                "@BeforeEach"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/nodes/Element_appendToTest.java.Element_appendToTest.[void]setUp()",
        "name": "setUp",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "@BeforeEach\n    public void setUp()",
        "original_string": "    @BeforeEach\n    public void setUp() {\n        parent = new Element(\"div\");\n        child = new Element(\"span\");\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/nodes/Element_appendToTest.java",
        "class_name": "Element_appendToTest",
        "class_uri": "src/test/java/org/jsoup/nodes/Element_appendToTest.java.Element_appendToTest",
        "attributes": {
            "modifiers": "@BeforeEach\n    public",
            "marker_annotations": [
                "@BeforeEach"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/nodes/Element_hasClassTest.java.Element_hasClassTest.[void]setUp()",
        "name": "setUp",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "@BeforeEach\n    public void setUp()",
        "original_string": "    @BeforeEach\n    public void setUp() {\n        element = new Element(\"div\");\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/nodes/Element_hasClassTest.java",
        "class_name": "Element_hasClassTest",
        "class_uri": "src/test/java/org/jsoup/nodes/Element_hasClassTest.java.Element_hasClassTest",
        "attributes": {
            "modifiers": "@BeforeEach\n    public",
            "marker_annotations": [
                "@BeforeEach"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/nodes/Attribute_createFromEncodedTest.java.Attribute_createFromEncodedTest.[void]setUp()",
        "name": "setUp",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "@BeforeEach\n    public void setUp()",
        "original_string": "    @BeforeEach\n    public void setUp() {\n        // No setup required for this test case\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/nodes/Attribute_createFromEncodedTest.java",
        "class_name": "Attribute_createFromEncodedTest",
        "class_uri": "src/test/java/org/jsoup/nodes/Attribute_createFromEncodedTest.java.Attribute_createFromEncodedTest",
        "attributes": {
            "modifiers": "@BeforeEach\n    public",
            "marker_annotations": [
                "@BeforeEach"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/nodes/Attribute_setValueTest.java.Attribute_setValueTest.[void]setUp()",
        "name": "setUp",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "@BeforeEach\n    public void setUp()",
        "original_string": "    @BeforeEach\n    public void setUp() {\n        parent = new Attributes();\n        attribute = new Attribute(\"key\", \"value\", parent);\n        parent.put(\"key\", \"value\");\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/nodes/Attribute_setValueTest.java",
        "class_name": "Attribute_setValueTest",
        "class_uri": "src/test/java/org/jsoup/nodes/Attribute_setValueTest.java.Attribute_setValueTest",
        "attributes": {
            "modifiers": "@BeforeEach\n    public",
            "marker_annotations": [
                "@BeforeEach"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/nodes/Element_getElementByIdTest.java.Element_getElementByIdTest.[void]setUp()",
        "name": "setUp",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "@BeforeEach\n    public void setUp()",
        "original_string": "    @BeforeEach\n    public void setUp() {\n        String html = \"<body><div id='first'><p>One</p></div><div id='second'><p>Two</p></div></body>\";\n        doc = Jsoup.parse(html);\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/nodes/Element_getElementByIdTest.java",
        "class_name": "Element_getElementByIdTest",
        "class_uri": "src/test/java/org/jsoup/nodes/Element_getElementByIdTest.java.Element_getElementByIdTest",
        "attributes": {
            "modifiers": "@BeforeEach\n    public",
            "marker_annotations": [
                "@BeforeEach"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/nodes/Attributes_hasDeclaredValueForKeyIgnoreCaseTest.java.Attributes_hasDeclaredValueForKeyIgnoreCaseTest.[void]setUp()",
        "name": "setUp",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "@BeforeEach\n    public void setUp()",
        "original_string": "    @BeforeEach\n    public void setUp() {\n        attributes = new Attributes();\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/nodes/Attributes_hasDeclaredValueForKeyIgnoreCaseTest.java",
        "class_name": "Attributes_hasDeclaredValueForKeyIgnoreCaseTest",
        "class_uri": "src/test/java/org/jsoup/nodes/Attributes_hasDeclaredValueForKeyIgnoreCaseTest.java.Attributes_hasDeclaredValueForKeyIgnoreCaseTest",
        "attributes": {
            "modifiers": "@BeforeEach\n    public",
            "marker_annotations": [
                "@BeforeEach"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/nodes/Document_expectFormTest.java.Document_expectFormTest.[void]setUp()",
        "name": "setUp",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "@BeforeEach\n    public void setUp()",
        "original_string": "    @BeforeEach\n    public void setUp() {\n        String html = \"<html><body><form id='form1'></form><div id='notForm'></div></body></html>\";\n        document = Jsoup.parse(html);\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/nodes/Document_expectFormTest.java",
        "class_name": "Document_expectFormTest",
        "class_uri": "src/test/java/org/jsoup/nodes/Document_expectFormTest.java.Document_expectFormTest",
        "attributes": {
            "modifiers": "@BeforeEach\n    public",
            "marker_annotations": [
                "@BeforeEach"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/nodes/Attribute_hashCodeTest.java.Attribute_hashCodeTest.[void]setUp()",
        "name": "setUp",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "@BeforeEach\n    public void setUp()",
        "original_string": "    @BeforeEach\n    public void setUp() {\n        attribute = new Attribute(\"key\", \"value\");\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/nodes/Attribute_hashCodeTest.java",
        "class_name": "Attribute_hashCodeTest",
        "class_uri": "src/test/java/org/jsoup/nodes/Attribute_hashCodeTest.java.Attribute_hashCodeTest",
        "attributes": {
            "modifiers": "@BeforeEach\n    public",
            "marker_annotations": [
                "@BeforeEach"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/nodes/Attributes_getIgnoreCaseTest.java.Attributes_getIgnoreCaseTest.[void]setUp()",
        "name": "setUp",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "@BeforeEach\n    public void setUp()",
        "original_string": "    @BeforeEach\n    public void setUp() {\n        attributes = new Attributes();\n        attributes.put(\"a\", \"valueA\");\n        attributes.put(\"B\", \"valueB\");\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/nodes/Attributes_getIgnoreCaseTest.java",
        "class_name": "Attributes_getIgnoreCaseTest",
        "class_uri": "src/test/java/org/jsoup/nodes/Attributes_getIgnoreCaseTest.java.Attributes_getIgnoreCaseTest",
        "attributes": {
            "modifiers": "@BeforeEach\n    public",
            "marker_annotations": [
                "@BeforeEach"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/nodes/Element_prependChildTest.java.Element_prependChildTest.[void]setUp()",
        "name": "setUp",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "@BeforeEach\n    public void setUp()",
        "original_string": "    @BeforeEach\n    public void setUp() {\n        element = new Element(\"div\");\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/nodes/Element_prependChildTest.java",
        "class_name": "Element_prependChildTest",
        "class_uri": "src/test/java/org/jsoup/nodes/Element_prependChildTest.java.Element_prependChildTest",
        "attributes": {
            "modifiers": "@BeforeEach\n    public",
            "marker_annotations": [
                "@BeforeEach"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/nodes/Element_cloneTest.java.Element_cloneTest.[void]setUp()",
        "name": "setUp",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "@BeforeEach\n    public void setUp()",
        "original_string": "    @BeforeEach\n    public void setUp() {\n        element = new Element(\"div\");\n        element.appendChild(new Element(\"p\").text(\"Child 1\"));\n        element.appendChild(new Element(\"p\").text(\"Child 2\"));\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/nodes/Element_cloneTest.java",
        "class_name": "Element_cloneTest",
        "class_uri": "src/test/java/org/jsoup/nodes/Element_cloneTest.java.Element_cloneTest",
        "attributes": {
            "modifiers": "@BeforeEach\n    public",
            "marker_annotations": [
                "@BeforeEach"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/nodes/Attributes_asListTest.java.Attributes_asListTest.[void]setUp()",
        "name": "setUp",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "@BeforeEach\n    public void setUp()",
        "original_string": "    @BeforeEach\n    public void setUp() {\n        attributes = new Attributes();\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/nodes/Attributes_asListTest.java",
        "class_name": "Attributes_asListTest",
        "class_uri": "src/test/java/org/jsoup/nodes/Attributes_asListTest.java.Attributes_asListTest",
        "attributes": {
            "modifiers": "@BeforeEach\n    public",
            "marker_annotations": [
                "@BeforeEach"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/nodes/DocumentTypeTest.java.DocumentTypeTest.[String]htmlOutput(String)",
        "name": "htmlOutput",
        "arg_nums": 1,
        "params": [
            {
                "name": "in",
                "type": "String"
            }
        ],
        "return_type": "String",
        "signature": "private String htmlOutput(String in)",
        "original_string": "    private String htmlOutput(String in) {\n        DocumentType type = (DocumentType) Jsoup.parse(in).childNode(0);\n        return type.outerHtml();\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/nodes/DocumentTypeTest.java",
        "class_name": "DocumentTypeTest",
        "class_uri": "src/test/java/org/jsoup/nodes/DocumentTypeTest.java.DocumentTypeTest",
        "attributes": {
            "modifiers": "private",
            "marker_annotations": [],
            "non_marker_annotations": [
                "private"
            ],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/nodes/DocumentTypeTest.java.DocumentTypeTest.[String]xmlOutput(String)",
        "name": "xmlOutput",
        "arg_nums": 1,
        "params": [
            {
                "name": "in",
                "type": "String"
            }
        ],
        "return_type": "String",
        "signature": "private String xmlOutput(String in)",
        "original_string": "    private String xmlOutput(String in) {\n        return Jsoup.parse(in, \"\", Parser.xmlParser()).childNode(0).outerHtml();\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/nodes/DocumentTypeTest.java",
        "class_name": "DocumentTypeTest",
        "class_uri": "src/test/java/org/jsoup/nodes/DocumentTypeTest.java.DocumentTypeTest",
        "attributes": {
            "modifiers": "private",
            "marker_annotations": [],
            "non_marker_annotations": [
                "private"
            ],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/nodes/Element_appendElementTest.java.Element_appendElementTest.[void]setUp()",
        "name": "setUp",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "@BeforeEach\n    public void setUp()",
        "original_string": "    @BeforeEach\n    public void setUp() {\n        element = new Element(\"div\");\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/nodes/Element_appendElementTest.java",
        "class_name": "Element_appendElementTest",
        "class_uri": "src/test/java/org/jsoup/nodes/Element_appendElementTest.java.Element_appendElementTest",
        "attributes": {
            "modifiers": "@BeforeEach\n    public",
            "marker_annotations": [
                "@BeforeEach"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/nodes/Document_outputSettingsTest.java.Document_outputSettingsTest.[void]setUp()",
        "name": "setUp",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "@BeforeEach\n    public void setUp()",
        "original_string": "    @BeforeEach\n    public void setUp() {\n        document = new Document(\"baseUri\");\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/nodes/Document_outputSettingsTest.java",
        "class_name": "Document_outputSettingsTest",
        "class_uri": "src/test/java/org/jsoup/nodes/Document_outputSettingsTest.java.Document_outputSettingsTest",
        "attributes": {
            "modifiers": "@BeforeEach\n    public",
            "marker_annotations": [
                "@BeforeEach"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/nodes/Attribute_getValueTest.java.Attribute_getValueTest.[void]setUp()",
        "name": "setUp",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "@BeforeEach\n    public void setUp()",
        "original_string": "    @BeforeEach\n    public void setUp() {\n        attribute = new Attribute(\"key\", \"value\");\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/nodes/Attribute_getValueTest.java",
        "class_name": "Attribute_getValueTest",
        "class_uri": "src/test/java/org/jsoup/nodes/Attribute_getValueTest.java.Attribute_getValueTest",
        "attributes": {
            "modifiers": "@BeforeEach\n    public",
            "marker_annotations": [
                "@BeforeEach"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/nodes/ElementTest.java.ElementTest.[void]validateScriptContents(String,Element)",
        "name": "validateScriptContents",
        "arg_nums": 2,
        "params": [
            {
                "name": "src",
                "type": "String"
            },
            {
                "name": "el",
                "type": "Element"
            }
        ],
        "return_type": "void",
        "signature": "private static void validateScriptContents(String src, Element el)",
        "original_string": "    private static void validateScriptContents(String src, Element el) {\n        assertEquals(\"\", el.text()); // it's not text\n        assertEquals(\"\", el.ownText());\n        assertEquals(\"\", el.wholeText());\n        assertEquals(src, el.html());\n        assertEquals(src, el.data());\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/nodes/ElementTest.java",
        "class_name": "ElementTest",
        "class_uri": "src/test/java/org/jsoup/nodes/ElementTest.java.ElementTest",
        "attributes": {
            "modifiers": "private static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "private",
                "static"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/nodes/ElementTest.java.ElementTest.[void]validateXmlScriptContents(Element)",
        "name": "validateXmlScriptContents",
        "arg_nums": 1,
        "params": [
            {
                "name": "el",
                "type": "Element"
            }
        ],
        "return_type": "void",
        "signature": "private static void validateXmlScriptContents(Element el)",
        "original_string": "    private static void validateXmlScriptContents(Element el) {\n        assertEquals(\"var foo = 5 < 2; var bar = 1 && 2;\", el.text());\n        assertEquals(\"var foo = 5 < 2; var bar = 1 && 2;\", el.ownText());\n        assertEquals(\"var foo = 5 < 2;\\nvar bar = 1 && 2;\", el.wholeText());\n        assertEquals(\"var foo = 5 &lt; 2;\\nvar bar = 1 &amp;&amp; 2;\", el.html());\n        assertEquals(\"\", el.data());\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/nodes/ElementTest.java",
        "class_name": "ElementTest",
        "class_uri": "src/test/java/org/jsoup/nodes/ElementTest.java.ElementTest",
        "attributes": {
            "modifiers": "private static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "private",
                "static"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/nodes/ElementTest.java.ElementTest.[Stream<Document.OutputSettings>]testOutputSettings()",
        "name": "testOutputSettings",
        "arg_nums": 0,
        "params": [],
        "return_type": "Stream<Document.OutputSettings>",
        "signature": "private static Stream<Document.OutputSettings> testOutputSettings()",
        "original_string": "    private static Stream<Document.OutputSettings> testOutputSettings() {\n        return Stream.of(\n            new Document.OutputSettings().prettyPrint(true).indentAmount(4),\n            new Document.OutputSettings().prettyPrint(true).indentAmount(1),\n            new Document.OutputSettings().prettyPrint(true).indentAmount(4).outline(true),\n            new Document.OutputSettings().prettyPrint(false)\n        );\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/nodes/ElementTest.java",
        "class_name": "ElementTest",
        "class_uri": "src/test/java/org/jsoup/nodes/ElementTest.java.ElementTest",
        "attributes": {
            "modifiers": "private static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "private",
                "static"
            ],
            "comments": [],
            "return_type": "Stream<Document.OutputSettings>",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/nodes/Element_forEachTest.java.Element_forEachTest.[void]setUp()",
        "name": "setUp",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "@BeforeEach\n    public void setUp()",
        "original_string": "    @BeforeEach\n    public void setUp() {\n        Document doc = Jsoup.parse(\"<div><p>1</p><p>2</p><p>3</p></div>\");\n        element = doc.body().child(0);\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/nodes/Element_forEachTest.java",
        "class_name": "Element_forEachTest",
        "class_uri": "src/test/java/org/jsoup/nodes/Element_forEachTest.java.Element_forEachTest",
        "attributes": {
            "modifiers": "@BeforeEach\n    public",
            "marker_annotations": [
                "@BeforeEach"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/nodes/Attribute_sourceRangeTest.java.Attribute_sourceRangeTest.[void]setUp()",
        "name": "setUp",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "@BeforeEach\n    public void setUp()",
        "original_string": "    @BeforeEach\n    public void setUp() {\n        parent = mock(Attributes.class);\n        attribute = new Attribute(\"key\", \"value\", parent);\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/nodes/Attribute_sourceRangeTest.java",
        "class_name": "Attribute_sourceRangeTest",
        "class_uri": "src/test/java/org/jsoup/nodes/Attribute_sourceRangeTest.java.Attribute_sourceRangeTest",
        "attributes": {
            "modifiers": "@BeforeEach\n    public",
            "marker_annotations": [
                "@BeforeEach"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/nodes/FormElementTest.java.FormElementTest.[void]setUp()",
        "name": "setUp",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "@BeforeAll\n    public static void setUp()",
        "original_string": "    @BeforeAll\n    public static void setUp() {\n        TestServer.start();\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/nodes/FormElementTest.java",
        "class_name": "FormElementTest",
        "class_uri": "src/test/java/org/jsoup/nodes/FormElementTest.java.FormElementTest",
        "attributes": {
            "modifiers": "@BeforeAll\n    public static",
            "marker_annotations": [
                "@BeforeAll"
            ],
            "non_marker_annotations": [
                "public",
                "static"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/nodes/Attributes_equalsTest.java.Attributes_equalsTest.[void]setUp()",
        "name": "setUp",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "@BeforeEach\n    public void setUp()",
        "original_string": "    @BeforeEach\n    public void setUp() {\n        attributes = new Attributes();\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/nodes/Attributes_equalsTest.java",
        "class_name": "Attributes_equalsTest",
        "class_uri": "src/test/java/org/jsoup/nodes/Attributes_equalsTest.java.Attributes_equalsTest",
        "attributes": {
            "modifiers": "@BeforeEach\n    public",
            "marker_annotations": [
                "@BeforeEach"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/nodes/Element_getElementsByTagTest.java.Element_getElementsByTagTest.[void]setUp()",
        "name": "setUp",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "@BeforeEach\n    public void setUp()",
        "original_string": "    @BeforeEach\n    public void setUp() {\n        String html = \"<body><div><p>One</p><p>Two</p></div><div>Three</div></body>\";\n        Document doc = Jsoup.parse(html);\n        element = doc.body();\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/nodes/Element_getElementsByTagTest.java",
        "class_name": "Element_getElementsByTagTest",
        "class_uri": "src/test/java/org/jsoup/nodes/Element_getElementsByTagTest.java.Element_getElementsByTagTest",
        "attributes": {
            "modifiers": "@BeforeEach\n    public",
            "marker_annotations": [
                "@BeforeEach"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/nodes/TextNode_splitTextTest.java.TextNode_splitTextTest.[void]setUp()",
        "name": "setUp",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "@BeforeEach\n    public void setUp()",
        "original_string": "    @BeforeEach\n    public void setUp() {\n        textNode = new TextNode(\"Hello World\");\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/nodes/TextNode_splitTextTest.java",
        "class_name": "TextNode_splitTextTest",
        "class_uri": "src/test/java/org/jsoup/nodes/TextNode_splitTextTest.java.TextNode_splitTextTest",
        "attributes": {
            "modifiers": "@BeforeEach\n    public",
            "marker_annotations": [
                "@BeforeEach"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/nodes/Attributes_removeIgnoreCaseTest.java.Attributes_removeIgnoreCaseTest.[void]setUp()",
        "name": "setUp",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "@BeforeEach\n    public void setUp()",
        "original_string": "    @BeforeEach\n    public void setUp() {\n        attributes = new Attributes();\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/nodes/Attributes_removeIgnoreCaseTest.java",
        "class_name": "Attributes_removeIgnoreCaseTest",
        "class_uri": "src/test/java/org/jsoup/nodes/Attributes_removeIgnoreCaseTest.java.Attributes_removeIgnoreCaseTest",
        "attributes": {
            "modifiers": "@BeforeEach\n    public",
            "marker_annotations": [
                "@BeforeEach"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/nodes/Element_dataTest.java.Element_dataTest.[void]setUp()",
        "name": "setUp",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "@BeforeEach\n    public void setUp()",
        "original_string": "    @BeforeEach\n    public void setUp() {\n        element = new Element(\"div\");\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/nodes/Element_dataTest.java",
        "class_name": "Element_dataTest",
        "class_uri": "src/test/java/org/jsoup/nodes/Element_dataTest.java.Element_dataTest",
        "attributes": {
            "modifiers": "@BeforeEach\n    public",
            "marker_annotations": [
                "@BeforeEach"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/nodes/Element_firstElementSiblingTest.java.Element_firstElementSiblingTest.[void]setUp()",
        "name": "setUp",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "@BeforeEach\n    public void setUp()",
        "original_string": "    @BeforeEach\n    public void setUp() {\n        parent = new Element(\"parent\");\n        child1 = new Element(\"child1\");\n        child2 = new Element(\"child2\");\n        parent.appendChild(child1);\n        parent.appendChild(child2);\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/nodes/Element_firstElementSiblingTest.java",
        "class_name": "Element_firstElementSiblingTest",
        "class_uri": "src/test/java/org/jsoup/nodes/Element_firstElementSiblingTest.java.Element_firstElementSiblingTest",
        "attributes": {
            "modifiers": "@BeforeEach\n    public",
            "marker_annotations": [
                "@BeforeEach"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/nodes/Element_filterTest.java.Element_filterTest.[void]setUp()",
        "name": "setUp",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "@BeforeEach\n    public void setUp()",
        "original_string": "    @BeforeEach\n    public void setUp() {\n        String html = \"<body><div><p>One</p></div><div><p>Two</p></div><div>Three</div></body>\";\n        Document doc = Jsoup.parse(html);\n        element = doc.selectFirst(\"div\");\n        assertNotNull(element);\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/nodes/Element_filterTest.java",
        "class_name": "Element_filterTest",
        "class_uri": "src/test/java/org/jsoup/nodes/Element_filterTest.java.Element_filterTest",
        "attributes": {
            "modifiers": "@BeforeEach\n    public",
            "marker_annotations": [
                "@BeforeEach"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/nodes/Document_outerHtmlTest.java.Document_outerHtmlTest.[void]setUp()",
        "name": "setUp",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "@BeforeEach\n    public void setUp()",
        "original_string": "    @BeforeEach\n    public void setUp() {\n        document = Jsoup.parse(\"<html><head></head><body><div>Test</div></body></html>\");\n        document.outputSettings().prettyPrint(false); // Disable pretty printing\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/nodes/Document_outerHtmlTest.java",
        "class_name": "Document_outerHtmlTest",
        "class_uri": "src/test/java/org/jsoup/nodes/Document_outerHtmlTest.java.Document_outerHtmlTest",
        "attributes": {
            "modifiers": "@BeforeEach\n    public",
            "marker_annotations": [
                "@BeforeEach"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/nodes/Element_hasTextTest.java.Element_hasTextTest.[void]setUp()",
        "name": "setUp",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "@BeforeEach\n    public void setUp()",
        "original_string": "    @BeforeEach\n    public void setUp() {\n        element = new Element(\"div\");\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/nodes/Element_hasTextTest.java",
        "class_name": "Element_hasTextTest",
        "class_uri": "src/test/java/org/jsoup/nodes/Element_hasTextTest.java.Element_hasTextTest",
        "attributes": {
            "modifiers": "@BeforeEach\n    public",
            "marker_annotations": [
                "@BeforeEach"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/nodes/Comment_setDataTest.java.Comment_setDataTest.[void]setUp()",
        "name": "setUp",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "@BeforeEach\n    public void setUp()",
        "original_string": "    @BeforeEach\n    public void setUp() {\n        comment = new Comment(\"initial data\");\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/nodes/Comment_setDataTest.java",
        "class_name": "Comment_setDataTest",
        "class_uri": "src/test/java/org/jsoup/nodes/Comment_setDataTest.java.Comment_setDataTest",
        "attributes": {
            "modifiers": "@BeforeEach\n    public",
            "marker_annotations": [
                "@BeforeEach"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/nodes/Element_expectFirstTest.java.Element_expectFirstTest.[void]setUp()",
        "name": "setUp",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "@BeforeEach\n    public void setUp()",
        "original_string": "    @BeforeEach\n    public void setUp() {\n        String html = \"<body><div><p>One</p></div><div><p>Two</p></div><div>Three</div></body>\";\n        doc = Jsoup.parse(html);\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/nodes/Element_expectFirstTest.java",
        "class_name": "Element_expectFirstTest",
        "class_uri": "src/test/java/org/jsoup/nodes/Element_expectFirstTest.java.Element_expectFirstTest",
        "attributes": {
            "modifiers": "@BeforeEach\n    public",
            "marker_annotations": [
                "@BeforeEach"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/test/java/org/jsoup/nodes/Element_toggleClassTest.java.Element_toggleClassTest.[void]setUp()",
        "name": "setUp",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "@BeforeEach\n    public void setUp()",
        "original_string": "    @BeforeEach\n    public void setUp() {\n        element = new Element(\"div\");\n    }",
        "default_arguments": null,
        "file": "src/test/java/org/jsoup/nodes/Element_toggleClassTest.java",
        "class_name": "Element_toggleClassTest",
        "class_uri": "src/test/java/org/jsoup/nodes/Element_toggleClassTest.java.Element_toggleClassTest",
        "attributes": {
            "modifiers": "@BeforeEach\n    public",
            "marker_annotations": [
                "@BeforeEach"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/UncheckedIOException.java.UncheckedIOException.[]UncheckedIOException(IOException)",
        "name": "UncheckedIOException",
        "arg_nums": 1,
        "params": [
            {
                "name": "cause",
                "type": "IOException"
            }
        ],
        "return_type": "",
        "signature": "public UncheckedIOException(IOException cause)",
        "original_string": "    public UncheckedIOException(IOException cause) {\n        super(cause);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/UncheckedIOException.java",
        "class_name": "UncheckedIOException",
        "class_uri": "src/main/java/org/jsoup/UncheckedIOException.java.UncheckedIOException",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/UncheckedIOException.java.UncheckedIOException.[]UncheckedIOException(String)",
        "name": "UncheckedIOException",
        "arg_nums": 1,
        "params": [
            {
                "name": "message",
                "type": "String"
            }
        ],
        "return_type": "",
        "signature": "public UncheckedIOException(String message)",
        "original_string": "    public UncheckedIOException(String message) {\n        super(new IOException(message));\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/UncheckedIOException.java",
        "class_name": "UncheckedIOException",
        "class_uri": "src/main/java/org/jsoup/UncheckedIOException.java.UncheckedIOException",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/UncheckedIOException.java.UncheckedIOException.[IOException]ioException()",
        "name": "ioException",
        "arg_nums": 0,
        "params": [],
        "return_type": "IOException",
        "signature": "public IOException ioException()",
        "original_string": "    public IOException ioException() {\n        return getCause();\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/UncheckedIOException.java",
        "class_name": "UncheckedIOException",
        "class_uri": "src/main/java/org/jsoup/UncheckedIOException.java.UncheckedIOException",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "IOException",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/Progress.java.Progress.[void]onProgress(int,int,float,ProgressContext)",
        "name": "onProgress",
        "arg_nums": 4,
        "params": [
            {
                "name": "processed",
                "type": "int"
            },
            {
                "name": "total",
                "type": "int"
            },
            {
                "name": "percent",
                "type": "float"
            },
            {
                "name": "context",
                "type": "ProgressContext"
            }
        ],
        "return_type": "void",
        "signature": "void onProgress(int processed, int total, float percent, ProgressContext context)",
        "original_string": "    void onProgress(int processed, int total, float percent, ProgressContext context);",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/Progress.java",
        "class_name": "Progress",
        "class_uri": "src/main/java/org/jsoup/Progress.java.Progress",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": "\nCalled to report progress. Note that this will be executed by the same thread that is doing the work, so either\ndon't take to long, or hand it off to another thread.\n@param processed the number of bytes processed so far.\n@param total the total number of expected bytes, or -1 if unknown.\n@param percent the percentage of completion, 0.0..100.0. If the expected total is unknown, % will remain at zero\nuntil complete.\n@param context the object that progress was made on.\n@since 1.18.1\n"
    },
    {
        "uris": "src/main/java/org/jsoup/Connection.java.Connection.[Connection]newRequest()",
        "name": "newRequest",
        "arg_nums": 0,
        "params": [],
        "return_type": "Connection",
        "signature": "Connection newRequest()",
        "original_string": "    Connection newRequest();",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/Connection.java",
        "class_name": "Connection",
        "class_uri": "src/main/java/org/jsoup/Connection.java.Connection",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "Connection",
            "classes": []
        },
        "docstring": "\nCreates a new request, using this Connection as the session-state and to initialize the connection settings (which\nmay then be independently changed on the returned {@link Connection.Request} object).\n@return a new Connection object, with a shared Cookie Store and initialized settings from this Connection and Request\n@since 1.14.1\n"
    },
    {
        "uris": "src/main/java/org/jsoup/Connection.java.Connection.[Connection]newRequest(String)",
        "name": "newRequest",
        "arg_nums": 1,
        "params": [
            {
                "name": "url",
                "type": "String"
            }
        ],
        "return_type": "Connection",
        "signature": "default Connection newRequest(String url)",
        "original_string": "    default Connection newRequest(String url) {\n        return newRequest().url(url);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/Connection.java",
        "class_name": "Connection",
        "class_uri": "src/main/java/org/jsoup/Connection.java.Connection",
        "attributes": {
            "modifiers": "default",
            "marker_annotations": [],
            "non_marker_annotations": [
                "default"
            ],
            "comments": [],
            "return_type": "Connection",
            "classes": []
        },
        "docstring": "\nCreates a new request, using this Connection as the session-state and to initialize the connection settings (which\nmay then be independently changed on the returned {@link Connection.Request} object).\n@return a new Connection object, with a shared Cookie Store and initialized settings from this Connection and Request\n@param url URL for the new request\n@since 1.17.1\n"
    },
    {
        "uris": "src/main/java/org/jsoup/Connection.java.Connection.[Connection]newRequest(URL)",
        "name": "newRequest",
        "arg_nums": 1,
        "params": [
            {
                "name": "url",
                "type": "URL"
            }
        ],
        "return_type": "Connection",
        "signature": "default Connection newRequest(URL url)",
        "original_string": "    default Connection newRequest(URL url) {\n        return newRequest().url(url);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/Connection.java",
        "class_name": "Connection",
        "class_uri": "src/main/java/org/jsoup/Connection.java.Connection",
        "attributes": {
            "modifiers": "default",
            "marker_annotations": [],
            "non_marker_annotations": [
                "default"
            ],
            "comments": [],
            "return_type": "Connection",
            "classes": []
        },
        "docstring": "\nCreates a new request, using this Connection as the session-state and to initialize the connection settings (which\nmay then be independently changed on the returned {@link Connection.Request} object).\n@return a new Connection object, with a shared Cookie Store and initialized settings from this Connection and Request\n@param url URL for the new request\n@since 1.17.1\n"
    },
    {
        "uris": "src/main/java/org/jsoup/Connection.java.Connection.[Connection]url(URL)",
        "name": "url",
        "arg_nums": 1,
        "params": [
            {
                "name": "url",
                "type": "URL"
            }
        ],
        "return_type": "Connection",
        "signature": "Connection url(URL url)",
        "original_string": "    Connection url(URL url);",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/Connection.java",
        "class_name": "Connection",
        "class_uri": "src/main/java/org/jsoup/Connection.java.Connection",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "Connection",
            "classes": []
        },
        "docstring": "\nSet the request URL to fetch. The protocol must be HTTP or HTTPS.\n@param url URL to connect to\n@return this Connection, for chaining\n"
    },
    {
        "uris": "src/main/java/org/jsoup/Connection.java.Connection.[Connection]url(String)",
        "name": "url",
        "arg_nums": 1,
        "params": [
            {
                "name": "url",
                "type": "String"
            }
        ],
        "return_type": "Connection",
        "signature": "Connection url(String url)",
        "original_string": "    Connection url(String url);",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/Connection.java",
        "class_name": "Connection",
        "class_uri": "src/main/java/org/jsoup/Connection.java.Connection",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "Connection",
            "classes": []
        },
        "docstring": "\nSet the request URL to fetch. The protocol must be HTTP or HTTPS.\n@param url URL to connect to\n@return this Connection, for chaining\n"
    },
    {
        "uris": "src/main/java/org/jsoup/Connection.java.Connection.[Connection]proxy(Proxy)",
        "name": "proxy",
        "arg_nums": 1,
        "params": [
            {
                "name": "proxy",
                "type": "Proxy"
            }
        ],
        "return_type": "Connection",
        "signature": "Connection proxy(@Nullable Proxy proxy)",
        "original_string": "    Connection proxy(@Nullable Proxy proxy);",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/Connection.java",
        "class_name": "Connection",
        "class_uri": "src/main/java/org/jsoup/Connection.java.Connection",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "Connection",
            "classes": []
        },
        "docstring": "\nSet the proxy to use for this request. Set to <code>null</code> to disable a previously set proxy.\n@param proxy proxy to use\n@return this Connection, for chaining\n"
    },
    {
        "uris": "src/main/java/org/jsoup/Connection.java.Connection.[Connection]proxy(String,int)",
        "name": "proxy",
        "arg_nums": 2,
        "params": [
            {
                "name": "host",
                "type": "String"
            },
            {
                "name": "port",
                "type": "int"
            }
        ],
        "return_type": "Connection",
        "signature": "Connection proxy(String host, int port)",
        "original_string": "    Connection proxy(String host, int port);",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/Connection.java",
        "class_name": "Connection",
        "class_uri": "src/main/java/org/jsoup/Connection.java.Connection",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "Connection",
            "classes": []
        },
        "docstring": "\nSet the HTTP proxy to use for this request.\n@param host the proxy hostname\n@param port the proxy port\n@return this Connection, for chaining\n"
    },
    {
        "uris": "src/main/java/org/jsoup/Connection.java.Connection.[Connection]userAgent(String)",
        "name": "userAgent",
        "arg_nums": 1,
        "params": [
            {
                "name": "userAgent",
                "type": "String"
            }
        ],
        "return_type": "Connection",
        "signature": "Connection userAgent(String userAgent)",
        "original_string": "    Connection userAgent(String userAgent);",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/Connection.java",
        "class_name": "Connection",
        "class_uri": "src/main/java/org/jsoup/Connection.java.Connection",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "Connection",
            "classes": []
        },
        "docstring": "\nSet the request user-agent header.\n@param userAgent user-agent to use\n@return this Connection, for chaining\n@see org.jsoup.helper.HttpConnection#DEFAULT_UA\n"
    },
    {
        "uris": "src/main/java/org/jsoup/Connection.java.Connection.[Connection]timeout(int)",
        "name": "timeout",
        "arg_nums": 1,
        "params": [
            {
                "name": "millis",
                "type": "int"
            }
        ],
        "return_type": "Connection",
        "signature": "Connection timeout(int millis)",
        "original_string": "    Connection timeout(int millis);",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/Connection.java",
        "class_name": "Connection",
        "class_uri": "src/main/java/org/jsoup/Connection.java.Connection",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "Connection",
            "classes": []
        },
        "docstring": "\nSet the total request timeout duration. If a timeout occurs, an {@link java.net.SocketTimeoutException} will be thrown.\n<p>The default timeout is <b>30 seconds</b> (30,000 millis). A timeout of zero is treated as an infinite timeout.\n<p>Note that this timeout specifies the combined maximum duration of the connection time and the time to read\nthe full response.\n@param millis number of milliseconds (thousandths of a second) before timing out connects or reads.\n@return this Connection, for chaining\n@see #maxBodySize(int)\n"
    },
    {
        "uris": "src/main/java/org/jsoup/Connection.java.Connection.[Connection]maxBodySize(int)",
        "name": "maxBodySize",
        "arg_nums": 1,
        "params": [
            {
                "name": "bytes",
                "type": "int"
            }
        ],
        "return_type": "Connection",
        "signature": "Connection maxBodySize(int bytes)",
        "original_string": "    Connection maxBodySize(int bytes);",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/Connection.java",
        "class_name": "Connection",
        "class_uri": "src/main/java/org/jsoup/Connection.java.Connection",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "Connection",
            "classes": []
        },
        "docstring": "\nSet the maximum bytes to read from the (uncompressed) connection into the body, before the connection is closed,\nand the input truncated (i.e. the body content will be trimmed). <b>The default maximum is 2MB</b>. A max size of\n<code>0</code> is treated as an infinite amount (bounded only by your patience and the memory available on your\nmachine).\n\n@param bytes number of bytes to read from the input before truncating\n@return this Connection, for chaining\n"
    },
    {
        "uris": "src/main/java/org/jsoup/Connection.java.Connection.[Connection]referrer(String)",
        "name": "referrer",
        "arg_nums": 1,
        "params": [
            {
                "name": "referrer",
                "type": "String"
            }
        ],
        "return_type": "Connection",
        "signature": "Connection referrer(String referrer)",
        "original_string": "    Connection referrer(String referrer);",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/Connection.java",
        "class_name": "Connection",
        "class_uri": "src/main/java/org/jsoup/Connection.java.Connection",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "Connection",
            "classes": []
        },
        "docstring": "\nSet the request referrer (aka \"referer\") header.\n@param referrer referrer to use\n@return this Connection, for chaining\n"
    },
    {
        "uris": "src/main/java/org/jsoup/Connection.java.Connection.[Connection]followRedirects(boolean)",
        "name": "followRedirects",
        "arg_nums": 1,
        "params": [
            {
                "name": "followRedirects",
                "type": "boolean"
            }
        ],
        "return_type": "Connection",
        "signature": "Connection followRedirects(boolean followRedirects)",
        "original_string": "    Connection followRedirects(boolean followRedirects);",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/Connection.java",
        "class_name": "Connection",
        "class_uri": "src/main/java/org/jsoup/Connection.java.Connection",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "Connection",
            "classes": []
        },
        "docstring": "\nConfigures the connection to (not) follow server redirects. By default, this is <b>true</b>.\n@param followRedirects true if server redirects should be followed.\n@return this Connection, for chaining\n"
    },
    {
        "uris": "src/main/java/org/jsoup/Connection.java.Connection.[Connection]method(Method)",
        "name": "method",
        "arg_nums": 1,
        "params": [
            {
                "name": "method",
                "type": "Method"
            }
        ],
        "return_type": "Connection",
        "signature": "Connection method(Method method)",
        "original_string": "    Connection method(Method method);",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/Connection.java",
        "class_name": "Connection",
        "class_uri": "src/main/java/org/jsoup/Connection.java.Connection",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "Connection",
            "classes": []
        },
        "docstring": "\nSet the request method to use, GET or POST. Default is GET.\n@param method HTTP request method\n@return this Connection, for chaining\n"
    },
    {
        "uris": "src/main/java/org/jsoup/Connection.java.Connection.[Connection]ignoreHttpErrors(boolean)",
        "name": "ignoreHttpErrors",
        "arg_nums": 1,
        "params": [
            {
                "name": "ignoreHttpErrors",
                "type": "boolean"
            }
        ],
        "return_type": "Connection",
        "signature": "Connection ignoreHttpErrors(boolean ignoreHttpErrors)",
        "original_string": "    Connection ignoreHttpErrors(boolean ignoreHttpErrors);",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/Connection.java",
        "class_name": "Connection",
        "class_uri": "src/main/java/org/jsoup/Connection.java.Connection",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "Connection",
            "classes": []
        },
        "docstring": "\nConfigures the connection to not throw exceptions when an HTTP error occurs. (4xx - 5xx, e.g. 404 or 500). By\ndefault, this is <b>false</b>; an IOException is thrown if an error is encountered. If set to <b>true</b>, the\nresponse is populated with the error body, and the status message will reflect the error.\n@param ignoreHttpErrors - false (default) if HTTP errors should be ignored.\n@return this Connection, for chaining\n"
    },
    {
        "uris": "src/main/java/org/jsoup/Connection.java.Connection.[Connection]ignoreContentType(boolean)",
        "name": "ignoreContentType",
        "arg_nums": 1,
        "params": [
            {
                "name": "ignoreContentType",
                "type": "boolean"
            }
        ],
        "return_type": "Connection",
        "signature": "Connection ignoreContentType(boolean ignoreContentType)",
        "original_string": "    Connection ignoreContentType(boolean ignoreContentType);",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/Connection.java",
        "class_name": "Connection",
        "class_uri": "src/main/java/org/jsoup/Connection.java.Connection",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "Connection",
            "classes": []
        },
        "docstring": "\nIgnore the document's Content-Type when parsing the response. By default, this is <b>false</b>, an unrecognised\ncontent-type will cause an IOException to be thrown. (This is to prevent producing garbage by attempting to parse\na JPEG binary image, for example.) Set to true to force a parse attempt regardless of content type.\n@param ignoreContentType set to true if you would like the content type ignored on parsing the response into a\nDocument.\n@return this Connection, for chaining\n"
    },
    {
        "uris": "src/main/java/org/jsoup/Connection.java.Connection.[Connection]sslSocketFactory(SSLSocketFactory)",
        "name": "sslSocketFactory",
        "arg_nums": 1,
        "params": [
            {
                "name": "sslSocketFactory",
                "type": "SSLSocketFactory"
            }
        ],
        "return_type": "Connection",
        "signature": "Connection sslSocketFactory(SSLSocketFactory sslSocketFactory)",
        "original_string": "    Connection sslSocketFactory(SSLSocketFactory sslSocketFactory);",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/Connection.java",
        "class_name": "Connection",
        "class_uri": "src/main/java/org/jsoup/Connection.java.Connection",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "Connection",
            "classes": []
        },
        "docstring": "\nSet custom SSL socket factory\n@param sslSocketFactory custom SSL socket factory\n@return this Connection, for chaining\n"
    },
    {
        "uris": "src/main/java/org/jsoup/Connection.java.Connection.[Connection]data(String,String)",
        "name": "data",
        "arg_nums": 2,
        "params": [
            {
                "name": "key",
                "type": "String"
            },
            {
                "name": "value",
                "type": "String"
            }
        ],
        "return_type": "Connection",
        "signature": "Connection data(String key, String value)",
        "original_string": "    Connection data(String key, String value);",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/Connection.java",
        "class_name": "Connection",
        "class_uri": "src/main/java/org/jsoup/Connection.java.Connection",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "Connection",
            "classes": []
        },
        "docstring": "\nAdd a request data parameter. Request parameters are sent in the request query string for GETs, and in the\nrequest body for POSTs. A request may have multiple values of the same name.\n@param key data key\n@param value data value\n@return this Connection, for chaining\n"
    },
    {
        "uris": "src/main/java/org/jsoup/Connection.java.Connection.[Connection]data(String,String,InputStream)",
        "name": "data",
        "arg_nums": 3,
        "params": [
            {
                "name": "key",
                "type": "String"
            },
            {
                "name": "filename",
                "type": "String"
            },
            {
                "name": "inputStream",
                "type": "InputStream"
            }
        ],
        "return_type": "Connection",
        "signature": "Connection data(String key, String filename, InputStream inputStream)",
        "original_string": "    Connection data(String key, String filename, InputStream inputStream);",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/Connection.java",
        "class_name": "Connection",
        "class_uri": "src/main/java/org/jsoup/Connection.java.Connection",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "Connection",
            "classes": []
        },
        "docstring": "\nAdd an input stream as a request data parameter. For GETs, has no effect, but for POSTS this will upload the\ninput stream.\n<p>Use the {@link #data(String, String, InputStream, String)} method to set the uploaded file's mimetype.</p>\n@param key data key (form item name)\n@param filename the name of the file to present to the remove server. Typically just the name, not path,\ncomponent.\n@param inputStream the input stream to upload, that you probably obtained from a {@link java.io.FileInputStream}.\nYou must close the InputStream in a {@code finally} block.\n@return this Connection, for chaining\n@see #data(String, String, InputStream, String)\n"
    },
    {
        "uris": "src/main/java/org/jsoup/Connection.java.Connection.[Connection]data(String,String,InputStream,String)",
        "name": "data",
        "arg_nums": 4,
        "params": [
            {
                "name": "key",
                "type": "String"
            },
            {
                "name": "filename",
                "type": "String"
            },
            {
                "name": "inputStream",
                "type": "InputStream"
            },
            {
                "name": "contentType",
                "type": "String"
            }
        ],
        "return_type": "Connection",
        "signature": "Connection data(String key, String filename, InputStream inputStream, String contentType)",
        "original_string": "    Connection data(String key, String filename, InputStream inputStream, String contentType);",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/Connection.java",
        "class_name": "Connection",
        "class_uri": "src/main/java/org/jsoup/Connection.java.Connection",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "Connection",
            "classes": []
        },
        "docstring": "\nAdd an input stream as a request data parameter. For GETs, has no effect, but for POSTS this will upload the\ninput stream.\n@param key data key (form item name)\n@param filename the name of the file to present to the remove server. Typically just the name, not path,\ncomponent.\n@param inputStream the input stream to upload, that you probably obtained from a {@link java.io.FileInputStream}.\n@param contentType the Content Type (aka mimetype) to specify for this file.\nYou must close the InputStream in a {@code finally} block.\n@return this Connection, for chaining\n"
    },
    {
        "uris": "src/main/java/org/jsoup/Connection.java.Connection.[Connection]data(Collection<KeyVal>)",
        "name": "data",
        "arg_nums": 1,
        "params": [
            {
                "name": "data",
                "type": "Collection<KeyVal>"
            }
        ],
        "return_type": "Connection",
        "signature": "Connection data(Collection<KeyVal> data)",
        "original_string": "    Connection data(Collection<KeyVal> data);",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/Connection.java",
        "class_name": "Connection",
        "class_uri": "src/main/java/org/jsoup/Connection.java.Connection",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "Connection",
            "classes": []
        },
        "docstring": "\nAdds all of the supplied data to the request data parameters\n@param data collection of data parameters\n@return this Connection, for chaining\n"
    },
    {
        "uris": "src/main/java/org/jsoup/Connection.java.Connection.[Connection]data(Map<String, String>)",
        "name": "data",
        "arg_nums": 1,
        "params": [
            {
                "name": "data",
                "type": "Map<String, String>"
            }
        ],
        "return_type": "Connection",
        "signature": "Connection data(Map<String, String> data)",
        "original_string": "    Connection data(Map<String, String> data);",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/Connection.java",
        "class_name": "Connection",
        "class_uri": "src/main/java/org/jsoup/Connection.java.Connection",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "Connection",
            "classes": []
        },
        "docstring": "\nAdds all of the supplied data to the request data parameters\n@param data map of data parameters\n@return this Connection, for chaining\n"
    },
    {
        "uris": "src/main/java/org/jsoup/Connection.java.Connection.[Connection]data()",
        "name": "data",
        "arg_nums": 0,
        "params": [],
        "return_type": "Connection",
        "signature": "Connection data(String... keyvals)",
        "original_string": "    Connection data(String... keyvals);",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/Connection.java",
        "class_name": "Connection",
        "class_uri": "src/main/java/org/jsoup/Connection.java.Connection",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "Connection",
            "classes": []
        },
        "docstring": "\nAdd one or more request {@code key, val} data parameter pairs.\n<p>Multiple parameters may be set at once, e.g.:\n<code>.data(\"name\", \"jsoup\", \"language\", \"Java\", \"language\", \"English\");</code> creates a query string like:\n<code>{@literal ?name=jsoup&language=Java&language=English}</code></p>\n<p>For GET requests, data parameters will be sent on the request query string. For POST (and other methods that\ncontain a body), they will be sent as body form parameters, unless the body is explicitly set by\n{@link #requestBody(String)}, in which case they will be query string parameters.</p>\n\n@param keyvals a set of key value pairs.\n@return this Connection, for chaining\n"
    },
    {
        "uris": "src/main/java/org/jsoup/Connection.java.Connection.[KeyVal]data(String)",
        "name": "data",
        "arg_nums": 1,
        "params": [
            {
                "name": "key",
                "type": "String"
            }
        ],
        "return_type": "KeyVal",
        "signature": "@Nullable KeyVal data(String key)",
        "original_string": "    @Nullable KeyVal data(String key);",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/Connection.java",
        "class_name": "Connection",
        "class_uri": "src/main/java/org/jsoup/Connection.java.Connection",
        "attributes": {
            "modifiers": "@Nullable",
            "marker_annotations": [
                "@Nullable"
            ],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "KeyVal",
            "classes": []
        },
        "docstring": "\nGet the data KeyVal for this key, if any\n@param key the data key\n@return null if not set\n"
    },
    {
        "uris": "src/main/java/org/jsoup/Connection.java.Connection.[Connection]requestBody(String)",
        "name": "requestBody",
        "arg_nums": 1,
        "params": [
            {
                "name": "body",
                "type": "String"
            }
        ],
        "return_type": "Connection",
        "signature": "Connection requestBody(String body)",
        "original_string": "    Connection requestBody(String body);",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/Connection.java",
        "class_name": "Connection",
        "class_uri": "src/main/java/org/jsoup/Connection.java.Connection",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "Connection",
            "classes": []
        },
        "docstring": "\nSet a POST (or PUT) request body. Useful when a server expects a plain request body (such as JSON), and not a set\nof URL encoded form key/value pairs. E.g.:\n<code><pre>Jsoup.connect(url)\n.requestBody(json)\n.header(\"Content-Type\", \"application/json\")\n.post();</pre></code>\nIf any data key/vals are supplied, they will be sent as URL query params.\n@return this Request, for chaining\n"
    },
    {
        "uris": "src/main/java/org/jsoup/Connection.java.Connection.[Connection]header(String,String)",
        "name": "header",
        "arg_nums": 2,
        "params": [
            {
                "name": "name",
                "type": "String"
            },
            {
                "name": "value",
                "type": "String"
            }
        ],
        "return_type": "Connection",
        "signature": "Connection header(String name, String value)",
        "original_string": "    Connection header(String name, String value);",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/Connection.java",
        "class_name": "Connection",
        "class_uri": "src/main/java/org/jsoup/Connection.java.Connection",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "Connection",
            "classes": []
        },
        "docstring": "\nSet a request header. Replaces any existing header with the same case-insensitive name.\n@param name header name\n@param value header value\n@return this Connection, for chaining\n@see org.jsoup.Connection.Request#header(String, String)\n@see org.jsoup.Connection.Request#headers()\n"
    },
    {
        "uris": "src/main/java/org/jsoup/Connection.java.Connection.[Connection]headers(Map<String,String>)",
        "name": "headers",
        "arg_nums": 1,
        "params": [
            {
                "name": "headers",
                "type": "Map<String,String>"
            }
        ],
        "return_type": "Connection",
        "signature": "Connection headers(Map<String,String> headers)",
        "original_string": "    Connection headers(Map<String,String> headers);",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/Connection.java",
        "class_name": "Connection",
        "class_uri": "src/main/java/org/jsoup/Connection.java.Connection",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "Connection",
            "classes": []
        },
        "docstring": "\nSets each of the supplied headers on the request. Existing headers with the same case-insensitive name will be\nreplaced with the new value.\n@param headers map of headers name {@literal ->} value pairs\n@return this Connection, for chaining\n@see org.jsoup.Connection.Request#headers()\n"
    },
    {
        "uris": "src/main/java/org/jsoup/Connection.java.Connection.[Connection]cookie(String,String)",
        "name": "cookie",
        "arg_nums": 2,
        "params": [
            {
                "name": "name",
                "type": "String"
            },
            {
                "name": "value",
                "type": "String"
            }
        ],
        "return_type": "Connection",
        "signature": "Connection cookie(String name, String value)",
        "original_string": "    Connection cookie(String name, String value);",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/Connection.java",
        "class_name": "Connection",
        "class_uri": "src/main/java/org/jsoup/Connection.java.Connection",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "Connection",
            "classes": []
        },
        "docstring": "\nSet a cookie to be sent in the request.\n@param name name of cookie\n@param value value of cookie\n@return this Connection, for chaining\n"
    },
    {
        "uris": "src/main/java/org/jsoup/Connection.java.Connection.[Connection]cookies(Map<String, String>)",
        "name": "cookies",
        "arg_nums": 1,
        "params": [
            {
                "name": "cookies",
                "type": "Map<String, String>"
            }
        ],
        "return_type": "Connection",
        "signature": "Connection cookies(Map<String, String> cookies)",
        "original_string": "    Connection cookies(Map<String, String> cookies);",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/Connection.java",
        "class_name": "Connection",
        "class_uri": "src/main/java/org/jsoup/Connection.java.Connection",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "Connection",
            "classes": []
        },
        "docstring": "\nAdds each of the supplied cookies to the request.\n@param cookies map of cookie name {@literal ->} value pairs\n@return this Connection, for chaining\n"
    },
    {
        "uris": "src/main/java/org/jsoup/Connection.java.Connection.[Connection]cookieStore(CookieStore)",
        "name": "cookieStore",
        "arg_nums": 1,
        "params": [
            {
                "name": "cookieStore",
                "type": "CookieStore"
            }
        ],
        "return_type": "Connection",
        "signature": "Connection cookieStore(CookieStore cookieStore)",
        "original_string": "    Connection cookieStore(CookieStore cookieStore);",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/Connection.java",
        "class_name": "Connection",
        "class_uri": "src/main/java/org/jsoup/Connection.java.Connection",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "Connection",
            "classes": []
        },
        "docstring": "\nProvide a custom or pre-filled CookieStore to be used on requests made by this Connection.\n@param cookieStore a cookie store to use for subsequent requests\n@return this Connection, for chaining\n@since 1.14.1\n"
    },
    {
        "uris": "src/main/java/org/jsoup/Connection.java.Connection.[CookieStore]cookieStore()",
        "name": "cookieStore",
        "arg_nums": 0,
        "params": [],
        "return_type": "CookieStore",
        "signature": "CookieStore cookieStore()",
        "original_string": "    CookieStore cookieStore();",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/Connection.java",
        "class_name": "Connection",
        "class_uri": "src/main/java/org/jsoup/Connection.java.Connection",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "CookieStore",
            "classes": []
        },
        "docstring": "\nGet the cookie store used by this Connection.\n@return the cookie store\n@since 1.14.1\n"
    },
    {
        "uris": "src/main/java/org/jsoup/Connection.java.Connection.[Connection]parser(Parser)",
        "name": "parser",
        "arg_nums": 1,
        "params": [
            {
                "name": "parser",
                "type": "Parser"
            }
        ],
        "return_type": "Connection",
        "signature": "Connection parser(Parser parser)",
        "original_string": "    Connection parser(Parser parser);",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/Connection.java",
        "class_name": "Connection",
        "class_uri": "src/main/java/org/jsoup/Connection.java.Connection",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "Connection",
            "classes": []
        },
        "docstring": "\nProvide a specific parser to use when parsing the response to a Document. If not set, jsoup defaults to the\n{@link Parser#htmlParser() HTML parser}, unless the response content-type is XML, in which case the\n{@link Parser#xmlParser() XML parser} is used.\n@param parser alternate parser\n@return this Connection, for chaining\n"
    },
    {
        "uris": "src/main/java/org/jsoup/Connection.java.Connection.[Connection]postDataCharset(String)",
        "name": "postDataCharset",
        "arg_nums": 1,
        "params": [
            {
                "name": "charset",
                "type": "String"
            }
        ],
        "return_type": "Connection",
        "signature": "Connection postDataCharset(String charset)",
        "original_string": "    Connection postDataCharset(String charset);",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/Connection.java",
        "class_name": "Connection",
        "class_uri": "src/main/java/org/jsoup/Connection.java.Connection",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "Connection",
            "classes": []
        },
        "docstring": "\nSet the character-set used to encode for x-www-form-urlencoded post data. Defaults to {@code UTF-8}.\n@param charset character set to encode post data\n@return this Connection, for chaining\n"
    },
    {
        "uris": "src/main/java/org/jsoup/Connection.java.Connection.[Connection]auth(RequestAuthenticator)",
        "name": "auth",
        "arg_nums": 1,
        "params": [
            {
                "name": "authenticator",
                "type": "RequestAuthenticator"
            }
        ],
        "return_type": "Connection",
        "signature": "default Connection auth(@Nullable RequestAuthenticator authenticator)",
        "original_string": "    default Connection auth(@Nullable RequestAuthenticator authenticator) {\n        throw new UnsupportedOperationException();\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/Connection.java",
        "class_name": "Connection",
        "class_uri": "src/main/java/org/jsoup/Connection.java.Connection",
        "attributes": {
            "modifiers": "default",
            "marker_annotations": [],
            "non_marker_annotations": [
                "default"
            ],
            "comments": [],
            "return_type": "Connection",
            "classes": []
        },
        "docstring": "\nSet the authenticator to use for this connection, enabling requests to URLs, and via proxies, that require\nauthentication credentials.\n<p>The authentication scheme used is automatically detected during the request execution.\nSupported schemes (subject to the platform) are {@code basic}, {@code digest}, {@code NTLM},\nand {@code Kerberos}.</p>\n\n<p>To use, supply a {@link RequestAuthenticator} function that:\n<ol>\n<li>validates the URL that is requesting authentication, and</li>\n<li>returns the appropriate credentials (username and password)</li>\n</ol>\n</p>\n\n<p>For example, to authenticate both to a proxy and a downstream web server:\n<code><pre>\nConnection session = Jsoup.newSession()\n.proxy(\"proxy.example.com\", 8080)\n.auth(auth -> {\nif (auth.isServer()) { // provide credentials for the request url\nValidate.isTrue(auth.url().getHost().equals(\"example.com\"));\n check that we're sending credentials were we expect, and not redirected out\nreturn auth.credentials(\"username\", \"password\");\n} else { // auth.isProxy()\nreturn auth.credentials(\"proxy-user\", \"proxy-password\");\n}\n});\n\nConnection.Response response = session.newRequest(\"https://example.com/adminzone/\").execute();\n</pre></code>\n</p>\n\n<p>The system may cache the authentication and use it for subsequent requests to the same resource.</p>\n\n<p><b>Implementation notes</b></p>\n<p>For compatibility, on a Java 8 platform, authentication is set up via the system-wide default\n{@link java.net.Authenticator#setDefault(Authenticator)} method via a ThreadLocal delegator. Whilst the\nauthenticator used is request specific and thread-safe, if you have other calls to {@code setDefault}, they will be\nincompatible with this implementation.</p>\n<p>On Java 9 and above, the preceding note does not apply; authenticators are directly set on the request. </p>\n<p>If you are attempting to authenticate to a proxy that uses the {@code basic} scheme and will be fetching HTTPS\nURLs, you need to configure your Java platform to enable that, by setting the\n{@code jdk.http.auth.tunneling.disabledSchemes} system property to {@code \"\"}.\nThis must be executed prior to any authorization attempts. E.g.:\n<code><pre>\nstatic {\nSystem.setProperty(\"jdk.http.auth.tunneling.disabledSchemes\", \"\");\n removes Basic, which is otherwise excluded from auth for CONNECT tunnels\n}</pre></code>\n</p>\n@param authenticator the authenticator to use in this connection\n@return this Connection, for chaining\n@since 1.17.1\n"
    },
    {
        "uris": "src/main/java/org/jsoup/Connection.java.Connection.[Document]get()",
        "name": "get",
        "arg_nums": 0,
        "params": [],
        "return_type": "Document",
        "signature": "Document get()",
        "original_string": "    Document get() throws IOException;",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/Connection.java",
        "class_name": "Connection",
        "class_uri": "src/main/java/org/jsoup/Connection.java.Connection",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "Document",
            "classes": []
        },
        "docstring": "\nExecute the request as a GET, and parse the result.\n@return parsed Document\n@throws java.net.MalformedURLException if the request URL is not an HTTP or HTTPS URL, or is otherwise malformed\n@throws HttpStatusException if the response is not OK and HTTP response errors are not ignored\n@throws UnsupportedMimeTypeException if the response mime type is not supported and those errors are not ignored\n@throws java.net.SocketTimeoutException if the connection times out\n@throws IOException on error\n"
    },
    {
        "uris": "src/main/java/org/jsoup/Connection.java.Connection.[Document]post()",
        "name": "post",
        "arg_nums": 0,
        "params": [],
        "return_type": "Document",
        "signature": "Document post()",
        "original_string": "    Document post() throws IOException;",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/Connection.java",
        "class_name": "Connection",
        "class_uri": "src/main/java/org/jsoup/Connection.java.Connection",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "Document",
            "classes": []
        },
        "docstring": "\nExecute the request as a POST, and parse the result.\n@return parsed Document\n@throws java.net.MalformedURLException if the request URL is not a HTTP or HTTPS URL, or is otherwise malformed\n@throws HttpStatusException if the response is not OK and HTTP response errors are not ignored\n@throws UnsupportedMimeTypeException if the response mime type is not supported and those errors are not ignored\n@throws java.net.SocketTimeoutException if the connection times out\n@throws IOException on error\n"
    },
    {
        "uris": "src/main/java/org/jsoup/Connection.java.Connection.[Response]execute()",
        "name": "execute",
        "arg_nums": 0,
        "params": [],
        "return_type": "Response",
        "signature": "Response execute()",
        "original_string": "    Response execute() throws IOException;",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/Connection.java",
        "class_name": "Connection",
        "class_uri": "src/main/java/org/jsoup/Connection.java.Connection",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "Response",
            "classes": []
        },
        "docstring": "\nExecute the request.\n@return the executed {@link Response}\n@throws java.net.MalformedURLException if the request URL is not a HTTP or HTTPS URL, or is otherwise malformed\n@throws HttpStatusException if the response is not OK and HTTP response errors are not ignored\n@throws UnsupportedMimeTypeException if the response mime type is not supported and those errors are not ignored\n@throws java.net.SocketTimeoutException if the connection times out\n@throws IOException on error\n"
    },
    {
        "uris": "src/main/java/org/jsoup/Connection.java.Connection.[Request]request()",
        "name": "request",
        "arg_nums": 0,
        "params": [],
        "return_type": "Request",
        "signature": "Request request()",
        "original_string": "    Request request();",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/Connection.java",
        "class_name": "Connection",
        "class_uri": "src/main/java/org/jsoup/Connection.java.Connection",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "Request",
            "classes": []
        },
        "docstring": "\nGet the request object associated with this connection\n@return request\n"
    },
    {
        "uris": "src/main/java/org/jsoup/Connection.java.Connection.[Connection]request(Request)",
        "name": "request",
        "arg_nums": 1,
        "params": [
            {
                "name": "request",
                "type": "Request"
            }
        ],
        "return_type": "Connection",
        "signature": "Connection request(Request request)",
        "original_string": "    Connection request(Request request);",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/Connection.java",
        "class_name": "Connection",
        "class_uri": "src/main/java/org/jsoup/Connection.java.Connection",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "Connection",
            "classes": []
        },
        "docstring": "\nSet the connection's request\n@param request new request object\n@return this Connection, for chaining\n"
    },
    {
        "uris": "src/main/java/org/jsoup/Connection.java.Connection.[Response]response()",
        "name": "response",
        "arg_nums": 0,
        "params": [],
        "return_type": "Response",
        "signature": "Response response()",
        "original_string": "    Response response();",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/Connection.java",
        "class_name": "Connection",
        "class_uri": "src/main/java/org/jsoup/Connection.java.Connection",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "Response",
            "classes": []
        },
        "docstring": "\nGet the response, once the request has been executed.\n@return response\n@throws IllegalArgumentException if called before the response has been executed.\n"
    },
    {
        "uris": "src/main/java/org/jsoup/Connection.java.Connection.[Connection]response(Response)",
        "name": "response",
        "arg_nums": 1,
        "params": [
            {
                "name": "response",
                "type": "Response"
            }
        ],
        "return_type": "Connection",
        "signature": "Connection response(Response response)",
        "original_string": "    Connection response(Response response);",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/Connection.java",
        "class_name": "Connection",
        "class_uri": "src/main/java/org/jsoup/Connection.java.Connection",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "Connection",
            "classes": []
        },
        "docstring": "\nSet the connection's response\n@param response new response\n@return this Connection, for chaining\n"
    },
    {
        "uris": "src/main/java/org/jsoup/Connection.java.Connection.[Connection]onResponseProgress(Progress<Response>)",
        "name": "onResponseProgress",
        "arg_nums": 1,
        "params": [
            {
                "name": "handler",
                "type": "Progress<Response>"
            }
        ],
        "return_type": "Connection",
        "signature": "default Connection onResponseProgress(Progress<Response> handler)",
        "original_string": "    default Connection onResponseProgress(Progress<Response> handler) {\n        throw new UnsupportedOperationException();\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/Connection.java",
        "class_name": "Connection",
        "class_uri": "src/main/java/org/jsoup/Connection.java.Connection",
        "attributes": {
            "modifiers": "default",
            "marker_annotations": [],
            "non_marker_annotations": [
                "default"
            ],
            "comments": [],
            "return_type": "Connection",
            "classes": []
        },
        "docstring": "\nSet the response progress handler, which will be called periodically as the response body is downloaded. Since\ndocuments are parsed as they are downloaded, this is also a good proxy for the parse progress.\n<p>The Response object is supplied as the progress context, and may be read from to obtain headers etc.</p>\n@param handler the progress handler\n@return this Connection, for chaining\n@since 1.18.1\n"
    },
    {
        "uris": "src/main/java/org/jsoup/Jsoup.java.Jsoup.[]Jsoup()",
        "name": "Jsoup",
        "arg_nums": 0,
        "params": [],
        "return_type": "",
        "signature": "private Jsoup()",
        "original_string": "    private Jsoup() {}",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/Jsoup.java",
        "class_name": "Jsoup",
        "class_uri": "src/main/java/org/jsoup/Jsoup.java.Jsoup",
        "attributes": {
            "modifiers": "private",
            "marker_annotations": [],
            "non_marker_annotations": [
                "private"
            ],
            "comments": [],
            "return_type": "",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/Jsoup.java.Jsoup.[Document]parse(String,String)",
        "name": "parse",
        "arg_nums": 2,
        "params": [
            {
                "name": "html",
                "type": "String"
            },
            {
                "name": "baseUri",
                "type": "String"
            }
        ],
        "return_type": "Document",
        "signature": "public static Document parse(String html, String baseUri)",
        "original_string": "    public static Document parse(String html, String baseUri) {\n        return Parser.parse(html, baseUri);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/Jsoup.java",
        "class_name": "Jsoup",
        "class_uri": "src/main/java/org/jsoup/Jsoup.java.Jsoup",
        "attributes": {
            "modifiers": "public static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public",
                "static"
            ],
            "comments": [],
            "return_type": "Document",
            "classes": []
        },
        "docstring": "\nParse HTML into a Document. The parser will make a sensible, balanced document tree out of any HTML.\n\n@param html    HTML to parse\n@param baseUri The URL where the HTML was retrieved from. Used to resolve relative URLs to absolute URLs, that occur\nbefore the HTML declares a {@code <base href>} tag.\n@return sane HTML\n"
    },
    {
        "uris": "src/main/java/org/jsoup/Jsoup.java.Jsoup.[Document]parse(String,String,Parser)",
        "name": "parse",
        "arg_nums": 3,
        "params": [
            {
                "name": "html",
                "type": "String"
            },
            {
                "name": "baseUri",
                "type": "String"
            },
            {
                "name": "parser",
                "type": "Parser"
            }
        ],
        "return_type": "Document",
        "signature": "public static Document parse(String html, String baseUri, Parser parser)",
        "original_string": "    public static Document parse(String html, String baseUri, Parser parser) {\n        return parser.parseInput(html, baseUri);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/Jsoup.java",
        "class_name": "Jsoup",
        "class_uri": "src/main/java/org/jsoup/Jsoup.java.Jsoup",
        "attributes": {
            "modifiers": "public static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public",
                "static"
            ],
            "comments": [],
            "return_type": "Document",
            "classes": []
        },
        "docstring": "\nParse HTML into a Document, using the provided Parser. You can provide an alternate parser, such as a simple XML\n(non-HTML) parser.\n\n@param html    HTML to parse\n@param baseUri The URL where the HTML was retrieved from. Used to resolve relative URLs to absolute URLs, that occur\nbefore the HTML declares a {@code <base href>} tag.\n@param parser alternate {@link Parser#xmlParser() parser} to use.\n@return sane HTML\n"
    },
    {
        "uris": "src/main/java/org/jsoup/Jsoup.java.Jsoup.[Document]parse(String,Parser)",
        "name": "parse",
        "arg_nums": 2,
        "params": [
            {
                "name": "html",
                "type": "String"
            },
            {
                "name": "parser",
                "type": "Parser"
            }
        ],
        "return_type": "Document",
        "signature": "public static Document parse(String html, Parser parser)",
        "original_string": "    public static Document parse(String html, Parser parser) {\n        return parser.parseInput(html, \"\");\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/Jsoup.java",
        "class_name": "Jsoup",
        "class_uri": "src/main/java/org/jsoup/Jsoup.java.Jsoup",
        "attributes": {
            "modifiers": "public static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public",
                "static"
            ],
            "comments": [],
            "return_type": "Document",
            "classes": []
        },
        "docstring": "\nParse HTML into a Document, using the provided Parser. You can provide an alternate parser, such as a simple XML\n(non-HTML) parser.  As no base URI is specified, absolute URL resolution, if required, relies on the HTML including\na {@code <base href>} tag.\n\n@param html    HTML to parse\nbefore the HTML declares a {@code <base href>} tag.\n@param parser alternate {@link Parser#xmlParser() parser} to use.\n@return sane HTML\n"
    },
    {
        "uris": "src/main/java/org/jsoup/Jsoup.java.Jsoup.[Document]parse(String)",
        "name": "parse",
        "arg_nums": 1,
        "params": [
            {
                "name": "html",
                "type": "String"
            }
        ],
        "return_type": "Document",
        "signature": "public static Document parse(String html)",
        "original_string": "    public static Document parse(String html) {\n        return Parser.parse(html, \"\");\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/Jsoup.java",
        "class_name": "Jsoup",
        "class_uri": "src/main/java/org/jsoup/Jsoup.java.Jsoup",
        "attributes": {
            "modifiers": "public static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public",
                "static"
            ],
            "comments": [],
            "return_type": "Document",
            "classes": []
        },
        "docstring": "\nParse HTML into a Document. As no base URI is specified, absolute URL resolution, if required, relies on the HTML\nincluding a {@code <base href>} tag.\n\n@param html HTML to parse\n@return sane HTML\n\n@see #parse(String, String)\n"
    },
    {
        "uris": "src/main/java/org/jsoup/Jsoup.java.Jsoup.[Connection]connect(String)",
        "name": "connect",
        "arg_nums": 1,
        "params": [
            {
                "name": "url",
                "type": "String"
            }
        ],
        "return_type": "Connection",
        "signature": "public static Connection connect(String url)",
        "original_string": "    public static Connection connect(String url) {\n        return HttpConnection.connect(url);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/Jsoup.java",
        "class_name": "Jsoup",
        "class_uri": "src/main/java/org/jsoup/Jsoup.java.Jsoup",
        "attributes": {
            "modifiers": "public static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public",
                "static"
            ],
            "comments": [],
            "return_type": "Connection",
            "classes": []
        },
        "docstring": "\nCreates a new {@link Connection} (session), with the defined request URL. Use to fetch and parse a HTML page.\n<p>\nUse examples:\n<ul>\n <li><code>Document doc = Jsoup.connect(\"http://example.com\").userAgent(\"Mozilla\").data(\"name\", \"jsoup\").get();</code></li>\n <li><code>Document doc = Jsoup.connect(\"http://example.com\").cookie(\"auth\", \"token\").post();</code></li>\n</ul>\n@param url URL to connect to. The protocol must be {@code http} or {@code https}.\n@return the connection. You can add data, cookies, and headers; set the user-agent, referrer, method; and then execute.\n@see #newSession()\n@see Connection#newRequest()\n"
    },
    {
        "uris": "src/main/java/org/jsoup/Jsoup.java.Jsoup.[Connection]newSession()",
        "name": "newSession",
        "arg_nums": 0,
        "params": [],
        "return_type": "Connection",
        "signature": "public static Connection newSession()",
        "original_string": "    public static Connection newSession() {\n        return new HttpConnection();\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/Jsoup.java",
        "class_name": "Jsoup",
        "class_uri": "src/main/java/org/jsoup/Jsoup.java.Jsoup",
        "attributes": {
            "modifiers": "public static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public",
                "static"
            ],
            "comments": [],
            "return_type": "Connection",
            "classes": []
        },
        "docstring": "\nCreates a new {@link Connection} to use as a session. Connection settings (user-agent, timeouts, URL, etc), and\ncookies will be maintained for the session. Use examples:\n<pre><code>\nConnection session = Jsoup.newSession()\n.timeout(20 * 1000)\n.userAgent(\"FooBar 2000\");\n\nDocument doc1 = session.newRequest()\n.url(\"https://jsoup.org/\").data(\"ref\", \"example\")\n.get();\nDocument doc2 = session.newRequest()\n.url(\"https://en.wikipedia.org/wiki/Main_Page\")\n.get();\nConnection con3 = session.newRequest();\n</code></pre>\n\n<p>For multi-threaded requests, it is safe to use this session between threads, but take care to call {@link\nConnection#newRequest()} per request and not share that instance between threads when executing or parsing.</p>\n\n@return a connection\n@since 1.14.1\n"
    },
    {
        "uris": "src/main/java/org/jsoup/Jsoup.java.Jsoup.[Document]parse(File,String,String)",
        "name": "parse",
        "arg_nums": 3,
        "params": [
            {
                "name": "file",
                "type": "File"
            },
            {
                "name": "charsetName",
                "type": "String"
            },
            {
                "name": "baseUri",
                "type": "String"
            }
        ],
        "return_type": "Document",
        "signature": "public static Document parse(File file, @Nullable String charsetName, String baseUri)",
        "original_string": "    public static Document parse(File file, @Nullable String charsetName, String baseUri) throws IOException {\n        return DataUtil.load(file, charsetName, baseUri);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/Jsoup.java",
        "class_name": "Jsoup",
        "class_uri": "src/main/java/org/jsoup/Jsoup.java.Jsoup",
        "attributes": {
            "modifiers": "public static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public",
                "static"
            ],
            "comments": [],
            "return_type": "Document",
            "classes": []
        },
        "docstring": "\nParse the contents of a file as HTML.\n\n@param file          file to load HTML from. Supports gzipped files (ending in .z or .gz).\n@param charsetName (optional) character set of file contents. Set to {@code null} to determine from {@code http-equiv} meta tag, if\npresent, or fall back to {@code UTF-8} (which is often safe to do).\n@param baseUri     The URL where the HTML was retrieved from, to resolve relative links against.\n@return sane HTML\n\n@throws IOException if the file could not be found, or read, or if the charsetName is invalid.\n"
    },
    {
        "uris": "src/main/java/org/jsoup/Jsoup.java.Jsoup.[Document]parse(File,String)",
        "name": "parse",
        "arg_nums": 2,
        "params": [
            {
                "name": "file",
                "type": "File"
            },
            {
                "name": "charsetName",
                "type": "String"
            }
        ],
        "return_type": "Document",
        "signature": "public static Document parse(File file, @Nullable String charsetName)",
        "original_string": "    public static Document parse(File file, @Nullable String charsetName) throws IOException {\n        return DataUtil.load(file, charsetName, file.getAbsolutePath());\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/Jsoup.java",
        "class_name": "Jsoup",
        "class_uri": "src/main/java/org/jsoup/Jsoup.java.Jsoup",
        "attributes": {
            "modifiers": "public static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public",
                "static"
            ],
            "comments": [],
            "return_type": "Document",
            "classes": []
        },
        "docstring": "\nParse the contents of a file as HTML. The location of the file is used as the base URI to qualify relative URLs.\n\n@param file        file to load HTML from. Supports gzipped files (ending in .z or .gz).\n@param charsetName (optional) character set of file contents. Set to {@code null} to determine from {@code http-equiv} meta tag, if\npresent, or fall back to {@code UTF-8} (which is often safe to do).\n@return sane HTML\n\n@throws IOException if the file could not be found, or read, or if the charsetName is invalid.\n@see #parse(File, String, String) parse(file, charset, baseUri)\n"
    },
    {
        "uris": "src/main/java/org/jsoup/Jsoup.java.Jsoup.[Document]parse(File)",
        "name": "parse",
        "arg_nums": 1,
        "params": [
            {
                "name": "file",
                "type": "File"
            }
        ],
        "return_type": "Document",
        "signature": "public static Document parse(File file)",
        "original_string": "    public static Document parse(File file) throws IOException {\n        return DataUtil.load(file, null, file.getAbsolutePath());\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/Jsoup.java",
        "class_name": "Jsoup",
        "class_uri": "src/main/java/org/jsoup/Jsoup.java.Jsoup",
        "attributes": {
            "modifiers": "public static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public",
                "static"
            ],
            "comments": [],
            "return_type": "Document",
            "classes": []
        },
        "docstring": "\nParse the contents of a file as HTML. The location of the file is used as the base URI to qualify relative URLs.\nThe charset used to read the file will be determined by the byte-order-mark (BOM), or a {@code <meta charset>} tag,\nor if neither is present, will be {@code UTF-8}.\n\n<p>This is the equivalent of calling {@link #parse(File, String) parse(file, null)}</p>\n\n@param file the file to load HTML from. Supports gzipped files (ending in .z or .gz).\n@return sane HTML\n@throws IOException if the file could not be found or read.\n@see #parse(File, String, String) parse(file, charset, baseUri)\n@since 1.15.1\n"
    },
    {
        "uris": "src/main/java/org/jsoup/Jsoup.java.Jsoup.[Document]parse(File,String,String,Parser)",
        "name": "parse",
        "arg_nums": 4,
        "params": [
            {
                "name": "file",
                "type": "File"
            },
            {
                "name": "charsetName",
                "type": "String"
            },
            {
                "name": "baseUri",
                "type": "String"
            },
            {
                "name": "parser",
                "type": "Parser"
            }
        ],
        "return_type": "Document",
        "signature": "public static Document parse(File file, @Nullable String charsetName, String baseUri, Parser parser)",
        "original_string": "    public static Document parse(File file, @Nullable String charsetName, String baseUri, Parser parser) throws IOException {\n        return DataUtil.load(file, charsetName, baseUri, parser);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/Jsoup.java",
        "class_name": "Jsoup",
        "class_uri": "src/main/java/org/jsoup/Jsoup.java.Jsoup",
        "attributes": {
            "modifiers": "public static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public",
                "static"
            ],
            "comments": [],
            "return_type": "Document",
            "classes": []
        },
        "docstring": "\nParse the contents of a file as HTML.\n\n@param file          file to load HTML from. Supports gzipped files (ending in .z or .gz).\n@param charsetName (optional) character set of file contents. Set to {@code null} to determine from {@code http-equiv} meta tag, if\npresent, or fall back to {@code UTF-8} (which is often safe to do).\n@param baseUri     The URL where the HTML was retrieved from, to resolve relative links against.\n@param parser alternate {@link Parser#xmlParser() parser} to use.\n@return sane HTML\n\n@throws IOException if the file could not be found, or read, or if the charsetName is invalid.\n@since 1.14.2\n"
    },
    {
        "uris": "src/main/java/org/jsoup/Jsoup.java.Jsoup.[Document]parse(Path,String,String)",
        "name": "parse",
        "arg_nums": 3,
        "params": [
            {
                "name": "path",
                "type": "Path"
            },
            {
                "name": "charsetName",
                "type": "String"
            },
            {
                "name": "baseUri",
                "type": "String"
            }
        ],
        "return_type": "Document",
        "signature": "public static Document parse(Path path, @Nullable String charsetName, String baseUri)",
        "original_string": "    public static Document parse(Path path, @Nullable String charsetName, String baseUri) throws IOException {\n        return DataUtil.load(path, charsetName, baseUri);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/Jsoup.java",
        "class_name": "Jsoup",
        "class_uri": "src/main/java/org/jsoup/Jsoup.java.Jsoup",
        "attributes": {
            "modifiers": "public static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public",
                "static"
            ],
            "comments": [],
            "return_type": "Document",
            "classes": []
        },
        "docstring": "\nParse the contents of a file as HTML.\n\n@param path          file to load HTML from. Supports gzipped files (ending in .z or .gz).\n@param charsetName (optional) character set of file contents. Set to {@code null} to determine from {@code http-equiv} meta tag, if\npresent, or fall back to {@code UTF-8} (which is often safe to do).\n@param baseUri     The URL where the HTML was retrieved from, to resolve relative links against.\n@return sane HTML\n\n@throws IOException if the file could not be found, or read, or if the charsetName is invalid.\n@since 1.18.1\n"
    },
    {
        "uris": "src/main/java/org/jsoup/Jsoup.java.Jsoup.[Document]parse(Path,String)",
        "name": "parse",
        "arg_nums": 2,
        "params": [
            {
                "name": "path",
                "type": "Path"
            },
            {
                "name": "charsetName",
                "type": "String"
            }
        ],
        "return_type": "Document",
        "signature": "public static Document parse(Path path, @Nullable String charsetName)",
        "original_string": "    public static Document parse(Path path, @Nullable String charsetName) throws IOException {\n        return DataUtil.load(path, charsetName, path.toAbsolutePath().toString());\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/Jsoup.java",
        "class_name": "Jsoup",
        "class_uri": "src/main/java/org/jsoup/Jsoup.java.Jsoup",
        "attributes": {
            "modifiers": "public static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public",
                "static"
            ],
            "comments": [],
            "return_type": "Document",
            "classes": []
        },
        "docstring": "\nParse the contents of a file as HTML. The location of the file is used as the base URI to qualify relative URLs.\n\n@param path        file to load HTML from. Supports gzipped files (ending in .z or .gz).\n@param charsetName (optional) character set of file contents. Set to {@code null} to determine from {@code http-equiv} meta tag, if\npresent, or fall back to {@code UTF-8} (which is often safe to do).\n@return sane HTML\n\n@throws IOException if the file could not be found, or read, or if the charsetName is invalid.\n@see #parse(File, String, String) parse(file, charset, baseUri)\n@since 1.18.1\n"
    },
    {
        "uris": "src/main/java/org/jsoup/Jsoup.java.Jsoup.[Document]parse(Path)",
        "name": "parse",
        "arg_nums": 1,
        "params": [
            {
                "name": "path",
                "type": "Path"
            }
        ],
        "return_type": "Document",
        "signature": "public static Document parse(Path path)",
        "original_string": "    public static Document parse(Path path) throws IOException {\n        return DataUtil.load(path, null, path.toAbsolutePath().toString());\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/Jsoup.java",
        "class_name": "Jsoup",
        "class_uri": "src/main/java/org/jsoup/Jsoup.java.Jsoup",
        "attributes": {
            "modifiers": "public static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public",
                "static"
            ],
            "comments": [],
            "return_type": "Document",
            "classes": []
        },
        "docstring": "\nParse the contents of a file as HTML. The location of the file is used as the base URI to qualify relative URLs.\nThe charset used to read the file will be determined by the byte-order-mark (BOM), or a {@code <meta charset>} tag,\nor if neither is present, will be {@code UTF-8}.\n\n<p>This is the equivalent of calling {@link #parse(File, String) parse(file, null)}</p>\n\n@param path the file to load HTML from. Supports gzipped files (ending in .z or .gz).\n@return sane HTML\n@throws IOException if the file could not be found or read.\n@see #parse(Path, String, String) parse(file, charset, baseUri)\n@since 1.18.1\n"
    },
    {
        "uris": "src/main/java/org/jsoup/Jsoup.java.Jsoup.[Document]parse(Path,String,String,Parser)",
        "name": "parse",
        "arg_nums": 4,
        "params": [
            {
                "name": "path",
                "type": "Path"
            },
            {
                "name": "charsetName",
                "type": "String"
            },
            {
                "name": "baseUri",
                "type": "String"
            },
            {
                "name": "parser",
                "type": "Parser"
            }
        ],
        "return_type": "Document",
        "signature": "public static Document parse(Path path, @Nullable String charsetName, String baseUri, Parser parser)",
        "original_string": "    public static Document parse(Path path, @Nullable String charsetName, String baseUri, Parser parser) throws IOException {\n        return DataUtil.load(path, charsetName, baseUri, parser);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/Jsoup.java",
        "class_name": "Jsoup",
        "class_uri": "src/main/java/org/jsoup/Jsoup.java.Jsoup",
        "attributes": {
            "modifiers": "public static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public",
                "static"
            ],
            "comments": [],
            "return_type": "Document",
            "classes": []
        },
        "docstring": "\nParse the contents of a file as HTML.\n\n@param path          file to load HTML from. Supports gzipped files (ending in .z or .gz).\n@param charsetName (optional) character set of file contents. Set to {@code null} to determine from {@code http-equiv} meta tag, if\npresent, or fall back to {@code UTF-8} (which is often safe to do).\n@param baseUri     The URL where the HTML was retrieved from, to resolve relative links against.\n@param parser alternate {@link Parser#xmlParser() parser} to use.\n@return sane HTML\n\n@throws IOException if the file could not be found, or read, or if the charsetName is invalid.\n@since 1.18.1\n"
    },
    {
        "uris": "src/main/java/org/jsoup/Jsoup.java.Jsoup.[Document]parse(InputStream,String,String)",
        "name": "parse",
        "arg_nums": 3,
        "params": [
            {
                "name": "in",
                "type": "InputStream"
            },
            {
                "name": "charsetName",
                "type": "String"
            },
            {
                "name": "baseUri",
                "type": "String"
            }
        ],
        "return_type": "Document",
        "signature": "public static Document parse(InputStream in, @Nullable String charsetName, String baseUri)",
        "original_string": "    public static Document parse(InputStream in, @Nullable String charsetName, String baseUri) throws IOException {\n        return DataUtil.load(in, charsetName, baseUri);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/Jsoup.java",
        "class_name": "Jsoup",
        "class_uri": "src/main/java/org/jsoup/Jsoup.java.Jsoup",
        "attributes": {
            "modifiers": "public static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public",
                "static"
            ],
            "comments": [],
            "return_type": "Document",
            "classes": []
        },
        "docstring": "\nRead an input stream, and parse it to a Document.\n\n@param in          input stream to read. The stream will be closed after reading.\n@param charsetName (optional) character set of file contents. Set to {@code null} to determine from {@code http-equiv} meta tag, if\npresent, or fall back to {@code UTF-8} (which is often safe to do).\n@param baseUri     The URL where the HTML was retrieved from, to resolve relative links against.\n@return sane HTML\n\n@throws IOException if the file could not be found, or read, or if the charsetName is invalid.\n"
    },
    {
        "uris": "src/main/java/org/jsoup/Jsoup.java.Jsoup.[Document]parse(InputStream,String,String,Parser)",
        "name": "parse",
        "arg_nums": 4,
        "params": [
            {
                "name": "in",
                "type": "InputStream"
            },
            {
                "name": "charsetName",
                "type": "String"
            },
            {
                "name": "baseUri",
                "type": "String"
            },
            {
                "name": "parser",
                "type": "Parser"
            }
        ],
        "return_type": "Document",
        "signature": "public static Document parse(InputStream in, @Nullable String charsetName, String baseUri, Parser parser)",
        "original_string": "    public static Document parse(InputStream in, @Nullable String charsetName, String baseUri, Parser parser) throws IOException {\n        return DataUtil.load(in, charsetName, baseUri, parser);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/Jsoup.java",
        "class_name": "Jsoup",
        "class_uri": "src/main/java/org/jsoup/Jsoup.java.Jsoup",
        "attributes": {
            "modifiers": "public static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public",
                "static"
            ],
            "comments": [],
            "return_type": "Document",
            "classes": []
        },
        "docstring": "\nRead an input stream, and parse it to a Document. You can provide an alternate parser, such as a simple XML\n(non-HTML) parser.\n\n@param in          input stream to read. Make sure to close it after parsing.\n@param charsetName (optional) character set of file contents. Set to {@code null} to determine from {@code http-equiv} meta tag, if\npresent, or fall back to {@code UTF-8} (which is often safe to do).\n@param baseUri     The URL where the HTML was retrieved from, to resolve relative links against.\n@param parser alternate {@link Parser#xmlParser() parser} to use.\n@return sane HTML\n\n@throws IOException if the file could not be found, or read, or if the charsetName is invalid.\n"
    },
    {
        "uris": "src/main/java/org/jsoup/Jsoup.java.Jsoup.[Document]parseBodyFragment(String,String)",
        "name": "parseBodyFragment",
        "arg_nums": 2,
        "params": [
            {
                "name": "bodyHtml",
                "type": "String"
            },
            {
                "name": "baseUri",
                "type": "String"
            }
        ],
        "return_type": "Document",
        "signature": "public static Document parseBodyFragment(String bodyHtml, String baseUri)",
        "original_string": "    public static Document parseBodyFragment(String bodyHtml, String baseUri) {\n        return Parser.parseBodyFragment(bodyHtml, baseUri);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/Jsoup.java",
        "class_name": "Jsoup",
        "class_uri": "src/main/java/org/jsoup/Jsoup.java.Jsoup",
        "attributes": {
            "modifiers": "public static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public",
                "static"
            ],
            "comments": [],
            "return_type": "Document",
            "classes": []
        },
        "docstring": "\nParse a fragment of HTML, with the assumption that it forms the {@code body} of the HTML.\n\n@param bodyHtml body HTML fragment\n@param baseUri  URL to resolve relative URLs against.\n@return sane HTML document\n\n@see Document#body()\n"
    },
    {
        "uris": "src/main/java/org/jsoup/Jsoup.java.Jsoup.[Document]parseBodyFragment(String)",
        "name": "parseBodyFragment",
        "arg_nums": 1,
        "params": [
            {
                "name": "bodyHtml",
                "type": "String"
            }
        ],
        "return_type": "Document",
        "signature": "public static Document parseBodyFragment(String bodyHtml)",
        "original_string": "    public static Document parseBodyFragment(String bodyHtml) {\n        return Parser.parseBodyFragment(bodyHtml, \"\");\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/Jsoup.java",
        "class_name": "Jsoup",
        "class_uri": "src/main/java/org/jsoup/Jsoup.java.Jsoup",
        "attributes": {
            "modifiers": "public static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public",
                "static"
            ],
            "comments": [],
            "return_type": "Document",
            "classes": []
        },
        "docstring": "\nParse a fragment of HTML, with the assumption that it forms the {@code body} of the HTML.\n\n@param bodyHtml body HTML fragment\n@return sane HTML document\n\n@see Document#body()\n"
    },
    {
        "uris": "src/main/java/org/jsoup/Jsoup.java.Jsoup.[Document]parse(URL,int)",
        "name": "parse",
        "arg_nums": 2,
        "params": [
            {
                "name": "url",
                "type": "URL"
            },
            {
                "name": "timeoutMillis",
                "type": "int"
            }
        ],
        "return_type": "Document",
        "signature": "public static Document parse(URL url, int timeoutMillis)",
        "original_string": "    public static Document parse(URL url, int timeoutMillis) throws IOException {\n        Connection con = HttpConnection.connect(url);\n        con.timeout(timeoutMillis);\n        return con.get();\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/Jsoup.java",
        "class_name": "Jsoup",
        "class_uri": "src/main/java/org/jsoup/Jsoup.java.Jsoup",
        "attributes": {
            "modifiers": "public static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public",
                "static"
            ],
            "comments": [],
            "return_type": "Document",
            "classes": []
        },
        "docstring": "\nFetch a URL, and parse it as HTML. Provided for compatibility; in most cases use {@link #connect(String)} instead.\n<p>\nThe encoding character set is determined by the content-type header or http-equiv meta tag, or falls back to {@code UTF-8}.\n\n@param url           URL to fetch (with a GET). The protocol must be {@code http} or {@code https}.\n@param timeoutMillis Connection and read timeout, in milliseconds. If exceeded, IOException is thrown.\n@return The parsed HTML.\n\n@throws java.net.MalformedURLException if the request URL is not a HTTP or HTTPS URL, or is otherwise malformed\n@throws HttpStatusException if the response is not OK and HTTP response errors are not ignored\n@throws UnsupportedMimeTypeException if the response mime type is not supported and those errors are not ignored\n@throws java.net.SocketTimeoutException if the connection times out\n@throws IOException if a connection or read error occurs\n\n@see #connect(String)\n"
    },
    {
        "uris": "src/main/java/org/jsoup/Jsoup.java.Jsoup.[String]clean(String,String,Safelist)",
        "name": "clean",
        "arg_nums": 3,
        "params": [
            {
                "name": "bodyHtml",
                "type": "String"
            },
            {
                "name": "baseUri",
                "type": "String"
            },
            {
                "name": "safelist",
                "type": "Safelist"
            }
        ],
        "return_type": "String",
        "signature": "public static String clean(String bodyHtml, String baseUri, Safelist safelist)",
        "original_string": "    public static String clean(String bodyHtml, String baseUri, Safelist safelist) {\n        Document dirty = parseBodyFragment(bodyHtml, baseUri);\n        Cleaner cleaner = new Cleaner(safelist);\n        Document clean = cleaner.clean(dirty);\n        return clean.body().html();\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/Jsoup.java",
        "class_name": "Jsoup",
        "class_uri": "src/main/java/org/jsoup/Jsoup.java.Jsoup",
        "attributes": {
            "modifiers": "public static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public",
                "static"
            ],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": "\nGet safe HTML from untrusted input HTML, by parsing input HTML and filtering it through an allow-list of safe\ntags and attributes.\n\n@param bodyHtml  input untrusted HTML (body fragment)\n@param baseUri   URL to resolve relative URLs against\n@param safelist  list of permitted HTML elements\n@return safe HTML (body fragment)\n\n@see Cleaner#clean(Document)\n"
    },
    {
        "uris": "src/main/java/org/jsoup/Jsoup.java.Jsoup.[String]clean(String,Safelist)",
        "name": "clean",
        "arg_nums": 2,
        "params": [
            {
                "name": "bodyHtml",
                "type": "String"
            },
            {
                "name": "safelist",
                "type": "Safelist"
            }
        ],
        "return_type": "String",
        "signature": "public static String clean(String bodyHtml, Safelist safelist)",
        "original_string": "    public static String clean(String bodyHtml, Safelist safelist) {\n        return clean(bodyHtml, \"\", safelist);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/Jsoup.java",
        "class_name": "Jsoup",
        "class_uri": "src/main/java/org/jsoup/Jsoup.java.Jsoup",
        "attributes": {
            "modifiers": "public static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public",
                "static"
            ],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": "\nGet safe HTML from untrusted input HTML, by parsing input HTML and filtering it through a safe-list of permitted\ntags and attributes.\n\n<p>Note that as this method does not take a base href URL to resolve attributes with relative URLs against, those\nURLs will be removed, unless the input HTML contains a {@code <base href> tag}. If you wish to preserve those, use\nthe {@link Jsoup#clean(String html, String baseHref, Safelist)} method instead, and enable\n{@link Safelist#preserveRelativeLinks(boolean)}.</p>\n\n<p>Note that the output of this method is still <b>HTML</b> even when using the TextNode only\n{@link Safelist#none()}, and so any HTML entities in the output will be appropriately escaped.\nIf you want plain text, not HTML, you should use a text method such as {@link Element#text()} instead, after\ncleaning the document.</p>\n<p>Example:</p>\n<pre>{@code\nString sourceBodyHtml = \"<p>5 is &lt; 6.</p>\";\nString html = Jsoup.clean(sourceBodyHtml, Safelist.none());\n\nCleaner cleaner = new Cleaner(Safelist.none());\nString text = cleaner.clean(Jsoup.parse(sourceBodyHtml)).text();\n\n html is: 5 is &lt; 6.\n text is: 5 is < 6.\n}</pre>\n\n@param bodyHtml input untrusted HTML (body fragment)\n@param safelist list of permitted HTML elements\n@return safe HTML (body fragment)\n@see Cleaner#clean(Document)\n"
    },
    {
        "uris": "src/main/java/org/jsoup/Jsoup.java.Jsoup.[String]clean(String,String,Safelist,Document.OutputSettings)",
        "name": "clean",
        "arg_nums": 4,
        "params": [
            {
                "name": "bodyHtml",
                "type": "String"
            },
            {
                "name": "baseUri",
                "type": "String"
            },
            {
                "name": "safelist",
                "type": "Safelist"
            },
            {
                "name": "outputSettings",
                "type": "Document.OutputSettings"
            }
        ],
        "return_type": "String",
        "signature": "public static String clean(String bodyHtml, String baseUri, Safelist safelist, Document.OutputSettings outputSettings)",
        "original_string": "    public static String clean(String bodyHtml, String baseUri, Safelist safelist, Document.OutputSettings outputSettings) {\n        Document dirty = parseBodyFragment(bodyHtml, baseUri);\n        Cleaner cleaner = new Cleaner(safelist);\n        Document clean = cleaner.clean(dirty);\n        clean.outputSettings(outputSettings);\n        return clean.body().html();\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/Jsoup.java",
        "class_name": "Jsoup",
        "class_uri": "src/main/java/org/jsoup/Jsoup.java.Jsoup",
        "attributes": {
            "modifiers": "public static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public",
                "static"
            ],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": "\nGet safe HTML from untrusted input HTML, by parsing input HTML and filtering it through a safe-list of\npermitted tags and attributes.\n<p>The HTML is treated as a body fragment; it's expected the cleaned HTML will be used within the body of an\nexisting document. If you want to clean full documents, use {@link Cleaner#clean(Document)} instead, and add\nstructural tags (<code>html, head, body</code> etc) to the safelist.\n\n@param bodyHtml input untrusted HTML (body fragment)\n@param baseUri URL to resolve relative URLs against\n@param safelist list of permitted HTML elements\n@param outputSettings document output settings; use to control pretty-printing and entity escape modes\n@return safe HTML (body fragment)\n@see Cleaner#clean(Document)\n"
    },
    {
        "uris": "src/main/java/org/jsoup/Jsoup.java.Jsoup.[boolean]isValid(String,Safelist)",
        "name": "isValid",
        "arg_nums": 2,
        "params": [
            {
                "name": "bodyHtml",
                "type": "String"
            },
            {
                "name": "safelist",
                "type": "Safelist"
            }
        ],
        "return_type": "boolean",
        "signature": "public static boolean isValid(String bodyHtml, Safelist safelist)",
        "original_string": "    public static boolean isValid(String bodyHtml, Safelist safelist) {\n        return new Cleaner(safelist).isValidBodyHtml(bodyHtml);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/Jsoup.java",
        "class_name": "Jsoup",
        "class_uri": "src/main/java/org/jsoup/Jsoup.java.Jsoup",
        "attributes": {
            "modifiers": "public static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public",
                "static"
            ],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": "\nTest if the input body HTML has only tags and attributes allowed by the Safelist. Useful for form validation.\n<p>\nThis method is intended to be used in a user interface as a validator for user input. Note that regardless of the\noutput of this method, the input document <b>must always</b> be normalized using a method such as\n{@link #clean(String, String, Safelist)}, and the result of that method used to store or serialize the document\nbefore later reuse such as presentation to end users. This ensures that enforced attributes are set correctly, and\nthat any differences between how a given browser and how jsoup parses the input HTML are normalized.\n</p>\n<p>Example:</p>\n<pre>{@code\nSafelist safelist = Safelist.relaxed();\nboolean isValid = Jsoup.isValid(sourceBodyHtml, safelist);\nString normalizedHtml = Jsoup.clean(sourceBodyHtml, \"https://example.com/\", safelist);\n}</pre>\n<p>Assumes the HTML is a body fragment (i.e. will be used in an existing HTML document body.)\n@param bodyHtml HTML to test\n@param safelist safelist to test against\n@return true if no tags or attributes were removed; false otherwise\n@see #clean(String, Safelist)\n"
    },
    {
        "uris": "src/main/java/org/jsoup/HttpStatusException.java.HttpStatusException.[]HttpStatusException(String,int,String)",
        "name": "HttpStatusException",
        "arg_nums": 3,
        "params": [
            {
                "name": "message",
                "type": "String"
            },
            {
                "name": "statusCode",
                "type": "int"
            },
            {
                "name": "url",
                "type": "String"
            }
        ],
        "return_type": "",
        "signature": "public HttpStatusException(String message, int statusCode, String url)",
        "original_string": "    public HttpStatusException(String message, int statusCode, String url) {\n        super(message + \". Status=\" + statusCode + \", URL=[\" + url + \"]\");\n        this.statusCode = statusCode;\n        this.url = url;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/HttpStatusException.java",
        "class_name": "HttpStatusException",
        "class_uri": "src/main/java/org/jsoup/HttpStatusException.java.HttpStatusException",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/HttpStatusException.java.HttpStatusException.[int]getStatusCode()",
        "name": "getStatusCode",
        "arg_nums": 0,
        "params": [],
        "return_type": "int",
        "signature": "public int getStatusCode()",
        "original_string": "    public int getStatusCode() {\n        return statusCode;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/HttpStatusException.java",
        "class_name": "HttpStatusException",
        "class_uri": "src/main/java/org/jsoup/HttpStatusException.java.HttpStatusException",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "int",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/HttpStatusException.java.HttpStatusException.[String]getUrl()",
        "name": "getUrl",
        "arg_nums": 0,
        "params": [],
        "return_type": "String",
        "signature": "public String getUrl()",
        "original_string": "    public String getUrl() {\n        return url;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/HttpStatusException.java",
        "class_name": "HttpStatusException",
        "class_uri": "src/main/java/org/jsoup/HttpStatusException.java.HttpStatusException",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/SerializationException.java.SerializationException.[]SerializationException()",
        "name": "SerializationException",
        "arg_nums": 0,
        "params": [],
        "return_type": "",
        "signature": "public SerializationException()",
        "original_string": " public SerializationException() {\n\t\tsuper();\n\t}",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/SerializationException.java",
        "class_name": "SerializationException",
        "class_uri": "src/main/java/org/jsoup/SerializationException.java.SerializationException",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "",
            "classes": []
        },
        "docstring": "\nCreates and initializes a new serialization exception with no error message and cause.\n"
    },
    {
        "uris": "src/main/java/org/jsoup/SerializationException.java.SerializationException.[]SerializationException(String)",
        "name": "SerializationException",
        "arg_nums": 1,
        "params": [
            {
                "name": "message",
                "type": "String"
            }
        ],
        "return_type": "",
        "signature": "public SerializationException(String message)",
        "original_string": " public SerializationException(String message) {\n\t\tsuper(message);\n\t}",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/SerializationException.java",
        "class_name": "SerializationException",
        "class_uri": "src/main/java/org/jsoup/SerializationException.java.SerializationException",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "",
            "classes": []
        },
        "docstring": "\nCreates and initializes a new serialization exception with the given error message and no cause.\n\n@param message\n           the error message of the new serialization exception (may be <code>null</code>).\n"
    },
    {
        "uris": "src/main/java/org/jsoup/SerializationException.java.SerializationException.[]SerializationException(Throwable)",
        "name": "SerializationException",
        "arg_nums": 1,
        "params": [
            {
                "name": "cause",
                "type": "Throwable"
            }
        ],
        "return_type": "",
        "signature": "public SerializationException(Throwable cause)",
        "original_string": " public SerializationException(Throwable cause) {\n\t\tsuper(cause);\n\t}",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/SerializationException.java",
        "class_name": "SerializationException",
        "class_uri": "src/main/java/org/jsoup/SerializationException.java.SerializationException",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "",
            "classes": []
        },
        "docstring": "\nCreates and initializes a new serialization exception with the specified cause and an error message of\n<code>(cause==null ? null : cause.toString())</code> (which typically contains the class and error message of\n<code>cause</code>).\n\n@param cause\n           the cause of the new serialization exception (may be <code>null</code>).\n"
    },
    {
        "uris": "src/main/java/org/jsoup/SerializationException.java.SerializationException.[]SerializationException(String,Throwable)",
        "name": "SerializationException",
        "arg_nums": 2,
        "params": [
            {
                "name": "message",
                "type": "String"
            },
            {
                "name": "cause",
                "type": "Throwable"
            }
        ],
        "return_type": "",
        "signature": "public SerializationException(String message, Throwable cause)",
        "original_string": " public SerializationException(String message, Throwable cause) {\n\t\tsuper(message, cause);\n\t}",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/SerializationException.java",
        "class_name": "SerializationException",
        "class_uri": "src/main/java/org/jsoup/SerializationException.java.SerializationException",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "",
            "classes": []
        },
        "docstring": "\nCreates and initializes a new serialization exception with the given error message and cause.\n\n@param message\n           the error message of the new serialization exception.\n@param cause\n           the cause of the new serialization exception.\n"
    },
    {
        "uris": "src/main/java/org/jsoup/UnsupportedMimeTypeException.java.UnsupportedMimeTypeException.[]UnsupportedMimeTypeException(String,String,String)",
        "name": "UnsupportedMimeTypeException",
        "arg_nums": 3,
        "params": [
            {
                "name": "message",
                "type": "String"
            },
            {
                "name": "mimeType",
                "type": "String"
            },
            {
                "name": "url",
                "type": "String"
            }
        ],
        "return_type": "",
        "signature": "public UnsupportedMimeTypeException(String message, String mimeType, String url)",
        "original_string": "    public UnsupportedMimeTypeException(String message, String mimeType, String url) {\n        super(message);\n        this.mimeType = mimeType;\n        this.url = url;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/UnsupportedMimeTypeException.java",
        "class_name": "UnsupportedMimeTypeException",
        "class_uri": "src/main/java/org/jsoup/UnsupportedMimeTypeException.java.UnsupportedMimeTypeException",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/UnsupportedMimeTypeException.java.UnsupportedMimeTypeException.[String]getMimeType()",
        "name": "getMimeType",
        "arg_nums": 0,
        "params": [],
        "return_type": "String",
        "signature": "public String getMimeType()",
        "original_string": "    public String getMimeType() {\n        return mimeType;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/UnsupportedMimeTypeException.java",
        "class_name": "UnsupportedMimeTypeException",
        "class_uri": "src/main/java/org/jsoup/UnsupportedMimeTypeException.java.UnsupportedMimeTypeException",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/UnsupportedMimeTypeException.java.UnsupportedMimeTypeException.[String]getUrl()",
        "name": "getUrl",
        "arg_nums": 0,
        "params": [],
        "return_type": "String",
        "signature": "public String getUrl()",
        "original_string": "    public String getUrl() {\n        return url;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/UnsupportedMimeTypeException.java",
        "class_name": "UnsupportedMimeTypeException",
        "class_uri": "src/main/java/org/jsoup/UnsupportedMimeTypeException.java.UnsupportedMimeTypeException",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/UnsupportedMimeTypeException.java.UnsupportedMimeTypeException.[String]toString()",
        "name": "toString",
        "arg_nums": 0,
        "params": [],
        "return_type": "String",
        "signature": "@Override\n    public String toString()",
        "original_string": "    @Override\n    public String toString() {\n        return super.toString() + \". Mimetype=\" + mimeType + \", URL=\"+url;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/UnsupportedMimeTypeException.java",
        "class_name": "UnsupportedMimeTypeException",
        "class_uri": "src/main/java/org/jsoup/UnsupportedMimeTypeException.java.UnsupportedMimeTypeException",
        "attributes": {
            "modifiers": "@Override\n    public",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/helper/Validate.java.Validate.[]Validate()",
        "name": "Validate",
        "arg_nums": 0,
        "params": [],
        "return_type": "",
        "signature": "private Validate()",
        "original_string": "    private Validate() {}",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/helper/Validate.java",
        "class_name": "Validate",
        "class_uri": "src/main/java/org/jsoup/helper/Validate.java.Validate",
        "attributes": {
            "modifiers": "private",
            "marker_annotations": [],
            "non_marker_annotations": [
                "private"
            ],
            "comments": [],
            "return_type": "",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/helper/Validate.java.Validate.[void]notNull(Object)",
        "name": "notNull",
        "arg_nums": 1,
        "params": [
            {
                "name": "obj",
                "type": "Object"
            }
        ],
        "return_type": "void",
        "signature": "public static void notNull(@Nullable Object obj)",
        "original_string": "    public static void notNull(@Nullable Object obj) {\n        if (obj == null)\n            throw new ValidationException(\"Object must not be null\");\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/helper/Validate.java",
        "class_name": "Validate",
        "class_uri": "src/main/java/org/jsoup/helper/Validate.java.Validate",
        "attributes": {
            "modifiers": "public static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public",
                "static"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": "\nValidates that the object is not null\n@param obj object to test\n@throws ValidationException if the object is null\n"
    },
    {
        "uris": "src/main/java/org/jsoup/helper/Validate.java.Validate.[void]notNullParam(Object,String)",
        "name": "notNullParam",
        "arg_nums": 2,
        "params": [
            {
                "name": "obj",
                "type": "Object"
            },
            {
                "name": "param",
                "type": "String"
            }
        ],
        "return_type": "void",
        "signature": "public static void notNullParam(@Nullable final Object obj, final String param)",
        "original_string": "    public static void notNullParam(@Nullable final Object obj, final String param) {\n        if (obj == null)\n            throw new ValidationException(String.format(\"The parameter '%s' must not be null.\", param));\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/helper/Validate.java",
        "class_name": "Validate",
        "class_uri": "src/main/java/org/jsoup/helper/Validate.java.Validate",
        "attributes": {
            "modifiers": "public static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public",
                "static"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": "\nValidates that the parameter is not null\n\n@param obj the parameter to test\n@param param the name of the parameter, for presentation in the validation exception.\n@throws ValidationException if the object is null\n"
    },
    {
        "uris": "src/main/java/org/jsoup/helper/Validate.java.Validate.[void]notNull(Object,String)",
        "name": "notNull",
        "arg_nums": 2,
        "params": [
            {
                "name": "obj",
                "type": "Object"
            },
            {
                "name": "msg",
                "type": "String"
            }
        ],
        "return_type": "void",
        "signature": "public static void notNull(@Nullable Object obj, String msg)",
        "original_string": "    public static void notNull(@Nullable Object obj, String msg) {\n        if (obj == null)\n            throw new ValidationException(msg);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/helper/Validate.java",
        "class_name": "Validate",
        "class_uri": "src/main/java/org/jsoup/helper/Validate.java.Validate",
        "attributes": {
            "modifiers": "public static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public",
                "static"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": "\nValidates that the object is not null\n@param obj object to test\n@param msg message to include in the Exception if validation fails\n@throws ValidationException if the object is null\n"
    },
    {
        "uris": "src/main/java/org/jsoup/helper/Validate.java.Validate.[Object]ensureNotNull(Object)",
        "name": "ensureNotNull",
        "arg_nums": 1,
        "params": [
            {
                "name": "obj",
                "type": "Object"
            }
        ],
        "return_type": "Object",
        "signature": "public static Object ensureNotNull(@Nullable Object obj)",
        "original_string": "    public static Object ensureNotNull(@Nullable Object obj) {\n        if (obj == null)\n            throw new ValidationException(\"Object must not be null\");\n        else return obj;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/helper/Validate.java",
        "class_name": "Validate",
        "class_uri": "src/main/java/org/jsoup/helper/Validate.java.Validate",
        "attributes": {
            "modifiers": "public static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public",
                "static"
            ],
            "comments": [],
            "return_type": "Object",
            "classes": []
        },
        "docstring": "\nVerifies the input object is not null, and returns that object. Effectively this casts a nullable object to a non-\nnull object. (Works around lack of Objects.requestNonNull in Android version.)\n@param obj nullable object to case to not-null\n@return the object, or throws an exception if it is null\n@throws ValidationException if the object is null\n"
    },
    {
        "uris": "src/main/java/org/jsoup/helper/Validate.java.Validate.[Object]ensureNotNull(Object,String)",
        "name": "ensureNotNull",
        "arg_nums": 2,
        "params": [
            {
                "name": "obj",
                "type": "Object"
            },
            {
                "name": "msg",
                "type": "String"
            }
        ],
        "return_type": "Object",
        "signature": "public static Object ensureNotNull(@Nullable Object obj, String msg, Object... args)",
        "original_string": "    public static Object ensureNotNull(@Nullable Object obj, String msg, Object... args) {\n        if (obj == null)\n            throw new ValidationException(String.format(msg, args));\n        else return obj;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/helper/Validate.java",
        "class_name": "Validate",
        "class_uri": "src/main/java/org/jsoup/helper/Validate.java.Validate",
        "attributes": {
            "modifiers": "public static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public",
                "static"
            ],
            "comments": [],
            "return_type": "Object",
            "classes": []
        },
        "docstring": "\nVerifies the input object is not null, and returns that object. Effectively this casts a nullable object to a non-\nnull object. (Works around lack of Objects.requestNonNull in Android version.)\n@param obj nullable object to case to not-null\n@param msg the String format message to include in the validation exception when thrown\n@param args the arguments to the msg\n@return the object, or throws an exception if it is null\n@throws ValidationException if the object is null\n"
    },
    {
        "uris": "src/main/java/org/jsoup/helper/Validate.java.Validate.[void]isTrue(boolean)",
        "name": "isTrue",
        "arg_nums": 1,
        "params": [
            {
                "name": "val",
                "type": "boolean"
            }
        ],
        "return_type": "void",
        "signature": "public static void isTrue(boolean val)",
        "original_string": "    public static void isTrue(boolean val) {\n        if (!val)\n            throw new ValidationException(\"Must be true\");\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/helper/Validate.java",
        "class_name": "Validate",
        "class_uri": "src/main/java/org/jsoup/helper/Validate.java.Validate",
        "attributes": {
            "modifiers": "public static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public",
                "static"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": "\nValidates that the value is true\n@param val object to test\n@throws ValidationException if the object is not true\n"
    },
    {
        "uris": "src/main/java/org/jsoup/helper/Validate.java.Validate.[void]isTrue(boolean,String)",
        "name": "isTrue",
        "arg_nums": 2,
        "params": [
            {
                "name": "val",
                "type": "boolean"
            },
            {
                "name": "msg",
                "type": "String"
            }
        ],
        "return_type": "void",
        "signature": "public static void isTrue(boolean val, String msg)",
        "original_string": "    public static void isTrue(boolean val, String msg) {\n        if (!val)\n            throw new ValidationException(msg);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/helper/Validate.java",
        "class_name": "Validate",
        "class_uri": "src/main/java/org/jsoup/helper/Validate.java.Validate",
        "attributes": {
            "modifiers": "public static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public",
                "static"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": "\nValidates that the value is true\n@param val object to test\n@param msg message to include in the Exception if validation fails\n@throws ValidationException if the object is not true\n"
    },
    {
        "uris": "src/main/java/org/jsoup/helper/Validate.java.Validate.[void]isFalse(boolean)",
        "name": "isFalse",
        "arg_nums": 1,
        "params": [
            {
                "name": "val",
                "type": "boolean"
            }
        ],
        "return_type": "void",
        "signature": "public static void isFalse(boolean val)",
        "original_string": "    public static void isFalse(boolean val) {\n        if (val)\n            throw new ValidationException(\"Must be false\");\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/helper/Validate.java",
        "class_name": "Validate",
        "class_uri": "src/main/java/org/jsoup/helper/Validate.java.Validate",
        "attributes": {
            "modifiers": "public static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public",
                "static"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": "\nValidates that the value is false\n@param val object to test\n@throws ValidationException if the object is not false\n"
    },
    {
        "uris": "src/main/java/org/jsoup/helper/Validate.java.Validate.[void]isFalse(boolean,String)",
        "name": "isFalse",
        "arg_nums": 2,
        "params": [
            {
                "name": "val",
                "type": "boolean"
            },
            {
                "name": "msg",
                "type": "String"
            }
        ],
        "return_type": "void",
        "signature": "public static void isFalse(boolean val, String msg)",
        "original_string": "    public static void isFalse(boolean val, String msg) {\n        if (val)\n            throw new ValidationException(msg);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/helper/Validate.java",
        "class_name": "Validate",
        "class_uri": "src/main/java/org/jsoup/helper/Validate.java.Validate",
        "attributes": {
            "modifiers": "public static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public",
                "static"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": "\nValidates that the value is false\n@param val object to test\n@param msg message to include in the Exception if validation fails\n@throws ValidationException if the object is not false\n"
    },
    {
        "uris": "src/main/java/org/jsoup/helper/Validate.java.Validate.[void]noNullElements(Object[])",
        "name": "noNullElements",
        "arg_nums": 1,
        "params": [
            {
                "name": "objects",
                "type": "Object[]"
            }
        ],
        "return_type": "void",
        "signature": "public static void noNullElements(Object[] objects)",
        "original_string": "    public static void noNullElements(Object[] objects) {\n        noNullElements(objects, \"Array must not contain any null objects\");\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/helper/Validate.java",
        "class_name": "Validate",
        "class_uri": "src/main/java/org/jsoup/helper/Validate.java.Validate",
        "attributes": {
            "modifiers": "public static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public",
                "static"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": "\nValidates that the array contains no null elements\n@param objects the array to test\n@throws ValidationException if the array contains a null element\n"
    },
    {
        "uris": "src/main/java/org/jsoup/helper/Validate.java.Validate.[void]noNullElements(Object[],String)",
        "name": "noNullElements",
        "arg_nums": 2,
        "params": [
            {
                "name": "objects",
                "type": "Object[]"
            },
            {
                "name": "msg",
                "type": "String"
            }
        ],
        "return_type": "void",
        "signature": "public static void noNullElements(Object[] objects, String msg)",
        "original_string": "    public static void noNullElements(Object[] objects, String msg) {\n        for (Object obj : objects)\n            if (obj == null)\n                throw new ValidationException(msg);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/helper/Validate.java",
        "class_name": "Validate",
        "class_uri": "src/main/java/org/jsoup/helper/Validate.java.Validate",
        "attributes": {
            "modifiers": "public static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public",
                "static"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": "\nValidates that the array contains no null elements\n@param objects the array to test\n@param msg message to include in the Exception if validation fails\n@throws ValidationException if the array contains a null element\n"
    },
    {
        "uris": "src/main/java/org/jsoup/helper/Validate.java.Validate.[void]notEmpty(String)",
        "name": "notEmpty",
        "arg_nums": 1,
        "params": [
            {
                "name": "string",
                "type": "String"
            }
        ],
        "return_type": "void",
        "signature": "public static void notEmpty(@Nullable String string)",
        "original_string": "    public static void notEmpty(@Nullable String string) {\n        if (string == null || string.length() == 0)\n            throw new ValidationException(\"String must not be empty\");\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/helper/Validate.java",
        "class_name": "Validate",
        "class_uri": "src/main/java/org/jsoup/helper/Validate.java.Validate",
        "attributes": {
            "modifiers": "public static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public",
                "static"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": "\nValidates that the string is not null and is not empty\n@param string the string to test\n@throws ValidationException if the string is null or empty\n"
    },
    {
        "uris": "src/main/java/org/jsoup/helper/Validate.java.Validate.[void]notEmptyParam(String,String)",
        "name": "notEmptyParam",
        "arg_nums": 2,
        "params": [
            {
                "name": "string",
                "type": "String"
            },
            {
                "name": "param",
                "type": "String"
            }
        ],
        "return_type": "void",
        "signature": "public static void notEmptyParam(@Nullable final String string, final String param)",
        "original_string": "    public static void notEmptyParam(@Nullable final String string, final String param) {\n        if (string == null || string.length() == 0)\n            throw new ValidationException(String.format(\"The '%s' parameter must not be empty.\", param));\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/helper/Validate.java",
        "class_name": "Validate",
        "class_uri": "src/main/java/org/jsoup/helper/Validate.java.Validate",
        "attributes": {
            "modifiers": "public static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public",
                "static"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": "\nValidates that the string parameter is not null and is not empty\n@param string the string to test\n@param param the name of the parameter, for presentation in the validation exception.\n@throws ValidationException if the string is null or empty\n"
    },
    {
        "uris": "src/main/java/org/jsoup/helper/Validate.java.Validate.[void]notEmpty(String,String)",
        "name": "notEmpty",
        "arg_nums": 2,
        "params": [
            {
                "name": "string",
                "type": "String"
            },
            {
                "name": "msg",
                "type": "String"
            }
        ],
        "return_type": "void",
        "signature": "public static void notEmpty(@Nullable String string, String msg)",
        "original_string": "    public static void notEmpty(@Nullable String string, String msg) {\n        if (string == null || string.length() == 0)\n            throw new ValidationException(msg);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/helper/Validate.java",
        "class_name": "Validate",
        "class_uri": "src/main/java/org/jsoup/helper/Validate.java.Validate",
        "attributes": {
            "modifiers": "public static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public",
                "static"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": "\nValidates that the string is not null and is not empty\n@param string the string to test\n@param msg message to include in the Exception if validation fails\n@throws ValidationException if the string is null or empty\n"
    },
    {
        "uris": "src/main/java/org/jsoup/helper/Validate.java.Validate.[void]wtf(String)",
        "name": "wtf",
        "arg_nums": 1,
        "params": [
            {
                "name": "msg",
                "type": "String"
            }
        ],
        "return_type": "void",
        "signature": "public static void wtf(String msg)",
        "original_string": "    public static void wtf(String msg) {\n        throw new IllegalStateException(msg);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/helper/Validate.java",
        "class_name": "Validate",
        "class_uri": "src/main/java/org/jsoup/helper/Validate.java.Validate",
        "attributes": {
            "modifiers": "public static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public",
                "static"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": "\nBlow up if we reach an unexpected state.\n@param msg message to think about\n@throws IllegalStateException if we reach this state\n"
    },
    {
        "uris": "src/main/java/org/jsoup/helper/Validate.java.Validate.[void]fail(String)",
        "name": "fail",
        "arg_nums": 1,
        "params": [
            {
                "name": "msg",
                "type": "String"
            }
        ],
        "return_type": "void",
        "signature": "public static void fail(String msg)",
        "original_string": "    public static void fail(String msg) {\n        throw new ValidationException(msg);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/helper/Validate.java",
        "class_name": "Validate",
        "class_uri": "src/main/java/org/jsoup/helper/Validate.java.Validate",
        "attributes": {
            "modifiers": "public static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public",
                "static"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": "\nCause a failure.\n@param msg message to output.\n@throws IllegalStateException if we reach this state\n"
    },
    {
        "uris": "src/main/java/org/jsoup/helper/Validate.java.Validate.[boolean]assertFail(String)",
        "name": "assertFail",
        "arg_nums": 1,
        "params": [
            {
                "name": "msg",
                "type": "String"
            }
        ],
        "return_type": "boolean",
        "signature": "static boolean assertFail(String msg)",
        "original_string": "    static boolean assertFail(String msg) {\n        fail(msg);\n        return false;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/helper/Validate.java",
        "class_name": "Validate",
        "class_uri": "src/main/java/org/jsoup/helper/Validate.java.Validate",
        "attributes": {
            "modifiers": "static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "static"
            ],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": "\nCause a failure, but return false so it can be used in an assert statement.\n@param msg message to output.\n@return false, always\n@throws IllegalStateException if we reach this state\n"
    },
    {
        "uris": "src/main/java/org/jsoup/helper/Validate.java.Validate.[void]fail(String)",
        "name": "fail",
        "arg_nums": 1,
        "params": [
            {
                "name": "msg",
                "type": "String"
            }
        ],
        "return_type": "void",
        "signature": "public static void fail(String msg, Object... args)",
        "original_string": "    public static void fail(String msg, Object... args) {\n        throw new ValidationException(String.format(msg, args));\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/helper/Validate.java",
        "class_name": "Validate",
        "class_uri": "src/main/java/org/jsoup/helper/Validate.java.Validate",
        "attributes": {
            "modifiers": "public static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public",
                "static"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": "\nCause a failure.\n@param msg message to output.\n@param args the format arguments to the msg\n@throws IllegalStateException if we reach this state\n"
    },
    {
        "uris": "src/main/java/org/jsoup/helper/UrlBuilder.java.UrlBuilder.[]UrlBuilder(URL)",
        "name": "UrlBuilder",
        "arg_nums": 1,
        "params": [
            {
                "name": "inputUrl",
                "type": "URL"
            }
        ],
        "return_type": "",
        "signature": "UrlBuilder(URL inputUrl)",
        "original_string": "    UrlBuilder(URL inputUrl) {\n        this.u = inputUrl;\n        if (u.getQuery() != null)\n            q = StringUtil.borrowBuilder().append(u.getQuery());\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/helper/UrlBuilder.java",
        "class_name": "UrlBuilder",
        "class_uri": "src/main/java/org/jsoup/helper/UrlBuilder.java.UrlBuilder",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/helper/UrlBuilder.java.UrlBuilder.[URL]build()",
        "name": "build",
        "arg_nums": 0,
        "params": [],
        "return_type": "URL",
        "signature": "URL build()",
        "original_string": "    URL build() {\n        try {\n            // use the URI class to encode non-ascii in path\n            URI uri = new URI(\n                u.getProtocol(),\n                u.getUserInfo(),\n                IDN.toASCII(decodePart(u.getHost())), // puny-code\n                u.getPort(),\n                null, null, null // path, query and fragment appended later so as not to encode\n            );\n\n            StringBuilder normUrl = StringUtil.borrowBuilder().append(uri.toASCIIString());\n            appendToAscii(u.getPath(), false, normUrl);\n            if (q != null) {\n                normUrl.append('?');\n                appendToAscii(StringUtil.releaseBuilder(q), true, normUrl);\n            }\n            if (u.getRef() != null) {\n                normUrl.append('#');\n                appendToAscii(u.getRef(), false, normUrl);\n            }\n            u = new URL(StringUtil.releaseBuilder(normUrl));\n            return u;\n        } catch (MalformedURLException | URISyntaxException | UnsupportedEncodingException e) {\n            // we assert here so that any incomplete normalization issues can be caught in devel. but in practise,\n            // the remote end will be able to handle it, so in prod we just pass the original URL.\n            // The UnsupportedEncodingException would never happen as always UTF8\n            assert Validate.assertFail(e.toString());\n            return u;\n        }\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/helper/UrlBuilder.java",
        "class_name": "UrlBuilder",
        "class_uri": "src/main/java/org/jsoup/helper/UrlBuilder.java.UrlBuilder",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "URL",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/helper/UrlBuilder.java.UrlBuilder.[void]appendKeyVal(Connection.KeyVal)",
        "name": "appendKeyVal",
        "arg_nums": 1,
        "params": [
            {
                "name": "kv",
                "type": "Connection.KeyVal"
            }
        ],
        "return_type": "void",
        "signature": "void appendKeyVal(Connection.KeyVal kv)",
        "original_string": "    void appendKeyVal(Connection.KeyVal kv) throws UnsupportedEncodingException {\n        if (q == null)\n            q = StringUtil.borrowBuilder();\n        else\n            q.append('&');\n        q\n            .append(URLEncoder.encode(kv.key(), UTF_8.name()))\n            .append('=')\n            .append(URLEncoder.encode(kv.value(), UTF_8.name()));\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/helper/UrlBuilder.java",
        "class_name": "UrlBuilder",
        "class_uri": "src/main/java/org/jsoup/helper/UrlBuilder.java.UrlBuilder",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/helper/UrlBuilder.java.UrlBuilder.[String]decodePart(String)",
        "name": "decodePart",
        "arg_nums": 1,
        "params": [
            {
                "name": "encoded",
                "type": "String"
            }
        ],
        "return_type": "String",
        "signature": "private static String decodePart(String encoded)",
        "original_string": "    private static String decodePart(String encoded) {\n        try {\n            return URLDecoder.decode(encoded, UTF_8.name());\n        } catch (UnsupportedEncodingException e) {\n            throw new RuntimeException(e); // wtf!\n        }\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/helper/UrlBuilder.java",
        "class_name": "UrlBuilder",
        "class_uri": "src/main/java/org/jsoup/helper/UrlBuilder.java.UrlBuilder",
        "attributes": {
            "modifiers": "private static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "private",
                "static"
            ],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/helper/UrlBuilder.java.UrlBuilder.[void]appendToAscii(String,boolean,StringBuilder)",
        "name": "appendToAscii",
        "arg_nums": 3,
        "params": [
            {
                "name": "s",
                "type": "String"
            },
            {
                "name": "spaceAsPlus",
                "type": "boolean"
            },
            {
                "name": "sb",
                "type": "StringBuilder"
            }
        ],
        "return_type": "void",
        "signature": "private static void appendToAscii(String s, boolean spaceAsPlus, StringBuilder sb)",
        "original_string": "    private static void appendToAscii(String s, boolean spaceAsPlus, StringBuilder sb) throws UnsupportedEncodingException {\n        for (int i = 0; i < s.length(); i++) {\n            int c = s.codePointAt(i);\n            if (c == ' ') {\n                sb.append(spaceAsPlus ? '+' : \"%20\");\n            } else if (c == '%') { // if already a valid escape, pass; otherwise, escape\n                if (i < s.length() - 2 && isHex(s.charAt(i + 1)) && isHex(s.charAt(i + 2))) {\n                    sb.append('%').append(s.charAt(i + 1)).append(s.charAt(i + 2));\n                    i += 2; // skip the next two characters\n                } else {\n                    sb.append(\"%25\");\n                }\n            } else if (c > 127 || unsafeCharacters.indexOf(c) != -1) { // past ascii, or otherwise unsafe\n                sb.append(URLEncoder.encode(new String(Character.toChars(c)), UTF_8.name()));\n                if (Character.charCount(c) == 2) i++; // advance past supplemental\n            } else {\n                sb.append((char) c);\n            }\n        }\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/helper/UrlBuilder.java",
        "class_name": "UrlBuilder",
        "class_uri": "src/main/java/org/jsoup/helper/UrlBuilder.java.UrlBuilder",
        "attributes": {
            "modifiers": "private static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "private",
                "static"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/helper/UrlBuilder.java.UrlBuilder.[boolean]isHex(char)",
        "name": "isHex",
        "arg_nums": 1,
        "params": [
            {
                "name": "c",
                "type": "char"
            }
        ],
        "return_type": "boolean",
        "signature": "private static boolean isHex(char c)",
        "original_string": "    private static boolean isHex(char c) {\n        return (c >= '0' && c <= '9') || (c >= 'A' && c <= 'F') || (c >= 'a' && c <= 'f');\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/helper/UrlBuilder.java",
        "class_name": "UrlBuilder",
        "class_uri": "src/main/java/org/jsoup/helper/UrlBuilder.java.UrlBuilder",
        "attributes": {
            "modifiers": "private static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "private",
                "static"
            ],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/helper/AuthenticationHandler.java.AuthenticationHandler.[]AuthenticationHandler()",
        "name": "AuthenticationHandler",
        "arg_nums": 0,
        "params": [],
        "return_type": "",
        "signature": "AuthenticationHandler()",
        "original_string": "    AuthenticationHandler() {}",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/helper/AuthenticationHandler.java",
        "class_name": "AuthenticationHandler",
        "class_uri": "src/main/java/org/jsoup/helper/AuthenticationHandler.java.AuthenticationHandler",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/helper/AuthenticationHandler.java.AuthenticationHandler.[]AuthenticationHandler(RequestAuthenticator)",
        "name": "AuthenticationHandler",
        "arg_nums": 1,
        "params": [
            {
                "name": "auth",
                "type": "RequestAuthenticator"
            }
        ],
        "return_type": "",
        "signature": "AuthenticationHandler(RequestAuthenticator auth)",
        "original_string": "    AuthenticationHandler(RequestAuthenticator auth) {\n        this.auth = auth;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/helper/AuthenticationHandler.java",
        "class_name": "AuthenticationHandler",
        "class_uri": "src/main/java/org/jsoup/helper/AuthenticationHandler.java.AuthenticationHandler",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/helper/AuthenticationHandler.java.AuthenticationHandler.[PasswordAuthentication]getPasswordAuthentication()",
        "name": "getPasswordAuthentication",
        "arg_nums": 0,
        "params": [],
        "return_type": "PasswordAuthentication",
        "signature": "@Nullable @Override public final PasswordAuthentication getPasswordAuthentication()",
        "original_string": "    @Nullable @Override public final PasswordAuthentication getPasswordAuthentication() {\n        AuthenticationHandler delegate = handler.get(this);\n        if (delegate == null) return null; // this request has no auth handler\n        delegate.attemptCount++;\n        // if the password returned fails, Java will repeatedly retry the request with a new password auth hit (because\n        // it may be an interactive prompt, and the user could eventually get it right). But in Jsoup's context, the\n        // auth will either be correct or not, so just abandon\n        if (delegate.attemptCount > MaxAttempts)\n            return null;\n        if (delegate.auth == null)\n            return null; // detached - would have been the Global Authenticator (not a delegate)\n\n        RequestAuthenticator.Context ctx = new RequestAuthenticator.Context(\n            this.getRequestingURL(), this.getRequestorType(), this.getRequestingPrompt());\n        return delegate.auth.authenticate(ctx);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/helper/AuthenticationHandler.java",
        "class_name": "AuthenticationHandler",
        "class_uri": "src/main/java/org/jsoup/helper/AuthenticationHandler.java.AuthenticationHandler",
        "attributes": {
            "modifiers": "@Nullable @Override public final",
            "marker_annotations": [
                "@Nullable",
                "@Override"
            ],
            "non_marker_annotations": [
                "public",
                "final"
            ],
            "comments": [],
            "return_type": "PasswordAuthentication",
            "classes": []
        },
        "docstring": "\nAuthentication callback, called by HttpURLConnection - either as system-wide default (Java 8) or per HttpURLConnection (Java 9+)\n@return credentials, or null if not attempting to auth.\n"
    },
    {
        "uris": "src/main/java/org/jsoup/helper/DataUtil.java.DataUtil.[]DataUtil()",
        "name": "DataUtil",
        "arg_nums": 0,
        "params": [],
        "return_type": "",
        "signature": "private DataUtil()",
        "original_string": "    private DataUtil() {}",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/helper/DataUtil.java",
        "class_name": "DataUtil",
        "class_uri": "src/main/java/org/jsoup/helper/DataUtil.java.DataUtil",
        "attributes": {
            "modifiers": "private",
            "marker_annotations": [],
            "non_marker_annotations": [
                "private"
            ],
            "comments": [],
            "return_type": "",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/helper/DataUtil.java.DataUtil.[Document]load(File,String,String)",
        "name": "load",
        "arg_nums": 3,
        "params": [
            {
                "name": "file",
                "type": "File"
            },
            {
                "name": "charsetName",
                "type": "String"
            },
            {
                "name": "baseUri",
                "type": "String"
            }
        ],
        "return_type": "Document",
        "signature": "public static Document load(File file, @Nullable String charsetName, String baseUri)",
        "original_string": "    public static Document load(File file, @Nullable String charsetName, String baseUri) throws IOException {\n        return load(file.toPath(), charsetName, baseUri);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/helper/DataUtil.java",
        "class_name": "DataUtil",
        "class_uri": "src/main/java/org/jsoup/helper/DataUtil.java.DataUtil",
        "attributes": {
            "modifiers": "public static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public",
                "static"
            ],
            "comments": [],
            "return_type": "Document",
            "classes": []
        },
        "docstring": "\nLoads and parses a file to a Document, with the HtmlParser. Files that are compressed with gzip (and end in {@code .gz} or {@code .z})\nare supported in addition to uncompressed files.\n\n@param file file to load\n@param charsetName (optional) character set of input; specify {@code null} to attempt to autodetect. A BOM in\n    the file will always override this setting.\n@param baseUri base URI of document, to resolve relative links against\n@return Document\n@throws IOException on IO error\n"
    },
    {
        "uris": "src/main/java/org/jsoup/helper/DataUtil.java.DataUtil.[Document]load(File,String,String,Parser)",
        "name": "load",
        "arg_nums": 4,
        "params": [
            {
                "name": "file",
                "type": "File"
            },
            {
                "name": "charsetName",
                "type": "String"
            },
            {
                "name": "baseUri",
                "type": "String"
            },
            {
                "name": "parser",
                "type": "Parser"
            }
        ],
        "return_type": "Document",
        "signature": "public static Document load(File file, @Nullable String charsetName, String baseUri, Parser parser)",
        "original_string": "    public static Document load(File file, @Nullable String charsetName, String baseUri, Parser parser) throws IOException {\n        return load(file.toPath(), charsetName, baseUri, parser);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/helper/DataUtil.java",
        "class_name": "DataUtil",
        "class_uri": "src/main/java/org/jsoup/helper/DataUtil.java.DataUtil",
        "attributes": {
            "modifiers": "public static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public",
                "static"
            ],
            "comments": [],
            "return_type": "Document",
            "classes": []
        },
        "docstring": "\nLoads and parses a file to a Document. Files that are compressed with gzip (and end in {@code .gz} or {@code .z})\nare supported in addition to uncompressed files.\n\n@param file file to load\n@param charsetName (optional) character set of input; specify {@code null} to attempt to autodetect. A BOM in\n    the file will always override this setting.\n@param baseUri base URI of document, to resolve relative links against\n@param parser alternate {@link Parser#xmlParser() parser} to use.\n\n@return Document\n@throws IOException on IO error\n@since 1.14.2\n"
    },
    {
        "uris": "src/main/java/org/jsoup/helper/DataUtil.java.DataUtil.[Document]load(Path,String,String)",
        "name": "load",
        "arg_nums": 3,
        "params": [
            {
                "name": "path",
                "type": "Path"
            },
            {
                "name": "charsetName",
                "type": "String"
            },
            {
                "name": "baseUri",
                "type": "String"
            }
        ],
        "return_type": "Document",
        "signature": "public static Document load(Path path, @Nullable String charsetName, String baseUri)",
        "original_string": "    public static Document load(Path path, @Nullable String charsetName, String baseUri) throws IOException {\n        return load(path, charsetName, baseUri, Parser.htmlParser());\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/helper/DataUtil.java",
        "class_name": "DataUtil",
        "class_uri": "src/main/java/org/jsoup/helper/DataUtil.java.DataUtil",
        "attributes": {
            "modifiers": "public static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public",
                "static"
            ],
            "comments": [],
            "return_type": "Document",
            "classes": []
        },
        "docstring": "\nLoads and parses a file to a Document, with the HtmlParser. Files that are compressed with gzip (and end in {@code .gz} or {@code .z})\nare supported in addition to uncompressed files.\n\n@param path file to load\n@param charsetName (optional) character set of input; specify {@code null} to attempt to autodetect. A BOM in\n    the file will always override this setting.\n@param baseUri base URI of document, to resolve relative links against\n@return Document\n@throws IOException on IO error\n"
    },
    {
        "uris": "src/main/java/org/jsoup/helper/DataUtil.java.DataUtil.[Document]load(Path,String,String,Parser)",
        "name": "load",
        "arg_nums": 4,
        "params": [
            {
                "name": "path",
                "type": "Path"
            },
            {
                "name": "charsetName",
                "type": "String"
            },
            {
                "name": "baseUri",
                "type": "String"
            },
            {
                "name": "parser",
                "type": "Parser"
            }
        ],
        "return_type": "Document",
        "signature": "public static Document load(Path path, @Nullable String charsetName, String baseUri, Parser parser)",
        "original_string": "    public static Document load(Path path, @Nullable String charsetName, String baseUri, Parser parser) throws IOException {\n        return parseInputStream(openStream(path), charsetName, baseUri, parser);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/helper/DataUtil.java",
        "class_name": "DataUtil",
        "class_uri": "src/main/java/org/jsoup/helper/DataUtil.java.DataUtil",
        "attributes": {
            "modifiers": "public static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public",
                "static"
            ],
            "comments": [],
            "return_type": "Document",
            "classes": []
        },
        "docstring": "\nLoads and parses a file to a Document. Files that are compressed with gzip (and end in {@code .gz} or {@code .z})\nare supported in addition to uncompressed files.\n\n@param path file to load\n@param charsetName (optional) character set of input; specify {@code null} to attempt to autodetect. A BOM in\nthe file will always override this setting.\n@param baseUri base URI of document, to resolve relative links against\n@param parser alternate {@link Parser#xmlParser() parser} to use.\n\n@return Document\n@throws IOException on IO error\n@since 1.17.2\n"
    },
    {
        "uris": "src/main/java/org/jsoup/helper/DataUtil.java.DataUtil.[StreamParser]streamParser(Path,Charset,String,Parser)",
        "name": "streamParser",
        "arg_nums": 4,
        "params": [
            {
                "name": "path",
                "type": "Path"
            },
            {
                "name": "charset",
                "type": "Charset"
            },
            {
                "name": "baseUri",
                "type": "String"
            },
            {
                "name": "parser",
                "type": "Parser"
            }
        ],
        "return_type": "StreamParser",
        "signature": "public static StreamParser streamParser(Path path, @Nullable Charset charset, String baseUri, Parser parser)",
        "original_string": "    public static StreamParser streamParser(Path path, @Nullable Charset charset, String baseUri, Parser parser) throws IOException {\n        StreamParser streamer = new StreamParser(parser);\n        String charsetName = charset != null? charset.name() : null;\n        DataUtil.CharsetDoc charsetDoc = DataUtil.detectCharset(openStream(path), charsetName, baseUri, parser);\n        BufferedReader reader = new BufferedReader(new InputStreamReader(charsetDoc.input, charsetDoc.charset), DefaultBufferSize);\n        streamer.parse(reader, baseUri); // initializes the parse and the document, but does not step() it\n\n        return streamer;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/helper/DataUtil.java",
        "class_name": "DataUtil",
        "class_uri": "src/main/java/org/jsoup/helper/DataUtil.java.DataUtil",
        "attributes": {
            "modifiers": "public static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public",
                "static"
            ],
            "comments": [],
            "return_type": "StreamParser",
            "classes": []
        },
        "docstring": "\nReturns a {@link StreamParser} that will parse the supplied file progressively.\nFiles that are compressed with gzip (and end in {@code .gz} or {@code .z})\nare supported in addition to uncompressed files.\n\n@param path file to load\n@param charset (optional) character set of input; specify {@code null} to attempt to autodetect from metadata.\nA BOM in the file will always override this setting.\n@param baseUri base URI of document, to resolve relative links against\n@param parser alternate {@link Parser#xmlParser() parser} to use.\n\n@return Document\n@throws IOException on IO error\n@since 1.18.2\n@see Connection.Response#streamParser()\n"
    },
    {
        "uris": "src/main/java/org/jsoup/helper/DataUtil.java.DataUtil.[ControllableInputStream]openStream(Path)",
        "name": "openStream",
        "arg_nums": 1,
        "params": [
            {
                "name": "path",
                "type": "Path"
            }
        ],
        "return_type": "ControllableInputStream",
        "signature": "private static ControllableInputStream openStream(Path path)",
        "original_string": "    private static ControllableInputStream openStream(Path path) throws IOException {\n        final SeekableByteChannel byteChannel = Files.newByteChannel(path);\n        InputStream stream = Channels.newInputStream(byteChannel);\n        String name = Normalizer.lowerCase(path.getFileName().toString());\n        if (name.endsWith(\".gz\") || name.endsWith(\".z\")) {\n            final boolean zipped = (stream.read() == 0x1f && stream.read() == 0x8b); // gzip magic bytes\n            byteChannel.position(0); // reset to start of file\n            if (zipped) {\n                stream = new GZIPInputStream(stream);\n            }\n        }\n        return ControllableInputStream.wrap(stream, 0);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/helper/DataUtil.java",
        "class_name": "DataUtil",
        "class_uri": "src/main/java/org/jsoup/helper/DataUtil.java.DataUtil",
        "attributes": {
            "modifiers": "private static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "private",
                "static"
            ],
            "comments": [],
            "return_type": "ControllableInputStream",
            "classes": []
        },
        "docstring": " Open an input stream from a file; if it's a gzip file, returns a GZIPInputStream to unzip it."
    },
    {
        "uris": "src/main/java/org/jsoup/helper/DataUtil.java.DataUtil.[Document]load(InputStream,String,String)",
        "name": "load",
        "arg_nums": 3,
        "params": [
            {
                "name": "in",
                "type": "InputStream"
            },
            {
                "name": "charsetName",
                "type": "String"
            },
            {
                "name": "baseUri",
                "type": "String"
            }
        ],
        "return_type": "Document",
        "signature": "public static Document load(InputStream in, @Nullable String charsetName, String baseUri)",
        "original_string": "    public static Document load(InputStream in, @Nullable String charsetName, String baseUri) throws IOException {\n        return parseInputStream(ControllableInputStream.wrap(in, 0), charsetName, baseUri, Parser.htmlParser());\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/helper/DataUtil.java",
        "class_name": "DataUtil",
        "class_uri": "src/main/java/org/jsoup/helper/DataUtil.java.DataUtil",
        "attributes": {
            "modifiers": "public static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public",
                "static"
            ],
            "comments": [],
            "return_type": "Document",
            "classes": []
        },
        "docstring": "\nParses a Document from an input steam.\n@param in input stream to parse. The stream will be closed after reading.\n@param charsetName character set of input (optional)\n@param baseUri base URI of document, to resolve relative links against\n@return Document\n@throws IOException on IO error\n"
    },
    {
        "uris": "src/main/java/org/jsoup/helper/DataUtil.java.DataUtil.[Document]load(InputStream,String,String,Parser)",
        "name": "load",
        "arg_nums": 4,
        "params": [
            {
                "name": "in",
                "type": "InputStream"
            },
            {
                "name": "charsetName",
                "type": "String"
            },
            {
                "name": "baseUri",
                "type": "String"
            },
            {
                "name": "parser",
                "type": "Parser"
            }
        ],
        "return_type": "Document",
        "signature": "public static Document load(InputStream in, @Nullable String charsetName, String baseUri, Parser parser)",
        "original_string": "    public static Document load(InputStream in, @Nullable String charsetName, String baseUri, Parser parser) throws IOException {\n        return parseInputStream(ControllableInputStream.wrap(in, 0), charsetName, baseUri, parser);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/helper/DataUtil.java",
        "class_name": "DataUtil",
        "class_uri": "src/main/java/org/jsoup/helper/DataUtil.java.DataUtil",
        "attributes": {
            "modifiers": "public static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public",
                "static"
            ],
            "comments": [],
            "return_type": "Document",
            "classes": []
        },
        "docstring": "\nParses a Document from an input steam, using the provided Parser.\n@param in input stream to parse. The stream will be closed after reading.\n@param charsetName character set of input (optional)\n@param baseUri base URI of document, to resolve relative links against\n@param parser alternate {@link Parser#xmlParser() parser} to use.\n@return Document\n@throws IOException on IO error\n"
    },
    {
        "uris": "src/main/java/org/jsoup/helper/DataUtil.java.DataUtil.[void]crossStreams(InputStream,OutputStream)",
        "name": "crossStreams",
        "arg_nums": 2,
        "params": [
            {
                "name": "in",
                "type": "InputStream"
            },
            {
                "name": "out",
                "type": "OutputStream"
            }
        ],
        "return_type": "void",
        "signature": "static void crossStreams(final InputStream in, final OutputStream out)",
        "original_string": "    static void crossStreams(final InputStream in, final OutputStream out) throws IOException {\n        final byte[] buffer = new byte[DefaultBufferSize];\n        int len;\n        while ((len = in.read(buffer)) != -1) {\n            out.write(buffer, 0, len);\n        }\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/helper/DataUtil.java",
        "class_name": "DataUtil",
        "class_uri": "src/main/java/org/jsoup/helper/DataUtil.java.DataUtil",
        "attributes": {
            "modifiers": "static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "static"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": "\nWrites the input stream to the output stream. Doesn't close them.\n@param in input stream to read from\n@param out output stream to write to\n@throws IOException on IO error\n"
    },
    {
        "uris": "src/main/java/org/jsoup/helper/DataUtil.java.DataUtil.[Document]parseInputStream(ControllableInputStream,String,String,Parser)",
        "name": "parseInputStream",
        "arg_nums": 4,
        "params": [
            {
                "name": "input",
                "type": "ControllableInputStream"
            },
            {
                "name": "charsetName",
                "type": "String"
            },
            {
                "name": "baseUri",
                "type": "String"
            },
            {
                "name": "parser",
                "type": "Parser"
            }
        ],
        "return_type": "Document",
        "signature": "static Document parseInputStream(@Nullable ControllableInputStream input, @Nullable String charsetName, String baseUri, Parser parser)",
        "original_string": "    static Document parseInputStream(@Nullable ControllableInputStream input, @Nullable String charsetName, String baseUri, Parser parser) throws IOException {\n        if (input == null) // empty body // todo reconsider?\n            return new Document(baseUri);\n\n        final Document doc;\n        CharsetDoc charsetDoc = null;\n        try {\n            charsetDoc = detectCharset(input, charsetName, baseUri, parser);\n            doc = parseInputStream(charsetDoc, baseUri, parser);\n        } finally {\n            if (charsetDoc != null)\n                charsetDoc.input.close();\n        }\n        return doc;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/helper/DataUtil.java",
        "class_name": "DataUtil",
        "class_uri": "src/main/java/org/jsoup/helper/DataUtil.java.DataUtil",
        "attributes": {
            "modifiers": "static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "static"
            ],
            "comments": [],
            "return_type": "Document",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/helper/DataUtil.java.DataUtil.[CharsetDoc]detectCharset(ControllableInputStream,String,String,Parser)",
        "name": "detectCharset",
        "arg_nums": 4,
        "params": [
            {
                "name": "input",
                "type": "ControllableInputStream"
            },
            {
                "name": "charsetName",
                "type": "String"
            },
            {
                "name": "baseUri",
                "type": "String"
            },
            {
                "name": "parser",
                "type": "Parser"
            }
        ],
        "return_type": "CharsetDoc",
        "signature": "static CharsetDoc detectCharset(ControllableInputStream input, @Nullable String charsetName, String baseUri, Parser parser)",
        "original_string": "    static CharsetDoc detectCharset(ControllableInputStream input, @Nullable String charsetName, String baseUri, Parser parser) throws IOException {\n        Document doc = null;\n        // read the start of the stream and look for a BOM or meta charset:\n        // look for BOM - overrides any other header or input\n        String bomCharset = detectCharsetFromBom(input); // resets / consumes appropriately\n        if (bomCharset != null)\n            charsetName = bomCharset;\n\n        if (charsetName == null) { // read ahead and determine from meta. safe first parse as UTF-8\n            int origMax = input.max();\n            input.max(firstReadBufferSize);\n            input.mark(firstReadBufferSize);\n            input.allowClose(false); // ignores closes during parse, in case we need to rewind\n            try {\n                Reader reader = new InputStreamReader(input, UTF_8); // input is currently capped to firstReadBufferSize\n                doc = parser.parseInput(reader, baseUri);\n                input.reset();\n                input.max(origMax); // reset for a full read if required\n            } catch (UncheckedIOException e) {\n                throw e.getCause();\n            } finally {\n                input.allowClose(true);\n            }\n\n            // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n            Elements metaElements = doc.select(\"meta[http-equiv=content-type], meta[charset]\");\n            String foundCharset = null; // if not found, will keep utf-8 as best attempt\n            for (Element meta : metaElements) {\n                if (meta.hasAttr(\"http-equiv\"))\n                    foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n                if (foundCharset == null && meta.hasAttr(\"charset\"))\n                    foundCharset = meta.attr(\"charset\");\n                if (foundCharset != null)\n                    break;\n            }\n\n            // look for <?xml encoding='ISO-8859-1'?>\n            if (foundCharset == null && doc.childNodeSize() > 0) {\n                Node first = doc.childNode(0);\n                XmlDeclaration decl = null;\n                if (first instanceof XmlDeclaration)\n                    decl = (XmlDeclaration) first;\n                else if (first instanceof Comment) {\n                    Comment comment = (Comment) first;\n                    if (comment.isXmlDeclaration())\n                        decl = comment.asXmlDeclaration();\n                }\n                if (decl != null && decl.name().equalsIgnoreCase(\"xml\")) {\n                    foundCharset = decl.attr(\"encoding\");\n                }\n            }\n            foundCharset = validateCharset(foundCharset);\n            if (foundCharset != null && !foundCharset.equalsIgnoreCase(defaultCharsetName)) { // need to re-decode. (case-insensitive check here to match how validate works)\n                foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n                charsetName = foundCharset;\n                doc = null;\n            } else if (input.baseReadFully()) { // if we have read fully, and the charset was correct, keep that current parse\n                input.close(); // the parser tried to close it\n            } else {\n                doc = null;\n            }\n        } else { // specified by content type header (or by user on file load)\n            Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n        }\n\n        // finally: prepare the return struct\n        if (charsetName == null)\n            charsetName = defaultCharsetName;\n        Charset charset = charsetName.equals(defaultCharsetName) ? UTF_8 : Charset.forName(charsetName);\n        return new CharsetDoc(charset, doc, input);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/helper/DataUtil.java",
        "class_name": "DataUtil",
        "class_uri": "src/main/java/org/jsoup/helper/DataUtil.java.DataUtil",
        "attributes": {
            "modifiers": "static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "static"
            ],
            "comments": [],
            "return_type": "CharsetDoc",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/helper/DataUtil.java.DataUtil.[Document]parseInputStream(CharsetDoc,String,Parser)",
        "name": "parseInputStream",
        "arg_nums": 3,
        "params": [
            {
                "name": "charsetDoc",
                "type": "CharsetDoc"
            },
            {
                "name": "baseUri",
                "type": "String"
            },
            {
                "name": "parser",
                "type": "Parser"
            }
        ],
        "return_type": "Document",
        "signature": "static Document parseInputStream(CharsetDoc charsetDoc, String baseUri, Parser parser)",
        "original_string": "    static Document parseInputStream(CharsetDoc charsetDoc, String baseUri, Parser parser) throws IOException {\n        // if doc != null it was fully parsed during charset detection; so just return that\n        if (charsetDoc.doc != null)\n            return charsetDoc.doc;\n\n        final InputStream input = charsetDoc.input;\n        Validate.notNull(input);\n        final Document doc;\n        final Charset charset = charsetDoc.charset;\n        try (Reader reader = new InputStreamReader(input, charset)) {\n            try {\n                doc = parser.parseInput(reader, baseUri);\n            } catch (UncheckedIOException e) {\n                // io exception when parsing (not seen before because reading the stream as we go)\n                throw e.getCause();\n            }\n            doc.outputSettings().charset(charset);\n            if (!charset.canEncode()) {\n                // some charsets can read but not encode; switch to an encodable charset and update the meta el\n                doc.charset(UTF_8);\n            }\n        }\n        return doc;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/helper/DataUtil.java",
        "class_name": "DataUtil",
        "class_uri": "src/main/java/org/jsoup/helper/DataUtil.java.DataUtil",
        "attributes": {
            "modifiers": "static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "static"
            ],
            "comments": [],
            "return_type": "Document",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/helper/DataUtil.java.DataUtil.[ByteBuffer]readToByteBuffer(InputStream,int)",
        "name": "readToByteBuffer",
        "arg_nums": 2,
        "params": [
            {
                "name": "inStream",
                "type": "InputStream"
            },
            {
                "name": "maxSize",
                "type": "int"
            }
        ],
        "return_type": "ByteBuffer",
        "signature": "public static ByteBuffer readToByteBuffer(InputStream inStream, int maxSize)",
        "original_string": "    public static ByteBuffer readToByteBuffer(InputStream inStream, int maxSize) throws IOException {\n        return ControllableInputStream.readToByteBuffer(inStream, maxSize);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/helper/DataUtil.java",
        "class_name": "DataUtil",
        "class_uri": "src/main/java/org/jsoup/helper/DataUtil.java.DataUtil",
        "attributes": {
            "modifiers": "public static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public",
                "static"
            ],
            "comments": [],
            "return_type": "ByteBuffer",
            "classes": []
        },
        "docstring": "\nRead the input stream into a byte buffer. To deal with slow input streams, you may interrupt the thread this\nmethod is executing on. The data read until being interrupted will be available.\n@param inStream the input stream to read from\n@param maxSize the maximum size in bytes to read from the stream. Set to 0 to be unlimited.\n@return the filled byte buffer\n@throws IOException if an exception occurs whilst reading from the input stream.\n"
    },
    {
        "uris": "src/main/java/org/jsoup/helper/DataUtil.java.DataUtil.[ByteBuffer]emptyByteBuffer()",
        "name": "emptyByteBuffer",
        "arg_nums": 0,
        "params": [],
        "return_type": "ByteBuffer",
        "signature": "static ByteBuffer emptyByteBuffer()",
        "original_string": "    static ByteBuffer emptyByteBuffer() {\n        return ByteBuffer.allocate(0);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/helper/DataUtil.java",
        "class_name": "DataUtil",
        "class_uri": "src/main/java/org/jsoup/helper/DataUtil.java.DataUtil",
        "attributes": {
            "modifiers": "static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "static"
            ],
            "comments": [],
            "return_type": "ByteBuffer",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/helper/DataUtil.java.DataUtil.[String]getCharsetFromContentType(String)",
        "name": "getCharsetFromContentType",
        "arg_nums": 1,
        "params": [
            {
                "name": "contentType",
                "type": "String"
            }
        ],
        "return_type": "String",
        "signature": "static @Nullable String getCharsetFromContentType(@Nullable String contentType)",
        "original_string": "    static @Nullable String getCharsetFromContentType(@Nullable String contentType) {\n        if (contentType == null) return null;\n        Matcher m = charsetPattern.matcher(contentType);\n        if (m.find()) {\n            String charset = m.group(1).trim();\n            charset = charset.replace(\"charset=\", \"\");\n            return validateCharset(charset);\n        }\n        return null;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/helper/DataUtil.java",
        "class_name": "DataUtil",
        "class_uri": "src/main/java/org/jsoup/helper/DataUtil.java.DataUtil",
        "attributes": {
            "modifiers": "static @Nullable",
            "marker_annotations": [
                "@Nullable"
            ],
            "non_marker_annotations": [
                "static"
            ],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": "\nParse out a charset from a content type header. If the charset is not supported, returns null (so the default\nwill kick in.)\n@param contentType e.g. \"text/html; charset=EUC-JP\"\n@return \"EUC-JP\", or null if not found. Charset is trimmed and uppercased.\n"
    },
    {
        "uris": "src/main/java/org/jsoup/helper/DataUtil.java.DataUtil.[String]validateCharset(String)",
        "name": "validateCharset",
        "arg_nums": 1,
        "params": [
            {
                "name": "cs",
                "type": "String"
            }
        ],
        "return_type": "String",
        "signature": "private @Nullable static String validateCharset(@Nullable String cs)",
        "original_string": "    private @Nullable static String validateCharset(@Nullable String cs) {\n        if (cs == null || cs.length() == 0) return null;\n        cs = cs.trim().replaceAll(\"[\\\"']\", \"\");\n        try {\n            if (Charset.isSupported(cs)) return cs;\n            cs = cs.toUpperCase(Locale.ENGLISH);\n            if (Charset.isSupported(cs)) return cs;\n        } catch (IllegalCharsetNameException e) {\n            // if all this charset matching fails.... we just take the default\n        }\n        return null;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/helper/DataUtil.java",
        "class_name": "DataUtil",
        "class_uri": "src/main/java/org/jsoup/helper/DataUtil.java.DataUtil",
        "attributes": {
            "modifiers": "private @Nullable static",
            "marker_annotations": [
                "@Nullable"
            ],
            "non_marker_annotations": [
                "private",
                "static"
            ],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/helper/DataUtil.java.DataUtil.[String]mimeBoundary()",
        "name": "mimeBoundary",
        "arg_nums": 0,
        "params": [],
        "return_type": "String",
        "signature": "static String mimeBoundary()",
        "original_string": "    static String mimeBoundary() {\n        final StringBuilder mime = StringUtil.borrowBuilder();\n        final Random rand = new Random();\n        for (int i = 0; i < boundaryLength; i++) {\n            mime.append(mimeBoundaryChars[rand.nextInt(mimeBoundaryChars.length)]);\n        }\n        return StringUtil.releaseBuilder(mime);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/helper/DataUtil.java",
        "class_name": "DataUtil",
        "class_uri": "src/main/java/org/jsoup/helper/DataUtil.java.DataUtil",
        "attributes": {
            "modifiers": "static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "static"
            ],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": "\nCreates a random string, suitable for use as a mime boundary\n"
    },
    {
        "uris": "src/main/java/org/jsoup/helper/DataUtil.java.DataUtil.[String]detectCharsetFromBom(ControllableInputStream)",
        "name": "detectCharsetFromBom",
        "arg_nums": 1,
        "params": [
            {
                "name": "input",
                "type": "ControllableInputStream"
            }
        ],
        "return_type": "String",
        "signature": "private static @Nullable String detectCharsetFromBom(ControllableInputStream input)",
        "original_string": "    private static @Nullable String detectCharsetFromBom(ControllableInputStream input) throws IOException {\n        byte[] bom = new byte[4];\n        input.mark(bom.length);\n        //noinspection ResultOfMethodCallIgnored\n        input.read(bom, 0, 4);\n        input.reset();\n\n        // 16 and 32 decoders consume the BOM to determine be/le; utf-8 should be consumed here\n        if (bom[0] == 0x00 && bom[1] == 0x00 && bom[2] == (byte) 0xFE && bom[3] == (byte) 0xFF || // BE\n            bom[0] == (byte) 0xFF && bom[1] == (byte) 0xFE && bom[2] == 0x00 && bom[3] == 0x00) { // LE\n            return \"UTF-32\"; // and I hope it's on your system\n        } else if (bom[0] == (byte) 0xFE && bom[1] == (byte) 0xFF || // BE\n            bom[0] == (byte) 0xFF && bom[1] == (byte) 0xFE) {\n            return \"UTF-16\"; // in all Javas\n        } else if (bom[0] == (byte) 0xEF && bom[1] == (byte) 0xBB && bom[2] == (byte) 0xBF) {\n            input.read(bom, 0, 3); // consume the UTF-8 BOM\n            return \"UTF-8\"; // in all Javas\n        }\n        return null;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/helper/DataUtil.java",
        "class_name": "DataUtil",
        "class_uri": "src/main/java/org/jsoup/helper/DataUtil.java.DataUtil",
        "attributes": {
            "modifiers": "private static @Nullable",
            "marker_annotations": [
                "@Nullable"
            ],
            "non_marker_annotations": [
                "private",
                "static"
            ],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/helper/RequestAuthenticator.java.RequestAuthenticator.[PasswordAuthentication]authenticate(Context)",
        "name": "authenticate",
        "arg_nums": 1,
        "params": [
            {
                "name": "auth",
                "type": "Context"
            }
        ],
        "return_type": "PasswordAuthentication",
        "signature": "@Nullable\n    PasswordAuthentication authenticate(Context auth)",
        "original_string": "    @Nullable\n    PasswordAuthentication authenticate(Context auth);",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/helper/RequestAuthenticator.java",
        "class_name": "RequestAuthenticator",
        "class_uri": "src/main/java/org/jsoup/helper/RequestAuthenticator.java.RequestAuthenticator",
        "attributes": {
            "modifiers": "@Nullable",
            "marker_annotations": [
                "@Nullable"
            ],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "PasswordAuthentication",
            "classes": []
        },
        "docstring": "\nProvide authentication credentials for the provided Request Context.\n@param auth the request context including URL, type (Server or Proxy), and realm.\n@return credentials for the request. May return {@code null} if they are not applicable -- but the request will\nlikely fail, as this method is only called if the request asked for authentication.\n"
    },
    {
        "uris": "src/main/java/org/jsoup/helper/ValidationException.java.ValidationException.[]ValidationException(String)",
        "name": "ValidationException",
        "arg_nums": 1,
        "params": [
            {
                "name": "msg",
                "type": "String"
            }
        ],
        "return_type": "",
        "signature": "public ValidationException(String msg)",
        "original_string": "    public ValidationException(String msg) {\n        super(msg);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/helper/ValidationException.java",
        "class_name": "ValidationException",
        "class_uri": "src/main/java/org/jsoup/helper/ValidationException.java.ValidationException",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/helper/ValidationException.java.ValidationException.[Throwable]fillInStackTrace()",
        "name": "fillInStackTrace",
        "arg_nums": 0,
        "params": [],
        "return_type": "Throwable",
        "signature": "@Override\n    public synchronized Throwable fillInStackTrace()",
        "original_string": "    @Override\n    public synchronized Throwable fillInStackTrace() {\n        // Filters out the Validate class from the stacktrace, to more clearly point at the root-cause.\n\n        super.fillInStackTrace();\n\n        StackTraceElement[] stackTrace = getStackTrace();\n        List<StackTraceElement> filteredTrace = new ArrayList<>();\n        for (StackTraceElement trace : stackTrace) {\n            if (trace.getClassName().equals(Validator)) continue;\n            filteredTrace.add(trace);\n        }\n\n        setStackTrace(filteredTrace.toArray(new StackTraceElement[0]));\n\n        return this;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/helper/ValidationException.java",
        "class_name": "ValidationException",
        "class_uri": "src/main/java/org/jsoup/helper/ValidationException.java.ValidationException",
        "attributes": {
            "modifiers": "@Override\n    public synchronized",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "public",
                "synchronized"
            ],
            "comments": [],
            "return_type": "Throwable",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/helper/ChangeNotifyingArrayList.java.ChangeNotifyingArrayList.[]ChangeNotifyingArrayList(int)",
        "name": "ChangeNotifyingArrayList",
        "arg_nums": 1,
        "params": [
            {
                "name": "initialCapacity",
                "type": "int"
            }
        ],
        "return_type": "",
        "signature": "public ChangeNotifyingArrayList(int initialCapacity)",
        "original_string": "    public ChangeNotifyingArrayList(int initialCapacity) {\n        super(initialCapacity);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/helper/ChangeNotifyingArrayList.java",
        "class_name": "ChangeNotifyingArrayList",
        "class_uri": "src/main/java/org/jsoup/helper/ChangeNotifyingArrayList.java.ChangeNotifyingArrayList",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/helper/ChangeNotifyingArrayList.java.ChangeNotifyingArrayList.[void]onContentsChanged()",
        "name": "onContentsChanged",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "public abstract void onContentsChanged()",
        "original_string": "    public abstract void onContentsChanged();",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/helper/ChangeNotifyingArrayList.java",
        "class_name": "ChangeNotifyingArrayList",
        "class_uri": "src/main/java/org/jsoup/helper/ChangeNotifyingArrayList.java.ChangeNotifyingArrayList",
        "attributes": {
            "modifiers": "public abstract",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public",
                "abstract"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/helper/ChangeNotifyingArrayList.java.ChangeNotifyingArrayList.[E]set(int,E)",
        "name": "set",
        "arg_nums": 2,
        "params": [
            {
                "name": "index",
                "type": "int"
            },
            {
                "name": "element",
                "type": "E"
            }
        ],
        "return_type": "E",
        "signature": "@Override\n    public E set(int index, E element)",
        "original_string": "    @Override\n    public E set(int index, E element) {\n        onContentsChanged();\n        return super.set(index, element);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/helper/ChangeNotifyingArrayList.java",
        "class_name": "ChangeNotifyingArrayList",
        "class_uri": "src/main/java/org/jsoup/helper/ChangeNotifyingArrayList.java.ChangeNotifyingArrayList",
        "attributes": {
            "modifiers": "@Override\n    public",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "E",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/helper/ChangeNotifyingArrayList.java.ChangeNotifyingArrayList.[boolean]add(E)",
        "name": "add",
        "arg_nums": 1,
        "params": [
            {
                "name": "e",
                "type": "E"
            }
        ],
        "return_type": "boolean",
        "signature": "@Override\n    public boolean add(E e)",
        "original_string": "    @Override\n    public boolean add(E e) {\n        onContentsChanged();\n        return super.add(e);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/helper/ChangeNotifyingArrayList.java",
        "class_name": "ChangeNotifyingArrayList",
        "class_uri": "src/main/java/org/jsoup/helper/ChangeNotifyingArrayList.java.ChangeNotifyingArrayList",
        "attributes": {
            "modifiers": "@Override\n    public",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/helper/ChangeNotifyingArrayList.java.ChangeNotifyingArrayList.[void]add(int,E)",
        "name": "add",
        "arg_nums": 2,
        "params": [
            {
                "name": "index",
                "type": "int"
            },
            {
                "name": "element",
                "type": "E"
            }
        ],
        "return_type": "void",
        "signature": "@Override\n    public void add(int index, E element)",
        "original_string": "    @Override\n    public void add(int index, E element) {\n        onContentsChanged();\n        super.add(index, element);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/helper/ChangeNotifyingArrayList.java",
        "class_name": "ChangeNotifyingArrayList",
        "class_uri": "src/main/java/org/jsoup/helper/ChangeNotifyingArrayList.java.ChangeNotifyingArrayList",
        "attributes": {
            "modifiers": "@Override\n    public",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/helper/ChangeNotifyingArrayList.java.ChangeNotifyingArrayList.[E]remove(int)",
        "name": "remove",
        "arg_nums": 1,
        "params": [
            {
                "name": "index",
                "type": "int"
            }
        ],
        "return_type": "E",
        "signature": "@Override\n    public E remove(int index)",
        "original_string": "    @Override\n    public E remove(int index) {\n        onContentsChanged();\n        return super.remove(index);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/helper/ChangeNotifyingArrayList.java",
        "class_name": "ChangeNotifyingArrayList",
        "class_uri": "src/main/java/org/jsoup/helper/ChangeNotifyingArrayList.java.ChangeNotifyingArrayList",
        "attributes": {
            "modifiers": "@Override\n    public",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "E",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/helper/ChangeNotifyingArrayList.java.ChangeNotifyingArrayList.[boolean]remove(Object)",
        "name": "remove",
        "arg_nums": 1,
        "params": [
            {
                "name": "o",
                "type": "Object"
            }
        ],
        "return_type": "boolean",
        "signature": "@Override\n    public boolean remove(Object o)",
        "original_string": "    @Override\n    public boolean remove(Object o) {\n        onContentsChanged();\n        return super.remove(o);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/helper/ChangeNotifyingArrayList.java",
        "class_name": "ChangeNotifyingArrayList",
        "class_uri": "src/main/java/org/jsoup/helper/ChangeNotifyingArrayList.java.ChangeNotifyingArrayList",
        "attributes": {
            "modifiers": "@Override\n    public",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/helper/ChangeNotifyingArrayList.java.ChangeNotifyingArrayList.[void]clear()",
        "name": "clear",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "@Override\n    public void clear()",
        "original_string": "    @Override\n    public void clear() {\n        onContentsChanged();\n        super.clear();\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/helper/ChangeNotifyingArrayList.java",
        "class_name": "ChangeNotifyingArrayList",
        "class_uri": "src/main/java/org/jsoup/helper/ChangeNotifyingArrayList.java.ChangeNotifyingArrayList",
        "attributes": {
            "modifiers": "@Override\n    public",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/helper/ChangeNotifyingArrayList.java.ChangeNotifyingArrayList.[boolean]addAll(Collection<? extends E>)",
        "name": "addAll",
        "arg_nums": 1,
        "params": [
            {
                "name": "c",
                "type": "Collection<? extends E>"
            }
        ],
        "return_type": "boolean",
        "signature": "@Override\n    public boolean addAll(Collection<? extends E> c)",
        "original_string": "    @Override\n    public boolean addAll(Collection<? extends E> c) {\n        onContentsChanged();\n        return super.addAll(c);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/helper/ChangeNotifyingArrayList.java",
        "class_name": "ChangeNotifyingArrayList",
        "class_uri": "src/main/java/org/jsoup/helper/ChangeNotifyingArrayList.java.ChangeNotifyingArrayList",
        "attributes": {
            "modifiers": "@Override\n    public",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/helper/ChangeNotifyingArrayList.java.ChangeNotifyingArrayList.[boolean]addAll(int,Collection<? extends E>)",
        "name": "addAll",
        "arg_nums": 2,
        "params": [
            {
                "name": "index",
                "type": "int"
            },
            {
                "name": "c",
                "type": "Collection<? extends E>"
            }
        ],
        "return_type": "boolean",
        "signature": "@Override\n    public boolean addAll(int index, Collection<? extends E> c)",
        "original_string": "    @Override\n    public boolean addAll(int index, Collection<? extends E> c) {\n        onContentsChanged();\n        return super.addAll(index, c);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/helper/ChangeNotifyingArrayList.java",
        "class_name": "ChangeNotifyingArrayList",
        "class_uri": "src/main/java/org/jsoup/helper/ChangeNotifyingArrayList.java.ChangeNotifyingArrayList",
        "attributes": {
            "modifiers": "@Override\n    public",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/helper/ChangeNotifyingArrayList.java.ChangeNotifyingArrayList.[void]removeRange(int,int)",
        "name": "removeRange",
        "arg_nums": 2,
        "params": [
            {
                "name": "fromIndex",
                "type": "int"
            },
            {
                "name": "toIndex",
                "type": "int"
            }
        ],
        "return_type": "void",
        "signature": "@Override\n    protected void removeRange(int fromIndex, int toIndex)",
        "original_string": "    @Override\n    protected void removeRange(int fromIndex, int toIndex) {\n        onContentsChanged();\n        super.removeRange(fromIndex, toIndex);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/helper/ChangeNotifyingArrayList.java",
        "class_name": "ChangeNotifyingArrayList",
        "class_uri": "src/main/java/org/jsoup/helper/ChangeNotifyingArrayList.java.ChangeNotifyingArrayList",
        "attributes": {
            "modifiers": "@Override\n    protected",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "protected"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/helper/ChangeNotifyingArrayList.java.ChangeNotifyingArrayList.[boolean]removeAll(Collection<?>)",
        "name": "removeAll",
        "arg_nums": 1,
        "params": [
            {
                "name": "c",
                "type": "Collection<?>"
            }
        ],
        "return_type": "boolean",
        "signature": "@Override\n    public boolean removeAll(Collection<?> c)",
        "original_string": "    @Override\n    public boolean removeAll(Collection<?> c) {\n        onContentsChanged();\n        return super.removeAll(c);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/helper/ChangeNotifyingArrayList.java",
        "class_name": "ChangeNotifyingArrayList",
        "class_uri": "src/main/java/org/jsoup/helper/ChangeNotifyingArrayList.java.ChangeNotifyingArrayList",
        "attributes": {
            "modifiers": "@Override\n    public",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/helper/ChangeNotifyingArrayList.java.ChangeNotifyingArrayList.[boolean]retainAll(Collection<?>)",
        "name": "retainAll",
        "arg_nums": 1,
        "params": [
            {
                "name": "c",
                "type": "Collection<?>"
            }
        ],
        "return_type": "boolean",
        "signature": "@Override\n    public boolean retainAll(Collection<?> c)",
        "original_string": "    @Override\n    public boolean retainAll(Collection<?> c) {\n        onContentsChanged();\n        return super.retainAll(c);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/helper/ChangeNotifyingArrayList.java",
        "class_name": "ChangeNotifyingArrayList",
        "class_uri": "src/main/java/org/jsoup/helper/ChangeNotifyingArrayList.java.ChangeNotifyingArrayList",
        "attributes": {
            "modifiers": "@Override\n    public",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/helper/CookieUtil.java.CookieUtil.[void]applyCookiesToRequest(HttpConnection.Request,HttpURLConnection)",
        "name": "applyCookiesToRequest",
        "arg_nums": 2,
        "params": [
            {
                "name": "req",
                "type": "HttpConnection.Request"
            },
            {
                "name": "con",
                "type": "HttpURLConnection"
            }
        ],
        "return_type": "void",
        "signature": "static void applyCookiesToRequest(HttpConnection.Request req, HttpURLConnection con)",
        "original_string": "    static void applyCookiesToRequest(HttpConnection.Request req, HttpURLConnection con) throws IOException {\n        // Request key/val cookies. LinkedHashSet used to preserve order, as cookie store will return most specific path first\n        Set<String> cookieSet = requestCookieSet(req);\n        Set<String> cookies2 = null;\n\n        // stored:\n        Map<String, List<String>> storedCookies = req.cookieManager().get(asUri(req.url), EmptyRequestHeaders);\n        for (Map.Entry<String, List<String>> entry : storedCookies.entrySet()) {\n            // might be Cookie: name=value; name=value\\nCookie2: name=value; name=value\n            List<String> cookies = entry.getValue(); // these will be name=val\n            if (cookies == null || cookies.size() == 0) // the cookie store often returns just an empty \"Cookie\" key, no val\n                continue;\n\n            String key = entry.getKey(); // Cookie or Cookie2\n            Set<String> set;\n            if (CookieName.equals(key))\n                set = cookieSet;\n            else if (Cookie2Name.equals(key)) {\n                set = new HashSet<>();\n                cookies2 = set;\n            } else {\n                continue; // unexpected header key\n            }\n            set.addAll(cookies);\n        }\n\n        if (cookieSet.size() > 0)\n            con.addRequestProperty(CookieName, StringUtil.join(cookieSet, Sep));\n        if (cookies2 != null && cookies2.size() > 0)\n            con.addRequestProperty(Cookie2Name, StringUtil.join(cookies2, Sep));\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/helper/CookieUtil.java",
        "class_name": "CookieUtil",
        "class_uri": "src/main/java/org/jsoup/helper/CookieUtil.java.CookieUtil",
        "attributes": {
            "modifiers": "static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "static"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": "\nPre-request, get any applicable headers out of the Request cookies and the Cookie Store, and add them to the request\nheaders. If the Cookie Store duplicates any Request cookies (same name and value), they will be discarded.\n"
    },
    {
        "uris": "src/main/java/org/jsoup/helper/CookieUtil.java.CookieUtil.[LinkedHashSet<String>]requestCookieSet(Connection.Request)",
        "name": "requestCookieSet",
        "arg_nums": 1,
        "params": [
            {
                "name": "req",
                "type": "Connection.Request"
            }
        ],
        "return_type": "LinkedHashSet<String>",
        "signature": "private static LinkedHashSet<String> requestCookieSet(Connection.Request req)",
        "original_string": "    private static LinkedHashSet<String> requestCookieSet(Connection.Request req) {\n        LinkedHashSet<String> set = new LinkedHashSet<>();\n        // req cookies are the wildcard key/val cookies (no domain, path, etc)\n        for (Map.Entry<String, String> cookie : req.cookies().entrySet()) {\n            set.add(cookie.getKey() + \"=\" + cookie.getValue());\n        }\n        return set;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/helper/CookieUtil.java",
        "class_name": "CookieUtil",
        "class_uri": "src/main/java/org/jsoup/helper/CookieUtil.java.CookieUtil",
        "attributes": {
            "modifiers": "private static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "private",
                "static"
            ],
            "comments": [],
            "return_type": "LinkedHashSet<String>",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/helper/CookieUtil.java.CookieUtil.[URI]asUri(URL)",
        "name": "asUri",
        "arg_nums": 1,
        "params": [
            {
                "name": "url",
                "type": "URL"
            }
        ],
        "return_type": "URI",
        "signature": "static URI asUri(URL url)",
        "original_string": "    static URI asUri(URL url) throws IOException {\n        try {\n            return url.toURI();\n        } catch (URISyntaxException e) {  // this would be a WTF because we construct the URL\n            MalformedURLException ue = new MalformedURLException(e.getMessage());\n            ue.initCause(e);\n            throw ue;\n        }\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/helper/CookieUtil.java",
        "class_name": "CookieUtil",
        "class_uri": "src/main/java/org/jsoup/helper/CookieUtil.java.CookieUtil",
        "attributes": {
            "modifiers": "static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "static"
            ],
            "comments": [],
            "return_type": "URI",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/helper/CookieUtil.java.CookieUtil.[void]storeCookies(HttpConnection.Request,HttpConnection.Response,URL,Map<String, List<String>>)",
        "name": "storeCookies",
        "arg_nums": 4,
        "params": [
            {
                "name": "req",
                "type": "HttpConnection.Request"
            },
            {
                "name": "res",
                "type": "HttpConnection.Response"
            },
            {
                "name": "url",
                "type": "URL"
            },
            {
                "name": "resHeaders",
                "type": "Map<String, List<String>>"
            }
        ],
        "return_type": "void",
        "signature": "static void storeCookies(HttpConnection.Request req, HttpConnection.Response res, URL url, Map<String, List<String>> resHeaders)",
        "original_string": "    static void storeCookies(HttpConnection.Request req, HttpConnection.Response res, URL url, Map<String, List<String>> resHeaders) throws IOException {\n        CookieManager manager = req.cookieManager();\n        URI uri = CookieUtil.asUri(url);\n        manager.put(uri, resHeaders); // stores cookies for session\n\n        // set up the simple cookie(name, value) map:\n        Map<String, List<String>> cookieMap = manager.get(uri, resHeaders); // get cookies for url; may have been set on this or earlier requests. the headers here are ignored other than a null check\n        for (List<String> values : cookieMap.values()) {\n            for (String headerVal : values) {\n                List<HttpCookie> cookies = HttpCookie.parse(headerVal);\n                for (HttpCookie cookie : cookies) {\n                    res.cookie(cookie.getName(), cookie.getValue());\n                }\n            }\n        }\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/helper/CookieUtil.java",
        "class_name": "CookieUtil",
        "class_uri": "src/main/java/org/jsoup/helper/CookieUtil.java.CookieUtil",
        "attributes": {
            "modifiers": "static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "static"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": " Store the Result cookies into the cookie manager, and place relevant cookies into the Response object."
    },
    {
        "uris": "src/main/java/org/jsoup/helper/W3CDom.java.W3CDom.[]W3CDom()",
        "name": "W3CDom",
        "arg_nums": 0,
        "params": [],
        "return_type": "",
        "signature": "public W3CDom()",
        "original_string": "    public W3CDom() {\n        factory = DocumentBuilderFactory.newInstance();\n        factory.setNamespaceAware(true);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/helper/W3CDom.java",
        "class_name": "W3CDom",
        "class_uri": "src/main/java/org/jsoup/helper/W3CDom.java.W3CDom",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "",
            "classes": []
        },
        "docstring": " false when using selectXpath, for user's query convenience"
    },
    {
        "uris": "src/main/java/org/jsoup/helper/W3CDom.java.W3CDom.[boolean]namespaceAware()",
        "name": "namespaceAware",
        "arg_nums": 0,
        "params": [],
        "return_type": "boolean",
        "signature": "public boolean namespaceAware()",
        "original_string": "    public boolean namespaceAware() {\n        return namespaceAware;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/helper/W3CDom.java",
        "class_name": "W3CDom",
        "class_uri": "src/main/java/org/jsoup/helper/W3CDom.java.W3CDom",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": "\nReturns if this W3C DOM is namespace aware. By default, this will be {@code true}, but is disabled for simplicity\nwhen using XPath selectors in {@link org.jsoup.nodes.Element#selectXpath(String)}.\n@return the current namespace aware setting.\n"
    },
    {
        "uris": "src/main/java/org/jsoup/helper/W3CDom.java.W3CDom.[W3CDom]namespaceAware(boolean)",
        "name": "namespaceAware",
        "arg_nums": 1,
        "params": [
            {
                "name": "namespaceAware",
                "type": "boolean"
            }
        ],
        "return_type": "W3CDom",
        "signature": "public W3CDom namespaceAware(boolean namespaceAware)",
        "original_string": "    public W3CDom namespaceAware(boolean namespaceAware) {\n        this.namespaceAware = namespaceAware;\n        factory.setNamespaceAware(namespaceAware);\n        return this;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/helper/W3CDom.java",
        "class_name": "W3CDom",
        "class_uri": "src/main/java/org/jsoup/helper/W3CDom.java.W3CDom",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "W3CDom",
            "classes": []
        },
        "docstring": "\nUpdate the namespace aware setting. This impacts the factory that is used to create W3C nodes from jsoup nodes.\n<p>For HTML documents, controls if the document will be in the default {@code http://www.w3.org/1999/xhtml}\nnamespace if otherwise unset.</p>.\n@param namespaceAware the updated setting\n@return this W3CDom, for chaining.\n"
    },
    {
        "uris": "src/main/java/org/jsoup/helper/W3CDom.java.W3CDom.[Document]convert(org.jsoup.nodes.Document)",
        "name": "convert",
        "arg_nums": 1,
        "params": [
            {
                "name": "in",
                "type": "org.jsoup.nodes.Document"
            }
        ],
        "return_type": "Document",
        "signature": "public static Document convert(org.jsoup.nodes.Document in)",
        "original_string": "    public static Document convert(org.jsoup.nodes.Document in) {\n        return (new W3CDom().fromJsoup(in));\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/helper/W3CDom.java",
        "class_name": "W3CDom",
        "class_uri": "src/main/java/org/jsoup/helper/W3CDom.java.W3CDom",
        "attributes": {
            "modifiers": "public static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public",
                "static"
            ],
            "comments": [],
            "return_type": "Document",
            "classes": []
        },
        "docstring": "\nConverts a jsoup DOM to a W3C DOM.\n\n@param in jsoup Document\n@return W3C Document\n"
    },
    {
        "uris": "src/main/java/org/jsoup/helper/W3CDom.java.W3CDom.[String]asString(Document,Map<String, String>)",
        "name": "asString",
        "arg_nums": 2,
        "params": [
            {
                "name": "doc",
                "type": "Document"
            },
            {
                "name": "properties",
                "type": "Map<String, String>"
            }
        ],
        "return_type": "String",
        "signature": "public static String asString(Document doc, @Nullable Map<String, String> properties)",
        "original_string": "    public static String asString(Document doc, @Nullable Map<String, String> properties) {\n        try {\n            DOMSource domSource = new DOMSource(doc);\n            StringWriter writer = new StringWriter();\n            StreamResult result = new StreamResult(writer);\n            TransformerFactory tf = TransformerFactory.newInstance();\n            Transformer transformer = tf.newTransformer();\n            if (properties != null)\n                transformer.setOutputProperties(propertiesFromMap(properties));\n\n            if (doc.getDoctype() != null) {\n                DocumentType doctype = doc.getDoctype();\n                if (!StringUtil.isBlank(doctype.getPublicId()))\n                    transformer.setOutputProperty(OutputKeys.DOCTYPE_PUBLIC, doctype.getPublicId());\n                if (!StringUtil.isBlank(doctype.getSystemId()))\n                    transformer.setOutputProperty(OutputKeys.DOCTYPE_SYSTEM, doctype.getSystemId());\n                    // handle <!doctype html> for legacy dom. TODO: nicer if <!doctype html>\n                else if (doctype.getName().equalsIgnoreCase(\"html\")\n                    && StringUtil.isBlank(doctype.getPublicId())\n                    && StringUtil.isBlank(doctype.getSystemId()))\n                    transformer.setOutputProperty(OutputKeys.DOCTYPE_SYSTEM, \"about:legacy-compat\");\n            }\n\n            transformer.transform(domSource, result);\n            return writer.toString();\n\n        } catch (TransformerException e) {\n            throw new IllegalStateException(e);\n        }\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/helper/W3CDom.java",
        "class_name": "W3CDom",
        "class_uri": "src/main/java/org/jsoup/helper/W3CDom.java.W3CDom",
        "attributes": {
            "modifiers": "public static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public",
                "static"
            ],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": "\nSerialize a W3C document to a String. Provide Properties to define output settings including if HTML or XML. If\nyou don't provide the properties ({@code null}), the output will be auto-detected based on the content of the\ndocument.\n\n@param doc Document\n@param properties (optional/nullable) the output properties to use. See {@link\n    Transformer#setOutputProperties(Properties)} and {@link OutputKeys}\n@return Document as string\n@see #OutputHtml\n@see #OutputXml\n@see OutputKeys#ENCODING\n@see OutputKeys#OMIT_XML_DECLARATION\n@see OutputKeys#STANDALONE\n@see OutputKeys#STANDALONE\n@see OutputKeys#DOCTYPE_PUBLIC\n@see OutputKeys#CDATA_SECTION_ELEMENTS\n@see OutputKeys#INDENT\n@see OutputKeys#MEDIA_TYPE\n"
    },
    {
        "uris": "src/main/java/org/jsoup/helper/W3CDom.java.W3CDom.[Properties]propertiesFromMap(Map<String, String>)",
        "name": "propertiesFromMap",
        "arg_nums": 1,
        "params": [
            {
                "name": "map",
                "type": "Map<String, String>"
            }
        ],
        "return_type": "Properties",
        "signature": "static Properties propertiesFromMap(Map<String, String> map)",
        "original_string": "    static Properties propertiesFromMap(Map<String, String> map) {\n        Properties props = new Properties();\n        props.putAll(map);\n        return props;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/helper/W3CDom.java",
        "class_name": "W3CDom",
        "class_uri": "src/main/java/org/jsoup/helper/W3CDom.java.W3CDom",
        "attributes": {
            "modifiers": "static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "static"
            ],
            "comments": [],
            "return_type": "Properties",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/helper/W3CDom.java.W3CDom.[HashMap<String, String>]OutputHtml()",
        "name": "OutputHtml",
        "arg_nums": 0,
        "params": [],
        "return_type": "HashMap<String, String>",
        "signature": "public static HashMap<String, String> OutputHtml()",
        "original_string": "    public static HashMap<String, String> OutputHtml() {\n        return methodMap(\"html\");\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/helper/W3CDom.java",
        "class_name": "W3CDom",
        "class_uri": "src/main/java/org/jsoup/helper/W3CDom.java.W3CDom",
        "attributes": {
            "modifiers": "public static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public",
                "static"
            ],
            "comments": [],
            "return_type": "HashMap<String, String>",
            "classes": []
        },
        "docstring": " Canned default for HTML output."
    },
    {
        "uris": "src/main/java/org/jsoup/helper/W3CDom.java.W3CDom.[HashMap<String, String>]OutputXml()",
        "name": "OutputXml",
        "arg_nums": 0,
        "params": [],
        "return_type": "HashMap<String, String>",
        "signature": "public static HashMap<String, String> OutputXml()",
        "original_string": "    public static HashMap<String, String> OutputXml() {\n        return methodMap(\"xml\");\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/helper/W3CDom.java",
        "class_name": "W3CDom",
        "class_uri": "src/main/java/org/jsoup/helper/W3CDom.java.W3CDom",
        "attributes": {
            "modifiers": "public static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public",
                "static"
            ],
            "comments": [],
            "return_type": "HashMap<String, String>",
            "classes": []
        },
        "docstring": " Canned default for XML output."
    },
    {
        "uris": "src/main/java/org/jsoup/helper/W3CDom.java.W3CDom.[HashMap<String, String>]methodMap(String)",
        "name": "methodMap",
        "arg_nums": 1,
        "params": [
            {
                "name": "method",
                "type": "String"
            }
        ],
        "return_type": "HashMap<String, String>",
        "signature": "private static HashMap<String, String> methodMap(String method)",
        "original_string": "    private static HashMap<String, String> methodMap(String method) {\n        HashMap<String, String> map = new HashMap<>();\n        map.put(METHOD, method);\n        return map;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/helper/W3CDom.java",
        "class_name": "W3CDom",
        "class_uri": "src/main/java/org/jsoup/helper/W3CDom.java.W3CDom",
        "attributes": {
            "modifiers": "private static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "private",
                "static"
            ],
            "comments": [],
            "return_type": "HashMap<String, String>",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/helper/W3CDom.java.W3CDom.[Document]fromJsoup(org.jsoup.nodes.Document)",
        "name": "fromJsoup",
        "arg_nums": 1,
        "params": [
            {
                "name": "in",
                "type": "org.jsoup.nodes.Document"
            }
        ],
        "return_type": "Document",
        "signature": "public Document fromJsoup(org.jsoup.nodes.Document in)",
        "original_string": "    public Document fromJsoup(org.jsoup.nodes.Document in) {\n        // just method API backcompat\n        return fromJsoup((org.jsoup.nodes.Element) in);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/helper/W3CDom.java",
        "class_name": "W3CDom",
        "class_uri": "src/main/java/org/jsoup/helper/W3CDom.java.W3CDom",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Document",
            "classes": []
        },
        "docstring": "\nConvert a jsoup Document to a W3C Document. The created nodes will link back to the original\njsoup nodes in the user property {@link #SourceProperty} (but after conversion, changes on one side will not\nflow to the other).\n\n@param in jsoup doc\n@return a W3C DOM Document representing the jsoup Document or Element contents.\n"
    },
    {
        "uris": "src/main/java/org/jsoup/helper/W3CDom.java.W3CDom.[Document]fromJsoup(org.jsoup.nodes.Element)",
        "name": "fromJsoup",
        "arg_nums": 1,
        "params": [
            {
                "name": "in",
                "type": "org.jsoup.nodes.Element"
            }
        ],
        "return_type": "Document",
        "signature": "public Document fromJsoup(org.jsoup.nodes.Element in)",
        "original_string": "    public Document fromJsoup(org.jsoup.nodes.Element in) {\n        Validate.notNull(in);\n        DocumentBuilder builder;\n        try {\n            builder = factory.newDocumentBuilder();\n            DOMImplementation impl = builder.getDOMImplementation();\n            Document out = builder.newDocument();\n            org.jsoup.nodes.Document inDoc = in.ownerDocument();\n            org.jsoup.nodes.DocumentType doctype = inDoc != null ? inDoc.documentType() : null;\n            if (doctype != null) {\n                try {\n                    org.w3c.dom.DocumentType documentType = impl.createDocumentType(doctype.name(), doctype.publicId(), doctype.systemId());\n                    out.appendChild(documentType);\n                } catch (DOMException ignored) {\n                    // invalid / empty doctype dropped\n                }\n            }\n            out.setXmlStandalone(true);\n            // if in is Document, use the root element, not the wrapping document, as the context:\n            org.jsoup.nodes.Element context = (in instanceof org.jsoup.nodes.Document) ? in.firstElementChild() : in;\n            out.setUserData(ContextProperty, context, null);\n            convert(inDoc != null ? inDoc : in, out);\n            return out;\n        } catch (ParserConfigurationException e) {\n            throw new IllegalStateException(e);\n        }\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/helper/W3CDom.java",
        "class_name": "W3CDom",
        "class_uri": "src/main/java/org/jsoup/helper/W3CDom.java.W3CDom",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Document",
            "classes": []
        },
        "docstring": "\nConvert a jsoup DOM to a W3C Document. The created nodes will link back to the original\njsoup nodes in the user property {@link #SourceProperty} (but after conversion, changes on one side will not\nflow to the other). The input Element is used as a context node, but the whole surrounding jsoup Document is\nconverted. (If you just want a subtree converted, use {@link #convert(org.jsoup.nodes.Element, Document)}.)\n\n@param in jsoup element or doc\n@return a W3C DOM Document representing the jsoup Document or Element contents.\n@see #sourceNodes(NodeList, Class)\n@see #contextNode(Document)\n"
    },
    {
        "uris": "src/main/java/org/jsoup/helper/W3CDom.java.W3CDom.[void]convert(org.jsoup.nodes.Document,Document)",
        "name": "convert",
        "arg_nums": 2,
        "params": [
            {
                "name": "in",
                "type": "org.jsoup.nodes.Document"
            },
            {
                "name": "out",
                "type": "Document"
            }
        ],
        "return_type": "void",
        "signature": "public void convert(org.jsoup.nodes.Document in, Document out)",
        "original_string": "    public void convert(org.jsoup.nodes.Document in, Document out) {\n        // just provides method API backcompat\n        convert((org.jsoup.nodes.Element) in, out);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/helper/W3CDom.java",
        "class_name": "W3CDom",
        "class_uri": "src/main/java/org/jsoup/helper/W3CDom.java.W3CDom",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": "\nConverts a jsoup document into the provided W3C Document. If required, you can set options on the output\ndocument before converting.\n\n@param in jsoup doc\n@param out w3c doc\n@see org.jsoup.helper.W3CDom#fromJsoup(org.jsoup.nodes.Element)\n"
    },
    {
        "uris": "src/main/java/org/jsoup/helper/W3CDom.java.W3CDom.[void]convert(org.jsoup.nodes.Element,Document)",
        "name": "convert",
        "arg_nums": 2,
        "params": [
            {
                "name": "in",
                "type": "org.jsoup.nodes.Element"
            },
            {
                "name": "out",
                "type": "Document"
            }
        ],
        "return_type": "void",
        "signature": "public void convert(org.jsoup.nodes.Element in, Document out)",
        "original_string": "    public void convert(org.jsoup.nodes.Element in, Document out) {\n        W3CBuilder builder = new W3CBuilder(out);\n        builder.namespaceAware = namespaceAware;\n        org.jsoup.nodes.Document inDoc = in.ownerDocument();\n        if (inDoc != null) {\n            if (!StringUtil.isBlank(inDoc.location())) {\n                out.setDocumentURI(inDoc.location());\n            }\n            builder.syntax = inDoc.outputSettings().syntax();\n        }\n        org.jsoup.nodes.Element rootEl = in instanceof org.jsoup.nodes.Document ? in.firstElementChild() : in; // skip the #root node if a Document\n        NodeTraversor.traverse(builder, rootEl);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/helper/W3CDom.java",
        "class_name": "W3CDom",
        "class_uri": "src/main/java/org/jsoup/helper/W3CDom.java.W3CDom",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": "\nConverts a jsoup element into the provided W3C Document. If required, you can set options on the output\ndocument before converting.\n\n@param in jsoup element\n@param out w3c doc\n@see org.jsoup.helper.W3CDom#fromJsoup(org.jsoup.nodes.Element)\n"
    },
    {
        "uris": "src/main/java/org/jsoup/helper/W3CDom.java.W3CDom.[NodeList]selectXpath(String,Document)",
        "name": "selectXpath",
        "arg_nums": 2,
        "params": [
            {
                "name": "xpath",
                "type": "String"
            },
            {
                "name": "doc",
                "type": "Document"
            }
        ],
        "return_type": "NodeList",
        "signature": "public NodeList selectXpath(String xpath, Document doc)",
        "original_string": "    public NodeList selectXpath(String xpath, Document doc) {\n        return selectXpath(xpath, (Node) doc);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/helper/W3CDom.java",
        "class_name": "W3CDom",
        "class_uri": "src/main/java/org/jsoup/helper/W3CDom.java.W3CDom",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "NodeList",
            "classes": []
        },
        "docstring": "\nEvaluate an XPath query against the supplied document, and return the results.\n@param xpath an XPath query\n@param doc the document to evaluate against\n@return the matches nodes\n"
    },
    {
        "uris": "src/main/java/org/jsoup/helper/W3CDom.java.W3CDom.[NodeList]selectXpath(String,Node)",
        "name": "selectXpath",
        "arg_nums": 2,
        "params": [
            {
                "name": "xpath",
                "type": "String"
            },
            {
                "name": "contextNode",
                "type": "Node"
            }
        ],
        "return_type": "NodeList",
        "signature": "public NodeList selectXpath(String xpath, Node contextNode)",
        "original_string": "    public NodeList selectXpath(String xpath, Node contextNode) {\n        Validate.notEmptyParam(xpath, \"xpath\");\n        Validate.notNullParam(contextNode, \"contextNode\");\n\n        NodeList nodeList;\n        try {\n            // if there is a configured XPath factory, use that instead of the Java base impl:\n            String property = System.getProperty(XPathFactoryProperty);\n            final XPathFactory xPathFactory = property != null ?\n                XPathFactory.newInstance(\"jsoup\") :\n                XPathFactory.newInstance();\n\n            XPathExpression expression = xPathFactory.newXPath().compile(xpath);\n            nodeList = (NodeList) expression.evaluate(contextNode, XPathConstants.NODESET); // love the strong typing here /s\n            Validate.notNull(nodeList);\n        } catch (XPathExpressionException | XPathFactoryConfigurationException e) {\n            throw new Selector.SelectorParseException(\n                e, \"Could not evaluate XPath query [%s]: %s\", xpath, e.getMessage());\n        }\n        return nodeList;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/helper/W3CDom.java",
        "class_name": "W3CDom",
        "class_uri": "src/main/java/org/jsoup/helper/W3CDom.java.W3CDom",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "NodeList",
            "classes": []
        },
        "docstring": "\nEvaluate an XPath query against the supplied context node, and return the results.\n@param xpath an XPath query\n@param contextNode the context node to evaluate against\n@return the matches nodes\n"
    },
    {
        "uris": "src/main/java/org/jsoup/helper/W3CDom.java.W3CDom.[List<T>]sourceNodes(NodeList,Class<T>)",
        "name": "sourceNodes",
        "arg_nums": 2,
        "params": [
            {
                "name": "nodeList",
                "type": "NodeList"
            },
            {
                "name": "nodeType",
                "type": "Class<T>"
            }
        ],
        "return_type": "List<T>",
        "signature": "public <T extends org.jsoup.nodes.Node> List<T> sourceNodes(NodeList nodeList, Class<T> nodeType)",
        "original_string": "    public <T extends org.jsoup.nodes.Node> List<T> sourceNodes(NodeList nodeList, Class<T> nodeType) {\n        Validate.notNull(nodeList);\n        Validate.notNull(nodeType);\n        List<T> nodes = new ArrayList<>(nodeList.getLength());\n\n        for (int i = 0; i < nodeList.getLength(); i++) {\n            org.w3c.dom.Node node = nodeList.item(i);\n            Object source = node.getUserData(W3CDom.SourceProperty);\n            if (nodeType.isInstance(source))\n                nodes.add(nodeType.cast(source));\n        }\n\n        return nodes;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/helper/W3CDom.java",
        "class_name": "W3CDom",
        "class_uri": "src/main/java/org/jsoup/helper/W3CDom.java.W3CDom",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "List<T>",
            "classes": []
        },
        "docstring": "\nRetrieves the original jsoup DOM nodes from a nodelist created by this convertor.\n@param nodeList the W3C nodes to get the original jsoup nodes from\n@param nodeType the jsoup node type to retrieve (e.g. Element, DataNode, etc)\n@param <T> node type\n@return a list of the original nodes\n"
    },
    {
        "uris": "src/main/java/org/jsoup/helper/W3CDom.java.W3CDom.[Node]contextNode(Document)",
        "name": "contextNode",
        "arg_nums": 1,
        "params": [
            {
                "name": "wDoc",
                "type": "Document"
            }
        ],
        "return_type": "Node",
        "signature": "public Node contextNode(Document wDoc)",
        "original_string": "    public Node contextNode(Document wDoc) {\n        return (Node) wDoc.getUserData(ContextNodeProperty);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/helper/W3CDom.java",
        "class_name": "W3CDom",
        "class_uri": "src/main/java/org/jsoup/helper/W3CDom.java.W3CDom",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Node",
            "classes": []
        },
        "docstring": "\nFor a Document created by {@link #fromJsoup(org.jsoup.nodes.Element)}, retrieves the W3C context node.\n@param wDoc Document created by this class\n@return the corresponding W3C Node to the jsoup Element that was used as the creating context.\n"
    },
    {
        "uris": "src/main/java/org/jsoup/helper/W3CDom.java.W3CDom.[String]asString(Document)",
        "name": "asString",
        "arg_nums": 1,
        "params": [
            {
                "name": "doc",
                "type": "Document"
            }
        ],
        "return_type": "String",
        "signature": "public String asString(Document doc)",
        "original_string": "    public String asString(Document doc) {\n        return asString(doc, null);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/helper/W3CDom.java",
        "class_name": "W3CDom",
        "class_uri": "src/main/java/org/jsoup/helper/W3CDom.java.W3CDom",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": "\nSerialize a W3C document to a String. The output format will be XML or HTML depending on the content of the doc.\n\n@param doc Document\n@return Document as string\n@see W3CDom#asString(Document, Map)\n"
    },
    {
        "uris": "src/main/java/org/jsoup/helper/HttpConnection.java.HttpConnection.[Connection]connect(String)",
        "name": "connect",
        "arg_nums": 1,
        "params": [
            {
                "name": "url",
                "type": "String"
            }
        ],
        "return_type": "Connection",
        "signature": "public static Connection connect(String url)",
        "original_string": "    public static Connection connect(String url) {\n        Connection con = new HttpConnection();\n        con.url(url);\n        return con;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "HttpConnection",
        "class_uri": "src/main/java/org/jsoup/helper/HttpConnection.java.HttpConnection",
        "attributes": {
            "modifiers": "public static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public",
                "static"
            ],
            "comments": [],
            "return_type": "Connection",
            "classes": []
        },
        "docstring": "\nCreate a new Connection, with the request URL specified.\n@param url the URL to fetch from\n@return a new Connection object\n"
    },
    {
        "uris": "src/main/java/org/jsoup/helper/HttpConnection.java.HttpConnection.[Connection]connect(URL)",
        "name": "connect",
        "arg_nums": 1,
        "params": [
            {
                "name": "url",
                "type": "URL"
            }
        ],
        "return_type": "Connection",
        "signature": "public static Connection connect(URL url)",
        "original_string": "    public static Connection connect(URL url) {\n        Connection con = new HttpConnection();\n        con.url(url);\n        return con;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "HttpConnection",
        "class_uri": "src/main/java/org/jsoup/helper/HttpConnection.java.HttpConnection",
        "attributes": {
            "modifiers": "public static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public",
                "static"
            ],
            "comments": [],
            "return_type": "Connection",
            "classes": []
        },
        "docstring": "\nCreate a new Connection, with the request URL specified.\n@param url the URL to fetch from\n@return a new Connection object\n"
    },
    {
        "uris": "src/main/java/org/jsoup/helper/HttpConnection.java.HttpConnection.[]HttpConnection()",
        "name": "HttpConnection",
        "arg_nums": 0,
        "params": [],
        "return_type": "",
        "signature": "public HttpConnection()",
        "original_string": "    public HttpConnection() {\n        req = new Request();\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "HttpConnection",
        "class_uri": "src/main/java/org/jsoup/helper/HttpConnection.java.HttpConnection",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "",
            "classes": []
        },
        "docstring": "\nCreate a new, empty HttpConnection.\n"
    },
    {
        "uris": "src/main/java/org/jsoup/helper/HttpConnection.java.HttpConnection.[]HttpConnection(Request)",
        "name": "HttpConnection",
        "arg_nums": 1,
        "params": [
            {
                "name": "copy",
                "type": "Request"
            }
        ],
        "return_type": "",
        "signature": "HttpConnection(Request copy)",
        "original_string": "    HttpConnection(Request copy) {\n        req = new Request(copy);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "HttpConnection",
        "class_uri": "src/main/java/org/jsoup/helper/HttpConnection.java.HttpConnection",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "",
            "classes": []
        },
        "docstring": "\nCreate a new Request by deep-copying an existing Request. Note that the data and body of the original are not\ncopied. All other settings (proxy, parser, cookies, etc) are copied.\n@param copy the request to copy\n"
    },
    {
        "uris": "src/main/java/org/jsoup/helper/HttpConnection.java.HttpConnection.[String]encodeMimeName(String)",
        "name": "encodeMimeName",
        "arg_nums": 1,
        "params": [
            {
                "name": "val",
                "type": "String"
            }
        ],
        "return_type": "String",
        "signature": "private static String encodeMimeName(String val)",
        "original_string": "    private static String encodeMimeName(String val) {\n        return val.replace(\"\\\"\", \"%22\");\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "HttpConnection",
        "class_uri": "src/main/java/org/jsoup/helper/HttpConnection.java.HttpConnection",
        "attributes": {
            "modifiers": "private static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "private",
                "static"
            ],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/helper/HttpConnection.java.HttpConnection.[Connection]newRequest()",
        "name": "newRequest",
        "arg_nums": 0,
        "params": [],
        "return_type": "Connection",
        "signature": "@Override\n    public Connection newRequest()",
        "original_string": "    @Override\n    public Connection newRequest() {\n        // copy the prototype request for the different settings, cookie manager, etc\n        return new HttpConnection(req);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "HttpConnection",
        "class_uri": "src/main/java/org/jsoup/helper/HttpConnection.java.HttpConnection",
        "attributes": {
            "modifiers": "@Override\n    public",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Connection",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/helper/HttpConnection.java.HttpConnection.[]HttpConnection(Request,Response)",
        "name": "HttpConnection",
        "arg_nums": 2,
        "params": [
            {
                "name": "req",
                "type": "Request"
            },
            {
                "name": "res",
                "type": "Response"
            }
        ],
        "return_type": "",
        "signature": "private HttpConnection(Request req, Response res)",
        "original_string": "    private HttpConnection(Request req, Response res) {\n        this.req = req;\n        this.res = res;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "HttpConnection",
        "class_uri": "src/main/java/org/jsoup/helper/HttpConnection.java.HttpConnection",
        "attributes": {
            "modifiers": "private",
            "marker_annotations": [],
            "non_marker_annotations": [
                "private"
            ],
            "comments": [],
            "return_type": "",
            "classes": []
        },
        "docstring": " Create a new Connection that just wraps the provided Request and Response"
    },
    {
        "uris": "src/main/java/org/jsoup/helper/HttpConnection.java.HttpConnection.[Connection]url(URL)",
        "name": "url",
        "arg_nums": 1,
        "params": [
            {
                "name": "url",
                "type": "URL"
            }
        ],
        "return_type": "Connection",
        "signature": "@Override\n    public Connection url(URL url)",
        "original_string": "    @Override\n    public Connection url(URL url) {\n        req.url(url);\n        return this;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "HttpConnection",
        "class_uri": "src/main/java/org/jsoup/helper/HttpConnection.java.HttpConnection",
        "attributes": {
            "modifiers": "@Override\n    public",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Connection",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/helper/HttpConnection.java.HttpConnection.[Connection]url(String)",
        "name": "url",
        "arg_nums": 1,
        "params": [
            {
                "name": "url",
                "type": "String"
            }
        ],
        "return_type": "Connection",
        "signature": "@Override\n    public Connection url(String url)",
        "original_string": "    @Override\n    public Connection url(String url) {\n        Validate.notEmptyParam(url, \"url\");\n        try {\n            req.url(new URL(url));\n        } catch (MalformedURLException e) {\n            throw new IllegalArgumentException(String.format(\"The supplied URL, '%s', is malformed. Make sure it is an absolute URL, and starts with 'http://' or 'https://'. See https://jsoup.org/cookbook/extracting-data/working-with-urls\", url), e);\n        }\n        return this;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "HttpConnection",
        "class_uri": "src/main/java/org/jsoup/helper/HttpConnection.java.HttpConnection",
        "attributes": {
            "modifiers": "@Override\n    public",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Connection",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/helper/HttpConnection.java.HttpConnection.[Connection]proxy(Proxy)",
        "name": "proxy",
        "arg_nums": 1,
        "params": [
            {
                "name": "proxy",
                "type": "Proxy"
            }
        ],
        "return_type": "Connection",
        "signature": "@Override\n    public Connection proxy(@Nullable Proxy proxy)",
        "original_string": "    @Override\n    public Connection proxy(@Nullable Proxy proxy) {\n        req.proxy(proxy);\n        return this;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "HttpConnection",
        "class_uri": "src/main/java/org/jsoup/helper/HttpConnection.java.HttpConnection",
        "attributes": {
            "modifiers": "@Override\n    public",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Connection",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/helper/HttpConnection.java.HttpConnection.[Connection]proxy(String,int)",
        "name": "proxy",
        "arg_nums": 2,
        "params": [
            {
                "name": "host",
                "type": "String"
            },
            {
                "name": "port",
                "type": "int"
            }
        ],
        "return_type": "Connection",
        "signature": "@Override\n    public Connection proxy(String host, int port)",
        "original_string": "    @Override\n    public Connection proxy(String host, int port) {\n        req.proxy(host, port);\n        return this;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "HttpConnection",
        "class_uri": "src/main/java/org/jsoup/helper/HttpConnection.java.HttpConnection",
        "attributes": {
            "modifiers": "@Override\n    public",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Connection",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/helper/HttpConnection.java.HttpConnection.[Connection]userAgent(String)",
        "name": "userAgent",
        "arg_nums": 1,
        "params": [
            {
                "name": "userAgent",
                "type": "String"
            }
        ],
        "return_type": "Connection",
        "signature": "@Override\n    public Connection userAgent(String userAgent)",
        "original_string": "    @Override\n    public Connection userAgent(String userAgent) {\n        Validate.notNullParam(userAgent, \"userAgent\");\n        req.header(USER_AGENT, userAgent);\n        return this;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "HttpConnection",
        "class_uri": "src/main/java/org/jsoup/helper/HttpConnection.java.HttpConnection",
        "attributes": {
            "modifiers": "@Override\n    public",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Connection",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/helper/HttpConnection.java.HttpConnection.[Connection]timeout(int)",
        "name": "timeout",
        "arg_nums": 1,
        "params": [
            {
                "name": "millis",
                "type": "int"
            }
        ],
        "return_type": "Connection",
        "signature": "@Override\n    public Connection timeout(int millis)",
        "original_string": "    @Override\n    public Connection timeout(int millis) {\n        req.timeout(millis);\n        return this;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "HttpConnection",
        "class_uri": "src/main/java/org/jsoup/helper/HttpConnection.java.HttpConnection",
        "attributes": {
            "modifiers": "@Override\n    public",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Connection",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/helper/HttpConnection.java.HttpConnection.[Connection]maxBodySize(int)",
        "name": "maxBodySize",
        "arg_nums": 1,
        "params": [
            {
                "name": "bytes",
                "type": "int"
            }
        ],
        "return_type": "Connection",
        "signature": "@Override\n    public Connection maxBodySize(int bytes)",
        "original_string": "    @Override\n    public Connection maxBodySize(int bytes) {\n        req.maxBodySize(bytes);\n        return this;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "HttpConnection",
        "class_uri": "src/main/java/org/jsoup/helper/HttpConnection.java.HttpConnection",
        "attributes": {
            "modifiers": "@Override\n    public",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Connection",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/helper/HttpConnection.java.HttpConnection.[Connection]followRedirects(boolean)",
        "name": "followRedirects",
        "arg_nums": 1,
        "params": [
            {
                "name": "followRedirects",
                "type": "boolean"
            }
        ],
        "return_type": "Connection",
        "signature": "@Override\n    public Connection followRedirects(boolean followRedirects)",
        "original_string": "    @Override\n    public Connection followRedirects(boolean followRedirects) {\n        req.followRedirects(followRedirects);\n        return this;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "HttpConnection",
        "class_uri": "src/main/java/org/jsoup/helper/HttpConnection.java.HttpConnection",
        "attributes": {
            "modifiers": "@Override\n    public",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Connection",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/helper/HttpConnection.java.HttpConnection.[Connection]referrer(String)",
        "name": "referrer",
        "arg_nums": 1,
        "params": [
            {
                "name": "referrer",
                "type": "String"
            }
        ],
        "return_type": "Connection",
        "signature": "@Override\n    public Connection referrer(String referrer)",
        "original_string": "    @Override\n    public Connection referrer(String referrer) {\n        Validate.notNullParam(referrer, \"referrer\");\n        req.header(\"Referer\", referrer);\n        return this;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "HttpConnection",
        "class_uri": "src/main/java/org/jsoup/helper/HttpConnection.java.HttpConnection",
        "attributes": {
            "modifiers": "@Override\n    public",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Connection",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/helper/HttpConnection.java.HttpConnection.[Connection]method(Method)",
        "name": "method",
        "arg_nums": 1,
        "params": [
            {
                "name": "method",
                "type": "Method"
            }
        ],
        "return_type": "Connection",
        "signature": "@Override\n    public Connection method(Method method)",
        "original_string": "    @Override\n    public Connection method(Method method) {\n        req.method(method);\n        return this;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "HttpConnection",
        "class_uri": "src/main/java/org/jsoup/helper/HttpConnection.java.HttpConnection",
        "attributes": {
            "modifiers": "@Override\n    public",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Connection",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/helper/HttpConnection.java.HttpConnection.[Connection]ignoreHttpErrors(boolean)",
        "name": "ignoreHttpErrors",
        "arg_nums": 1,
        "params": [
            {
                "name": "ignoreHttpErrors",
                "type": "boolean"
            }
        ],
        "return_type": "Connection",
        "signature": "@Override\n    public Connection ignoreHttpErrors(boolean ignoreHttpErrors)",
        "original_string": "    @Override\n    public Connection ignoreHttpErrors(boolean ignoreHttpErrors) {\n\t\treq.ignoreHttpErrors(ignoreHttpErrors);\n\t\treturn this;\n\t}",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "HttpConnection",
        "class_uri": "src/main/java/org/jsoup/helper/HttpConnection.java.HttpConnection",
        "attributes": {
            "modifiers": "@Override\n    public",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Connection",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/helper/HttpConnection.java.HttpConnection.[Connection]ignoreContentType(boolean)",
        "name": "ignoreContentType",
        "arg_nums": 1,
        "params": [
            {
                "name": "ignoreContentType",
                "type": "boolean"
            }
        ],
        "return_type": "Connection",
        "signature": "@Override\n    public Connection ignoreContentType(boolean ignoreContentType)",
        "original_string": "    @Override\n    public Connection ignoreContentType(boolean ignoreContentType) {\n        req.ignoreContentType(ignoreContentType);\n        return this;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "HttpConnection",
        "class_uri": "src/main/java/org/jsoup/helper/HttpConnection.java.HttpConnection",
        "attributes": {
            "modifiers": "@Override\n    public",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Connection",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/helper/HttpConnection.java.HttpConnection.[Connection]data(String,String)",
        "name": "data",
        "arg_nums": 2,
        "params": [
            {
                "name": "key",
                "type": "String"
            },
            {
                "name": "value",
                "type": "String"
            }
        ],
        "return_type": "Connection",
        "signature": "@Override\n    public Connection data(String key, String value)",
        "original_string": "    @Override\n    public Connection data(String key, String value) {\n        req.data(KeyVal.create(key, value));\n        return this;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "HttpConnection",
        "class_uri": "src/main/java/org/jsoup/helper/HttpConnection.java.HttpConnection",
        "attributes": {
            "modifiers": "@Override\n    public",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Connection",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/helper/HttpConnection.java.HttpConnection.[Connection]sslSocketFactory(SSLSocketFactory)",
        "name": "sslSocketFactory",
        "arg_nums": 1,
        "params": [
            {
                "name": "sslSocketFactory",
                "type": "SSLSocketFactory"
            }
        ],
        "return_type": "Connection",
        "signature": "@Override\n    public Connection sslSocketFactory(SSLSocketFactory sslSocketFactory)",
        "original_string": "    @Override\n    public Connection sslSocketFactory(SSLSocketFactory sslSocketFactory) {\n\t    req.sslSocketFactory(sslSocketFactory);\n\t    return this;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "HttpConnection",
        "class_uri": "src/main/java/org/jsoup/helper/HttpConnection.java.HttpConnection",
        "attributes": {
            "modifiers": "@Override\n    public",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Connection",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/helper/HttpConnection.java.HttpConnection.[Connection]data(String,String,InputStream)",
        "name": "data",
        "arg_nums": 3,
        "params": [
            {
                "name": "key",
                "type": "String"
            },
            {
                "name": "filename",
                "type": "String"
            },
            {
                "name": "inputStream",
                "type": "InputStream"
            }
        ],
        "return_type": "Connection",
        "signature": "@Override\n    public Connection data(String key, String filename, InputStream inputStream)",
        "original_string": "    @Override\n    public Connection data(String key, String filename, InputStream inputStream) {\n        req.data(KeyVal.create(key, filename, inputStream));\n        return this;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "HttpConnection",
        "class_uri": "src/main/java/org/jsoup/helper/HttpConnection.java.HttpConnection",
        "attributes": {
            "modifiers": "@Override\n    public",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Connection",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/helper/HttpConnection.java.HttpConnection.[Connection]data(String,String,InputStream,String)",
        "name": "data",
        "arg_nums": 4,
        "params": [
            {
                "name": "key",
                "type": "String"
            },
            {
                "name": "filename",
                "type": "String"
            },
            {
                "name": "inputStream",
                "type": "InputStream"
            },
            {
                "name": "contentType",
                "type": "String"
            }
        ],
        "return_type": "Connection",
        "signature": "@Override\n    public Connection data(String key, String filename, InputStream inputStream, String contentType)",
        "original_string": "    @Override\n    public Connection data(String key, String filename, InputStream inputStream, String contentType) {\n        req.data(KeyVal.create(key, filename, inputStream).contentType(contentType));\n        return this;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "HttpConnection",
        "class_uri": "src/main/java/org/jsoup/helper/HttpConnection.java.HttpConnection",
        "attributes": {
            "modifiers": "@Override\n    public",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Connection",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/helper/HttpConnection.java.HttpConnection.[Connection]data(Map<String, String>)",
        "name": "data",
        "arg_nums": 1,
        "params": [
            {
                "name": "data",
                "type": "Map<String, String>"
            }
        ],
        "return_type": "Connection",
        "signature": "@Override\n    public Connection data(Map<String, String> data)",
        "original_string": "    @Override\n    public Connection data(Map<String, String> data) {\n        Validate.notNullParam(data, \"data\");\n        for (Map.Entry<String, String> entry : data.entrySet()) {\n            req.data(KeyVal.create(entry.getKey(), entry.getValue()));\n        }\n        return this;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "HttpConnection",
        "class_uri": "src/main/java/org/jsoup/helper/HttpConnection.java.HttpConnection",
        "attributes": {
            "modifiers": "@Override\n    public",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Connection",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/helper/HttpConnection.java.HttpConnection.[Connection]data()",
        "name": "data",
        "arg_nums": 0,
        "params": [],
        "return_type": "Connection",
        "signature": "@Override\n    public Connection data(String... keyvals)",
        "original_string": "    @Override\n    public Connection data(String... keyvals) {\n        Validate.notNullParam(keyvals, \"keyvals\");\n        Validate.isTrue(keyvals.length %2 == 0, \"Must supply an even number of key value pairs\");\n        for (int i = 0; i < keyvals.length; i += 2) {\n            String key = keyvals[i];\n            String value = keyvals[i+1];\n            Validate.notEmpty(key, \"Data key must not be empty\");\n            Validate.notNull(value, \"Data value must not be null\");\n            req.data(KeyVal.create(key, value));\n        }\n        return this;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "HttpConnection",
        "class_uri": "src/main/java/org/jsoup/helper/HttpConnection.java.HttpConnection",
        "attributes": {
            "modifiers": "@Override\n    public",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Connection",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/helper/HttpConnection.java.HttpConnection.[Connection]data(Collection<Connection.KeyVal>)",
        "name": "data",
        "arg_nums": 1,
        "params": [
            {
                "name": "data",
                "type": "Collection<Connection.KeyVal>"
            }
        ],
        "return_type": "Connection",
        "signature": "@Override\n    public Connection data(Collection<Connection.KeyVal> data)",
        "original_string": "    @Override\n    public Connection data(Collection<Connection.KeyVal> data) {\n        Validate.notNullParam(data, \"data\");\n        for (Connection.KeyVal entry: data) {\n            req.data(entry);\n        }\n        return this;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "HttpConnection",
        "class_uri": "src/main/java/org/jsoup/helper/HttpConnection.java.HttpConnection",
        "attributes": {
            "modifiers": "@Override\n    public",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Connection",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/helper/HttpConnection.java.HttpConnection.[Connection.KeyVal]data(String)",
        "name": "data",
        "arg_nums": 1,
        "params": [
            {
                "name": "key",
                "type": "String"
            }
        ],
        "return_type": "Connection.KeyVal",
        "signature": "@Override\n    public Connection.KeyVal data(String key)",
        "original_string": "    @Override\n    public Connection.KeyVal data(String key) {\n        Validate.notEmptyParam(key, \"key\");\n        for (Connection.KeyVal keyVal : request().data()) {\n            if (keyVal.key().equals(key))\n                return keyVal;\n        }\n        return null;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "HttpConnection",
        "class_uri": "src/main/java/org/jsoup/helper/HttpConnection.java.HttpConnection",
        "attributes": {
            "modifiers": "@Override\n    public",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Connection.KeyVal",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/helper/HttpConnection.java.HttpConnection.[Connection]requestBody(String)",
        "name": "requestBody",
        "arg_nums": 1,
        "params": [
            {
                "name": "body",
                "type": "String"
            }
        ],
        "return_type": "Connection",
        "signature": "@Override\n    public Connection requestBody(String body)",
        "original_string": "    @Override\n    public Connection requestBody(String body) {\n        req.requestBody(body);\n        return this;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "HttpConnection",
        "class_uri": "src/main/java/org/jsoup/helper/HttpConnection.java.HttpConnection",
        "attributes": {
            "modifiers": "@Override\n    public",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Connection",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/helper/HttpConnection.java.HttpConnection.[Connection]header(String,String)",
        "name": "header",
        "arg_nums": 2,
        "params": [
            {
                "name": "name",
                "type": "String"
            },
            {
                "name": "value",
                "type": "String"
            }
        ],
        "return_type": "Connection",
        "signature": "@Override\n    public Connection header(String name, String value)",
        "original_string": "    @Override\n    public Connection header(String name, String value) {\n        req.header(name, value);\n        return this;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "HttpConnection",
        "class_uri": "src/main/java/org/jsoup/helper/HttpConnection.java.HttpConnection",
        "attributes": {
            "modifiers": "@Override\n    public",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Connection",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/helper/HttpConnection.java.HttpConnection.[Connection]headers(Map<String,String>)",
        "name": "headers",
        "arg_nums": 1,
        "params": [
            {
                "name": "headers",
                "type": "Map<String,String>"
            }
        ],
        "return_type": "Connection",
        "signature": "@Override\n    public Connection headers(Map<String,String> headers)",
        "original_string": "    @Override\n    public Connection headers(Map<String,String> headers) {\n        Validate.notNullParam(headers, \"headers\");\n        for (Map.Entry<String,String> entry : headers.entrySet()) {\n            req.header(entry.getKey(),entry.getValue());\n        }\n        return this;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "HttpConnection",
        "class_uri": "src/main/java/org/jsoup/helper/HttpConnection.java.HttpConnection",
        "attributes": {
            "modifiers": "@Override\n    public",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Connection",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/helper/HttpConnection.java.HttpConnection.[Connection]cookie(String,String)",
        "name": "cookie",
        "arg_nums": 2,
        "params": [
            {
                "name": "name",
                "type": "String"
            },
            {
                "name": "value",
                "type": "String"
            }
        ],
        "return_type": "Connection",
        "signature": "@Override\n    public Connection cookie(String name, String value)",
        "original_string": "    @Override\n    public Connection cookie(String name, String value) {\n        req.cookie(name, value);\n        return this;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "HttpConnection",
        "class_uri": "src/main/java/org/jsoup/helper/HttpConnection.java.HttpConnection",
        "attributes": {
            "modifiers": "@Override\n    public",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Connection",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/helper/HttpConnection.java.HttpConnection.[Connection]cookies(Map<String, String>)",
        "name": "cookies",
        "arg_nums": 1,
        "params": [
            {
                "name": "cookies",
                "type": "Map<String, String>"
            }
        ],
        "return_type": "Connection",
        "signature": "@Override\n    public Connection cookies(Map<String, String> cookies)",
        "original_string": "    @Override\n    public Connection cookies(Map<String, String> cookies) {\n        Validate.notNullParam(cookies, \"cookies\");\n        for (Map.Entry<String, String> entry : cookies.entrySet()) {\n            req.cookie(entry.getKey(), entry.getValue());\n        }\n        return this;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "HttpConnection",
        "class_uri": "src/main/java/org/jsoup/helper/HttpConnection.java.HttpConnection",
        "attributes": {
            "modifiers": "@Override\n    public",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Connection",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/helper/HttpConnection.java.HttpConnection.[Connection]cookieStore(CookieStore)",
        "name": "cookieStore",
        "arg_nums": 1,
        "params": [
            {
                "name": "cookieStore",
                "type": "CookieStore"
            }
        ],
        "return_type": "Connection",
        "signature": "@Override\n    public Connection cookieStore(CookieStore cookieStore)",
        "original_string": "    @Override\n    public Connection cookieStore(CookieStore cookieStore) {\n        // create a new cookie manager using the new store\n        req.cookieManager = new CookieManager(cookieStore, null);\n        return this;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "HttpConnection",
        "class_uri": "src/main/java/org/jsoup/helper/HttpConnection.java.HttpConnection",
        "attributes": {
            "modifiers": "@Override\n    public",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Connection",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/helper/HttpConnection.java.HttpConnection.[CookieStore]cookieStore()",
        "name": "cookieStore",
        "arg_nums": 0,
        "params": [],
        "return_type": "CookieStore",
        "signature": "@Override\n    public CookieStore cookieStore()",
        "original_string": "    @Override\n    public CookieStore cookieStore() {\n        return req.cookieManager.getCookieStore();\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "HttpConnection",
        "class_uri": "src/main/java/org/jsoup/helper/HttpConnection.java.HttpConnection",
        "attributes": {
            "modifiers": "@Override\n    public",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "CookieStore",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/helper/HttpConnection.java.HttpConnection.[Connection]parser(Parser)",
        "name": "parser",
        "arg_nums": 1,
        "params": [
            {
                "name": "parser",
                "type": "Parser"
            }
        ],
        "return_type": "Connection",
        "signature": "@Override\n    public Connection parser(Parser parser)",
        "original_string": "    @Override\n    public Connection parser(Parser parser) {\n        req.parser(parser);\n        return this;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "HttpConnection",
        "class_uri": "src/main/java/org/jsoup/helper/HttpConnection.java.HttpConnection",
        "attributes": {
            "modifiers": "@Override\n    public",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Connection",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/helper/HttpConnection.java.HttpConnection.[Document]get()",
        "name": "get",
        "arg_nums": 0,
        "params": [],
        "return_type": "Document",
        "signature": "@Override\n    public Document get()",
        "original_string": "    @Override\n    public Document get() throws IOException {\n        req.method(Method.GET);\n        execute();\n        Validate.notNull(res);\n        return res.parse();\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "HttpConnection",
        "class_uri": "src/main/java/org/jsoup/helper/HttpConnection.java.HttpConnection",
        "attributes": {
            "modifiers": "@Override\n    public",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Document",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/helper/HttpConnection.java.HttpConnection.[Document]post()",
        "name": "post",
        "arg_nums": 0,
        "params": [],
        "return_type": "Document",
        "signature": "@Override\n    public Document post()",
        "original_string": "    @Override\n    public Document post() throws IOException {\n        req.method(Method.POST);\n        execute();\n        Validate.notNull(res);\n        return res.parse();\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "HttpConnection",
        "class_uri": "src/main/java/org/jsoup/helper/HttpConnection.java.HttpConnection",
        "attributes": {
            "modifiers": "@Override\n    public",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Document",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/helper/HttpConnection.java.HttpConnection.[Connection.Response]execute()",
        "name": "execute",
        "arg_nums": 0,
        "params": [],
        "return_type": "Connection.Response",
        "signature": "@Override\n    public Connection.Response execute()",
        "original_string": "    @Override\n    public Connection.Response execute() throws IOException {\n        res = Response.execute(req);\n        return res;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "HttpConnection",
        "class_uri": "src/main/java/org/jsoup/helper/HttpConnection.java.HttpConnection",
        "attributes": {
            "modifiers": "@Override\n    public",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Connection.Response",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/helper/HttpConnection.java.HttpConnection.[Connection.Request]request()",
        "name": "request",
        "arg_nums": 0,
        "params": [],
        "return_type": "Connection.Request",
        "signature": "@Override\n    public Connection.Request request()",
        "original_string": "    @Override\n    public Connection.Request request() {\n        return req;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "HttpConnection",
        "class_uri": "src/main/java/org/jsoup/helper/HttpConnection.java.HttpConnection",
        "attributes": {
            "modifiers": "@Override\n    public",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Connection.Request",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/helper/HttpConnection.java.HttpConnection.[Connection]request(Connection.Request)",
        "name": "request",
        "arg_nums": 1,
        "params": [
            {
                "name": "request",
                "type": "Connection.Request"
            }
        ],
        "return_type": "Connection",
        "signature": "@Override\n    public Connection request(Connection.Request request)",
        "original_string": "    @Override\n    public Connection request(Connection.Request request) {\n        req = (HttpConnection.Request) request; // will throw a class-cast exception if the user has extended some but not all of Connection; that's desired\n        return this;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "HttpConnection",
        "class_uri": "src/main/java/org/jsoup/helper/HttpConnection.java.HttpConnection",
        "attributes": {
            "modifiers": "@Override\n    public",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Connection",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/helper/HttpConnection.java.HttpConnection.[Connection.Response]response()",
        "name": "response",
        "arg_nums": 0,
        "params": [],
        "return_type": "Connection.Response",
        "signature": "@Override\n    public Connection.Response response()",
        "original_string": "    @Override\n    public Connection.Response response() {\n        if (res == null) {\n            throw new IllegalArgumentException(\"You must execute the request before getting a response.\");\n        }\n        return res;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "HttpConnection",
        "class_uri": "src/main/java/org/jsoup/helper/HttpConnection.java.HttpConnection",
        "attributes": {
            "modifiers": "@Override\n    public",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Connection.Response",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/helper/HttpConnection.java.HttpConnection.[Connection]response(Connection.Response)",
        "name": "response",
        "arg_nums": 1,
        "params": [
            {
                "name": "response",
                "type": "Connection.Response"
            }
        ],
        "return_type": "Connection",
        "signature": "@Override\n    public Connection response(Connection.Response response)",
        "original_string": "    @Override\n    public Connection response(Connection.Response response) {\n        res = response;\n        return this;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "HttpConnection",
        "class_uri": "src/main/java/org/jsoup/helper/HttpConnection.java.HttpConnection",
        "attributes": {
            "modifiers": "@Override\n    public",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Connection",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/helper/HttpConnection.java.HttpConnection.[Connection]postDataCharset(String)",
        "name": "postDataCharset",
        "arg_nums": 1,
        "params": [
            {
                "name": "charset",
                "type": "String"
            }
        ],
        "return_type": "Connection",
        "signature": "@Override\n    public Connection postDataCharset(String charset)",
        "original_string": "    @Override\n    public Connection postDataCharset(String charset) {\n        req.postDataCharset(charset);\n        return this;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "HttpConnection",
        "class_uri": "src/main/java/org/jsoup/helper/HttpConnection.java.HttpConnection",
        "attributes": {
            "modifiers": "@Override\n    public",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Connection",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/helper/HttpConnection.java.HttpConnection.[Connection]auth(RequestAuthenticator)",
        "name": "auth",
        "arg_nums": 1,
        "params": [
            {
                "name": "authenticator",
                "type": "RequestAuthenticator"
            }
        ],
        "return_type": "Connection",
        "signature": "@Override public Connection auth(RequestAuthenticator authenticator)",
        "original_string": "    @Override public Connection auth(RequestAuthenticator authenticator) {\n        req.auth(authenticator);\n        return this;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "HttpConnection",
        "class_uri": "src/main/java/org/jsoup/helper/HttpConnection.java.HttpConnection",
        "attributes": {
            "modifiers": "@Override public",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Connection",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/helper/HttpConnection.java.HttpConnection.[Connection]onResponseProgress(Progress<Connection.Response>)",
        "name": "onResponseProgress",
        "arg_nums": 1,
        "params": [
            {
                "name": "handler",
                "type": "Progress<Connection.Response>"
            }
        ],
        "return_type": "Connection",
        "signature": "@Override public Connection onResponseProgress(Progress<Connection.Response> handler)",
        "original_string": "    @Override public Connection onResponseProgress(Progress<Connection.Response> handler) {\n        req.responseProgress = handler;\n        return this;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "HttpConnection",
        "class_uri": "src/main/java/org/jsoup/helper/HttpConnection.java.HttpConnection",
        "attributes": {
            "modifiers": "@Override public",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Connection",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/helper/HttpConnection.java.HttpConnection.[boolean]needsMultipart(Connection.Request)",
        "name": "needsMultipart",
        "arg_nums": 1,
        "params": [
            {
                "name": "req",
                "type": "Connection.Request"
            }
        ],
        "return_type": "boolean",
        "signature": "private static boolean needsMultipart(Connection.Request req)",
        "original_string": "    private static boolean needsMultipart(Connection.Request req) {\n        // multipart mode, for files. add the header if we see something with an inputstream, and return a non-null boundary\n        for (Connection.KeyVal keyVal : req.data()) {\n            if (keyVal.hasInputStream())\n                return true;\n        }\n        return false;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "HttpConnection",
        "class_uri": "src/main/java/org/jsoup/helper/HttpConnection.java.HttpConnection",
        "attributes": {
            "modifiers": "private static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "private",
                "static"
            ],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/select/CombiningEvaluator.java.CombiningEvaluator.[]CombiningEvaluator()",
        "name": "CombiningEvaluator",
        "arg_nums": 0,
        "params": [],
        "return_type": "",
        "signature": "CombiningEvaluator()",
        "original_string": "    CombiningEvaluator() {\n        super();\n        evaluators = new ArrayList<>();\n        sortedEvaluators = new ArrayList<>();\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/select/CombiningEvaluator.java",
        "class_name": "CombiningEvaluator",
        "class_uri": "src/main/java/org/jsoup/select/CombiningEvaluator.java.CombiningEvaluator",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/select/CombiningEvaluator.java.CombiningEvaluator.[]CombiningEvaluator(Collection<Evaluator>)",
        "name": "CombiningEvaluator",
        "arg_nums": 1,
        "params": [
            {
                "name": "evaluators",
                "type": "Collection<Evaluator>"
            }
        ],
        "return_type": "",
        "signature": "CombiningEvaluator(Collection<Evaluator> evaluators)",
        "original_string": "    CombiningEvaluator(Collection<Evaluator> evaluators) {\n        this();\n        this.evaluators.addAll(evaluators);\n        updateEvaluators();\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/select/CombiningEvaluator.java",
        "class_name": "CombiningEvaluator",
        "class_uri": "src/main/java/org/jsoup/select/CombiningEvaluator.java.CombiningEvaluator",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/select/CombiningEvaluator.java.CombiningEvaluator.[void]reset()",
        "name": "reset",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "@Override protected void reset()",
        "original_string": "    @Override protected void reset() {\n        for (Evaluator evaluator : evaluators) {\n            evaluator.reset();\n        }\n        super.reset();\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/select/CombiningEvaluator.java",
        "class_name": "CombiningEvaluator",
        "class_uri": "src/main/java/org/jsoup/select/CombiningEvaluator.java.CombiningEvaluator",
        "attributes": {
            "modifiers": "@Override protected",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "protected"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/select/CombiningEvaluator.java.CombiningEvaluator.[int]cost()",
        "name": "cost",
        "arg_nums": 0,
        "params": [],
        "return_type": "int",
        "signature": "@Override protected int cost()",
        "original_string": "    @Override protected int cost() {\n        return cost;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/select/CombiningEvaluator.java",
        "class_name": "CombiningEvaluator",
        "class_uri": "src/main/java/org/jsoup/select/CombiningEvaluator.java.CombiningEvaluator",
        "attributes": {
            "modifiers": "@Override protected",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "protected"
            ],
            "comments": [],
            "return_type": "int",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/select/CombiningEvaluator.java.CombiningEvaluator.[Evaluator]rightMostEvaluator()",
        "name": "rightMostEvaluator",
        "arg_nums": 0,
        "params": [],
        "return_type": "Evaluator",
        "signature": "@Nullable Evaluator rightMostEvaluator()",
        "original_string": "    @Nullable Evaluator rightMostEvaluator() {\n        return num > 0 ? evaluators.get(num - 1) : null;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/select/CombiningEvaluator.java",
        "class_name": "CombiningEvaluator",
        "class_uri": "src/main/java/org/jsoup/select/CombiningEvaluator.java.CombiningEvaluator",
        "attributes": {
            "modifiers": "@Nullable",
            "marker_annotations": [
                "@Nullable"
            ],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "Evaluator",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/select/CombiningEvaluator.java.CombiningEvaluator.[void]replaceRightMostEvaluator(Evaluator)",
        "name": "replaceRightMostEvaluator",
        "arg_nums": 1,
        "params": [
            {
                "name": "replacement",
                "type": "Evaluator"
            }
        ],
        "return_type": "void",
        "signature": "void replaceRightMostEvaluator(Evaluator replacement)",
        "original_string": "    void replaceRightMostEvaluator(Evaluator replacement) {\n        evaluators.set(num - 1, replacement);\n        updateEvaluators();\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/select/CombiningEvaluator.java",
        "class_name": "CombiningEvaluator",
        "class_uri": "src/main/java/org/jsoup/select/CombiningEvaluator.java.CombiningEvaluator",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/select/CombiningEvaluator.java.CombiningEvaluator.[void]updateEvaluators()",
        "name": "updateEvaluators",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "void updateEvaluators()",
        "original_string": "    void updateEvaluators() {\n        // used so we don't need to bash on size() for every match test\n        num = evaluators.size();\n\n        // sort the evaluators by lowest cost first, to optimize the evaluation order\n        cost = 0;\n        for (Evaluator evaluator : evaluators) {\n            cost += evaluator.cost();\n        }\n        sortedEvaluators.clear();\n        sortedEvaluators.addAll(evaluators);\n        sortedEvaluators.sort(Comparator.comparingInt(Evaluator::cost));\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/select/CombiningEvaluator.java",
        "class_name": "CombiningEvaluator",
        "class_uri": "src/main/java/org/jsoup/select/CombiningEvaluator.java.CombiningEvaluator",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/select/NodeTraversor.java.NodeTraversor.[void]traverse(NodeVisitor,Node)",
        "name": "traverse",
        "arg_nums": 2,
        "params": [
            {
                "name": "visitor",
                "type": "NodeVisitor"
            },
            {
                "name": "root",
                "type": "Node"
            }
        ],
        "return_type": "void",
        "signature": "public static void traverse(NodeVisitor visitor, Node root)",
        "original_string": "    public static void traverse(NodeVisitor visitor, Node root) {\n        Validate.notNull(visitor);\n        Validate.notNull(root);\n        Node node = root;\n        int depth = 0;\n        \n        while (node != null) {\n            Node parent = node.parentNode(); // remember parent to find nodes that get replaced in .head\n            int origSize = parent != null ? parent.childNodeSize() : 0;\n            Node next = node.nextSibling();\n\n            visitor.head(node, depth); // visit current node\n            if (parent != null && !node.hasParent()) { // removed or replaced\n                if (origSize == parent.childNodeSize()) { // replaced\n                    node = parent.childNode(node.siblingIndex()); // replace ditches parent but keeps sibling index\n                } else { // removed\n                    node = next;\n                    if (node == null) { // last one, go up\n                        node = parent;\n                        depth--;\n                    }\n                    continue; // don't tail removed\n                }\n            }\n\n            if (node.childNodeSize() > 0) { // descend\n                node = node.childNode(0);\n                depth++;\n            } else {\n                while (true) {\n                    assert node != null; // as depth > 0, will have parent\n                    if (!(node.nextSibling() == null && depth > 0)) break;\n                    visitor.tail(node, depth); // when no more siblings, ascend\n                    node = node.parentNode();\n                    depth--;\n                }\n                visitor.tail(node, depth);\n                if (node == root)\n                    break;\n                node = node.nextSibling();\n            }\n        }\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/select/NodeTraversor.java",
        "class_name": "NodeTraversor",
        "class_uri": "src/main/java/org/jsoup/select/NodeTraversor.java.NodeTraversor",
        "attributes": {
            "modifiers": "public static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public",
                "static"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": "\nRun a depth-first traverse of the root and all of its descendants.\n@param visitor Node visitor.\n@param root the initial node point to traverse.\n@see NodeVisitor\n"
    },
    {
        "uris": "src/main/java/org/jsoup/select/NodeTraversor.java.NodeTraversor.[void]traverse(NodeVisitor,Elements)",
        "name": "traverse",
        "arg_nums": 2,
        "params": [
            {
                "name": "visitor",
                "type": "NodeVisitor"
            },
            {
                "name": "elements",
                "type": "Elements"
            }
        ],
        "return_type": "void",
        "signature": "public static void traverse(NodeVisitor visitor, Elements elements)",
        "original_string": "    public static void traverse(NodeVisitor visitor, Elements elements) {\n        Validate.notNull(visitor);\n        Validate.notNull(elements);\n        for (Element el : elements)\n            traverse(visitor, el);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/select/NodeTraversor.java",
        "class_name": "NodeTraversor",
        "class_uri": "src/main/java/org/jsoup/select/NodeTraversor.java.NodeTraversor",
        "attributes": {
            "modifiers": "public static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public",
                "static"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": "\nRun a depth-first traversal of each Element.\n@param visitor Node visitor.\n@param elements Elements to traverse.\n"
    },
    {
        "uris": "src/main/java/org/jsoup/select/NodeTraversor.java.NodeTraversor.[FilterResult]filter(NodeFilter,Node)",
        "name": "filter",
        "arg_nums": 2,
        "params": [
            {
                "name": "filter",
                "type": "NodeFilter"
            },
            {
                "name": "root",
                "type": "Node"
            }
        ],
        "return_type": "FilterResult",
        "signature": "public static FilterResult filter(NodeFilter filter, Node root)",
        "original_string": "    public static FilterResult filter(NodeFilter filter, Node root) {\n        Node node = root;\n        int depth = 0;\n\n        while (node != null) {\n            FilterResult result = filter.head(node, depth);\n            if (result == FilterResult.STOP)\n                return result;\n            // Descend into child nodes:\n            if (result == FilterResult.CONTINUE && node.childNodeSize() > 0) {\n                node = node.childNode(0);\n                ++depth;\n                continue;\n            }\n            // No siblings, move upwards:\n            while (true) {\n                assert node != null; // depth > 0, so has parent\n                if (!(node.nextSibling() == null && depth > 0)) break;\n                // 'tail' current node:\n                if (result == FilterResult.CONTINUE || result == FilterResult.SKIP_CHILDREN) {\n                    result = filter.tail(node, depth);\n                    if (result == FilterResult.STOP)\n                        return result;\n                }\n                Node prev = node; // In case we need to remove it below.\n                node = node.parentNode();\n                depth--;\n                if (result == FilterResult.REMOVE)\n                    prev.remove(); // Remove AFTER finding parent.\n                result = FilterResult.CONTINUE; // Parent was not pruned.\n            }\n            // 'tail' current node, then proceed with siblings:\n            if (result == FilterResult.CONTINUE || result == FilterResult.SKIP_CHILDREN) {\n                result = filter.tail(node, depth);\n                if (result == FilterResult.STOP)\n                    return result;\n            }\n            if (node == root)\n                return result;\n            Node prev = node; // In case we need to remove it below.\n            node = node.nextSibling();\n            if (result == FilterResult.REMOVE)\n                prev.remove(); // Remove AFTER finding sibling.\n        }\n        // root == null?\n        return FilterResult.CONTINUE;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/select/NodeTraversor.java",
        "class_name": "NodeTraversor",
        "class_uri": "src/main/java/org/jsoup/select/NodeTraversor.java.NodeTraversor",
        "attributes": {
            "modifiers": "public static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public",
                "static"
            ],
            "comments": [],
            "return_type": "FilterResult",
            "classes": []
        },
        "docstring": "\nRun a depth-first filtered traversal of the root and all of its descendants.\n@param filter NodeFilter visitor.\n@param root the root node point to traverse.\n@return The filter result of the root node, or {@link FilterResult#STOP}.\n\n@see NodeFilter\n"
    },
    {
        "uris": "src/main/java/org/jsoup/select/NodeTraversor.java.NodeTraversor.[void]filter(NodeFilter,Elements)",
        "name": "filter",
        "arg_nums": 2,
        "params": [
            {
                "name": "filter",
                "type": "NodeFilter"
            },
            {
                "name": "elements",
                "type": "Elements"
            }
        ],
        "return_type": "void",
        "signature": "public static void filter(NodeFilter filter, Elements elements)",
        "original_string": "    public static void filter(NodeFilter filter, Elements elements) {\n        Validate.notNull(filter);\n        Validate.notNull(elements);\n        for (Element el : elements)\n            if (filter(filter, el) == FilterResult.STOP)\n                break;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/select/NodeTraversor.java",
        "class_name": "NodeTraversor",
        "class_uri": "src/main/java/org/jsoup/select/NodeTraversor.java.NodeTraversor",
        "attributes": {
            "modifiers": "public static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public",
                "static"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": "\nRun a depth-first filtered traversal of each Element.\n@param filter NodeFilter visitor.\n@see NodeFilter\n"
    },
    {
        "uris": "src/main/java/org/jsoup/select/Elements.java.Elements.[]Elements()",
        "name": "Elements",
        "arg_nums": 0,
        "params": [],
        "return_type": "",
        "signature": "public Elements()",
        "original_string": "    public Elements() {\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/select/Elements.java",
        "class_name": "Elements",
        "class_uri": "src/main/java/org/jsoup/select/Elements.java.Elements",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/select/Elements.java.Elements.[]Elements(int)",
        "name": "Elements",
        "arg_nums": 1,
        "params": [
            {
                "name": "initialCapacity",
                "type": "int"
            }
        ],
        "return_type": "",
        "signature": "public Elements(int initialCapacity)",
        "original_string": "    public Elements(int initialCapacity) {\n        super(initialCapacity);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/select/Elements.java",
        "class_name": "Elements",
        "class_uri": "src/main/java/org/jsoup/select/Elements.java.Elements",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/select/Elements.java.Elements.[]Elements(Collection<Element>)",
        "name": "Elements",
        "arg_nums": 1,
        "params": [
            {
                "name": "elements",
                "type": "Collection<Element>"
            }
        ],
        "return_type": "",
        "signature": "public Elements(Collection<Element> elements)",
        "original_string": "    public Elements(Collection<Element> elements) {\n        super(elements);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/select/Elements.java",
        "class_name": "Elements",
        "class_uri": "src/main/java/org/jsoup/select/Elements.java.Elements",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/select/Elements.java.Elements.[]Elements(List<Element>)",
        "name": "Elements",
        "arg_nums": 1,
        "params": [
            {
                "name": "elements",
                "type": "List<Element>"
            }
        ],
        "return_type": "",
        "signature": "public Elements(List<Element> elements)",
        "original_string": "    public Elements(List<Element> elements) {\n        super(elements);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/select/Elements.java",
        "class_name": "Elements",
        "class_uri": "src/main/java/org/jsoup/select/Elements.java.Elements",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/select/Elements.java.Elements.[]Elements()",
        "name": "Elements",
        "arg_nums": 0,
        "params": [],
        "return_type": "",
        "signature": "public Elements(Element... elements)",
        "original_string": "    public Elements(Element... elements) {\n    \tsuper(Arrays.asList(elements));\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/select/Elements.java",
        "class_name": "Elements",
        "class_uri": "src/main/java/org/jsoup/select/Elements.java.Elements",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/select/Elements.java.Elements.[Elements]clone()",
        "name": "clone",
        "arg_nums": 0,
        "params": [],
        "return_type": "Elements",
        "signature": "@Override\n\tpublic Elements clone()",
        "original_string": "    @Override\n\tpublic Elements clone() {\n        Elements clone = new Elements(size());\n\n        for(Element e : this)\n    \t\tclone.add(e.clone());\n    \t\n    \treturn clone;\n\t}",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/select/Elements.java",
        "class_name": "Elements",
        "class_uri": "src/main/java/org/jsoup/select/Elements.java.Elements",
        "attributes": {
            "modifiers": "@Override\n\tpublic",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Elements",
            "classes": []
        },
        "docstring": "\nCreates a deep copy of these elements.\n@return a deep copy\n"
    },
    {
        "uris": "src/main/java/org/jsoup/select/Elements.java.Elements.[String]attr(String)",
        "name": "attr",
        "arg_nums": 1,
        "params": [
            {
                "name": "attributeKey",
                "type": "String"
            }
        ],
        "return_type": "String",
        "signature": "public String attr(String attributeKey)",
        "original_string": "    public String attr(String attributeKey) {\n        for (Element element : this) {\n            if (element.hasAttr(attributeKey))\n                return element.attr(attributeKey);\n        }\n        return \"\";\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/select/Elements.java",
        "class_name": "Elements",
        "class_uri": "src/main/java/org/jsoup/select/Elements.java.Elements",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": "\nGet an attribute value from the first matched element that has the attribute.\n@param attributeKey The attribute key.\n@return The attribute value from the first matched element that has the attribute. If no elements were matched (isEmpty() == true),\nor if the no elements have the attribute, returns empty string.\n@see #hasAttr(String)\n"
    },
    {
        "uris": "src/main/java/org/jsoup/select/Elements.java.Elements.[boolean]hasAttr(String)",
        "name": "hasAttr",
        "arg_nums": 1,
        "params": [
            {
                "name": "attributeKey",
                "type": "String"
            }
        ],
        "return_type": "boolean",
        "signature": "public boolean hasAttr(String attributeKey)",
        "original_string": "    public boolean hasAttr(String attributeKey) {\n        for (Element element : this) {\n            if (element.hasAttr(attributeKey))\n                return true;\n        }\n        return false;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/select/Elements.java",
        "class_name": "Elements",
        "class_uri": "src/main/java/org/jsoup/select/Elements.java.Elements",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": "\nChecks if any of the matched elements have this attribute defined.\n@param attributeKey attribute key\n@return true if any of the elements have the attribute; false if none do.\n"
    },
    {
        "uris": "src/main/java/org/jsoup/select/Elements.java.Elements.[List<String>]eachAttr(String)",
        "name": "eachAttr",
        "arg_nums": 1,
        "params": [
            {
                "name": "attributeKey",
                "type": "String"
            }
        ],
        "return_type": "List<String>",
        "signature": "public List<String> eachAttr(String attributeKey)",
        "original_string": "    public List<String> eachAttr(String attributeKey) {\n        List<String> attrs = new ArrayList<>(size());\n        for (Element element : this) {\n            if (element.hasAttr(attributeKey))\n                attrs.add(element.attr(attributeKey));\n        }\n        return attrs;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/select/Elements.java",
        "class_name": "Elements",
        "class_uri": "src/main/java/org/jsoup/select/Elements.java.Elements",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "List<String>",
            "classes": []
        },
        "docstring": "\nGet the attribute value for each of the matched elements. If an element does not have this attribute, no value is\nincluded in the result set for that element.\n@param attributeKey the attribute name to return values for. You can add the {@code abs:} prefix to the key to\nget absolute URLs from relative URLs, e.g.: {@code doc.select(\"a\").eachAttr(\"abs:href\")} .\n@return a list of each element's attribute value for the attribute\n"
    },
    {
        "uris": "src/main/java/org/jsoup/select/Elements.java.Elements.[Elements]attr(String,String)",
        "name": "attr",
        "arg_nums": 2,
        "params": [
            {
                "name": "attributeKey",
                "type": "String"
            },
            {
                "name": "attributeValue",
                "type": "String"
            }
        ],
        "return_type": "Elements",
        "signature": "public Elements attr(String attributeKey, String attributeValue)",
        "original_string": "    public Elements attr(String attributeKey, String attributeValue) {\n        for (Element element : this) {\n            element.attr(attributeKey, attributeValue);\n        }\n        return this;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/select/Elements.java",
        "class_name": "Elements",
        "class_uri": "src/main/java/org/jsoup/select/Elements.java.Elements",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Elements",
            "classes": []
        },
        "docstring": "\nSet an attribute on all matched elements.\n@param attributeKey attribute key\n@param attributeValue attribute value\n@return this\n"
    },
    {
        "uris": "src/main/java/org/jsoup/select/Elements.java.Elements.[Elements]removeAttr(String)",
        "name": "removeAttr",
        "arg_nums": 1,
        "params": [
            {
                "name": "attributeKey",
                "type": "String"
            }
        ],
        "return_type": "Elements",
        "signature": "public Elements removeAttr(String attributeKey)",
        "original_string": "    public Elements removeAttr(String attributeKey) {\n        for (Element element : this) {\n            element.removeAttr(attributeKey);\n        }\n        return this;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/select/Elements.java",
        "class_name": "Elements",
        "class_uri": "src/main/java/org/jsoup/select/Elements.java.Elements",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Elements",
            "classes": []
        },
        "docstring": "\nRemove an attribute from every matched element.\n@param attributeKey The attribute to remove.\n@return this (for chaining)\n"
    },
    {
        "uris": "src/main/java/org/jsoup/select/Elements.java.Elements.[Elements]addClass(String)",
        "name": "addClass",
        "arg_nums": 1,
        "params": [
            {
                "name": "className",
                "type": "String"
            }
        ],
        "return_type": "Elements",
        "signature": "public Elements addClass(String className)",
        "original_string": "    public Elements addClass(String className) {\n        for (Element element : this) {\n            element.addClass(className);\n        }\n        return this;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/select/Elements.java",
        "class_name": "Elements",
        "class_uri": "src/main/java/org/jsoup/select/Elements.java.Elements",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Elements",
            "classes": []
        },
        "docstring": "\nAdd the class name to every matched element's {@code class} attribute.\n@param className class name to add\n@return this\n"
    },
    {
        "uris": "src/main/java/org/jsoup/select/Elements.java.Elements.[Elements]removeClass(String)",
        "name": "removeClass",
        "arg_nums": 1,
        "params": [
            {
                "name": "className",
                "type": "String"
            }
        ],
        "return_type": "Elements",
        "signature": "public Elements removeClass(String className)",
        "original_string": "    public Elements removeClass(String className) {\n        for (Element element : this) {\n            element.removeClass(className);\n        }\n        return this;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/select/Elements.java",
        "class_name": "Elements",
        "class_uri": "src/main/java/org/jsoup/select/Elements.java.Elements",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Elements",
            "classes": []
        },
        "docstring": "\nRemove the class name from every matched element's {@code class} attribute, if present.\n@param className class name to remove\n@return this\n"
    },
    {
        "uris": "src/main/java/org/jsoup/select/Elements.java.Elements.[Elements]toggleClass(String)",
        "name": "toggleClass",
        "arg_nums": 1,
        "params": [
            {
                "name": "className",
                "type": "String"
            }
        ],
        "return_type": "Elements",
        "signature": "public Elements toggleClass(String className)",
        "original_string": "    public Elements toggleClass(String className) {\n        for (Element element : this) {\n            element.toggleClass(className);\n        }\n        return this;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/select/Elements.java",
        "class_name": "Elements",
        "class_uri": "src/main/java/org/jsoup/select/Elements.java.Elements",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Elements",
            "classes": []
        },
        "docstring": "\nToggle the class name on every matched element's {@code class} attribute.\n@param className class name to add if missing, or remove if present, from every element.\n@return this\n"
    },
    {
        "uris": "src/main/java/org/jsoup/select/Elements.java.Elements.[boolean]hasClass(String)",
        "name": "hasClass",
        "arg_nums": 1,
        "params": [
            {
                "name": "className",
                "type": "String"
            }
        ],
        "return_type": "boolean",
        "signature": "public boolean hasClass(String className)",
        "original_string": "    public boolean hasClass(String className) {\n        for (Element element : this) {\n            if (element.hasClass(className))\n                return true;\n        }\n        return false;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/select/Elements.java",
        "class_name": "Elements",
        "class_uri": "src/main/java/org/jsoup/select/Elements.java.Elements",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": "\nDetermine if any of the matched elements have this class name set in their {@code class} attribute.\n@param className class name to check for\n@return true if any do, false if none do\n"
    },
    {
        "uris": "src/main/java/org/jsoup/select/Elements.java.Elements.[String]val()",
        "name": "val",
        "arg_nums": 0,
        "params": [],
        "return_type": "String",
        "signature": "public String val()",
        "original_string": "    public String val() {\n        if (size() > 0)\n            //noinspection ConstantConditions\n            return first().val(); // first() != null as size() > 0\n        else\n            return \"\";\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/select/Elements.java",
        "class_name": "Elements",
        "class_uri": "src/main/java/org/jsoup/select/Elements.java.Elements",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": "\nGet the form element's value of the first matched element.\n@return The form element's value, or empty if not set.\n@see Element#val()\n"
    },
    {
        "uris": "src/main/java/org/jsoup/select/Elements.java.Elements.[Elements]val(String)",
        "name": "val",
        "arg_nums": 1,
        "params": [
            {
                "name": "value",
                "type": "String"
            }
        ],
        "return_type": "Elements",
        "signature": "public Elements val(String value)",
        "original_string": "    public Elements val(String value) {\n        for (Element element : this)\n            element.val(value);\n        return this;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/select/Elements.java",
        "class_name": "Elements",
        "class_uri": "src/main/java/org/jsoup/select/Elements.java.Elements",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Elements",
            "classes": []
        },
        "docstring": "\nSet the form element's value in each of the matched elements.\n@param value The value to set into each matched element\n@return this (for chaining)\n"
    },
    {
        "uris": "src/main/java/org/jsoup/select/Elements.java.Elements.[String]text()",
        "name": "text",
        "arg_nums": 0,
        "params": [],
        "return_type": "String",
        "signature": "public String text()",
        "original_string": "    public String text() {\n        return stream()\n            .map(Element::text)\n            .collect(StringUtil.joining(\" \"));\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/select/Elements.java",
        "class_name": "Elements",
        "class_uri": "src/main/java/org/jsoup/select/Elements.java.Elements",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": "\nGet the combined text of all the matched elements.\n<p>\nNote that it is possible to get repeats if the matched elements contain both parent elements and their own\nchildren, as the Element.text() method returns the combined text of a parent and all its children.\n@return string of all text: unescaped and no HTML.\n@see Element#text()\n@see #eachText()\n"
    },
    {
        "uris": "src/main/java/org/jsoup/select/Elements.java.Elements.[boolean]hasText()",
        "name": "hasText",
        "arg_nums": 0,
        "params": [],
        "return_type": "boolean",
        "signature": "public boolean hasText()",
        "original_string": "    public boolean hasText() {\n        for (Element element: this) {\n            if (element.hasText())\n                return true;\n        }\n        return false;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/select/Elements.java",
        "class_name": "Elements",
        "class_uri": "src/main/java/org/jsoup/select/Elements.java.Elements",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": "\nTest if any matched Element has any text content, that is not just whitespace.\n@return true if any element has non-blank text content.\n@see Element#hasText()\n"
    },
    {
        "uris": "src/main/java/org/jsoup/select/Elements.java.Elements.[List<String>]eachText()",
        "name": "eachText",
        "arg_nums": 0,
        "params": [],
        "return_type": "List<String>",
        "signature": "public List<String> eachText()",
        "original_string": "    public List<String> eachText() {\n        ArrayList<String> texts = new ArrayList<>(size());\n        for (Element el: this) {\n            if (el.hasText())\n                texts.add(el.text());\n        }\n        return texts;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/select/Elements.java",
        "class_name": "Elements",
        "class_uri": "src/main/java/org/jsoup/select/Elements.java.Elements",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "List<String>",
            "classes": []
        },
        "docstring": "\nGet the text content of each of the matched elements. If an element has no text, then it is not included in the\nresult.\n@return A list of each matched element's text content.\n@see Element#text()\n@see Element#hasText()\n@see #text()\n"
    },
    {
        "uris": "src/main/java/org/jsoup/select/Elements.java.Elements.[String]html()",
        "name": "html",
        "arg_nums": 0,
        "params": [],
        "return_type": "String",
        "signature": "public String html()",
        "original_string": "    public String html() {\n        return stream()\n            .map(Element::html)\n            .collect(StringUtil.joining(\"\\n\"));\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/select/Elements.java",
        "class_name": "Elements",
        "class_uri": "src/main/java/org/jsoup/select/Elements.java.Elements",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": "\nGet the combined inner HTML of all matched elements.\n@return string of all element's inner HTML.\n@see #text()\n@see #outerHtml()\n"
    },
    {
        "uris": "src/main/java/org/jsoup/select/Elements.java.Elements.[String]outerHtml()",
        "name": "outerHtml",
        "arg_nums": 0,
        "params": [],
        "return_type": "String",
        "signature": "public String outerHtml()",
        "original_string": "    public String outerHtml() {\n        return stream()\n            .map(Element::outerHtml)\n            .collect(StringUtil.joining(\"\\n\"));\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/select/Elements.java",
        "class_name": "Elements",
        "class_uri": "src/main/java/org/jsoup/select/Elements.java.Elements",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": "\nGet the combined outer HTML of all matched elements.\n@return string of all element's outer HTML.\n@see #text()\n@see #html()\n"
    },
    {
        "uris": "src/main/java/org/jsoup/select/Elements.java.Elements.[String]toString()",
        "name": "toString",
        "arg_nums": 0,
        "params": [],
        "return_type": "String",
        "signature": "@Override\n    public String toString()",
        "original_string": "    @Override\n    public String toString() {\n        return outerHtml();\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/select/Elements.java",
        "class_name": "Elements",
        "class_uri": "src/main/java/org/jsoup/select/Elements.java.Elements",
        "attributes": {
            "modifiers": "@Override\n    public",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": "\nGet the combined outer HTML of all matched elements. Alias of {@link #outerHtml()}.\n@return string of all element's outer HTML.\n@see #text()\n@see #html()\n"
    },
    {
        "uris": "src/main/java/org/jsoup/select/Elements.java.Elements.[Elements]tagName(String)",
        "name": "tagName",
        "arg_nums": 1,
        "params": [
            {
                "name": "tagName",
                "type": "String"
            }
        ],
        "return_type": "Elements",
        "signature": "public Elements tagName(String tagName)",
        "original_string": "    public Elements tagName(String tagName) {\n        for (Element element : this) {\n            element.tagName(tagName);\n        }\n        return this;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/select/Elements.java",
        "class_name": "Elements",
        "class_uri": "src/main/java/org/jsoup/select/Elements.java.Elements",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Elements",
            "classes": []
        },
        "docstring": "\nUpdate (rename) the tag name of each matched element. For example, to change each {@code <i>} to a {@code <em>}, do\n{@code doc.select(\"i\").tagName(\"em\");}\n\n@param tagName the new tag name\n@return this, for chaining\n@see Element#tagName(String)\n"
    },
    {
        "uris": "src/main/java/org/jsoup/select/Elements.java.Elements.[Elements]html(String)",
        "name": "html",
        "arg_nums": 1,
        "params": [
            {
                "name": "html",
                "type": "String"
            }
        ],
        "return_type": "Elements",
        "signature": "public Elements html(String html)",
        "original_string": "    public Elements html(String html) {\n        for (Element element : this) {\n            element.html(html);\n        }\n        return this;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/select/Elements.java",
        "class_name": "Elements",
        "class_uri": "src/main/java/org/jsoup/select/Elements.java.Elements",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Elements",
            "classes": []
        },
        "docstring": "\nSet the inner HTML of each matched element.\n@param html HTML to parse and set into each matched element.\n@return this, for chaining\n@see Element#html(String)\n"
    },
    {
        "uris": "src/main/java/org/jsoup/select/Elements.java.Elements.[Elements]prepend(String)",
        "name": "prepend",
        "arg_nums": 1,
        "params": [
            {
                "name": "html",
                "type": "String"
            }
        ],
        "return_type": "Elements",
        "signature": "public Elements prepend(String html)",
        "original_string": "    public Elements prepend(String html) {\n        for (Element element : this) {\n            element.prepend(html);\n        }\n        return this;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/select/Elements.java",
        "class_name": "Elements",
        "class_uri": "src/main/java/org/jsoup/select/Elements.java.Elements",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Elements",
            "classes": []
        },
        "docstring": "\nAdd the supplied HTML to the start of each matched element's inner HTML.\n@param html HTML to add inside each element, before the existing HTML\n@return this, for chaining\n@see Element#prepend(String)\n"
    },
    {
        "uris": "src/main/java/org/jsoup/select/Elements.java.Elements.[Elements]append(String)",
        "name": "append",
        "arg_nums": 1,
        "params": [
            {
                "name": "html",
                "type": "String"
            }
        ],
        "return_type": "Elements",
        "signature": "public Elements append(String html)",
        "original_string": "    public Elements append(String html) {\n        for (Element element : this) {\n            element.append(html);\n        }\n        return this;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/select/Elements.java",
        "class_name": "Elements",
        "class_uri": "src/main/java/org/jsoup/select/Elements.java.Elements",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Elements",
            "classes": []
        },
        "docstring": "\nAdd the supplied HTML to the end of each matched element's inner HTML.\n@param html HTML to add inside each element, after the existing HTML\n@return this, for chaining\n@see Element#append(String)\n"
    },
    {
        "uris": "src/main/java/org/jsoup/select/Elements.java.Elements.[Elements]before(String)",
        "name": "before",
        "arg_nums": 1,
        "params": [
            {
                "name": "html",
                "type": "String"
            }
        ],
        "return_type": "Elements",
        "signature": "public Elements before(String html)",
        "original_string": "    public Elements before(String html) {\n        for (Element element : this) {\n            element.before(html);\n        }\n        return this;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/select/Elements.java",
        "class_name": "Elements",
        "class_uri": "src/main/java/org/jsoup/select/Elements.java.Elements",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Elements",
            "classes": []
        },
        "docstring": "\nInsert the supplied HTML before each matched element's outer HTML.\n@param html HTML to insert before each element\n@return this, for chaining\n@see Element#before(String)\n"
    },
    {
        "uris": "src/main/java/org/jsoup/select/Elements.java.Elements.[Elements]after(String)",
        "name": "after",
        "arg_nums": 1,
        "params": [
            {
                "name": "html",
                "type": "String"
            }
        ],
        "return_type": "Elements",
        "signature": "public Elements after(String html)",
        "original_string": "    public Elements after(String html) {\n        for (Element element : this) {\n            element.after(html);\n        }\n        return this;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/select/Elements.java",
        "class_name": "Elements",
        "class_uri": "src/main/java/org/jsoup/select/Elements.java.Elements",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Elements",
            "classes": []
        },
        "docstring": "\nInsert the supplied HTML after each matched element's outer HTML.\n@param html HTML to insert after each element\n@return this, for chaining\n@see Element#after(String)\n"
    },
    {
        "uris": "src/main/java/org/jsoup/select/Elements.java.Elements.[Elements]wrap(String)",
        "name": "wrap",
        "arg_nums": 1,
        "params": [
            {
                "name": "html",
                "type": "String"
            }
        ],
        "return_type": "Elements",
        "signature": "public Elements wrap(String html)",
        "original_string": "    public Elements wrap(String html) {\n        Validate.notEmpty(html);\n        for (Element element : this) {\n            element.wrap(html);\n        }\n        return this;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/select/Elements.java",
        "class_name": "Elements",
        "class_uri": "src/main/java/org/jsoup/select/Elements.java.Elements",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Elements",
            "classes": []
        },
        "docstring": "\nWrap the supplied HTML around each matched elements. For example, with HTML\n{@code <p><b>This</b> is <b>Jsoup</b></p>},\n<code>doc.select(\"b\").wrap(\"&lt;i&gt;&lt;/i&gt;\");</code>\nbecomes {@code <p><i><b>This</b></i> is <i><b>jsoup</b></i></p>}\n@param html HTML to wrap around each element, e.g. {@code <div class=\"head\"></div>}. Can be arbitrarily deep.\n@return this (for chaining)\n@see Element#wrap\n"
    },
    {
        "uris": "src/main/java/org/jsoup/select/Elements.java.Elements.[Elements]unwrap()",
        "name": "unwrap",
        "arg_nums": 0,
        "params": [],
        "return_type": "Elements",
        "signature": "public Elements unwrap()",
        "original_string": "    public Elements unwrap() {\n        for (Element element : this) {\n            element.unwrap();\n        }\n        return this;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/select/Elements.java",
        "class_name": "Elements",
        "class_uri": "src/main/java/org/jsoup/select/Elements.java.Elements",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Elements",
            "classes": []
        },
        "docstring": "\nRemoves the matched elements from the DOM, and moves their children up into their parents. This has the effect of\ndropping the elements but keeping their children.\n<p>\nThis is useful for e.g removing unwanted formatting elements but keeping their contents.\n</p>\n\nE.g. with HTML: <p>{@code <div><font>One</font> <font><a href=\"/\">Two</a></font></div>}</p>\n<p>{@code doc.select(\"font\").unwrap();}</p>\n<p>HTML = {@code <div>One <a href=\"/\">Two</a></div>}</p>\n\n@return this (for chaining)\n@see Node#unwrap\n"
    },
    {
        "uris": "src/main/java/org/jsoup/select/Elements.java.Elements.[Elements]empty()",
        "name": "empty",
        "arg_nums": 0,
        "params": [],
        "return_type": "Elements",
        "signature": "public Elements empty()",
        "original_string": "    public Elements empty() {\n        for (Element element : this) {\n            element.empty();\n        }\n        return this;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/select/Elements.java",
        "class_name": "Elements",
        "class_uri": "src/main/java/org/jsoup/select/Elements.java.Elements",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Elements",
            "classes": []
        },
        "docstring": "\nEmpty (remove all child nodes from) each matched element. This is similar to setting the inner HTML of each\nelement to nothing.\n<p>\nE.g. HTML: {@code <div><p>Hello <b>there</b></p> <p>now</p></div>}<br>\n<code>doc.select(\"p\").empty();</code><br>\nHTML = {@code <div><p></p> <p></p></div>}\n@return this, for chaining\n@see Element#empty()\n@see #remove()\n"
    },
    {
        "uris": "src/main/java/org/jsoup/select/Elements.java.Elements.[Elements]remove()",
        "name": "remove",
        "arg_nums": 0,
        "params": [],
        "return_type": "Elements",
        "signature": "public Elements remove()",
        "original_string": "    public Elements remove() {\n        for (Element element : this) {\n            element.remove();\n        }\n        return this;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/select/Elements.java",
        "class_name": "Elements",
        "class_uri": "src/main/java/org/jsoup/select/Elements.java.Elements",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Elements",
            "classes": []
        },
        "docstring": "\nRemove each matched element from the DOM. This is similar to setting the outer HTML of each element to nothing.\n<p>The elements will still be retained in this list, in case further processing of them is desired.</p>\n<p>\nE.g. HTML: {@code <div><p>Hello</p> <p>there</p> <img /></div>}<br>\n<code>doc.select(\"p\").remove();</code><br>\nHTML = {@code <div> <img /></div>}\n<p>\nNote that this method should not be used to clean user-submitted HTML; rather, use {@link org.jsoup.safety.Cleaner} to clean HTML.\n@return this, for chaining\n@see Element#empty()\n@see #empty()\n@see #clear()\n"
    },
    {
        "uris": "src/main/java/org/jsoup/select/Elements.java.Elements.[Elements]select(String)",
        "name": "select",
        "arg_nums": 1,
        "params": [
            {
                "name": "query",
                "type": "String"
            }
        ],
        "return_type": "Elements",
        "signature": "public Elements select(String query)",
        "original_string": "    public Elements select(String query) {\n        return Selector.select(query, this);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/select/Elements.java",
        "class_name": "Elements",
        "class_uri": "src/main/java/org/jsoup/select/Elements.java.Elements",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Elements",
            "classes": []
        },
        "docstring": "\nFind matching elements within this element list.\n@param query A {@link Selector} query\n@return the filtered list of elements, or an empty list if none match.\n"
    },
    {
        "uris": "src/main/java/org/jsoup/select/Elements.java.Elements.[Elements]not(String)",
        "name": "not",
        "arg_nums": 1,
        "params": [
            {
                "name": "query",
                "type": "String"
            }
        ],
        "return_type": "Elements",
        "signature": "public Elements not(String query)",
        "original_string": "    public Elements not(String query) {\n        Elements out = Selector.select(query, this);\n        return Selector.filterOut(this, out);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/select/Elements.java",
        "class_name": "Elements",
        "class_uri": "src/main/java/org/jsoup/select/Elements.java.Elements",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Elements",
            "classes": []
        },
        "docstring": "\nRemove elements from this list that match the {@link Selector} query.\n<p>\nE.g. HTML: {@code <div class=logo>One</div> <div>Two</div>}<br>\n<code>Elements divs = doc.select(\"div\").not(\".logo\");</code><br>\nResult: {@code divs: [<div>Two</div>]}\n<p>\n@param query the selector query whose results should be removed from these elements\n@return a new elements list that contains only the filtered results\n"
    },
    {
        "uris": "src/main/java/org/jsoup/select/Elements.java.Elements.[Elements]eq(int)",
        "name": "eq",
        "arg_nums": 1,
        "params": [
            {
                "name": "index",
                "type": "int"
            }
        ],
        "return_type": "Elements",
        "signature": "public Elements eq(int index)",
        "original_string": "    public Elements eq(int index) {\n        return size() > index ? new Elements(get(index)) : new Elements();\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/select/Elements.java",
        "class_name": "Elements",
        "class_uri": "src/main/java/org/jsoup/select/Elements.java.Elements",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Elements",
            "classes": []
        },
        "docstring": "\nGet the <i>nth</i> matched element as an Elements object.\n<p>\nSee also {@link #get(int)} to retrieve an Element.\n@param index the (zero-based) index of the element in the list to retain\n@return Elements containing only the specified element, or, if that element did not exist, an empty list.\n"
    },
    {
        "uris": "src/main/java/org/jsoup/select/Elements.java.Elements.[boolean]is(String)",
        "name": "is",
        "arg_nums": 1,
        "params": [
            {
                "name": "query",
                "type": "String"
            }
        ],
        "return_type": "boolean",
        "signature": "public boolean is(String query)",
        "original_string": "    public boolean is(String query) {\n        Evaluator eval = QueryParser.parse(query);\n        for (Element e : this) {\n            if (e.is(eval))\n                return true;\n        }\n        return false;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/select/Elements.java",
        "class_name": "Elements",
        "class_uri": "src/main/java/org/jsoup/select/Elements.java.Elements",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": "\nTest if any of the matched elements match the supplied query.\n@param query A selector\n@return true if at least one element in the list matches the query.\n"
    },
    {
        "uris": "src/main/java/org/jsoup/select/Elements.java.Elements.[Elements]next()",
        "name": "next",
        "arg_nums": 0,
        "params": [],
        "return_type": "Elements",
        "signature": "public Elements next()",
        "original_string": "    public Elements next() {\n        return siblings(null, true, false);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/select/Elements.java",
        "class_name": "Elements",
        "class_uri": "src/main/java/org/jsoup/select/Elements.java.Elements",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Elements",
            "classes": []
        },
        "docstring": "\nGet the immediate next element sibling of each element in this list.\n@return next element siblings.\n"
    },
    {
        "uris": "src/main/java/org/jsoup/select/Elements.java.Elements.[Elements]next(String)",
        "name": "next",
        "arg_nums": 1,
        "params": [
            {
                "name": "query",
                "type": "String"
            }
        ],
        "return_type": "Elements",
        "signature": "public Elements next(String query)",
        "original_string": "    public Elements next(String query) {\n        return siblings(query, true, false);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/select/Elements.java",
        "class_name": "Elements",
        "class_uri": "src/main/java/org/jsoup/select/Elements.java.Elements",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Elements",
            "classes": []
        },
        "docstring": "\nGet the immediate next element sibling of each element in this list, filtered by the query.\n@param query CSS query to match siblings against\n@return next element siblings.\n"
    },
    {
        "uris": "src/main/java/org/jsoup/select/Elements.java.Elements.[Elements]nextAll()",
        "name": "nextAll",
        "arg_nums": 0,
        "params": [],
        "return_type": "Elements",
        "signature": "public Elements nextAll()",
        "original_string": "    public Elements nextAll() {\n        return siblings(null, true, true);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/select/Elements.java",
        "class_name": "Elements",
        "class_uri": "src/main/java/org/jsoup/select/Elements.java.Elements",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Elements",
            "classes": []
        },
        "docstring": "\nGet each of the following element siblings of each element in this list.\n@return all following element siblings.\n"
    },
    {
        "uris": "src/main/java/org/jsoup/select/Elements.java.Elements.[Elements]nextAll(String)",
        "name": "nextAll",
        "arg_nums": 1,
        "params": [
            {
                "name": "query",
                "type": "String"
            }
        ],
        "return_type": "Elements",
        "signature": "public Elements nextAll(String query)",
        "original_string": "    public Elements nextAll(String query) {\n        return siblings(query, true, true);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/select/Elements.java",
        "class_name": "Elements",
        "class_uri": "src/main/java/org/jsoup/select/Elements.java.Elements",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Elements",
            "classes": []
        },
        "docstring": "\nGet each of the following element siblings of each element in this list, that match the query.\n@param query CSS query to match siblings against\n@return all following element siblings.\n"
    },
    {
        "uris": "src/main/java/org/jsoup/select/Elements.java.Elements.[Elements]prev()",
        "name": "prev",
        "arg_nums": 0,
        "params": [],
        "return_type": "Elements",
        "signature": "public Elements prev()",
        "original_string": "    public Elements prev() {\n        return siblings(null, false, false);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/select/Elements.java",
        "class_name": "Elements",
        "class_uri": "src/main/java/org/jsoup/select/Elements.java.Elements",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Elements",
            "classes": []
        },
        "docstring": "\nGet the immediate previous element sibling of each element in this list.\n@return previous element siblings.\n"
    },
    {
        "uris": "src/main/java/org/jsoup/select/Elements.java.Elements.[Elements]prev(String)",
        "name": "prev",
        "arg_nums": 1,
        "params": [
            {
                "name": "query",
                "type": "String"
            }
        ],
        "return_type": "Elements",
        "signature": "public Elements prev(String query)",
        "original_string": "    public Elements prev(String query) {\n        return siblings(query, false, false);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/select/Elements.java",
        "class_name": "Elements",
        "class_uri": "src/main/java/org/jsoup/select/Elements.java.Elements",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Elements",
            "classes": []
        },
        "docstring": "\nGet the immediate previous element sibling of each element in this list, filtered by the query.\n@param query CSS query to match siblings against\n@return previous element siblings.\n"
    },
    {
        "uris": "src/main/java/org/jsoup/select/Elements.java.Elements.[Elements]prevAll()",
        "name": "prevAll",
        "arg_nums": 0,
        "params": [],
        "return_type": "Elements",
        "signature": "public Elements prevAll()",
        "original_string": "    public Elements prevAll() {\n        return siblings(null, false, true);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/select/Elements.java",
        "class_name": "Elements",
        "class_uri": "src/main/java/org/jsoup/select/Elements.java.Elements",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Elements",
            "classes": []
        },
        "docstring": "\nGet each of the previous element siblings of each element in this list.\n@return all previous element siblings.\n"
    },
    {
        "uris": "src/main/java/org/jsoup/select/Elements.java.Elements.[Elements]prevAll(String)",
        "name": "prevAll",
        "arg_nums": 1,
        "params": [
            {
                "name": "query",
                "type": "String"
            }
        ],
        "return_type": "Elements",
        "signature": "public Elements prevAll(String query)",
        "original_string": "    public Elements prevAll(String query) {\n        return siblings(query, false, true);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/select/Elements.java",
        "class_name": "Elements",
        "class_uri": "src/main/java/org/jsoup/select/Elements.java.Elements",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Elements",
            "classes": []
        },
        "docstring": "\nGet each of the previous element siblings of each element in this list, that match the query.\n@param query CSS query to match siblings against\n@return all previous element siblings.\n"
    },
    {
        "uris": "src/main/java/org/jsoup/select/Elements.java.Elements.[Elements]siblings(String,boolean,boolean)",
        "name": "siblings",
        "arg_nums": 3,
        "params": [
            {
                "name": "query",
                "type": "String"
            },
            {
                "name": "next",
                "type": "boolean"
            },
            {
                "name": "all",
                "type": "boolean"
            }
        ],
        "return_type": "Elements",
        "signature": "private Elements siblings(@Nullable String query, boolean next, boolean all)",
        "original_string": "    private Elements siblings(@Nullable String query, boolean next, boolean all) {\n        Elements els = new Elements();\n        Evaluator eval = query != null? QueryParser.parse(query) : null;\n        for (Element e : this) {\n            do {\n                Element sib = next ? e.nextElementSibling() : e.previousElementSibling();\n                if (sib == null) break;\n                if (eval == null)\n                    els.add(sib);\n                else if (sib.is(eval))\n                    els.add(sib);\n                e = sib;\n            } while (all);\n        }\n        return els;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/select/Elements.java",
        "class_name": "Elements",
        "class_uri": "src/main/java/org/jsoup/select/Elements.java.Elements",
        "attributes": {
            "modifiers": "private",
            "marker_annotations": [],
            "non_marker_annotations": [
                "private"
            ],
            "comments": [],
            "return_type": "Elements",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/select/Elements.java.Elements.[Elements]parents()",
        "name": "parents",
        "arg_nums": 0,
        "params": [],
        "return_type": "Elements",
        "signature": "public Elements parents()",
        "original_string": "    public Elements parents() {\n        HashSet<Element> combo = new LinkedHashSet<>();\n        for (Element e: this) {\n            combo.addAll(e.parents());\n        }\n        return new Elements(combo);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/select/Elements.java",
        "class_name": "Elements",
        "class_uri": "src/main/java/org/jsoup/select/Elements.java.Elements",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Elements",
            "classes": []
        },
        "docstring": "\nGet all of the parents and ancestor elements of the matched elements.\n@return all of the parents and ancestor elements of the matched elements\n"
    },
    {
        "uris": "src/main/java/org/jsoup/select/Elements.java.Elements.[Element]first()",
        "name": "first",
        "arg_nums": 0,
        "params": [],
        "return_type": "Element",
        "signature": "public @Nullable Element first()",
        "original_string": "    public @Nullable Element first() {\n        return isEmpty() ? null : get(0);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/select/Elements.java",
        "class_name": "Elements",
        "class_uri": "src/main/java/org/jsoup/select/Elements.java.Elements",
        "attributes": {
            "modifiers": "public @Nullable",
            "marker_annotations": [
                "@Nullable"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Element",
            "classes": []
        },
        "docstring": "\nGet the first matched element.\n@return The first matched element, or <code>null</code> if contents is empty.\n"
    },
    {
        "uris": "src/main/java/org/jsoup/select/Elements.java.Elements.[Element]last()",
        "name": "last",
        "arg_nums": 0,
        "params": [],
        "return_type": "Element",
        "signature": "public @Nullable Element last()",
        "original_string": "    public @Nullable Element last() {\n        return isEmpty() ? null : get(size() - 1);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/select/Elements.java",
        "class_name": "Elements",
        "class_uri": "src/main/java/org/jsoup/select/Elements.java.Elements",
        "attributes": {
            "modifiers": "public @Nullable",
            "marker_annotations": [
                "@Nullable"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Element",
            "classes": []
        },
        "docstring": "\nGet the last matched element.\n@return The last matched element, or <code>null</code> if contents is empty.\n"
    },
    {
        "uris": "src/main/java/org/jsoup/select/Elements.java.Elements.[Elements]traverse(NodeVisitor)",
        "name": "traverse",
        "arg_nums": 1,
        "params": [
            {
                "name": "nodeVisitor",
                "type": "NodeVisitor"
            }
        ],
        "return_type": "Elements",
        "signature": "public Elements traverse(NodeVisitor nodeVisitor)",
        "original_string": "    public Elements traverse(NodeVisitor nodeVisitor) {\n        NodeTraversor.traverse(nodeVisitor, this);\n        return this;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/select/Elements.java",
        "class_name": "Elements",
        "class_uri": "src/main/java/org/jsoup/select/Elements.java.Elements",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Elements",
            "classes": []
        },
        "docstring": "\nPerform a depth-first traversal on each of the selected elements.\n@param nodeVisitor the visitor callbacks to perform on each node\n@return this, for chaining\n"
    },
    {
        "uris": "src/main/java/org/jsoup/select/Elements.java.Elements.[Elements]filter(NodeFilter)",
        "name": "filter",
        "arg_nums": 1,
        "params": [
            {
                "name": "nodeFilter",
                "type": "NodeFilter"
            }
        ],
        "return_type": "Elements",
        "signature": "public Elements filter(NodeFilter nodeFilter)",
        "original_string": "    public Elements filter(NodeFilter nodeFilter) {\n        NodeTraversor.filter(nodeFilter, this);\n        return this;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/select/Elements.java",
        "class_name": "Elements",
        "class_uri": "src/main/java/org/jsoup/select/Elements.java.Elements",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Elements",
            "classes": []
        },
        "docstring": "\nPerform a depth-first filtering on each of the selected elements.\n@param nodeFilter the filter callbacks to perform on each node\n@return this, for chaining\n"
    },
    {
        "uris": "src/main/java/org/jsoup/select/Elements.java.Elements.[List<FormElement>]forms()",
        "name": "forms",
        "arg_nums": 0,
        "params": [],
        "return_type": "List<FormElement>",
        "signature": "public List<FormElement> forms()",
        "original_string": "    public List<FormElement> forms() {\n        ArrayList<FormElement> forms = new ArrayList<>();\n        for (Element el: this)\n            if (el instanceof FormElement)\n                forms.add((FormElement) el);\n        return forms;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/select/Elements.java",
        "class_name": "Elements",
        "class_uri": "src/main/java/org/jsoup/select/Elements.java.Elements",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "List<FormElement>",
            "classes": []
        },
        "docstring": "\nGet the {@link FormElement} forms from the selected elements, if any.\n@return a list of {@link FormElement}s pulled from the matched elements. The list will be empty if the elements contain\nno forms.\n"
    },
    {
        "uris": "src/main/java/org/jsoup/select/Elements.java.Elements.[List<Comment>]comments()",
        "name": "comments",
        "arg_nums": 0,
        "params": [],
        "return_type": "List<Comment>",
        "signature": "public List<Comment> comments()",
        "original_string": "    public List<Comment> comments() {\n        return childNodesOfType(Comment.class);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/select/Elements.java",
        "class_name": "Elements",
        "class_uri": "src/main/java/org/jsoup/select/Elements.java.Elements",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "List<Comment>",
            "classes": []
        },
        "docstring": "\nGet {@link Comment} nodes that are direct child nodes of the selected elements.\n@return Comment nodes, or an empty list if none.\n"
    },
    {
        "uris": "src/main/java/org/jsoup/select/Elements.java.Elements.[List<TextNode>]textNodes()",
        "name": "textNodes",
        "arg_nums": 0,
        "params": [],
        "return_type": "List<TextNode>",
        "signature": "public List<TextNode> textNodes()",
        "original_string": "    public List<TextNode> textNodes() {\n        return childNodesOfType(TextNode.class);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/select/Elements.java",
        "class_name": "Elements",
        "class_uri": "src/main/java/org/jsoup/select/Elements.java.Elements",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "List<TextNode>",
            "classes": []
        },
        "docstring": "\nGet {@link TextNode} nodes that are direct child nodes of the selected elements.\n@return TextNode nodes, or an empty list if none.\n"
    },
    {
        "uris": "src/main/java/org/jsoup/select/Elements.java.Elements.[List<DataNode>]dataNodes()",
        "name": "dataNodes",
        "arg_nums": 0,
        "params": [],
        "return_type": "List<DataNode>",
        "signature": "public List<DataNode> dataNodes()",
        "original_string": "    public List<DataNode> dataNodes() {\n        return childNodesOfType(DataNode.class);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/select/Elements.java",
        "class_name": "Elements",
        "class_uri": "src/main/java/org/jsoup/select/Elements.java.Elements",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "List<DataNode>",
            "classes": []
        },
        "docstring": "\nGet {@link DataNode} nodes that are direct child nodes of the selected elements. DataNode nodes contain the\ncontent of tags such as {@code script}, {@code style} etc and are distinct from {@link TextNode}s.\n@return Comment nodes, or an empty list if none.\n"
    },
    {
        "uris": "src/main/java/org/jsoup/select/Elements.java.Elements.[List<T>]childNodesOfType(Class<T>)",
        "name": "childNodesOfType",
        "arg_nums": 1,
        "params": [
            {
                "name": "tClass",
                "type": "Class<T>"
            }
        ],
        "return_type": "List<T>",
        "signature": "private <T extends Node> List<T> childNodesOfType(Class<T> tClass)",
        "original_string": "    private <T extends Node> List<T> childNodesOfType(Class<T> tClass) {\n        ArrayList<T> nodes = new ArrayList<>();\n        for (Element el: this) {\n            for (int i = 0; i < el.childNodeSize(); i++) {\n                Node node = el.childNode(i);\n                if (tClass.isInstance(node))\n                    nodes.add(tClass.cast(node));\n            }\n        }\n        return nodes;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/select/Elements.java",
        "class_name": "Elements",
        "class_uri": "src/main/java/org/jsoup/select/Elements.java.Elements",
        "attributes": {
            "modifiers": "private",
            "marker_annotations": [],
            "non_marker_annotations": [
                "private"
            ],
            "comments": [],
            "return_type": "List<T>",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/select/Elements.java.Elements.[Element]set(int,Element)",
        "name": "set",
        "arg_nums": 2,
        "params": [
            {
                "name": "index",
                "type": "int"
            },
            {
                "name": "element",
                "type": "Element"
            }
        ],
        "return_type": "Element",
        "signature": "@Override public Element set(int index, Element element)",
        "original_string": "    @Override public Element set(int index, Element element) {\n        Validate.notNull(element);\n        Element old = super.set(index, element);\n        old.replaceWith(element);\n        return old;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/select/Elements.java",
        "class_name": "Elements",
        "class_uri": "src/main/java/org/jsoup/select/Elements.java.Elements",
        "attributes": {
            "modifiers": "@Override public",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Element",
            "classes": []
        },
        "docstring": "\nReplace the Element at the specified index in this list, and in the DOM.\n@param index index of the element to replace\n@param element element to be stored at the specified position\n@return the old Element at this index\n@since 1.17.1\n"
    },
    {
        "uris": "src/main/java/org/jsoup/select/Elements.java.Elements.[Element]remove(int)",
        "name": "remove",
        "arg_nums": 1,
        "params": [
            {
                "name": "index",
                "type": "int"
            }
        ],
        "return_type": "Element",
        "signature": "@Override public Element remove(int index)",
        "original_string": "    @Override public Element remove(int index) {\n        Element old = super.remove(index);\n        old.remove();\n        return old;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/select/Elements.java",
        "class_name": "Elements",
        "class_uri": "src/main/java/org/jsoup/select/Elements.java.Elements",
        "attributes": {
            "modifiers": "@Override public",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Element",
            "classes": []
        },
        "docstring": "\nRemove the Element at the specified index in this ist, and from the DOM.\n@param index the index of the element to be removed\n@return the old element at this index\n@since 1.17.1\n"
    },
    {
        "uris": "src/main/java/org/jsoup/select/Elements.java.Elements.[boolean]remove(Object)",
        "name": "remove",
        "arg_nums": 1,
        "params": [
            {
                "name": "o",
                "type": "Object"
            }
        ],
        "return_type": "boolean",
        "signature": "@Override public boolean remove(Object o)",
        "original_string": "    @Override public boolean remove(Object o) {\n        int index = super.indexOf(o);\n        if (index == -1) {\n            return false;\n        } else {\n            remove(index);\n            return true;\n        }\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/select/Elements.java",
        "class_name": "Elements",
        "class_uri": "src/main/java/org/jsoup/select/Elements.java.Elements",
        "attributes": {
            "modifiers": "@Override public",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": "\nRemove the specified Element from this list, and from th DOM\n@param o element to be removed from this list, if present\n@return if this list contained the Element\n@since 1.17.1\n"
    },
    {
        "uris": "src/main/java/org/jsoup/select/Elements.java.Elements.[void]clear()",
        "name": "clear",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "@Override public void clear()",
        "original_string": "    @Override public void clear() {\n        remove();\n        super.clear();\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/select/Elements.java",
        "class_name": "Elements",
        "class_uri": "src/main/java/org/jsoup/select/Elements.java.Elements",
        "attributes": {
            "modifiers": "@Override public",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": "\nRemoves all the elements from this list, and each of them from the DOM.\n@since 1.17.1\n@see #remove()\n"
    },
    {
        "uris": "src/main/java/org/jsoup/select/Elements.java.Elements.[boolean]removeAll(Collection<?>)",
        "name": "removeAll",
        "arg_nums": 1,
        "params": [
            {
                "name": "c",
                "type": "Collection<?>"
            }
        ],
        "return_type": "boolean",
        "signature": "@Override public boolean removeAll(Collection<?> c)",
        "original_string": "    @Override public boolean removeAll(Collection<?> c) {\n        boolean anyRemoved = false;\n        for (Object o : c) {\n            anyRemoved |= this.remove(o);\n        }\n        return anyRemoved;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/select/Elements.java",
        "class_name": "Elements",
        "class_uri": "src/main/java/org/jsoup/select/Elements.java.Elements",
        "attributes": {
            "modifiers": "@Override public",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": "\nRemoves from this list, and from the DOM, each of the elements that are contained in the specified collection and\nare in this list.\n@param c collection containing elements to be removed from this list\n@return {@code true} if elements were removed from this list\n@since 1.17.1\n"
    },
    {
        "uris": "src/main/java/org/jsoup/select/Elements.java.Elements.[boolean]retainAll(Collection<?>)",
        "name": "retainAll",
        "arg_nums": 1,
        "params": [
            {
                "name": "c",
                "type": "Collection<?>"
            }
        ],
        "return_type": "boolean",
        "signature": "@Override public boolean retainAll(Collection<?> c)",
        "original_string": "    @Override public boolean retainAll(Collection<?> c) {\n        boolean anyRemoved = false;\n        for (Iterator<Element> it = this.iterator(); it.hasNext(); ) {\n            Element el = it.next();\n            if (!c.contains(el)) {\n                it.remove();\n                anyRemoved = true;\n            }\n        }\n        return anyRemoved;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/select/Elements.java",
        "class_name": "Elements",
        "class_uri": "src/main/java/org/jsoup/select/Elements.java.Elements",
        "attributes": {
            "modifiers": "@Override public",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": "\nRetain in this list, and in the DOM, only the elements that are in the specified collection and are in this list.\nIn other words, remove elements from this list and the DOM any item that is in this list but not in the specified\ncollection.\n@param c collection containing elements to be retained in this list\n@return {@code true} if elements were removed from this list\n@since 1.17.1\n"
    },
    {
        "uris": "src/main/java/org/jsoup/select/Elements.java.Elements.[boolean]removeIf(Predicate<? super Element>)",
        "name": "removeIf",
        "arg_nums": 1,
        "params": [
            {
                "name": "filter",
                "type": "Predicate<? super Element>"
            }
        ],
        "return_type": "boolean",
        "signature": "@Override public boolean removeIf(Predicate<? super Element> filter)",
        "original_string": "    @Override public boolean removeIf(Predicate<? super Element> filter) {\n        boolean anyRemoved = false;\n        for (Iterator<Element> it = this.iterator(); it.hasNext(); ) {\n            Element el = it.next();\n            if (filter.test(el)) {\n                it.remove();\n                anyRemoved = true;\n            }\n        }\n        return anyRemoved;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/select/Elements.java",
        "class_name": "Elements",
        "class_uri": "src/main/java/org/jsoup/select/Elements.java.Elements",
        "attributes": {
            "modifiers": "@Override public",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": "\nRemove from the list, and from the DOM, all elements in this list that mach the given filter.\n@param filter a predicate which returns {@code true} for elements to be removed\n@return {@code true} if elements were removed from this list\n@since 1.17.1\n"
    },
    {
        "uris": "src/main/java/org/jsoup/select/Elements.java.Elements.[void]replaceAll(UnaryOperator<Element>)",
        "name": "replaceAll",
        "arg_nums": 1,
        "params": [
            {
                "name": "operator",
                "type": "UnaryOperator<Element>"
            }
        ],
        "return_type": "void",
        "signature": "@Override public void replaceAll(UnaryOperator<Element> operator)",
        "original_string": "    @Override public void replaceAll(UnaryOperator<Element> operator) {\n        for (int i = 0; i < this.size(); i++) {\n            this.set(i, operator.apply(this.get(i)));\n        }\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/select/Elements.java",
        "class_name": "Elements",
        "class_uri": "src/main/java/org/jsoup/select/Elements.java.Elements",
        "attributes": {
            "modifiers": "@Override public",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": "\nReplace each element in this list with the result of the operator, and update the DOM.\n@param operator the operator to apply to each element\n@since 1.17.1\n"
    },
    {
        "uris": "src/main/java/org/jsoup/select/Evaluator.java.Evaluator.[]Evaluator()",
        "name": "Evaluator",
        "arg_nums": 0,
        "params": [],
        "return_type": "",
        "signature": "protected Evaluator()",
        "original_string": "    protected Evaluator() {\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/select/Evaluator.java",
        "class_name": "Evaluator",
        "class_uri": "src/main/java/org/jsoup/select/Evaluator.java.Evaluator",
        "attributes": {
            "modifiers": "protected",
            "marker_annotations": [],
            "non_marker_annotations": [
                "protected"
            ],
            "comments": [],
            "return_type": "",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/select/Evaluator.java.Evaluator.[Predicate<Element>]asPredicate(Element)",
        "name": "asPredicate",
        "arg_nums": 1,
        "params": [
            {
                "name": "root",
                "type": "Element"
            }
        ],
        "return_type": "Predicate<Element>",
        "signature": "public Predicate<Element> asPredicate(Element root)",
        "original_string": "    public Predicate<Element> asPredicate(Element root) {\n        return element -> matches(root, element);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/select/Evaluator.java",
        "class_name": "Evaluator",
        "class_uri": "src/main/java/org/jsoup/select/Evaluator.java.Evaluator",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Predicate<Element>",
            "classes": []
        },
        "docstring": "\nProvides a Predicate for this Evaluator, matching the test Element.\n@param root the root Element, for match evaluation\n@return a predicate that accepts an Element to test for matches with this Evaluator\n@since 1.17.1\n"
    },
    {
        "uris": "src/main/java/org/jsoup/select/Evaluator.java.Evaluator.[boolean]matches(Element,Element)",
        "name": "matches",
        "arg_nums": 2,
        "params": [
            {
                "name": "root",
                "type": "Element"
            },
            {
                "name": "element",
                "type": "Element"
            }
        ],
        "return_type": "boolean",
        "signature": "public abstract boolean matches(Element root, Element element)",
        "original_string": "    public abstract boolean matches(Element root, Element element);",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/select/Evaluator.java",
        "class_name": "Evaluator",
        "class_uri": "src/main/java/org/jsoup/select/Evaluator.java.Evaluator",
        "attributes": {
            "modifiers": "public abstract",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public",
                "abstract"
            ],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": "\nTest if the element meets the evaluator's requirements.\n\n@param root    Root of the matching subtree\n@param element tested element\n@return Returns <tt>true</tt> if the requirements are met or\n<tt>false</tt> otherwise\n"
    },
    {
        "uris": "src/main/java/org/jsoup/select/Evaluator.java.Evaluator.[void]reset()",
        "name": "reset",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "protected void reset()",
        "original_string": "    protected void reset() {\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/select/Evaluator.java",
        "class_name": "Evaluator",
        "class_uri": "src/main/java/org/jsoup/select/Evaluator.java.Evaluator",
        "attributes": {
            "modifiers": "protected",
            "marker_annotations": [],
            "non_marker_annotations": [
                "protected"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": "\nReset any internal state in this Evaluator before executing a new Collector evaluation.\n"
    },
    {
        "uris": "src/main/java/org/jsoup/select/Evaluator.java.Evaluator.[int]cost()",
        "name": "cost",
        "arg_nums": 0,
        "params": [],
        "return_type": "int",
        "signature": "protected int cost()",
        "original_string": "    protected int cost() {\n        return 5; // a nominal default cost\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/select/Evaluator.java",
        "class_name": "Evaluator",
        "class_uri": "src/main/java/org/jsoup/select/Evaluator.java.Evaluator",
        "attributes": {
            "modifiers": "protected",
            "marker_annotations": [],
            "non_marker_annotations": [
                "protected"
            ],
            "comments": [],
            "return_type": "int",
            "classes": []
        },
        "docstring": "\nA relative evaluator cost function. During evaluation, Evaluators are sorted by ascending cost as an optimization.\n@return the relative cost of this Evaluator\n"
    },
    {
        "uris": "src/main/java/org/jsoup/select/NodeFilter.java.NodeFilter.[FilterResult]head(Node,int)",
        "name": "head",
        "arg_nums": 2,
        "params": [
            {
                "name": "node",
                "type": "Node"
            },
            {
                "name": "depth",
                "type": "int"
            }
        ],
        "return_type": "FilterResult",
        "signature": "FilterResult head(Node node, int depth)",
        "original_string": "    FilterResult head(Node node, int depth);",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/select/NodeFilter.java",
        "class_name": "NodeFilter",
        "class_uri": "src/main/java/org/jsoup/select/NodeFilter.java.NodeFilter",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "FilterResult",
            "classes": []
        },
        "docstring": "\nCallback for when a node is first visited.\n@param node the node being visited.\n@param depth the depth of the node, relative to the root node. E.g., the root node has depth 0, and a child node of that will have depth 1.\n@return Filter decision\n"
    },
    {
        "uris": "src/main/java/org/jsoup/select/NodeFilter.java.NodeFilter.[FilterResult]tail(Node,int)",
        "name": "tail",
        "arg_nums": 2,
        "params": [
            {
                "name": "node",
                "type": "Node"
            },
            {
                "name": "depth",
                "type": "int"
            }
        ],
        "return_type": "FilterResult",
        "signature": "default FilterResult tail(Node node, int depth)",
        "original_string": "    default FilterResult tail(Node node, int depth) {\n        return FilterResult.CONTINUE;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/select/NodeFilter.java",
        "class_name": "NodeFilter",
        "class_uri": "src/main/java/org/jsoup/select/NodeFilter.java.NodeFilter",
        "attributes": {
            "modifiers": "default",
            "marker_annotations": [],
            "non_marker_annotations": [
                "default"
            ],
            "comments": [],
            "return_type": "FilterResult",
            "classes": []
        },
        "docstring": "\nCallback for when a node is last visited, after all of its descendants have been visited.\n<p>This method has a default implementation to return {@link FilterResult#CONTINUE}.</p>\n@param node the node being visited.\n@param depth the depth of the node, relative to the root node. E.g., the root node has depth 0, and a child node of that will have depth 1.\n@return Filter decision\n"
    },
    {
        "uris": "src/main/java/org/jsoup/select/NodeVisitor.java.NodeVisitor.[void]head(Node,int)",
        "name": "head",
        "arg_nums": 2,
        "params": [
            {
                "name": "node",
                "type": "Node"
            },
            {
                "name": "depth",
                "type": "int"
            }
        ],
        "return_type": "void",
        "signature": "void head(Node node, int depth)",
        "original_string": "    void head(Node node, int depth);",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/select/NodeVisitor.java",
        "class_name": "NodeVisitor",
        "class_uri": "src/main/java/org/jsoup/select/NodeVisitor.java.NodeVisitor",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": "\nCallback for when a node is first visited.\n<p>The node may be modified (e.g. {@link Node#attr(String)}, replaced {@link Node#replaceWith(Node)}) or removed\n{@link Node#remove()}. If it's {@code instanceOf Element}, you may cast it to an {@link Element} and access those\nmethods.</p>\n\n@param node the node being visited.\n@param depth the depth of the node, relative to the root node. E.g., the root node has depth 0, and a child node\nof that will have depth 1.\n"
    },
    {
        "uris": "src/main/java/org/jsoup/select/NodeVisitor.java.NodeVisitor.[void]tail(Node,int)",
        "name": "tail",
        "arg_nums": 2,
        "params": [
            {
                "name": "node",
                "type": "Node"
            },
            {
                "name": "depth",
                "type": "int"
            }
        ],
        "return_type": "void",
        "signature": "default void tail(Node node, int depth)",
        "original_string": "    default void tail(Node node, int depth) {\n        // no-op by default, to allow just specifying the head() method\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/select/NodeVisitor.java",
        "class_name": "NodeVisitor",
        "class_uri": "src/main/java/org/jsoup/select/NodeVisitor.java.NodeVisitor",
        "attributes": {
            "modifiers": "default",
            "marker_annotations": [],
            "non_marker_annotations": [
                "default"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": "\nCallback for when a node is last visited, after all of its descendants have been visited.\n<p>This method has a default no-op implementation.</p>\n<p>Note that neither replacement with {@link Node#replaceWith(Node)} nor removal with {@link Node#remove()} is\nsupported during {@code tail()}.\n\n@param node the node being visited.\n@param depth the depth of the node, relative to the root node. E.g., the root node has depth 0, and a child node\nof that will have depth 1.\n"
    },
    {
        "uris": "src/main/java/org/jsoup/select/QueryParser.java.QueryParser.[]QueryParser(String)",
        "name": "QueryParser",
        "arg_nums": 1,
        "params": [
            {
                "name": "query",
                "type": "String"
            }
        ],
        "return_type": "",
        "signature": "private QueryParser(String query)",
        "original_string": "    private QueryParser(String query) {\n        Validate.notEmpty(query);\n        query = query.trim();\n        this.query = query;\n        this.tq = new TokenQueue(query);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/select/QueryParser.java",
        "class_name": "QueryParser",
        "class_uri": "src/main/java/org/jsoup/select/QueryParser.java.QueryParser",
        "attributes": {
            "modifiers": "private",
            "marker_annotations": [],
            "non_marker_annotations": [
                "private"
            ],
            "comments": [],
            "return_type": "",
            "classes": []
        },
        "docstring": "\nCreate a new QueryParser.\n@param query CSS query\n"
    },
    {
        "uris": "src/main/java/org/jsoup/select/QueryParser.java.QueryParser.[Evaluator]parse(String)",
        "name": "parse",
        "arg_nums": 1,
        "params": [
            {
                "name": "query",
                "type": "String"
            }
        ],
        "return_type": "Evaluator",
        "signature": "public static Evaluator parse(String query)",
        "original_string": "    public static Evaluator parse(String query) {\n        try {\n            QueryParser p = new QueryParser(query);\n            return p.parse();\n        } catch (IllegalArgumentException e) {\n            throw new Selector.SelectorParseException(e.getMessage());\n        }\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/select/QueryParser.java",
        "class_name": "QueryParser",
        "class_uri": "src/main/java/org/jsoup/select/QueryParser.java.QueryParser",
        "attributes": {
            "modifiers": "public static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public",
                "static"
            ],
            "comments": [],
            "return_type": "Evaluator",
            "classes": []
        },
        "docstring": "\nParse a CSS query into an Evaluator.\n@param query CSS query\n@return Evaluator\n@see Selector selector query syntax\n"
    },
    {
        "uris": "src/main/java/org/jsoup/select/QueryParser.java.QueryParser.[Evaluator]parse()",
        "name": "parse",
        "arg_nums": 0,
        "params": [],
        "return_type": "Evaluator",
        "signature": "Evaluator parse()",
        "original_string": "    Evaluator parse() {\n        tq.consumeWhitespace();\n\n        if (tq.matchesAny(Combinators)) { // if starts with a combinator, use root as elements\n            evals.add(new StructuralEvaluator.Root());\n            combinator(tq.consume());\n        } else {\n            evals.add(consumeEvaluator());\n        }\n\n        while (!tq.isEmpty()) {\n            // hierarchy and extras\n            boolean seenWhite = tq.consumeWhitespace();\n\n            if (tq.matchesAny(Combinators)) {\n                combinator(tq.consume());\n            } else if (seenWhite) {\n                combinator(' ');\n            } else { // E.class, E#id, E[attr] etc. AND\n                evals.add(consumeEvaluator()); // take next el, #. etc off queue\n            }\n        }\n\n        if (evals.size() == 1)\n            return evals.get(0);\n\n        return new CombiningEvaluator.And(evals);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/select/QueryParser.java",
        "class_name": "QueryParser",
        "class_uri": "src/main/java/org/jsoup/select/QueryParser.java.QueryParser",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "Evaluator",
            "classes": []
        },
        "docstring": "\nParse the query\n@return Evaluator\n"
    },
    {
        "uris": "src/main/java/org/jsoup/select/QueryParser.java.QueryParser.[void]combinator(char)",
        "name": "combinator",
        "arg_nums": 1,
        "params": [
            {
                "name": "combinator",
                "type": "char"
            }
        ],
        "return_type": "void",
        "signature": "private void combinator(char combinator)",
        "original_string": "    private void combinator(char combinator) {\n        tq.consumeWhitespace();\n        String subQuery = consumeSubQuery(); // support multi > childs\n\n        Evaluator rootEval; // the new topmost evaluator\n        Evaluator currentEval; // the evaluator the new eval will be combined to. could be root, or rightmost or.\n        Evaluator newEval = parse(subQuery); // the evaluator to add into target evaluator\n        boolean replaceRightMost = false;\n\n        if (evals.size() == 1) {\n            rootEval = currentEval = evals.get(0);\n            // make sure OR (,) has precedence:\n            if (rootEval instanceof CombiningEvaluator.Or && combinator != ',') {\n                currentEval = ((CombiningEvaluator.Or) currentEval).rightMostEvaluator();\n                assert currentEval != null; // rightMost signature can return null (if none set), but always will have one by this point\n                replaceRightMost = true;\n            }\n        }\n        else {\n            rootEval = currentEval = new CombiningEvaluator.And(evals);\n        }\n        evals.clear();\n\n        // for most combinators: change the current eval into an AND of the current eval and the new eval\n        switch (combinator) {\n            case '>':\n                ImmediateParentRun run = currentEval instanceof ImmediateParentRun ?\n                        (ImmediateParentRun) currentEval : new ImmediateParentRun(currentEval);\n                run.add(newEval);\n                currentEval = run;\n                break;\n            case ' ':\n                currentEval = new CombiningEvaluator.And(new StructuralEvaluator.Parent(currentEval), newEval);\n                break;\n            case '+':\n                currentEval = new CombiningEvaluator.And(new StructuralEvaluator.ImmediatePreviousSibling(currentEval), newEval);\n                break;\n            case '~':\n                currentEval = new CombiningEvaluator.And(new StructuralEvaluator.PreviousSibling(currentEval), newEval);\n                break;\n            case ',':\n                CombiningEvaluator.Or or;\n                if (currentEval instanceof CombiningEvaluator.Or) {\n                    or = (CombiningEvaluator.Or) currentEval;\n                } else {\n                    or = new CombiningEvaluator.Or();\n                    or.add(currentEval);\n                }\n                or.add(newEval);\n                currentEval = or;\n                break;\n            default:\n                throw new Selector.SelectorParseException(\"Unknown combinator '%s'\", combinator);\n        }\n\n        if (replaceRightMost)\n            ((CombiningEvaluator.Or) rootEval).replaceRightMostEvaluator(currentEval);\n        else rootEval = currentEval;\n        evals.add(rootEval);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/select/QueryParser.java",
        "class_name": "QueryParser",
        "class_uri": "src/main/java/org/jsoup/select/QueryParser.java.QueryParser",
        "attributes": {
            "modifiers": "private",
            "marker_annotations": [],
            "non_marker_annotations": [
                "private"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/select/QueryParser.java.QueryParser.[String]consumeSubQuery()",
        "name": "consumeSubQuery",
        "arg_nums": 0,
        "params": [],
        "return_type": "String",
        "signature": "private String consumeSubQuery()",
        "original_string": "    private String consumeSubQuery() {\n        StringBuilder sq = StringUtil.borrowBuilder();\n        boolean seenClause = false; // eat until we hit a combinator after eating something else\n        while (!tq.isEmpty()) {\n            if (tq.matchesAny(Combinators)) {\n                if (seenClause)\n                    break;\n                sq.append(tq.consume());\n                continue;\n            }\n            seenClause = true;\n            if (tq.matches(\"(\"))\n                sq.append(\"(\").append(tq.chompBalanced('(', ')')).append(\")\");\n            else if (tq.matches(\"[\"))\n                sq.append(\"[\").append(tq.chompBalanced('[', ']')).append(\"]\");\n            else if (tq.matches(\"\\\\\")) { // bounce over escapes\n                sq.append(tq.consume());\n                if (!tq.isEmpty()) sq.append(tq.consume());\n            } else\n                sq.append(tq.consume());\n        }\n        return StringUtil.releaseBuilder(sq);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/select/QueryParser.java",
        "class_name": "QueryParser",
        "class_uri": "src/main/java/org/jsoup/select/QueryParser.java.QueryParser",
        "attributes": {
            "modifiers": "private",
            "marker_annotations": [],
            "non_marker_annotations": [
                "private"
            ],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/select/QueryParser.java.QueryParser.[Evaluator]consumeEvaluator()",
        "name": "consumeEvaluator",
        "arg_nums": 0,
        "params": [],
        "return_type": "Evaluator",
        "signature": "private Evaluator consumeEvaluator()",
        "original_string": "    private Evaluator consumeEvaluator() {\n        if (tq.matchChomp(\"#\"))\n            return byId();\n        else if (tq.matchChomp(\".\"))\n            return byClass();\n        else if (tq.matchesWord() || tq.matches(\"*|\"))\n            return byTag();\n        else if (tq.matches(\"[\"))\n            return byAttribute();\n        else if (tq.matchChomp(\"*\"))\n            return new Evaluator.AllElements();\n        else if (tq.matchChomp(\":\"))\n            return parsePseudoSelector();\n\t\telse // unhandled\n            throw new Selector.SelectorParseException(\"Could not parse query '%s': unexpected token at '%s'\", query, tq.remainder());\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/select/QueryParser.java",
        "class_name": "QueryParser",
        "class_uri": "src/main/java/org/jsoup/select/QueryParser.java.QueryParser",
        "attributes": {
            "modifiers": "private",
            "marker_annotations": [],
            "non_marker_annotations": [
                "private"
            ],
            "comments": [],
            "return_type": "Evaluator",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/select/QueryParser.java.QueryParser.[Evaluator]parsePseudoSelector()",
        "name": "parsePseudoSelector",
        "arg_nums": 0,
        "params": [],
        "return_type": "Evaluator",
        "signature": "private Evaluator parsePseudoSelector()",
        "original_string": "    private Evaluator parsePseudoSelector() {\n        final String pseudo = tq.consumeCssIdentifier();\n        switch (pseudo) {\n            case \"lt\":\n                return new Evaluator.IndexLessThan(consumeIndex());\n            case \"gt\":\n                return new Evaluator.IndexGreaterThan(consumeIndex());\n            case \"eq\":\n                return new Evaluator.IndexEquals(consumeIndex());\n            case \"has\":\n                return has();\n            case \"is\":\n                return is();\n            case \"contains\":\n                return contains(false);\n            case \"containsOwn\":\n                return contains(true);\n            case \"containsWholeText\":\n                return containsWholeText(false);\n            case \"containsWholeOwnText\":\n                return containsWholeText(true);\n            case \"containsData\":\n                return containsData();\n            case \"matches\":\n                return matches(false);\n            case \"matchesOwn\":\n                return matches(true);\n            case \"matchesWholeText\":\n                return matchesWholeText(false);\n            case \"matchesWholeOwnText\":\n                return matchesWholeText(true);\n            case \"not\":\n                return not();\n            case \"nth-child\":\n                return cssNthChild(false, false);\n            case \"nth-last-child\":\n                return cssNthChild(true, false);\n            case \"nth-of-type\":\n                return cssNthChild(false, true);\n            case \"nth-last-of-type\":\n                return cssNthChild(true, true);\n            case \"first-child\":\n                return new Evaluator.IsFirstChild();\n            case \"last-child\":\n                return new Evaluator.IsLastChild();\n            case \"first-of-type\":\n                return new Evaluator.IsFirstOfType();\n            case \"last-of-type\":\n                return new Evaluator.IsLastOfType();\n            case \"only-child\":\n                return new Evaluator.IsOnlyChild();\n            case \"only-of-type\":\n                return new Evaluator.IsOnlyOfType();\n            case \"empty\":\n                return new Evaluator.IsEmpty();\n            case \"root\":\n                return new Evaluator.IsRoot();\n            case \"matchText\":\n                return new Evaluator.MatchText();\n            default:\n                throw new Selector.SelectorParseException(\"Could not parse query '%s': unexpected token at '%s'\", query, tq.remainder());\n        }\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/select/QueryParser.java",
        "class_name": "QueryParser",
        "class_uri": "src/main/java/org/jsoup/select/QueryParser.java.QueryParser",
        "attributes": {
            "modifiers": "private",
            "marker_annotations": [],
            "non_marker_annotations": [
                "private"
            ],
            "comments": [],
            "return_type": "Evaluator",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/select/QueryParser.java.QueryParser.[Evaluator]byId()",
        "name": "byId",
        "arg_nums": 0,
        "params": [],
        "return_type": "Evaluator",
        "signature": "private Evaluator byId()",
        "original_string": "    private Evaluator byId() {\n        String id = tq.consumeCssIdentifier();\n        Validate.notEmpty(id);\n        return new Evaluator.Id(id);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/select/QueryParser.java",
        "class_name": "QueryParser",
        "class_uri": "src/main/java/org/jsoup/select/QueryParser.java.QueryParser",
        "attributes": {
            "modifiers": "private",
            "marker_annotations": [],
            "non_marker_annotations": [
                "private"
            ],
            "comments": [],
            "return_type": "Evaluator",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/select/QueryParser.java.QueryParser.[Evaluator]byClass()",
        "name": "byClass",
        "arg_nums": 0,
        "params": [],
        "return_type": "Evaluator",
        "signature": "private Evaluator byClass()",
        "original_string": "    private Evaluator byClass() {\n        String className = tq.consumeCssIdentifier();\n        Validate.notEmpty(className);\n        return new Evaluator.Class(className.trim());\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/select/QueryParser.java",
        "class_name": "QueryParser",
        "class_uri": "src/main/java/org/jsoup/select/QueryParser.java.QueryParser",
        "attributes": {
            "modifiers": "private",
            "marker_annotations": [],
            "non_marker_annotations": [
                "private"
            ],
            "comments": [],
            "return_type": "Evaluator",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/select/QueryParser.java.QueryParser.[Evaluator]byTag()",
        "name": "byTag",
        "arg_nums": 0,
        "params": [],
        "return_type": "Evaluator",
        "signature": "private Evaluator byTag()",
        "original_string": "    private Evaluator byTag() {\n        // todo - these aren't dealing perfectly with case sensitivity. For case sensitive parsers, we should also make\n        // the tag in the selector case-sensitive (and also attribute names). But for now, normalize (lower-case) for\n        // consistency - both the selector and the element tag\n        String tagName = normalize(tq.consumeElementSelector());\n        Validate.notEmpty(tagName);\n\n        // namespaces:\n        if (tagName.startsWith(\"*|\")) { // namespaces: wildcard match equals(tagName) or ending in \":\"+tagName\n            String plainTag = tagName.substring(2); // strip *|\n            return new CombiningEvaluator.Or(\n                new Evaluator.Tag(plainTag),\n                new Evaluator.TagEndsWith(\":\" + plainTag)\n            );\n        } else if (tagName.endsWith(\"|*\")) { // ns|*\n            String ns = tagName.substring(0, tagName.length() - 2) + \":\"; // strip |*, to ns:\n            return new Evaluator.TagStartsWith(ns);\n        } else if (tagName.contains(\"|\")) { // flip \"abc|def\" to \"abc:def\"\n            tagName = tagName.replace(\"|\", \":\");\n        }\n\n        return new Evaluator.Tag(tagName);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/select/QueryParser.java",
        "class_name": "QueryParser",
        "class_uri": "src/main/java/org/jsoup/select/QueryParser.java.QueryParser",
        "attributes": {
            "modifiers": "private",
            "marker_annotations": [],
            "non_marker_annotations": [
                "private"
            ],
            "comments": [],
            "return_type": "Evaluator",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/select/QueryParser.java.QueryParser.[Evaluator]byAttribute()",
        "name": "byAttribute",
        "arg_nums": 0,
        "params": [],
        "return_type": "Evaluator",
        "signature": "private Evaluator byAttribute()",
        "original_string": "    private Evaluator byAttribute() {\n        TokenQueue cq = new TokenQueue(tq.chompBalanced('[', ']')); // content queue\n        String key = cq.consumeToAny(AttributeEvals); // eq, not, start, end, contain, match, (no val)\n        Validate.notEmpty(key);\n        cq.consumeWhitespace();\n        final Evaluator eval;\n\n        if (cq.isEmpty()) {\n            if (key.startsWith(\"^\"))\n                eval = new Evaluator.AttributeStarting(key.substring(1));\n            else if (key.equals(\"*\")) // any attribute\n                eval = new Evaluator.AttributeStarting(\"\");\n            else\n                eval = new Evaluator.Attribute(key);\n        } else {\n            if (cq.matchChomp(\"=\"))\n                eval = new Evaluator.AttributeWithValue(key, cq.remainder());\n            else if (cq.matchChomp(\"!=\"))\n                eval = new Evaluator.AttributeWithValueNot(key, cq.remainder());\n            else if (cq.matchChomp(\"^=\"))\n                eval = new Evaluator.AttributeWithValueStarting(key, cq.remainder());\n            else if (cq.matchChomp(\"$=\"))\n                eval = new Evaluator.AttributeWithValueEnding(key, cq.remainder());\n            else if (cq.matchChomp(\"*=\"))\n                eval = new Evaluator.AttributeWithValueContaining(key, cq.remainder());\n            else if (cq.matchChomp(\"~=\"))\n                eval = new Evaluator.AttributeWithValueMatching(key, Pattern.compile(cq.remainder()));\n            else\n                throw new Selector.SelectorParseException(\"Could not parse attribute query '%s': unexpected token at '%s'\", query, cq.remainder());\n        }\n        return eval;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/select/QueryParser.java",
        "class_name": "QueryParser",
        "class_uri": "src/main/java/org/jsoup/select/QueryParser.java.QueryParser",
        "attributes": {
            "modifiers": "private",
            "marker_annotations": [],
            "non_marker_annotations": [
                "private"
            ],
            "comments": [],
            "return_type": "Evaluator",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/select/QueryParser.java.QueryParser.[Evaluator]cssNthChild(boolean,boolean)",
        "name": "cssNthChild",
        "arg_nums": 2,
        "params": [
            {
                "name": "backwards",
                "type": "boolean"
            },
            {
                "name": "ofType",
                "type": "boolean"
            }
        ],
        "return_type": "Evaluator",
        "signature": "private Evaluator cssNthChild(boolean backwards, boolean ofType)",
        "original_string": " private Evaluator cssNthChild(boolean backwards, boolean ofType) {\n\t\tString arg = normalize(consumeParens());\n\t\tMatcher mAB = NTH_AB.matcher(arg);\n\t\tMatcher mB = NTH_B.matcher(arg);\n\t\tfinal int a, b;\n\t\tif (\"odd\".equals(arg)) {\n\t\t\ta = 2;\n\t\t\tb = 1;\n\t\t} else if (\"even\".equals(arg)) {\n\t\t\ta = 2;\n\t\t\tb = 0;\n\t\t} else if (mAB.matches()) {\n\t\t\ta = mAB.group(3) != null ? Integer.parseInt(mAB.group(1).replaceFirst(\"^\\\\+\", \"\")) : 1;\n\t\t\tb = mAB.group(4) != null ? Integer.parseInt(mAB.group(4).replaceFirst(\"^\\\\+\", \"\")) : 0;\n\t\t} else if (mB.matches()) {\n\t\t\ta = 0;\n\t\t\tb = Integer.parseInt(mB.group().replaceFirst(\"^\\\\+\", \"\"));\n\t\t} else {\n\t\t\tthrow new Selector.SelectorParseException(\"Could not parse nth-index '%s': unexpected format\", arg);\n\t\t}\n\n        final Evaluator eval;\n\t\tif (ofType)\n\t\t\tif (backwards)\n\t\t\t\teval = new Evaluator.IsNthLastOfType(a, b);\n\t\t\telse\n\t\t\t\teval = new Evaluator.IsNthOfType(a, b);\n\t\telse {\n\t\t\tif (backwards)\n\t\t\t\teval = (new Evaluator.IsNthLastChild(a, b));\n\t\t\telse\n\t\t\t\teval = new Evaluator.IsNthChild(a, b);\n\t\t}\n        return eval;\n\t}",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/select/QueryParser.java",
        "class_name": "QueryParser",
        "class_uri": "src/main/java/org/jsoup/select/QueryParser.java.QueryParser",
        "attributes": {
            "modifiers": "private",
            "marker_annotations": [],
            "non_marker_annotations": [
                "private"
            ],
            "comments": [],
            "return_type": "Evaluator",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/select/QueryParser.java.QueryParser.[String]consumeParens()",
        "name": "consumeParens",
        "arg_nums": 0,
        "params": [],
        "return_type": "String",
        "signature": "private String consumeParens()",
        "original_string": "    private String consumeParens() {\n        return tq.chompBalanced('(', ')');\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/select/QueryParser.java",
        "class_name": "QueryParser",
        "class_uri": "src/main/java/org/jsoup/select/QueryParser.java.QueryParser",
        "attributes": {
            "modifiers": "private",
            "marker_annotations": [],
            "non_marker_annotations": [
                "private"
            ],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/select/QueryParser.java.QueryParser.[int]consumeIndex()",
        "name": "consumeIndex",
        "arg_nums": 0,
        "params": [],
        "return_type": "int",
        "signature": "private int consumeIndex()",
        "original_string": "    private int consumeIndex() {\n        String index = consumeParens().trim();\n        Validate.isTrue(StringUtil.isNumeric(index), \"Index must be numeric\");\n        return Integer.parseInt(index);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/select/QueryParser.java",
        "class_name": "QueryParser",
        "class_uri": "src/main/java/org/jsoup/select/QueryParser.java.QueryParser",
        "attributes": {
            "modifiers": "private",
            "marker_annotations": [],
            "non_marker_annotations": [
                "private"
            ],
            "comments": [],
            "return_type": "int",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/select/QueryParser.java.QueryParser.[Evaluator]has()",
        "name": "has",
        "arg_nums": 0,
        "params": [],
        "return_type": "Evaluator",
        "signature": "private Evaluator has()",
        "original_string": "    private Evaluator has() {\n        String subQuery = consumeParens();\n        Validate.notEmpty(subQuery, \":has(selector) sub-select must not be empty\");\n        return new StructuralEvaluator.Has(parse(subQuery));\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/select/QueryParser.java",
        "class_name": "QueryParser",
        "class_uri": "src/main/java/org/jsoup/select/QueryParser.java.QueryParser",
        "attributes": {
            "modifiers": "private",
            "marker_annotations": [],
            "non_marker_annotations": [
                "private"
            ],
            "comments": [],
            "return_type": "Evaluator",
            "classes": []
        },
        "docstring": " pseudo selector :has(el)"
    },
    {
        "uris": "src/main/java/org/jsoup/select/QueryParser.java.QueryParser.[Evaluator]is()",
        "name": "is",
        "arg_nums": 0,
        "params": [],
        "return_type": "Evaluator",
        "signature": "private Evaluator is()",
        "original_string": "    private Evaluator is() {\n        String subQuery = consumeParens();\n        Validate.notEmpty(subQuery, \":is(selector) sub-select must not be empty\");\n        return new StructuralEvaluator.Is(parse(subQuery));\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/select/QueryParser.java",
        "class_name": "QueryParser",
        "class_uri": "src/main/java/org/jsoup/select/QueryParser.java.QueryParser",
        "attributes": {
            "modifiers": "private",
            "marker_annotations": [],
            "non_marker_annotations": [
                "private"
            ],
            "comments": [],
            "return_type": "Evaluator",
            "classes": []
        },
        "docstring": " psuedo selector :is()"
    },
    {
        "uris": "src/main/java/org/jsoup/select/QueryParser.java.QueryParser.[Evaluator]contains(boolean)",
        "name": "contains",
        "arg_nums": 1,
        "params": [
            {
                "name": "own",
                "type": "boolean"
            }
        ],
        "return_type": "Evaluator",
        "signature": "private Evaluator contains(boolean own)",
        "original_string": "    private Evaluator contains(boolean own) {\n        String query = own ? \":containsOwn\" : \":contains\";\n        String searchText = TokenQueue.unescape(consumeParens());\n        Validate.notEmpty(searchText, query + \"(text) query must not be empty\");\n        return own\n            ? new Evaluator.ContainsOwnText(searchText)\n            : new Evaluator.ContainsText(searchText);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/select/QueryParser.java",
        "class_name": "QueryParser",
        "class_uri": "src/main/java/org/jsoup/select/QueryParser.java.QueryParser",
        "attributes": {
            "modifiers": "private",
            "marker_annotations": [],
            "non_marker_annotations": [
                "private"
            ],
            "comments": [],
            "return_type": "Evaluator",
            "classes": []
        },
        "docstring": " pseudo selector :contains(text), containsOwn(text)"
    },
    {
        "uris": "src/main/java/org/jsoup/select/QueryParser.java.QueryParser.[Evaluator]containsWholeText(boolean)",
        "name": "containsWholeText",
        "arg_nums": 1,
        "params": [
            {
                "name": "own",
                "type": "boolean"
            }
        ],
        "return_type": "Evaluator",
        "signature": "private Evaluator containsWholeText(boolean own)",
        "original_string": "    private Evaluator containsWholeText(boolean own) {\n        String query = own ? \":containsWholeOwnText\" : \":containsWholeText\";\n        String searchText = TokenQueue.unescape(consumeParens());\n        Validate.notEmpty(searchText, query + \"(text) query must not be empty\");\n        return own\n            ? new Evaluator.ContainsWholeOwnText(searchText)\n            : new Evaluator.ContainsWholeText(searchText);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/select/QueryParser.java",
        "class_name": "QueryParser",
        "class_uri": "src/main/java/org/jsoup/select/QueryParser.java.QueryParser",
        "attributes": {
            "modifiers": "private",
            "marker_annotations": [],
            "non_marker_annotations": [
                "private"
            ],
            "comments": [],
            "return_type": "Evaluator",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/select/QueryParser.java.QueryParser.[Evaluator]containsData()",
        "name": "containsData",
        "arg_nums": 0,
        "params": [],
        "return_type": "Evaluator",
        "signature": "private Evaluator containsData()",
        "original_string": "    private Evaluator containsData() {\n        String searchText = TokenQueue.unescape(consumeParens());\n        Validate.notEmpty(searchText, \":containsData(text) query must not be empty\");\n        return new Evaluator.ContainsData(searchText);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/select/QueryParser.java",
        "class_name": "QueryParser",
        "class_uri": "src/main/java/org/jsoup/select/QueryParser.java.QueryParser",
        "attributes": {
            "modifiers": "private",
            "marker_annotations": [],
            "non_marker_annotations": [
                "private"
            ],
            "comments": [],
            "return_type": "Evaluator",
            "classes": []
        },
        "docstring": " pseudo selector :containsData(data)"
    },
    {
        "uris": "src/main/java/org/jsoup/select/QueryParser.java.QueryParser.[Evaluator]matches(boolean)",
        "name": "matches",
        "arg_nums": 1,
        "params": [
            {
                "name": "own",
                "type": "boolean"
            }
        ],
        "return_type": "Evaluator",
        "signature": "private Evaluator matches(boolean own)",
        "original_string": "    private Evaluator matches(boolean own) {\n        String query = own ? \":matchesOwn\" : \":matches\";\n        String regex = consumeParens(); // don't unescape, as regex bits will be escaped\n        Validate.notEmpty(regex, query + \"(regex) query must not be empty\");\n\n        return own\n            ? new Evaluator.MatchesOwn(Pattern.compile(regex))\n            : new Evaluator.Matches(Pattern.compile(regex));\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/select/QueryParser.java",
        "class_name": "QueryParser",
        "class_uri": "src/main/java/org/jsoup/select/QueryParser.java.QueryParser",
        "attributes": {
            "modifiers": "private",
            "marker_annotations": [],
            "non_marker_annotations": [
                "private"
            ],
            "comments": [],
            "return_type": "Evaluator",
            "classes": []
        },
        "docstring": " :matches(regex), matchesOwn(regex)"
    },
    {
        "uris": "src/main/java/org/jsoup/select/QueryParser.java.QueryParser.[Evaluator]matchesWholeText(boolean)",
        "name": "matchesWholeText",
        "arg_nums": 1,
        "params": [
            {
                "name": "own",
                "type": "boolean"
            }
        ],
        "return_type": "Evaluator",
        "signature": "private Evaluator matchesWholeText(boolean own)",
        "original_string": "    private Evaluator matchesWholeText(boolean own) {\n        String query = own ? \":matchesWholeOwnText\" : \":matchesWholeText\";\n        String regex = consumeParens(); // don't unescape, as regex bits will be escaped\n        Validate.notEmpty(regex, query + \"(regex) query must not be empty\");\n\n        return own\n            ? new Evaluator.MatchesWholeOwnText(Pattern.compile(regex))\n            : new Evaluator.MatchesWholeText(Pattern.compile(regex));\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/select/QueryParser.java",
        "class_name": "QueryParser",
        "class_uri": "src/main/java/org/jsoup/select/QueryParser.java.QueryParser",
        "attributes": {
            "modifiers": "private",
            "marker_annotations": [],
            "non_marker_annotations": [
                "private"
            ],
            "comments": [],
            "return_type": "Evaluator",
            "classes": []
        },
        "docstring": " :matches(regex), matchesOwn(regex)"
    },
    {
        "uris": "src/main/java/org/jsoup/select/QueryParser.java.QueryParser.[Evaluator]not()",
        "name": "not",
        "arg_nums": 0,
        "params": [],
        "return_type": "Evaluator",
        "signature": "private Evaluator not()",
        "original_string": "    private Evaluator not() {\n        String subQuery = consumeParens();\n        Validate.notEmpty(subQuery, \":not(selector) subselect must not be empty\");\n\n        return new StructuralEvaluator.Not(parse(subQuery));\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/select/QueryParser.java",
        "class_name": "QueryParser",
        "class_uri": "src/main/java/org/jsoup/select/QueryParser.java.QueryParser",
        "attributes": {
            "modifiers": "private",
            "marker_annotations": [],
            "non_marker_annotations": [
                "private"
            ],
            "comments": [],
            "return_type": "Evaluator",
            "classes": []
        },
        "docstring": " :not(selector)"
    },
    {
        "uris": "src/main/java/org/jsoup/select/QueryParser.java.QueryParser.[String]toString()",
        "name": "toString",
        "arg_nums": 0,
        "params": [],
        "return_type": "String",
        "signature": "@Override\n    public String toString()",
        "original_string": "    @Override\n    public String toString() {\n        return query;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/select/QueryParser.java",
        "class_name": "QueryParser",
        "class_uri": "src/main/java/org/jsoup/select/QueryParser.java.QueryParser",
        "attributes": {
            "modifiers": "@Override\n    public",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/select/StructuralEvaluator.java.StructuralEvaluator.[]StructuralEvaluator(Evaluator)",
        "name": "StructuralEvaluator",
        "arg_nums": 1,
        "params": [
            {
                "name": "evaluator",
                "type": "Evaluator"
            }
        ],
        "return_type": "",
        "signature": "public StructuralEvaluator(Evaluator evaluator)",
        "original_string": "    public StructuralEvaluator(Evaluator evaluator) {\n        this.evaluator = evaluator;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/select/StructuralEvaluator.java",
        "class_name": "StructuralEvaluator",
        "class_uri": "src/main/java/org/jsoup/select/StructuralEvaluator.java.StructuralEvaluator",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/select/StructuralEvaluator.java.StructuralEvaluator.[boolean]memoMatches(Element,Element)",
        "name": "memoMatches",
        "arg_nums": 2,
        "params": [
            {
                "name": "root",
                "type": "Element"
            },
            {
                "name": "element",
                "type": "Element"
            }
        ],
        "return_type": "boolean",
        "signature": "boolean memoMatches(final Element root, final Element element)",
        "original_string": "    boolean memoMatches(final Element root, final Element element) {\n        Map<Element, IdentityHashMap<Element, Boolean>> rootMemo = threadMemo.get();\n        Map<Element, Boolean> memo = rootMemo.computeIfAbsent(root, Functions.identityMapFunction());\n        return memo.computeIfAbsent(element, key -> evaluator.matches(root, key));\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/select/StructuralEvaluator.java",
        "class_name": "StructuralEvaluator",
        "class_uri": "src/main/java/org/jsoup/select/StructuralEvaluator.java.StructuralEvaluator",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/select/StructuralEvaluator.java.StructuralEvaluator.[void]reset()",
        "name": "reset",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "@Override protected void reset()",
        "original_string": "    @Override protected void reset() {\n        threadMemo.get().clear();\n        super.reset();\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/select/StructuralEvaluator.java",
        "class_name": "StructuralEvaluator",
        "class_uri": "src/main/java/org/jsoup/select/StructuralEvaluator.java.StructuralEvaluator",
        "attributes": {
            "modifiers": "@Override protected",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "protected"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/select/Selector.java.Selector.[]Selector()",
        "name": "Selector",
        "arg_nums": 0,
        "params": [],
        "return_type": "",
        "signature": "private Selector()",
        "original_string": "    private Selector() {}",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/select/Selector.java",
        "class_name": "Selector",
        "class_uri": "src/main/java/org/jsoup/select/Selector.java.Selector",
        "attributes": {
            "modifiers": "private",
            "marker_annotations": [],
            "non_marker_annotations": [
                "private"
            ],
            "comments": [],
            "return_type": "",
            "classes": []
        },
        "docstring": " not instantiable"
    },
    {
        "uris": "src/main/java/org/jsoup/select/Selector.java.Selector.[Elements]select(String,Element)",
        "name": "select",
        "arg_nums": 2,
        "params": [
            {
                "name": "query",
                "type": "String"
            },
            {
                "name": "root",
                "type": "Element"
            }
        ],
        "return_type": "Elements",
        "signature": "public static Elements select(String query, Element root)",
        "original_string": "    public static Elements select(String query, Element root) {\n        Validate.notEmpty(query);\n        return select(QueryParser.parse(query), root);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/select/Selector.java",
        "class_name": "Selector",
        "class_uri": "src/main/java/org/jsoup/select/Selector.java.Selector",
        "attributes": {
            "modifiers": "public static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public",
                "static"
            ],
            "comments": [],
            "return_type": "Elements",
            "classes": []
        },
        "docstring": "\nFind elements matching selector.\n\n@param query CSS selector\n@param root  root element to descend into\n@return matching elements, empty if none\n@throws Selector.SelectorParseException (unchecked) on an invalid CSS query.\n"
    },
    {
        "uris": "src/main/java/org/jsoup/select/Selector.java.Selector.[Elements]select(Evaluator,Element)",
        "name": "select",
        "arg_nums": 2,
        "params": [
            {
                "name": "evaluator",
                "type": "Evaluator"
            },
            {
                "name": "root",
                "type": "Element"
            }
        ],
        "return_type": "Elements",
        "signature": "public static Elements select(Evaluator evaluator, Element root)",
        "original_string": "    public static Elements select(Evaluator evaluator, Element root) {\n        Validate.notNull(evaluator);\n        Validate.notNull(root);\n        return Collector.collect(evaluator, root);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/select/Selector.java",
        "class_name": "Selector",
        "class_uri": "src/main/java/org/jsoup/select/Selector.java.Selector",
        "attributes": {
            "modifiers": "public static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public",
                "static"
            ],
            "comments": [],
            "return_type": "Elements",
            "classes": []
        },
        "docstring": "\nFind elements matching selector.\n\n@param evaluator CSS selector\n@param root root element to descend into\n@return matching elements, empty if none\n"
    },
    {
        "uris": "src/main/java/org/jsoup/select/Selector.java.Selector.[Elements]select(String,Iterable<Element>)",
        "name": "select",
        "arg_nums": 2,
        "params": [
            {
                "name": "query",
                "type": "String"
            },
            {
                "name": "roots",
                "type": "Iterable<Element>"
            }
        ],
        "return_type": "Elements",
        "signature": "public static Elements select(String query, Iterable<Element> roots)",
        "original_string": "    public static Elements select(String query, Iterable<Element> roots) {\n        Validate.notEmpty(query);\n        Validate.notNull(roots);\n        Evaluator evaluator = QueryParser.parse(query);\n        Elements elements = new Elements();\n        IdentityHashMap<Element, Boolean> seenElements = new IdentityHashMap<>();\n        // dedupe elements by identity, not equality\n\n        for (Element root : roots) {\n            final Elements found = select(evaluator, root);\n            for (Element el : found) {\n                if (seenElements.put(el, Boolean.TRUE) == null) {\n                    elements.add(el);\n                }\n            }\n        }\n        return elements;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/select/Selector.java",
        "class_name": "Selector",
        "class_uri": "src/main/java/org/jsoup/select/Selector.java.Selector",
        "attributes": {
            "modifiers": "public static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public",
                "static"
            ],
            "comments": [],
            "return_type": "Elements",
            "classes": []
        },
        "docstring": "\nFind elements matching selector.\n\n@param query CSS selector\n@param roots root elements to descend into\n@return matching elements, empty if none\n"
    },
    {
        "uris": "src/main/java/org/jsoup/select/Selector.java.Selector.[Elements]filterOut(Collection<Element>,Collection<Element>)",
        "name": "filterOut",
        "arg_nums": 2,
        "params": [
            {
                "name": "elements",
                "type": "Collection<Element>"
            },
            {
                "name": "outs",
                "type": "Collection<Element>"
            }
        ],
        "return_type": "Elements",
        "signature": "static Elements filterOut(Collection<Element> elements, Collection<Element> outs)",
        "original_string": "    static Elements filterOut(Collection<Element> elements, Collection<Element> outs) {\n        Elements output = new Elements();\n        for (Element el : elements) {\n            boolean found = false;\n            for (Element out : outs) {\n                if (el.equals(out)) {\n                    found = true;\n                    break;\n                }\n            }\n            if (!found)\n                output.add(el);\n        }\n        return output;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/select/Selector.java",
        "class_name": "Selector",
        "class_uri": "src/main/java/org/jsoup/select/Selector.java.Selector",
        "attributes": {
            "modifiers": "static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "static"
            ],
            "comments": [],
            "return_type": "Elements",
            "classes": []
        },
        "docstring": " exclude set. package open so that Elements can implement .not() selector."
    },
    {
        "uris": "src/main/java/org/jsoup/select/Selector.java.Selector.[Element]selectFirst(String,Element)",
        "name": "selectFirst",
        "arg_nums": 2,
        "params": [
            {
                "name": "cssQuery",
                "type": "String"
            },
            {
                "name": "root",
                "type": "Element"
            }
        ],
        "return_type": "Element",
        "signature": "public static @Nullable Element selectFirst(String cssQuery, Element root)",
        "original_string": "    public static @Nullable Element selectFirst(String cssQuery, Element root) {\n        Validate.notEmpty(cssQuery);\n        return Collector.findFirst(QueryParser.parse(cssQuery), root);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/select/Selector.java",
        "class_name": "Selector",
        "class_uri": "src/main/java/org/jsoup/select/Selector.java.Selector",
        "attributes": {
            "modifiers": "public static @Nullable",
            "marker_annotations": [
                "@Nullable"
            ],
            "non_marker_annotations": [
                "public",
                "static"
            ],
            "comments": [],
            "return_type": "Element",
            "classes": []
        },
        "docstring": "\nFind the first element that matches the query.\n@param cssQuery CSS selector\n@param root root element to descend into\n@return the matching element, or <b>null</b> if none.\n"
    },
    {
        "uris": "src/main/java/org/jsoup/select/Collector.java.Collector.[]Collector()",
        "name": "Collector",
        "arg_nums": 0,
        "params": [],
        "return_type": "",
        "signature": "private Collector()",
        "original_string": "    private Collector() {}",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/select/Collector.java",
        "class_name": "Collector",
        "class_uri": "src/main/java/org/jsoup/select/Collector.java.Collector",
        "attributes": {
            "modifiers": "private",
            "marker_annotations": [],
            "non_marker_annotations": [
                "private"
            ],
            "comments": [],
            "return_type": "",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/select/Collector.java.Collector.[Elements]collect(Evaluator,Element)",
        "name": "collect",
        "arg_nums": 2,
        "params": [
            {
                "name": "eval",
                "type": "Evaluator"
            },
            {
                "name": "root",
                "type": "Element"
            }
        ],
        "return_type": "Elements",
        "signature": "public static Elements collect (Evaluator eval, Element root)",
        "original_string": "    public static Elements collect (Evaluator eval, Element root) {\n        eval.reset();\n\n        return root.stream()\n            .filter(eval.asPredicate(root))\n            .collect(Collectors.toCollection(Elements::new));\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/select/Collector.java",
        "class_name": "Collector",
        "class_uri": "src/main/java/org/jsoup/select/Collector.java.Collector",
        "attributes": {
            "modifiers": "public static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public",
                "static"
            ],
            "comments": [],
            "return_type": "Elements",
            "classes": []
        },
        "docstring": "\nBuild a list of elements, by visiting root and every descendant of root, and testing it against the evaluator.\n@param eval Evaluator to test elements against\n@param root root of tree to descend\n@return list of matches; empty if none\n"
    },
    {
        "uris": "src/main/java/org/jsoup/select/Collector.java.Collector.[Element]findFirst(Evaluator,Element)",
        "name": "findFirst",
        "arg_nums": 2,
        "params": [
            {
                "name": "eval",
                "type": "Evaluator"
            },
            {
                "name": "root",
                "type": "Element"
            }
        ],
        "return_type": "Element",
        "signature": "public static @Nullable Element findFirst(Evaluator eval, Element root)",
        "original_string": "    public static @Nullable Element findFirst(Evaluator eval, Element root) {\n        eval.reset();\n\n        Optional<Element> first = root.stream().filter(eval.asPredicate(root)).findFirst();\n        return first.orElse(null);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/select/Collector.java",
        "class_name": "Collector",
        "class_uri": "src/main/java/org/jsoup/select/Collector.java.Collector",
        "attributes": {
            "modifiers": "public static @Nullable",
            "marker_annotations": [
                "@Nullable"
            ],
            "non_marker_annotations": [
                "public",
                "static"
            ],
            "comments": [],
            "return_type": "Element",
            "classes": []
        },
        "docstring": "\nFinds the first Element that matches the Evaluator that descends from the root, and stops the query once that first\nmatch is found.\n@param eval Evaluator to test elements against\n@param root root of tree to descend\n@return the first match; {@code null} if none\n"
    },
    {
        "uris": "src/main/java/org/jsoup/parser/ParseError.java.ParseError.[]ParseError(CharacterReader,String)",
        "name": "ParseError",
        "arg_nums": 2,
        "params": [
            {
                "name": "reader",
                "type": "CharacterReader"
            },
            {
                "name": "errorMsg",
                "type": "String"
            }
        ],
        "return_type": "",
        "signature": "ParseError(CharacterReader reader, String errorMsg)",
        "original_string": "    ParseError(CharacterReader reader, String errorMsg) {\n        pos = reader.pos();\n        cursorPos = reader.posLineCol();\n        this.errorMsg = errorMsg;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/ParseError.java",
        "class_name": "ParseError",
        "class_uri": "src/main/java/org/jsoup/parser/ParseError.java.ParseError",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/ParseError.java.ParseError.[]ParseError(CharacterReader,String)",
        "name": "ParseError",
        "arg_nums": 2,
        "params": [
            {
                "name": "reader",
                "type": "CharacterReader"
            },
            {
                "name": "errorFormat",
                "type": "String"
            }
        ],
        "return_type": "",
        "signature": "ParseError(CharacterReader reader, String errorFormat, Object... args)",
        "original_string": "    ParseError(CharacterReader reader, String errorFormat, Object... args) {\n        pos = reader.pos();\n        cursorPos = reader.posLineCol();\n        this.errorMsg = String.format(errorFormat, args);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/ParseError.java",
        "class_name": "ParseError",
        "class_uri": "src/main/java/org/jsoup/parser/ParseError.java.ParseError",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/ParseError.java.ParseError.[]ParseError(int,String)",
        "name": "ParseError",
        "arg_nums": 2,
        "params": [
            {
                "name": "pos",
                "type": "int"
            },
            {
                "name": "errorMsg",
                "type": "String"
            }
        ],
        "return_type": "",
        "signature": "ParseError(int pos, String errorMsg)",
        "original_string": "    ParseError(int pos, String errorMsg) {\n        this.pos = pos;\n        cursorPos = String.valueOf(pos);\n        this.errorMsg = errorMsg;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/ParseError.java",
        "class_name": "ParseError",
        "class_uri": "src/main/java/org/jsoup/parser/ParseError.java.ParseError",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/ParseError.java.ParseError.[]ParseError(int,String)",
        "name": "ParseError",
        "arg_nums": 2,
        "params": [
            {
                "name": "pos",
                "type": "int"
            },
            {
                "name": "errorFormat",
                "type": "String"
            }
        ],
        "return_type": "",
        "signature": "ParseError(int pos, String errorFormat, Object... args)",
        "original_string": "    ParseError(int pos, String errorFormat, Object... args) {\n        this.pos = pos;\n        cursorPos = String.valueOf(pos);\n        this.errorMsg = String.format(errorFormat, args);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/ParseError.java",
        "class_name": "ParseError",
        "class_uri": "src/main/java/org/jsoup/parser/ParseError.java.ParseError",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/ParseError.java.ParseError.[String]getErrorMessage()",
        "name": "getErrorMessage",
        "arg_nums": 0,
        "params": [],
        "return_type": "String",
        "signature": "public String getErrorMessage()",
        "original_string": "    public String getErrorMessage() {\n        return errorMsg;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/ParseError.java",
        "class_name": "ParseError",
        "class_uri": "src/main/java/org/jsoup/parser/ParseError.java.ParseError",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": "\nRetrieve the error message.\n@return the error message.\n"
    },
    {
        "uris": "src/main/java/org/jsoup/parser/ParseError.java.ParseError.[int]getPosition()",
        "name": "getPosition",
        "arg_nums": 0,
        "params": [],
        "return_type": "int",
        "signature": "public int getPosition()",
        "original_string": "    public int getPosition() {\n        return pos;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/ParseError.java",
        "class_name": "ParseError",
        "class_uri": "src/main/java/org/jsoup/parser/ParseError.java.ParseError",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "int",
            "classes": []
        },
        "docstring": "\nRetrieves the offset of the error.\n@return error offset within input\n"
    },
    {
        "uris": "src/main/java/org/jsoup/parser/ParseError.java.ParseError.[String]getCursorPos()",
        "name": "getCursorPos",
        "arg_nums": 0,
        "params": [],
        "return_type": "String",
        "signature": "public String getCursorPos()",
        "original_string": "    public String getCursorPos() {\n        return cursorPos;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/ParseError.java",
        "class_name": "ParseError",
        "class_uri": "src/main/java/org/jsoup/parser/ParseError.java.ParseError",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": "\nGet the formatted line:column cursor position where the error occurred.\n@return line:number cursor position\n"
    },
    {
        "uris": "src/main/java/org/jsoup/parser/ParseError.java.ParseError.[String]toString()",
        "name": "toString",
        "arg_nums": 0,
        "params": [],
        "return_type": "String",
        "signature": "@Override\n    public String toString()",
        "original_string": "    @Override\n    public String toString() {\n        return \"<\" + cursorPos + \">: \" + errorMsg;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/ParseError.java",
        "class_name": "ParseError",
        "class_uri": "src/main/java/org/jsoup/parser/ParseError.java.ParseError",
        "attributes": {
            "modifiers": "@Override\n    public",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/ParseErrorList.java.ParseErrorList.[]ParseErrorList(int,int)",
        "name": "ParseErrorList",
        "arg_nums": 2,
        "params": [
            {
                "name": "initialCapacity",
                "type": "int"
            },
            {
                "name": "maxSize",
                "type": "int"
            }
        ],
        "return_type": "",
        "signature": "ParseErrorList(int initialCapacity, int maxSize)",
        "original_string": "    ParseErrorList(int initialCapacity, int maxSize) {\n        super(initialCapacity);\n        this.initialCapacity = initialCapacity;\n        this.maxSize = maxSize;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/ParseErrorList.java",
        "class_name": "ParseErrorList",
        "class_uri": "src/main/java/org/jsoup/parser/ParseErrorList.java.ParseErrorList",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/ParseErrorList.java.ParseErrorList.[]ParseErrorList(ParseErrorList)",
        "name": "ParseErrorList",
        "arg_nums": 1,
        "params": [
            {
                "name": "copy",
                "type": "ParseErrorList"
            }
        ],
        "return_type": "",
        "signature": "ParseErrorList(ParseErrorList copy)",
        "original_string": "    ParseErrorList(ParseErrorList copy) {\n        this(copy.initialCapacity, copy.maxSize);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/ParseErrorList.java",
        "class_name": "ParseErrorList",
        "class_uri": "src/main/java/org/jsoup/parser/ParseErrorList.java.ParseErrorList",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "",
            "classes": []
        },
        "docstring": "\nCreate a new ParseErrorList with the same settings, but no errors in the list\n@param copy initial and max size details to copy\n"
    },
    {
        "uris": "src/main/java/org/jsoup/parser/ParseErrorList.java.ParseErrorList.[boolean]canAddError()",
        "name": "canAddError",
        "arg_nums": 0,
        "params": [],
        "return_type": "boolean",
        "signature": "boolean canAddError()",
        "original_string": "    boolean canAddError() {\n        return size() < maxSize;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/ParseErrorList.java",
        "class_name": "ParseErrorList",
        "class_uri": "src/main/java/org/jsoup/parser/ParseErrorList.java.ParseErrorList",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/ParseErrorList.java.ParseErrorList.[int]getMaxSize()",
        "name": "getMaxSize",
        "arg_nums": 0,
        "params": [],
        "return_type": "int",
        "signature": "int getMaxSize()",
        "original_string": "    int getMaxSize() {\n        return maxSize;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/ParseErrorList.java",
        "class_name": "ParseErrorList",
        "class_uri": "src/main/java/org/jsoup/parser/ParseErrorList.java.ParseErrorList",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "int",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/ParseErrorList.java.ParseErrorList.[ParseErrorList]noTracking()",
        "name": "noTracking",
        "arg_nums": 0,
        "params": [],
        "return_type": "ParseErrorList",
        "signature": "public static ParseErrorList noTracking()",
        "original_string": "    public static ParseErrorList noTracking() {\n        return new ParseErrorList(0, 0);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/ParseErrorList.java",
        "class_name": "ParseErrorList",
        "class_uri": "src/main/java/org/jsoup/parser/ParseErrorList.java.ParseErrorList",
        "attributes": {
            "modifiers": "public static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public",
                "static"
            ],
            "comments": [],
            "return_type": "ParseErrorList",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/ParseErrorList.java.ParseErrorList.[ParseErrorList]tracking(int)",
        "name": "tracking",
        "arg_nums": 1,
        "params": [
            {
                "name": "maxSize",
                "type": "int"
            }
        ],
        "return_type": "ParseErrorList",
        "signature": "public static ParseErrorList tracking(int maxSize)",
        "original_string": "    public static ParseErrorList tracking(int maxSize) {\n        return new ParseErrorList(INITIAL_CAPACITY, maxSize);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/ParseErrorList.java",
        "class_name": "ParseErrorList",
        "class_uri": "src/main/java/org/jsoup/parser/ParseErrorList.java.ParseErrorList",
        "attributes": {
            "modifiers": "public static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public",
                "static"
            ],
            "comments": [],
            "return_type": "ParseErrorList",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/ParseErrorList.java.ParseErrorList.[Object]clone()",
        "name": "clone",
        "arg_nums": 0,
        "params": [],
        "return_type": "Object",
        "signature": "@Override\n    public Object clone()",
        "original_string": "    @Override\n    public Object clone() {\n        // all class fields are primitive, so native clone is enough.\n        return super.clone();\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/ParseErrorList.java",
        "class_name": "ParseErrorList",
        "class_uri": "src/main/java/org/jsoup/parser/ParseErrorList.java.ParseErrorList",
        "attributes": {
            "modifiers": "@Override\n    public",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Object",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/ParseSettings.java.ParseSettings.[boolean]preserveTagCase()",
        "name": "preserveTagCase",
        "arg_nums": 0,
        "params": [],
        "return_type": "boolean",
        "signature": "public boolean preserveTagCase()",
        "original_string": "    public boolean preserveTagCase() {\n        return preserveTagCase;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/ParseSettings.java",
        "class_name": "ParseSettings",
        "class_uri": "src/main/java/org/jsoup/parser/ParseSettings.java.ParseSettings",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": "\nReturns true if preserving tag name case.\n"
    },
    {
        "uris": "src/main/java/org/jsoup/parser/ParseSettings.java.ParseSettings.[boolean]preserveAttributeCase()",
        "name": "preserveAttributeCase",
        "arg_nums": 0,
        "params": [],
        "return_type": "boolean",
        "signature": "public boolean preserveAttributeCase()",
        "original_string": "    public boolean preserveAttributeCase() {\n        return preserveAttributeCase;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/ParseSettings.java",
        "class_name": "ParseSettings",
        "class_uri": "src/main/java/org/jsoup/parser/ParseSettings.java.ParseSettings",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": "\nReturns true if preserving attribute case.\n"
    },
    {
        "uris": "src/main/java/org/jsoup/parser/ParseSettings.java.ParseSettings.[]ParseSettings(boolean,boolean)",
        "name": "ParseSettings",
        "arg_nums": 2,
        "params": [
            {
                "name": "tag",
                "type": "boolean"
            },
            {
                "name": "attribute",
                "type": "boolean"
            }
        ],
        "return_type": "",
        "signature": "public ParseSettings(boolean tag, boolean attribute)",
        "original_string": "    public ParseSettings(boolean tag, boolean attribute) {\n        preserveTagCase = tag;\n        preserveAttributeCase = attribute;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/ParseSettings.java",
        "class_name": "ParseSettings",
        "class_uri": "src/main/java/org/jsoup/parser/ParseSettings.java.ParseSettings",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "",
            "classes": []
        },
        "docstring": "\nDefine parse settings.\n@param tag preserve tag case?\n@param attribute preserve attribute name case?\n"
    },
    {
        "uris": "src/main/java/org/jsoup/parser/ParseSettings.java.ParseSettings.[]ParseSettings(ParseSettings)",
        "name": "ParseSettings",
        "arg_nums": 1,
        "params": [
            {
                "name": "copy",
                "type": "ParseSettings"
            }
        ],
        "return_type": "",
        "signature": "ParseSettings(ParseSettings copy)",
        "original_string": "    ParseSettings(ParseSettings copy) {\n        this(copy.preserveTagCase, copy.preserveAttributeCase);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/ParseSettings.java",
        "class_name": "ParseSettings",
        "class_uri": "src/main/java/org/jsoup/parser/ParseSettings.java.ParseSettings",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/ParseSettings.java.ParseSettings.[String]normalizeTag(String)",
        "name": "normalizeTag",
        "arg_nums": 1,
        "params": [
            {
                "name": "name",
                "type": "String"
            }
        ],
        "return_type": "String",
        "signature": "public String normalizeTag(String name)",
        "original_string": "    public String normalizeTag(String name) {\n        name = name.trim();\n        if (!preserveTagCase)\n            name = lowerCase(name);\n        return name;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/ParseSettings.java",
        "class_name": "ParseSettings",
        "class_uri": "src/main/java/org/jsoup/parser/ParseSettings.java.ParseSettings",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": "\nNormalizes a tag name according to the case preservation setting.\n"
    },
    {
        "uris": "src/main/java/org/jsoup/parser/ParseSettings.java.ParseSettings.[String]normalizeAttribute(String)",
        "name": "normalizeAttribute",
        "arg_nums": 1,
        "params": [
            {
                "name": "name",
                "type": "String"
            }
        ],
        "return_type": "String",
        "signature": "public String normalizeAttribute(String name)",
        "original_string": "    public String normalizeAttribute(String name) {\n        name = name.trim();\n        if (!preserveAttributeCase)\n            name = lowerCase(name);\n        return name;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/ParseSettings.java",
        "class_name": "ParseSettings",
        "class_uri": "src/main/java/org/jsoup/parser/ParseSettings.java.ParseSettings",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": "\nNormalizes an attribute according to the case preservation setting.\n"
    },
    {
        "uris": "src/main/java/org/jsoup/parser/ParseSettings.java.ParseSettings.[Attributes]normalizeAttributes(Attributes)",
        "name": "normalizeAttributes",
        "arg_nums": 1,
        "params": [
            {
                "name": "attributes",
                "type": "Attributes"
            }
        ],
        "return_type": "Attributes",
        "signature": "@Nullable Attributes normalizeAttributes(@Nullable Attributes attributes)",
        "original_string": "    @Nullable Attributes normalizeAttributes(@Nullable Attributes attributes) {\n        if (attributes != null && !preserveAttributeCase) {\n            attributes.normalize();\n        }\n        return attributes;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/ParseSettings.java",
        "class_name": "ParseSettings",
        "class_uri": "src/main/java/org/jsoup/parser/ParseSettings.java.ParseSettings",
        "attributes": {
            "modifiers": "@Nullable",
            "marker_annotations": [
                "@Nullable"
            ],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "Attributes",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/ParseSettings.java.ParseSettings.[String]normalName(String)",
        "name": "normalName",
        "arg_nums": 1,
        "params": [
            {
                "name": "name",
                "type": "String"
            }
        ],
        "return_type": "String",
        "signature": "static String normalName(String name)",
        "original_string": "    static String normalName(String name) {\n        return lowerCase(name.trim());\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/ParseSettings.java",
        "class_name": "ParseSettings",
        "class_uri": "src/main/java/org/jsoup/parser/ParseSettings.java.ParseSettings",
        "attributes": {
            "modifiers": "static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "static"
            ],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": " Returns the normal name that a Tag will have (trimmed and lower-cased)"
    },
    {
        "uris": "src/main/java/org/jsoup/parser/CharacterReader.java.CharacterReader.[]CharacterReader(Reader,int)",
        "name": "CharacterReader",
        "arg_nums": 2,
        "params": [
            {
                "name": "input",
                "type": "Reader"
            },
            {
                "name": "sz",
                "type": "int"
            }
        ],
        "return_type": "",
        "signature": "public CharacterReader(Reader input, int sz)",
        "original_string": "    public CharacterReader(Reader input, int sz) {\n        this(input); // sz is no longer used\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/CharacterReader.java",
        "class_name": "CharacterReader",
        "class_uri": "src/main/java/org/jsoup/parser/CharacterReader.java.CharacterReader",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "",
            "classes": []
        },
        "docstring": " line numbers start at 1; += newlinePosition[indexof(pos)]"
    },
    {
        "uris": "src/main/java/org/jsoup/parser/CharacterReader.java.CharacterReader.[]CharacterReader(Reader)",
        "name": "CharacterReader",
        "arg_nums": 1,
        "params": [
            {
                "name": "input",
                "type": "Reader"
            }
        ],
        "return_type": "",
        "signature": "public CharacterReader(Reader input)",
        "original_string": "    public CharacterReader(Reader input) {\n        Validate.notNull(input);\n        reader = input;\n        charBuf = BufferPool.borrow();\n        stringCache = StringPool.borrow();\n        bufferUp();\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/CharacterReader.java",
        "class_name": "CharacterReader",
        "class_uri": "src/main/java/org/jsoup/parser/CharacterReader.java.CharacterReader",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/CharacterReader.java.CharacterReader.[]CharacterReader(String)",
        "name": "CharacterReader",
        "arg_nums": 1,
        "params": [
            {
                "name": "input",
                "type": "String"
            }
        ],
        "return_type": "",
        "signature": "public CharacterReader(String input)",
        "original_string": "    public CharacterReader(String input) {\n        this(new StringReader(input));\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/CharacterReader.java",
        "class_name": "CharacterReader",
        "class_uri": "src/main/java/org/jsoup/parser/CharacterReader.java.CharacterReader",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/CharacterReader.java.CharacterReader.[void]close()",
        "name": "close",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "public void close()",
        "original_string": "    public void close() {\n        if (reader == null)\n            return;\n        try {\n            reader.close();\n        } catch (IOException ignored) {\n        } finally {\n            reader = null;\n            Arrays.fill(charBuf, (char) 0); // before release, clear the buffer. Not required, but acts as a safety net, and makes debug view clearer\n            BufferPool.release(charBuf);\n            charBuf = null;\n            StringPool.release(stringCache); // conversely, we don't clear the string cache, so we can reuse the contents\n            stringCache = null;\n        }\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/CharacterReader.java",
        "class_name": "CharacterReader",
        "class_uri": "src/main/java/org/jsoup/parser/CharacterReader.java.CharacterReader",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/CharacterReader.java.CharacterReader.[void]bufferUp()",
        "name": "bufferUp",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "private void bufferUp()",
        "original_string": "    private void bufferUp() {\n        if (readFully || bufPos < fillPoint || bufMark != -1)\n            return;\n        doBufferUp(); // structured so bufferUp may become an intrinsic candidate\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/CharacterReader.java",
        "class_name": "CharacterReader",
        "class_uri": "src/main/java/org/jsoup/parser/CharacterReader.java.CharacterReader",
        "attributes": {
            "modifiers": "private",
            "marker_annotations": [],
            "non_marker_annotations": [
                "private"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/CharacterReader.java.CharacterReader.[void]doBufferUp()",
        "name": "doBufferUp",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "private void doBufferUp()",
        "original_string": "    private void doBufferUp() {\n        /*\n        The flow:\n        - if read fully, or if bufPos < fillPoint, or if marked - do not fill.\n        - update readerPos (total amount consumed from this CharacterReader) += bufPos\n        - shift charBuf contents such that bufPos = 0; set next read offset (bufLength) -= shift amount\n        - loop read the Reader until we fill charBuf. bufLength += read.\n        - readFully = true when read = -1\n         */\n        consumed += bufPos;\n        bufLength -= bufPos;\n        if (bufLength > 0)\n            System.arraycopy(charBuf, bufPos, charBuf, 0, bufLength);\n        bufPos = 0;\n        while (bufLength < BufferSize) {\n            try {\n                int read = reader.read(charBuf, bufLength, charBuf.length - bufLength);\n                if (read == -1) {\n                    readFully = true;\n                    break;\n                }\n                bufLength += read;\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n        }\n        fillPoint = Math.min(bufLength, RefillPoint);\n\n        scanBufferForNewlines(); // if enabled, we index newline positions for line number tracking\n        lastIcSeq = null; // cache for last containsIgnoreCase(seq)\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/CharacterReader.java",
        "class_name": "CharacterReader",
        "class_uri": "src/main/java/org/jsoup/parser/CharacterReader.java.CharacterReader",
        "attributes": {
            "modifiers": "private",
            "marker_annotations": [],
            "non_marker_annotations": [
                "private"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/CharacterReader.java.CharacterReader.[void]mark()",
        "name": "mark",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "void mark()",
        "original_string": "    void mark() {\n        // make sure there is enough look ahead capacity\n        if (bufLength - bufPos < RewindLimit)\n            fillPoint = 0;\n\n        bufferUp();\n        bufMark = bufPos;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/CharacterReader.java",
        "class_name": "CharacterReader",
        "class_uri": "src/main/java/org/jsoup/parser/CharacterReader.java.CharacterReader",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/CharacterReader.java.CharacterReader.[void]unmark()",
        "name": "unmark",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "void unmark()",
        "original_string": "    void unmark() {\n        bufMark = -1;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/CharacterReader.java",
        "class_name": "CharacterReader",
        "class_uri": "src/main/java/org/jsoup/parser/CharacterReader.java.CharacterReader",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/CharacterReader.java.CharacterReader.[void]rewindToMark()",
        "name": "rewindToMark",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "void rewindToMark()",
        "original_string": "    void rewindToMark() {\n        if (bufMark == -1)\n            throw new UncheckedIOException(new IOException(\"Mark invalid\"));\n\n        bufPos = bufMark;\n        unmark();\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/CharacterReader.java",
        "class_name": "CharacterReader",
        "class_uri": "src/main/java/org/jsoup/parser/CharacterReader.java.CharacterReader",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/CharacterReader.java.CharacterReader.[int]pos()",
        "name": "pos",
        "arg_nums": 0,
        "params": [],
        "return_type": "int",
        "signature": "public int pos()",
        "original_string": "    public int pos() {\n        return consumed + bufPos;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/CharacterReader.java",
        "class_name": "CharacterReader",
        "class_uri": "src/main/java/org/jsoup/parser/CharacterReader.java.CharacterReader",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "int",
            "classes": []
        },
        "docstring": "\nGets the position currently read to in the content. Starts at 0.\n@return current position\n"
    },
    {
        "uris": "src/main/java/org/jsoup/parser/CharacterReader.java.CharacterReader.[boolean]readFully()",
        "name": "readFully",
        "arg_nums": 0,
        "params": [],
        "return_type": "boolean",
        "signature": "boolean readFully()",
        "original_string": "    boolean readFully() {\n        return readFully;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/CharacterReader.java",
        "class_name": "CharacterReader",
        "class_uri": "src/main/java/org/jsoup/parser/CharacterReader.java.CharacterReader",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": " Tests if the buffer has been fully read."
    },
    {
        "uris": "src/main/java/org/jsoup/parser/CharacterReader.java.CharacterReader.[void]trackNewlines(boolean)",
        "name": "trackNewlines",
        "arg_nums": 1,
        "params": [
            {
                "name": "track",
                "type": "boolean"
            }
        ],
        "return_type": "void",
        "signature": "public void trackNewlines(boolean track)",
        "original_string": "    public void trackNewlines(boolean track) {\n        if (track && newlinePositions == null) {\n            newlinePositions = new ArrayList<>(BufferSize / 80); // rough guess of likely count\n            scanBufferForNewlines(); // first pass when enabled; subsequently called during bufferUp\n        }\n        else if (!track)\n            newlinePositions = null;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/CharacterReader.java",
        "class_name": "CharacterReader",
        "class_uri": "src/main/java/org/jsoup/parser/CharacterReader.java.CharacterReader",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": "\nEnables or disables line number tracking. By default, will be <b>off</b>.Tracking line numbers improves the\nlegibility of parser error messages, for example. Tracking should be enabled before any content is read to be of\nuse.\n\n@param track set tracking on|off\n@since 1.14.3\n"
    },
    {
        "uris": "src/main/java/org/jsoup/parser/CharacterReader.java.CharacterReader.[boolean]isTrackNewlines()",
        "name": "isTrackNewlines",
        "arg_nums": 0,
        "params": [],
        "return_type": "boolean",
        "signature": "public boolean isTrackNewlines()",
        "original_string": "    public boolean isTrackNewlines() {\n        return newlinePositions != null;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/CharacterReader.java",
        "class_name": "CharacterReader",
        "class_uri": "src/main/java/org/jsoup/parser/CharacterReader.java.CharacterReader",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": "\nCheck if the tracking of newlines is enabled.\n@return the current newline tracking state\n@since 1.14.3\n"
    },
    {
        "uris": "src/main/java/org/jsoup/parser/CharacterReader.java.CharacterReader.[int]lineNumber()",
        "name": "lineNumber",
        "arg_nums": 0,
        "params": [],
        "return_type": "int",
        "signature": "public int lineNumber()",
        "original_string": "    public int lineNumber() {\n        return lineNumber(pos());\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/CharacterReader.java",
        "class_name": "CharacterReader",
        "class_uri": "src/main/java/org/jsoup/parser/CharacterReader.java.CharacterReader",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "int",
            "classes": []
        },
        "docstring": "\nGet the current line number (that the reader has consumed to). Starts at line #1.\n@return the current line number, or 1 if line tracking is not enabled.\n@since 1.14.3\n@see #trackNewlines(boolean)\n"
    },
    {
        "uris": "src/main/java/org/jsoup/parser/CharacterReader.java.CharacterReader.[int]lineNumber(int)",
        "name": "lineNumber",
        "arg_nums": 1,
        "params": [
            {
                "name": "pos",
                "type": "int"
            }
        ],
        "return_type": "int",
        "signature": "int lineNumber(int pos)",
        "original_string": "    int lineNumber(int pos) {\n        // note that this impl needs to be called before the next buffer up or line numberoffset will be wrong. if that\n        // causes issues, can remove the reset of newlinepositions during buffer, at the cost of a larger tracking array\n        if (!isTrackNewlines())\n            return 1;\n\n        int i = lineNumIndex(pos);\n        if (i == -1)\n            return lineNumberOffset; // first line\n        return i + lineNumberOffset + 1;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/CharacterReader.java",
        "class_name": "CharacterReader",
        "class_uri": "src/main/java/org/jsoup/parser/CharacterReader.java.CharacterReader",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "int",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/CharacterReader.java.CharacterReader.[int]columnNumber()",
        "name": "columnNumber",
        "arg_nums": 0,
        "params": [],
        "return_type": "int",
        "signature": "public int columnNumber()",
        "original_string": "    public int columnNumber() {\n        return columnNumber(pos());\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/CharacterReader.java",
        "class_name": "CharacterReader",
        "class_uri": "src/main/java/org/jsoup/parser/CharacterReader.java.CharacterReader",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "int",
            "classes": []
        },
        "docstring": "\nGet the current column number (that the reader has consumed to). Starts at column #1.\n@return the current column number\n@since 1.14.3\n@see #trackNewlines(boolean)\n"
    },
    {
        "uris": "src/main/java/org/jsoup/parser/CharacterReader.java.CharacterReader.[int]columnNumber(int)",
        "name": "columnNumber",
        "arg_nums": 1,
        "params": [
            {
                "name": "pos",
                "type": "int"
            }
        ],
        "return_type": "int",
        "signature": "int columnNumber(int pos)",
        "original_string": "    int columnNumber(int pos) {\n        if (!isTrackNewlines())\n            return pos + 1;\n\n        int i = lineNumIndex(pos);\n        if (i == -1)\n          return pos + 1;\n        return pos - newlinePositions.get(i) + 1;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/CharacterReader.java",
        "class_name": "CharacterReader",
        "class_uri": "src/main/java/org/jsoup/parser/CharacterReader.java.CharacterReader",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "int",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/CharacterReader.java.CharacterReader.[String]posLineCol()",
        "name": "posLineCol",
        "arg_nums": 0,
        "params": [],
        "return_type": "String",
        "signature": "String posLineCol()",
        "original_string": "    String posLineCol() {\n        return lineNumber() + \":\" + columnNumber();\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/CharacterReader.java",
        "class_name": "CharacterReader",
        "class_uri": "src/main/java/org/jsoup/parser/CharacterReader.java.CharacterReader",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": "\nGet a formatted string representing the current line and column positions. E.g. <code>5:10</code> indicating line\nnumber 5 and column number 10.\n@return line:col position\n@since 1.14.3\n@see #trackNewlines(boolean)\n"
    },
    {
        "uris": "src/main/java/org/jsoup/parser/CharacterReader.java.CharacterReader.[int]lineNumIndex(int)",
        "name": "lineNumIndex",
        "arg_nums": 1,
        "params": [
            {
                "name": "pos",
                "type": "int"
            }
        ],
        "return_type": "int",
        "signature": "private int lineNumIndex(int pos)",
        "original_string": "    private int lineNumIndex(int pos) {\n        if (!isTrackNewlines()) return 0;\n        int i = Collections.binarySearch(newlinePositions, pos);\n        if (i < -1) i = Math.abs(i) - 2;\n        return i;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/CharacterReader.java",
        "class_name": "CharacterReader",
        "class_uri": "src/main/java/org/jsoup/parser/CharacterReader.java.CharacterReader",
        "attributes": {
            "modifiers": "private",
            "marker_annotations": [],
            "non_marker_annotations": [
                "private"
            ],
            "comments": [],
            "return_type": "int",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/CharacterReader.java.CharacterReader.[void]scanBufferForNewlines()",
        "name": "scanBufferForNewlines",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "private void scanBufferForNewlines()",
        "original_string": "    private void scanBufferForNewlines() {\n        if (!isTrackNewlines())\n            return;\n\n        if (newlinePositions.size() > 0) {\n            // work out the line number that we have read up to (as we have likely scanned past this point)\n            int index = lineNumIndex(consumed);\n            if (index == -1) index = 0; // first line\n            int linePos = newlinePositions.get(index);\n            lineNumberOffset += index; // the num lines we've read up to\n            newlinePositions.clear();\n            newlinePositions.add(linePos); // roll the last read pos to first, for cursor num after buffer\n        }\n\n        for (int i = bufPos; i < bufLength; i++) {\n            if (charBuf[i] == '\\n')\n                newlinePositions.add(1 + consumed + i);\n        }\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/CharacterReader.java",
        "class_name": "CharacterReader",
        "class_uri": "src/main/java/org/jsoup/parser/CharacterReader.java.CharacterReader",
        "attributes": {
            "modifiers": "private",
            "marker_annotations": [],
            "non_marker_annotations": [
                "private"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": "\nScans the buffer for newline position, and tracks their location in newlinePositions.\n"
    },
    {
        "uris": "src/main/java/org/jsoup/parser/CharacterReader.java.CharacterReader.[boolean]isEmpty()",
        "name": "isEmpty",
        "arg_nums": 0,
        "params": [],
        "return_type": "boolean",
        "signature": "public boolean isEmpty()",
        "original_string": "    public boolean isEmpty() {\n        bufferUp();\n        return bufPos >= bufLength;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/CharacterReader.java",
        "class_name": "CharacterReader",
        "class_uri": "src/main/java/org/jsoup/parser/CharacterReader.java.CharacterReader",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": "\nTests if all the content has been read.\n@return true if nothing left to read.\n"
    },
    {
        "uris": "src/main/java/org/jsoup/parser/CharacterReader.java.CharacterReader.[boolean]isEmptyNoBufferUp()",
        "name": "isEmptyNoBufferUp",
        "arg_nums": 0,
        "params": [],
        "return_type": "boolean",
        "signature": "private boolean isEmptyNoBufferUp()",
        "original_string": "    private boolean isEmptyNoBufferUp() {\n        return bufPos >= bufLength;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/CharacterReader.java",
        "class_name": "CharacterReader",
        "class_uri": "src/main/java/org/jsoup/parser/CharacterReader.java.CharacterReader",
        "attributes": {
            "modifiers": "private",
            "marker_annotations": [],
            "non_marker_annotations": [
                "private"
            ],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/CharacterReader.java.CharacterReader.[char]current()",
        "name": "current",
        "arg_nums": 0,
        "params": [],
        "return_type": "char",
        "signature": "public char current()",
        "original_string": "    public char current() {\n        bufferUp();\n        return isEmptyNoBufferUp() ? EOF : charBuf[bufPos];\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/CharacterReader.java",
        "class_name": "CharacterReader",
        "class_uri": "src/main/java/org/jsoup/parser/CharacterReader.java.CharacterReader",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "char",
            "classes": []
        },
        "docstring": "\nGet the char at the current position.\n@return char\n"
    },
    {
        "uris": "src/main/java/org/jsoup/parser/CharacterReader.java.CharacterReader.[char]consume()",
        "name": "consume",
        "arg_nums": 0,
        "params": [],
        "return_type": "char",
        "signature": "char consume()",
        "original_string": "    char consume() {\n        bufferUp();\n        char val = isEmptyNoBufferUp() ? EOF : charBuf[bufPos];\n        bufPos++;\n        return val;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/CharacterReader.java",
        "class_name": "CharacterReader",
        "class_uri": "src/main/java/org/jsoup/parser/CharacterReader.java.CharacterReader",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "char",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/CharacterReader.java.CharacterReader.[void]unconsume()",
        "name": "unconsume",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "void unconsume()",
        "original_string": "    void unconsume() {\n        if (bufPos < 1)\n            throw new UncheckedIOException(new IOException(\"WTF: No buffer left to unconsume.\")); // a bug if this fires, need to trace it.\n\n        bufPos--;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/CharacterReader.java",
        "class_name": "CharacterReader",
        "class_uri": "src/main/java/org/jsoup/parser/CharacterReader.java.CharacterReader",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": "\nUnconsume one character (bufPos--). MUST only be called directly after a consume(), and no chance of a bufferUp.\n"
    },
    {
        "uris": "src/main/java/org/jsoup/parser/CharacterReader.java.CharacterReader.[void]advance()",
        "name": "advance",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "public void advance()",
        "original_string": "    public void advance() {\n        bufPos++;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/CharacterReader.java",
        "class_name": "CharacterReader",
        "class_uri": "src/main/java/org/jsoup/parser/CharacterReader.java.CharacterReader",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": "\nMoves the current position by one.\n"
    },
    {
        "uris": "src/main/java/org/jsoup/parser/CharacterReader.java.CharacterReader.[int]nextIndexOf(char)",
        "name": "nextIndexOf",
        "arg_nums": 1,
        "params": [
            {
                "name": "c",
                "type": "char"
            }
        ],
        "return_type": "int",
        "signature": "int nextIndexOf(char c)",
        "original_string": "    int nextIndexOf(char c) {\n        // doesn't handle scanning for surrogates\n        bufferUp();\n        for (int i = bufPos; i < bufLength; i++) {\n            if (c == charBuf[i])\n                return i - bufPos;\n        }\n        return -1;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/CharacterReader.java",
        "class_name": "CharacterReader",
        "class_uri": "src/main/java/org/jsoup/parser/CharacterReader.java.CharacterReader",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "int",
            "classes": []
        },
        "docstring": "\nReturns the number of characters between the current position and the next instance of the input char\n@param c scan target\n@return offset between current position and next instance of target. -1 if not found.\n"
    },
    {
        "uris": "src/main/java/org/jsoup/parser/CharacterReader.java.CharacterReader.[int]nextIndexOf(CharSequence)",
        "name": "nextIndexOf",
        "arg_nums": 1,
        "params": [
            {
                "name": "seq",
                "type": "CharSequence"
            }
        ],
        "return_type": "int",
        "signature": "int nextIndexOf(CharSequence seq)",
        "original_string": "    int nextIndexOf(CharSequence seq) {\n        bufferUp();\n        // doesn't handle scanning for surrogates\n        char startChar = seq.charAt(0);\n        for (int offset = bufPos; offset < bufLength; offset++) {\n            // scan to first instance of startchar:\n            if (startChar != charBuf[offset])\n                while(++offset < bufLength && startChar != charBuf[offset]) { /* empty */ }\n            int i = offset + 1;\n            int last = i + seq.length()-1;\n            if (offset < bufLength && last <= bufLength) {\n                for (int j = 1; i < last && seq.charAt(j) == charBuf[i]; i++, j++) { /* empty */ }\n                if (i == last) // found full sequence\n                    return offset - bufPos;\n            }\n        }\n        return -1;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/CharacterReader.java",
        "class_name": "CharacterReader",
        "class_uri": "src/main/java/org/jsoup/parser/CharacterReader.java.CharacterReader",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "int",
            "classes": []
        },
        "docstring": "\nReturns the number of characters between the current position and the next instance of the input sequence\n\n@param seq scan target\n@return offset between current position and next instance of target. -1 if not found.\n"
    },
    {
        "uris": "src/main/java/org/jsoup/parser/CharacterReader.java.CharacterReader.[String]consumeTo(char)",
        "name": "consumeTo",
        "arg_nums": 1,
        "params": [
            {
                "name": "c",
                "type": "char"
            }
        ],
        "return_type": "String",
        "signature": "public String consumeTo(char c)",
        "original_string": "    public String consumeTo(char c) {\n        int offset = nextIndexOf(c);\n        if (offset != -1) {\n            String consumed = cacheString(charBuf, stringCache, bufPos, offset);\n            bufPos += offset;\n            return consumed;\n        } else {\n            return consumeToEnd();\n        }\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/CharacterReader.java",
        "class_name": "CharacterReader",
        "class_uri": "src/main/java/org/jsoup/parser/CharacterReader.java.CharacterReader",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": "\nReads characters up to the specific char.\n@param c the delimiter\n@return the chars read\n"
    },
    {
        "uris": "src/main/java/org/jsoup/parser/CharacterReader.java.CharacterReader.[String]consumeTo(String)",
        "name": "consumeTo",
        "arg_nums": 1,
        "params": [
            {
                "name": "seq",
                "type": "String"
            }
        ],
        "return_type": "String",
        "signature": "String consumeTo(String seq)",
        "original_string": "    String consumeTo(String seq) {\n        int offset = nextIndexOf(seq);\n        if (offset != -1) {\n            String consumed = cacheString(charBuf, stringCache, bufPos, offset);\n            bufPos += offset;\n            return consumed;\n        } else if (bufLength - bufPos < seq.length()) {\n            // nextIndexOf() did a bufferUp(), so if the buffer is shorter than the search string, we must be at EOF\n            return consumeToEnd();\n        } else {\n            // the string we're looking for may be straddling a buffer boundary, so keep (length - 1) characters\n            // unread in case they contain the beginning of the search string\n            int endPos = bufLength - seq.length() + 1;\n            String consumed = cacheString(charBuf, stringCache, bufPos, endPos - bufPos);\n            bufPos = endPos;\n            return consumed;\n        }\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/CharacterReader.java",
        "class_name": "CharacterReader",
        "class_uri": "src/main/java/org/jsoup/parser/CharacterReader.java.CharacterReader",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/CharacterReader.java.CharacterReader.[String]consumeToAny()",
        "name": "consumeToAny",
        "arg_nums": 0,
        "params": [],
        "return_type": "String",
        "signature": "public String consumeToAny(final char... chars)",
        "original_string": "    public String consumeToAny(final char... chars) {\n        bufferUp();\n        int pos = bufPos;\n        final int start = pos;\n        final int remaining = bufLength;\n        final char[] val = charBuf;\n        final int charLen = chars.length;\n        int i;\n\n        OUTER: while (pos < remaining) {\n            for (i = 0; i < charLen; i++) {\n                if (val[pos] == chars[i])\n                    break OUTER;\n            }\n            pos++;\n        }\n\n        bufPos = pos;\n        return pos > start ? cacheString(charBuf, stringCache, start, pos -start) : \"\";\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/CharacterReader.java",
        "class_name": "CharacterReader",
        "class_uri": "src/main/java/org/jsoup/parser/CharacterReader.java.CharacterReader",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": "\nRead characters until the first of any delimiters is found.\n@param chars delimiters to scan for\n@return characters read up to the matched delimiter.\n"
    },
    {
        "uris": "src/main/java/org/jsoup/parser/CharacterReader.java.CharacterReader.[String]consumeToAnySorted()",
        "name": "consumeToAnySorted",
        "arg_nums": 0,
        "params": [],
        "return_type": "String",
        "signature": "String consumeToAnySorted(final char... chars)",
        "original_string": "    String consumeToAnySorted(final char... chars) {\n        bufferUp();\n        int pos = bufPos;\n        final int start = pos;\n        final int remaining = bufLength;\n        final char[] val = charBuf;\n\n        while (pos < remaining) {\n            if (Arrays.binarySearch(chars, val[pos]) >= 0)\n                break;\n            pos++;\n        }\n        bufPos = pos;\n        return bufPos > start ? cacheString(charBuf, stringCache, start, pos -start) : \"\";\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/CharacterReader.java",
        "class_name": "CharacterReader",
        "class_uri": "src/main/java/org/jsoup/parser/CharacterReader.java.CharacterReader",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/CharacterReader.java.CharacterReader.[String]consumeData()",
        "name": "consumeData",
        "arg_nums": 0,
        "params": [],
        "return_type": "String",
        "signature": "String consumeData()",
        "original_string": "    String consumeData() {\n        // &, <, null\n        //bufferUp(); // no need to bufferUp, just called consume()\n        int pos = bufPos;\n        final int start = pos;\n        final int remaining = bufLength;\n        final char[] val = charBuf;\n\n        OUTER: while (pos < remaining) {\n            switch (val[pos]) {\n                case '&':\n                case '<':\n                case TokeniserState.nullChar:\n                    break OUTER;\n                default:\n                    pos++;\n            }\n        }\n        bufPos = pos;\n        return pos > start ? cacheString(charBuf, stringCache, start, pos -start) : \"\";\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/CharacterReader.java",
        "class_name": "CharacterReader",
        "class_uri": "src/main/java/org/jsoup/parser/CharacterReader.java.CharacterReader",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/CharacterReader.java.CharacterReader.[String]consumeAttributeQuoted(boolean)",
        "name": "consumeAttributeQuoted",
        "arg_nums": 1,
        "params": [
            {
                "name": "single",
                "type": "boolean"
            }
        ],
        "return_type": "String",
        "signature": "String consumeAttributeQuoted(final boolean single)",
        "original_string": "    String consumeAttributeQuoted(final boolean single) {\n        // null, \" or ', &\n        //bufferUp(); // no need to bufferUp, just called consume()\n        int pos = bufPos;\n        final int start = pos;\n        final int remaining = bufLength;\n        final char[] val = charBuf;\n\n        OUTER: while (pos < remaining) {\n            switch (val[pos]) {\n                case '&':\n                case TokeniserState.nullChar:\n                    break OUTER;\n                case '\\'':\n                    if (single) break OUTER;\n                    break;\n                case '\"':\n                    if (!single) break OUTER;\n                    break;\n            }\n            pos++;\n        }\n        bufPos = pos;\n        return pos > start ? cacheString(charBuf, stringCache, start, pos -start) : \"\";\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/CharacterReader.java",
        "class_name": "CharacterReader",
        "class_uri": "src/main/java/org/jsoup/parser/CharacterReader.java.CharacterReader",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/CharacterReader.java.CharacterReader.[String]consumeRawData()",
        "name": "consumeRawData",
        "arg_nums": 0,
        "params": [],
        "return_type": "String",
        "signature": "String consumeRawData()",
        "original_string": "    String consumeRawData() {\n        // <, null\n        //bufferUp(); // no need to bufferUp, just called consume()\n        int pos = bufPos;\n        final int start = pos;\n        final int remaining = bufLength;\n        final char[] val = charBuf;\n\n        OUTER: while (pos < remaining) {\n            switch (val[pos]) {\n                case '<':\n                case TokeniserState.nullChar:\n                    break OUTER;\n                default:\n                    pos++;\n            }\n        }\n        bufPos = pos;\n        return pos > start ? cacheString(charBuf, stringCache, start, pos -start) : \"\";\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/CharacterReader.java",
        "class_name": "CharacterReader",
        "class_uri": "src/main/java/org/jsoup/parser/CharacterReader.java.CharacterReader",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/CharacterReader.java.CharacterReader.[String]consumeTagName()",
        "name": "consumeTagName",
        "arg_nums": 0,
        "params": [],
        "return_type": "String",
        "signature": "String consumeTagName()",
        "original_string": "    String consumeTagName() {\n        // '\\t', '\\n', '\\r', '\\f', ' ', '/', '>'\n        // NOTE: out of spec, added '<' to fix common author bugs; does not stop and append on nullChar but eats\n        bufferUp();\n        int pos = bufPos;\n        final int start = pos;\n        final int remaining = bufLength;\n        final char[] val = charBuf;\n\n        OUTER: while (pos < remaining) {\n            switch (val[pos]) {\n                case '\\t':\n                case '\\n':\n                case '\\r':\n                case '\\f':\n                case ' ':\n                case '/':\n                case '>':\n                case '<':\n                    break OUTER;\n            }\n            pos++;\n        }\n\n        bufPos = pos;\n        return pos > start ? cacheString(charBuf, stringCache, start, pos -start) : \"\";\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/CharacterReader.java",
        "class_name": "CharacterReader",
        "class_uri": "src/main/java/org/jsoup/parser/CharacterReader.java.CharacterReader",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/CharacterReader.java.CharacterReader.[String]consumeToEnd()",
        "name": "consumeToEnd",
        "arg_nums": 0,
        "params": [],
        "return_type": "String",
        "signature": "String consumeToEnd()",
        "original_string": "    String consumeToEnd() {\n        bufferUp();\n        String data = cacheString(charBuf, stringCache, bufPos, bufLength - bufPos);\n        bufPos = bufLength;\n        return data;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/CharacterReader.java",
        "class_name": "CharacterReader",
        "class_uri": "src/main/java/org/jsoup/parser/CharacterReader.java.CharacterReader",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/CharacterReader.java.CharacterReader.[String]consumeLetterSequence()",
        "name": "consumeLetterSequence",
        "arg_nums": 0,
        "params": [],
        "return_type": "String",
        "signature": "String consumeLetterSequence()",
        "original_string": "    String consumeLetterSequence() {\n        bufferUp();\n        int start = bufPos;\n        while (bufPos < bufLength) {\n            char c = charBuf[bufPos];\n            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || Character.isLetter(c))\n                bufPos++;\n            else\n                break;\n        }\n\n        return cacheString(charBuf, stringCache, start, bufPos - start);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/CharacterReader.java",
        "class_name": "CharacterReader",
        "class_uri": "src/main/java/org/jsoup/parser/CharacterReader.java.CharacterReader",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/CharacterReader.java.CharacterReader.[String]consumeLetterThenDigitSequence()",
        "name": "consumeLetterThenDigitSequence",
        "arg_nums": 0,
        "params": [],
        "return_type": "String",
        "signature": "String consumeLetterThenDigitSequence()",
        "original_string": "    String consumeLetterThenDigitSequence() {\n        bufferUp();\n        int start = bufPos;\n        while (bufPos < bufLength) {\n            char c = charBuf[bufPos];\n            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || Character.isLetter(c))\n                bufPos++;\n            else\n                break;\n        }\n        while (!isEmptyNoBufferUp()) {\n            char c = charBuf[bufPos];\n            if (c >= '0' && c <= '9')\n                bufPos++;\n            else\n                break;\n        }\n\n        return cacheString(charBuf, stringCache, start, bufPos - start);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/CharacterReader.java",
        "class_name": "CharacterReader",
        "class_uri": "src/main/java/org/jsoup/parser/CharacterReader.java.CharacterReader",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/CharacterReader.java.CharacterReader.[String]consumeHexSequence()",
        "name": "consumeHexSequence",
        "arg_nums": 0,
        "params": [],
        "return_type": "String",
        "signature": "String consumeHexSequence()",
        "original_string": "    String consumeHexSequence() {\n        bufferUp();\n        int start = bufPos;\n        while (bufPos < bufLength) {\n            char c = charBuf[bufPos];\n            if ((c >= '0' && c <= '9') || (c >= 'A' && c <= 'F') || (c >= 'a' && c <= 'f'))\n                bufPos++;\n            else\n                break;\n        }\n        return cacheString(charBuf, stringCache, start, bufPos - start);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/CharacterReader.java",
        "class_name": "CharacterReader",
        "class_uri": "src/main/java/org/jsoup/parser/CharacterReader.java.CharacterReader",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/CharacterReader.java.CharacterReader.[String]consumeDigitSequence()",
        "name": "consumeDigitSequence",
        "arg_nums": 0,
        "params": [],
        "return_type": "String",
        "signature": "String consumeDigitSequence()",
        "original_string": "    String consumeDigitSequence() {\n        bufferUp();\n        int start = bufPos;\n        while (bufPos < bufLength) {\n            char c = charBuf[bufPos];\n            if (c >= '0' && c <= '9')\n                bufPos++;\n            else\n                break;\n        }\n        return cacheString(charBuf, stringCache, start, bufPos - start);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/CharacterReader.java",
        "class_name": "CharacterReader",
        "class_uri": "src/main/java/org/jsoup/parser/CharacterReader.java.CharacterReader",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/CharacterReader.java.CharacterReader.[boolean]matches(char)",
        "name": "matches",
        "arg_nums": 1,
        "params": [
            {
                "name": "c",
                "type": "char"
            }
        ],
        "return_type": "boolean",
        "signature": "boolean matches(char c)",
        "original_string": "    boolean matches(char c) {\n        return !isEmpty() && charBuf[bufPos] == c;\n\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/CharacterReader.java",
        "class_name": "CharacterReader",
        "class_uri": "src/main/java/org/jsoup/parser/CharacterReader.java.CharacterReader",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/CharacterReader.java.CharacterReader.[boolean]matches(String)",
        "name": "matches",
        "arg_nums": 1,
        "params": [
            {
                "name": "seq",
                "type": "String"
            }
        ],
        "return_type": "boolean",
        "signature": "boolean matches(String seq)",
        "original_string": "    boolean matches(String seq) {\n        bufferUp();\n        int scanLength = seq.length();\n        if (scanLength > bufLength - bufPos)\n            return false;\n\n        for (int offset = 0; offset < scanLength; offset++)\n            if (seq.charAt(offset) != charBuf[bufPos +offset])\n                return false;\n        return true;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/CharacterReader.java",
        "class_name": "CharacterReader",
        "class_uri": "src/main/java/org/jsoup/parser/CharacterReader.java.CharacterReader",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/CharacterReader.java.CharacterReader.[boolean]matchesIgnoreCase(String)",
        "name": "matchesIgnoreCase",
        "arg_nums": 1,
        "params": [
            {
                "name": "seq",
                "type": "String"
            }
        ],
        "return_type": "boolean",
        "signature": "boolean matchesIgnoreCase(String seq)",
        "original_string": "    boolean matchesIgnoreCase(String seq) {\n        bufferUp();\n        int scanLength = seq.length();\n        if (scanLength > bufLength - bufPos)\n            return false;\n\n        for (int offset = 0; offset < scanLength; offset++) {\n            char upScan = Character.toUpperCase(seq.charAt(offset));\n            char upTarget = Character.toUpperCase(charBuf[bufPos + offset]);\n            if (upScan != upTarget)\n                return false;\n        }\n        return true;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/CharacterReader.java",
        "class_name": "CharacterReader",
        "class_uri": "src/main/java/org/jsoup/parser/CharacterReader.java.CharacterReader",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/CharacterReader.java.CharacterReader.[boolean]matchesAny()",
        "name": "matchesAny",
        "arg_nums": 0,
        "params": [],
        "return_type": "boolean",
        "signature": "boolean matchesAny(char... seq)",
        "original_string": "    boolean matchesAny(char... seq) {\n        if (isEmpty())\n            return false;\n\n        bufferUp();\n        char c = charBuf[bufPos];\n        for (char seek : seq) {\n            if (seek == c)\n                return true;\n        }\n        return false;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/CharacterReader.java",
        "class_name": "CharacterReader",
        "class_uri": "src/main/java/org/jsoup/parser/CharacterReader.java.CharacterReader",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/CharacterReader.java.CharacterReader.[boolean]matchesAnySorted(char[])",
        "name": "matchesAnySorted",
        "arg_nums": 1,
        "params": [
            {
                "name": "seq",
                "type": "char[]"
            }
        ],
        "return_type": "boolean",
        "signature": "boolean matchesAnySorted(char[] seq)",
        "original_string": "    boolean matchesAnySorted(char[] seq) {\n        bufferUp();\n        return !isEmpty() && Arrays.binarySearch(seq, charBuf[bufPos]) >= 0;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/CharacterReader.java",
        "class_name": "CharacterReader",
        "class_uri": "src/main/java/org/jsoup/parser/CharacterReader.java.CharacterReader",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/CharacterReader.java.CharacterReader.[boolean]matchesLetter()",
        "name": "matchesLetter",
        "arg_nums": 0,
        "params": [],
        "return_type": "boolean",
        "signature": "boolean matchesLetter()",
        "original_string": "    boolean matchesLetter() {\n        if (isEmpty())\n            return false;\n        char c = charBuf[bufPos];\n        return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || Character.isLetter(c);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/CharacterReader.java",
        "class_name": "CharacterReader",
        "class_uri": "src/main/java/org/jsoup/parser/CharacterReader.java.CharacterReader",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/CharacterReader.java.CharacterReader.[boolean]matchesAsciiAlpha()",
        "name": "matchesAsciiAlpha",
        "arg_nums": 0,
        "params": [],
        "return_type": "boolean",
        "signature": "boolean matchesAsciiAlpha()",
        "original_string": "    boolean matchesAsciiAlpha() {\n        if (isEmpty())\n            return false;\n        char c = charBuf[bufPos];\n        return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z');\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/CharacterReader.java",
        "class_name": "CharacterReader",
        "class_uri": "src/main/java/org/jsoup/parser/CharacterReader.java.CharacterReader",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": "\nChecks if the current pos matches an ascii alpha (A-Z a-z) per https://infra.spec.whatwg.org/#ascii-alpha\n@return if it matches or not\n"
    },
    {
        "uris": "src/main/java/org/jsoup/parser/CharacterReader.java.CharacterReader.[boolean]matchesDigit()",
        "name": "matchesDigit",
        "arg_nums": 0,
        "params": [],
        "return_type": "boolean",
        "signature": "boolean matchesDigit()",
        "original_string": "    boolean matchesDigit() {\n        if (isEmpty())\n            return false;\n        char c = charBuf[bufPos];\n        return (c >= '0' && c <= '9');\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/CharacterReader.java",
        "class_name": "CharacterReader",
        "class_uri": "src/main/java/org/jsoup/parser/CharacterReader.java.CharacterReader",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/CharacterReader.java.CharacterReader.[boolean]matchConsume(String)",
        "name": "matchConsume",
        "arg_nums": 1,
        "params": [
            {
                "name": "seq",
                "type": "String"
            }
        ],
        "return_type": "boolean",
        "signature": "boolean matchConsume(String seq)",
        "original_string": "    boolean matchConsume(String seq) {\n        bufferUp();\n        if (matches(seq)) {\n            bufPos += seq.length();\n            return true;\n        } else {\n            return false;\n        }\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/CharacterReader.java",
        "class_name": "CharacterReader",
        "class_uri": "src/main/java/org/jsoup/parser/CharacterReader.java.CharacterReader",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/CharacterReader.java.CharacterReader.[boolean]matchConsumeIgnoreCase(String)",
        "name": "matchConsumeIgnoreCase",
        "arg_nums": 1,
        "params": [
            {
                "name": "seq",
                "type": "String"
            }
        ],
        "return_type": "boolean",
        "signature": "boolean matchConsumeIgnoreCase(String seq)",
        "original_string": "    boolean matchConsumeIgnoreCase(String seq) {\n        if (matchesIgnoreCase(seq)) {\n            bufPos += seq.length();\n            return true;\n        } else {\n            return false;\n        }\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/CharacterReader.java",
        "class_name": "CharacterReader",
        "class_uri": "src/main/java/org/jsoup/parser/CharacterReader.java.CharacterReader",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/CharacterReader.java.CharacterReader.[boolean]containsIgnoreCase(String)",
        "name": "containsIgnoreCase",
        "arg_nums": 1,
        "params": [
            {
                "name": "seq",
                "type": "String"
            }
        ],
        "return_type": "boolean",
        "signature": "boolean containsIgnoreCase(String seq)",
        "original_string": "    boolean containsIgnoreCase(String seq) {\n        if (seq.equals(lastIcSeq)) {\n            if (lastIcIndex == -1) return false;\n            if (lastIcIndex >= bufPos) return true;\n        }\n        lastIcSeq = seq;\n\n        String loScan = seq.toLowerCase(Locale.ENGLISH);\n        int lo = nextIndexOf(loScan);\n        if (lo > -1) {\n            lastIcIndex = bufPos + lo; return true;\n        }\n\n        String hiScan = seq.toUpperCase(Locale.ENGLISH);\n        int hi = nextIndexOf(hiScan);\n        boolean found = hi > -1;\n        lastIcIndex = found ? bufPos + hi : -1; // we don't care about finding the nearest, just that buf contains\n        return found;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/CharacterReader.java",
        "class_name": "CharacterReader",
        "class_uri": "src/main/java/org/jsoup/parser/CharacterReader.java.CharacterReader",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": " Used to check presence of </title>, </style> when we're in RCData and see a <xxx. Only finds consistent case."
    },
    {
        "uris": "src/main/java/org/jsoup/parser/CharacterReader.java.CharacterReader.[String]toString()",
        "name": "toString",
        "arg_nums": 0,
        "params": [],
        "return_type": "String",
        "signature": "@Override\n    public String toString()",
        "original_string": "    @Override\n    public String toString() {\n        if (bufLength - bufPos < 0)\n            return \"\";\n        return new String(charBuf, bufPos, bufLength - bufPos);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/CharacterReader.java",
        "class_name": "CharacterReader",
        "class_uri": "src/main/java/org/jsoup/parser/CharacterReader.java.CharacterReader",
        "attributes": {
            "modifiers": "@Override\n    public",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/CharacterReader.java.CharacterReader.[String]cacheString(char[],String[],int,int)",
        "name": "cacheString",
        "arg_nums": 4,
        "params": [
            {
                "name": "charBuf",
                "type": "char[]"
            },
            {
                "name": "stringCache",
                "type": "String[]"
            },
            {
                "name": "start",
                "type": "int"
            },
            {
                "name": "count",
                "type": "int"
            }
        ],
        "return_type": "String",
        "signature": "private static String cacheString(final char[] charBuf, final String[] stringCache, final int start, final int count)",
        "original_string": "    private static String cacheString(final char[] charBuf, final String[] stringCache, final int start, final int count) {\n        if (count > MaxStringCacheLen) // don't cache strings that are too big\n            return new String(charBuf, start, count);\n        if (count < 1)\n            return \"\";\n\n        // calculate hash:\n        int hash = 0;\n        int end = count + start;\n        for (int i = start; i < end; i++) {\n            hash = 31 * hash + charBuf[i];\n        }\n\n        // get from cache\n        final int index = hash & StringCacheSize - 1;\n        String cached = stringCache[index];\n\n        if (cached != null && rangeEquals(charBuf, start, count, cached)) // positive hit\n            return cached;\n        else {\n            cached = new String(charBuf, start, count);\n            stringCache[index] = cached; // add or replace, assuming most recently used are most likely to recur next\n        }\n\n        return cached;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/CharacterReader.java",
        "class_name": "CharacterReader",
        "class_uri": "src/main/java/org/jsoup/parser/CharacterReader.java.CharacterReader",
        "attributes": {
            "modifiers": "private static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "private",
                "static"
            ],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": "\nCaches short strings, as a flyweight pattern, to reduce GC load. Just for this doc, to prevent leaks.\n<p />\nSimplistic, and on hash collisions just falls back to creating a new string, vs a full HashMap with Entry list.\nThat saves both having to create objects as hash keys, and running through the entry list, at the expense of\nsome more duplicates.\n"
    },
    {
        "uris": "src/main/java/org/jsoup/parser/CharacterReader.java.CharacterReader.[boolean]rangeEquals(char[],int,int,String)",
        "name": "rangeEquals",
        "arg_nums": 4,
        "params": [
            {
                "name": "charBuf",
                "type": "char[]"
            },
            {
                "name": "start",
                "type": "int"
            },
            {
                "name": "count",
                "type": "int"
            },
            {
                "name": "cached",
                "type": "String"
            }
        ],
        "return_type": "boolean",
        "signature": "static boolean rangeEquals(final char[] charBuf, final int start, int count, final String cached)",
        "original_string": "    static boolean rangeEquals(final char[] charBuf, final int start, int count, final String cached) {\n        if (count == cached.length()) {\n            int i = start;\n            int j = 0;\n            while (count-- != 0) {\n                if (charBuf[i++] != cached.charAt(j++))\n                    return false;\n            }\n            return true;\n        }\n        return false;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/CharacterReader.java",
        "class_name": "CharacterReader",
        "class_uri": "src/main/java/org/jsoup/parser/CharacterReader.java.CharacterReader",
        "attributes": {
            "modifiers": "static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "static"
            ],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": "\nCheck if the value of the provided range equals the string.\n"
    },
    {
        "uris": "src/main/java/org/jsoup/parser/CharacterReader.java.CharacterReader.[boolean]rangeEquals(int,int,String)",
        "name": "rangeEquals",
        "arg_nums": 3,
        "params": [
            {
                "name": "start",
                "type": "int"
            },
            {
                "name": "count",
                "type": "int"
            },
            {
                "name": "cached",
                "type": "String"
            }
        ],
        "return_type": "boolean",
        "signature": "boolean rangeEquals(final int start, final int count, final String cached)",
        "original_string": "    boolean rangeEquals(final int start, final int count, final String cached) {\n        return rangeEquals(charBuf, start, count, cached);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/CharacterReader.java",
        "class_name": "CharacterReader",
        "class_uri": "src/main/java/org/jsoup/parser/CharacterReader.java.CharacterReader",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": " just used for testing"
    },
    {
        "uris": "src/main/java/org/jsoup/parser/TreeBuilder.java.TreeBuilder.[ParseSettings]defaultSettings()",
        "name": "defaultSettings",
        "arg_nums": 0,
        "params": [],
        "return_type": "ParseSettings",
        "signature": "abstract ParseSettings defaultSettings()",
        "original_string": "    abstract ParseSettings defaultSettings();",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/TreeBuilder.java",
        "class_name": "TreeBuilder",
        "class_uri": "src/main/java/org/jsoup/parser/TreeBuilder.java.TreeBuilder",
        "attributes": {
            "modifiers": "abstract",
            "marker_annotations": [],
            "non_marker_annotations": [
                "abstract"
            ],
            "comments": [],
            "return_type": "ParseSettings",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/TreeBuilder.java.TreeBuilder.[void]initialiseParse(Reader,String,Parser)",
        "name": "initialiseParse",
        "arg_nums": 3,
        "params": [
            {
                "name": "input",
                "type": "Reader"
            },
            {
                "name": "baseUri",
                "type": "String"
            },
            {
                "name": "parser",
                "type": "Parser"
            }
        ],
        "return_type": "void",
        "signature": "void initialiseParse(Reader input, String baseUri, Parser parser)",
        "original_string": "    void initialiseParse(Reader input, String baseUri, Parser parser) {\n        Validate.notNullParam(input, \"input\");\n        Validate.notNullParam(baseUri, \"baseUri\");\n        Validate.notNull(parser);\n\n        doc = new Document(parser.defaultNamespace(), baseUri);\n        doc.parser(parser);\n        this.parser = parser;\n        settings = parser.settings();\n        reader = new CharacterReader(input);\n        trackSourceRange = parser.isTrackPosition();\n        reader.trackNewlines(parser.isTrackErrors() || trackSourceRange); // when tracking errors or source ranges, enable newline tracking for better legibility\n        tokeniser = new Tokeniser(this);\n        stack = new ArrayList<>(32);\n        seenTags = new HashMap<>();\n        start = new Token.StartTag(this);\n        currentToken = start; // init current token to the virtual start token.\n        this.baseUri = baseUri;\n        onNodeInserted(doc);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/TreeBuilder.java",
        "class_name": "TreeBuilder",
        "class_uri": "src/main/java/org/jsoup/parser/TreeBuilder.java.TreeBuilder",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": " optionally tracks the source range of nodes and attributes"
    },
    {
        "uris": "src/main/java/org/jsoup/parser/TreeBuilder.java.TreeBuilder.[void]completeParse()",
        "name": "completeParse",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "void completeParse()",
        "original_string": "    void completeParse() {\n        // tidy up - as the Parser and Treebuilder are retained in document for settings / fragments\n        if (reader == null) return;\n        reader.close();\n        reader = null;\n        tokeniser = null;\n        stack = null;\n        seenTags = null;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/TreeBuilder.java",
        "class_name": "TreeBuilder",
        "class_uri": "src/main/java/org/jsoup/parser/TreeBuilder.java.TreeBuilder",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/TreeBuilder.java.TreeBuilder.[Document]parse(Reader,String,Parser)",
        "name": "parse",
        "arg_nums": 3,
        "params": [
            {
                "name": "input",
                "type": "Reader"
            },
            {
                "name": "baseUri",
                "type": "String"
            },
            {
                "name": "parser",
                "type": "Parser"
            }
        ],
        "return_type": "Document",
        "signature": "Document parse(Reader input, String baseUri, Parser parser)",
        "original_string": "    Document parse(Reader input, String baseUri, Parser parser) {\n        initialiseParse(input, baseUri, parser);\n        runParser();\n        return doc;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/TreeBuilder.java",
        "class_name": "TreeBuilder",
        "class_uri": "src/main/java/org/jsoup/parser/TreeBuilder.java.TreeBuilder",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "Document",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/TreeBuilder.java.TreeBuilder.[List<Node>]parseFragment(String,Element,String,Parser)",
        "name": "parseFragment",
        "arg_nums": 4,
        "params": [
            {
                "name": "inputFragment",
                "type": "String"
            },
            {
                "name": "context",
                "type": "Element"
            },
            {
                "name": "baseUri",
                "type": "String"
            },
            {
                "name": "parser",
                "type": "Parser"
            }
        ],
        "return_type": "List<Node>",
        "signature": "List<Node> parseFragment(String inputFragment, @Nullable Element context, String baseUri, Parser parser)",
        "original_string": "    List<Node> parseFragment(String inputFragment, @Nullable Element context, String baseUri, Parser parser) {\n        initialiseParse(new StringReader(inputFragment), baseUri, parser);\n        initialiseParseFragment(context);\n        runParser();\n        return completeParseFragment();\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/TreeBuilder.java",
        "class_name": "TreeBuilder",
        "class_uri": "src/main/java/org/jsoup/parser/TreeBuilder.java.TreeBuilder",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "List<Node>",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/TreeBuilder.java.TreeBuilder.[void]initialiseParseFragment(Element)",
        "name": "initialiseParseFragment",
        "arg_nums": 1,
        "params": [
            {
                "name": "context",
                "type": "Element"
            }
        ],
        "return_type": "void",
        "signature": "void initialiseParseFragment(@Nullable Element context)",
        "original_string": "    void initialiseParseFragment(@Nullable Element context) {\n        // in Html, sets up context; no-op in XML\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/TreeBuilder.java",
        "class_name": "TreeBuilder",
        "class_uri": "src/main/java/org/jsoup/parser/TreeBuilder.java.TreeBuilder",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/TreeBuilder.java.TreeBuilder.[List<Node>]completeParseFragment()",
        "name": "completeParseFragment",
        "arg_nums": 0,
        "params": [],
        "return_type": "List<Node>",
        "signature": "abstract List<Node> completeParseFragment()",
        "original_string": "    abstract List<Node> completeParseFragment();",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/TreeBuilder.java",
        "class_name": "TreeBuilder",
        "class_uri": "src/main/java/org/jsoup/parser/TreeBuilder.java.TreeBuilder",
        "attributes": {
            "modifiers": "abstract",
            "marker_annotations": [],
            "non_marker_annotations": [
                "abstract"
            ],
            "comments": [],
            "return_type": "List<Node>",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/TreeBuilder.java.TreeBuilder.[void]nodeListener(NodeVisitor)",
        "name": "nodeListener",
        "arg_nums": 1,
        "params": [
            {
                "name": "nodeListener",
                "type": "NodeVisitor"
            }
        ],
        "return_type": "void",
        "signature": "void nodeListener(NodeVisitor nodeListener)",
        "original_string": "    void nodeListener(NodeVisitor nodeListener) {\n        this.nodeListener = nodeListener;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/TreeBuilder.java",
        "class_name": "TreeBuilder",
        "class_uri": "src/main/java/org/jsoup/parser/TreeBuilder.java.TreeBuilder",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": " Set the node listener, which will then get callbacks for node insert and removals."
    },
    {
        "uris": "src/main/java/org/jsoup/parser/TreeBuilder.java.TreeBuilder.[TreeBuilder]newInstance()",
        "name": "newInstance",
        "arg_nums": 0,
        "params": [],
        "return_type": "TreeBuilder",
        "signature": "abstract TreeBuilder newInstance()",
        "original_string": "    abstract TreeBuilder newInstance();",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/TreeBuilder.java",
        "class_name": "TreeBuilder",
        "class_uri": "src/main/java/org/jsoup/parser/TreeBuilder.java.TreeBuilder",
        "attributes": {
            "modifiers": "abstract",
            "marker_annotations": [],
            "non_marker_annotations": [
                "abstract"
            ],
            "comments": [],
            "return_type": "TreeBuilder",
            "classes": []
        },
        "docstring": "\nCreate a new copy of this TreeBuilder\n@return copy, ready for a new parse\n"
    },
    {
        "uris": "src/main/java/org/jsoup/parser/TreeBuilder.java.TreeBuilder.[void]runParser()",
        "name": "runParser",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "void runParser()",
        "original_string": "    void runParser() {\n        do {} while (stepParser()); // run until stepParser sees EOF\n        completeParse();\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/TreeBuilder.java",
        "class_name": "TreeBuilder",
        "class_uri": "src/main/java/org/jsoup/parser/TreeBuilder.java.TreeBuilder",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/TreeBuilder.java.TreeBuilder.[boolean]stepParser()",
        "name": "stepParser",
        "arg_nums": 0,
        "params": [],
        "return_type": "boolean",
        "signature": "boolean stepParser()",
        "original_string": "    boolean stepParser() {\n        // if we have reached the end already, step by popping off the stack, to hit nodeRemoved callbacks:\n        if (currentToken.type == Token.TokenType.EOF) {\n            if (stack == null) {\n                return false;\n            } if (stack.isEmpty()) {\n                onNodeClosed(doc); // the root doc is not on the stack, so let this final step close it\n                stack = null;\n                return true;\n            }\n            pop();\n            return true;\n        }\n        final Token token = tokeniser.read();\n        currentToken = token;\n        process(token);\n        token.reset();\n        return true;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/TreeBuilder.java",
        "class_name": "TreeBuilder",
        "class_uri": "src/main/java/org/jsoup/parser/TreeBuilder.java.TreeBuilder",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/TreeBuilder.java.TreeBuilder.[boolean]process(Token)",
        "name": "process",
        "arg_nums": 1,
        "params": [
            {
                "name": "token",
                "type": "Token"
            }
        ],
        "return_type": "boolean",
        "signature": "abstract boolean process(Token token)",
        "original_string": "    abstract boolean process(Token token);",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/TreeBuilder.java",
        "class_name": "TreeBuilder",
        "class_uri": "src/main/java/org/jsoup/parser/TreeBuilder.java.TreeBuilder",
        "attributes": {
            "modifiers": "abstract",
            "marker_annotations": [],
            "non_marker_annotations": [
                "abstract"
            ],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/TreeBuilder.java.TreeBuilder.[boolean]processStartTag(String)",
        "name": "processStartTag",
        "arg_nums": 1,
        "params": [
            {
                "name": "name",
                "type": "String"
            }
        ],
        "return_type": "boolean",
        "signature": "boolean processStartTag(String name)",
        "original_string": "    boolean processStartTag(String name) {\n        // these are \"virtual\" start tags (auto-created by the treebuilder), so not tracking the start position\n        final Token.StartTag start = this.start;\n        if (currentToken == start) { // don't recycle an in-use token\n            return process(new Token.StartTag(this).name(name));\n        }\n        return process(start.reset().name(name));\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/TreeBuilder.java",
        "class_name": "TreeBuilder",
        "class_uri": "src/main/java/org/jsoup/parser/TreeBuilder.java.TreeBuilder",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/TreeBuilder.java.TreeBuilder.[boolean]processStartTag(String,Attributes)",
        "name": "processStartTag",
        "arg_nums": 2,
        "params": [
            {
                "name": "name",
                "type": "String"
            },
            {
                "name": "attrs",
                "type": "Attributes"
            }
        ],
        "return_type": "boolean",
        "signature": "boolean processStartTag(String name, Attributes attrs)",
        "original_string": "    boolean processStartTag(String name, Attributes attrs) {\n        final Token.StartTag start = this.start;\n        if (currentToken == start) { // don't recycle an in-use token\n            return process(new Token.StartTag(this).nameAttr(name, attrs));\n        }\n        start.reset();\n        start.nameAttr(name, attrs);\n        return process(start);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/TreeBuilder.java",
        "class_name": "TreeBuilder",
        "class_uri": "src/main/java/org/jsoup/parser/TreeBuilder.java.TreeBuilder",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/TreeBuilder.java.TreeBuilder.[boolean]processEndTag(String)",
        "name": "processEndTag",
        "arg_nums": 1,
        "params": [
            {
                "name": "name",
                "type": "String"
            }
        ],
        "return_type": "boolean",
        "signature": "boolean processEndTag(String name)",
        "original_string": "    boolean processEndTag(String name) {\n        if (currentToken == end) { // don't recycle an in-use token\n            return process(new Token.EndTag(this).name(name));\n        }\n        return process(end.reset().name(name));\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/TreeBuilder.java",
        "class_name": "TreeBuilder",
        "class_uri": "src/main/java/org/jsoup/parser/TreeBuilder.java.TreeBuilder",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/TreeBuilder.java.TreeBuilder.[Element]pop()",
        "name": "pop",
        "arg_nums": 0,
        "params": [],
        "return_type": "Element",
        "signature": "final Element pop()",
        "original_string": "    final Element pop() {\n        int size = stack.size();\n        Element removed = stack.remove(size - 1);\n        onNodeClosed(removed);\n        return removed;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/TreeBuilder.java",
        "class_name": "TreeBuilder",
        "class_uri": "src/main/java/org/jsoup/parser/TreeBuilder.java.TreeBuilder",
        "attributes": {
            "modifiers": "final",
            "marker_annotations": [],
            "non_marker_annotations": [
                "final"
            ],
            "comments": [],
            "return_type": "Element",
            "classes": []
        },
        "docstring": "\nRemoves the last Element from the stack, hits onNodeClosed, and then returns it.\n@return\n"
    },
    {
        "uris": "src/main/java/org/jsoup/parser/TreeBuilder.java.TreeBuilder.[void]push(Element)",
        "name": "push",
        "arg_nums": 1,
        "params": [
            {
                "name": "element",
                "type": "Element"
            }
        ],
        "return_type": "void",
        "signature": "final void push(Element element)",
        "original_string": "    final void push(Element element) {\n        stack.add(element);\n        onNodeInserted(element);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/TreeBuilder.java",
        "class_name": "TreeBuilder",
        "class_uri": "src/main/java/org/jsoup/parser/TreeBuilder.java.TreeBuilder",
        "attributes": {
            "modifiers": "final",
            "marker_annotations": [],
            "non_marker_annotations": [
                "final"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": "\nAdds the specified Element to the end of the stack, and hits onNodeInserted.\n@param element\n"
    },
    {
        "uris": "src/main/java/org/jsoup/parser/TreeBuilder.java.TreeBuilder.[Element]currentElement()",
        "name": "currentElement",
        "arg_nums": 0,
        "params": [],
        "return_type": "Element",
        "signature": "Element currentElement()",
        "original_string": "    Element currentElement() {\n        int size = stack.size();\n        return size > 0 ? stack.get(size-1) : doc;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/TreeBuilder.java",
        "class_name": "TreeBuilder",
        "class_uri": "src/main/java/org/jsoup/parser/TreeBuilder.java.TreeBuilder",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "Element",
            "classes": []
        },
        "docstring": "\nGet the current element (last on the stack). If all items have been removed, returns the document instead\n(which might not actually be on the stack; use stack.size() == 0 to test if required.\n@return the last element on the stack, if any; or the root document\n"
    },
    {
        "uris": "src/main/java/org/jsoup/parser/TreeBuilder.java.TreeBuilder.[boolean]currentElementIs(String)",
        "name": "currentElementIs",
        "arg_nums": 1,
        "params": [
            {
                "name": "normalName",
                "type": "String"
            }
        ],
        "return_type": "boolean",
        "signature": "boolean currentElementIs(String normalName)",
        "original_string": "    boolean currentElementIs(String normalName) {\n        if (stack.size() == 0)\n            return false;\n        Element current = currentElement();\n        return current != null && current.normalName().equals(normalName)\n            && current.tag().namespace().equals(NamespaceHtml);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/TreeBuilder.java",
        "class_name": "TreeBuilder",
        "class_uri": "src/main/java/org/jsoup/parser/TreeBuilder.java.TreeBuilder",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": "\nChecks if the Current Element's normal name equals the supplied name, in the HTML namespace.\n@param normalName name to check\n@return true if there is a current element on the stack, and its name equals the supplied\n"
    },
    {
        "uris": "src/main/java/org/jsoup/parser/TreeBuilder.java.TreeBuilder.[boolean]currentElementIs(String,String)",
        "name": "currentElementIs",
        "arg_nums": 2,
        "params": [
            {
                "name": "normalName",
                "type": "String"
            },
            {
                "name": "namespace",
                "type": "String"
            }
        ],
        "return_type": "boolean",
        "signature": "boolean currentElementIs(String normalName, String namespace)",
        "original_string": "    boolean currentElementIs(String normalName, String namespace) {\n        if (stack.size() == 0)\n            return false;\n        Element current = currentElement();\n        return current != null && current.normalName().equals(normalName)\n            && current.tag().namespace().equals(namespace);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/TreeBuilder.java",
        "class_name": "TreeBuilder",
        "class_uri": "src/main/java/org/jsoup/parser/TreeBuilder.java.TreeBuilder",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": "\nChecks if the Current Element's normal name equals the supplied name, in the specified namespace.\n@param normalName name to check\n@param namespace the namespace\n@return true if there is a current element on the stack, and its name equals the supplied\n"
    },
    {
        "uris": "src/main/java/org/jsoup/parser/TreeBuilder.java.TreeBuilder.[void]error(String)",
        "name": "error",
        "arg_nums": 1,
        "params": [
            {
                "name": "msg",
                "type": "String"
            }
        ],
        "return_type": "void",
        "signature": "void error(String msg)",
        "original_string": "    void error(String msg) {\n        error(msg, (Object[]) null);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/TreeBuilder.java",
        "class_name": "TreeBuilder",
        "class_uri": "src/main/java/org/jsoup/parser/TreeBuilder.java.TreeBuilder",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": "\nIf the parser is tracking errors, add an error at the current position.\n@param msg error message\n"
    },
    {
        "uris": "src/main/java/org/jsoup/parser/TreeBuilder.java.TreeBuilder.[void]error(String)",
        "name": "error",
        "arg_nums": 1,
        "params": [
            {
                "name": "msg",
                "type": "String"
            }
        ],
        "return_type": "void",
        "signature": "void error(String msg, Object... args)",
        "original_string": "    void error(String msg, Object... args) {\n        ParseErrorList errors = parser.getErrors();\n        if (errors.canAddError())\n            errors.add(new ParseError(reader, msg, args));\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/TreeBuilder.java",
        "class_name": "TreeBuilder",
        "class_uri": "src/main/java/org/jsoup/parser/TreeBuilder.java.TreeBuilder",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": "\nIf the parser is tracking errors, add an error at the current position.\n@param msg error message template\n@param args template arguments\n"
    },
    {
        "uris": "src/main/java/org/jsoup/parser/TreeBuilder.java.TreeBuilder.[boolean]isContentForTagData(String)",
        "name": "isContentForTagData",
        "arg_nums": 1,
        "params": [
            {
                "name": "normalName",
                "type": "String"
            }
        ],
        "return_type": "boolean",
        "signature": "boolean isContentForTagData(String normalName)",
        "original_string": "    boolean isContentForTagData(String normalName) {\n        return false;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/TreeBuilder.java",
        "class_name": "TreeBuilder",
        "class_uri": "src/main/java/org/jsoup/parser/TreeBuilder.java.TreeBuilder",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": "\n(An internal method, visible for Element. For HTML parse, signals that script and style text should be treated as\nData Nodes).\n"
    },
    {
        "uris": "src/main/java/org/jsoup/parser/TreeBuilder.java.TreeBuilder.[Tag]tagFor(String,String,ParseSettings)",
        "name": "tagFor",
        "arg_nums": 3,
        "params": [
            {
                "name": "tagName",
                "type": "String"
            },
            {
                "name": "namespace",
                "type": "String"
            },
            {
                "name": "settings",
                "type": "ParseSettings"
            }
        ],
        "return_type": "Tag",
        "signature": "Tag tagFor(String tagName, String namespace, ParseSettings settings)",
        "original_string": "    Tag tagFor(String tagName, String namespace, ParseSettings settings) {\n        Tag cached = seenTags.get(tagName); // note that we don't normalize the cache key. But tag via valueOf may be normalized.\n        if (cached == null || !cached.namespace().equals(namespace)) {\n            // only return from cache if the namespace is the same. not running nested cache to save double hit on the common flow\n            Tag tag = Tag.valueOf(tagName, namespace, settings);\n            seenTags.put(tagName, tag);\n            return tag;\n        }\n        return cached;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/TreeBuilder.java",
        "class_name": "TreeBuilder",
        "class_uri": "src/main/java/org/jsoup/parser/TreeBuilder.java.TreeBuilder",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "Tag",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/TreeBuilder.java.TreeBuilder.[Tag]tagFor(String,ParseSettings)",
        "name": "tagFor",
        "arg_nums": 2,
        "params": [
            {
                "name": "tagName",
                "type": "String"
            },
            {
                "name": "settings",
                "type": "ParseSettings"
            }
        ],
        "return_type": "Tag",
        "signature": "Tag tagFor(String tagName, ParseSettings settings)",
        "original_string": "    Tag tagFor(String tagName, ParseSettings settings) {\n        return tagFor(tagName, defaultNamespace(), settings);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/TreeBuilder.java",
        "class_name": "TreeBuilder",
        "class_uri": "src/main/java/org/jsoup/parser/TreeBuilder.java.TreeBuilder",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "Tag",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/TreeBuilder.java.TreeBuilder.[String]defaultNamespace()",
        "name": "defaultNamespace",
        "arg_nums": 0,
        "params": [],
        "return_type": "String",
        "signature": "String defaultNamespace()",
        "original_string": "    String defaultNamespace() {\n        return NamespaceHtml;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/TreeBuilder.java",
        "class_name": "TreeBuilder",
        "class_uri": "src/main/java/org/jsoup/parser/TreeBuilder.java.TreeBuilder",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": "\nGets the default namespace for this TreeBuilder\n@return the default namespace\n"
    },
    {
        "uris": "src/main/java/org/jsoup/parser/TreeBuilder.java.TreeBuilder.[void]onNodeInserted(Node)",
        "name": "onNodeInserted",
        "arg_nums": 1,
        "params": [
            {
                "name": "node",
                "type": "Node"
            }
        ],
        "return_type": "void",
        "signature": "void onNodeInserted(Node node)",
        "original_string": "    void onNodeInserted(Node node) {\n        trackNodePosition(node, true);\n\n        if (nodeListener != null)\n            nodeListener.head(node, stack.size());\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/TreeBuilder.java",
        "class_name": "TreeBuilder",
        "class_uri": "src/main/java/org/jsoup/parser/TreeBuilder.java.TreeBuilder",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": "\nCalled by implementing TreeBuilders when a node has been inserted. This implementation includes optionally tracking\nthe source range of the node.  @param node the node that was just inserted\n"
    },
    {
        "uris": "src/main/java/org/jsoup/parser/TreeBuilder.java.TreeBuilder.[void]onNodeClosed(Node)",
        "name": "onNodeClosed",
        "arg_nums": 1,
        "params": [
            {
                "name": "node",
                "type": "Node"
            }
        ],
        "return_type": "void",
        "signature": "void onNodeClosed(Node node)",
        "original_string": "    void onNodeClosed(Node node) {\n        trackNodePosition(node, false);\n\n        if (nodeListener != null)\n            nodeListener.tail(node, stack.size());\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/TreeBuilder.java",
        "class_name": "TreeBuilder",
        "class_uri": "src/main/java/org/jsoup/parser/TreeBuilder.java.TreeBuilder",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": "\nCalled by implementing TreeBuilders when a node is explicitly closed. This implementation includes optionally\ntracking the closing source range of the node.  @param node the node being closed\n"
    },
    {
        "uris": "src/main/java/org/jsoup/parser/TreeBuilder.java.TreeBuilder.[void]trackNodePosition(Node,boolean)",
        "name": "trackNodePosition",
        "arg_nums": 2,
        "params": [
            {
                "name": "node",
                "type": "Node"
            },
            {
                "name": "isStart",
                "type": "boolean"
            }
        ],
        "return_type": "void",
        "signature": "private void trackNodePosition(Node node, boolean isStart)",
        "original_string": "    private void trackNodePosition(Node node, boolean isStart) {\n        if (!trackSourceRange) return;\n\n        final Token token = currentToken;\n        int startPos = token.startPos();\n        int endPos = token.endPos();\n\n        // handle implicit element open / closes.\n        if (node instanceof Element) {\n            final Element el = (Element) node;\n            if (token.isEOF()) {\n                if (el.endSourceRange().isTracked())\n                    return; // /body and /html are left on stack until EOF, don't reset them\n                startPos = endPos = reader.pos();\n            } else if (isStart) { // opening tag\n                if  (!token.isStartTag() || !el.normalName().equals(token.asStartTag().normalName)) {\n                    endPos = startPos;\n                }\n            } else { // closing tag\n                if (!el.tag().isEmpty() && !el.tag().isSelfClosing()) {\n                    if (!token.isEndTag() || !el.normalName().equals(token.asEndTag().normalName)) {\n                        endPos = startPos;\n                    }\n                }\n            }\n        }\n\n        Range.Position startPosition = new Range.Position\n            (startPos, reader.lineNumber(startPos), reader.columnNumber(startPos));\n        Range.Position endPosition = new Range.Position\n            (endPos, reader.lineNumber(endPos), reader.columnNumber(endPos));\n        Range range = new Range(startPosition, endPosition);\n        node.attributes().userData(isStart ? SharedConstants.RangeKey : SharedConstants.EndRangeKey, range);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/TreeBuilder.java",
        "class_name": "TreeBuilder",
        "class_uri": "src/main/java/org/jsoup/parser/TreeBuilder.java.TreeBuilder",
        "attributes": {
            "modifiers": "private",
            "marker_annotations": [],
            "non_marker_annotations": [
                "private"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/Tokeniser.java.Tokeniser.[]Tokeniser(TreeBuilder)",
        "name": "Tokeniser",
        "arg_nums": 1,
        "params": [
            {
                "name": "treeBuilder",
                "type": "TreeBuilder"
            }
        ],
        "return_type": "",
        "signature": "Tokeniser(TreeBuilder treeBuilder)",
        "original_string": "    Tokeniser(TreeBuilder treeBuilder) {\n        tagPending = startPending  = new Token.StartTag(treeBuilder);\n        endPending = new Token.EndTag(treeBuilder);\n        this.reader = treeBuilder.reader;\n        this.errors = treeBuilder.parser.getErrors();\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/Tokeniser.java",
        "class_name": "Tokeniser",
        "class_uri": "src/main/java/org/jsoup/parser/Tokeniser.java.Tokeniser",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "",
            "classes": []
        },
        "docstring": " reader pos at the start of markup / characters. markup updated on state transition, char on token emit."
    },
    {
        "uris": "src/main/java/org/jsoup/parser/Tokeniser.java.Tokeniser.[Token]read()",
        "name": "read",
        "arg_nums": 0,
        "params": [],
        "return_type": "Token",
        "signature": "Token read()",
        "original_string": "    Token read() {\n        while (!isEmitPending) {\n            state.read(this, reader);\n        }\n\n        // if emit is pending, a non-character token was found: return any chars in buffer, and leave token for next read:\n        final StringBuilder cb = this.charsBuilder;\n        if (cb.length() != 0) {\n            String str = cb.toString();\n            cb.delete(0, cb.length());\n            Token token = charPending.data(str);\n            charsString = null;\n            return token;\n        } else if (charsString != null) {\n            Token token = charPending.data(charsString);\n            charsString = null;\n            return token;\n        } else {\n            isEmitPending = false;\n            assert emitPending != null;\n            return emitPending;\n        }\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/Tokeniser.java",
        "class_name": "Tokeniser",
        "class_uri": "src/main/java/org/jsoup/parser/Tokeniser.java.Tokeniser",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "Token",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/Tokeniser.java.Tokeniser.[void]emit(Token)",
        "name": "emit",
        "arg_nums": 1,
        "params": [
            {
                "name": "token",
                "type": "Token"
            }
        ],
        "return_type": "void",
        "signature": "void emit(Token token)",
        "original_string": "    void emit(Token token) {\n        Validate.isFalse(isEmitPending);\n\n        emitPending = token;\n        isEmitPending = true;\n        token.startPos(markupStartPos);\n        token.endPos(reader.pos());\n        charStartPos = reader.pos(); // update char start when we complete a token emit\n\n        if (token.type == Token.TokenType.StartTag) {\n            Token.StartTag startTag = (Token.StartTag) token;\n            lastStartTag = startTag.tagName;\n            lastStartCloseSeq = null; // only lazy inits\n        } else if (token.type == Token.TokenType.EndTag) {\n            Token.EndTag endTag = (Token.EndTag) token;\n            if (endTag.hasAttributes())\n                error(\"Attributes incorrectly present on end tag [/%s]\", endTag.normalName());\n        }\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/Tokeniser.java",
        "class_name": "Tokeniser",
        "class_uri": "src/main/java/org/jsoup/parser/Tokeniser.java.Tokeniser",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/Tokeniser.java.Tokeniser.[void]emit(String)",
        "name": "emit",
        "arg_nums": 1,
        "params": [
            {
                "name": "str",
                "type": "String"
            }
        ],
        "return_type": "void",
        "signature": "void emit(final String str)",
        "original_string": "    void emit(final String str) {\n        // buffer strings up until last string token found, to emit only one token for a run of character refs etc.\n        // does not set isEmitPending; read checks that\n        if (charsString == null) {\n            charsString = str;\n        } else {\n            if (charsBuilder.length() == 0) { // switching to string builder as more than one emit before read\n                charsBuilder.append(charsString);\n            }\n            charsBuilder.append(str);\n        }\n        charPending.startPos(charStartPos);\n        charPending.endPos(reader.pos());\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/Tokeniser.java",
        "class_name": "Tokeniser",
        "class_uri": "src/main/java/org/jsoup/parser/Tokeniser.java.Tokeniser",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/Tokeniser.java.Tokeniser.[void]emit(StringBuilder)",
        "name": "emit",
        "arg_nums": 1,
        "params": [
            {
                "name": "str",
                "type": "StringBuilder"
            }
        ],
        "return_type": "void",
        "signature": "void emit(final StringBuilder str)",
        "original_string": "    void emit(final StringBuilder str) {\n        if (charsString == null) {\n            charsString = str.toString();\n        } else {\n            if (charsBuilder.length() == 0) {\n                charsBuilder.append(charsString);\n            }\n            charsBuilder.append(str);\n        }\n        charPending.startPos(charStartPos);\n        charPending.endPos(reader.pos());\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/Tokeniser.java",
        "class_name": "Tokeniser",
        "class_uri": "src/main/java/org/jsoup/parser/Tokeniser.java.Tokeniser",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": " variations to limit need to create temp strings"
    },
    {
        "uris": "src/main/java/org/jsoup/parser/Tokeniser.java.Tokeniser.[void]emit(char)",
        "name": "emit",
        "arg_nums": 1,
        "params": [
            {
                "name": "c",
                "type": "char"
            }
        ],
        "return_type": "void",
        "signature": "void emit(char c)",
        "original_string": "    void emit(char c) {\n        if (charsString == null) {\n            charsString = String.valueOf(c);\n        } else {\n            if (charsBuilder.length() == 0) {\n                charsBuilder.append(charsString);\n            }\n            charsBuilder.append(c);\n        }\n        charPending.startPos(charStartPos);\n        charPending.endPos(reader.pos());\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/Tokeniser.java",
        "class_name": "Tokeniser",
        "class_uri": "src/main/java/org/jsoup/parser/Tokeniser.java.Tokeniser",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/Tokeniser.java.Tokeniser.[void]emit(char[])",
        "name": "emit",
        "arg_nums": 1,
        "params": [
            {
                "name": "chars",
                "type": "char[]"
            }
        ],
        "return_type": "void",
        "signature": "void emit(char[] chars)",
        "original_string": "    void emit(char[] chars) {\n        emit(String.valueOf(chars));\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/Tokeniser.java",
        "class_name": "Tokeniser",
        "class_uri": "src/main/java/org/jsoup/parser/Tokeniser.java.Tokeniser",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/Tokeniser.java.Tokeniser.[void]emit(int[])",
        "name": "emit",
        "arg_nums": 1,
        "params": [
            {
                "name": "codepoints",
                "type": "int[]"
            }
        ],
        "return_type": "void",
        "signature": "void emit(int[] codepoints)",
        "original_string": "    void emit(int[] codepoints) {\n        emit(new String(codepoints, 0, codepoints.length));\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/Tokeniser.java",
        "class_name": "Tokeniser",
        "class_uri": "src/main/java/org/jsoup/parser/Tokeniser.java.Tokeniser",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/Tokeniser.java.Tokeniser.[TokeniserState]getState()",
        "name": "getState",
        "arg_nums": 0,
        "params": [],
        "return_type": "TokeniserState",
        "signature": "TokeniserState getState()",
        "original_string": "    TokeniserState getState() {\n        return state;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/Tokeniser.java",
        "class_name": "Tokeniser",
        "class_uri": "src/main/java/org/jsoup/parser/Tokeniser.java.Tokeniser",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "TokeniserState",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/Tokeniser.java.Tokeniser.[void]transition(TokeniserState)",
        "name": "transition",
        "arg_nums": 1,
        "params": [
            {
                "name": "newState",
                "type": "TokeniserState"
            }
        ],
        "return_type": "void",
        "signature": "void transition(TokeniserState newState)",
        "original_string": "    void transition(TokeniserState newState) {\n        // track markup position on state transitions\n        if (newState == TokeniserState.TagOpen)\n            markupStartPos = reader.pos();\n\n        this.state = newState;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/Tokeniser.java",
        "class_name": "Tokeniser",
        "class_uri": "src/main/java/org/jsoup/parser/Tokeniser.java.Tokeniser",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/Tokeniser.java.Tokeniser.[void]advanceTransition(TokeniserState)",
        "name": "advanceTransition",
        "arg_nums": 1,
        "params": [
            {
                "name": "newState",
                "type": "TokeniserState"
            }
        ],
        "return_type": "void",
        "signature": "void advanceTransition(TokeniserState newState)",
        "original_string": "    void advanceTransition(TokeniserState newState) {\n        transition(newState);\n        reader.advance();\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/Tokeniser.java",
        "class_name": "Tokeniser",
        "class_uri": "src/main/java/org/jsoup/parser/Tokeniser.java.Tokeniser",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/Tokeniser.java.Tokeniser.[int[]]consumeCharacterReference(Character,boolean)",
        "name": "consumeCharacterReference",
        "arg_nums": 2,
        "params": [
            {
                "name": "additionalAllowedCharacter",
                "type": "Character"
            },
            {
                "name": "inAttribute",
                "type": "boolean"
            }
        ],
        "return_type": "int[]",
        "signature": "@Nullable int[] consumeCharacterReference(@Nullable Character additionalAllowedCharacter, boolean inAttribute)",
        "original_string": "    @Nullable int[] consumeCharacterReference(@Nullable Character additionalAllowedCharacter, boolean inAttribute) {\n        if (reader.isEmpty())\n            return null;\n        if (additionalAllowedCharacter != null && additionalAllowedCharacter == reader.current())\n            return null;\n        if (reader.matchesAnySorted(notCharRefCharsSorted))\n            return null;\n\n        final int[] codeRef = codepointHolder;\n        reader.mark();\n        if (reader.matchConsume(\"#\")) { // numbered\n            boolean isHexMode = reader.matchConsumeIgnoreCase(\"X\");\n            String numRef = isHexMode ? reader.consumeHexSequence() : reader.consumeDigitSequence();\n            if (numRef.length() == 0) { // didn't match anything\n                characterReferenceError(\"numeric reference with no numerals\");\n                reader.rewindToMark();\n                return null;\n            }\n\n            reader.unmark();\n            if (!reader.matchConsume(\";\"))\n                characterReferenceError(\"missing semicolon on [&#%s]\", numRef); // missing semi\n            int charval = -1;\n            try {\n                int base = isHexMode ? 16 : 10;\n                charval = Integer.valueOf(numRef, base);\n            } catch (NumberFormatException ignored) {\n                // skip\n            }\n            // todo: check for extra illegal unicode points as parse errors - described https://html.spec.whatwg.org/multipage/syntax.html#character-references and in Infra\n            // The numeric character reference forms described above are allowed to reference any code point excluding U+000D CR, noncharacters, and controls other than ASCII whitespace.\n            if (charval == -1 || charval > 0x10FFFF) {\n                characterReferenceError(\"character [%s] outside of valid range\", charval);\n                codeRef[0] = replacementChar;\n            } else {\n                // fix illegal unicode characters to match browser behavior\n                if (charval >= win1252ExtensionsStart && charval < win1252ExtensionsStart + win1252Extensions.length) {\n                    characterReferenceError(\"character [%s] is not a valid unicode code point\", charval);\n                    charval = win1252Extensions[charval - win1252ExtensionsStart];\n                }\n\n                // todo: implement number replacement table\n                // todo: check for extra illegal unicode points as parse errors\n                codeRef[0] = charval;\n            }\n            return codeRef;\n        } else { // named\n            // get as many letters as possible, and look for matching entities.\n            String nameRef = reader.consumeLetterThenDigitSequence();\n            boolean looksLegit = reader.matches(';');\n            // found if a base named entity without a ;, or an extended entity with the ;.\n            boolean found = (Entities.isBaseNamedEntity(nameRef) || (Entities.isNamedEntity(nameRef) && looksLegit));\n\n            if (!found) {\n                reader.rewindToMark();\n                if (looksLegit) // named with semicolon\n                    characterReferenceError(\"invalid named reference [%s]\", nameRef);\n                return null;\n            }\n            if (inAttribute && (reader.matchesLetter() || reader.matchesDigit() || reader.matchesAny('=', '-', '_'))) {\n                // don't want that to match\n                reader.rewindToMark();\n                return null;\n            }\n\n            reader.unmark();\n            if (!reader.matchConsume(\";\"))\n                characterReferenceError(\"missing semicolon on [&%s]\", nameRef); // missing semi\n            int numChars = Entities.codepointsForName(nameRef, multipointHolder);\n            if (numChars == 1) {\n                codeRef[0] = multipointHolder[0];\n                return codeRef;\n            } else if (numChars ==2) {\n                return multipointHolder;\n            } else {\n                Validate.fail(\"Unexpected characters returned for \" + nameRef);\n                return multipointHolder;\n            }\n        }\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/Tokeniser.java",
        "class_name": "Tokeniser",
        "class_uri": "src/main/java/org/jsoup/parser/Tokeniser.java.Tokeniser",
        "attributes": {
            "modifiers": "@Nullable",
            "marker_annotations": [
                "@Nullable"
            ],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "int[]",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/Tokeniser.java.Tokeniser.[Token.Tag]createTagPending(boolean)",
        "name": "createTagPending",
        "arg_nums": 1,
        "params": [
            {
                "name": "start",
                "type": "boolean"
            }
        ],
        "return_type": "Token.Tag",
        "signature": "Token.Tag createTagPending(boolean start)",
        "original_string": "    Token.Tag createTagPending(boolean start) {\n        tagPending = start ? startPending.reset() : endPending.reset();\n        return tagPending;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/Tokeniser.java",
        "class_name": "Tokeniser",
        "class_uri": "src/main/java/org/jsoup/parser/Tokeniser.java.Tokeniser",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "Token.Tag",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/Tokeniser.java.Tokeniser.[void]emitTagPending()",
        "name": "emitTagPending",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "void emitTagPending()",
        "original_string": "    void emitTagPending() {\n        tagPending.finaliseTag();\n        emit(tagPending);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/Tokeniser.java",
        "class_name": "Tokeniser",
        "class_uri": "src/main/java/org/jsoup/parser/Tokeniser.java.Tokeniser",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/Tokeniser.java.Tokeniser.[void]createCommentPending()",
        "name": "createCommentPending",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "void createCommentPending()",
        "original_string": "    void createCommentPending() {\n        commentPending.reset();\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/Tokeniser.java",
        "class_name": "Tokeniser",
        "class_uri": "src/main/java/org/jsoup/parser/Tokeniser.java.Tokeniser",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/Tokeniser.java.Tokeniser.[void]emitCommentPending()",
        "name": "emitCommentPending",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "void emitCommentPending()",
        "original_string": "    void emitCommentPending() {\n        emit(commentPending);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/Tokeniser.java",
        "class_name": "Tokeniser",
        "class_uri": "src/main/java/org/jsoup/parser/Tokeniser.java.Tokeniser",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/Tokeniser.java.Tokeniser.[void]createBogusCommentPending()",
        "name": "createBogusCommentPending",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "void createBogusCommentPending()",
        "original_string": "    void createBogusCommentPending() {\n        commentPending.reset();\n        commentPending.bogus = true;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/Tokeniser.java",
        "class_name": "Tokeniser",
        "class_uri": "src/main/java/org/jsoup/parser/Tokeniser.java.Tokeniser",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/Tokeniser.java.Tokeniser.[void]createDoctypePending()",
        "name": "createDoctypePending",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "void createDoctypePending()",
        "original_string": "    void createDoctypePending() {\n        doctypePending.reset();\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/Tokeniser.java",
        "class_name": "Tokeniser",
        "class_uri": "src/main/java/org/jsoup/parser/Tokeniser.java.Tokeniser",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/Tokeniser.java.Tokeniser.[void]emitDoctypePending()",
        "name": "emitDoctypePending",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "void emitDoctypePending()",
        "original_string": "    void emitDoctypePending() {\n        emit(doctypePending);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/Tokeniser.java",
        "class_name": "Tokeniser",
        "class_uri": "src/main/java/org/jsoup/parser/Tokeniser.java.Tokeniser",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/Tokeniser.java.Tokeniser.[void]createTempBuffer()",
        "name": "createTempBuffer",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "void createTempBuffer()",
        "original_string": "    void createTempBuffer() {\n        Token.reset(dataBuffer);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/Tokeniser.java",
        "class_name": "Tokeniser",
        "class_uri": "src/main/java/org/jsoup/parser/Tokeniser.java.Tokeniser",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/Tokeniser.java.Tokeniser.[boolean]isAppropriateEndTagToken()",
        "name": "isAppropriateEndTagToken",
        "arg_nums": 0,
        "params": [],
        "return_type": "boolean",
        "signature": "boolean isAppropriateEndTagToken()",
        "original_string": "    boolean isAppropriateEndTagToken() {\n        return lastStartTag != null && tagPending.name().equalsIgnoreCase(lastStartTag);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/Tokeniser.java",
        "class_name": "Tokeniser",
        "class_uri": "src/main/java/org/jsoup/parser/Tokeniser.java.Tokeniser",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/Tokeniser.java.Tokeniser.[String]appropriateEndTagName()",
        "name": "appropriateEndTagName",
        "arg_nums": 0,
        "params": [],
        "return_type": "String",
        "signature": "@Nullable String appropriateEndTagName()",
        "original_string": "    @Nullable String appropriateEndTagName() {\n        return lastStartTag; // could be null\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/Tokeniser.java",
        "class_name": "Tokeniser",
        "class_uri": "src/main/java/org/jsoup/parser/Tokeniser.java.Tokeniser",
        "attributes": {
            "modifiers": "@Nullable",
            "marker_annotations": [
                "@Nullable"
            ],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/Tokeniser.java.Tokeniser.[String]appropriateEndTagSeq()",
        "name": "appropriateEndTagSeq",
        "arg_nums": 0,
        "params": [],
        "return_type": "String",
        "signature": "String appropriateEndTagSeq()",
        "original_string": "    String appropriateEndTagSeq() {\n        if (lastStartCloseSeq == null) // reset on start tag emit\n            lastStartCloseSeq = \"</\" + lastStartTag;\n        return lastStartCloseSeq;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/Tokeniser.java",
        "class_name": "Tokeniser",
        "class_uri": "src/main/java/org/jsoup/parser/Tokeniser.java.Tokeniser",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": " Returns the closer sequence {@code </lastStart}"
    },
    {
        "uris": "src/main/java/org/jsoup/parser/Tokeniser.java.Tokeniser.[void]error(TokeniserState)",
        "name": "error",
        "arg_nums": 1,
        "params": [
            {
                "name": "state",
                "type": "TokeniserState"
            }
        ],
        "return_type": "void",
        "signature": "void error(TokeniserState state)",
        "original_string": "    void error(TokeniserState state) {\n        if (errors.canAddError())\n            errors.add(new ParseError(reader, \"Unexpected character '%s' in input state [%s]\", reader.current(), state));\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/Tokeniser.java",
        "class_name": "Tokeniser",
        "class_uri": "src/main/java/org/jsoup/parser/Tokeniser.java.Tokeniser",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/Tokeniser.java.Tokeniser.[void]eofError(TokeniserState)",
        "name": "eofError",
        "arg_nums": 1,
        "params": [
            {
                "name": "state",
                "type": "TokeniserState"
            }
        ],
        "return_type": "void",
        "signature": "void eofError(TokeniserState state)",
        "original_string": "    void eofError(TokeniserState state) {\n        if (errors.canAddError())\n            errors.add(new ParseError(reader, \"Unexpectedly reached end of file (EOF) in input state [%s]\", state));\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/Tokeniser.java",
        "class_name": "Tokeniser",
        "class_uri": "src/main/java/org/jsoup/parser/Tokeniser.java.Tokeniser",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/Tokeniser.java.Tokeniser.[void]characterReferenceError(String)",
        "name": "characterReferenceError",
        "arg_nums": 1,
        "params": [
            {
                "name": "message",
                "type": "String"
            }
        ],
        "return_type": "void",
        "signature": "private void characterReferenceError(String message, Object... args)",
        "original_string": "    private void characterReferenceError(String message, Object... args) {\n        if (errors.canAddError())\n            errors.add(new ParseError(reader, String.format(\"Invalid character reference: \" + message, args)));\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/Tokeniser.java",
        "class_name": "Tokeniser",
        "class_uri": "src/main/java/org/jsoup/parser/Tokeniser.java.Tokeniser",
        "attributes": {
            "modifiers": "private",
            "marker_annotations": [],
            "non_marker_annotations": [
                "private"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/Tokeniser.java.Tokeniser.[void]error(String)",
        "name": "error",
        "arg_nums": 1,
        "params": [
            {
                "name": "errorMsg",
                "type": "String"
            }
        ],
        "return_type": "void",
        "signature": "void error(String errorMsg)",
        "original_string": "    void error(String errorMsg) {\n        if (errors.canAddError())\n            errors.add(new ParseError(reader, errorMsg));\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/Tokeniser.java",
        "class_name": "Tokeniser",
        "class_uri": "src/main/java/org/jsoup/parser/Tokeniser.java.Tokeniser",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/Tokeniser.java.Tokeniser.[void]error(String)",
        "name": "error",
        "arg_nums": 1,
        "params": [
            {
                "name": "errorMsg",
                "type": "String"
            }
        ],
        "return_type": "void",
        "signature": "void error(String errorMsg, Object... args)",
        "original_string": "    void error(String errorMsg, Object... args) {\n        if (errors.canAddError())\n            errors.add(new ParseError(reader, errorMsg, args));\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/Tokeniser.java",
        "class_name": "Tokeniser",
        "class_uri": "src/main/java/org/jsoup/parser/Tokeniser.java.Tokeniser",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/Tokeniser.java.Tokeniser.[boolean]currentNodeInHtmlNS()",
        "name": "currentNodeInHtmlNS",
        "arg_nums": 0,
        "params": [],
        "return_type": "boolean",
        "signature": "static boolean currentNodeInHtmlNS()",
        "original_string": "    static boolean currentNodeInHtmlNS() {\n        // todo: implement namespaces correctly\n        return true;\n        // Element currentNode = currentNode();\n        // return currentNode != null && currentNode.namespace().equals(\"HTML\");\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/Tokeniser.java",
        "class_name": "Tokeniser",
        "class_uri": "src/main/java/org/jsoup/parser/Tokeniser.java.Tokeniser",
        "attributes": {
            "modifiers": "static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "static"
            ],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/Tokeniser.java.Tokeniser.[String]unescapeEntities(boolean)",
        "name": "unescapeEntities",
        "arg_nums": 1,
        "params": [
            {
                "name": "inAttribute",
                "type": "boolean"
            }
        ],
        "return_type": "String",
        "signature": "String unescapeEntities(boolean inAttribute)",
        "original_string": "    String unescapeEntities(boolean inAttribute) {\n        StringBuilder builder = StringUtil.borrowBuilder();\n        while (!reader.isEmpty()) {\n            builder.append(reader.consumeTo('&'));\n            if (reader.matches('&')) {\n                reader.consume();\n                int[] c = consumeCharacterReference(null, inAttribute);\n                if (c == null || c.length==0)\n                    builder.append('&');\n                else {\n                    builder.appendCodePoint(c[0]);\n                    if (c.length == 2)\n                        builder.appendCodePoint(c[1]);\n                }\n\n            }\n        }\n        return StringUtil.releaseBuilder(builder);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/Tokeniser.java",
        "class_name": "Tokeniser",
        "class_uri": "src/main/java/org/jsoup/parser/Tokeniser.java.Tokeniser",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": "\nUtility method to consume reader and unescape entities found within.\n@param inAttribute if the text to be unescaped is in an attribute\n@return unescaped string from reader\n"
    },
    {
        "uris": "src/main/java/org/jsoup/parser/Token.java.Token.[]Token(TokenType)",
        "name": "Token",
        "arg_nums": 1,
        "params": [
            {
                "name": "type",
                "type": "TokenType"
            }
        ],
        "return_type": "",
        "signature": "private Token(TokenType type)",
        "original_string": "    private Token(TokenType type) {\n        this.type = type;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/Token.java",
        "class_name": "Token",
        "class_uri": "src/main/java/org/jsoup/parser/Token.java.Token",
        "attributes": {
            "modifiers": "private",
            "marker_annotations": [],
            "non_marker_annotations": [
                "private"
            ],
            "comments": [],
            "return_type": "",
            "classes": []
        },
        "docstring": " position in CharacterReader this token was read from"
    },
    {
        "uris": "src/main/java/org/jsoup/parser/Token.java.Token.[String]tokenType()",
        "name": "tokenType",
        "arg_nums": 0,
        "params": [],
        "return_type": "String",
        "signature": "String tokenType()",
        "original_string": "    String tokenType() {\n        return this.getClass().getSimpleName();\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/Token.java",
        "class_name": "Token",
        "class_uri": "src/main/java/org/jsoup/parser/Token.java.Token",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/Token.java.Token.[Token]reset()",
        "name": "reset",
        "arg_nums": 0,
        "params": [],
        "return_type": "Token",
        "signature": "Token reset()",
        "original_string": "    Token reset() {\n        startPos = Unset;\n        endPos = Unset;\n        return this;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/Token.java",
        "class_name": "Token",
        "class_uri": "src/main/java/org/jsoup/parser/Token.java.Token",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "Token",
            "classes": []
        },
        "docstring": "\nReset the data represent by this token, for reuse. Prevents the need to create transfer objects for every\npiece of data, which immediately get GCed.\n"
    },
    {
        "uris": "src/main/java/org/jsoup/parser/Token.java.Token.[int]startPos()",
        "name": "startPos",
        "arg_nums": 0,
        "params": [],
        "return_type": "int",
        "signature": "int startPos()",
        "original_string": "    int startPos() {\n        return startPos;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/Token.java",
        "class_name": "Token",
        "class_uri": "src/main/java/org/jsoup/parser/Token.java.Token",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "int",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/Token.java.Token.[void]startPos(int)",
        "name": "startPos",
        "arg_nums": 1,
        "params": [
            {
                "name": "pos",
                "type": "int"
            }
        ],
        "return_type": "void",
        "signature": "void startPos(int pos)",
        "original_string": "    void startPos(int pos) {\n        startPos = pos;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/Token.java",
        "class_name": "Token",
        "class_uri": "src/main/java/org/jsoup/parser/Token.java.Token",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/Token.java.Token.[int]endPos()",
        "name": "endPos",
        "arg_nums": 0,
        "params": [],
        "return_type": "int",
        "signature": "int endPos()",
        "original_string": "    int endPos() {\n        return endPos;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/Token.java",
        "class_name": "Token",
        "class_uri": "src/main/java/org/jsoup/parser/Token.java.Token",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "int",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/Token.java.Token.[void]endPos(int)",
        "name": "endPos",
        "arg_nums": 1,
        "params": [
            {
                "name": "pos",
                "type": "int"
            }
        ],
        "return_type": "void",
        "signature": "void endPos(int pos)",
        "original_string": "    void endPos(int pos) {\n        endPos = pos;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/Token.java",
        "class_name": "Token",
        "class_uri": "src/main/java/org/jsoup/parser/Token.java.Token",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/Token.java.Token.[void]reset(StringBuilder)",
        "name": "reset",
        "arg_nums": 1,
        "params": [
            {
                "name": "sb",
                "type": "StringBuilder"
            }
        ],
        "return_type": "void",
        "signature": "static void reset(StringBuilder sb)",
        "original_string": "    static void reset(StringBuilder sb) {\n        if (sb != null) {\n            sb.delete(0, sb.length());\n        }\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/Token.java",
        "class_name": "Token",
        "class_uri": "src/main/java/org/jsoup/parser/Token.java.Token",
        "attributes": {
            "modifiers": "static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "static"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/Token.java.Token.[boolean]isDoctype()",
        "name": "isDoctype",
        "arg_nums": 0,
        "params": [],
        "return_type": "boolean",
        "signature": "final boolean isDoctype()",
        "original_string": "    final boolean isDoctype() {\n        return type == TokenType.Doctype;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/Token.java",
        "class_name": "Token",
        "class_uri": "src/main/java/org/jsoup/parser/Token.java.Token",
        "attributes": {
            "modifiers": "final",
            "marker_annotations": [],
            "non_marker_annotations": [
                "final"
            ],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/Token.java.Token.[Doctype]asDoctype()",
        "name": "asDoctype",
        "arg_nums": 0,
        "params": [],
        "return_type": "Doctype",
        "signature": "final Doctype asDoctype()",
        "original_string": "    final Doctype asDoctype() {\n        return (Doctype) this;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/Token.java",
        "class_name": "Token",
        "class_uri": "src/main/java/org/jsoup/parser/Token.java.Token",
        "attributes": {
            "modifiers": "final",
            "marker_annotations": [],
            "non_marker_annotations": [
                "final"
            ],
            "comments": [],
            "return_type": "Doctype",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/Token.java.Token.[boolean]isStartTag()",
        "name": "isStartTag",
        "arg_nums": 0,
        "params": [],
        "return_type": "boolean",
        "signature": "final boolean isStartTag()",
        "original_string": "    final boolean isStartTag() {\n        return type == TokenType.StartTag;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/Token.java",
        "class_name": "Token",
        "class_uri": "src/main/java/org/jsoup/parser/Token.java.Token",
        "attributes": {
            "modifiers": "final",
            "marker_annotations": [],
            "non_marker_annotations": [
                "final"
            ],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/Token.java.Token.[StartTag]asStartTag()",
        "name": "asStartTag",
        "arg_nums": 0,
        "params": [],
        "return_type": "StartTag",
        "signature": "final StartTag asStartTag()",
        "original_string": "    final StartTag asStartTag() {\n        return (StartTag) this;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/Token.java",
        "class_name": "Token",
        "class_uri": "src/main/java/org/jsoup/parser/Token.java.Token",
        "attributes": {
            "modifiers": "final",
            "marker_annotations": [],
            "non_marker_annotations": [
                "final"
            ],
            "comments": [],
            "return_type": "StartTag",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/Token.java.Token.[boolean]isEndTag()",
        "name": "isEndTag",
        "arg_nums": 0,
        "params": [],
        "return_type": "boolean",
        "signature": "final boolean isEndTag()",
        "original_string": "    final boolean isEndTag() {\n        return type == TokenType.EndTag;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/Token.java",
        "class_name": "Token",
        "class_uri": "src/main/java/org/jsoup/parser/Token.java.Token",
        "attributes": {
            "modifiers": "final",
            "marker_annotations": [],
            "non_marker_annotations": [
                "final"
            ],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/Token.java.Token.[EndTag]asEndTag()",
        "name": "asEndTag",
        "arg_nums": 0,
        "params": [],
        "return_type": "EndTag",
        "signature": "final EndTag asEndTag()",
        "original_string": "    final EndTag asEndTag() {\n        return (EndTag) this;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/Token.java",
        "class_name": "Token",
        "class_uri": "src/main/java/org/jsoup/parser/Token.java.Token",
        "attributes": {
            "modifiers": "final",
            "marker_annotations": [],
            "non_marker_annotations": [
                "final"
            ],
            "comments": [],
            "return_type": "EndTag",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/Token.java.Token.[boolean]isComment()",
        "name": "isComment",
        "arg_nums": 0,
        "params": [],
        "return_type": "boolean",
        "signature": "final boolean isComment()",
        "original_string": "    final boolean isComment() {\n        return type == TokenType.Comment;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/Token.java",
        "class_name": "Token",
        "class_uri": "src/main/java/org/jsoup/parser/Token.java.Token",
        "attributes": {
            "modifiers": "final",
            "marker_annotations": [],
            "non_marker_annotations": [
                "final"
            ],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/Token.java.Token.[Comment]asComment()",
        "name": "asComment",
        "arg_nums": 0,
        "params": [],
        "return_type": "Comment",
        "signature": "final Comment asComment()",
        "original_string": "    final Comment asComment() {\n        return (Comment) this;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/Token.java",
        "class_name": "Token",
        "class_uri": "src/main/java/org/jsoup/parser/Token.java.Token",
        "attributes": {
            "modifiers": "final",
            "marker_annotations": [],
            "non_marker_annotations": [
                "final"
            ],
            "comments": [],
            "return_type": "Comment",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/Token.java.Token.[boolean]isCharacter()",
        "name": "isCharacter",
        "arg_nums": 0,
        "params": [],
        "return_type": "boolean",
        "signature": "final boolean isCharacter()",
        "original_string": "    final boolean isCharacter() {\n        return type == TokenType.Character;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/Token.java",
        "class_name": "Token",
        "class_uri": "src/main/java/org/jsoup/parser/Token.java.Token",
        "attributes": {
            "modifiers": "final",
            "marker_annotations": [],
            "non_marker_annotations": [
                "final"
            ],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/Token.java.Token.[boolean]isCData()",
        "name": "isCData",
        "arg_nums": 0,
        "params": [],
        "return_type": "boolean",
        "signature": "final boolean isCData()",
        "original_string": "    final boolean isCData() {\n        return this instanceof CData;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/Token.java",
        "class_name": "Token",
        "class_uri": "src/main/java/org/jsoup/parser/Token.java.Token",
        "attributes": {
            "modifiers": "final",
            "marker_annotations": [],
            "non_marker_annotations": [
                "final"
            ],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/Token.java.Token.[Character]asCharacter()",
        "name": "asCharacter",
        "arg_nums": 0,
        "params": [],
        "return_type": "Character",
        "signature": "final Character asCharacter()",
        "original_string": "    final Character asCharacter() {\n        return (Character) this;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/Token.java",
        "class_name": "Token",
        "class_uri": "src/main/java/org/jsoup/parser/Token.java.Token",
        "attributes": {
            "modifiers": "final",
            "marker_annotations": [],
            "non_marker_annotations": [
                "final"
            ],
            "comments": [],
            "return_type": "Character",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/Token.java.Token.[boolean]isEOF()",
        "name": "isEOF",
        "arg_nums": 0,
        "params": [],
        "return_type": "boolean",
        "signature": "final boolean isEOF()",
        "original_string": "    final boolean isEOF() {\n        return type == TokenType.EOF;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/Token.java",
        "class_name": "Token",
        "class_uri": "src/main/java/org/jsoup/parser/Token.java.Token",
        "attributes": {
            "modifiers": "final",
            "marker_annotations": [],
            "non_marker_annotations": [
                "final"
            ],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/Parser.java.Parser.[]Parser(TreeBuilder)",
        "name": "Parser",
        "arg_nums": 1,
        "params": [
            {
                "name": "treeBuilder",
                "type": "TreeBuilder"
            }
        ],
        "return_type": "",
        "signature": "public Parser(TreeBuilder treeBuilder)",
        "original_string": "    public Parser(TreeBuilder treeBuilder) {\n        this.treeBuilder = treeBuilder;\n        settings = treeBuilder.defaultSettings();\n        errors = ParseErrorList.noTracking();\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/Parser.java",
        "class_name": "Parser",
        "class_uri": "src/main/java/org/jsoup/parser/Parser.java.Parser",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "",
            "classes": []
        },
        "docstring": "\nCreate a new Parser, using the specified TreeBuilder\n@param treeBuilder TreeBuilder to use to parse input into Documents.\n"
    },
    {
        "uris": "src/main/java/org/jsoup/parser/Parser.java.Parser.[Parser]newInstance()",
        "name": "newInstance",
        "arg_nums": 0,
        "params": [],
        "return_type": "Parser",
        "signature": "public Parser newInstance()",
        "original_string": "    public Parser newInstance() {\n        return new Parser(this);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/Parser.java",
        "class_name": "Parser",
        "class_uri": "src/main/java/org/jsoup/parser/Parser.java.Parser",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Parser",
            "classes": []
        },
        "docstring": "\nCreates a new Parser as a deep copy of this; including initializing a new TreeBuilder. Allows independent (multi-threaded) use.\n@return a copied parser\n"
    },
    {
        "uris": "src/main/java/org/jsoup/parser/Parser.java.Parser.[]Parser(Parser)",
        "name": "Parser",
        "arg_nums": 1,
        "params": [
            {
                "name": "copy",
                "type": "Parser"
            }
        ],
        "return_type": "",
        "signature": "private Parser(Parser copy)",
        "original_string": "    private Parser(Parser copy) {\n        treeBuilder = copy.treeBuilder.newInstance(); // because extended\n        errors = new ParseErrorList(copy.errors); // only copies size, not contents\n        settings = new ParseSettings(copy.settings);\n        trackPosition = copy.trackPosition;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/Parser.java",
        "class_name": "Parser",
        "class_uri": "src/main/java/org/jsoup/parser/Parser.java.Parser",
        "attributes": {
            "modifiers": "private",
            "marker_annotations": [],
            "non_marker_annotations": [
                "private"
            ],
            "comments": [],
            "return_type": "",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/Parser.java.Parser.[Document]parseInput(String,String)",
        "name": "parseInput",
        "arg_nums": 2,
        "params": [
            {
                "name": "html",
                "type": "String"
            },
            {
                "name": "baseUri",
                "type": "String"
            }
        ],
        "return_type": "Document",
        "signature": "public Document parseInput(String html, String baseUri)",
        "original_string": "    public Document parseInput(String html, String baseUri) {\n        return treeBuilder.parse(new StringReader(html), baseUri, this);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/Parser.java",
        "class_name": "Parser",
        "class_uri": "src/main/java/org/jsoup/parser/Parser.java.Parser",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Document",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/Parser.java.Parser.[Document]parseInput(Reader,String)",
        "name": "parseInput",
        "arg_nums": 2,
        "params": [
            {
                "name": "inputHtml",
                "type": "Reader"
            },
            {
                "name": "baseUri",
                "type": "String"
            }
        ],
        "return_type": "Document",
        "signature": "public Document parseInput(Reader inputHtml, String baseUri)",
        "original_string": "    public Document parseInput(Reader inputHtml, String baseUri) {\n        return treeBuilder.parse(inputHtml, baseUri, this);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/Parser.java",
        "class_name": "Parser",
        "class_uri": "src/main/java/org/jsoup/parser/Parser.java.Parser",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Document",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/Parser.java.Parser.[List<Node>]parseFragmentInput(String,Element,String)",
        "name": "parseFragmentInput",
        "arg_nums": 3,
        "params": [
            {
                "name": "fragment",
                "type": "String"
            },
            {
                "name": "context",
                "type": "Element"
            },
            {
                "name": "baseUri",
                "type": "String"
            }
        ],
        "return_type": "List<Node>",
        "signature": "public List<Node> parseFragmentInput(String fragment, @Nullable Element context, String baseUri)",
        "original_string": "    public List<Node> parseFragmentInput(String fragment, @Nullable Element context, String baseUri) {\n        return treeBuilder.parseFragment(fragment, context, baseUri, this);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/Parser.java",
        "class_name": "Parser",
        "class_uri": "src/main/java/org/jsoup/parser/Parser.java.Parser",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "List<Node>",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/Parser.java.Parser.[TreeBuilder]getTreeBuilder()",
        "name": "getTreeBuilder",
        "arg_nums": 0,
        "params": [],
        "return_type": "TreeBuilder",
        "signature": "public TreeBuilder getTreeBuilder()",
        "original_string": "    public TreeBuilder getTreeBuilder() {\n        return treeBuilder;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/Parser.java",
        "class_name": "Parser",
        "class_uri": "src/main/java/org/jsoup/parser/Parser.java.Parser",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "TreeBuilder",
            "classes": []
        },
        "docstring": "\nGet the TreeBuilder currently in use.\n@return current TreeBuilder.\n"
    },
    {
        "uris": "src/main/java/org/jsoup/parser/Parser.java.Parser.[Parser]setTreeBuilder(TreeBuilder)",
        "name": "setTreeBuilder",
        "arg_nums": 1,
        "params": [
            {
                "name": "treeBuilder",
                "type": "TreeBuilder"
            }
        ],
        "return_type": "Parser",
        "signature": "public Parser setTreeBuilder(TreeBuilder treeBuilder)",
        "original_string": "    public Parser setTreeBuilder(TreeBuilder treeBuilder) {\n        this.treeBuilder = treeBuilder;\n        treeBuilder.parser = this;\n        return this;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/Parser.java",
        "class_name": "Parser",
        "class_uri": "src/main/java/org/jsoup/parser/Parser.java.Parser",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Parser",
            "classes": []
        },
        "docstring": "\nUpdate the TreeBuilder used when parsing content.\n@param treeBuilder new TreeBuilder\n@return this, for chaining\n"
    },
    {
        "uris": "src/main/java/org/jsoup/parser/Parser.java.Parser.[boolean]isTrackErrors()",
        "name": "isTrackErrors",
        "arg_nums": 0,
        "params": [],
        "return_type": "boolean",
        "signature": "public boolean isTrackErrors()",
        "original_string": "    public boolean isTrackErrors() {\n        return errors.getMaxSize() > 0;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/Parser.java",
        "class_name": "Parser",
        "class_uri": "src/main/java/org/jsoup/parser/Parser.java.Parser",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": "\nCheck if parse error tracking is enabled.\n@return current track error state.\n"
    },
    {
        "uris": "src/main/java/org/jsoup/parser/Parser.java.Parser.[Parser]setTrackErrors(int)",
        "name": "setTrackErrors",
        "arg_nums": 1,
        "params": [
            {
                "name": "maxErrors",
                "type": "int"
            }
        ],
        "return_type": "Parser",
        "signature": "public Parser setTrackErrors(int maxErrors)",
        "original_string": "    public Parser setTrackErrors(int maxErrors) {\n        errors = maxErrors > 0 ? ParseErrorList.tracking(maxErrors) : ParseErrorList.noTracking();\n        return this;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/Parser.java",
        "class_name": "Parser",
        "class_uri": "src/main/java/org/jsoup/parser/Parser.java.Parser",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Parser",
            "classes": []
        },
        "docstring": "\nEnable or disable parse error tracking for the next parse.\n@param maxErrors the maximum number of errors to track. Set to 0 to disable.\n@return this, for chaining\n"
    },
    {
        "uris": "src/main/java/org/jsoup/parser/Parser.java.Parser.[ParseErrorList]getErrors()",
        "name": "getErrors",
        "arg_nums": 0,
        "params": [],
        "return_type": "ParseErrorList",
        "signature": "public ParseErrorList getErrors()",
        "original_string": "    public ParseErrorList getErrors() {\n        return errors;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/Parser.java",
        "class_name": "Parser",
        "class_uri": "src/main/java/org/jsoup/parser/Parser.java.Parser",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "ParseErrorList",
            "classes": []
        },
        "docstring": "\nRetrieve the parse errors, if any, from the last parse.\n@return list of parse errors, up to the size of the maximum errors tracked.\n@see #setTrackErrors(int)\n"
    },
    {
        "uris": "src/main/java/org/jsoup/parser/Parser.java.Parser.[boolean]isTrackPosition()",
        "name": "isTrackPosition",
        "arg_nums": 0,
        "params": [],
        "return_type": "boolean",
        "signature": "public boolean isTrackPosition()",
        "original_string": "    public boolean isTrackPosition() {\n        return trackPosition;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/Parser.java",
        "class_name": "Parser",
        "class_uri": "src/main/java/org/jsoup/parser/Parser.java.Parser",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": "\nTest if position tracking is enabled. If it is, Nodes will have a Position to track where in the original input\nsource they were created from. By default, tracking is not enabled.\n@return current track position setting\n"
    },
    {
        "uris": "src/main/java/org/jsoup/parser/Parser.java.Parser.[Parser]setTrackPosition(boolean)",
        "name": "setTrackPosition",
        "arg_nums": 1,
        "params": [
            {
                "name": "trackPosition",
                "type": "boolean"
            }
        ],
        "return_type": "Parser",
        "signature": "public Parser setTrackPosition(boolean trackPosition)",
        "original_string": "    public Parser setTrackPosition(boolean trackPosition) {\n        this.trackPosition = trackPosition;\n        return this;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/Parser.java",
        "class_name": "Parser",
        "class_uri": "src/main/java/org/jsoup/parser/Parser.java.Parser",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Parser",
            "classes": []
        },
        "docstring": "\nEnable or disable source position tracking. If enabled, Nodes will have a Position to track where in the original\ninput source they were created from.\n@param trackPosition position tracking setting; {@code true} to enable\n@return this Parser, for chaining\n"
    },
    {
        "uris": "src/main/java/org/jsoup/parser/Parser.java.Parser.[Parser]settings(ParseSettings)",
        "name": "settings",
        "arg_nums": 1,
        "params": [
            {
                "name": "settings",
                "type": "ParseSettings"
            }
        ],
        "return_type": "Parser",
        "signature": "public Parser settings(ParseSettings settings)",
        "original_string": "    public Parser settings(ParseSettings settings) {\n        this.settings = settings;\n        return this;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/Parser.java",
        "class_name": "Parser",
        "class_uri": "src/main/java/org/jsoup/parser/Parser.java.Parser",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Parser",
            "classes": []
        },
        "docstring": "\nUpdate the ParseSettings of this Parser, to control the case sensitivity of tags and attributes.\n@param settings the new settings\n@return this Parser\n"
    },
    {
        "uris": "src/main/java/org/jsoup/parser/Parser.java.Parser.[ParseSettings]settings()",
        "name": "settings",
        "arg_nums": 0,
        "params": [],
        "return_type": "ParseSettings",
        "signature": "public ParseSettings settings()",
        "original_string": "    public ParseSettings settings() {\n        return settings;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/Parser.java",
        "class_name": "Parser",
        "class_uri": "src/main/java/org/jsoup/parser/Parser.java.Parser",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "ParseSettings",
            "classes": []
        },
        "docstring": "\nGets the current ParseSettings for this Parser\n@return current ParseSettings\n"
    },
    {
        "uris": "src/main/java/org/jsoup/parser/Parser.java.Parser.[boolean]isContentForTagData(String)",
        "name": "isContentForTagData",
        "arg_nums": 1,
        "params": [
            {
                "name": "normalName",
                "type": "String"
            }
        ],
        "return_type": "boolean",
        "signature": "public boolean isContentForTagData(String normalName)",
        "original_string": "    public boolean isContentForTagData(String normalName) {\n        return getTreeBuilder().isContentForTagData(normalName);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/Parser.java",
        "class_name": "Parser",
        "class_uri": "src/main/java/org/jsoup/parser/Parser.java.Parser",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": "\n(An internal method, visible for Element. For HTML parse, signals that script and style text should be treated as\nData Nodes).\n"
    },
    {
        "uris": "src/main/java/org/jsoup/parser/Parser.java.Parser.[String]defaultNamespace()",
        "name": "defaultNamespace",
        "arg_nums": 0,
        "params": [],
        "return_type": "String",
        "signature": "public String defaultNamespace()",
        "original_string": "    public String defaultNamespace() {\n        return getTreeBuilder().defaultNamespace();\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/Parser.java",
        "class_name": "Parser",
        "class_uri": "src/main/java/org/jsoup/parser/Parser.java.Parser",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/Parser.java.Parser.[Document]parse(String,String)",
        "name": "parse",
        "arg_nums": 2,
        "params": [
            {
                "name": "html",
                "type": "String"
            },
            {
                "name": "baseUri",
                "type": "String"
            }
        ],
        "return_type": "Document",
        "signature": "public static Document parse(String html, String baseUri)",
        "original_string": "    public static Document parse(String html, String baseUri) {\n        TreeBuilder treeBuilder = new HtmlTreeBuilder();\n        return treeBuilder.parse(new StringReader(html), baseUri, new Parser(treeBuilder));\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/Parser.java",
        "class_name": "Parser",
        "class_uri": "src/main/java/org/jsoup/parser/Parser.java.Parser",
        "attributes": {
            "modifiers": "public static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public",
                "static"
            ],
            "comments": [],
            "return_type": "Document",
            "classes": []
        },
        "docstring": "\nParse HTML into a Document.\n\n@param html HTML to parse\n@param baseUri base URI of document (i.e. original fetch location), for resolving relative URLs.\n\n@return parsed Document\n"
    },
    {
        "uris": "src/main/java/org/jsoup/parser/Parser.java.Parser.[List<Node>]parseFragment(String,Element,String)",
        "name": "parseFragment",
        "arg_nums": 3,
        "params": [
            {
                "name": "fragmentHtml",
                "type": "String"
            },
            {
                "name": "context",
                "type": "Element"
            },
            {
                "name": "baseUri",
                "type": "String"
            }
        ],
        "return_type": "List<Node>",
        "signature": "public static List<Node> parseFragment(String fragmentHtml, Element context, String baseUri)",
        "original_string": "    public static List<Node> parseFragment(String fragmentHtml, Element context, String baseUri) {\n        HtmlTreeBuilder treeBuilder = new HtmlTreeBuilder();\n        return treeBuilder.parseFragment(fragmentHtml, context, baseUri, new Parser(treeBuilder));\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/Parser.java",
        "class_name": "Parser",
        "class_uri": "src/main/java/org/jsoup/parser/Parser.java.Parser",
        "attributes": {
            "modifiers": "public static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public",
                "static"
            ],
            "comments": [],
            "return_type": "List<Node>",
            "classes": []
        },
        "docstring": "\nParse a fragment of HTML into a list of nodes. The context element, if supplied, supplies parsing context.\n\n@param fragmentHtml the fragment of HTML to parse\n@param context (optional) the element that this HTML fragment is being parsed for (i.e. for inner HTML). This\nprovides stack context (for implicit element creation).\n@param baseUri base URI of document (i.e. original fetch location), for resolving relative URLs.\n\n@return list of nodes parsed from the input HTML. Note that the context element, if supplied, is not modified.\n"
    },
    {
        "uris": "src/main/java/org/jsoup/parser/Parser.java.Parser.[List<Node>]parseFragment(String,Element,String,ParseErrorList)",
        "name": "parseFragment",
        "arg_nums": 4,
        "params": [
            {
                "name": "fragmentHtml",
                "type": "String"
            },
            {
                "name": "context",
                "type": "Element"
            },
            {
                "name": "baseUri",
                "type": "String"
            },
            {
                "name": "errorList",
                "type": "ParseErrorList"
            }
        ],
        "return_type": "List<Node>",
        "signature": "public static List<Node> parseFragment(String fragmentHtml, Element context, String baseUri, ParseErrorList errorList)",
        "original_string": "    public static List<Node> parseFragment(String fragmentHtml, Element context, String baseUri, ParseErrorList errorList) {\n        HtmlTreeBuilder treeBuilder = new HtmlTreeBuilder();\n        Parser parser = new Parser(treeBuilder);\n        parser.errors = errorList;\n        return treeBuilder.parseFragment(fragmentHtml, context, baseUri, parser);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/Parser.java",
        "class_name": "Parser",
        "class_uri": "src/main/java/org/jsoup/parser/Parser.java.Parser",
        "attributes": {
            "modifiers": "public static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public",
                "static"
            ],
            "comments": [],
            "return_type": "List<Node>",
            "classes": []
        },
        "docstring": "\nParse a fragment of HTML into a list of nodes. The context element, if supplied, supplies parsing context.\n\n@param fragmentHtml the fragment of HTML to parse\n@param context (optional) the element that this HTML fragment is being parsed for (i.e. for inner HTML). This\nprovides stack context (for implicit element creation).\n@param baseUri base URI of document (i.e. original fetch location), for resolving relative URLs.\n@param errorList list to add errors to\n\n@return list of nodes parsed from the input HTML. Note that the context element, if supplied, is not modified.\n"
    },
    {
        "uris": "src/main/java/org/jsoup/parser/Parser.java.Parser.[List<Node>]parseXmlFragment(String,String)",
        "name": "parseXmlFragment",
        "arg_nums": 2,
        "params": [
            {
                "name": "fragmentXml",
                "type": "String"
            },
            {
                "name": "baseUri",
                "type": "String"
            }
        ],
        "return_type": "List<Node>",
        "signature": "public static List<Node> parseXmlFragment(String fragmentXml, String baseUri)",
        "original_string": "    public static List<Node> parseXmlFragment(String fragmentXml, String baseUri) {\n        XmlTreeBuilder treeBuilder = new XmlTreeBuilder();\n        return treeBuilder.parseFragment(fragmentXml, null, baseUri, new Parser(treeBuilder));\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/Parser.java",
        "class_name": "Parser",
        "class_uri": "src/main/java/org/jsoup/parser/Parser.java.Parser",
        "attributes": {
            "modifiers": "public static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public",
                "static"
            ],
            "comments": [],
            "return_type": "List<Node>",
            "classes": []
        },
        "docstring": "\nParse a fragment of XML into a list of nodes.\n\n@param fragmentXml the fragment of XML to parse\n@param baseUri base URI of document (i.e. original fetch location), for resolving relative URLs.\n@return list of nodes parsed from the input XML.\n"
    },
    {
        "uris": "src/main/java/org/jsoup/parser/Parser.java.Parser.[Document]parseBodyFragment(String,String)",
        "name": "parseBodyFragment",
        "arg_nums": 2,
        "params": [
            {
                "name": "bodyHtml",
                "type": "String"
            },
            {
                "name": "baseUri",
                "type": "String"
            }
        ],
        "return_type": "Document",
        "signature": "public static Document parseBodyFragment(String bodyHtml, String baseUri)",
        "original_string": "    public static Document parseBodyFragment(String bodyHtml, String baseUri) {\n        Document doc = Document.createShell(baseUri);\n        Element body = doc.body();\n        List<Node> nodeList = parseFragment(bodyHtml, body, baseUri);\n        Node[] nodes = nodeList.toArray(new Node[0]); // the node list gets modified when re-parented\n        for (int i = nodes.length - 1; i > 0; i--) {\n            nodes[i].remove();\n        }\n        for (Node node : nodes) {\n            body.appendChild(node);\n        }\n        return doc;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/Parser.java",
        "class_name": "Parser",
        "class_uri": "src/main/java/org/jsoup/parser/Parser.java.Parser",
        "attributes": {
            "modifiers": "public static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public",
                "static"
            ],
            "comments": [],
            "return_type": "Document",
            "classes": []
        },
        "docstring": "\nParse a fragment of HTML into the {@code body} of a Document.\n\n@param bodyHtml fragment of HTML\n@param baseUri base URI of document (i.e. original fetch location), for resolving relative URLs.\n\n@return Document, with empty head, and HTML parsed into body\n"
    },
    {
        "uris": "src/main/java/org/jsoup/parser/Parser.java.Parser.[String]unescapeEntities(String,boolean)",
        "name": "unescapeEntities",
        "arg_nums": 2,
        "params": [
            {
                "name": "string",
                "type": "String"
            },
            {
                "name": "inAttribute",
                "type": "boolean"
            }
        ],
        "return_type": "String",
        "signature": "public static String unescapeEntities(String string, boolean inAttribute)",
        "original_string": "    public static String unescapeEntities(String string, boolean inAttribute) {\n        Parser parser = Parser.htmlParser();\n        parser.treeBuilder.initialiseParse(new StringReader(string), \"\", parser);\n        Tokeniser tokeniser = new Tokeniser(parser.treeBuilder);\n        return tokeniser.unescapeEntities(inAttribute);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/Parser.java",
        "class_name": "Parser",
        "class_uri": "src/main/java/org/jsoup/parser/Parser.java.Parser",
        "attributes": {
            "modifiers": "public static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public",
                "static"
            ],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": "\nUtility method to unescape HTML entities from a string\n@param string HTML escaped string\n@param inAttribute if the string is to be escaped in strict mode (as attributes are)\n@return an unescaped string\n"
    },
    {
        "uris": "src/main/java/org/jsoup/parser/Parser.java.Parser.[Parser]htmlParser()",
        "name": "htmlParser",
        "arg_nums": 0,
        "params": [],
        "return_type": "Parser",
        "signature": "public static Parser htmlParser()",
        "original_string": "    public static Parser htmlParser() {\n        return new Parser(new HtmlTreeBuilder());\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/Parser.java",
        "class_name": "Parser",
        "class_uri": "src/main/java/org/jsoup/parser/Parser.java.Parser",
        "attributes": {
            "modifiers": "public static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public",
                "static"
            ],
            "comments": [],
            "return_type": "Parser",
            "classes": []
        },
        "docstring": "\nCreate a new HTML parser. This parser treats input as HTML5, and enforces the creation of a normalised document,\nbased on a knowledge of the semantics of the incoming tags.\n@return a new HTML parser.\n"
    },
    {
        "uris": "src/main/java/org/jsoup/parser/Parser.java.Parser.[Parser]xmlParser()",
        "name": "xmlParser",
        "arg_nums": 0,
        "params": [],
        "return_type": "Parser",
        "signature": "public static Parser xmlParser()",
        "original_string": "    public static Parser xmlParser() {\n        return new Parser(new XmlTreeBuilder());\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/Parser.java",
        "class_name": "Parser",
        "class_uri": "src/main/java/org/jsoup/parser/Parser.java.Parser",
        "attributes": {
            "modifiers": "public static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public",
                "static"
            ],
            "comments": [],
            "return_type": "Parser",
            "classes": []
        },
        "docstring": "\nCreate a new XML parser. This parser assumes no knowledge of the incoming tags and does not treat it as HTML,\nrather creates a simple tree directly from the input.\n@return a new simple XML parser.\n"
    },
    {
        "uris": "src/main/java/org/jsoup/parser/TokenQueue.java.TokenQueue.[]TokenQueue(String)",
        "name": "TokenQueue",
        "arg_nums": 1,
        "params": [
            {
                "name": "data",
                "type": "String"
            }
        ],
        "return_type": "",
        "signature": "public TokenQueue(String data)",
        "original_string": "    public TokenQueue(String data) {\n        Validate.notNull(data);\n        queue = data;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/TokenQueue.java",
        "class_name": "TokenQueue",
        "class_uri": "src/main/java/org/jsoup/parser/TokenQueue.java.TokenQueue",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "",
            "classes": []
        },
        "docstring": "\nCreate a new TokenQueue.\n@param data string of data to back queue.\n"
    },
    {
        "uris": "src/main/java/org/jsoup/parser/TokenQueue.java.TokenQueue.[boolean]isEmpty()",
        "name": "isEmpty",
        "arg_nums": 0,
        "params": [],
        "return_type": "boolean",
        "signature": "public boolean isEmpty()",
        "original_string": "    public boolean isEmpty() {\n        return remainingLength() == 0;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/TokenQueue.java",
        "class_name": "TokenQueue",
        "class_uri": "src/main/java/org/jsoup/parser/TokenQueue.java.TokenQueue",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": "\nIs the queue empty?\n@return true if no data left in queue.\n"
    },
    {
        "uris": "src/main/java/org/jsoup/parser/TokenQueue.java.TokenQueue.[int]remainingLength()",
        "name": "remainingLength",
        "arg_nums": 0,
        "params": [],
        "return_type": "int",
        "signature": "private int remainingLength()",
        "original_string": "    private int remainingLength() {\n        return queue.length() - pos;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/TokenQueue.java",
        "class_name": "TokenQueue",
        "class_uri": "src/main/java/org/jsoup/parser/TokenQueue.java.TokenQueue",
        "attributes": {
            "modifiers": "private",
            "marker_annotations": [],
            "non_marker_annotations": [
                "private"
            ],
            "comments": [],
            "return_type": "int",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/TokenQueue.java.TokenQueue.[void]addFirst(String)",
        "name": "addFirst",
        "arg_nums": 1,
        "params": [
            {
                "name": "seq",
                "type": "String"
            }
        ],
        "return_type": "void",
        "signature": "public void addFirst(String seq)",
        "original_string": "    public void addFirst(String seq) {\n        // not very performant, but an edge case\n        queue = seq + queue.substring(pos);\n        pos = 0;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/TokenQueue.java",
        "class_name": "TokenQueue",
        "class_uri": "src/main/java/org/jsoup/parser/TokenQueue.java.TokenQueue",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": "\nAdd a string to the start of the queue.\n@param seq string to add.\n"
    },
    {
        "uris": "src/main/java/org/jsoup/parser/TokenQueue.java.TokenQueue.[boolean]matches(String)",
        "name": "matches",
        "arg_nums": 1,
        "params": [
            {
                "name": "seq",
                "type": "String"
            }
        ],
        "return_type": "boolean",
        "signature": "public boolean matches(String seq)",
        "original_string": "    public boolean matches(String seq) {\n        return queue.regionMatches(true, pos, seq, 0, seq.length());\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/TokenQueue.java",
        "class_name": "TokenQueue",
        "class_uri": "src/main/java/org/jsoup/parser/TokenQueue.java.TokenQueue",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": "\nTests if the next characters on the queue match the sequence. Case insensitive.\n@param seq String to check queue for.\n@return true if the next characters match.\n"
    },
    {
        "uris": "src/main/java/org/jsoup/parser/TokenQueue.java.TokenQueue.[boolean]matchesAny()",
        "name": "matchesAny",
        "arg_nums": 0,
        "params": [],
        "return_type": "boolean",
        "signature": "public boolean matchesAny(String... seq)",
        "original_string": "    public boolean matchesAny(String... seq) {\n        for (String s : seq) {\n            if (matches(s))\n                return true;\n        }\n        return false;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/TokenQueue.java",
        "class_name": "TokenQueue",
        "class_uri": "src/main/java/org/jsoup/parser/TokenQueue.java.TokenQueue",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": "\nTests if the next characters match any of the sequences. Case insensitive.\n@param seq list of strings to case insensitively check for\n@return true of any matched, false if none did\n"
    },
    {
        "uris": "src/main/java/org/jsoup/parser/TokenQueue.java.TokenQueue.[boolean]matchesAny()",
        "name": "matchesAny",
        "arg_nums": 0,
        "params": [],
        "return_type": "boolean",
        "signature": "public boolean matchesAny(char... seq)",
        "original_string": "    public boolean matchesAny(char... seq) {\n        if (isEmpty())\n            return false;\n\n        for (char c: seq) {\n            if (queue.charAt(pos) == c)\n                return true;\n        }\n        return false;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/TokenQueue.java",
        "class_name": "TokenQueue",
        "class_uri": "src/main/java/org/jsoup/parser/TokenQueue.java.TokenQueue",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/TokenQueue.java.TokenQueue.[boolean]matchChomp(String)",
        "name": "matchChomp",
        "arg_nums": 1,
        "params": [
            {
                "name": "seq",
                "type": "String"
            }
        ],
        "return_type": "boolean",
        "signature": "public boolean matchChomp(String seq)",
        "original_string": "    public boolean matchChomp(String seq) {\n        if (matches(seq)) {\n            pos += seq.length();\n            return true;\n        } else {\n            return false;\n        }\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/TokenQueue.java",
        "class_name": "TokenQueue",
        "class_uri": "src/main/java/org/jsoup/parser/TokenQueue.java.TokenQueue",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": "\nTests if the queue matches the sequence (as with match), and if they do, removes the matched string from the\nqueue.\n@param seq String to search for, and if found, remove from queue.\n@return true if found and removed, false if not found.\n"
    },
    {
        "uris": "src/main/java/org/jsoup/parser/TokenQueue.java.TokenQueue.[boolean]matchesWhitespace()",
        "name": "matchesWhitespace",
        "arg_nums": 0,
        "params": [],
        "return_type": "boolean",
        "signature": "public boolean matchesWhitespace()",
        "original_string": "    public boolean matchesWhitespace() {\n        return !isEmpty() && StringUtil.isWhitespace(queue.charAt(pos));\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/TokenQueue.java",
        "class_name": "TokenQueue",
        "class_uri": "src/main/java/org/jsoup/parser/TokenQueue.java.TokenQueue",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": "\nTests if queue starts with a whitespace character.\n@return if starts with whitespace\n"
    },
    {
        "uris": "src/main/java/org/jsoup/parser/TokenQueue.java.TokenQueue.[boolean]matchesWord()",
        "name": "matchesWord",
        "arg_nums": 0,
        "params": [],
        "return_type": "boolean",
        "signature": "public boolean matchesWord()",
        "original_string": "    public boolean matchesWord() {\n        return !isEmpty() && Character.isLetterOrDigit(queue.charAt(pos));\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/TokenQueue.java",
        "class_name": "TokenQueue",
        "class_uri": "src/main/java/org/jsoup/parser/TokenQueue.java.TokenQueue",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": "\nTest if the queue matches a word character (letter or digit).\n@return if matches a word character\n"
    },
    {
        "uris": "src/main/java/org/jsoup/parser/TokenQueue.java.TokenQueue.[void]advance()",
        "name": "advance",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "public void advance()",
        "original_string": "    public void advance() {\n        if (!isEmpty()) pos++;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/TokenQueue.java",
        "class_name": "TokenQueue",
        "class_uri": "src/main/java/org/jsoup/parser/TokenQueue.java.TokenQueue",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": "\nDrops the next character off the queue.\n"
    },
    {
        "uris": "src/main/java/org/jsoup/parser/TokenQueue.java.TokenQueue.[char]consume()",
        "name": "consume",
        "arg_nums": 0,
        "params": [],
        "return_type": "char",
        "signature": "public char consume()",
        "original_string": "    public char consume() {\n        return queue.charAt(pos++);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/TokenQueue.java",
        "class_name": "TokenQueue",
        "class_uri": "src/main/java/org/jsoup/parser/TokenQueue.java.TokenQueue",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "char",
            "classes": []
        },
        "docstring": "\nConsume one character off queue.\n@return first character on queue.\n"
    },
    {
        "uris": "src/main/java/org/jsoup/parser/TokenQueue.java.TokenQueue.[void]consume(String)",
        "name": "consume",
        "arg_nums": 1,
        "params": [
            {
                "name": "seq",
                "type": "String"
            }
        ],
        "return_type": "void",
        "signature": "public void consume(String seq)",
        "original_string": "    public void consume(String seq) {\n        if (!matches(seq))\n            throw new IllegalStateException(\"Queue did not match expected sequence\");\n        int len = seq.length();\n        if (len > remainingLength())\n            throw new IllegalStateException(\"Queue not long enough to consume sequence\");\n        \n        pos += len;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/TokenQueue.java",
        "class_name": "TokenQueue",
        "class_uri": "src/main/java/org/jsoup/parser/TokenQueue.java.TokenQueue",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": "\nConsumes the supplied sequence of the queue. If the queue does not start with the supplied sequence, will\nthrow an illegal state exception -- but you should be running match() against that condition.\n<p>\nCase insensitive.\n@param seq sequence to remove from head of queue.\n"
    },
    {
        "uris": "src/main/java/org/jsoup/parser/TokenQueue.java.TokenQueue.[String]consumeTo(String)",
        "name": "consumeTo",
        "arg_nums": 1,
        "params": [
            {
                "name": "seq",
                "type": "String"
            }
        ],
        "return_type": "String",
        "signature": "public String consumeTo(String seq)",
        "original_string": "    public String consumeTo(String seq) {\n        int offset = queue.indexOf(seq, pos);\n        if (offset != -1) {\n            String consumed = queue.substring(pos, offset);\n            pos += consumed.length();\n            return consumed;\n        } else {\n            return remainder();\n        }\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/TokenQueue.java",
        "class_name": "TokenQueue",
        "class_uri": "src/main/java/org/jsoup/parser/TokenQueue.java.TokenQueue",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": "\nPulls a string off the queue, up to but exclusive of the match sequence, or to the queue running out.\n@param seq String to end on (and not include in return, but leave on queue). <b>Case sensitive.</b>\n@return The matched data consumed from queue.\n"
    },
    {
        "uris": "src/main/java/org/jsoup/parser/TokenQueue.java.TokenQueue.[String]consumeToIgnoreCase(String)",
        "name": "consumeToIgnoreCase",
        "arg_nums": 1,
        "params": [
            {
                "name": "seq",
                "type": "String"
            }
        ],
        "return_type": "String",
        "signature": "public String consumeToIgnoreCase(String seq)",
        "original_string": "    public String consumeToIgnoreCase(String seq) {\n        int start = pos;\n        String first = seq.substring(0, 1);\n        boolean canScan = first.toLowerCase().equals(first.toUpperCase()); // if first is not cased, use index of\n        while (!isEmpty()) {\n            if (matches(seq))\n                break;\n            \n            if (canScan) {\n                int skip = queue.indexOf(first, pos) - pos;\n                if (skip == 0) // this char is the skip char, but not match, so force advance of pos\n                    pos++;\n                else if (skip < 0) // no chance of finding, grab to end\n                    pos = queue.length();\n                else\n                    pos += skip;\n            }\n            else\n                pos++;\n        }\n\n        return queue.substring(start, pos);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/TokenQueue.java",
        "class_name": "TokenQueue",
        "class_uri": "src/main/java/org/jsoup/parser/TokenQueue.java.TokenQueue",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/TokenQueue.java.TokenQueue.[String]consumeToAny()",
        "name": "consumeToAny",
        "arg_nums": 0,
        "params": [],
        "return_type": "String",
        "signature": "public String consumeToAny(String... seq)",
        "original_string": "    public String consumeToAny(String... seq) {\n        int start = pos;\n        while (!isEmpty() && !matchesAny(seq)) {\n            pos++;\n        }\n\n        return queue.substring(start, pos);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/TokenQueue.java",
        "class_name": "TokenQueue",
        "class_uri": "src/main/java/org/jsoup/parser/TokenQueue.java.TokenQueue",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": " is a case sensitive time..."
    },
    {
        "uris": "src/main/java/org/jsoup/parser/TokenQueue.java.TokenQueue.[String]chompTo(String)",
        "name": "chompTo",
        "arg_nums": 1,
        "params": [
            {
                "name": "seq",
                "type": "String"
            }
        ],
        "return_type": "String",
        "signature": "public String chompTo(String seq)",
        "original_string": "    public String chompTo(String seq) {\n        String data = consumeTo(seq);\n        matchChomp(seq);\n        return data;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/TokenQueue.java",
        "class_name": "TokenQueue",
        "class_uri": "src/main/java/org/jsoup/parser/TokenQueue.java.TokenQueue",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": "\nPulls a string off the queue (like consumeTo), and then pulls off the matched string (but does not return it).\n<p>\nIf the queue runs out of characters before finding the seq, will return as much as it can (and queue will go\nisEmpty() == true).\n@param seq String to match up to, and not include in return, and to pull off queue. <b>Case sensitive.</b>\n@return Data matched from queue.\n"
    },
    {
        "uris": "src/main/java/org/jsoup/parser/TokenQueue.java.TokenQueue.[String]chompToIgnoreCase(String)",
        "name": "chompToIgnoreCase",
        "arg_nums": 1,
        "params": [
            {
                "name": "seq",
                "type": "String"
            }
        ],
        "return_type": "String",
        "signature": "public String chompToIgnoreCase(String seq)",
        "original_string": "    public String chompToIgnoreCase(String seq) {\n        String data = consumeToIgnoreCase(seq); // case insensitive scan\n        matchChomp(seq);\n        return data;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/TokenQueue.java",
        "class_name": "TokenQueue",
        "class_uri": "src/main/java/org/jsoup/parser/TokenQueue.java.TokenQueue",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/TokenQueue.java.TokenQueue.[String]chompBalanced(char,char)",
        "name": "chompBalanced",
        "arg_nums": 2,
        "params": [
            {
                "name": "open",
                "type": "char"
            },
            {
                "name": "close",
                "type": "char"
            }
        ],
        "return_type": "String",
        "signature": "public String chompBalanced(char open, char close)",
        "original_string": "    public String chompBalanced(char open, char close) {\n        int start = -1;\n        int end = -1;\n        int depth = 0;\n        char last = 0;\n        boolean inSingleQuote = false;\n        boolean inDoubleQuote = false;\n        boolean inRegexQE = false; // regex \\Q .. \\E escapes from Pattern.quote()\n\n        do {\n            if (isEmpty()) break;\n            char c = consume();\n            if (last != ESC) {\n                if (c == '\\'' && c != open && !inDoubleQuote)\n                    inSingleQuote = !inSingleQuote;\n                else if (c == '\"' && c != open && !inSingleQuote)\n                    inDoubleQuote = !inDoubleQuote;\n                if (inSingleQuote || inDoubleQuote || inRegexQE){\n                    last = c;\n                    continue;\n                }\n\n                if (c == open) {\n                    depth++;\n                    if (start == -1)\n                        start = pos;\n                }\n                else if (c == close)\n                    depth--;\n            } else if (c == 'Q') {\n                inRegexQE = true;\n            } else if (c == 'E') {\n                inRegexQE = false;\n            }\n\n            if (depth > 0 && last != 0)\n                end = pos; // don't include the outer match pair in the return\n            last = c;\n        } while (depth > 0);\n        final String out = (end >= 0) ? queue.substring(start, end) : \"\";\n        if (depth > 0) {// ran out of queue before seeing enough )\n            Validate.fail(\"Did not find balanced marker at '\" + out + \"'\");\n        }\n        return out;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/TokenQueue.java",
        "class_name": "TokenQueue",
        "class_uri": "src/main/java/org/jsoup/parser/TokenQueue.java.TokenQueue",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": "\nPulls a balanced string off the queue. E.g. if queue is \"(one (two) three) four\", (,) will return \"one (two) three\",\nand leave \" four\" on the queue. Unbalanced openers and closers can be quoted (with ' or \") or escaped (with \\). Those escapes will be left\nin the returned string, which is suitable for regexes (where we need to preserve the escape), but unsuitable for\ncontains text strings; use unescape for that.\n@param open opener\n@param close closer\n@return data matched from the queue\n"
    },
    {
        "uris": "src/main/java/org/jsoup/parser/TokenQueue.java.TokenQueue.[String]unescape(String)",
        "name": "unescape",
        "arg_nums": 1,
        "params": [
            {
                "name": "in",
                "type": "String"
            }
        ],
        "return_type": "String",
        "signature": "public static String unescape(String in)",
        "original_string": "    public static String unescape(String in) {\n        StringBuilder out = StringUtil.borrowBuilder();\n        char last = 0;\n        for (char c : in.toCharArray()) {\n            if (c == ESC) {\n                if (last == ESC) {\n                    out.append(c);\n                    c = 0;\n                }\n            }\n            else \n                out.append(c);\n            last = c;\n        }\n        return StringUtil.releaseBuilder(out);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/TokenQueue.java",
        "class_name": "TokenQueue",
        "class_uri": "src/main/java/org/jsoup/parser/TokenQueue.java.TokenQueue",
        "attributes": {
            "modifiers": "public static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public",
                "static"
            ],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": "\nUnescape a \\ escaped string.\n@param in backslash escaped string\n@return unescaped string\n"
    },
    {
        "uris": "src/main/java/org/jsoup/parser/TokenQueue.java.TokenQueue.[String]escapeCssIdentifier(String)",
        "name": "escapeCssIdentifier",
        "arg_nums": 1,
        "params": [
            {
                "name": "in",
                "type": "String"
            }
        ],
        "return_type": "String",
        "signature": "public static String escapeCssIdentifier(String in)",
        "original_string": "    public static String escapeCssIdentifier(String in) {\n        StringBuilder out = StringUtil.borrowBuilder();\n        TokenQueue q = new TokenQueue(in);\n        while (!q.isEmpty()) {\n            if (q.matchesCssIdentifier(CssIdentifierChars)) {\n                out.append(q.consume());\n            } else {\n                out.append(ESC).append(q.consume());\n            }\n        }\n        return StringUtil.releaseBuilder(out);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/TokenQueue.java",
        "class_name": "TokenQueue",
        "class_uri": "src/main/java/org/jsoup/parser/TokenQueue.java.TokenQueue",
        "attributes": {
            "modifiers": "public static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public",
                "static"
            ],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": "\nGiven a CSS identifier (such as a tag, ID, or class), escape any CSS special characters that would otherwise not be\nvalid in a selector.\n"
    },
    {
        "uris": "src/main/java/org/jsoup/parser/TokenQueue.java.TokenQueue.[boolean]consumeWhitespace()",
        "name": "consumeWhitespace",
        "arg_nums": 0,
        "params": [],
        "return_type": "boolean",
        "signature": "public boolean consumeWhitespace()",
        "original_string": "    public boolean consumeWhitespace() {\n        boolean seen = false;\n        while (matchesWhitespace()) {\n            pos++;\n            seen = true;\n        }\n        return seen;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/TokenQueue.java",
        "class_name": "TokenQueue",
        "class_uri": "src/main/java/org/jsoup/parser/TokenQueue.java.TokenQueue",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": "\nPulls the next run of whitespace characters of the queue.\n@return Whether consuming whitespace or not\n"
    },
    {
        "uris": "src/main/java/org/jsoup/parser/TokenQueue.java.TokenQueue.[String]consumeWord()",
        "name": "consumeWord",
        "arg_nums": 0,
        "params": [],
        "return_type": "String",
        "signature": "public String consumeWord()",
        "original_string": "    public String consumeWord() {\n        int start = pos;\n        while (matchesWord())\n            pos++;\n        return queue.substring(start, pos);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/TokenQueue.java",
        "class_name": "TokenQueue",
        "class_uri": "src/main/java/org/jsoup/parser/TokenQueue.java.TokenQueue",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": "\nRetrieves the next run of word type (letter or digit) off the queue.\n@return String of word characters from queue, or empty string if none.\n"
    },
    {
        "uris": "src/main/java/org/jsoup/parser/TokenQueue.java.TokenQueue.[String]consumeElementSelector()",
        "name": "consumeElementSelector",
        "arg_nums": 0,
        "params": [],
        "return_type": "String",
        "signature": "public String consumeElementSelector()",
        "original_string": "    public String consumeElementSelector() {\n        return consumeEscapedCssIdentifier(ElementSelectorChars);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/TokenQueue.java",
        "class_name": "TokenQueue",
        "class_uri": "src/main/java/org/jsoup/parser/TokenQueue.java.TokenQueue",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": "\nConsume a CSS element selector (tag name, but | instead of : for namespaces (or *| for wildcard namespace), to not conflict with :pseudo selects).\n\n@return tag name\n"
    },
    {
        "uris": "src/main/java/org/jsoup/parser/TokenQueue.java.TokenQueue.[String]consumeCssIdentifier()",
        "name": "consumeCssIdentifier",
        "arg_nums": 0,
        "params": [],
        "return_type": "String",
        "signature": "public String consumeCssIdentifier()",
        "original_string": "    public String consumeCssIdentifier() {\n        return consumeEscapedCssIdentifier(CssIdentifierChars);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/TokenQueue.java",
        "class_name": "TokenQueue",
        "class_uri": "src/main/java/org/jsoup/parser/TokenQueue.java.TokenQueue",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": "\nConsume a CSS identifier (ID or class) off the queue (letter, digit, -, _)\nhttp://www.w3.org/TR/CSS2/syndata.html#value-def-identifier\n@return identifier\n"
    },
    {
        "uris": "src/main/java/org/jsoup/parser/TokenQueue.java.TokenQueue.[String]consumeEscapedCssIdentifier()",
        "name": "consumeEscapedCssIdentifier",
        "arg_nums": 0,
        "params": [],
        "return_type": "String",
        "signature": "private String consumeEscapedCssIdentifier(String... matches)",
        "original_string": "    private String consumeEscapedCssIdentifier(String... matches) {\n        int start = pos;\n        boolean escaped = false;\n        while (!isEmpty()) {\n            if (queue.charAt(pos) == ESC && remainingLength() >1 ) {\n                escaped = true;\n                pos+=2; // skip the escape and the escaped\n            } else if (matchesCssIdentifier(matches)) {\n                pos++;\n            } else {\n                break;\n            }\n        }\n\n        String consumed = queue.substring(start, pos);\n        return escaped ? unescape(consumed) : consumed;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/TokenQueue.java",
        "class_name": "TokenQueue",
        "class_uri": "src/main/java/org/jsoup/parser/TokenQueue.java.TokenQueue",
        "attributes": {
            "modifiers": "private",
            "marker_annotations": [],
            "non_marker_annotations": [
                "private"
            ],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/TokenQueue.java.TokenQueue.[boolean]matchesCssIdentifier()",
        "name": "matchesCssIdentifier",
        "arg_nums": 0,
        "params": [],
        "return_type": "boolean",
        "signature": "private boolean matchesCssIdentifier(String... matches)",
        "original_string": "    private boolean matchesCssIdentifier(String... matches) {\n        return matchesWord() || matchesAny(matches);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/TokenQueue.java",
        "class_name": "TokenQueue",
        "class_uri": "src/main/java/org/jsoup/parser/TokenQueue.java.TokenQueue",
        "attributes": {
            "modifiers": "private",
            "marker_annotations": [],
            "non_marker_annotations": [
                "private"
            ],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/TokenQueue.java.TokenQueue.[String]remainder()",
        "name": "remainder",
        "arg_nums": 0,
        "params": [],
        "return_type": "String",
        "signature": "public String remainder()",
        "original_string": "    public String remainder() {\n        final String remainder = queue.substring(pos);\n        pos = queue.length();\n        return remainder;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/TokenQueue.java",
        "class_name": "TokenQueue",
        "class_uri": "src/main/java/org/jsoup/parser/TokenQueue.java.TokenQueue",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": "\nConsume and return whatever is left on the queue.\n@return remained of queue.\n"
    },
    {
        "uris": "src/main/java/org/jsoup/parser/TokenQueue.java.TokenQueue.[String]toString()",
        "name": "toString",
        "arg_nums": 0,
        "params": [],
        "return_type": "String",
        "signature": "@Override\n    public String toString()",
        "original_string": "    @Override\n    public String toString() {\n        return queue.substring(pos);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/TokenQueue.java",
        "class_name": "TokenQueue",
        "class_uri": "src/main/java/org/jsoup/parser/TokenQueue.java.TokenQueue",
        "attributes": {
            "modifiers": "@Override\n    public",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/XmlTreeBuilder.java.XmlTreeBuilder.[ParseSettings]defaultSettings()",
        "name": "defaultSettings",
        "arg_nums": 0,
        "params": [],
        "return_type": "ParseSettings",
        "signature": "@Override ParseSettings defaultSettings()",
        "original_string": "    @Override ParseSettings defaultSettings() {\n        return ParseSettings.preserveCase;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/XmlTreeBuilder.java",
        "class_name": "XmlTreeBuilder",
        "class_uri": "src/main/java/org/jsoup/parser/XmlTreeBuilder.java.XmlTreeBuilder",
        "attributes": {
            "modifiers": "@Override",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "ParseSettings",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/XmlTreeBuilder.java.XmlTreeBuilder.[void]initialiseParse(Reader,String,Parser)",
        "name": "initialiseParse",
        "arg_nums": 3,
        "params": [
            {
                "name": "input",
                "type": "Reader"
            },
            {
                "name": "baseUri",
                "type": "String"
            },
            {
                "name": "parser",
                "type": "Parser"
            }
        ],
        "return_type": "void",
        "signature": "@Override\n    protected void initialiseParse(Reader input, String baseUri, Parser parser)",
        "original_string": "    @Override\n    protected void initialiseParse(Reader input, String baseUri, Parser parser) {\n        super.initialiseParse(input, baseUri, parser);\n        doc.outputSettings()\n            .syntax(Document.OutputSettings.Syntax.xml)\n            .escapeMode(Entities.EscapeMode.xhtml)\n            .prettyPrint(false); // as XML, we don't understand what whitespace is significant or not\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/XmlTreeBuilder.java",
        "class_name": "XmlTreeBuilder",
        "class_uri": "src/main/java/org/jsoup/parser/XmlTreeBuilder.java.XmlTreeBuilder",
        "attributes": {
            "modifiers": "@Override\n    protected",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "protected"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/XmlTreeBuilder.java.XmlTreeBuilder.[Document]parse(Reader,String)",
        "name": "parse",
        "arg_nums": 2,
        "params": [
            {
                "name": "input",
                "type": "Reader"
            },
            {
                "name": "baseUri",
                "type": "String"
            }
        ],
        "return_type": "Document",
        "signature": "Document parse(Reader input, String baseUri)",
        "original_string": "    Document parse(Reader input, String baseUri) {\n        return parse(input, baseUri, new Parser(this));\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/XmlTreeBuilder.java",
        "class_name": "XmlTreeBuilder",
        "class_uri": "src/main/java/org/jsoup/parser/XmlTreeBuilder.java.XmlTreeBuilder",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "Document",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/XmlTreeBuilder.java.XmlTreeBuilder.[Document]parse(String,String)",
        "name": "parse",
        "arg_nums": 2,
        "params": [
            {
                "name": "input",
                "type": "String"
            },
            {
                "name": "baseUri",
                "type": "String"
            }
        ],
        "return_type": "Document",
        "signature": "Document parse(String input, String baseUri)",
        "original_string": "    Document parse(String input, String baseUri) {\n        return parse(new StringReader(input), baseUri, new Parser(this));\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/XmlTreeBuilder.java",
        "class_name": "XmlTreeBuilder",
        "class_uri": "src/main/java/org/jsoup/parser/XmlTreeBuilder.java.XmlTreeBuilder",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "Document",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/XmlTreeBuilder.java.XmlTreeBuilder.[List<Node>]completeParseFragment()",
        "name": "completeParseFragment",
        "arg_nums": 0,
        "params": [],
        "return_type": "List<Node>",
        "signature": "@Override List<Node> completeParseFragment()",
        "original_string": "    @Override List<Node> completeParseFragment() {\n        return doc.childNodes();\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/XmlTreeBuilder.java",
        "class_name": "XmlTreeBuilder",
        "class_uri": "src/main/java/org/jsoup/parser/XmlTreeBuilder.java.XmlTreeBuilder",
        "attributes": {
            "modifiers": "@Override",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "List<Node>",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/XmlTreeBuilder.java.XmlTreeBuilder.[XmlTreeBuilder]newInstance()",
        "name": "newInstance",
        "arg_nums": 0,
        "params": [],
        "return_type": "XmlTreeBuilder",
        "signature": "@Override\n    XmlTreeBuilder newInstance()",
        "original_string": "    @Override\n    XmlTreeBuilder newInstance() {\n        return new XmlTreeBuilder();\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/XmlTreeBuilder.java",
        "class_name": "XmlTreeBuilder",
        "class_uri": "src/main/java/org/jsoup/parser/XmlTreeBuilder.java.XmlTreeBuilder",
        "attributes": {
            "modifiers": "@Override",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "XmlTreeBuilder",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/XmlTreeBuilder.java.XmlTreeBuilder.[String]defaultNamespace()",
        "name": "defaultNamespace",
        "arg_nums": 0,
        "params": [],
        "return_type": "String",
        "signature": "@Override public String defaultNamespace()",
        "original_string": "    @Override public String defaultNamespace() {\n        return NamespaceXml;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/XmlTreeBuilder.java",
        "class_name": "XmlTreeBuilder",
        "class_uri": "src/main/java/org/jsoup/parser/XmlTreeBuilder.java.XmlTreeBuilder",
        "attributes": {
            "modifiers": "@Override public",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/XmlTreeBuilder.java.XmlTreeBuilder.[boolean]process(Token)",
        "name": "process",
        "arg_nums": 1,
        "params": [
            {
                "name": "token",
                "type": "Token"
            }
        ],
        "return_type": "boolean",
        "signature": "@Override\n    protected boolean process(Token token)",
        "original_string": "    @Override\n    protected boolean process(Token token) {\n        currentToken = token;\n\n        // start tag, end tag, doctype, comment, character, eof\n        switch (token.type) {\n            case StartTag:\n                insertElementFor(token.asStartTag());\n                break;\n            case EndTag:\n                popStackToClose(token.asEndTag());\n                break;\n            case Comment:\n                insertCommentFor(token.asComment());\n                break;\n            case Character:\n                insertCharacterFor(token.asCharacter());\n                break;\n            case Doctype:\n                insertDoctypeFor(token.asDoctype());\n                break;\n            case EOF: // could put some normalisation here if desired\n                break;\n            default:\n                Validate.fail(\"Unexpected token type: \" + token.type);\n        }\n        return true;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/XmlTreeBuilder.java",
        "class_name": "XmlTreeBuilder",
        "class_uri": "src/main/java/org/jsoup/parser/XmlTreeBuilder.java.XmlTreeBuilder",
        "attributes": {
            "modifiers": "@Override\n    protected",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "protected"
            ],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/XmlTreeBuilder.java.XmlTreeBuilder.[void]insertElementFor(Token.StartTag)",
        "name": "insertElementFor",
        "arg_nums": 1,
        "params": [
            {
                "name": "startTag",
                "type": "Token.StartTag"
            }
        ],
        "return_type": "void",
        "signature": "void insertElementFor(Token.StartTag startTag)",
        "original_string": "    void insertElementFor(Token.StartTag startTag) {\n        Tag tag = tagFor(startTag.name(), settings);\n        if (startTag.attributes != null)\n            startTag.attributes.deduplicate(settings);\n\n        Element el = new Element(tag, null, settings.normalizeAttributes(startTag.attributes));\n        currentElement().appendChild(el);\n        push(el);\n\n        if (startTag.isSelfClosing()) {\n            tag.setSelfClosing();\n            pop(); // push & pop ensures onNodeInserted & onNodeClosed\n        }\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/XmlTreeBuilder.java",
        "class_name": "XmlTreeBuilder",
        "class_uri": "src/main/java/org/jsoup/parser/XmlTreeBuilder.java.XmlTreeBuilder",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/XmlTreeBuilder.java.XmlTreeBuilder.[void]insertLeafNode(LeafNode)",
        "name": "insertLeafNode",
        "arg_nums": 1,
        "params": [
            {
                "name": "node",
                "type": "LeafNode"
            }
        ],
        "return_type": "void",
        "signature": "void insertLeafNode(LeafNode node)",
        "original_string": "    void insertLeafNode(LeafNode node) {\n        currentElement().appendChild(node);\n        onNodeInserted(node);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/XmlTreeBuilder.java",
        "class_name": "XmlTreeBuilder",
        "class_uri": "src/main/java/org/jsoup/parser/XmlTreeBuilder.java.XmlTreeBuilder",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/XmlTreeBuilder.java.XmlTreeBuilder.[void]insertCommentFor(Token.Comment)",
        "name": "insertCommentFor",
        "arg_nums": 1,
        "params": [
            {
                "name": "commentToken",
                "type": "Token.Comment"
            }
        ],
        "return_type": "void",
        "signature": "void insertCommentFor(Token.Comment commentToken)",
        "original_string": "    void insertCommentFor(Token.Comment commentToken) {\n        Comment comment = new Comment(commentToken.getData());\n        LeafNode insert = comment;\n        if (commentToken.bogus && comment.isXmlDeclaration()) {\n            // xml declarations are emitted as bogus comments (which is right for html, but not xml)\n            // so we do a bit of a hack and parse the data as an element to pull the attributes out\n            // todo - refactor this to parse more appropriately\n            XmlDeclaration decl = comment.asXmlDeclaration(); // else, we couldn't parse it as a decl, so leave as a comment\n            if (decl != null)\n                insert = decl;\n        }\n        insertLeafNode(insert);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/XmlTreeBuilder.java",
        "class_name": "XmlTreeBuilder",
        "class_uri": "src/main/java/org/jsoup/parser/XmlTreeBuilder.java.XmlTreeBuilder",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/XmlTreeBuilder.java.XmlTreeBuilder.[void]insertCharacterFor(Token.Character)",
        "name": "insertCharacterFor",
        "arg_nums": 1,
        "params": [
            {
                "name": "token",
                "type": "Token.Character"
            }
        ],
        "return_type": "void",
        "signature": "void insertCharacterFor(Token.Character token)",
        "original_string": "    void insertCharacterFor(Token.Character token) {\n        final String data = token.getData();\n        insertLeafNode(token.isCData() ? new CDataNode(data) : new TextNode(data));\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/XmlTreeBuilder.java",
        "class_name": "XmlTreeBuilder",
        "class_uri": "src/main/java/org/jsoup/parser/XmlTreeBuilder.java.XmlTreeBuilder",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/XmlTreeBuilder.java.XmlTreeBuilder.[void]insertDoctypeFor(Token.Doctype)",
        "name": "insertDoctypeFor",
        "arg_nums": 1,
        "params": [
            {
                "name": "token",
                "type": "Token.Doctype"
            }
        ],
        "return_type": "void",
        "signature": "void insertDoctypeFor(Token.Doctype token)",
        "original_string": "    void insertDoctypeFor(Token.Doctype token) {\n        DocumentType doctypeNode = new DocumentType(settings.normalizeTag(token.getName()), token.getPublicIdentifier(), token.getSystemIdentifier());\n        doctypeNode.setPubSysKey(token.getPubSysKey());\n        insertLeafNode(doctypeNode);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/XmlTreeBuilder.java",
        "class_name": "XmlTreeBuilder",
        "class_uri": "src/main/java/org/jsoup/parser/XmlTreeBuilder.java.XmlTreeBuilder",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/XmlTreeBuilder.java.XmlTreeBuilder.[void]popStackToClose(Token.EndTag)",
        "name": "popStackToClose",
        "arg_nums": 1,
        "params": [
            {
                "name": "endTag",
                "type": "Token.EndTag"
            }
        ],
        "return_type": "void",
        "signature": "protected void popStackToClose(Token.EndTag endTag)",
        "original_string": "    protected void popStackToClose(Token.EndTag endTag) {\n        // like in HtmlTreeBuilder - don't scan up forever for very (artificially) deeply nested stacks\n        String elName = settings.normalizeTag(endTag.tagName);\n        Element firstFound = null;\n\n        final int bottom = stack.size() - 1;\n        final int upper = bottom >= maxQueueDepth ? bottom - maxQueueDepth : 0;\n\n        for (int pos = stack.size() -1; pos >= upper; pos--) {\n            Element next = stack.get(pos);\n            if (next.nodeName().equals(elName)) {\n                firstFound = next;\n                break;\n            }\n        }\n        if (firstFound == null)\n            return; // not found, skip\n\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = pop();\n            if (next == firstFound) {\n                break;\n            }\n        }\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/XmlTreeBuilder.java",
        "class_name": "XmlTreeBuilder",
        "class_uri": "src/main/java/org/jsoup/parser/XmlTreeBuilder.java.XmlTreeBuilder",
        "attributes": {
            "modifiers": "protected",
            "marker_annotations": [],
            "non_marker_annotations": [
                "protected"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": "\nIf the stack contains an element with this tag's name, pop up the stack to remove the first occurrence. If not\nfound, skips.\n\n@param endTag tag to close\n"
    },
    {
        "uris": "src/main/java/org/jsoup/parser/Tag.java.Tag.[]Tag(String,String)",
        "name": "Tag",
        "arg_nums": 2,
        "params": [
            {
                "name": "tagName",
                "type": "String"
            },
            {
                "name": "namespace",
                "type": "String"
            }
        ],
        "return_type": "",
        "signature": "private Tag(String tagName, String namespace)",
        "original_string": "    private Tag(String tagName, String namespace) {\n        this.tagName = tagName;\n        normalName = Normalizer.lowerCase(tagName);\n        this.namespace = namespace;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/Tag.java",
        "class_name": "Tag",
        "class_uri": "src/main/java/org/jsoup/parser/Tag.java.Tag",
        "attributes": {
            "modifiers": "private",
            "marker_annotations": [],
            "non_marker_annotations": [
                "private"
            ],
            "comments": [],
            "return_type": "",
            "classes": []
        },
        "docstring": " a control that can be submitted in a form: input etc"
    },
    {
        "uris": "src/main/java/org/jsoup/parser/Tag.java.Tag.[String]getName()",
        "name": "getName",
        "arg_nums": 0,
        "params": [],
        "return_type": "String",
        "signature": "public String getName()",
        "original_string": "    public String getName() {\n        return tagName;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/Tag.java",
        "class_name": "Tag",
        "class_uri": "src/main/java/org/jsoup/parser/Tag.java.Tag",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": "\nGet this tag's name.\n\n@return the tag's name\n"
    },
    {
        "uris": "src/main/java/org/jsoup/parser/Tag.java.Tag.[String]normalName()",
        "name": "normalName",
        "arg_nums": 0,
        "params": [],
        "return_type": "String",
        "signature": "public String normalName()",
        "original_string": "    public String normalName() {\n        return normalName;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/Tag.java",
        "class_name": "Tag",
        "class_uri": "src/main/java/org/jsoup/parser/Tag.java.Tag",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": "\nGet this tag's normalized (lowercased) name.\n@return the tag's normal name.\n"
    },
    {
        "uris": "src/main/java/org/jsoup/parser/Tag.java.Tag.[String]namespace()",
        "name": "namespace",
        "arg_nums": 0,
        "params": [],
        "return_type": "String",
        "signature": "public String namespace()",
        "original_string": "    public String namespace() {\n        return namespace;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/Tag.java",
        "class_name": "Tag",
        "class_uri": "src/main/java/org/jsoup/parser/Tag.java.Tag",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/Tag.java.Tag.[Tag]valueOf(String,String,ParseSettings)",
        "name": "valueOf",
        "arg_nums": 3,
        "params": [
            {
                "name": "tagName",
                "type": "String"
            },
            {
                "name": "namespace",
                "type": "String"
            },
            {
                "name": "settings",
                "type": "ParseSettings"
            }
        ],
        "return_type": "Tag",
        "signature": "public static Tag valueOf(String tagName, String namespace, ParseSettings settings)",
        "original_string": "    public static Tag valueOf(String tagName, String namespace, ParseSettings settings) {\n        Validate.notEmpty(tagName);\n        Validate.notNull(namespace);\n        Tag tag = Tags.get(tagName);\n        if (tag != null && tag.namespace.equals(namespace))\n            return tag;\n\n        tagName = settings.normalizeTag(tagName); // the name we'll use\n        Validate.notEmpty(tagName);\n        String normalName = Normalizer.lowerCase(tagName); // the lower-case name to get tag settings off\n        tag = Tags.get(normalName);\n        if (tag != null && tag.namespace.equals(namespace)) {\n            if (settings.preserveTagCase() && !tagName.equals(normalName)) {\n                tag = tag.clone(); // get a new version vs the static one, so name update doesn't reset all\n                tag.tagName = tagName;\n            }\n            return tag;\n        }\n\n        // not defined: create default; go anywhere, do anything! (incl be inside a <p>)\n        tag = new Tag(tagName, namespace);\n        tag.isBlock = false;\n\n        return tag;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/Tag.java",
        "class_name": "Tag",
        "class_uri": "src/main/java/org/jsoup/parser/Tag.java.Tag",
        "attributes": {
            "modifiers": "public static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public",
                "static"
            ],
            "comments": [],
            "return_type": "Tag",
            "classes": []
        },
        "docstring": "\nGet a Tag by name. If not previously defined (unknown), returns a new generic tag, that can do anything.\n<p>\nPre-defined tags (p, div etc) will be ==, but unknown tags are not registered and will only .equals().\n</p>\n\n@param tagName Name of tag, e.g. \"p\". Case-insensitive.\n@param namespace the namespace for the tag.\n@param settings used to control tag name sensitivity\n@return The tag, either defined or new generic.\n"
    },
    {
        "uris": "src/main/java/org/jsoup/parser/Tag.java.Tag.[Tag]valueOf(String)",
        "name": "valueOf",
        "arg_nums": 1,
        "params": [
            {
                "name": "tagName",
                "type": "String"
            }
        ],
        "return_type": "Tag",
        "signature": "public static Tag valueOf(String tagName)",
        "original_string": "    public static Tag valueOf(String tagName) {\n        return valueOf(tagName, Parser.NamespaceHtml, ParseSettings.preserveCase);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/Tag.java",
        "class_name": "Tag",
        "class_uri": "src/main/java/org/jsoup/parser/Tag.java.Tag",
        "attributes": {
            "modifiers": "public static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public",
                "static"
            ],
            "comments": [],
            "return_type": "Tag",
            "classes": []
        },
        "docstring": "\nGet a Tag by name. If not previously defined (unknown), returns a new generic tag, that can do anything.\n<p>\nPre-defined tags (P, DIV etc) will be ==, but unknown tags are not registered and will only .equals().\n</p>\n\n@param tagName Name of tag, e.g. \"p\". <b>Case sensitive</b>.\n@return The tag, either defined or new generic.\n@see #valueOf(String tagName, String namespace, ParseSettings settings)\n"
    },
    {
        "uris": "src/main/java/org/jsoup/parser/Tag.java.Tag.[Tag]valueOf(String,ParseSettings)",
        "name": "valueOf",
        "arg_nums": 2,
        "params": [
            {
                "name": "tagName",
                "type": "String"
            },
            {
                "name": "settings",
                "type": "ParseSettings"
            }
        ],
        "return_type": "Tag",
        "signature": "public static Tag valueOf(String tagName, ParseSettings settings)",
        "original_string": "    public static Tag valueOf(String tagName, ParseSettings settings) {\n        return valueOf(tagName, Parser.NamespaceHtml, settings);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/Tag.java",
        "class_name": "Tag",
        "class_uri": "src/main/java/org/jsoup/parser/Tag.java.Tag",
        "attributes": {
            "modifiers": "public static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public",
                "static"
            ],
            "comments": [],
            "return_type": "Tag",
            "classes": []
        },
        "docstring": "\nGet a Tag by name. If not previously defined (unknown), returns a new generic tag, that can do anything.\n<p>\nPre-defined tags (P, DIV etc) will be ==, but unknown tags are not registered and will only .equals().\n</p>\n\n@param tagName Name of tag, e.g. \"p\". <b>Case sensitive</b>.\n@param settings used to control tag name sensitivity\n@return The tag, either defined or new generic.\n@see #valueOf(String tagName, String namespace, ParseSettings settings)\n"
    },
    {
        "uris": "src/main/java/org/jsoup/parser/Tag.java.Tag.[boolean]isBlock()",
        "name": "isBlock",
        "arg_nums": 0,
        "params": [],
        "return_type": "boolean",
        "signature": "public boolean isBlock()",
        "original_string": "    public boolean isBlock() {\n        return isBlock;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/Tag.java",
        "class_name": "Tag",
        "class_uri": "src/main/java/org/jsoup/parser/Tag.java.Tag",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": "\nGets if this is a block tag.\n\n@return if block tag\n"
    },
    {
        "uris": "src/main/java/org/jsoup/parser/Tag.java.Tag.[boolean]formatAsBlock()",
        "name": "formatAsBlock",
        "arg_nums": 0,
        "params": [],
        "return_type": "boolean",
        "signature": "public boolean formatAsBlock()",
        "original_string": "    public boolean formatAsBlock() {\n        return formatAsBlock;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/Tag.java",
        "class_name": "Tag",
        "class_uri": "src/main/java/org/jsoup/parser/Tag.java.Tag",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": "\nGets if this tag should be formatted as a block (or as inline)\n\n@return if should be formatted as block or inline\n"
    },
    {
        "uris": "src/main/java/org/jsoup/parser/Tag.java.Tag.[boolean]isInline()",
        "name": "isInline",
        "arg_nums": 0,
        "params": [],
        "return_type": "boolean",
        "signature": "public boolean isInline()",
        "original_string": "    public boolean isInline() {\n        return !isBlock;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/Tag.java",
        "class_name": "Tag",
        "class_uri": "src/main/java/org/jsoup/parser/Tag.java.Tag",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": "\nGets if this tag is an inline tag.\n\n@return if this tag is an inline tag.\n"
    },
    {
        "uris": "src/main/java/org/jsoup/parser/Tag.java.Tag.[boolean]isEmpty()",
        "name": "isEmpty",
        "arg_nums": 0,
        "params": [],
        "return_type": "boolean",
        "signature": "public boolean isEmpty()",
        "original_string": "    public boolean isEmpty() {\n        return empty;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/Tag.java",
        "class_name": "Tag",
        "class_uri": "src/main/java/org/jsoup/parser/Tag.java.Tag",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": "\nGet if this is an empty tag\n\n@return if this is an empty tag\n"
    },
    {
        "uris": "src/main/java/org/jsoup/parser/Tag.java.Tag.[boolean]isSelfClosing()",
        "name": "isSelfClosing",
        "arg_nums": 0,
        "params": [],
        "return_type": "boolean",
        "signature": "public boolean isSelfClosing()",
        "original_string": "    public boolean isSelfClosing() {\n        return empty || selfClosing;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/Tag.java",
        "class_name": "Tag",
        "class_uri": "src/main/java/org/jsoup/parser/Tag.java.Tag",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": "\nGet if this tag is self-closing.\n\n@return if this tag should be output as self-closing.\n"
    },
    {
        "uris": "src/main/java/org/jsoup/parser/Tag.java.Tag.[boolean]isKnownTag()",
        "name": "isKnownTag",
        "arg_nums": 0,
        "params": [],
        "return_type": "boolean",
        "signature": "public boolean isKnownTag()",
        "original_string": "    public boolean isKnownTag() {\n        return Tags.containsKey(tagName);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/Tag.java",
        "class_name": "Tag",
        "class_uri": "src/main/java/org/jsoup/parser/Tag.java.Tag",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": "\nGet if this is a pre-defined tag, or was auto created on parsing.\n\n@return if a known tag\n"
    },
    {
        "uris": "src/main/java/org/jsoup/parser/Tag.java.Tag.[boolean]isKnownTag(String)",
        "name": "isKnownTag",
        "arg_nums": 1,
        "params": [
            {
                "name": "tagName",
                "type": "String"
            }
        ],
        "return_type": "boolean",
        "signature": "public static boolean isKnownTag(String tagName)",
        "original_string": "    public static boolean isKnownTag(String tagName) {\n        return Tags.containsKey(tagName);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/Tag.java",
        "class_name": "Tag",
        "class_uri": "src/main/java/org/jsoup/parser/Tag.java.Tag",
        "attributes": {
            "modifiers": "public static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public",
                "static"
            ],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": "\nCheck if this tagname is a known tag.\n\n@param tagName name of tag\n@return if known HTML tag\n"
    },
    {
        "uris": "src/main/java/org/jsoup/parser/Tag.java.Tag.[boolean]preserveWhitespace()",
        "name": "preserveWhitespace",
        "arg_nums": 0,
        "params": [],
        "return_type": "boolean",
        "signature": "public boolean preserveWhitespace()",
        "original_string": "    public boolean preserveWhitespace() {\n        return preserveWhitespace;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/Tag.java",
        "class_name": "Tag",
        "class_uri": "src/main/java/org/jsoup/parser/Tag.java.Tag",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": "\nGet if this tag should preserve whitespace within child text nodes.\n\n@return if preserve whitespace\n"
    },
    {
        "uris": "src/main/java/org/jsoup/parser/Tag.java.Tag.[boolean]isFormListed()",
        "name": "isFormListed",
        "arg_nums": 0,
        "params": [],
        "return_type": "boolean",
        "signature": "public boolean isFormListed()",
        "original_string": "    public boolean isFormListed() {\n        return formList;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/Tag.java",
        "class_name": "Tag",
        "class_uri": "src/main/java/org/jsoup/parser/Tag.java.Tag",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": "\nGet if this tag represents a control associated with a form. E.g. input, textarea, output\n@return if associated with a form\n"
    },
    {
        "uris": "src/main/java/org/jsoup/parser/Tag.java.Tag.[boolean]isFormSubmittable()",
        "name": "isFormSubmittable",
        "arg_nums": 0,
        "params": [],
        "return_type": "boolean",
        "signature": "public boolean isFormSubmittable()",
        "original_string": "    public boolean isFormSubmittable() {\n        return formSubmit;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/Tag.java",
        "class_name": "Tag",
        "class_uri": "src/main/java/org/jsoup/parser/Tag.java.Tag",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": "\nGet if this tag represents an element that should be submitted with a form. E.g. input, option\n@return if submittable with a form\n"
    },
    {
        "uris": "src/main/java/org/jsoup/parser/Tag.java.Tag.[Tag]setSelfClosing()",
        "name": "setSelfClosing",
        "arg_nums": 0,
        "params": [],
        "return_type": "Tag",
        "signature": "Tag setSelfClosing()",
        "original_string": "    Tag setSelfClosing() {\n        selfClosing = true;\n        return this;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/Tag.java",
        "class_name": "Tag",
        "class_uri": "src/main/java/org/jsoup/parser/Tag.java.Tag",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "Tag",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/Tag.java.Tag.[boolean]equals(Object)",
        "name": "equals",
        "arg_nums": 1,
        "params": [
            {
                "name": "o",
                "type": "Object"
            }
        ],
        "return_type": "boolean",
        "signature": "@Override\n    public boolean equals(Object o)",
        "original_string": "    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (!(o instanceof Tag)) return false;\n\n        Tag tag = (Tag) o;\n\n        if (!tagName.equals(tag.tagName)) return false;\n        if (empty != tag.empty) return false;\n        if (formatAsBlock != tag.formatAsBlock) return false;\n        if (isBlock != tag.isBlock) return false;\n        if (preserveWhitespace != tag.preserveWhitespace) return false;\n        if (selfClosing != tag.selfClosing) return false;\n        if (formList != tag.formList) return false;\n        return formSubmit == tag.formSubmit;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/Tag.java",
        "class_name": "Tag",
        "class_uri": "src/main/java/org/jsoup/parser/Tag.java.Tag",
        "attributes": {
            "modifiers": "@Override\n    public",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/Tag.java.Tag.[int]hashCode()",
        "name": "hashCode",
        "arg_nums": 0,
        "params": [],
        "return_type": "int",
        "signature": "@Override\n    public int hashCode()",
        "original_string": "    @Override\n    public int hashCode() {\n        return Objects.hash(tagName, isBlock, formatAsBlock, empty, selfClosing, preserveWhitespace,\n            formList, formSubmit);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/Tag.java",
        "class_name": "Tag",
        "class_uri": "src/main/java/org/jsoup/parser/Tag.java.Tag",
        "attributes": {
            "modifiers": "@Override\n    public",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "int",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/Tag.java.Tag.[String]toString()",
        "name": "toString",
        "arg_nums": 0,
        "params": [],
        "return_type": "String",
        "signature": "@Override\n    public String toString()",
        "original_string": "    @Override\n    public String toString() {\n        return tagName;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/Tag.java",
        "class_name": "Tag",
        "class_uri": "src/main/java/org/jsoup/parser/Tag.java.Tag",
        "attributes": {
            "modifiers": "@Override\n    public",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/Tag.java.Tag.[Tag]clone()",
        "name": "clone",
        "arg_nums": 0,
        "params": [],
        "return_type": "Tag",
        "signature": "@Override\n    protected Tag clone()",
        "original_string": "    @Override\n    protected Tag clone() {\n        try {\n            return (Tag) super.clone();\n        } catch (CloneNotSupportedException e) {\n            throw new RuntimeException(e);\n        }\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/Tag.java",
        "class_name": "Tag",
        "class_uri": "src/main/java/org/jsoup/parser/Tag.java.Tag",
        "attributes": {
            "modifiers": "@Override\n    protected",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "protected"
            ],
            "comments": [],
            "return_type": "Tag",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/Tag.java.Tag.[void]setupTags(String[],Consumer<Tag>)",
        "name": "setupTags",
        "arg_nums": 2,
        "params": [
            {
                "name": "tagNames",
                "type": "String[]"
            },
            {
                "name": "tagModifier",
                "type": "Consumer<Tag>"
            }
        ],
        "return_type": "void",
        "signature": "private static void setupTags(String[] tagNames, Consumer<Tag> tagModifier)",
        "original_string": "    private static void setupTags(String[] tagNames, Consumer<Tag> tagModifier) {\n        for (String tagName : tagNames) {\n            Tag tag = Tags.get(tagName);\n            if (tag == null) {\n                tag = new Tag(tagName, Parser.NamespaceHtml);\n                Tags.put(tag.tagName, tag);\n            }\n            tagModifier.accept(tag);\n        }\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/Tag.java",
        "class_name": "Tag",
        "class_uri": "src/main/java/org/jsoup/parser/Tag.java.Tag",
        "attributes": {
            "modifiers": "private static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "private",
                "static"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/StreamParser.java.StreamParser.[]StreamParser(Parser)",
        "name": "StreamParser",
        "arg_nums": 1,
        "params": [
            {
                "name": "parser",
                "type": "Parser"
            }
        ],
        "return_type": "",
        "signature": "public StreamParser(Parser parser)",
        "original_string": "    public StreamParser(Parser parser) {\n        this.parser = parser;\n        treeBuilder = parser.getTreeBuilder();\n        treeBuilder.nodeListener(it);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/StreamParser.java",
        "class_name": "StreamParser",
        "class_uri": "src/main/java/org/jsoup/parser/StreamParser.java.StreamParser",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "",
            "classes": []
        },
        "docstring": "\nConstruct a new StreamParser, using the supplied base Parser.\n@param parser the configured base parser\n"
    },
    {
        "uris": "src/main/java/org/jsoup/parser/StreamParser.java.StreamParser.[StreamParser]parse(Reader,String)",
        "name": "parse",
        "arg_nums": 2,
        "params": [
            {
                "name": "input",
                "type": "Reader"
            },
            {
                "name": "baseUri",
                "type": "String"
            }
        ],
        "return_type": "StreamParser",
        "signature": "public StreamParser parse(Reader input, String baseUri)",
        "original_string": "    public StreamParser parse(Reader input, String baseUri) {\n        close(); // probably a no-op, but ensures any previous reader is closed\n        it.reset();\n        treeBuilder.initialiseParse(input, baseUri, parser); // reader is not read, so no chance of IO error\n        document = treeBuilder.doc;\n        return this;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/StreamParser.java",
        "class_name": "StreamParser",
        "class_uri": "src/main/java/org/jsoup/parser/StreamParser.java.StreamParser",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "StreamParser",
            "classes": []
        },
        "docstring": "\nProvide the input for a Document parse. The input is not read until a consuming operation is called.\n@param input the input to be read.\n@param baseUri the URL of this input, for absolute link resolution\n@return this parser, for chaining\n"
    },
    {
        "uris": "src/main/java/org/jsoup/parser/StreamParser.java.StreamParser.[StreamParser]parse(String,String)",
        "name": "parse",
        "arg_nums": 2,
        "params": [
            {
                "name": "input",
                "type": "String"
            },
            {
                "name": "baseUri",
                "type": "String"
            }
        ],
        "return_type": "StreamParser",
        "signature": "public StreamParser parse(String input, String baseUri)",
        "original_string": "    public StreamParser parse(String input, String baseUri) {\n        return parse(new StringReader(input), baseUri);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/StreamParser.java",
        "class_name": "StreamParser",
        "class_uri": "src/main/java/org/jsoup/parser/StreamParser.java.StreamParser",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "StreamParser",
            "classes": []
        },
        "docstring": "\nProvide the input for a Document parse. The input is not read until a consuming operation is called.\n@param input the input to be read\n@param baseUri the URL of this input, for absolute link resolution\n@return this parser\n"
    },
    {
        "uris": "src/main/java/org/jsoup/parser/StreamParser.java.StreamParser.[StreamParser]parseFragment(Reader,Element,String)",
        "name": "parseFragment",
        "arg_nums": 3,
        "params": [
            {
                "name": "input",
                "type": "Reader"
            },
            {
                "name": "context",
                "type": "Element"
            },
            {
                "name": "baseUri",
                "type": "String"
            }
        ],
        "return_type": "StreamParser",
        "signature": "public StreamParser parseFragment(Reader input, @Nullable Element context, String baseUri)",
        "original_string": "    public StreamParser parseFragment(Reader input, @Nullable Element context, String baseUri) {\n        parse(input, baseUri);\n        treeBuilder.initialiseParseFragment(context);\n        return this;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/StreamParser.java",
        "class_name": "StreamParser",
        "class_uri": "src/main/java/org/jsoup/parser/StreamParser.java.StreamParser",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "StreamParser",
            "classes": []
        },
        "docstring": "\nProvide the input for a fragment parse. The input is not read until a consuming operation is called.\n@param input the input to be read\n@param context the optional fragment context element\n@param baseUri the URL of this input, for absolute link resolution\n@return this parser\n@see #completeFragment()\n"
    },
    {
        "uris": "src/main/java/org/jsoup/parser/StreamParser.java.StreamParser.[StreamParser]parseFragment(String,Element,String)",
        "name": "parseFragment",
        "arg_nums": 3,
        "params": [
            {
                "name": "input",
                "type": "String"
            },
            {
                "name": "context",
                "type": "Element"
            },
            {
                "name": "baseUri",
                "type": "String"
            }
        ],
        "return_type": "StreamParser",
        "signature": "public StreamParser parseFragment(String input, @Nullable Element context, String baseUri)",
        "original_string": "    public StreamParser parseFragment(String input, @Nullable Element context, String baseUri) {\n        return parseFragment(new StringReader(input), context, baseUri);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/StreamParser.java",
        "class_name": "StreamParser",
        "class_uri": "src/main/java/org/jsoup/parser/StreamParser.java.StreamParser",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "StreamParser",
            "classes": []
        },
        "docstring": "\nProvide the input for a fragment parse. The input is not read until a consuming operation is called.\n@param input the input to be read\n@param context the optional fragment context element\n@param baseUri the URL of this input, for absolute link resolution\n@return this parser\n@see #completeFragment()\n"
    },
    {
        "uris": "src/main/java/org/jsoup/parser/StreamParser.java.StreamParser.[Stream<Element>]stream()",
        "name": "stream",
        "arg_nums": 0,
        "params": [],
        "return_type": "Stream<Element>",
        "signature": "public Stream<Element> stream()",
        "original_string": "    public Stream<Element> stream() {\n        return StreamSupport.stream(\n            Spliterators.spliteratorUnknownSize(\n                it, Spliterator.DISTINCT | Spliterator.NONNULL | Spliterator.ORDERED),\n            false);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/StreamParser.java",
        "class_name": "StreamParser",
        "class_uri": "src/main/java/org/jsoup/parser/StreamParser.java.StreamParser",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Stream<Element>",
            "classes": []
        },
        "docstring": "\nCreates a {@link Stream} of {@link Element}s, with the input being parsed as each element is consumed. Each\nElement returned will be complete (that is, all of its children will be included, and if it has a next sibling, that\n(empty) sibling will exist at {@link Element#nextElementSibling()}). The stream will be emitted in document order as\neach element is closed. That means that child elements will be returned prior to their parents.\n<p>The stream will start from the current position of the backing iterator and the parse.</p>\n<p>When consuming the stream, if the Reader that the Parser is reading throws an I/O exception (for example a\nSocketTimeoutException), that will be emitted as an {@link UncheckedIOException}</p>\n@return a stream of Element objects\n@throws UncheckedIOException if the underlying Reader excepts during a read (in stream consuming methods)\n"
    },
    {
        "uris": "src/main/java/org/jsoup/parser/StreamParser.java.StreamParser.[Iterator<Element>]iterator()",
        "name": "iterator",
        "arg_nums": 0,
        "params": [],
        "return_type": "Iterator<Element>",
        "signature": "public Iterator<Element> iterator()",
        "original_string": "    public Iterator<Element> iterator() {\n        //noinspection ReturnOfInnerClass\n        return it;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/StreamParser.java",
        "class_name": "StreamParser",
        "class_uri": "src/main/java/org/jsoup/parser/StreamParser.java.StreamParser",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Iterator<Element>",
            "classes": []
        },
        "docstring": "\nReturns an {@link Iterator} of {@link Element}s, with the input being parsed as each element is consumed. Each\nElement returned will be complete (that is, all of its children will be included, and if it has a next sibling, that\n(empty) sibling will exist at {@link Element#nextElementSibling()}). The elements will be emitted in document order as\neach element is closed. That means that child elements will be returned prior to their parents.\n<p>The iterator will start from the current position of the parse.</p>\n<p>The iterator is backed by this StreamParser, and the resources it holds.</p>\n@return a stream of Element objects\n"
    },
    {
        "uris": "src/main/java/org/jsoup/parser/StreamParser.java.StreamParser.[StreamParser]stop()",
        "name": "stop",
        "arg_nums": 0,
        "params": [],
        "return_type": "StreamParser",
        "signature": "public StreamParser stop()",
        "original_string": "    public StreamParser stop() {\n        stopped = true;\n        return this;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/StreamParser.java",
        "class_name": "StreamParser",
        "class_uri": "src/main/java/org/jsoup/parser/StreamParser.java.StreamParser",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "StreamParser",
            "classes": []
        },
        "docstring": "\nFlags that the parse should be stopped; the backing iterator will not return any more Elements.\n@return this parser\n"
    },
    {
        "uris": "src/main/java/org/jsoup/parser/StreamParser.java.StreamParser.[void]close()",
        "name": "close",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "@Override public void close()",
        "original_string": "    @Override public void close() {\n        treeBuilder.completeParse(); // closes the reader, frees resources\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/StreamParser.java",
        "class_name": "StreamParser",
        "class_uri": "src/main/java/org/jsoup/parser/StreamParser.java.StreamParser",
        "attributes": {
            "modifiers": "@Override public",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": "\nCloses the input and releases resources including the underlying parser and reader.\n<p>The parser will also be closed when the input is fully read.</p>\n<p>The parser can be reused with another call to {@link #parse(Reader, String)}.</p>\n"
    },
    {
        "uris": "src/main/java/org/jsoup/parser/StreamParser.java.StreamParser.[Document]document()",
        "name": "document",
        "arg_nums": 0,
        "params": [],
        "return_type": "Document",
        "signature": "public Document document()",
        "original_string": "    public Document document() {\n        document = treeBuilder.doc;\n        Validate.notNull(document, \"Must run parse() before calling.\");\n        return document;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/StreamParser.java",
        "class_name": "StreamParser",
        "class_uri": "src/main/java/org/jsoup/parser/StreamParser.java.StreamParser",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Document",
            "classes": []
        },
        "docstring": "\nGet the current {@link Document} as it is being parsed. It will be only partially complete until the input is fully\nread. Structural changes (e.g. insert, remove) may be made to the Document contents.\n@return the (partial) Document\n"
    },
    {
        "uris": "src/main/java/org/jsoup/parser/StreamParser.java.StreamParser.[Document]complete()",
        "name": "complete",
        "arg_nums": 0,
        "params": [],
        "return_type": "Document",
        "signature": "public Document complete()",
        "original_string": "    public Document complete() throws IOException {\n        Document doc = document();\n        treeBuilder.runParser();\n        return doc;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/StreamParser.java",
        "class_name": "StreamParser",
        "class_uri": "src/main/java/org/jsoup/parser/StreamParser.java.StreamParser",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Document",
            "classes": []
        },
        "docstring": "\nRuns the parser until the input is fully read, and returns the completed Document.\n@return the completed Document\n@throws IOException if an I/O error occurs\n"
    },
    {
        "uris": "src/main/java/org/jsoup/parser/StreamParser.java.StreamParser.[List<Node>]completeFragment()",
        "name": "completeFragment",
        "arg_nums": 0,
        "params": [],
        "return_type": "List<Node>",
        "signature": "public List<Node> completeFragment()",
        "original_string": "    public List<Node> completeFragment() throws IOException {\n        treeBuilder.runParser();\n        return treeBuilder.completeParseFragment();\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/StreamParser.java",
        "class_name": "StreamParser",
        "class_uri": "src/main/java/org/jsoup/parser/StreamParser.java.StreamParser",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "List<Node>",
            "classes": []
        },
        "docstring": "\nWhen initialized as a fragment parse, runs the parser until the input is fully read, and returns the completed\nfragment child nodes.\n@return the completed child nodes\n@throws IOException if an I/O error occurs\n@see #parseFragment(Reader, Element, String)\n"
    },
    {
        "uris": "src/main/java/org/jsoup/parser/StreamParser.java.StreamParser.[Element]selectFirst(String)",
        "name": "selectFirst",
        "arg_nums": 1,
        "params": [
            {
                "name": "query",
                "type": "String"
            }
        ],
        "return_type": "Element",
        "signature": "public @Nullable Element selectFirst(String query)",
        "original_string": "    public @Nullable Element selectFirst(String query) throws IOException {\n        return selectFirst(QueryParser.parse(query));\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/StreamParser.java",
        "class_name": "StreamParser",
        "class_uri": "src/main/java/org/jsoup/parser/StreamParser.java.StreamParser",
        "attributes": {
            "modifiers": "public @Nullable",
            "marker_annotations": [
                "@Nullable"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Element",
            "classes": []
        },
        "docstring": "\nFinds the first Element that matches the provided query. If the parsed Document does not already have a match, the\ninput will be parsed until the first match is found, or the input is completely read.\n@param query the {@link org.jsoup.select.Selector} query.\n@return the first matching {@link Element}, or {@code null} if there's no match\n@throws IOException if an I/O error occurs\n"
    },
    {
        "uris": "src/main/java/org/jsoup/parser/StreamParser.java.StreamParser.[Element]expectFirst(String)",
        "name": "expectFirst",
        "arg_nums": 1,
        "params": [
            {
                "name": "query",
                "type": "String"
            }
        ],
        "return_type": "Element",
        "signature": "public Element expectFirst(String query)",
        "original_string": "    public Element expectFirst(String query) throws IOException {\n        return (Element) Validate.ensureNotNull(\n            selectFirst(query),\n            \"No elements matched the query '%s' in the document.\"\n            , query\n        );\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/StreamParser.java",
        "class_name": "StreamParser",
        "class_uri": "src/main/java/org/jsoup/parser/StreamParser.java.StreamParser",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Element",
            "classes": []
        },
        "docstring": "\nJust like {@link #selectFirst(String)}, but if there is no match, throws an {@link IllegalArgumentException}. This\nis useful if you want to simply abort processing on a failed match.\n@param query the {@link org.jsoup.select.Selector} query.\n@return the first matching element\n@throws IllegalArgumentException if no match is found\n@throws IOException if an I/O error occurs\n"
    },
    {
        "uris": "src/main/java/org/jsoup/parser/StreamParser.java.StreamParser.[Element]selectFirst(Evaluator)",
        "name": "selectFirst",
        "arg_nums": 1,
        "params": [
            {
                "name": "eval",
                "type": "Evaluator"
            }
        ],
        "return_type": "Element",
        "signature": "public @Nullable Element selectFirst(Evaluator eval)",
        "original_string": "    public @Nullable Element selectFirst(Evaluator eval) throws IOException {\n        final Document doc = document();\n\n        // run the query on the existing (partial) doc first, as there may be a hit already parsed\n        Element first = doc.selectFirst(eval);\n        if (first != null) return first;\n\n        return selectNext(eval);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/StreamParser.java",
        "class_name": "StreamParser",
        "class_uri": "src/main/java/org/jsoup/parser/StreamParser.java.StreamParser",
        "attributes": {
            "modifiers": "public @Nullable",
            "marker_annotations": [
                "@Nullable"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Element",
            "classes": []
        },
        "docstring": "\nFinds the first Element that matches the provided query. If the parsed Document does not already have a match, the\ninput will be parsed until the first match is found, or the input is completely read.\n@param eval the {@link org.jsoup.select.Selector} evaluator.\n@return the first matching {@link Element}, or {@code null} if there's no match\n@throws IOException if an I/O error occurs\n"
    },
    {
        "uris": "src/main/java/org/jsoup/parser/StreamParser.java.StreamParser.[Element]selectNext(String)",
        "name": "selectNext",
        "arg_nums": 1,
        "params": [
            {
                "name": "query",
                "type": "String"
            }
        ],
        "return_type": "Element",
        "signature": "public @Nullable Element selectNext(String query)",
        "original_string": "    public @Nullable Element selectNext(String query) throws IOException {\n        return selectNext(QueryParser.parse(query));\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/StreamParser.java",
        "class_name": "StreamParser",
        "class_uri": "src/main/java/org/jsoup/parser/StreamParser.java.StreamParser",
        "attributes": {
            "modifiers": "public @Nullable",
            "marker_annotations": [
                "@Nullable"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Element",
            "classes": []
        },
        "docstring": "\nFinds the next Element that matches the provided query. The input will be parsed until the next match is found, or\nthe input is completely read.\n@param query the {@link org.jsoup.select.Selector} query.\n@return the next matching {@link Element}, or {@code null} if there's no match\n@throws IOException if an I/O error occurs\n"
    },
    {
        "uris": "src/main/java/org/jsoup/parser/StreamParser.java.StreamParser.[Element]expectNext(String)",
        "name": "expectNext",
        "arg_nums": 1,
        "params": [
            {
                "name": "query",
                "type": "String"
            }
        ],
        "return_type": "Element",
        "signature": "public Element expectNext(String query)",
        "original_string": "    public Element expectNext(String query) throws IOException {\n        return (Element) Validate.ensureNotNull(\n            selectNext(query),\n            \"No elements matched the query '%s' in the document.\"\n            , query\n        );\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/StreamParser.java",
        "class_name": "StreamParser",
        "class_uri": "src/main/java/org/jsoup/parser/StreamParser.java.StreamParser",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Element",
            "classes": []
        },
        "docstring": "\nJust like {@link #selectFirst(String)}, but if there is no match, throws an {@link IllegalArgumentException}. This\nis useful if you want to simply abort processing on a failed match.\n@param query the {@link org.jsoup.select.Selector} query.\n@return the first matching element\n@throws IllegalArgumentException if no match is found\n@throws IOException if an I/O error occurs\n"
    },
    {
        "uris": "src/main/java/org/jsoup/parser/StreamParser.java.StreamParser.[Element]selectNext(Evaluator)",
        "name": "selectNext",
        "arg_nums": 1,
        "params": [
            {
                "name": "eval",
                "type": "Evaluator"
            }
        ],
        "return_type": "Element",
        "signature": "public @Nullable Element selectNext(Evaluator eval)",
        "original_string": "    public @Nullable Element selectNext(Evaluator eval) throws IOException {\n        try {\n            final Document doc = document(); // validates the parse was initialized, keeps stack trace out of stream\n            return stream()\n                .filter(eval.asPredicate(doc))\n                .findFirst()\n                .orElse(null);\n        } catch (UncheckedIOException e) {\n            // Reader threw an IO exception emitted via Iterator's next()\n            throw e.getCause();\n        }\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/StreamParser.java",
        "class_name": "StreamParser",
        "class_uri": "src/main/java/org/jsoup/parser/StreamParser.java.StreamParser",
        "attributes": {
            "modifiers": "public @Nullable",
            "marker_annotations": [
                "@Nullable"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Element",
            "classes": []
        },
        "docstring": "\nFinds the next Element that matches the provided query. The input will be parsed until the next match is found, or\nthe input is completely read.\n@param eval the {@link org.jsoup.select.Selector} evaluator.\n@return the next matching {@link Element}, or {@code null} if there's no match\n@throws IOException if an I/O error occurs\n"
    },
    {
        "uris": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[ParseSettings]defaultSettings()",
        "name": "defaultSettings",
        "arg_nums": 0,
        "params": [],
        "return_type": "ParseSettings",
        "signature": "@Override ParseSettings defaultSettings()",
        "original_string": "    @Override ParseSettings defaultSettings() {\n        return ParseSettings.htmlDefault;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "class_name": "HtmlTreeBuilder",
        "class_uri": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder",
        "attributes": {
            "modifiers": "@Override",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "ParseSettings",
            "classes": []
        },
        "docstring": " if parsing a fragment of html"
    },
    {
        "uris": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[HtmlTreeBuilder]newInstance()",
        "name": "newInstance",
        "arg_nums": 0,
        "params": [],
        "return_type": "HtmlTreeBuilder",
        "signature": "@Override\n    HtmlTreeBuilder newInstance()",
        "original_string": "    @Override\n    HtmlTreeBuilder newInstance() {\n        return new HtmlTreeBuilder();\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "class_name": "HtmlTreeBuilder",
        "class_uri": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder",
        "attributes": {
            "modifiers": "@Override",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "HtmlTreeBuilder",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[void]initialiseParse(Reader,String,Parser)",
        "name": "initialiseParse",
        "arg_nums": 3,
        "params": [
            {
                "name": "input",
                "type": "Reader"
            },
            {
                "name": "baseUri",
                "type": "String"
            },
            {
                "name": "parser",
                "type": "Parser"
            }
        ],
        "return_type": "void",
        "signature": "@Override\n    protected void initialiseParse(Reader input, String baseUri, Parser parser)",
        "original_string": "    @Override\n    protected void initialiseParse(Reader input, String baseUri, Parser parser) {\n        super.initialiseParse(input, baseUri, parser);\n\n        // this is a bit mucky. todo - probably just create new parser objects to ensure all reset.\n        state = HtmlTreeBuilderState.Initial;\n        originalState = null;\n        baseUriSetFromDoc = false;\n        headElement = null;\n        formElement = null;\n        contextElement = null;\n        formattingElements = new ArrayList<>();\n        tmplInsertMode = new ArrayList<>();\n        pendingTableCharacters = new ArrayList<>();\n        emptyEnd = new Token.EndTag(this);\n        framesetOk = true;\n        fosterInserts = false;\n        fragmentParsing = false;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "class_name": "HtmlTreeBuilder",
        "class_uri": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder",
        "attributes": {
            "modifiers": "@Override\n    protected",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "protected"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[void]initialiseParseFragment(Element)",
        "name": "initialiseParseFragment",
        "arg_nums": 1,
        "params": [
            {
                "name": "context",
                "type": "Element"
            }
        ],
        "return_type": "void",
        "signature": "@Override void initialiseParseFragment(@Nullable Element context)",
        "original_string": "    @Override void initialiseParseFragment(@Nullable Element context) {\n        // context may be null\n        state = HtmlTreeBuilderState.Initial;\n        fragmentParsing = true;\n\n        if (context != null) {\n            final String contextName = context.normalName();\n            contextElement = new Element(tagFor(contextName, settings), baseUri);\n            if (context.ownerDocument() != null) // quirks setup:\n                doc.quirksMode(context.ownerDocument().quirksMode());\n\n            // initialise the tokeniser state:\n            switch (contextName) {\n                case \"title\":\n                case \"textarea\":\n                    tokeniser.transition(TokeniserState.Rcdata);\n                    break;\n                case \"iframe\":\n                case \"noembed\":\n                case \"noframes\":\n                case \"style\":\n                case \"xmp\":\n                    tokeniser.transition(TokeniserState.Rawtext);\n                    break;\n                case \"script\":\n                    tokeniser.transition(TokeniserState.ScriptData);\n                    break;\n                case \"plaintext\":\n                    tokeniser.transition(TokeniserState.PLAINTEXT);\n                    break;\n                case \"template\":\n                    tokeniser.transition(TokeniserState.Data);\n                    pushTemplateMode(HtmlTreeBuilderState.InTemplate);\n                    break;\n                default:\n                    tokeniser.transition(TokeniserState.Data);\n            }\n            doc.appendChild(contextElement);\n            push(contextElement);\n            resetInsertionMode();\n\n            // setup form element to nearest form on context (up ancestor chain). ensures form controls are associated\n            // with form correctly\n            Element formSearch = context;\n            while (formSearch != null) {\n                if (formSearch instanceof FormElement) {\n                    formElement = (FormElement) formSearch;\n                    break;\n                }\n                formSearch = formSearch.parent();\n            }\n        }\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "class_name": "HtmlTreeBuilder",
        "class_uri": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder",
        "attributes": {
            "modifiers": "@Override",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[List<Node>]completeParseFragment()",
        "name": "completeParseFragment",
        "arg_nums": 0,
        "params": [],
        "return_type": "List<Node>",
        "signature": "@Override List<Node> completeParseFragment()",
        "original_string": "    @Override List<Node> completeParseFragment() {\n        if (contextElement != null) {\n            // depending on context and the input html, content may have been added outside of the root el\n            // e.g. context=p, input=div, the div will have been pushed out.\n            List<Node> nodes = contextElement.siblingNodes();\n            if (!nodes.isEmpty())\n                contextElement.insertChildren(-1, nodes);\n            return contextElement.childNodes();\n        }\n        else\n            return doc.childNodes();\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "class_name": "HtmlTreeBuilder",
        "class_uri": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder",
        "attributes": {
            "modifiers": "@Override",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "List<Node>",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[boolean]process(Token)",
        "name": "process",
        "arg_nums": 1,
        "params": [
            {
                "name": "token",
                "type": "Token"
            }
        ],
        "return_type": "boolean",
        "signature": "@Override\n    protected boolean process(Token token)",
        "original_string": "    @Override\n    protected boolean process(Token token) {\n        HtmlTreeBuilderState dispatch = useCurrentOrForeignInsert(token) ? this.state : ForeignContent;\n        return dispatch.process(token, this);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "class_name": "HtmlTreeBuilder",
        "class_uri": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder",
        "attributes": {
            "modifiers": "@Override\n    protected",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "protected"
            ],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[boolean]useCurrentOrForeignInsert(Token)",
        "name": "useCurrentOrForeignInsert",
        "arg_nums": 1,
        "params": [
            {
                "name": "token",
                "type": "Token"
            }
        ],
        "return_type": "boolean",
        "signature": "boolean useCurrentOrForeignInsert(Token token)",
        "original_string": "    boolean useCurrentOrForeignInsert(Token token) {\n        // https://html.spec.whatwg.org/multipage/parsing.html#tree-construction\n        // If the stack of open elements is empty\n        if (stack.isEmpty())\n            return true;\n        final Element el = currentElement();\n        final String ns = el.tag().namespace();\n\n        // If the adjusted current node is an element in the HTML namespace\n        if (NamespaceHtml.equals(ns))\n            return true;\n\n        // If the adjusted current node is a MathML text integration point and the token is a start tag whose tag name is neither \"mglyph\" nor \"malignmark\"\n        // If the adjusted current node is a MathML text integration point and the token is a character token\n        if (isMathmlTextIntegration(el)) {\n            if (token.isStartTag()\n                    && !\"mglyph\".equals(token.asStartTag().normalName)\n                    && !\"malignmark\".equals(token.asStartTag().normalName))\n                    return true;\n            if (token.isCharacter())\n                    return true;\n        }\n        // If the adjusted current node is a MathML annotation-xml element and the token is a start tag whose tag name is \"svg\"\n        if (Parser.NamespaceMathml.equals(ns)\n            && el.nameIs(\"annotation-xml\")\n            && token.isStartTag()\n            && \"svg\".equals(token.asStartTag().normalName))\n            return true;\n\n        // If the adjusted current node is an HTML integration point and the token is a start tag\n        // If the adjusted current node is an HTML integration point and the token is a character token\n        if (isHtmlIntegration(el)\n            && (token.isStartTag() || token.isCharacter()))\n            return true;\n\n        // If the token is an end-of-file token\n        return token.isEOF();\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "class_name": "HtmlTreeBuilder",
        "class_uri": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[boolean]isMathmlTextIntegration(Element)",
        "name": "isMathmlTextIntegration",
        "arg_nums": 1,
        "params": [
            {
                "name": "el",
                "type": "Element"
            }
        ],
        "return_type": "boolean",
        "signature": "static boolean isMathmlTextIntegration(Element el)",
        "original_string": "    static boolean isMathmlTextIntegration(Element el) {\n        /*\n        A node is a MathML text integration point if it is one of the following elements:\n        A MathML mi element\n        A MathML mo element\n        A MathML mn element\n        A MathML ms element\n        A MathML mtext element\n         */\n        return (Parser.NamespaceMathml.equals(el.tag().namespace())\n            && StringUtil.inSorted(el.normalName(), TagMathMlTextIntegration));\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "class_name": "HtmlTreeBuilder",
        "class_uri": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder",
        "attributes": {
            "modifiers": "static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "static"
            ],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[boolean]isHtmlIntegration(Element)",
        "name": "isHtmlIntegration",
        "arg_nums": 1,
        "params": [
            {
                "name": "el",
                "type": "Element"
            }
        ],
        "return_type": "boolean",
        "signature": "static boolean isHtmlIntegration(Element el)",
        "original_string": "    static boolean isHtmlIntegration(Element el) {\n        /*\n        A node is an HTML integration point if it is one of the following elements:\n        A MathML annotation-xml element whose start tag token had an attribute with the name \"encoding\" whose value was an ASCII case-insensitive match for the string \"text/html\"\n        A MathML annotation-xml element whose start tag token had an attribute with the name \"encoding\" whose value was an ASCII case-insensitive match for the string \"application/xhtml+xml\"\n        An SVG foreignObject element\n        An SVG desc element\n        An SVG title element\n         */\n        if (Parser.NamespaceMathml.equals(el.tag().namespace())\n            && el.nameIs(\"annotation-xml\")) {\n            String encoding = Normalizer.normalize(el.attr(\"encoding\"));\n            if (encoding.equals(\"text/html\") || encoding.equals(\"application/xhtml+xml\"))\n                return true;\n        }\n        if (Parser.NamespaceSvg.equals(el.tag().namespace())\n            && StringUtil.in(el.tagName(), TagSvgHtmlIntegration)) // note using .tagName for case-sensitive hit here of foreignObject\n            return true;\n\n        return false;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "class_name": "HtmlTreeBuilder",
        "class_uri": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder",
        "attributes": {
            "modifiers": "static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "static"
            ],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[boolean]process(Token,HtmlTreeBuilderState)",
        "name": "process",
        "arg_nums": 2,
        "params": [
            {
                "name": "token",
                "type": "Token"
            },
            {
                "name": "state",
                "type": "HtmlTreeBuilderState"
            }
        ],
        "return_type": "boolean",
        "signature": "boolean process(Token token, HtmlTreeBuilderState state)",
        "original_string": "    boolean process(Token token, HtmlTreeBuilderState state) {\n        return state.process(token, this);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "class_name": "HtmlTreeBuilder",
        "class_uri": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[void]transition(HtmlTreeBuilderState)",
        "name": "transition",
        "arg_nums": 1,
        "params": [
            {
                "name": "state",
                "type": "HtmlTreeBuilderState"
            }
        ],
        "return_type": "void",
        "signature": "void transition(HtmlTreeBuilderState state)",
        "original_string": "    void transition(HtmlTreeBuilderState state) {\n        this.state = state;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "class_name": "HtmlTreeBuilder",
        "class_uri": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[HtmlTreeBuilderState]state()",
        "name": "state",
        "arg_nums": 0,
        "params": [],
        "return_type": "HtmlTreeBuilderState",
        "signature": "HtmlTreeBuilderState state()",
        "original_string": "    HtmlTreeBuilderState state() {\n        return state;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "class_name": "HtmlTreeBuilder",
        "class_uri": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "HtmlTreeBuilderState",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[void]markInsertionMode()",
        "name": "markInsertionMode",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "void markInsertionMode()",
        "original_string": "    void markInsertionMode() {\n        originalState = state;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "class_name": "HtmlTreeBuilder",
        "class_uri": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[HtmlTreeBuilderState]originalState()",
        "name": "originalState",
        "arg_nums": 0,
        "params": [],
        "return_type": "HtmlTreeBuilderState",
        "signature": "HtmlTreeBuilderState originalState()",
        "original_string": "    HtmlTreeBuilderState originalState() {\n        return originalState;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "class_name": "HtmlTreeBuilder",
        "class_uri": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "HtmlTreeBuilderState",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[void]framesetOk(boolean)",
        "name": "framesetOk",
        "arg_nums": 1,
        "params": [
            {
                "name": "framesetOk",
                "type": "boolean"
            }
        ],
        "return_type": "void",
        "signature": "void framesetOk(boolean framesetOk)",
        "original_string": "    void framesetOk(boolean framesetOk) {\n        this.framesetOk = framesetOk;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "class_name": "HtmlTreeBuilder",
        "class_uri": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[boolean]framesetOk()",
        "name": "framesetOk",
        "arg_nums": 0,
        "params": [],
        "return_type": "boolean",
        "signature": "boolean framesetOk()",
        "original_string": "    boolean framesetOk() {\n        return framesetOk;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "class_name": "HtmlTreeBuilder",
        "class_uri": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[Document]getDocument()",
        "name": "getDocument",
        "arg_nums": 0,
        "params": [],
        "return_type": "Document",
        "signature": "Document getDocument()",
        "original_string": "    Document getDocument() {\n        return doc;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "class_name": "HtmlTreeBuilder",
        "class_uri": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "Document",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[String]getBaseUri()",
        "name": "getBaseUri",
        "arg_nums": 0,
        "params": [],
        "return_type": "String",
        "signature": "String getBaseUri()",
        "original_string": "    String getBaseUri() {\n        return baseUri;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "class_name": "HtmlTreeBuilder",
        "class_uri": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[void]maybeSetBaseUri(Element)",
        "name": "maybeSetBaseUri",
        "arg_nums": 1,
        "params": [
            {
                "name": "base",
                "type": "Element"
            }
        ],
        "return_type": "void",
        "signature": "void maybeSetBaseUri(Element base)",
        "original_string": "    void maybeSetBaseUri(Element base) {\n        if (baseUriSetFromDoc) // only listen to the first <base href> in parse\n            return;\n\n        String href = base.absUrl(\"href\");\n        if (href.length() != 0) { // ignore <base target> etc\n            baseUri = href;\n            baseUriSetFromDoc = true;\n            doc.setBaseUri(href); // set on the doc so doc.createElement(Tag) will get updated base, and to update all descendants\n        }\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "class_name": "HtmlTreeBuilder",
        "class_uri": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[boolean]isFragmentParsing()",
        "name": "isFragmentParsing",
        "arg_nums": 0,
        "params": [],
        "return_type": "boolean",
        "signature": "boolean isFragmentParsing()",
        "original_string": "    boolean isFragmentParsing() {\n        return fragmentParsing;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "class_name": "HtmlTreeBuilder",
        "class_uri": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[void]error(HtmlTreeBuilderState)",
        "name": "error",
        "arg_nums": 1,
        "params": [
            {
                "name": "state",
                "type": "HtmlTreeBuilderState"
            }
        ],
        "return_type": "void",
        "signature": "void error(HtmlTreeBuilderState state)",
        "original_string": "    void error(HtmlTreeBuilderState state) {\n        if (parser.getErrors().canAddError())\n            parser.getErrors().add(new ParseError(reader, \"Unexpected %s token [%s] when in state [%s]\",\n                currentToken.tokenType(), currentToken, state));\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "class_name": "HtmlTreeBuilder",
        "class_uri": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[Element]createElementFor(Token.StartTag,String,boolean)",
        "name": "createElementFor",
        "arg_nums": 3,
        "params": [
            {
                "name": "startTag",
                "type": "Token.StartTag"
            },
            {
                "name": "namespace",
                "type": "String"
            },
            {
                "name": "forcePreserveCase",
                "type": "boolean"
            }
        ],
        "return_type": "Element",
        "signature": "Element createElementFor(Token.StartTag startTag, String namespace, boolean forcePreserveCase)",
        "original_string": "    Element createElementFor(Token.StartTag startTag, String namespace, boolean forcePreserveCase) {\n        // dedupe and normalize the attributes:\n        Attributes attributes = startTag.attributes;\n        if (!forcePreserveCase)\n            attributes = settings.normalizeAttributes(attributes);\n        if (attributes != null && !attributes.isEmpty()) {\n            int dupes = attributes.deduplicate(settings);\n            if (dupes > 0) {\n                error(\"Dropped duplicate attribute(s) in tag [%s]\", startTag.normalName);\n            }\n        }\n\n        Tag tag = tagFor(startTag.tagName, namespace,\n            forcePreserveCase ? ParseSettings.preserveCase : settings);\n\n        return (tag.normalName().equals(\"form\")) ?\n            new FormElement(tag, null, attributes) :\n            new Element(tag, null, attributes);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "class_name": "HtmlTreeBuilder",
        "class_uri": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "Element",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[Element]insertElementFor(Token.StartTag)",
        "name": "insertElementFor",
        "arg_nums": 1,
        "params": [
            {
                "name": "startTag",
                "type": "Token.StartTag"
            }
        ],
        "return_type": "Element",
        "signature": "Element insertElementFor(final Token.StartTag startTag)",
        "original_string": "    Element insertElementFor(final Token.StartTag startTag) {\n        Element el = createElementFor(startTag, NamespaceHtml, false);\n        doInsertElement(el, startTag);\n\n        // handle self-closing tags. when the spec expects an empty tag, will directly hit insertEmpty, so won't generate this fake end tag.\n        if (startTag.isSelfClosing()) {\n            Tag tag = el.tag();\n            if (tag.isKnownTag()) {\n                if (!tag.isEmpty())\n                    tokeniser.error(\"Tag [%s] cannot be self closing; not a void tag\", tag.normalName());\n                // else: ok\n            }\n            else { // unknown tag: remember this is self-closing, for output\n                tag.setSelfClosing();\n            }\n\n            // effectively a pop, but fiddles with the state. handles empty style, title etc which would otherwise leave us in data state\n            tokeniser.transition(TokeniserState.Data); // handles <script />, otherwise needs breakout steps from script data\n            tokeniser.emit(emptyEnd.reset().name(el.tagName()));  // ensure we get out of whatever state we are in. emitted for yielded processing\n        }\n\n        return el;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "class_name": "HtmlTreeBuilder",
        "class_uri": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "Element",
            "classes": []
        },
        "docstring": " Inserts an HTML element for the given tag)"
    },
    {
        "uris": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[Element]insertForeignElementFor(Token.StartTag,String)",
        "name": "insertForeignElementFor",
        "arg_nums": 2,
        "params": [
            {
                "name": "startTag",
                "type": "Token.StartTag"
            },
            {
                "name": "namespace",
                "type": "String"
            }
        ],
        "return_type": "Element",
        "signature": "Element insertForeignElementFor(final Token.StartTag startTag, String namespace)",
        "original_string": "    Element insertForeignElementFor(final Token.StartTag startTag, String namespace) {\n        Element el = createElementFor(startTag, namespace, true);\n        doInsertElement(el, startTag);\n\n        if (startTag.isSelfClosing()) {\n            el.tag().setSelfClosing(); // remember this is self-closing for output\n            pop();\n        }\n\n        return el;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "class_name": "HtmlTreeBuilder",
        "class_uri": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "Element",
            "classes": []
        },
        "docstring": "\nInserts a foreign element. Preserves the case of the tag name and of the attributes.\n"
    },
    {
        "uris": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[Element]insertEmptyElementFor(Token.StartTag)",
        "name": "insertEmptyElementFor",
        "arg_nums": 1,
        "params": [
            {
                "name": "startTag",
                "type": "Token.StartTag"
            }
        ],
        "return_type": "Element",
        "signature": "Element insertEmptyElementFor(Token.StartTag startTag)",
        "original_string": "    Element insertEmptyElementFor(Token.StartTag startTag) {\n        Element el = createElementFor(startTag, NamespaceHtml, false);\n        doInsertElement(el, startTag);\n        pop();\n        return el;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "class_name": "HtmlTreeBuilder",
        "class_uri": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "Element",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[FormElement]insertFormElement(Token.StartTag,boolean,boolean)",
        "name": "insertFormElement",
        "arg_nums": 3,
        "params": [
            {
                "name": "startTag",
                "type": "Token.StartTag"
            },
            {
                "name": "onStack",
                "type": "boolean"
            },
            {
                "name": "checkTemplateStack",
                "type": "boolean"
            }
        ],
        "return_type": "FormElement",
        "signature": "FormElement insertFormElement(Token.StartTag startTag, boolean onStack, boolean checkTemplateStack)",
        "original_string": "    FormElement insertFormElement(Token.StartTag startTag, boolean onStack, boolean checkTemplateStack) {\n        FormElement el = (FormElement) createElementFor(startTag, NamespaceHtml, false);\n\n        if (checkTemplateStack) {\n            if(!onStack(\"template\"))\n                setFormElement(el);\n        } else\n            setFormElement(el);\n\n        doInsertElement(el, startTag);\n        if (!onStack) pop();\n        return el;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "class_name": "HtmlTreeBuilder",
        "class_uri": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "FormElement",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[void]doInsertElement(Element,Token)",
        "name": "doInsertElement",
        "arg_nums": 2,
        "params": [
            {
                "name": "el",
                "type": "Element"
            },
            {
                "name": "token",
                "type": "Token"
            }
        ],
        "return_type": "void",
        "signature": "private void doInsertElement(Element el, @Nullable Token token)",
        "original_string": "    private void doInsertElement(Element el, @Nullable Token token) {\n        if (el.tag().isFormListed() && formElement != null)\n            formElement.addElement(el); // connect form controls to their form element\n\n        // in HTML, the xmlns attribute if set must match what the parser set the tag's namespace to\n        if (parser.getErrors().canAddError() && el.hasAttr(\"xmlns\") && !el.attr(\"xmlns\").equals(el.tag().namespace()))\n            error(\"Invalid xmlns attribute [%s] on tag [%s]\", el.attr(\"xmlns\"), el.tagName());\n\n        if (isFosterInserts() && StringUtil.inSorted(currentElement().normalName(), InTableFoster))\n            insertInFosterParent(el);\n        else\n            currentElement().appendChild(el);\n\n        push(el);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "class_name": "HtmlTreeBuilder",
        "class_uri": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder",
        "attributes": {
            "modifiers": "private",
            "marker_annotations": [],
            "non_marker_annotations": [
                "private"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": " Inserts the Element onto the stack. All element inserts must run through this method. Performs any general\ntests on the Element before insertion.\n@param el the Element to insert and make the current element\n@param token the token this element was parsed from. If null, uses a zero-width current token as intrinsic insert\n"
    },
    {
        "uris": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[void]insertCommentNode(Token.Comment)",
        "name": "insertCommentNode",
        "arg_nums": 1,
        "params": [
            {
                "name": "token",
                "type": "Token.Comment"
            }
        ],
        "return_type": "void",
        "signature": "void insertCommentNode(Token.Comment token)",
        "original_string": "    void insertCommentNode(Token.Comment token) {\n        Comment node = new Comment(token.getData());\n        currentElement().appendChild(node);\n        onNodeInserted(node);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "class_name": "HtmlTreeBuilder",
        "class_uri": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[void]insertCharacterNode(Token.Character)",
        "name": "insertCharacterNode",
        "arg_nums": 1,
        "params": [
            {
                "name": "characterToken",
                "type": "Token.Character"
            }
        ],
        "return_type": "void",
        "signature": "void insertCharacterNode(Token.Character characterToken)",
        "original_string": "    void insertCharacterNode(Token.Character characterToken) {\n        Element el = currentElement(); // will be doc if no current element; allows for whitespace to be inserted into the doc root object (not on the stack)\n        insertCharacterToElement(characterToken, el);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "class_name": "HtmlTreeBuilder",
        "class_uri": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": " Inserts the provided character token into the current element."
    },
    {
        "uris": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[void]insertCharacterToElement(Token.Character,Element)",
        "name": "insertCharacterToElement",
        "arg_nums": 2,
        "params": [
            {
                "name": "characterToken",
                "type": "Token.Character"
            },
            {
                "name": "el",
                "type": "Element"
            }
        ],
        "return_type": "void",
        "signature": "void insertCharacterToElement(Token.Character characterToken, Element el)",
        "original_string": "    void insertCharacterToElement(Token.Character characterToken, Element el) {\n        final Node node;\n        final String tagName = el.normalName();\n        final String data = characterToken.getData();\n\n        if (characterToken.isCData())\n            node = new CDataNode(data);\n        else if (isContentForTagData(tagName))\n            node = new DataNode(data);\n        else\n            node = new TextNode(data);\n        el.appendChild(node); // doesn't use insertNode, because we don't foster these; and will always have a stack.\n        onNodeInserted(node);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "class_name": "HtmlTreeBuilder",
        "class_uri": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": " Inserts the provided character token into the provided element."
    },
    {
        "uris": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[ArrayList<Element>]getStack()",
        "name": "getStack",
        "arg_nums": 0,
        "params": [],
        "return_type": "ArrayList<Element>",
        "signature": "ArrayList<Element> getStack()",
        "original_string": "    ArrayList<Element> getStack() {\n        return stack;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "class_name": "HtmlTreeBuilder",
        "class_uri": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "ArrayList<Element>",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[boolean]onStack(Element)",
        "name": "onStack",
        "arg_nums": 1,
        "params": [
            {
                "name": "el",
                "type": "Element"
            }
        ],
        "return_type": "boolean",
        "signature": "boolean onStack(Element el)",
        "original_string": "    boolean onStack(Element el) {\n        return onStack(stack, el);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "class_name": "HtmlTreeBuilder",
        "class_uri": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[boolean]onStack(String)",
        "name": "onStack",
        "arg_nums": 1,
        "params": [
            {
                "name": "elName",
                "type": "String"
            }
        ],
        "return_type": "boolean",
        "signature": "boolean onStack(String elName)",
        "original_string": "    boolean onStack(String elName) {\n        return getFromStack(elName) != null;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "class_name": "HtmlTreeBuilder",
        "class_uri": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": " Checks if there is an HTML element with the given name on the stack."
    },
    {
        "uris": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[boolean]onStack(ArrayList<Element>,Element)",
        "name": "onStack",
        "arg_nums": 2,
        "params": [
            {
                "name": "queue",
                "type": "ArrayList<Element>"
            },
            {
                "name": "element",
                "type": "Element"
            }
        ],
        "return_type": "boolean",
        "signature": "private static boolean onStack(ArrayList<Element> queue, Element element)",
        "original_string": "    private static boolean onStack(ArrayList<Element> queue, Element element) {\n        final int bottom = queue.size() - 1;\n        final int upper = bottom >= maxQueueDepth ? bottom - maxQueueDepth : 0;\n        for (int pos = bottom; pos >= upper; pos--) {\n            Element next = queue.get(pos);\n            if (next == element) {\n                return true;\n            }\n        }\n        return false;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "class_name": "HtmlTreeBuilder",
        "class_uri": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder",
        "attributes": {
            "modifiers": "private static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "private",
                "static"
            ],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": " an arbitrary tension point between real HTML and crafted pain"
    },
    {
        "uris": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[Element]getFromStack(String)",
        "name": "getFromStack",
        "arg_nums": 1,
        "params": [
            {
                "name": "elName",
                "type": "String"
            }
        ],
        "return_type": "Element",
        "signature": "@Nullable\n    Element getFromStack(String elName)",
        "original_string": "    @Nullable\n    Element getFromStack(String elName) {\n        final int bottom = stack.size() - 1;\n        final int upper = bottom >= maxQueueDepth ? bottom - maxQueueDepth : 0;\n        for (int pos = bottom; pos >= upper; pos--) {\n            Element next = stack.get(pos);\n            if (next.elementIs(elName, NamespaceHtml)) {\n                return next;\n            }\n        }\n        return null;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "class_name": "HtmlTreeBuilder",
        "class_uri": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder",
        "attributes": {
            "modifiers": "@Nullable",
            "marker_annotations": [
                "@Nullable"
            ],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "Element",
            "classes": []
        },
        "docstring": " Gets the nearest (lowest) HTML element with the given name from the stack."
    },
    {
        "uris": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[boolean]removeFromStack(Element)",
        "name": "removeFromStack",
        "arg_nums": 1,
        "params": [
            {
                "name": "el",
                "type": "Element"
            }
        ],
        "return_type": "boolean",
        "signature": "boolean removeFromStack(Element el)",
        "original_string": "    boolean removeFromStack(Element el) {\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            if (next == el) {\n                stack.remove(pos);\n                onNodeClosed(el);\n                return true;\n            }\n        }\n        return false;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "class_name": "HtmlTreeBuilder",
        "class_uri": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[Element]popStackToClose(String)",
        "name": "popStackToClose",
        "arg_nums": 1,
        "params": [
            {
                "name": "elName",
                "type": "String"
            }
        ],
        "return_type": "Element",
        "signature": "@Nullable\n    Element popStackToClose(String elName)",
        "original_string": "    @Nullable\n    Element popStackToClose(String elName) {\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element el = pop();\n            if (el.elementIs(elName, NamespaceHtml)) {\n                return el;\n            }\n        }\n        return null;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "class_name": "HtmlTreeBuilder",
        "class_uri": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder",
        "attributes": {
            "modifiers": "@Nullable",
            "marker_annotations": [
                "@Nullable"
            ],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "Element",
            "classes": []
        },
        "docstring": " Pops the stack until the given HTML element is removed."
    },
    {
        "uris": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[Element]popStackToCloseAnyNamespace(String)",
        "name": "popStackToCloseAnyNamespace",
        "arg_nums": 1,
        "params": [
            {
                "name": "elName",
                "type": "String"
            }
        ],
        "return_type": "Element",
        "signature": "@Nullable\n    Element popStackToCloseAnyNamespace(String elName)",
        "original_string": "    @Nullable\n    Element popStackToCloseAnyNamespace(String elName) {\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element el = pop();\n            if (el.nameIs(elName)) {\n                return el;\n            }\n        }\n        return null;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "class_name": "HtmlTreeBuilder",
        "class_uri": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder",
        "attributes": {
            "modifiers": "@Nullable",
            "marker_annotations": [
                "@Nullable"
            ],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "Element",
            "classes": []
        },
        "docstring": " Pops the stack until an element with the supplied name is removed, irrespective of namespace."
    },
    {
        "uris": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[void]popStackToClose()",
        "name": "popStackToClose",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "void popStackToClose(String... elNames)",
        "original_string": "    void popStackToClose(String... elNames) { // elnames is sorted, comes from Constants\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element el = pop();\n            if (inSorted(el.normalName(), elNames) && NamespaceHtml.equals(el.tag().namespace())) {\n                break;\n            }\n        }\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "class_name": "HtmlTreeBuilder",
        "class_uri": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": " Pops the stack until one of the given HTML elements is removed."
    },
    {
        "uris": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[void]clearStackToTableContext()",
        "name": "clearStackToTableContext",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "void clearStackToTableContext()",
        "original_string": "    void clearStackToTableContext() {\n        clearStackToContext(\"table\", \"template\");\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "class_name": "HtmlTreeBuilder",
        "class_uri": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[void]clearStackToTableBodyContext()",
        "name": "clearStackToTableBodyContext",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "void clearStackToTableBodyContext()",
        "original_string": "    void clearStackToTableBodyContext() {\n        clearStackToContext(\"tbody\", \"tfoot\", \"thead\", \"template\");\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "class_name": "HtmlTreeBuilder",
        "class_uri": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[void]clearStackToTableRowContext()",
        "name": "clearStackToTableRowContext",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "void clearStackToTableRowContext()",
        "original_string": "    void clearStackToTableRowContext() {\n        clearStackToContext(\"tr\", \"template\");\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "class_name": "HtmlTreeBuilder",
        "class_uri": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[void]clearStackToContext()",
        "name": "clearStackToContext",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "private void clearStackToContext(String... nodeNames)",
        "original_string": "    private void clearStackToContext(String... nodeNames) {\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            if (NamespaceHtml.equals(next.tag().namespace()) &&\n                (StringUtil.in(next.normalName(), nodeNames) || next.nameIs(\"html\")))\n                break;\n            else\n                pop();\n        }\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "class_name": "HtmlTreeBuilder",
        "class_uri": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder",
        "attributes": {
            "modifiers": "private",
            "marker_annotations": [],
            "non_marker_annotations": [
                "private"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": " Removes elements from the stack until one of the supplied HTML elements is removed."
    },
    {
        "uris": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[Element]aboveOnStack(Element)",
        "name": "aboveOnStack",
        "arg_nums": 1,
        "params": [
            {
                "name": "el",
                "type": "Element"
            }
        ],
        "return_type": "Element",
        "signature": "@Nullable Element aboveOnStack(Element el)",
        "original_string": "    @Nullable Element aboveOnStack(Element el) {\n        assert onStack(el);\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            if (next == el) {\n                return stack.get(pos-1);\n            }\n        }\n        return null;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "class_name": "HtmlTreeBuilder",
        "class_uri": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder",
        "attributes": {
            "modifiers": "@Nullable",
            "marker_annotations": [
                "@Nullable"
            ],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "Element",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[void]insertOnStackAfter(Element,Element)",
        "name": "insertOnStackAfter",
        "arg_nums": 2,
        "params": [
            {
                "name": "after",
                "type": "Element"
            },
            {
                "name": "in",
                "type": "Element"
            }
        ],
        "return_type": "void",
        "signature": "void insertOnStackAfter(Element after, Element in)",
        "original_string": "    void insertOnStackAfter(Element after, Element in) {\n        int i = stack.lastIndexOf(after);\n        Validate.isTrue(i != -1);\n        stack.add(i+1, in);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "class_name": "HtmlTreeBuilder",
        "class_uri": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[void]replaceOnStack(Element,Element)",
        "name": "replaceOnStack",
        "arg_nums": 2,
        "params": [
            {
                "name": "out",
                "type": "Element"
            },
            {
                "name": "in",
                "type": "Element"
            }
        ],
        "return_type": "void",
        "signature": "void replaceOnStack(Element out, Element in)",
        "original_string": "    void replaceOnStack(Element out, Element in) {\n        replaceInQueue(stack, out, in);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "class_name": "HtmlTreeBuilder",
        "class_uri": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[void]replaceInQueue(ArrayList<Element>,Element,Element)",
        "name": "replaceInQueue",
        "arg_nums": 3,
        "params": [
            {
                "name": "queue",
                "type": "ArrayList<Element>"
            },
            {
                "name": "out",
                "type": "Element"
            },
            {
                "name": "in",
                "type": "Element"
            }
        ],
        "return_type": "void",
        "signature": "private static void replaceInQueue(ArrayList<Element> queue, Element out, Element in)",
        "original_string": "    private static void replaceInQueue(ArrayList<Element> queue, Element out, Element in) {\n        int i = queue.lastIndexOf(out);\n        Validate.isTrue(i != -1);\n        queue.set(i, in);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "class_name": "HtmlTreeBuilder",
        "class_uri": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder",
        "attributes": {
            "modifiers": "private static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "private",
                "static"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[boolean]resetInsertionMode()",
        "name": "resetInsertionMode",
        "arg_nums": 0,
        "params": [],
        "return_type": "boolean",
        "signature": "boolean resetInsertionMode()",
        "original_string": "    boolean resetInsertionMode() {\n        // https://html.spec.whatwg.org/multipage/parsing.html#the-insertion-mode\n        boolean last = false;\n        final int bottom = stack.size() - 1;\n        final int upper = bottom >= maxQueueDepth ? bottom - maxQueueDepth : 0;\n        final HtmlTreeBuilderState origState = this.state;\n\n        if (stack.size() == 0) { // nothing left of stack, just get to body\n            transition(HtmlTreeBuilderState.InBody);\n        }\n\n        LOOP: for (int pos = bottom; pos >= upper; pos--) {\n            Element node = stack.get(pos);\n            if (pos == upper) {\n                last = true;\n                if (fragmentParsing)\n                    node = contextElement;\n            }\n            String name = node != null ? node.normalName() : \"\";\n            if (!NamespaceHtml.equals(node.tag().namespace()))\n                continue; // only looking for HTML elements here\n\n            switch (name) {\n                case \"select\":\n                    transition(HtmlTreeBuilderState.InSelect);\n                    // todo - should loop up (with some limit) and check for table or template hits\n                    break LOOP;\n                case \"td\":\n                case \"th\":\n                    if (!last) {\n                        transition(HtmlTreeBuilderState.InCell);\n                        break LOOP;\n                    }\n                    break;\n                case \"tr\":\n                    transition(HtmlTreeBuilderState.InRow);\n                    break LOOP;\n                case \"tbody\":\n                case \"thead\":\n                case \"tfoot\":\n                    transition(HtmlTreeBuilderState.InTableBody);\n                    break LOOP;\n                case \"caption\":\n                    transition(HtmlTreeBuilderState.InCaption);\n                    break LOOP;\n                case \"colgroup\":\n                    transition(HtmlTreeBuilderState.InColumnGroup);\n                    break LOOP;\n                case \"table\":\n                    transition(HtmlTreeBuilderState.InTable);\n                    break LOOP;\n                case \"template\":\n                    HtmlTreeBuilderState tmplState = currentTemplateMode();\n                    Validate.notNull(tmplState, \"Bug: no template insertion mode on stack!\");\n                    transition(tmplState);\n                    break LOOP;\n                case \"head\":\n                    if (!last) {\n                        transition(HtmlTreeBuilderState.InHead);\n                        break LOOP;\n                    }\n                    break;\n                case \"body\":\n                    transition(HtmlTreeBuilderState.InBody);\n                    break LOOP;\n                case \"frameset\":\n                    transition(HtmlTreeBuilderState.InFrameset);\n                    break LOOP;\n                case \"html\":\n                    transition(headElement == null ? HtmlTreeBuilderState.BeforeHead : HtmlTreeBuilderState.AfterHead);\n                    break LOOP;\n            }\n            if (last) {\n                transition(HtmlTreeBuilderState.InBody);\n                break;\n            }\n        }\n        return state != origState;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "class_name": "HtmlTreeBuilder",
        "class_uri": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": "\nReset the insertion mode, by searching up the stack for an appropriate insertion mode. The stack search depth\nis limited to {@link #maxQueueDepth}.\n@return true if the insertion mode was actually changed.\n"
    },
    {
        "uris": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[void]resetBody()",
        "name": "resetBody",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "void resetBody()",
        "original_string": "    void resetBody() {\n        if (!onStack(\"body\")) {\n            stack.add(doc.body()); // not onNodeInserted, as already seen\n        }\n        transition(HtmlTreeBuilderState.InBody);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "class_name": "HtmlTreeBuilder",
        "class_uri": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": " Places the body back onto the stack and moves to InBody, for cases in AfterBody / AfterAfterBody when more content comes"
    },
    {
        "uris": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[boolean]inSpecificScope(String,String[],String[])",
        "name": "inSpecificScope",
        "arg_nums": 3,
        "params": [
            {
                "name": "targetName",
                "type": "String"
            },
            {
                "name": "baseTypes",
                "type": "String[]"
            },
            {
                "name": "extraTypes",
                "type": "String[]"
            }
        ],
        "return_type": "boolean",
        "signature": "private boolean inSpecificScope(String targetName, String[] baseTypes, String[] extraTypes)",
        "original_string": "    private boolean inSpecificScope(String targetName, String[] baseTypes, String[] extraTypes) {\n        specificScopeTarget[0] = targetName;\n        return inSpecificScope(specificScopeTarget, baseTypes, extraTypes);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "class_name": "HtmlTreeBuilder",
        "class_uri": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder",
        "attributes": {
            "modifiers": "private",
            "marker_annotations": [],
            "non_marker_annotations": [
                "private"
            ],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[boolean]inSpecificScope(String[],String[],String[])",
        "name": "inSpecificScope",
        "arg_nums": 3,
        "params": [
            {
                "name": "targetNames",
                "type": "String[]"
            },
            {
                "name": "baseTypes",
                "type": "String[]"
            },
            {
                "name": "extraTypes",
                "type": "String[]"
            }
        ],
        "return_type": "boolean",
        "signature": "private boolean inSpecificScope(String[] targetNames, String[] baseTypes, @Nullable String[] extraTypes)",
        "original_string": "    private boolean inSpecificScope(String[] targetNames, String[] baseTypes, @Nullable String[] extraTypes) {\n        // https://html.spec.whatwg.org/multipage/parsing.html#has-an-element-in-the-specific-scope\n        final int bottom = stack.size() -1;\n        final int top = bottom > MaxScopeSearchDepth ? bottom - MaxScopeSearchDepth : 0;\n        // don't walk too far up the tree\n\n        for (int pos = bottom; pos >= top; pos--) {\n            Element el = stack.get(pos);\n            if (!el.tag().namespace().equals(NamespaceHtml)) continue;\n\n            final String elName = el.normalName();\n            if (inSorted(elName, targetNames))\n                return true;\n            if (inSorted(elName, baseTypes))\n                return false;\n            if (extraTypes != null && inSorted(elName, extraTypes))\n                return false;\n        }\n        //Validate.fail(\"Should not be reachable\"); // would end up false because hitting 'html' at root (basetypes)\n        return false;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "class_name": "HtmlTreeBuilder",
        "class_uri": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder",
        "attributes": {
            "modifiers": "private",
            "marker_annotations": [],
            "non_marker_annotations": [
                "private"
            ],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[boolean]inScope(String[])",
        "name": "inScope",
        "arg_nums": 1,
        "params": [
            {
                "name": "targetNames",
                "type": "String[]"
            }
        ],
        "return_type": "boolean",
        "signature": "boolean inScope(String[] targetNames)",
        "original_string": "    boolean inScope(String[] targetNames) {\n        return inSpecificScope(targetNames, TagsSearchInScope, null);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "class_name": "HtmlTreeBuilder",
        "class_uri": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[boolean]inScope(String)",
        "name": "inScope",
        "arg_nums": 1,
        "params": [
            {
                "name": "targetName",
                "type": "String"
            }
        ],
        "return_type": "boolean",
        "signature": "boolean inScope(String targetName)",
        "original_string": "    boolean inScope(String targetName) {\n        return inScope(targetName, null);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "class_name": "HtmlTreeBuilder",
        "class_uri": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[boolean]inScope(String,String[])",
        "name": "inScope",
        "arg_nums": 2,
        "params": [
            {
                "name": "targetName",
                "type": "String"
            },
            {
                "name": "extras",
                "type": "String[]"
            }
        ],
        "return_type": "boolean",
        "signature": "boolean inScope(String targetName, String[] extras)",
        "original_string": "    boolean inScope(String targetName, String[] extras) {\n        return inSpecificScope(targetName, TagsSearchInScope, extras);\n        // todo: in mathml namespace: mi, mo, mn, ms, mtext annotation-xml\n        // todo: in svg namespace: forignOjbect, desc, title\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "class_name": "HtmlTreeBuilder",
        "class_uri": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[boolean]inListItemScope(String)",
        "name": "inListItemScope",
        "arg_nums": 1,
        "params": [
            {
                "name": "targetName",
                "type": "String"
            }
        ],
        "return_type": "boolean",
        "signature": "boolean inListItemScope(String targetName)",
        "original_string": "    boolean inListItemScope(String targetName) {\n        return inScope(targetName, TagSearchList);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "class_name": "HtmlTreeBuilder",
        "class_uri": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[boolean]inButtonScope(String)",
        "name": "inButtonScope",
        "arg_nums": 1,
        "params": [
            {
                "name": "targetName",
                "type": "String"
            }
        ],
        "return_type": "boolean",
        "signature": "boolean inButtonScope(String targetName)",
        "original_string": "    boolean inButtonScope(String targetName) {\n        return inScope(targetName, TagSearchButton);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "class_name": "HtmlTreeBuilder",
        "class_uri": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[boolean]inTableScope(String)",
        "name": "inTableScope",
        "arg_nums": 1,
        "params": [
            {
                "name": "targetName",
                "type": "String"
            }
        ],
        "return_type": "boolean",
        "signature": "boolean inTableScope(String targetName)",
        "original_string": "    boolean inTableScope(String targetName) {\n        return inSpecificScope(targetName, TagSearchTableScope, null);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "class_name": "HtmlTreeBuilder",
        "class_uri": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[boolean]inSelectScope(String)",
        "name": "inSelectScope",
        "arg_nums": 1,
        "params": [
            {
                "name": "targetName",
                "type": "String"
            }
        ],
        "return_type": "boolean",
        "signature": "boolean inSelectScope(String targetName)",
        "original_string": "    boolean inSelectScope(String targetName) {\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element el = stack.get(pos);\n            String elName = el.normalName();\n            if (elName.equals(targetName))\n                return true;\n            if (!inSorted(elName, TagSearchSelectScope)) // all elements except\n                return false;\n        }\n        Validate.fail(\"Should not be reachable\");\n        return false;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "class_name": "HtmlTreeBuilder",
        "class_uri": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[boolean]onStackNot(String[])",
        "name": "onStackNot",
        "arg_nums": 1,
        "params": [
            {
                "name": "allowedTags",
                "type": "String[]"
            }
        ],
        "return_type": "boolean",
        "signature": "boolean onStackNot(String[] allowedTags)",
        "original_string": "    boolean onStackNot(String[] allowedTags) {\n        final int bottom = stack.size() -1;\n        final int top = bottom > MaxScopeSearchDepth ? bottom - MaxScopeSearchDepth : 0;\n        // don't walk too far up the tree\n\n        for (int pos = bottom; pos >= top; pos--) {\n            final String elName = stack.get(pos).normalName();\n            if (!inSorted(elName, allowedTags))\n                return true;\n        }\n        return false;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "class_name": "HtmlTreeBuilder",
        "class_uri": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": " Tests if there is some element on the stack that is not in the provided set."
    },
    {
        "uris": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[void]setHeadElement(Element)",
        "name": "setHeadElement",
        "arg_nums": 1,
        "params": [
            {
                "name": "headElement",
                "type": "Element"
            }
        ],
        "return_type": "void",
        "signature": "void setHeadElement(Element headElement)",
        "original_string": "    void setHeadElement(Element headElement) {\n        this.headElement = headElement;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "class_name": "HtmlTreeBuilder",
        "class_uri": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[Element]getHeadElement()",
        "name": "getHeadElement",
        "arg_nums": 0,
        "params": [],
        "return_type": "Element",
        "signature": "Element getHeadElement()",
        "original_string": "    Element getHeadElement() {\n        return headElement;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "class_name": "HtmlTreeBuilder",
        "class_uri": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "Element",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[boolean]isFosterInserts()",
        "name": "isFosterInserts",
        "arg_nums": 0,
        "params": [],
        "return_type": "boolean",
        "signature": "boolean isFosterInserts()",
        "original_string": "    boolean isFosterInserts() {\n        return fosterInserts;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "class_name": "HtmlTreeBuilder",
        "class_uri": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[void]setFosterInserts(boolean)",
        "name": "setFosterInserts",
        "arg_nums": 1,
        "params": [
            {
                "name": "fosterInserts",
                "type": "boolean"
            }
        ],
        "return_type": "void",
        "signature": "void setFosterInserts(boolean fosterInserts)",
        "original_string": "    void setFosterInserts(boolean fosterInserts) {\n        this.fosterInserts = fosterInserts;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "class_name": "HtmlTreeBuilder",
        "class_uri": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[FormElement]getFormElement()",
        "name": "getFormElement",
        "arg_nums": 0,
        "params": [],
        "return_type": "FormElement",
        "signature": "@Nullable FormElement getFormElement()",
        "original_string": "    @Nullable FormElement getFormElement() {\n        return formElement;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "class_name": "HtmlTreeBuilder",
        "class_uri": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder",
        "attributes": {
            "modifiers": "@Nullable",
            "marker_annotations": [
                "@Nullable"
            ],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "FormElement",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[void]setFormElement(FormElement)",
        "name": "setFormElement",
        "arg_nums": 1,
        "params": [
            {
                "name": "formElement",
                "type": "FormElement"
            }
        ],
        "return_type": "void",
        "signature": "void setFormElement(FormElement formElement)",
        "original_string": "    void setFormElement(FormElement formElement) {\n        this.formElement = formElement;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "class_name": "HtmlTreeBuilder",
        "class_uri": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[void]resetPendingTableCharacters()",
        "name": "resetPendingTableCharacters",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "void resetPendingTableCharacters()",
        "original_string": "    void resetPendingTableCharacters() {\n        pendingTableCharacters.clear();\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "class_name": "HtmlTreeBuilder",
        "class_uri": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[List<Token.Character>]getPendingTableCharacters()",
        "name": "getPendingTableCharacters",
        "arg_nums": 0,
        "params": [],
        "return_type": "List<Token.Character>",
        "signature": "List<Token.Character> getPendingTableCharacters()",
        "original_string": "    List<Token.Character> getPendingTableCharacters() {\n        return pendingTableCharacters;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "class_name": "HtmlTreeBuilder",
        "class_uri": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "List<Token.Character>",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[void]addPendingTableCharacters(Token.Character)",
        "name": "addPendingTableCharacters",
        "arg_nums": 1,
        "params": [
            {
                "name": "c",
                "type": "Token.Character"
            }
        ],
        "return_type": "void",
        "signature": "void addPendingTableCharacters(Token.Character c)",
        "original_string": "    void addPendingTableCharacters(Token.Character c) {\n        // make a clone of the token to maintain its state (as Tokens are otherwise reset)\n        Token.Character clone = c.clone();\n        pendingTableCharacters.add(clone);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "class_name": "HtmlTreeBuilder",
        "class_uri": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[void]generateImpliedEndTags(String)",
        "name": "generateImpliedEndTags",
        "arg_nums": 1,
        "params": [
            {
                "name": "excludeTag",
                "type": "String"
            }
        ],
        "return_type": "void",
        "signature": "void generateImpliedEndTags(String excludeTag)",
        "original_string": "    void generateImpliedEndTags(String excludeTag) {\n        while (inSorted(currentElement().normalName(), TagSearchEndTags)) {\n            if (excludeTag != null && currentElementIs(excludeTag))\n                break;\n            pop();\n        }\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "class_name": "HtmlTreeBuilder",
        "class_uri": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": "\n13.2.6.3 Closing elements that have implied end tags\nWhen the steps below require the UA to generate implied end tags, then, while the current node is a dd element, a dt element, an li element, an optgroup element, an option element, a p element, an rb element, an rp element, an rt element, or an rtc element, the UA must pop the current node off the stack of open elements.\n\nIf a step requires the UA to generate implied end tags but lists an element to exclude from the process, then the UA must perform the above steps as if that element was not in the above list.\n\nWhen the steps below require the UA to generate all implied end tags thoroughly, then, while the current node is a caption element, a colgroup element, a dd element, a dt element, an li element, an optgroup element, an option element, a p element, an rb element, an rp element, an rt element, an rtc element, a tbody element, a td element, a tfoot element, a th element, a thead element, or a tr element, the UA must pop the current node off the stack of open elements.\n\n@param excludeTag If a step requires the UA to generate implied end tags but lists an element to exclude from the\nprocess, then the UA must perform the above steps as if that element was not in the above list.\n"
    },
    {
        "uris": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[void]generateImpliedEndTags()",
        "name": "generateImpliedEndTags",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "void generateImpliedEndTags()",
        "original_string": "    void generateImpliedEndTags() {\n        generateImpliedEndTags(false);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "class_name": "HtmlTreeBuilder",
        "class_uri": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[void]generateImpliedEndTags(boolean)",
        "name": "generateImpliedEndTags",
        "arg_nums": 1,
        "params": [
            {
                "name": "thorough",
                "type": "boolean"
            }
        ],
        "return_type": "void",
        "signature": "void generateImpliedEndTags(boolean thorough)",
        "original_string": "    void generateImpliedEndTags(boolean thorough) {\n        final String[] search = thorough ? TagThoroughSearchEndTags : TagSearchEndTags;\n        while (NamespaceHtml.equals(currentElement().tag().namespace())\n            && inSorted(currentElement().normalName(), search)) {\n            pop();\n        }\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "class_name": "HtmlTreeBuilder",
        "class_uri": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": "\nPops HTML elements off the stack according to the implied end tag rules\n@param thorough if we are thorough (includes table elements etc) or not\n"
    },
    {
        "uris": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[void]closeElement(String)",
        "name": "closeElement",
        "arg_nums": 1,
        "params": [
            {
                "name": "name",
                "type": "String"
            }
        ],
        "return_type": "void",
        "signature": "void closeElement(String name)",
        "original_string": "    void closeElement(String name) {\n        generateImpliedEndTags(name);\n        if (!name.equals(currentElement().normalName())) error(state());\n        popStackToClose(name);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "class_name": "HtmlTreeBuilder",
        "class_uri": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[boolean]isSpecial(Element)",
        "name": "isSpecial",
        "arg_nums": 1,
        "params": [
            {
                "name": "el",
                "type": "Element"
            }
        ],
        "return_type": "boolean",
        "signature": "static boolean isSpecial(Element el)",
        "original_string": "    static boolean isSpecial(Element el) {\n        // todo: mathml's mi, mo, mn\n        // todo: svg's foreigObject, desc, title\n        String name = el.normalName();\n        return inSorted(name, TagSearchSpecial);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "class_name": "HtmlTreeBuilder",
        "class_uri": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder",
        "attributes": {
            "modifiers": "static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "static"
            ],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[Element]lastFormattingElement()",
        "name": "lastFormattingElement",
        "arg_nums": 0,
        "params": [],
        "return_type": "Element",
        "signature": "Element lastFormattingElement()",
        "original_string": "    Element lastFormattingElement() {\n        return formattingElements.size() > 0 ? formattingElements.get(formattingElements.size()-1) : null;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "class_name": "HtmlTreeBuilder",
        "class_uri": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "Element",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[int]positionOfElement(Element)",
        "name": "positionOfElement",
        "arg_nums": 1,
        "params": [
            {
                "name": "el",
                "type": "Element"
            }
        ],
        "return_type": "int",
        "signature": "int positionOfElement(Element el)",
        "original_string": "    int positionOfElement(Element el){\n        for (int i = 0; i < formattingElements.size(); i++){\n            if (el == formattingElements.get(i))\n                return i;\n        }\n        return -1;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "class_name": "HtmlTreeBuilder",
        "class_uri": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "int",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[Element]removeLastFormattingElement()",
        "name": "removeLastFormattingElement",
        "arg_nums": 0,
        "params": [],
        "return_type": "Element",
        "signature": "Element removeLastFormattingElement()",
        "original_string": "    Element removeLastFormattingElement() {\n        int size = formattingElements.size();\n        if (size > 0)\n            return formattingElements.remove(size-1);\n        else\n            return null;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "class_name": "HtmlTreeBuilder",
        "class_uri": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "Element",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[void]pushActiveFormattingElements(Element)",
        "name": "pushActiveFormattingElements",
        "arg_nums": 1,
        "params": [
            {
                "name": "in",
                "type": "Element"
            }
        ],
        "return_type": "void",
        "signature": "void pushActiveFormattingElements(Element in)",
        "original_string": "    void pushActiveFormattingElements(Element in) {\n        checkActiveFormattingElements(in);\n        formattingElements.add(in);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "class_name": "HtmlTreeBuilder",
        "class_uri": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": " active formatting elements"
    },
    {
        "uris": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[void]pushWithBookmark(Element,int)",
        "name": "pushWithBookmark",
        "arg_nums": 2,
        "params": [
            {
                "name": "in",
                "type": "Element"
            },
            {
                "name": "bookmark",
                "type": "int"
            }
        ],
        "return_type": "void",
        "signature": "void pushWithBookmark(Element in, int bookmark)",
        "original_string": "    void pushWithBookmark(Element in, int bookmark){\n        checkActiveFormattingElements(in);\n        // catch any range errors and assume bookmark is incorrect - saves a redundant range check.\n        try {\n            formattingElements.add(bookmark, in);\n        } catch (IndexOutOfBoundsException e) {\n            formattingElements.add(in);\n        }\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "class_name": "HtmlTreeBuilder",
        "class_uri": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[void]checkActiveFormattingElements(Element)",
        "name": "checkActiveFormattingElements",
        "arg_nums": 1,
        "params": [
            {
                "name": "in",
                "type": "Element"
            }
        ],
        "return_type": "void",
        "signature": "void checkActiveFormattingElements(Element in)",
        "original_string": "    void checkActiveFormattingElements(Element in){\n        int numSeen = 0;\n        final int size = formattingElements.size() -1;\n        int ceil = size - maxUsedFormattingElements; if (ceil <0) ceil = 0;\n\n        for (int pos = size; pos >= ceil; pos--) {\n            Element el = formattingElements.get(pos);\n            if (el == null) // marker\n                break;\n\n            if (isSameFormattingElement(in, el))\n                numSeen++;\n\n            if (numSeen == 3) {\n                formattingElements.remove(pos);\n                break;\n            }\n        }\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "class_name": "HtmlTreeBuilder",
        "class_uri": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[boolean]isSameFormattingElement(Element,Element)",
        "name": "isSameFormattingElement",
        "arg_nums": 2,
        "params": [
            {
                "name": "a",
                "type": "Element"
            },
            {
                "name": "b",
                "type": "Element"
            }
        ],
        "return_type": "boolean",
        "signature": "private static boolean isSameFormattingElement(Element a, Element b)",
        "original_string": "    private static boolean isSameFormattingElement(Element a, Element b) {\n        // same if: same namespace, tag, and attributes. Element.equals only checks tag, might in future check children\n        return a.normalName().equals(b.normalName()) &&\n                // a.namespace().equals(b.namespace()) &&\n                a.attributes().equals(b.attributes());\n        // todo: namespaces\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "class_name": "HtmlTreeBuilder",
        "class_uri": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder",
        "attributes": {
            "modifiers": "private static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "private",
                "static"
            ],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[void]reconstructFormattingElements()",
        "name": "reconstructFormattingElements",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "void reconstructFormattingElements()",
        "original_string": "    void reconstructFormattingElements() {\n        if (stack.size() > maxQueueDepth)\n            return;\n        Element last = lastFormattingElement();\n        if (last == null || onStack(last))\n            return;\n\n        Element entry = last;\n        int size = formattingElements.size();\n        int ceil = size - maxUsedFormattingElements; if (ceil <0) ceil = 0;\n        int pos = size - 1;\n        boolean skip = false;\n        while (true) {\n            if (pos == ceil) { // step 4. if none before, skip to 8\n                skip = true;\n                break;\n            }\n            entry = formattingElements.get(--pos); // step 5. one earlier than entry\n            if (entry == null || onStack(entry)) // step 6 - neither marker nor on stack\n                break; // jump to 8, else continue back to 4\n        }\n        while(true) {\n            if (!skip) // step 7: on later than entry\n                entry = formattingElements.get(++pos);\n            Validate.notNull(entry); // should not occur, as we break at last element\n\n            // 8. create new element from element, 9 insert into current node, onto stack\n            skip = false; // can only skip increment from 4.\n            Element newEl = new Element(tagFor(entry.normalName(), settings), null, entry.attributes().clone());\n            doInsertElement(newEl, null);\n\n            // 10. replace entry with new entry\n            formattingElements.set(pos, newEl);\n\n            // 11\n            if (pos == size-1) // if not last entry in list, jump to 7\n                break;\n        }\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "class_name": "HtmlTreeBuilder",
        "class_uri": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[void]clearFormattingElementsToLastMarker()",
        "name": "clearFormattingElementsToLastMarker",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "void clearFormattingElementsToLastMarker()",
        "original_string": "    void clearFormattingElementsToLastMarker() {\n        while (!formattingElements.isEmpty()) {\n            Element el = removeLastFormattingElement();\n            if (el == null)\n                break;\n        }\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "class_name": "HtmlTreeBuilder",
        "class_uri": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": " limit how many elements get recreated"
    },
    {
        "uris": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[void]removeFromActiveFormattingElements(Element)",
        "name": "removeFromActiveFormattingElements",
        "arg_nums": 1,
        "params": [
            {
                "name": "el",
                "type": "Element"
            }
        ],
        "return_type": "void",
        "signature": "void removeFromActiveFormattingElements(Element el)",
        "original_string": "    void removeFromActiveFormattingElements(Element el) {\n        for (int pos = formattingElements.size() -1; pos >= 0; pos--) {\n            Element next = formattingElements.get(pos);\n            if (next == el) {\n                formattingElements.remove(pos);\n                break;\n            }\n        }\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "class_name": "HtmlTreeBuilder",
        "class_uri": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[boolean]isInActiveFormattingElements(Element)",
        "name": "isInActiveFormattingElements",
        "arg_nums": 1,
        "params": [
            {
                "name": "el",
                "type": "Element"
            }
        ],
        "return_type": "boolean",
        "signature": "boolean isInActiveFormattingElements(Element el)",
        "original_string": "    boolean isInActiveFormattingElements(Element el) {\n        return onStack(formattingElements, el);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "class_name": "HtmlTreeBuilder",
        "class_uri": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[Element]getActiveFormattingElement(String)",
        "name": "getActiveFormattingElement",
        "arg_nums": 1,
        "params": [
            {
                "name": "nodeName",
                "type": "String"
            }
        ],
        "return_type": "Element",
        "signature": "@Nullable\n    Element getActiveFormattingElement(String nodeName)",
        "original_string": "    @Nullable\n    Element getActiveFormattingElement(String nodeName) {\n        for (int pos = formattingElements.size() -1; pos >= 0; pos--) {\n            Element next = formattingElements.get(pos);\n            if (next == null) // scope marker\n                break;\n            else if (next.nameIs(nodeName))\n                return next;\n        }\n        return null;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "class_name": "HtmlTreeBuilder",
        "class_uri": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder",
        "attributes": {
            "modifiers": "@Nullable",
            "marker_annotations": [
                "@Nullable"
            ],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "Element",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[void]replaceActiveFormattingElement(Element,Element)",
        "name": "replaceActiveFormattingElement",
        "arg_nums": 2,
        "params": [
            {
                "name": "out",
                "type": "Element"
            },
            {
                "name": "in",
                "type": "Element"
            }
        ],
        "return_type": "void",
        "signature": "void replaceActiveFormattingElement(Element out, Element in)",
        "original_string": "    void replaceActiveFormattingElement(Element out, Element in) {\n        replaceInQueue(formattingElements, out, in);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "class_name": "HtmlTreeBuilder",
        "class_uri": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[void]insertMarkerToFormattingElements()",
        "name": "insertMarkerToFormattingElements",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "void insertMarkerToFormattingElements()",
        "original_string": "    void insertMarkerToFormattingElements() {\n        formattingElements.add(null);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "class_name": "HtmlTreeBuilder",
        "class_uri": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[void]insertInFosterParent(Node)",
        "name": "insertInFosterParent",
        "arg_nums": 1,
        "params": [
            {
                "name": "in",
                "type": "Node"
            }
        ],
        "return_type": "void",
        "signature": "void insertInFosterParent(Node in)",
        "original_string": "    void insertInFosterParent(Node in) {\n        Element fosterParent;\n        Element lastTable = getFromStack(\"table\");\n        boolean isLastTableParent = false;\n        if (lastTable != null) {\n            if (lastTable.parent() != null) {\n                fosterParent = lastTable.parent();\n                isLastTableParent = true;\n            } else\n                fosterParent = aboveOnStack(lastTable);\n        } else { // no table == frag\n            fosterParent = stack.get(0);\n        }\n\n        if (isLastTableParent) {\n            Validate.notNull(lastTable); // last table cannot be null by this point.\n            lastTable.before(in);\n        }\n        else\n            fosterParent.appendChild(in);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "class_name": "HtmlTreeBuilder",
        "class_uri": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[void]pushTemplateMode(HtmlTreeBuilderState)",
        "name": "pushTemplateMode",
        "arg_nums": 1,
        "params": [
            {
                "name": "state",
                "type": "HtmlTreeBuilderState"
            }
        ],
        "return_type": "void",
        "signature": "void pushTemplateMode(HtmlTreeBuilderState state)",
        "original_string": "    void pushTemplateMode(HtmlTreeBuilderState state) {\n        tmplInsertMode.add(state);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "class_name": "HtmlTreeBuilder",
        "class_uri": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": " Template Insertion Mode stack"
    },
    {
        "uris": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[HtmlTreeBuilderState]popTemplateMode()",
        "name": "popTemplateMode",
        "arg_nums": 0,
        "params": [],
        "return_type": "HtmlTreeBuilderState",
        "signature": "@Nullable HtmlTreeBuilderState popTemplateMode()",
        "original_string": "    @Nullable HtmlTreeBuilderState popTemplateMode() {\n        if (tmplInsertMode.size() > 0) {\n            return tmplInsertMode.remove(tmplInsertMode.size() -1);\n        } else {\n            return null;\n        }\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "class_name": "HtmlTreeBuilder",
        "class_uri": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder",
        "attributes": {
            "modifiers": "@Nullable",
            "marker_annotations": [
                "@Nullable"
            ],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "HtmlTreeBuilderState",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[int]templateModeSize()",
        "name": "templateModeSize",
        "arg_nums": 0,
        "params": [],
        "return_type": "int",
        "signature": "int templateModeSize()",
        "original_string": "    int templateModeSize() {\n        return tmplInsertMode.size();\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "class_name": "HtmlTreeBuilder",
        "class_uri": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "int",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[HtmlTreeBuilderState]currentTemplateMode()",
        "name": "currentTemplateMode",
        "arg_nums": 0,
        "params": [],
        "return_type": "HtmlTreeBuilderState",
        "signature": "@Nullable HtmlTreeBuilderState currentTemplateMode()",
        "original_string": "    @Nullable HtmlTreeBuilderState currentTemplateMode() {\n        return (tmplInsertMode.size() > 0) ? tmplInsertMode.get(tmplInsertMode.size() -1)  : null;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "class_name": "HtmlTreeBuilder",
        "class_uri": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder",
        "attributes": {
            "modifiers": "@Nullable",
            "marker_annotations": [
                "@Nullable"
            ],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "HtmlTreeBuilderState",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[String]toString()",
        "name": "toString",
        "arg_nums": 0,
        "params": [],
        "return_type": "String",
        "signature": "@Override\n    public String toString()",
        "original_string": "    @Override\n    public String toString() {\n        return \"TreeBuilder{\" +\n                \"currentToken=\" + currentToken +\n                \", state=\" + state +\n                \", currentElement=\" + currentElement() +\n                '}';\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "class_name": "HtmlTreeBuilder",
        "class_uri": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder",
        "attributes": {
            "modifiers": "@Override\n    public",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[boolean]isContentForTagData(String)",
        "name": "isContentForTagData",
        "arg_nums": 1,
        "params": [
            {
                "name": "normalName",
                "type": "String"
            }
        ],
        "return_type": "boolean",
        "signature": "@Override protected boolean isContentForTagData(final String normalName)",
        "original_string": "    @Override protected boolean isContentForTagData(final String normalName) {\n        return (normalName.equals(\"script\") || normalName.equals(\"style\"));\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "class_name": "HtmlTreeBuilder",
        "class_uri": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder",
        "attributes": {
            "modifiers": "@Override protected",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "protected"
            ],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/safety/Safelist.java.Safelist.[Safelist]none()",
        "name": "none",
        "arg_nums": 0,
        "params": [],
        "return_type": "Safelist",
        "signature": "public static Safelist none()",
        "original_string": "    public static Safelist none() {\n        return new Safelist();\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/safety/Safelist.java",
        "class_name": "Safelist",
        "class_uri": "src/main/java/org/jsoup/safety/Safelist.java.Safelist",
        "attributes": {
            "modifiers": "public static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public",
                "static"
            ],
            "comments": [],
            "return_type": "Safelist",
            "classes": []
        },
        "docstring": "\nThis safelist allows only text nodes: any HTML Element or any Node other than a TextNode will be removed.\n<p>\nNote that the output of {@link org.jsoup.Jsoup#clean(String, Safelist)} is still <b>HTML</b> even when using\nthis Safelist, and so any HTML entities in the output will be appropriately escaped. If you want plain text, not\nHTML, you should use a text method such as {@link Element#text()} instead, after cleaning the document.\n</p>\n<p>Example:</p>\n<pre>{@code\nString sourceBodyHtml = \"<p>5 is &lt; 6.</p>\";\nString html = Jsoup.clean(sourceBodyHtml, Safelist.none());\n\nCleaner cleaner = new Cleaner(Safelist.none());\nString text = cleaner.clean(Jsoup.parse(sourceBodyHtml)).text();\n\n html is: 5 is &lt; 6.\n text is: 5 is < 6.\n}</pre>\n\n@return safelist\n"
    },
    {
        "uris": "src/main/java/org/jsoup/safety/Safelist.java.Safelist.[Safelist]simpleText()",
        "name": "simpleText",
        "arg_nums": 0,
        "params": [],
        "return_type": "Safelist",
        "signature": "public static Safelist simpleText()",
        "original_string": "    public static Safelist simpleText() {\n        return new Safelist()\n                .addTags(\"b\", \"em\", \"i\", \"strong\", \"u\")\n                ;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/safety/Safelist.java",
        "class_name": "Safelist",
        "class_uri": "src/main/java/org/jsoup/safety/Safelist.java.Safelist",
        "attributes": {
            "modifiers": "public static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public",
                "static"
            ],
            "comments": [],
            "return_type": "Safelist",
            "classes": []
        },
        "docstring": "\nThis safelist allows only simple text formatting: <code>b, em, i, strong, u</code>. All other HTML (tags and\nattributes) will be removed.\n\n@return safelist\n"
    },
    {
        "uris": "src/main/java/org/jsoup/safety/Safelist.java.Safelist.[Safelist]basic()",
        "name": "basic",
        "arg_nums": 0,
        "params": [],
        "return_type": "Safelist",
        "signature": "public static Safelist basic()",
        "original_string": "    public static Safelist basic() {\n        return new Safelist()\n                .addTags(\n                        \"a\", \"b\", \"blockquote\", \"br\", \"cite\", \"code\", \"dd\", \"dl\", \"dt\", \"em\",\n                        \"i\", \"li\", \"ol\", \"p\", \"pre\", \"q\", \"small\", \"span\", \"strike\", \"strong\", \"sub\",\n                        \"sup\", \"u\", \"ul\")\n\n                .addAttributes(\"a\", \"href\")\n                .addAttributes(\"blockquote\", \"cite\")\n                .addAttributes(\"q\", \"cite\")\n\n                .addProtocols(\"a\", \"href\", \"ftp\", \"http\", \"https\", \"mailto\")\n                .addProtocols(\"blockquote\", \"cite\", \"http\", \"https\")\n                .addProtocols(\"cite\", \"cite\", \"http\", \"https\")\n\n                .addEnforcedAttribute(\"a\", \"rel\", \"nofollow\")\n                ;\n\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/safety/Safelist.java",
        "class_name": "Safelist",
        "class_uri": "src/main/java/org/jsoup/safety/Safelist.java.Safelist",
        "attributes": {
            "modifiers": "public static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public",
                "static"
            ],
            "comments": [],
            "return_type": "Safelist",
            "classes": []
        },
        "docstring": "\n<p>\nThis safelist allows a fuller range of text nodes: <code>a, b, blockquote, br, cite, code, dd, dl, dt, em, i, li,\nol, p, pre, q, small, span, strike, strong, sub, sup, u, ul</code>, and appropriate attributes.\n</p>\n<p>\nLinks (<code>a</code> elements) can point to <code>http, https, ftp, mailto</code>, and have an enforced\n<code>rel=nofollow</code> attribute.\n</p>\n<p>\nDoes not allow images.\n</p>\n\n@return safelist\n"
    },
    {
        "uris": "src/main/java/org/jsoup/safety/Safelist.java.Safelist.[Safelist]basicWithImages()",
        "name": "basicWithImages",
        "arg_nums": 0,
        "params": [],
        "return_type": "Safelist",
        "signature": "public static Safelist basicWithImages()",
        "original_string": "    public static Safelist basicWithImages() {\n        return basic()\n                .addTags(\"img\")\n                .addAttributes(\"img\", \"align\", \"alt\", \"height\", \"src\", \"title\", \"width\")\n                .addProtocols(\"img\", \"src\", \"http\", \"https\")\n                ;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/safety/Safelist.java",
        "class_name": "Safelist",
        "class_uri": "src/main/java/org/jsoup/safety/Safelist.java.Safelist",
        "attributes": {
            "modifiers": "public static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public",
                "static"
            ],
            "comments": [],
            "return_type": "Safelist",
            "classes": []
        },
        "docstring": "\nThis safelist allows the same text tags as {@link #basic}, and also allows <code>img</code> tags, with appropriate\nattributes, with <code>src</code> pointing to <code>http</code> or <code>https</code>.\n\n@return safelist\n"
    },
    {
        "uris": "src/main/java/org/jsoup/safety/Safelist.java.Safelist.[Safelist]relaxed()",
        "name": "relaxed",
        "arg_nums": 0,
        "params": [],
        "return_type": "Safelist",
        "signature": "public static Safelist relaxed()",
        "original_string": "    public static Safelist relaxed() {\n        return new Safelist()\n                .addTags(\n                        \"a\", \"b\", \"blockquote\", \"br\", \"caption\", \"cite\", \"code\", \"col\",\n                        \"colgroup\", \"dd\", \"div\", \"dl\", \"dt\", \"em\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\",\n                        \"i\", \"img\", \"li\", \"ol\", \"p\", \"pre\", \"q\", \"small\", \"span\", \"strike\", \"strong\",\n                        \"sub\", \"sup\", \"table\", \"tbody\", \"td\", \"tfoot\", \"th\", \"thead\", \"tr\", \"u\",\n                        \"ul\")\n\n                .addAttributes(\"a\", \"href\", \"title\")\n                .addAttributes(\"blockquote\", \"cite\")\n                .addAttributes(\"col\", \"span\", \"width\")\n                .addAttributes(\"colgroup\", \"span\", \"width\")\n                .addAttributes(\"img\", \"align\", \"alt\", \"height\", \"src\", \"title\", \"width\")\n                .addAttributes(\"ol\", \"start\", \"type\")\n                .addAttributes(\"q\", \"cite\")\n                .addAttributes(\"table\", \"summary\", \"width\")\n                .addAttributes(\"td\", \"abbr\", \"axis\", \"colspan\", \"rowspan\", \"width\")\n                .addAttributes(\n                        \"th\", \"abbr\", \"axis\", \"colspan\", \"rowspan\", \"scope\",\n                        \"width\")\n                .addAttributes(\"ul\", \"type\")\n\n                .addProtocols(\"a\", \"href\", \"ftp\", \"http\", \"https\", \"mailto\")\n                .addProtocols(\"blockquote\", \"cite\", \"http\", \"https\")\n                .addProtocols(\"cite\", \"cite\", \"http\", \"https\")\n                .addProtocols(\"img\", \"src\", \"http\", \"https\")\n                .addProtocols(\"q\", \"cite\", \"http\", \"https\")\n                ;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/safety/Safelist.java",
        "class_name": "Safelist",
        "class_uri": "src/main/java/org/jsoup/safety/Safelist.java.Safelist",
        "attributes": {
            "modifiers": "public static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public",
                "static"
            ],
            "comments": [],
            "return_type": "Safelist",
            "classes": []
        },
        "docstring": "\nThis safelist allows a full range of text and structural body HTML: <code>a, b, blockquote, br, caption, cite,\ncode, col, colgroup, dd, div, dl, dt, em, h1, h2, h3, h4, h5, h6, i, img, li, ol, p, pre, q, small, span, strike, strong, sub,\nsup, table, tbody, td, tfoot, th, thead, tr, u, ul</code>\n<p>\nLinks do not have an enforced <code>rel=nofollow</code> attribute, but you can add that if desired.\n</p>\n\n@return safelist\n"
    },
    {
        "uris": "src/main/java/org/jsoup/safety/Safelist.java.Safelist.[]Safelist()",
        "name": "Safelist",
        "arg_nums": 0,
        "params": [],
        "return_type": "",
        "signature": "public Safelist()",
        "original_string": "    public Safelist() {\n        tagNames = new HashSet<>();\n        attributes = new HashMap<>();\n        enforcedAttributes = new HashMap<>();\n        protocols = new HashMap<>();\n        preserveRelativeLinks = false;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/safety/Safelist.java",
        "class_name": "Safelist",
        "class_uri": "src/main/java/org/jsoup/safety/Safelist.java.Safelist",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "",
            "classes": []
        },
        "docstring": "\nCreate a new, empty safelist. Generally it will be better to start with a default prepared safelist instead.\n\n@see #basic()\n@see #basicWithImages()\n@see #simpleText()\n@see #relaxed()\n"
    },
    {
        "uris": "src/main/java/org/jsoup/safety/Safelist.java.Safelist.[]Safelist(Safelist)",
        "name": "Safelist",
        "arg_nums": 1,
        "params": [
            {
                "name": "copy",
                "type": "Safelist"
            }
        ],
        "return_type": "",
        "signature": "public Safelist(Safelist copy)",
        "original_string": "    public Safelist(Safelist copy) {\n        this();\n        tagNames.addAll(copy.tagNames);\n        for (Map.Entry<TagName, Set<AttributeKey>> copyTagAttributes : copy.attributes.entrySet()) {\n            attributes.put(copyTagAttributes.getKey(), new HashSet<>(copyTagAttributes.getValue()));\n        }\n        for (Map.Entry<TagName, Map<AttributeKey, AttributeValue>> enforcedEntry : copy.enforcedAttributes.entrySet()) {\n            enforcedAttributes.put(enforcedEntry.getKey(), new HashMap<>(enforcedEntry.getValue()));\n        }\n        for (Map.Entry<TagName, Map<AttributeKey, Set<Protocol>>> protocolsEntry : copy.protocols.entrySet()) {\n            Map<AttributeKey, Set<Protocol>> attributeProtocolsCopy = new HashMap<>();\n            for (Map.Entry<AttributeKey, Set<Protocol>> attributeProtocols : protocolsEntry.getValue().entrySet()) {\n                attributeProtocolsCopy.put(attributeProtocols.getKey(), new HashSet<>(attributeProtocols.getValue()));\n            }\n            protocols.put(protocolsEntry.getKey(), attributeProtocolsCopy);\n        }\n        preserveRelativeLinks = copy.preserveRelativeLinks;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/safety/Safelist.java",
        "class_name": "Safelist",
        "class_uri": "src/main/java/org/jsoup/safety/Safelist.java.Safelist",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "",
            "classes": []
        },
        "docstring": "\nDeep copy an existing Safelist to a new Safelist.\n@param copy the Safelist to copy\n"
    },
    {
        "uris": "src/main/java/org/jsoup/safety/Safelist.java.Safelist.[Safelist]addTags()",
        "name": "addTags",
        "arg_nums": 0,
        "params": [],
        "return_type": "Safelist",
        "signature": "public Safelist addTags(String... tags)",
        "original_string": "    public Safelist addTags(String... tags) {\n        Validate.notNull(tags);\n\n        for (String tagName : tags) {\n            Validate.notEmpty(tagName);\n            Validate.isFalse(tagName.equalsIgnoreCase(\"noscript\"),\n                \"noscript is unsupported in Safelists, due to incompatibilities between parsers with and without script-mode enabled\");\n            tagNames.add(TagName.valueOf(tagName));\n        }\n        return this;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/safety/Safelist.java",
        "class_name": "Safelist",
        "class_uri": "src/main/java/org/jsoup/safety/Safelist.java.Safelist",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Safelist",
            "classes": []
        },
        "docstring": "\nAdd a list of allowed elements to a safelist. (If a tag is not allowed, it will be removed from the HTML.)\n\n@param tags tag names to allow\n@return this (for chaining)\n"
    },
    {
        "uris": "src/main/java/org/jsoup/safety/Safelist.java.Safelist.[Safelist]removeTags()",
        "name": "removeTags",
        "arg_nums": 0,
        "params": [],
        "return_type": "Safelist",
        "signature": "public Safelist removeTags(String... tags)",
        "original_string": "    public Safelist removeTags(String... tags) {\n        Validate.notNull(tags);\n\n        for(String tag: tags) {\n            Validate.notEmpty(tag);\n            TagName tagName = TagName.valueOf(tag);\n\n            if(tagNames.remove(tagName)) { // Only look in sub-maps if tag was allowed\n                attributes.remove(tagName);\n                enforcedAttributes.remove(tagName);\n                protocols.remove(tagName);\n            }\n        }\n        return this;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/safety/Safelist.java",
        "class_name": "Safelist",
        "class_uri": "src/main/java/org/jsoup/safety/Safelist.java.Safelist",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Safelist",
            "classes": []
        },
        "docstring": "\nRemove a list of allowed elements from a safelist. (If a tag is not allowed, it will be removed from the HTML.)\n\n@param tags tag names to disallow\n@return this (for chaining)\n"
    },
    {
        "uris": "src/main/java/org/jsoup/safety/Safelist.java.Safelist.[Safelist]addAttributes(String)",
        "name": "addAttributes",
        "arg_nums": 1,
        "params": [
            {
                "name": "tag",
                "type": "String"
            }
        ],
        "return_type": "Safelist",
        "signature": "public Safelist addAttributes(String tag, String... attributes)",
        "original_string": "    public Safelist addAttributes(String tag, String... attributes) {\n        Validate.notEmpty(tag);\n        Validate.notNull(attributes);\n        Validate.isTrue(attributes.length > 0, \"No attribute names supplied.\");\n\n        addTags(tag);\n        TagName tagName = TagName.valueOf(tag);\n        Set<AttributeKey> attributeSet = new HashSet<>();\n        for (String key : attributes) {\n            Validate.notEmpty(key);\n            attributeSet.add(AttributeKey.valueOf(key));\n        }\n        Set<AttributeKey> currentSet = this.attributes.computeIfAbsent(tagName, Functions.setFunction());\n        currentSet.addAll(attributeSet);\n        return this;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/safety/Safelist.java",
        "class_name": "Safelist",
        "class_uri": "src/main/java/org/jsoup/safety/Safelist.java.Safelist",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Safelist",
            "classes": []
        },
        "docstring": "\nAdd a list of allowed attributes to a tag. (If an attribute is not allowed on an element, it will be removed.)\n<p>\nE.g.: <code>addAttributes(\"a\", \"href\", \"class\")</code> allows <code>href</code> and <code>class</code> attributes\non <code>a</code> tags.\n</p>\n<p>\nTo make an attribute valid for <b>all tags</b>, use the pseudo tag <code>:all</code>, e.g.\n<code>addAttributes(\":all\", \"class\")</code>.\n</p>\n\n@param tag  The tag the attributes are for. The tag will be added to the allowed tag list if necessary.\n@param attributes List of valid attributes for the tag\n@return this (for chaining)\n"
    },
    {
        "uris": "src/main/java/org/jsoup/safety/Safelist.java.Safelist.[Safelist]removeAttributes(String)",
        "name": "removeAttributes",
        "arg_nums": 1,
        "params": [
            {
                "name": "tag",
                "type": "String"
            }
        ],
        "return_type": "Safelist",
        "signature": "public Safelist removeAttributes(String tag, String... attributes)",
        "original_string": "    public Safelist removeAttributes(String tag, String... attributes) {\n        Validate.notEmpty(tag);\n        Validate.notNull(attributes);\n        Validate.isTrue(attributes.length > 0, \"No attribute names supplied.\");\n\n        TagName tagName = TagName.valueOf(tag);\n        Set<AttributeKey> attributeSet = new HashSet<>();\n        for (String key : attributes) {\n            Validate.notEmpty(key);\n            attributeSet.add(AttributeKey.valueOf(key));\n        }\n        if(tagNames.contains(tagName) && this.attributes.containsKey(tagName)) { // Only look in sub-maps if tag was allowed\n            Set<AttributeKey> currentSet = this.attributes.get(tagName);\n            currentSet.removeAll(attributeSet);\n\n            if(currentSet.isEmpty()) // Remove tag from attribute map if no attributes are allowed for tag\n                this.attributes.remove(tagName);\n        }\n        if(tag.equals(All)) { // Attribute needs to be removed from all individually set tags\n            Iterator<Map.Entry<TagName, Set<AttributeKey>>> it = this.attributes.entrySet().iterator();\n            while (it.hasNext()) {\n                Map.Entry<TagName, Set<AttributeKey>> entry = it.next();\n                Set<AttributeKey> currentSet = entry.getValue();\n                currentSet.removeAll(attributeSet);\n                if(currentSet.isEmpty()) // Remove tag from attribute map if no attributes are allowed for tag\n                    it.remove();\n            }\n        }\n        return this;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/safety/Safelist.java",
        "class_name": "Safelist",
        "class_uri": "src/main/java/org/jsoup/safety/Safelist.java.Safelist",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Safelist",
            "classes": []
        },
        "docstring": "\nRemove a list of allowed attributes from a tag. (If an attribute is not allowed on an element, it will be removed.)\n<p>\nE.g.: <code>removeAttributes(\"a\", \"href\", \"class\")</code> disallows <code>href</code> and <code>class</code>\nattributes on <code>a</code> tags.\n</p>\n<p>\nTo make an attribute invalid for <b>all tags</b>, use the pseudo tag <code>:all</code>, e.g.\n<code>removeAttributes(\":all\", \"class\")</code>.\n</p>\n\n@param tag  The tag the attributes are for.\n@param attributes List of invalid attributes for the tag\n@return this (for chaining)\n"
    },
    {
        "uris": "src/main/java/org/jsoup/safety/Safelist.java.Safelist.[Safelist]addEnforcedAttribute(String,String,String)",
        "name": "addEnforcedAttribute",
        "arg_nums": 3,
        "params": [
            {
                "name": "tag",
                "type": "String"
            },
            {
                "name": "attribute",
                "type": "String"
            },
            {
                "name": "value",
                "type": "String"
            }
        ],
        "return_type": "Safelist",
        "signature": "public Safelist addEnforcedAttribute(String tag, String attribute, String value)",
        "original_string": "    public Safelist addEnforcedAttribute(String tag, String attribute, String value) {\n        Validate.notEmpty(tag);\n        Validate.notEmpty(attribute);\n        Validate.notEmpty(value);\n\n        TagName tagName = TagName.valueOf(tag);\n        tagNames.add(tagName);\n        AttributeKey attrKey = AttributeKey.valueOf(attribute);\n        AttributeValue attrVal = AttributeValue.valueOf(value);\n\n        Map<AttributeKey, AttributeValue> attrMap = enforcedAttributes.computeIfAbsent(tagName, Functions.mapFunction());\n        attrMap.put(attrKey, attrVal);\n        return this;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/safety/Safelist.java",
        "class_name": "Safelist",
        "class_uri": "src/main/java/org/jsoup/safety/Safelist.java.Safelist",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Safelist",
            "classes": []
        },
        "docstring": "\nAdd an enforced attribute to a tag. An enforced attribute will always be added to the element. If the element\nalready has the attribute set, it will be overridden with this value.\n<p>\nE.g.: <code>addEnforcedAttribute(\"a\", \"rel\", \"nofollow\")</code> will make all <code>a</code> tags output as\n<code>&lt;a href=\"...\" rel=\"nofollow\"&gt;</code>\n</p>\n\n@param tag   The tag the enforced attribute is for. The tag will be added to the allowed tag list if necessary.\n@param attribute   The attribute name\n@param value The enforced attribute value\n@return this (for chaining)\n"
    },
    {
        "uris": "src/main/java/org/jsoup/safety/Safelist.java.Safelist.[Safelist]removeEnforcedAttribute(String,String)",
        "name": "removeEnforcedAttribute",
        "arg_nums": 2,
        "params": [
            {
                "name": "tag",
                "type": "String"
            },
            {
                "name": "attribute",
                "type": "String"
            }
        ],
        "return_type": "Safelist",
        "signature": "public Safelist removeEnforcedAttribute(String tag, String attribute)",
        "original_string": "    public Safelist removeEnforcedAttribute(String tag, String attribute) {\n        Validate.notEmpty(tag);\n        Validate.notEmpty(attribute);\n\n        TagName tagName = TagName.valueOf(tag);\n        if(tagNames.contains(tagName) && enforcedAttributes.containsKey(tagName)) {\n            AttributeKey attrKey = AttributeKey.valueOf(attribute);\n            Map<AttributeKey, AttributeValue> attrMap = enforcedAttributes.get(tagName);\n            attrMap.remove(attrKey);\n\n            if(attrMap.isEmpty()) // Remove tag from enforced attribute map if no enforced attributes are present\n                enforcedAttributes.remove(tagName);\n        }\n        return this;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/safety/Safelist.java",
        "class_name": "Safelist",
        "class_uri": "src/main/java/org/jsoup/safety/Safelist.java.Safelist",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Safelist",
            "classes": []
        },
        "docstring": "\nRemove a previously configured enforced attribute from a tag.\n\n@param tag   The tag the enforced attribute is for.\n@param attribute   The attribute name\n@return this (for chaining)\n"
    },
    {
        "uris": "src/main/java/org/jsoup/safety/Safelist.java.Safelist.[Safelist]preserveRelativeLinks(boolean)",
        "name": "preserveRelativeLinks",
        "arg_nums": 1,
        "params": [
            {
                "name": "preserve",
                "type": "boolean"
            }
        ],
        "return_type": "Safelist",
        "signature": "public Safelist preserveRelativeLinks(boolean preserve)",
        "original_string": "    public Safelist preserveRelativeLinks(boolean preserve) {\n        preserveRelativeLinks = preserve;\n        return this;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/safety/Safelist.java",
        "class_name": "Safelist",
        "class_uri": "src/main/java/org/jsoup/safety/Safelist.java.Safelist",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Safelist",
            "classes": []
        },
        "docstring": "\nConfigure this Safelist to preserve relative links in an element's URL attribute, or convert them to absolute\nlinks. By default, this is <b>false</b>: URLs will be  made absolute (e.g. start with an allowed protocol, like\ne.g. {@code http://}.\n<p>\nNote that when handling relative links, the input document must have an appropriate {@code base URI} set when\nparsing, so that the link's protocol can be confirmed. Regardless of the setting of the {@code preserve relative\nlinks} option, the link must be resolvable against the base URI to an allowed protocol; otherwise the attribute\nwill be removed.\n</p>\n\n@param preserve {@code true} to allow relative links, {@code false} (default) to deny\n@return this Safelist, for chaining.\n@see #addProtocols\n"
    },
    {
        "uris": "src/main/java/org/jsoup/safety/Safelist.java.Safelist.[Safelist]addProtocols(String,String)",
        "name": "addProtocols",
        "arg_nums": 2,
        "params": [
            {
                "name": "tag",
                "type": "String"
            },
            {
                "name": "attribute",
                "type": "String"
            }
        ],
        "return_type": "Safelist",
        "signature": "public Safelist addProtocols(String tag, String attribute, String... protocols)",
        "original_string": "    public Safelist addProtocols(String tag, String attribute, String... protocols) {\n        Validate.notEmpty(tag);\n        Validate.notEmpty(attribute);\n        Validate.notNull(protocols);\n\n        TagName tagName = TagName.valueOf(tag);\n        AttributeKey attrKey = AttributeKey.valueOf(attribute);\n        Map<AttributeKey, Set<Protocol>> attrMap = this.protocols.computeIfAbsent(tagName, Functions.mapFunction());\n        Set<Protocol> protSet = attrMap.computeIfAbsent(attrKey, Functions.setFunction());\n\n        for (String protocol : protocols) {\n            Validate.notEmpty(protocol);\n            Protocol prot = Protocol.valueOf(protocol);\n            protSet.add(prot);\n        }\n        return this;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/safety/Safelist.java",
        "class_name": "Safelist",
        "class_uri": "src/main/java/org/jsoup/safety/Safelist.java.Safelist",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Safelist",
            "classes": []
        },
        "docstring": "\nAdd allowed URL protocols for an element's URL attribute. This restricts the possible values of the attribute to\nURLs with the defined protocol.\n<p>\nE.g.: <code>addProtocols(\"a\", \"href\", \"ftp\", \"http\", \"https\")</code>\n</p>\n<p>\nTo allow a link to an in-page URL anchor (i.e. <code>&lt;a href=\"#anchor\"&gt;</code>, add a <code>#</code>:<br>\nE.g.: <code>addProtocols(\"a\", \"href\", \"#\")</code>\n</p>\n\n@param tag       Tag the URL protocol is for\n@param attribute       Attribute name\n@param protocols List of valid protocols\n@return this, for chaining\n"
    },
    {
        "uris": "src/main/java/org/jsoup/safety/Safelist.java.Safelist.[Safelist]removeProtocols(String,String)",
        "name": "removeProtocols",
        "arg_nums": 2,
        "params": [
            {
                "name": "tag",
                "type": "String"
            },
            {
                "name": "attribute",
                "type": "String"
            }
        ],
        "return_type": "Safelist",
        "signature": "public Safelist removeProtocols(String tag, String attribute, String... removeProtocols)",
        "original_string": "    public Safelist removeProtocols(String tag, String attribute, String... removeProtocols) {\n        Validate.notEmpty(tag);\n        Validate.notEmpty(attribute);\n        Validate.notNull(removeProtocols);\n\n        TagName tagName = TagName.valueOf(tag);\n        AttributeKey attr = AttributeKey.valueOf(attribute);\n\n        // make sure that what we're removing actually exists; otherwise can open the tag to any data and that can\n        // be surprising\n        Validate.isTrue(protocols.containsKey(tagName), \"Cannot remove a protocol that is not set.\");\n        Map<AttributeKey, Set<Protocol>> tagProtocols = protocols.get(tagName);\n        Validate.isTrue(tagProtocols.containsKey(attr), \"Cannot remove a protocol that is not set.\");\n\n        Set<Protocol> attrProtocols = tagProtocols.get(attr);\n        for (String protocol : removeProtocols) {\n            Validate.notEmpty(protocol);\n            attrProtocols.remove(Protocol.valueOf(protocol));\n        }\n\n        if (attrProtocols.isEmpty()) { // Remove protocol set if empty\n            tagProtocols.remove(attr);\n            if (tagProtocols.isEmpty()) // Remove entry for tag if empty\n                protocols.remove(tagName);\n        }\n        return this;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/safety/Safelist.java",
        "class_name": "Safelist",
        "class_uri": "src/main/java/org/jsoup/safety/Safelist.java.Safelist",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Safelist",
            "classes": []
        },
        "docstring": "\nRemove allowed URL protocols for an element's URL attribute. If you remove all protocols for an attribute, that\nattribute will allow any protocol.\n<p>\nE.g.: <code>removeProtocols(\"a\", \"href\", \"ftp\")</code>\n</p>\n\n@param tag Tag the URL protocol is for\n@param attribute Attribute name\n@param removeProtocols List of invalid protocols\n@return this, for chaining\n"
    },
    {
        "uris": "src/main/java/org/jsoup/safety/Safelist.java.Safelist.[boolean]isSafeTag(String)",
        "name": "isSafeTag",
        "arg_nums": 1,
        "params": [
            {
                "name": "tag",
                "type": "String"
            }
        ],
        "return_type": "boolean",
        "signature": "public boolean isSafeTag(String tag)",
        "original_string": "    public boolean isSafeTag(String tag) {\n        return tagNames.contains(TagName.valueOf(tag));\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/safety/Safelist.java",
        "class_name": "Safelist",
        "class_uri": "src/main/java/org/jsoup/safety/Safelist.java.Safelist",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": "\nTest if the supplied tag is allowed by this safelist.\n@param tag test tag\n@return true if allowed\n"
    },
    {
        "uris": "src/main/java/org/jsoup/safety/Safelist.java.Safelist.[boolean]isSafeAttribute(String,Element,Attribute)",
        "name": "isSafeAttribute",
        "arg_nums": 3,
        "params": [
            {
                "name": "tagName",
                "type": "String"
            },
            {
                "name": "el",
                "type": "Element"
            },
            {
                "name": "attr",
                "type": "Attribute"
            }
        ],
        "return_type": "boolean",
        "signature": "public boolean isSafeAttribute(String tagName, Element el, Attribute attr)",
        "original_string": "    public boolean isSafeAttribute(String tagName, Element el, Attribute attr) {\n        TagName tag = TagName.valueOf(tagName);\n        AttributeKey key = AttributeKey.valueOf(attr.getKey());\n\n        Set<AttributeKey> okSet = attributes.get(tag);\n        if (okSet != null && okSet.contains(key)) {\n            if (protocols.containsKey(tag)) {\n                Map<AttributeKey, Set<Protocol>> attrProts = protocols.get(tag);\n                // ok if not defined protocol; otherwise test\n                return !attrProts.containsKey(key) || testValidProtocol(el, attr, attrProts.get(key));\n            } else { // attribute found, no protocols defined, so OK\n                return true;\n            }\n        }\n        // might be an enforced attribute?\n        Map<AttributeKey, AttributeValue> enforcedSet = enforcedAttributes.get(tag);\n        if (enforcedSet != null) {\n            Attributes expect = getEnforcedAttributes(tagName);\n            String attrKey = attr.getKey();\n            if (expect.hasKeyIgnoreCase(attrKey)) {\n                return expect.getIgnoreCase(attrKey).equals(attr.getValue());\n            }\n        }\n        // no attributes defined for tag, try :all tag\n        return !tagName.equals(All) && isSafeAttribute(All, el, attr);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/safety/Safelist.java",
        "class_name": "Safelist",
        "class_uri": "src/main/java/org/jsoup/safety/Safelist.java.Safelist",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": "\nTest if the supplied attribute is allowed by this safelist for this tag.\n@param tagName tag to consider allowing the attribute in\n@param el element under test, to confirm protocol\n@param attr attribute under test\n@return true if allowed\n"
    },
    {
        "uris": "src/main/java/org/jsoup/safety/Safelist.java.Safelist.[boolean]testValidProtocol(Element,Attribute,Set<Protocol>)",
        "name": "testValidProtocol",
        "arg_nums": 3,
        "params": [
            {
                "name": "el",
                "type": "Element"
            },
            {
                "name": "attr",
                "type": "Attribute"
            },
            {
                "name": "protocols",
                "type": "Set<Protocol>"
            }
        ],
        "return_type": "boolean",
        "signature": "private boolean testValidProtocol(Element el, Attribute attr, Set<Protocol> protocols)",
        "original_string": "    private boolean testValidProtocol(Element el, Attribute attr, Set<Protocol> protocols) {\n        // try to resolve relative urls to abs, and optionally update the attribute so output html has abs.\n        // rels without a baseuri get removed\n        String value = el.absUrl(attr.getKey());\n        if (value.length() == 0)\n            value = attr.getValue(); // if it could not be made abs, run as-is to allow custom unknown protocols\n        if (!preserveRelativeLinks)\n            attr.setValue(value);\n        \n        for (Protocol protocol : protocols) {\n            String prot = protocol.toString();\n\n            if (prot.equals(\"#\")) { // allows anchor links\n                if (isValidAnchor(value)) {\n                    return true;\n                } else {\n                    continue;\n                }\n            }\n\n            prot += \":\";\n\n            if (lowerCase(value).startsWith(prot)) {\n                return true;\n            }\n        }\n        return false;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/safety/Safelist.java",
        "class_name": "Safelist",
        "class_uri": "src/main/java/org/jsoup/safety/Safelist.java.Safelist",
        "attributes": {
            "modifiers": "private",
            "marker_annotations": [],
            "non_marker_annotations": [
                "private"
            ],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/safety/Safelist.java.Safelist.[boolean]isValidAnchor(String)",
        "name": "isValidAnchor",
        "arg_nums": 1,
        "params": [
            {
                "name": "value",
                "type": "String"
            }
        ],
        "return_type": "boolean",
        "signature": "private boolean isValidAnchor(String value)",
        "original_string": "    private boolean isValidAnchor(String value) {\n        return value.startsWith(\"#\") && !value.matches(\".*\\\\s.*\");\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/safety/Safelist.java",
        "class_name": "Safelist",
        "class_uri": "src/main/java/org/jsoup/safety/Safelist.java.Safelist",
        "attributes": {
            "modifiers": "private",
            "marker_annotations": [],
            "non_marker_annotations": [
                "private"
            ],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/safety/Safelist.java.Safelist.[Attributes]getEnforcedAttributes(String)",
        "name": "getEnforcedAttributes",
        "arg_nums": 1,
        "params": [
            {
                "name": "tagName",
                "type": "String"
            }
        ],
        "return_type": "Attributes",
        "signature": "public Attributes getEnforcedAttributes(String tagName)",
        "original_string": "    public Attributes getEnforcedAttributes(String tagName) {\n        Attributes attrs = new Attributes();\n        TagName tag = TagName.valueOf(tagName);\n        if (enforcedAttributes.containsKey(tag)) {\n            Map<AttributeKey, AttributeValue> keyVals = enforcedAttributes.get(tag);\n            for (Map.Entry<AttributeKey, AttributeValue> entry : keyVals.entrySet()) {\n                attrs.put(entry.getKey().toString(), entry.getValue().toString());\n            }\n        }\n        return attrs;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/safety/Safelist.java",
        "class_name": "Safelist",
        "class_uri": "src/main/java/org/jsoup/safety/Safelist.java.Safelist",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Attributes",
            "classes": []
        },
        "docstring": "\nGets the Attributes that should be enforced for a given tag\n@param tagName the tag\n@return the attributes that will be enforced; empty if none are set for the given tag\n"
    },
    {
        "uris": "src/main/java/org/jsoup/safety/Cleaner.java.Cleaner.[]Cleaner(Safelist)",
        "name": "Cleaner",
        "arg_nums": 1,
        "params": [
            {
                "name": "safelist",
                "type": "Safelist"
            }
        ],
        "return_type": "",
        "signature": "public Cleaner(Safelist safelist)",
        "original_string": "    public Cleaner(Safelist safelist) {\n        Validate.notNull(safelist);\n        this.safelist = safelist;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/safety/Cleaner.java",
        "class_name": "Cleaner",
        "class_uri": "src/main/java/org/jsoup/safety/Cleaner.java.Cleaner",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "",
            "classes": []
        },
        "docstring": "\nCreate a new cleaner, that sanitizes documents using the supplied safelist.\n@param safelist safe-list to clean with\n"
    },
    {
        "uris": "src/main/java/org/jsoup/safety/Cleaner.java.Cleaner.[Document]clean(Document)",
        "name": "clean",
        "arg_nums": 1,
        "params": [
            {
                "name": "dirtyDocument",
                "type": "Document"
            }
        ],
        "return_type": "Document",
        "signature": "public Document clean(Document dirtyDocument)",
        "original_string": "    public Document clean(Document dirtyDocument) {\n        Validate.notNull(dirtyDocument);\n\n        Document clean = Document.createShell(dirtyDocument.baseUri());\n        copySafeNodes(dirtyDocument.body(), clean.body());\n        clean.outputSettings(dirtyDocument.outputSettings().clone());\n\n        return clean;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/safety/Cleaner.java",
        "class_name": "Cleaner",
        "class_uri": "src/main/java/org/jsoup/safety/Cleaner.java.Cleaner",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Document",
            "classes": []
        },
        "docstring": "\nCreates a new, clean document, from the original dirty document, containing only elements allowed by the safelist.\nThe original document is not modified. Only elements from the dirty document's <code>body</code> are used. The\nOutputSettings of the original document are cloned into the clean document.\n@param dirtyDocument Untrusted base document to clean.\n@return cleaned document.\n"
    },
    {
        "uris": "src/main/java/org/jsoup/safety/Cleaner.java.Cleaner.[boolean]isValid(Document)",
        "name": "isValid",
        "arg_nums": 1,
        "params": [
            {
                "name": "dirtyDocument",
                "type": "Document"
            }
        ],
        "return_type": "boolean",
        "signature": "public boolean isValid(Document dirtyDocument)",
        "original_string": "    public boolean isValid(Document dirtyDocument) {\n        Validate.notNull(dirtyDocument);\n\n        Document clean = Document.createShell(dirtyDocument.baseUri());\n        int numDiscarded = copySafeNodes(dirtyDocument.body(), clean.body());\n        return numDiscarded == 0\n            && dirtyDocument.head().childNodes().isEmpty(); // because we only look at the body, but we start from a shell, make sure there's nothing in the head\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/safety/Cleaner.java",
        "class_name": "Cleaner",
        "class_uri": "src/main/java/org/jsoup/safety/Cleaner.java.Cleaner",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": "\nDetermines if the input document's <b>body</b> is valid, against the safelist. It is considered valid if all the\ntags and attributes in the input HTML are allowed by the safelist, and that there is no content in the\n<code>head</code>.\n<p>\nThis method is intended to be used in a user interface as a validator for user input. Note that regardless of the\noutput of this method, the input document <b>must always</b> be normalized using a method such as\n{@link #clean(Document)}, and the result of that method used to store or serialize the document before later reuse\nsuch as presentation to end users. This ensures that enforced attributes are set correctly, and that any\ndifferences between how a given browser and how jsoup parses the input HTML are normalized.\n</p>\n<p>Example:\n<pre>{@code\nDocument inputDoc = Jsoup.parse(inputHtml);\nCleaner cleaner = new Cleaner(Safelist.relaxed());\nboolean isValid = cleaner.isValid(inputDoc);\nDocument normalizedDoc = cleaner.clean(inputDoc);\n}</pre>\n</p>\n@param dirtyDocument document to test\n@return true if no tags or attributes need to be removed; false if they do\n"
    },
    {
        "uris": "src/main/java/org/jsoup/safety/Cleaner.java.Cleaner.[boolean]isValidBodyHtml(String)",
        "name": "isValidBodyHtml",
        "arg_nums": 1,
        "params": [
            {
                "name": "bodyHtml",
                "type": "String"
            }
        ],
        "return_type": "boolean",
        "signature": "public boolean isValidBodyHtml(String bodyHtml)",
        "original_string": "    public boolean isValidBodyHtml(String bodyHtml) {\n        Document clean = Document.createShell(\"\");\n        Document dirty = Document.createShell(\"\");\n        ParseErrorList errorList = ParseErrorList.tracking(1);\n        List<Node> nodes = Parser.parseFragment(bodyHtml, dirty.body(), \"\", errorList);\n        dirty.body().insertChildren(0, nodes);\n        int numDiscarded = copySafeNodes(dirty.body(), clean.body());\n        return numDiscarded == 0 && errorList.isEmpty();\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/safety/Cleaner.java",
        "class_name": "Cleaner",
        "class_uri": "src/main/java/org/jsoup/safety/Cleaner.java.Cleaner",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": "\nDetermines if the input document's <b>body HTML</b> is valid, against the safelist. It is considered valid if all\nthe tags and attributes in the input HTML are allowed by the safelist.\n<p>\nThis method is intended to be used in a user interface as a validator for user input. Note that regardless of the\noutput of this method, the input document <b>must always</b> be normalized using a method such as\n{@link #clean(Document)}, and the result of that method used to store or serialize the document before later reuse\nsuch as presentation to end users. This ensures that enforced attributes are set correctly, and that any\ndifferences between how a given browser and how jsoup parses the input HTML are normalized.\n</p>\n<p>Example:\n<pre>{@code\nDocument inputDoc = Jsoup.parse(inputHtml);\nCleaner cleaner = new Cleaner(Safelist.relaxed());\nboolean isValid = cleaner.isValidBodyHtml(inputHtml);\nDocument normalizedDoc = cleaner.clean(inputDoc);\n}</pre>\n</p>\n@param bodyHtml HTML fragment to test\n@return true if no tags or attributes need to be removed; false if they do\n"
    },
    {
        "uris": "src/main/java/org/jsoup/safety/Cleaner.java.Cleaner.[int]copySafeNodes(Element,Element)",
        "name": "copySafeNodes",
        "arg_nums": 2,
        "params": [
            {
                "name": "source",
                "type": "Element"
            },
            {
                "name": "dest",
                "type": "Element"
            }
        ],
        "return_type": "int",
        "signature": "private int copySafeNodes(Element source, Element dest)",
        "original_string": "    private int copySafeNodes(Element source, Element dest) {\n        CleaningVisitor cleaningVisitor = new CleaningVisitor(source, dest);\n        NodeTraversor.traverse(cleaningVisitor, source);\n        return cleaningVisitor.numDiscarded;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/safety/Cleaner.java",
        "class_name": "Cleaner",
        "class_uri": "src/main/java/org/jsoup/safety/Cleaner.java.Cleaner",
        "attributes": {
            "modifiers": "private",
            "marker_annotations": [],
            "non_marker_annotations": [
                "private"
            ],
            "comments": [],
            "return_type": "int",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/safety/Cleaner.java.Cleaner.[ElementMeta]createSafeElement(Element)",
        "name": "createSafeElement",
        "arg_nums": 1,
        "params": [
            {
                "name": "sourceEl",
                "type": "Element"
            }
        ],
        "return_type": "ElementMeta",
        "signature": "private ElementMeta createSafeElement(Element sourceEl)",
        "original_string": "    private ElementMeta createSafeElement(Element sourceEl) {\n        Element dest = sourceEl.shallowClone(); // reuses tag, clones attributes and preserves any user data\n        String sourceTag = sourceEl.tagName();\n        Attributes destAttrs = dest.attributes();\n        dest.clearAttributes(); // clear all non-internal attributes, ready for safe copy\n\n        int numDiscarded = 0;\n        Attributes sourceAttrs = sourceEl.attributes();\n        for (Attribute sourceAttr : sourceAttrs) {\n            if (safelist.isSafeAttribute(sourceTag, sourceEl, sourceAttr))\n                destAttrs.put(sourceAttr);\n            else\n                numDiscarded++;\n        }\n        Attributes enforcedAttrs = safelist.getEnforcedAttributes(sourceTag);\n        destAttrs.addAll(enforcedAttrs);\n        dest.attributes().addAll(destAttrs); // re-attach, if removed in clear\n        return new ElementMeta(dest, numDiscarded);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/safety/Cleaner.java",
        "class_name": "Cleaner",
        "class_uri": "src/main/java/org/jsoup/safety/Cleaner.java.Cleaner",
        "attributes": {
            "modifiers": "private",
            "marker_annotations": [],
            "non_marker_annotations": [
                "private"
            ],
            "comments": [],
            "return_type": "ElementMeta",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/internal/Functions.java.Functions.[]Functions()",
        "name": "Functions",
        "arg_nums": 0,
        "params": [],
        "return_type": "",
        "signature": "private Functions()",
        "original_string": "    private Functions() {\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/internal/Functions.java",
        "class_name": "Functions",
        "class_uri": "src/main/java/org/jsoup/internal/Functions.java.Functions",
        "attributes": {
            "modifiers": "private",
            "marker_annotations": [],
            "non_marker_annotations": [
                "private"
            ],
            "comments": [],
            "return_type": "",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/internal/Functions.java.Functions.[Function<T, List<U>>]listFunction()",
        "name": "listFunction",
        "arg_nums": 0,
        "params": [],
        "return_type": "Function<T, List<U>>",
        "signature": "public static <T, U> Function<T, List<U>> listFunction()",
        "original_string": "    public static <T, U> Function<T, List<U>> listFunction() {\n        return (Function<T, List<U>>) ListFunction;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/internal/Functions.java",
        "class_name": "Functions",
        "class_uri": "src/main/java/org/jsoup/internal/Functions.java.Functions",
        "attributes": {
            "modifiers": "public static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public",
                "static"
            ],
            "comments": [],
            "return_type": "Function<T, List<U>>",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/internal/Functions.java.Functions.[Function<T, Set<U>>]setFunction()",
        "name": "setFunction",
        "arg_nums": 0,
        "params": [],
        "return_type": "Function<T, Set<U>>",
        "signature": "public static <T, U> Function<T, Set<U>> setFunction()",
        "original_string": "    public static <T, U> Function<T, Set<U>> setFunction() {\n        return (Function<T, Set<U>>) SetFunction;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/internal/Functions.java",
        "class_name": "Functions",
        "class_uri": "src/main/java/org/jsoup/internal/Functions.java.Functions",
        "attributes": {
            "modifiers": "public static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public",
                "static"
            ],
            "comments": [],
            "return_type": "Function<T, Set<U>>",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/internal/Functions.java.Functions.[Function<T, Map<K, V>>]mapFunction()",
        "name": "mapFunction",
        "arg_nums": 0,
        "params": [],
        "return_type": "Function<T, Map<K, V>>",
        "signature": "public static <T, K, V> Function<T, Map<K, V>> mapFunction()",
        "original_string": "    public static <T, K, V> Function<T, Map<K, V>> mapFunction() {\n        return (Function<T, Map<K, V>>) MapFunction;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/internal/Functions.java",
        "class_name": "Functions",
        "class_uri": "src/main/java/org/jsoup/internal/Functions.java.Functions",
        "attributes": {
            "modifiers": "public static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public",
                "static"
            ],
            "comments": [],
            "return_type": "Function<T, Map<K, V>>",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/internal/Functions.java.Functions.[Function<T, IdentityHashMap<K, V>>]identityMapFunction()",
        "name": "identityMapFunction",
        "arg_nums": 0,
        "params": [],
        "return_type": "Function<T, IdentityHashMap<K, V>>",
        "signature": "public static <T, K, V> Function<T, IdentityHashMap<K, V>> identityMapFunction()",
        "original_string": "    public static <T, K, V> Function<T, IdentityHashMap<K, V>> identityMapFunction() {\n        return (Function<T, IdentityHashMap<K, V>>) IdentityMapFunction;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/internal/Functions.java",
        "class_name": "Functions",
        "class_uri": "src/main/java/org/jsoup/internal/Functions.java.Functions",
        "attributes": {
            "modifiers": "public static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public",
                "static"
            ],
            "comments": [],
            "return_type": "Function<T, IdentityHashMap<K, V>>",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/internal/SoftPool.java.SoftPool.[]SoftPool(Supplier<T>)",
        "name": "SoftPool",
        "arg_nums": 1,
        "params": [
            {
                "name": "initializer",
                "type": "Supplier<T>"
            }
        ],
        "return_type": "",
        "signature": "public SoftPool(Supplier<T> initializer)",
        "original_string": "    public SoftPool(Supplier<T> initializer) {\n        this.initializer = initializer;\n        this.threadLocalStack = ThreadLocal.withInitial(() -> new SoftReference<>(new Stack<>()));\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/internal/SoftPool.java",
        "class_name": "SoftPool",
        "class_uri": "src/main/java/org/jsoup/internal/SoftPool.java.SoftPool",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "",
            "classes": []
        },
        "docstring": "\nCreate a new SoftPool.\n@param initializer a supplier that creates a new object when one is needed.\n"
    },
    {
        "uris": "src/main/java/org/jsoup/internal/SoftPool.java.SoftPool.[T]borrow()",
        "name": "borrow",
        "arg_nums": 0,
        "params": [],
        "return_type": "T",
        "signature": "public T borrow()",
        "original_string": "    public T borrow() {\n        Stack<T> stack = getStack();\n        if (!stack.isEmpty()) {\n            return stack.pop();\n        }\n        return initializer.get();\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/internal/SoftPool.java",
        "class_name": "SoftPool",
        "class_uri": "src/main/java/org/jsoup/internal/SoftPool.java.SoftPool",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "T",
            "classes": []
        },
        "docstring": "\nBorrow an object from the pool, creating a new one if the pool is empty. Make sure to release it back to the pool\nwhen done, so that it can be reused.\n@return an object from the pool, as defined by the initializer.\n"
    },
    {
        "uris": "src/main/java/org/jsoup/internal/SoftPool.java.SoftPool.[void]release(T)",
        "name": "release",
        "arg_nums": 1,
        "params": [
            {
                "name": "value",
                "type": "T"
            }
        ],
        "return_type": "void",
        "signature": "public void release(T value)",
        "original_string": "    public void release(T value) {\n        Stack<T> stack = getStack();\n        if (stack.size() < MaxIdle) {\n            stack.push(value);\n        }\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/internal/SoftPool.java",
        "class_name": "SoftPool",
        "class_uri": "src/main/java/org/jsoup/internal/SoftPool.java.SoftPool",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": "\nRelease an object back to the pool. If the pool is full, the object is not retained. If you don't want to reuse a\nborrowed object (for e.g. a StringBuilder that grew too large), just don't release it.\n@param value the object to release back to the pool.\n"
    },
    {
        "uris": "src/main/java/org/jsoup/internal/SoftPool.java.SoftPool.[Stack<T>]getStack()",
        "name": "getStack",
        "arg_nums": 0,
        "params": [],
        "return_type": "Stack<T>",
        "signature": "Stack<T> getStack()",
        "original_string": "    Stack<T> getStack() {\n        Stack<T> stack = threadLocalStack.get().get();\n        if (stack == null) {\n            stack = new Stack<>();\n            threadLocalStack.set(new SoftReference<>(stack));\n        }\n        return stack;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/internal/SoftPool.java",
        "class_name": "SoftPool",
        "class_uri": "src/main/java/org/jsoup/internal/SoftPool.java.SoftPool",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "Stack<T>",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/internal/SharedConstants.java.SharedConstants.[]SharedConstants()",
        "name": "SharedConstants",
        "arg_nums": 0,
        "params": [],
        "return_type": "",
        "signature": "private SharedConstants()",
        "original_string": "    private SharedConstants() {}",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/internal/SharedConstants.java",
        "class_name": "SharedConstants",
        "class_uri": "src/main/java/org/jsoup/internal/SharedConstants.java.SharedConstants",
        "attributes": {
            "modifiers": "private",
            "marker_annotations": [],
            "non_marker_annotations": [
                "private"
            ],
            "comments": [],
            "return_type": "",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/internal/Normalizer.java.Normalizer.[String]lowerCase(String)",
        "name": "lowerCase",
        "arg_nums": 1,
        "params": [
            {
                "name": "input",
                "type": "String"
            }
        ],
        "return_type": "String",
        "signature": "public static String lowerCase(final String input)",
        "original_string": "    public static String lowerCase(final String input) {\n        return input != null ? input.toLowerCase(Locale.ENGLISH) : \"\";\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/internal/Normalizer.java",
        "class_name": "Normalizer",
        "class_uri": "src/main/java/org/jsoup/internal/Normalizer.java.Normalizer",
        "attributes": {
            "modifiers": "public static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public",
                "static"
            ],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": " Drops the input string to lower case."
    },
    {
        "uris": "src/main/java/org/jsoup/internal/Normalizer.java.Normalizer.[String]normalize(String)",
        "name": "normalize",
        "arg_nums": 1,
        "params": [
            {
                "name": "input",
                "type": "String"
            }
        ],
        "return_type": "String",
        "signature": "public static String normalize(final String input)",
        "original_string": "    public static String normalize(final String input) {\n        return lowerCase(input).trim();\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/internal/Normalizer.java",
        "class_name": "Normalizer",
        "class_uri": "src/main/java/org/jsoup/internal/Normalizer.java.Normalizer",
        "attributes": {
            "modifiers": "public static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public",
                "static"
            ],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": " Lower-cases and trims the input string."
    },
    {
        "uris": "src/main/java/org/jsoup/internal/Normalizer.java.Normalizer.[String]normalize(String,boolean)",
        "name": "normalize",
        "arg_nums": 2,
        "params": [
            {
                "name": "input",
                "type": "String"
            },
            {
                "name": "isStringLiteral",
                "type": "boolean"
            }
        ],
        "return_type": "String",
        "signature": "public static String normalize(final String input, boolean isStringLiteral)",
        "original_string": "    public static String normalize(final String input, boolean isStringLiteral) {\n        return isStringLiteral ? lowerCase(input) : normalize(input);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/internal/Normalizer.java",
        "class_name": "Normalizer",
        "class_uri": "src/main/java/org/jsoup/internal/Normalizer.java.Normalizer",
        "attributes": {
            "modifiers": "public static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public",
                "static"
            ],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": " If a string literal, just lower case the string; otherwise lower-case and trim."
    },
    {
        "uris": "src/main/java/org/jsoup/internal/StringUtil.java.StringUtil.[String]join(Collection<?>,String)",
        "name": "join",
        "arg_nums": 2,
        "params": [
            {
                "name": "strings",
                "type": "Collection<?>"
            },
            {
                "name": "sep",
                "type": "String"
            }
        ],
        "return_type": "String",
        "signature": "public static String join(Collection<?> strings, String sep)",
        "original_string": "    public static String join(Collection<?> strings, String sep) {\n        return join(strings.iterator(), sep);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/internal/StringUtil.java",
        "class_name": "StringUtil",
        "class_uri": "src/main/java/org/jsoup/internal/StringUtil.java.StringUtil",
        "attributes": {
            "modifiers": "public static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public",
                "static"
            ],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": "\nJoin a collection of strings by a separator\n@param strings collection of string objects\n@param sep string to place between strings\n@return joined string\n"
    },
    {
        "uris": "src/main/java/org/jsoup/internal/StringUtil.java.StringUtil.[String]join(Iterator<?>,String)",
        "name": "join",
        "arg_nums": 2,
        "params": [
            {
                "name": "strings",
                "type": "Iterator<?>"
            },
            {
                "name": "sep",
                "type": "String"
            }
        ],
        "return_type": "String",
        "signature": "public static String join(Iterator<?> strings, String sep)",
        "original_string": "    public static String join(Iterator<?> strings, String sep) {\n        if (!strings.hasNext())\n            return \"\";\n\n        String start = strings.next().toString();\n        if (!strings.hasNext()) // only one, avoid builder\n            return start;\n\n        StringJoiner j = new StringJoiner(sep);\n        j.add(start);\n        while (strings.hasNext()) {\n            j.add(strings.next());\n        }\n        return j.complete();\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/internal/StringUtil.java",
        "class_name": "StringUtil",
        "class_uri": "src/main/java/org/jsoup/internal/StringUtil.java.StringUtil",
        "attributes": {
            "modifiers": "public static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public",
                "static"
            ],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": "\nJoin a collection of strings by a separator\n@param strings iterator of string objects\n@param sep string to place between strings\n@return joined string\n"
    },
    {
        "uris": "src/main/java/org/jsoup/internal/StringUtil.java.StringUtil.[String]join(String[],String)",
        "name": "join",
        "arg_nums": 2,
        "params": [
            {
                "name": "strings",
                "type": "String[]"
            },
            {
                "name": "sep",
                "type": "String"
            }
        ],
        "return_type": "String",
        "signature": "public static String join(String[] strings, String sep)",
        "original_string": "    public static String join(String[] strings, String sep) {\n        return join(Arrays.asList(strings), sep);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/internal/StringUtil.java",
        "class_name": "StringUtil",
        "class_uri": "src/main/java/org/jsoup/internal/StringUtil.java.StringUtil",
        "attributes": {
            "modifiers": "public static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public",
                "static"
            ],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": "\nJoin an array of strings by a separator\n@param strings collection of string objects\n@param sep string to place between strings\n@return joined string\n"
    },
    {
        "uris": "src/main/java/org/jsoup/internal/StringUtil.java.StringUtil.[String]padding(int)",
        "name": "padding",
        "arg_nums": 1,
        "params": [
            {
                "name": "width",
                "type": "int"
            }
        ],
        "return_type": "String",
        "signature": "public static String padding(int width)",
        "original_string": "    public static String padding(int width) {\n        return padding(width, 30);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/internal/StringUtil.java",
        "class_name": "StringUtil",
        "class_uri": "src/main/java/org/jsoup/internal/StringUtil.java.StringUtil",
        "attributes": {
            "modifiers": "public static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public",
                "static"
            ],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": "\nReturns space padding (up to the default max of 30). Use {@link #padding(int, int)} to specify a different limit.\n@param width amount of padding desired\n@return string of spaces * width\n@see #padding(int, int) \n"
    },
    {
        "uris": "src/main/java/org/jsoup/internal/StringUtil.java.StringUtil.[String]padding(int,int)",
        "name": "padding",
        "arg_nums": 2,
        "params": [
            {
                "name": "width",
                "type": "int"
            },
            {
                "name": "maxPaddingWidth",
                "type": "int"
            }
        ],
        "return_type": "String",
        "signature": "public static String padding(int width, int maxPaddingWidth)",
        "original_string": "    public static String padding(int width, int maxPaddingWidth) {\n        Validate.isTrue(width >= 0, \"width must be >= 0\");\n        Validate.isTrue(maxPaddingWidth >= -1);\n        if (maxPaddingWidth != -1)\n            width = Math.min(width, maxPaddingWidth);\n        if (width < padding.length)\n            return padding[width];        \n        char[] out = new char[width];\n        for (int i = 0; i < width; i++)\n            out[i] = ' ';\n        return String.valueOf(out);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/internal/StringUtil.java",
        "class_name": "StringUtil",
        "class_uri": "src/main/java/org/jsoup/internal/StringUtil.java.StringUtil",
        "attributes": {
            "modifiers": "public static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public",
                "static"
            ],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": "\nReturns space padding, up to a max of maxPaddingWidth.\n@param width amount of padding desired\n@param maxPaddingWidth maximum padding to apply. Set to {@code -1} for unlimited.\n@return string of spaces * width\n"
    },
    {
        "uris": "src/main/java/org/jsoup/internal/StringUtil.java.StringUtil.[boolean]isBlank(String)",
        "name": "isBlank",
        "arg_nums": 1,
        "params": [
            {
                "name": "string",
                "type": "String"
            }
        ],
        "return_type": "boolean",
        "signature": "public static boolean isBlank(final String string)",
        "original_string": "    public static boolean isBlank(final String string) {\n        if (string == null || string.length() == 0)\n            return true;\n\n        int l = string.length();\n        for (int i = 0; i < l; i++) {\n            if (!StringUtil.isWhitespace(string.codePointAt(i)))\n                return false;\n        }\n        return true;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/internal/StringUtil.java",
        "class_name": "StringUtil",
        "class_uri": "src/main/java/org/jsoup/internal/StringUtil.java.StringUtil",
        "attributes": {
            "modifiers": "public static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public",
                "static"
            ],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": "\nTests if a string is blank: null, empty, or only whitespace (\" \", \\r\\n, \\t, etc)\n@param string string to test\n@return if string is blank\n"
    },
    {
        "uris": "src/main/java/org/jsoup/internal/StringUtil.java.StringUtil.[boolean]startsWithNewline(String)",
        "name": "startsWithNewline",
        "arg_nums": 1,
        "params": [
            {
                "name": "string",
                "type": "String"
            }
        ],
        "return_type": "boolean",
        "signature": "public static boolean startsWithNewline(final String string)",
        "original_string": "    public static boolean startsWithNewline(final String string) {\n        if (string == null || string.length() == 0)\n            return false;\n        return string.charAt(0) == '\\n';\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/internal/StringUtil.java",
        "class_name": "StringUtil",
        "class_uri": "src/main/java/org/jsoup/internal/StringUtil.java.StringUtil",
        "attributes": {
            "modifiers": "public static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public",
                "static"
            ],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": "\nTests if a string starts with a newline character\n@param string string to test\n@return if its first character is a newline\n"
    },
    {
        "uris": "src/main/java/org/jsoup/internal/StringUtil.java.StringUtil.[boolean]isNumeric(String)",
        "name": "isNumeric",
        "arg_nums": 1,
        "params": [
            {
                "name": "string",
                "type": "String"
            }
        ],
        "return_type": "boolean",
        "signature": "public static boolean isNumeric(String string)",
        "original_string": "    public static boolean isNumeric(String string) {\n        if (string == null || string.length() == 0)\n            return false;\n\n        int l = string.length();\n        for (int i = 0; i < l; i++) {\n            if (!Character.isDigit(string.codePointAt(i)))\n                return false;\n        }\n        return true;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/internal/StringUtil.java",
        "class_name": "StringUtil",
        "class_uri": "src/main/java/org/jsoup/internal/StringUtil.java.StringUtil",
        "attributes": {
            "modifiers": "public static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public",
                "static"
            ],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": "\nTests if a string is numeric, i.e. contains only digit characters\n@param string string to test\n@return true if only digit chars, false if empty or null or contains non-digit chars\n"
    },
    {
        "uris": "src/main/java/org/jsoup/internal/StringUtil.java.StringUtil.[boolean]isWhitespace(int)",
        "name": "isWhitespace",
        "arg_nums": 1,
        "params": [
            {
                "name": "c",
                "type": "int"
            }
        ],
        "return_type": "boolean",
        "signature": "public static boolean isWhitespace(int c)",
        "original_string": "    public static boolean isWhitespace(int c){\n        return c == ' ' || c == '\\t' || c == '\\n' || c == '\\f' || c == '\\r';\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/internal/StringUtil.java",
        "class_name": "StringUtil",
        "class_uri": "src/main/java/org/jsoup/internal/StringUtil.java.StringUtil",
        "attributes": {
            "modifiers": "public static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public",
                "static"
            ],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": "\nTests if a code point is \"whitespace\" as defined in the HTML spec. Used for output HTML.\n@param c code point to test\n@return true if code point is whitespace, false otherwise\n@see #isActuallyWhitespace(int)\n"
    },
    {
        "uris": "src/main/java/org/jsoup/internal/StringUtil.java.StringUtil.[boolean]isActuallyWhitespace(int)",
        "name": "isActuallyWhitespace",
        "arg_nums": 1,
        "params": [
            {
                "name": "c",
                "type": "int"
            }
        ],
        "return_type": "boolean",
        "signature": "public static boolean isActuallyWhitespace(int c)",
        "original_string": "    public static boolean isActuallyWhitespace(int c){\n        return c == ' ' || c == '\\t' || c == '\\n' || c == '\\f' || c == '\\r' || c == 160;\n        // 160 is &nbsp; (non-breaking space). Not in the spec but expected.\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/internal/StringUtil.java",
        "class_name": "StringUtil",
        "class_uri": "src/main/java/org/jsoup/internal/StringUtil.java.StringUtil",
        "attributes": {
            "modifiers": "public static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public",
                "static"
            ],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": "\nTests if a code point is \"whitespace\" as defined by what it looks like. Used for Element.text etc.\n@param c code point to test\n@return true if code point is whitespace, false otherwise\n"
    },
    {
        "uris": "src/main/java/org/jsoup/internal/StringUtil.java.StringUtil.[boolean]isInvisibleChar(int)",
        "name": "isInvisibleChar",
        "arg_nums": 1,
        "params": [
            {
                "name": "c",
                "type": "int"
            }
        ],
        "return_type": "boolean",
        "signature": "public static boolean isInvisibleChar(int c)",
        "original_string": "    public static boolean isInvisibleChar(int c) {\n        return c == 8203 || c == 173; // zero width sp, soft hyphen\n        // previously also included zw non join, zw join - but removing those breaks semantic meaning of text\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/internal/StringUtil.java",
        "class_name": "StringUtil",
        "class_uri": "src/main/java/org/jsoup/internal/StringUtil.java.StringUtil",
        "attributes": {
            "modifiers": "public static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public",
                "static"
            ],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/internal/StringUtil.java.StringUtil.[String]normaliseWhitespace(String)",
        "name": "normaliseWhitespace",
        "arg_nums": 1,
        "params": [
            {
                "name": "string",
                "type": "String"
            }
        ],
        "return_type": "String",
        "signature": "public static String normaliseWhitespace(String string)",
        "original_string": "    public static String normaliseWhitespace(String string) {\n        StringBuilder sb = StringUtil.borrowBuilder();\n        appendNormalisedWhitespace(sb, string, false);\n        return StringUtil.releaseBuilder(sb);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/internal/StringUtil.java",
        "class_name": "StringUtil",
        "class_uri": "src/main/java/org/jsoup/internal/StringUtil.java.StringUtil",
        "attributes": {
            "modifiers": "public static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public",
                "static"
            ],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": "\nNormalise the whitespace within this string; multiple spaces collapse to a single, and all whitespace characters\n(e.g. newline, tab) convert to a simple space.\n@param string content to normalise\n@return normalised string\n"
    },
    {
        "uris": "src/main/java/org/jsoup/internal/StringUtil.java.StringUtil.[void]appendNormalisedWhitespace(StringBuilder,String,boolean)",
        "name": "appendNormalisedWhitespace",
        "arg_nums": 3,
        "params": [
            {
                "name": "accum",
                "type": "StringBuilder"
            },
            {
                "name": "string",
                "type": "String"
            },
            {
                "name": "stripLeading",
                "type": "boolean"
            }
        ],
        "return_type": "void",
        "signature": "public static void appendNormalisedWhitespace(StringBuilder accum, String string, boolean stripLeading)",
        "original_string": "    public static void appendNormalisedWhitespace(StringBuilder accum, String string, boolean stripLeading) {\n        boolean lastWasWhite = false;\n        boolean reachedNonWhite = false;\n\n        int len = string.length();\n        int c;\n        for (int i = 0; i < len; i+= Character.charCount(c)) {\n            c = string.codePointAt(i);\n            if (isActuallyWhitespace(c)) {\n                if ((stripLeading && !reachedNonWhite) || lastWasWhite)\n                    continue;\n                accum.append(' ');\n                lastWasWhite = true;\n            }\n            else if (!isInvisibleChar(c)) {\n                accum.appendCodePoint(c);\n                lastWasWhite = false;\n                reachedNonWhite = true;\n            }\n        }\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/internal/StringUtil.java",
        "class_name": "StringUtil",
        "class_uri": "src/main/java/org/jsoup/internal/StringUtil.java.StringUtil",
        "attributes": {
            "modifiers": "public static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public",
                "static"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": "\nAfter normalizing the whitespace within a string, appends it to a string builder.\n@param accum builder to append to\n@param string string to normalize whitespace within\n@param stripLeading set to true if you wish to remove any leading whitespace\n"
    },
    {
        "uris": "src/main/java/org/jsoup/internal/StringUtil.java.StringUtil.[boolean]in(String)",
        "name": "in",
        "arg_nums": 1,
        "params": [
            {
                "name": "needle",
                "type": "String"
            }
        ],
        "return_type": "boolean",
        "signature": "public static boolean in(final String needle, final String... haystack)",
        "original_string": "    public static boolean in(final String needle, final String... haystack) {\n        final int len = haystack.length;\n        for (int i = 0; i < len; i++) {\n            if (haystack[i].equals(needle))\n               return true;\n        }\n        return false;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/internal/StringUtil.java",
        "class_name": "StringUtil",
        "class_uri": "src/main/java/org/jsoup/internal/StringUtil.java.StringUtil",
        "attributes": {
            "modifiers": "public static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public",
                "static"
            ],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/internal/StringUtil.java.StringUtil.[boolean]inSorted(String,String[])",
        "name": "inSorted",
        "arg_nums": 2,
        "params": [
            {
                "name": "needle",
                "type": "String"
            },
            {
                "name": "haystack",
                "type": "String[]"
            }
        ],
        "return_type": "boolean",
        "signature": "public static boolean inSorted(String needle, String[] haystack)",
        "original_string": "    public static boolean inSorted(String needle, String[] haystack) {\n        return Arrays.binarySearch(haystack, needle) >= 0;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/internal/StringUtil.java",
        "class_name": "StringUtil",
        "class_uri": "src/main/java/org/jsoup/internal/StringUtil.java.StringUtil",
        "attributes": {
            "modifiers": "public static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public",
                "static"
            ],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/internal/StringUtil.java.StringUtil.[boolean]isAscii(String)",
        "name": "isAscii",
        "arg_nums": 1,
        "params": [
            {
                "name": "string",
                "type": "String"
            }
        ],
        "return_type": "boolean",
        "signature": "public static boolean isAscii(String string)",
        "original_string": "    public static boolean isAscii(String string) {\n        Validate.notNull(string);\n        for (int i = 0; i < string.length(); i++) {\n            int c = string.charAt(i);\n            if (c > 127) { // ascii range\n                return false;\n            }\n        }\n        return true;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/internal/StringUtil.java",
        "class_name": "StringUtil",
        "class_uri": "src/main/java/org/jsoup/internal/StringUtil.java.StringUtil",
        "attributes": {
            "modifiers": "public static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public",
                "static"
            ],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": "\nTests that a String contains only ASCII characters.\n@param string scanned string\n@return true if all characters are in range 0 - 127\n"
    },
    {
        "uris": "src/main/java/org/jsoup/internal/StringUtil.java.StringUtil.[URL]resolve(URL,String)",
        "name": "resolve",
        "arg_nums": 2,
        "params": [
            {
                "name": "base",
                "type": "URL"
            },
            {
                "name": "relUrl",
                "type": "String"
            }
        ],
        "return_type": "URL",
        "signature": "public static URL resolve(URL base, String relUrl)",
        "original_string": "    public static URL resolve(URL base, String relUrl) throws MalformedURLException {\n        relUrl = stripControlChars(relUrl);\n        // workaround: java resolves '//path/file + ?foo' to '//path/?foo', not '//path/file?foo' as desired\n        if (relUrl.startsWith(\"?\"))\n            relUrl = base.getPath() + relUrl;\n        // workaround: //example.com + ./foo = //example.com/./foo, not //example.com/foo\n        URL url = new URL(base, relUrl);\n        String fixedFile = extraDotSegmentsPattern.matcher(url.getFile()).replaceFirst(\"/\");\n        if (url.getRef() != null) {\n            fixedFile = fixedFile + \"#\" + url.getRef();\n        }\n        return new URL(url.getProtocol(), url.getHost(), url.getPort(), fixedFile);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/internal/StringUtil.java",
        "class_name": "StringUtil",
        "class_uri": "src/main/java/org/jsoup/internal/StringUtil.java.StringUtil",
        "attributes": {
            "modifiers": "public static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public",
                "static"
            ],
            "comments": [],
            "return_type": "URL",
            "classes": []
        },
        "docstring": "\nCreate a new absolute URL, from a provided existing absolute URL and a relative URL component.\n@param base the existing absolute base URL\n@param relUrl the relative URL to resolve. (If it's already absolute, it will be returned)\n@return the resolved absolute URL\n@throws MalformedURLException if an error occurred generating the URL\n"
    },
    {
        "uris": "src/main/java/org/jsoup/internal/StringUtil.java.StringUtil.[String]resolve(String,String)",
        "name": "resolve",
        "arg_nums": 2,
        "params": [
            {
                "name": "baseUrl",
                "type": "String"
            },
            {
                "name": "relUrl",
                "type": "String"
            }
        ],
        "return_type": "String",
        "signature": "public static String resolve(String baseUrl, String relUrl)",
        "original_string": "    public static String resolve(String baseUrl, String relUrl) {\n        // workaround: java will allow control chars in a path URL and may treat as relative, but Chrome / Firefox will strip and may see as a scheme. Normalize to browser's view.\n        baseUrl = stripControlChars(baseUrl); relUrl = stripControlChars(relUrl);\n        try {\n            URL base;\n            try {\n                base = new URL(baseUrl);\n            } catch (MalformedURLException e) {\n                // the base is unsuitable, but the attribute/rel may be abs on its own, so try that\n                URL abs = new URL(relUrl);\n                return abs.toExternalForm();\n            }\n            return resolve(base, relUrl).toExternalForm();\n        } catch (MalformedURLException e) {\n            // it may still be valid, just that Java doesn't have a registered stream handler for it, e.g. tel\n            // we test here vs at start to normalize supported URLs (e.g. HTTP -> http)\n            return validUriScheme.matcher(relUrl).find() ? relUrl : \"\";\n        }\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/internal/StringUtil.java",
        "class_name": "StringUtil",
        "class_uri": "src/main/java/org/jsoup/internal/StringUtil.java.StringUtil",
        "attributes": {
            "modifiers": "public static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public",
                "static"
            ],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": "\nCreate a new absolute URL, from a provided existing absolute URL and a relative URL component.\n@param baseUrl the existing absolute base URL\n@param relUrl the relative URL to resolve. (If it's already absolute, it will be returned)\n@return an absolute URL if one was able to be generated, or the empty string if not\n"
    },
    {
        "uris": "src/main/java/org/jsoup/internal/StringUtil.java.StringUtil.[String]stripControlChars(String)",
        "name": "stripControlChars",
        "arg_nums": 1,
        "params": [
            {
                "name": "input",
                "type": "String"
            }
        ],
        "return_type": "String",
        "signature": "private static String stripControlChars(final String input)",
        "original_string": "    private static String stripControlChars(final String input) {\n        return controlChars.matcher(input).replaceAll(\"\");\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/internal/StringUtil.java",
        "class_name": "StringUtil",
        "class_uri": "src/main/java/org/jsoup/internal/StringUtil.java.StringUtil",
        "attributes": {
            "modifiers": "private static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "private",
                "static"
            ],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": " matches ascii 0 - 31, to strip from url"
    },
    {
        "uris": "src/main/java/org/jsoup/internal/StringUtil.java.StringUtil.[StringBuilder]borrowBuilder()",
        "name": "borrowBuilder",
        "arg_nums": 0,
        "params": [],
        "return_type": "StringBuilder",
        "signature": "public static StringBuilder borrowBuilder()",
        "original_string": "    public static StringBuilder borrowBuilder() {\n        return BuilderPool.borrow();\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/internal/StringUtil.java",
        "class_name": "StringUtil",
        "class_uri": "src/main/java/org/jsoup/internal/StringUtil.java.StringUtil",
        "attributes": {
            "modifiers": "public static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public",
                "static"
            ],
            "comments": [],
            "return_type": "StringBuilder",
            "classes": []
        },
        "docstring": "\nMaintains cached StringBuilders in a flyweight pattern, to minimize new StringBuilder GCs. The StringBuilder is\nprevented from growing too large.\n<p>\nCare must be taken to release the builder once its work has been completed, with {@link #releaseBuilder}\n@return an empty StringBuilder\n"
    },
    {
        "uris": "src/main/java/org/jsoup/internal/StringUtil.java.StringUtil.[String]releaseBuilder(StringBuilder)",
        "name": "releaseBuilder",
        "arg_nums": 1,
        "params": [
            {
                "name": "sb",
                "type": "StringBuilder"
            }
        ],
        "return_type": "String",
        "signature": "public static String releaseBuilder(StringBuilder sb)",
        "original_string": "    public static String releaseBuilder(StringBuilder sb) {\n        Validate.notNull(sb);\n        String string = sb.toString();\n\n        // if it hasn't grown too big, reset it and return it to the pool:\n        if (sb.length() <= MaxBuilderSize) {\n            sb.delete(0, sb.length()); // make sure it's emptied on release\n            BuilderPool.release(sb);\n        }\n\n        return string;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/internal/StringUtil.java",
        "class_name": "StringUtil",
        "class_uri": "src/main/java/org/jsoup/internal/StringUtil.java.StringUtil",
        "attributes": {
            "modifiers": "public static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public",
                "static"
            ],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": "\nRelease a borrowed builder. Care must be taken not to use the builder after it has been returned, as its\ncontents may be changed by this method, or by a concurrent thread.\n@param sb the StringBuilder to release.\n@return the string value of the released String Builder (as an incentive to release it!).\n"
    },
    {
        "uris": "src/main/java/org/jsoup/internal/StringUtil.java.StringUtil.[Collector<CharSequence, ?, String>]joining(String)",
        "name": "joining",
        "arg_nums": 1,
        "params": [
            {
                "name": "delimiter",
                "type": "String"
            }
        ],
        "return_type": "Collector<CharSequence, ?, String>",
        "signature": "public static Collector<CharSequence, ?, String> joining(String delimiter)",
        "original_string": "    public static Collector<CharSequence, ?, String> joining(String delimiter) {\n        return Collector.of(() -> new StringJoiner(delimiter),\n            StringJoiner::add,\n            (j1, j2) -> {\n                j1.append(j2.complete());\n                return j1;\n            },\n            StringJoiner::complete);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/internal/StringUtil.java",
        "class_name": "StringUtil",
        "class_uri": "src/main/java/org/jsoup/internal/StringUtil.java.StringUtil",
        "attributes": {
            "modifiers": "public static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public",
                "static"
            ],
            "comments": [],
            "return_type": "Collector<CharSequence, ?, String>",
            "classes": []
        },
        "docstring": "\nReturn a {@link Collector} similar to the one returned by {@link Collectors#joining(CharSequence)},\nbut backed by jsoup's {@link StringJoiner}, which allows for more efficient garbage collection.\n\n@param delimiter The delimiter for separating the strings.\n@return A {@code Collector} which concatenates CharSequence elements, separated by the specified delimiter\n"
    },
    {
        "uris": "src/main/java/org/jsoup/internal/SimpleBufferedInput.java.SimpleBufferedInput.[]SimpleBufferedInput(InputStream)",
        "name": "SimpleBufferedInput",
        "arg_nums": 1,
        "params": [
            {
                "name": "in",
                "type": "InputStream"
            }
        ],
        "return_type": "",
        "signature": "SimpleBufferedInput(InputStream in)",
        "original_string": "    SimpleBufferedInput(InputStream in) {\n        super(in);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/internal/SimpleBufferedInput.java",
        "class_name": "SimpleBufferedInput",
        "class_uri": "src/main/java/org/jsoup/internal/SimpleBufferedInput.java.SimpleBufferedInput",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "",
            "classes": []
        },
        "docstring": " true when the underlying inputstream has been read fully"
    },
    {
        "uris": "src/main/java/org/jsoup/internal/SimpleBufferedInput.java.SimpleBufferedInput.[int]read()",
        "name": "read",
        "arg_nums": 0,
        "params": [],
        "return_type": "int",
        "signature": "@Override\n    public int read()",
        "original_string": "    @Override\n    public int read() throws IOException {\n        if (bufPos >= bufLength) {\n            fill();\n            if (bufPos >= bufLength)\n                return -1;\n        }\n        return getBuf()[bufPos++] & 0xff;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/internal/SimpleBufferedInput.java",
        "class_name": "SimpleBufferedInput",
        "class_uri": "src/main/java/org/jsoup/internal/SimpleBufferedInput.java.SimpleBufferedInput",
        "attributes": {
            "modifiers": "@Override\n    public",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "int",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/internal/SimpleBufferedInput.java.SimpleBufferedInput.[int]read(byte[],int,int)",
        "name": "read",
        "arg_nums": 3,
        "params": [
            {
                "name": "dest",
                "type": "byte[]"
            },
            {
                "name": "offset",
                "type": "int"
            },
            {
                "name": "desiredLen",
                "type": "int"
            }
        ],
        "return_type": "int",
        "signature": "@Override\n    public int read(byte[] dest, int offset, int desiredLen)",
        "original_string": "    @Override\n    public int read(byte[] dest, int offset, int desiredLen) throws IOException {\n        Validate.notNull(dest);\n        if (offset < 0 || desiredLen < 0 || desiredLen > dest.length - offset) {\n            throw new IndexOutOfBoundsException();\n        } else if (desiredLen == 0) {\n            return 0;\n        }\n\n        int bufAvail = bufLength - bufPos;\n        if (bufAvail <= 0) { // can't serve from the buffer\n            if (!inReadFully && bufMark < 0) {\n                // skip creating / copying into a local buffer; just pass through\n                int read = in.read(dest, offset, desiredLen);\n                closeIfDone(read);\n                return read;\n            }\n            fill();\n            bufAvail = bufLength - bufPos;\n        }\n\n        int read = Math.min(bufAvail, desiredLen);\n        if (read <= 0) {\n            return -1;\n        }\n\n        System.arraycopy(getBuf(), bufPos, dest, offset, read);\n        bufPos += read;\n        return read;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/internal/SimpleBufferedInput.java",
        "class_name": "SimpleBufferedInput",
        "class_uri": "src/main/java/org/jsoup/internal/SimpleBufferedInput.java.SimpleBufferedInput",
        "attributes": {
            "modifiers": "@Override\n    public",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "int",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/internal/SimpleBufferedInput.java.SimpleBufferedInput.[void]fill()",
        "name": "fill",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "private void fill()",
        "original_string": "    private void fill() throws IOException {\n        if (inReadFully) return;\n        if (byteBuf == null) { // get one on first demand\n            byteBuf = BufferPool.borrow();\n        }\n\n        if (bufMark < 0) { // no mark, can lose buffer (assumes we've read to bufLen)\n            bufPos = 0;\n        } else if (bufPos >= BufferSize) { // no room left in buffer\n            if (bufMark > 0) { // can throw away early part of the buffer\n                int size = bufPos - bufMark;\n                System.arraycopy(byteBuf, bufMark, byteBuf, 0, size);\n                bufPos = size;\n                bufMark = 0;\n            } else { // invalidate mark\n                bufMark = -1;\n                bufPos = 0;\n            }\n        }\n        bufLength = bufPos;\n        int read = in.read(byteBuf, bufPos, byteBuf.length - bufPos);\n        if (read > 0) {\n            bufLength = read + bufPos;\n            while (byteBuf.length - bufLength > 0) { // read in more if we have space, without blocking\n                if (in.available() < 1) break;\n                read = in.read(byteBuf, bufLength, byteBuf.length - bufLength);\n                if (read <= 0) break;\n                bufLength += read;\n            }\n        }\n        closeIfDone(read);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/internal/SimpleBufferedInput.java",
        "class_name": "SimpleBufferedInput",
        "class_uri": "src/main/java/org/jsoup/internal/SimpleBufferedInput.java.SimpleBufferedInput",
        "attributes": {
            "modifiers": "private",
            "marker_annotations": [],
            "non_marker_annotations": [
                "private"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/internal/SimpleBufferedInput.java.SimpleBufferedInput.[void]closeIfDone(int)",
        "name": "closeIfDone",
        "arg_nums": 1,
        "params": [
            {
                "name": "read",
                "type": "int"
            }
        ],
        "return_type": "void",
        "signature": "private void closeIfDone(int read)",
        "original_string": "    private void closeIfDone(int read) throws IOException {\n        if (read == -1) {\n            inReadFully = true;\n            super.close(); // close underlying stream immediately; frees resources a little earlier\n        }\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/internal/SimpleBufferedInput.java",
        "class_name": "SimpleBufferedInput",
        "class_uri": "src/main/java/org/jsoup/internal/SimpleBufferedInput.java.SimpleBufferedInput",
        "attributes": {
            "modifiers": "private",
            "marker_annotations": [],
            "non_marker_annotations": [
                "private"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/internal/SimpleBufferedInput.java.SimpleBufferedInput.[byte[]]getBuf()",
        "name": "getBuf",
        "arg_nums": 0,
        "params": [],
        "return_type": "byte[]",
        "signature": "byte[] getBuf()",
        "original_string": "    byte[] getBuf() {\n        Validate.notNull(byteBuf);\n        return byteBuf;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/internal/SimpleBufferedInput.java",
        "class_name": "SimpleBufferedInput",
        "class_uri": "src/main/java/org/jsoup/internal/SimpleBufferedInput.java.SimpleBufferedInput",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "byte[]",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/internal/SimpleBufferedInput.java.SimpleBufferedInput.[boolean]baseReadFully()",
        "name": "baseReadFully",
        "arg_nums": 0,
        "params": [],
        "return_type": "boolean",
        "signature": "boolean baseReadFully()",
        "original_string": "    boolean baseReadFully() {\n        return inReadFully;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/internal/SimpleBufferedInput.java",
        "class_name": "SimpleBufferedInput",
        "class_uri": "src/main/java/org/jsoup/internal/SimpleBufferedInput.java.SimpleBufferedInput",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": "\nCheck if the underlying InputStream has been read fully. There may still content in this buffer to be consumed.\n@return true if the underlying inputstream has been read fully.\n"
    },
    {
        "uris": "src/main/java/org/jsoup/internal/SimpleBufferedInput.java.SimpleBufferedInput.[int]available()",
        "name": "available",
        "arg_nums": 0,
        "params": [],
        "return_type": "int",
        "signature": "@Override\n    public int available()",
        "original_string": "    @Override\n    public int available() throws IOException {\n        if (byteBuf != null && bufLength - bufPos > 0)\n            return bufLength - bufPos; // doesn't include those in.available(), but mostly used as a block test\n        return inReadFully ? 0 : in.available();\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/internal/SimpleBufferedInput.java",
        "class_name": "SimpleBufferedInput",
        "class_uri": "src/main/java/org/jsoup/internal/SimpleBufferedInput.java.SimpleBufferedInput",
        "attributes": {
            "modifiers": "@Override\n    public",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "int",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/internal/SimpleBufferedInput.java.SimpleBufferedInput.[void]mark(int)",
        "name": "mark",
        "arg_nums": 1,
        "params": [
            {
                "name": "readlimit",
                "type": "int"
            }
        ],
        "return_type": "void",
        "signature": "@SuppressWarnings(\"NonSynchronizedMethodOverridesSynchronizedMethod\") // explicitly not synced\n    @Override\n    public void mark(int readlimit)",
        "original_string": "    @SuppressWarnings(\"NonSynchronizedMethodOverridesSynchronizedMethod\") // explicitly not synced\n    @Override\n    public void mark(int readlimit) {\n        if (readlimit > BufferSize) {\n            throw new IllegalArgumentException(\"Read-ahead limit is greater than buffer size\");\n        }\n        bufMark = bufPos;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/internal/SimpleBufferedInput.java",
        "class_name": "SimpleBufferedInput",
        "class_uri": "src/main/java/org/jsoup/internal/SimpleBufferedInput.java.SimpleBufferedInput",
        "attributes": {
            "modifiers": "@SuppressWarnings(\"NonSynchronizedMethodOverridesSynchronizedMethod\") // explicitly not synced\n    @Override\n    public",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "@SuppressWarnings(\"NonSynchronizedMethodOverridesSynchronizedMethod\")",
                "public"
            ],
            "comments": [
                "// explicitly not synced"
            ],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/internal/SimpleBufferedInput.java.SimpleBufferedInput.[void]reset()",
        "name": "reset",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "@SuppressWarnings(\"NonSynchronizedMethodOverridesSynchronizedMethod\") // explicitly not synced\n    @Override\n    public void reset()",
        "original_string": "    @SuppressWarnings(\"NonSynchronizedMethodOverridesSynchronizedMethod\") // explicitly not synced\n    @Override\n    public void reset() throws IOException {\n        if (bufMark < 0)\n            throw new IOException(\"Resetting to invalid mark\");\n        bufPos = bufMark;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/internal/SimpleBufferedInput.java",
        "class_name": "SimpleBufferedInput",
        "class_uri": "src/main/java/org/jsoup/internal/SimpleBufferedInput.java.SimpleBufferedInput",
        "attributes": {
            "modifiers": "@SuppressWarnings(\"NonSynchronizedMethodOverridesSynchronizedMethod\") // explicitly not synced\n    @Override\n    public",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "@SuppressWarnings(\"NonSynchronizedMethodOverridesSynchronizedMethod\")",
                "public"
            ],
            "comments": [
                "// explicitly not synced"
            ],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/internal/SimpleBufferedInput.java.SimpleBufferedInput.[void]close()",
        "name": "close",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "@Override\n    public void close()",
        "original_string": "    @Override\n    public void close() throws IOException {\n        super.close();\n        if (byteBuf == null) return; // already closed, or never allocated\n        BufferPool.release(byteBuf); // return the buffer to the pool\n        byteBuf = null; // NPE further attempts to read\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/internal/SimpleBufferedInput.java",
        "class_name": "SimpleBufferedInput",
        "class_uri": "src/main/java/org/jsoup/internal/SimpleBufferedInput.java.SimpleBufferedInput",
        "attributes": {
            "modifiers": "@Override\n    public",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/internal/ControllableInputStream.java.ControllableInputStream.[]ControllableInputStream(SimpleBufferedInput,int)",
        "name": "ControllableInputStream",
        "arg_nums": 2,
        "params": [
            {
                "name": "in",
                "type": "SimpleBufferedInput"
            },
            {
                "name": "maxSize",
                "type": "int"
            }
        ],
        "return_type": "",
        "signature": "private ControllableInputStream(SimpleBufferedInput in, int maxSize)",
        "original_string": "    private ControllableInputStream(SimpleBufferedInput in, int maxSize) {\n        super(in);\n        Validate.isTrue(maxSize >= 0);\n        buff = in;\n        this.maxSize = maxSize;\n        remaining = maxSize;\n        markPos = -1;\n        startTime = System.nanoTime();\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/internal/ControllableInputStream.java",
        "class_name": "ControllableInputStream",
        "class_uri": "src/main/java/org/jsoup/internal/ControllableInputStream.java.ControllableInputStream",
        "attributes": {
            "modifiers": "private",
            "marker_annotations": [],
            "non_marker_annotations": [
                "private"
            ],
            "comments": [],
            "return_type": "",
            "classes": []
        },
        "docstring": " amount read; can be reset()"
    },
    {
        "uris": "src/main/java/org/jsoup/internal/ControllableInputStream.java.ControllableInputStream.[ControllableInputStream]wrap(InputStream,int)",
        "name": "wrap",
        "arg_nums": 2,
        "params": [
            {
                "name": "in",
                "type": "InputStream"
            },
            {
                "name": "maxSize",
                "type": "int"
            }
        ],
        "return_type": "ControllableInputStream",
        "signature": "public static ControllableInputStream wrap(InputStream in, int maxSize)",
        "original_string": "    public static ControllableInputStream wrap(InputStream in, int maxSize) {\n        // bufferSize currently unused; consider implementing as a min size in the SoftPool recycler\n        if (in instanceof ControllableInputStream)\n            return (ControllableInputStream) in;\n        else\n            return new ControllableInputStream(new SimpleBufferedInput(in), maxSize);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/internal/ControllableInputStream.java",
        "class_name": "ControllableInputStream",
        "class_uri": "src/main/java/org/jsoup/internal/ControllableInputStream.java.ControllableInputStream",
        "attributes": {
            "modifiers": "public static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public",
                "static"
            ],
            "comments": [],
            "return_type": "ControllableInputStream",
            "classes": []
        },
        "docstring": "\nIf this InputStream is not already a ControllableInputStream, let it be one.\n@param in the input stream to (maybe) wrap\n@param maxSize the maximum size to allow to be read. 0 == infinite.\n@return a controllable input stream\n"
    },
    {
        "uris": "src/main/java/org/jsoup/internal/ControllableInputStream.java.ControllableInputStream.[ControllableInputStream]wrap(InputStream,int,int)",
        "name": "wrap",
        "arg_nums": 3,
        "params": [
            {
                "name": "in",
                "type": "InputStream"
            },
            {
                "name": "bufferSize",
                "type": "int"
            },
            {
                "name": "maxSize",
                "type": "int"
            }
        ],
        "return_type": "ControllableInputStream",
        "signature": "public static ControllableInputStream wrap(InputStream in, int bufferSize, int maxSize)",
        "original_string": "    public static ControllableInputStream wrap(InputStream in, int bufferSize, int maxSize) {\n        // todo - bufferSize currently unused; consider implementing as a min size in the SoftPool recycler; or just deprecate if always DefaultBufferSize\n        return wrap(in, maxSize);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/internal/ControllableInputStream.java",
        "class_name": "ControllableInputStream",
        "class_uri": "src/main/java/org/jsoup/internal/ControllableInputStream.java.ControllableInputStream",
        "attributes": {
            "modifiers": "public static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public",
                "static"
            ],
            "comments": [],
            "return_type": "ControllableInputStream",
            "classes": []
        },
        "docstring": "\nIf this InputStream is not already a ControllableInputStream, let it be one.\n@param in the input stream to (maybe) wrap\n@param bufferSize the buffer size to use when reading\n@param maxSize the maximum size to allow to be read. 0 == infinite.\n@return a controllable input stream\n"
    },
    {
        "uris": "src/main/java/org/jsoup/internal/ControllableInputStream.java.ControllableInputStream.[int]read(byte[],int,int)",
        "name": "read",
        "arg_nums": 3,
        "params": [
            {
                "name": "b",
                "type": "byte[]"
            },
            {
                "name": "off",
                "type": "int"
            },
            {
                "name": "len",
                "type": "int"
            }
        ],
        "return_type": "int",
        "signature": "@Override\n    public int read(byte[] b, int off, int len)",
        "original_string": "    @Override\n    public int read(byte[] b, int off, int len) throws IOException {\n        if (readPos == 0) emitProgress(); // emits a progress\n\n        boolean capped = maxSize != 0;\n        if (interrupted || capped && remaining <= 0)\n            return -1;\n        if (Thread.currentThread().isInterrupted()) {\n            // interrupted latches, because parse() may call twice\n            interrupted = true;\n            return -1;\n        }\n\n        if (capped && len > remaining)\n            len = remaining; // don't read more than desired, even if available\n\n        while (true) { // loop trying to read until we get some data or hit the overall timeout, if we have one\n            if (expired())\n                throw new SocketTimeoutException(\"Read timeout\");\n\n            try {\n                final int read = super.read(b, off, len);\n                if (read == -1) { // completed\n                    contentLength = readPos;\n                } else {\n                    remaining -= read;\n                    readPos += read;\n                }\n                emitProgress();\n                return read;\n            } catch (SocketTimeoutException e) {\n                if (expired() || timeout == 0)\n                    throw e;\n            }\n        }\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/internal/ControllableInputStream.java",
        "class_name": "ControllableInputStream",
        "class_uri": "src/main/java/org/jsoup/internal/ControllableInputStream.java.ControllableInputStream",
        "attributes": {
            "modifiers": "@Override\n    public",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "int",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/internal/ControllableInputStream.java.ControllableInputStream.[ByteBuffer]readToByteBuffer(InputStream,int)",
        "name": "readToByteBuffer",
        "arg_nums": 2,
        "params": [
            {
                "name": "in",
                "type": "InputStream"
            },
            {
                "name": "max",
                "type": "int"
            }
        ],
        "return_type": "ByteBuffer",
        "signature": "public static ByteBuffer readToByteBuffer(InputStream in, int max)",
        "original_string": "    public static ByteBuffer readToByteBuffer(InputStream in, int max) throws IOException {\n        Validate.isTrue(max >= 0, \"maxSize must be 0 (unlimited) or larger\");\n        Validate.notNull(in);\n        final boolean capped = max > 0;\n        final byte[] readBuf = SimpleBufferedInput.BufferPool.borrow(); // Share the same byte[] pool as SBI\n        final int outSize = capped ? Math.min(max, DefaultBufferSize) : DefaultBufferSize;\n        ByteBuffer outBuf = ByteBuffer.allocate(outSize);\n\n        try {\n            int remaining = max;\n            int read;\n            while ((read = in.read(readBuf, 0, capped ? Math.min(remaining, DefaultBufferSize) : DefaultBufferSize)) != -1) {\n                if (outBuf.remaining() < read) { // needs to grow\n                    int newCapacity = (int) Math.max(outBuf.capacity() * 1.5, outBuf.capacity() + read);\n                    ByteBuffer newBuffer = ByteBuffer.allocate(newCapacity);\n                    outBuf.flip();\n                    newBuffer.put(outBuf);\n                    outBuf = newBuffer;\n                }\n                outBuf.put(readBuf, 0, read);\n                if (capped) {\n                    remaining -= read;\n                    if (remaining <= 0) break;\n                }\n            }\n            outBuf.flip(); // Prepare the buffer for reading\n            return outBuf;\n        } finally {\n            SimpleBufferedInput.BufferPool.release(readBuf);\n        }\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/internal/ControllableInputStream.java",
        "class_name": "ControllableInputStream",
        "class_uri": "src/main/java/org/jsoup/internal/ControllableInputStream.java.ControllableInputStream",
        "attributes": {
            "modifiers": "public static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public",
                "static"
            ],
            "comments": [],
            "return_type": "ByteBuffer",
            "classes": []
        },
        "docstring": "\nReads this inputstream to a ByteBuffer. The supplied max may be less than the inputstream's max, to support\nreading just the first bytes.\n"
    },
    {
        "uris": "src/main/java/org/jsoup/internal/ControllableInputStream.java.ControllableInputStream.[void]reset()",
        "name": "reset",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "@SuppressWarnings(\"NonSynchronizedMethodOverridesSynchronizedMethod\") // not synchronized in later JDKs\n    @Override public void reset()",
        "original_string": "    @SuppressWarnings(\"NonSynchronizedMethodOverridesSynchronizedMethod\") // not synchronized in later JDKs\n    @Override public void reset() throws IOException {\n        super.reset();\n        remaining = maxSize - markPos;\n        readPos = markPos; // readPos is used for progress emits\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/internal/ControllableInputStream.java",
        "class_name": "ControllableInputStream",
        "class_uri": "src/main/java/org/jsoup/internal/ControllableInputStream.java.ControllableInputStream",
        "attributes": {
            "modifiers": "@SuppressWarnings(\"NonSynchronizedMethodOverridesSynchronizedMethod\") // not synchronized in later JDKs\n    @Override public",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "@SuppressWarnings(\"NonSynchronizedMethodOverridesSynchronizedMethod\")",
                "public"
            ],
            "comments": [
                "// not synchronized in later JDKs"
            ],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/internal/ControllableInputStream.java.ControllableInputStream.[void]mark(int)",
        "name": "mark",
        "arg_nums": 1,
        "params": [
            {
                "name": "readlimit",
                "type": "int"
            }
        ],
        "return_type": "void",
        "signature": "@SuppressWarnings(\"NonSynchronizedMethodOverridesSynchronizedMethod\") // not synchronized in later JDKs\n    @Override public void mark(int readlimit)",
        "original_string": "    @SuppressWarnings(\"NonSynchronizedMethodOverridesSynchronizedMethod\") // not synchronized in later JDKs\n    @Override public void mark(int readlimit) {\n        super.mark(readlimit);\n        markPos = maxSize - remaining;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/internal/ControllableInputStream.java",
        "class_name": "ControllableInputStream",
        "class_uri": "src/main/java/org/jsoup/internal/ControllableInputStream.java.ControllableInputStream",
        "attributes": {
            "modifiers": "@SuppressWarnings(\"NonSynchronizedMethodOverridesSynchronizedMethod\") // not synchronized in later JDKs\n    @Override public",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "@SuppressWarnings(\"NonSynchronizedMethodOverridesSynchronizedMethod\")",
                "public"
            ],
            "comments": [
                "// not synchronized in later JDKs"
            ],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/internal/ControllableInputStream.java.ControllableInputStream.[boolean]baseReadFully()",
        "name": "baseReadFully",
        "arg_nums": 0,
        "params": [],
        "return_type": "boolean",
        "signature": "public boolean baseReadFully()",
        "original_string": "    public boolean baseReadFully() {\n        return buff.baseReadFully();\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/internal/ControllableInputStream.java",
        "class_name": "ControllableInputStream",
        "class_uri": "src/main/java/org/jsoup/internal/ControllableInputStream.java.ControllableInputStream",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": "\nCheck if the underlying InputStream has been read fully. There may still content in buffers to be consumed, and\nread methods may return -1 if hit the read limit.\n@return true if the underlying inputstream has been read fully.\n"
    },
    {
        "uris": "src/main/java/org/jsoup/internal/ControllableInputStream.java.ControllableInputStream.[int]max()",
        "name": "max",
        "arg_nums": 0,
        "params": [],
        "return_type": "int",
        "signature": "public int max()",
        "original_string": "    public int max() {\n        return maxSize;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/internal/ControllableInputStream.java",
        "class_name": "ControllableInputStream",
        "class_uri": "src/main/java/org/jsoup/internal/ControllableInputStream.java.ControllableInputStream",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "int",
            "classes": []
        },
        "docstring": "\nGet the max size of this stream (how far at most will be read from the underlying stream)\n@return the max size\n"
    },
    {
        "uris": "src/main/java/org/jsoup/internal/ControllableInputStream.java.ControllableInputStream.[void]max(int)",
        "name": "max",
        "arg_nums": 1,
        "params": [
            {
                "name": "newMax",
                "type": "int"
            }
        ],
        "return_type": "void",
        "signature": "public void max(int newMax)",
        "original_string": "    public void max(int newMax) {\n        remaining += newMax - maxSize; // update remaining to reflect the difference in the new maxsize\n        maxSize = newMax;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/internal/ControllableInputStream.java",
        "class_name": "ControllableInputStream",
        "class_uri": "src/main/java/org/jsoup/internal/ControllableInputStream.java.ControllableInputStream",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/internal/ControllableInputStream.java.ControllableInputStream.[void]allowClose(boolean)",
        "name": "allowClose",
        "arg_nums": 1,
        "params": [
            {
                "name": "allowClose",
                "type": "boolean"
            }
        ],
        "return_type": "void",
        "signature": "public void allowClose(boolean allowClose)",
        "original_string": "    public void allowClose(boolean allowClose) {\n        this.allowClose = allowClose;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/internal/ControllableInputStream.java",
        "class_name": "ControllableInputStream",
        "class_uri": "src/main/java/org/jsoup/internal/ControllableInputStream.java.ControllableInputStream",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/internal/ControllableInputStream.java.ControllableInputStream.[void]close()",
        "name": "close",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "@Override public void close()",
        "original_string": "    @Override public void close() throws IOException {\n        if (allowClose) super.close();\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/internal/ControllableInputStream.java",
        "class_name": "ControllableInputStream",
        "class_uri": "src/main/java/org/jsoup/internal/ControllableInputStream.java.ControllableInputStream",
        "attributes": {
            "modifiers": "@Override public",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/internal/ControllableInputStream.java.ControllableInputStream.[ControllableInputStream]timeout(long,long)",
        "name": "timeout",
        "arg_nums": 2,
        "params": [
            {
                "name": "startTimeNanos",
                "type": "long"
            },
            {
                "name": "timeoutMillis",
                "type": "long"
            }
        ],
        "return_type": "ControllableInputStream",
        "signature": "public ControllableInputStream timeout(long startTimeNanos, long timeoutMillis)",
        "original_string": "    public ControllableInputStream timeout(long startTimeNanos, long timeoutMillis) {\n        this.startTime = startTimeNanos;\n        this.timeout = timeoutMillis * 1000000;\n        return this;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/internal/ControllableInputStream.java",
        "class_name": "ControllableInputStream",
        "class_uri": "src/main/java/org/jsoup/internal/ControllableInputStream.java.ControllableInputStream",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "ControllableInputStream",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/internal/ControllableInputStream.java.ControllableInputStream.[void]emitProgress()",
        "name": "emitProgress",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "private void emitProgress()",
        "original_string": "    private void emitProgress() {\n        if (progress == null) return;\n        // calculate percent complete if contentLength > 0 (and cap to 100.0 if totalRead > contentLength):\n        float percent = contentLength > 0 ? Math.min(100f, readPos * 100f / contentLength) : 0;\n        //noinspection unchecked\n        ((Progress<Object>) progress).onProgress(readPos, contentLength, percent, progressContext); // (not actually unchecked - verified when set)\n        if (percent == 100.0f) progress = null; // detach once we reach 100%, so that any subsequent buffer hits don't report 100 again\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/internal/ControllableInputStream.java",
        "class_name": "ControllableInputStream",
        "class_uri": "src/main/java/org/jsoup/internal/ControllableInputStream.java.ControllableInputStream",
        "attributes": {
            "modifiers": "private",
            "marker_annotations": [],
            "non_marker_annotations": [
                "private"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/internal/ControllableInputStream.java.ControllableInputStream.[ControllableInputStream]onProgress(int,Progress<ProgressContext>,ProgressContext)",
        "name": "onProgress",
        "arg_nums": 3,
        "params": [
            {
                "name": "contentLength",
                "type": "int"
            },
            {
                "name": "callback",
                "type": "Progress<ProgressContext>"
            },
            {
                "name": "context",
                "type": "ProgressContext"
            }
        ],
        "return_type": "ControllableInputStream",
        "signature": "public <ProgressContext> ControllableInputStream onProgress(int contentLength, Progress<ProgressContext> callback, ProgressContext context)",
        "original_string": "    public <ProgressContext> ControllableInputStream onProgress(int contentLength, Progress<ProgressContext> callback, ProgressContext context) {\n        Validate.notNull(callback);\n        Validate.notNull(context);\n        this.contentLength = contentLength;\n        this.progress = callback;\n        this.progressContext = context;\n        return this;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/internal/ControllableInputStream.java",
        "class_name": "ControllableInputStream",
        "class_uri": "src/main/java/org/jsoup/internal/ControllableInputStream.java.ControllableInputStream",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "ControllableInputStream",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/internal/ControllableInputStream.java.ControllableInputStream.[boolean]expired()",
        "name": "expired",
        "arg_nums": 0,
        "params": [],
        "return_type": "boolean",
        "signature": "private boolean expired()",
        "original_string": "    private boolean expired() {\n        if (timeout == 0)\n            return false;\n\n        final long now = System.nanoTime();\n        final long dur = now - startTime;\n        return (dur > timeout);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/internal/ControllableInputStream.java",
        "class_name": "ControllableInputStream",
        "class_uri": "src/main/java/org/jsoup/internal/ControllableInputStream.java.ControllableInputStream",
        "attributes": {
            "modifiers": "private",
            "marker_annotations": [],
            "non_marker_annotations": [
                "private"
            ],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/internal/ControllableInputStream.java.ControllableInputStream.[BufferedInputStream]inputStream()",
        "name": "inputStream",
        "arg_nums": 0,
        "params": [],
        "return_type": "BufferedInputStream",
        "signature": "public BufferedInputStream inputStream()",
        "original_string": "    public BufferedInputStream inputStream() {\n        // called via HttpConnection.Response.bodyStream(), needs an OG BufferedInputStream\n        return new BufferedInputStream(buff);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/internal/ControllableInputStream.java",
        "class_name": "ControllableInputStream",
        "class_uri": "src/main/java/org/jsoup/internal/ControllableInputStream.java.ControllableInputStream",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "BufferedInputStream",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Comment.java.Comment.[]Comment(String)",
        "name": "Comment",
        "arg_nums": 1,
        "params": [
            {
                "name": "data",
                "type": "String"
            }
        ],
        "return_type": "",
        "signature": "public Comment(String data)",
        "original_string": "    public Comment(String data) {\n        super(data);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Comment.java",
        "class_name": "Comment",
        "class_uri": "src/main/java/org/jsoup/nodes/Comment.java.Comment",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "",
            "classes": []
        },
        "docstring": "\nCreate a new comment node.\n@param data The contents of the comment\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Comment.java.Comment.[String]nodeName()",
        "name": "nodeName",
        "arg_nums": 0,
        "params": [],
        "return_type": "String",
        "signature": "@Override public String nodeName()",
        "original_string": "    @Override public String nodeName() {\n        return \"#comment\";\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Comment.java",
        "class_name": "Comment",
        "class_uri": "src/main/java/org/jsoup/nodes/Comment.java.Comment",
        "attributes": {
            "modifiers": "@Override public",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Comment.java.Comment.[String]getData()",
        "name": "getData",
        "arg_nums": 0,
        "params": [],
        "return_type": "String",
        "signature": "public String getData()",
        "original_string": "    public String getData() {\n        return coreValue();\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Comment.java",
        "class_name": "Comment",
        "class_uri": "src/main/java/org/jsoup/nodes/Comment.java.Comment",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": "\nGet the contents of the comment.\n@return comment content\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Comment.java.Comment.[Comment]setData(String)",
        "name": "setData",
        "arg_nums": 1,
        "params": [
            {
                "name": "data",
                "type": "String"
            }
        ],
        "return_type": "Comment",
        "signature": "public Comment setData(String data)",
        "original_string": "    public Comment setData(String data) {\n        coreValue(data);\n        return this;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Comment.java",
        "class_name": "Comment",
        "class_uri": "src/main/java/org/jsoup/nodes/Comment.java.Comment",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Comment",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Comment.java.Comment.[void]outerHtmlHead(Appendable,int,Document.OutputSettings)",
        "name": "outerHtmlHead",
        "arg_nums": 3,
        "params": [
            {
                "name": "accum",
                "type": "Appendable"
            },
            {
                "name": "depth",
                "type": "int"
            },
            {
                "name": "out",
                "type": "Document.OutputSettings"
            }
        ],
        "return_type": "void",
        "signature": "@Override\n\tvoid outerHtmlHead(Appendable accum, int depth, Document.OutputSettings out)",
        "original_string": "    @Override\n\tvoid outerHtmlHead(Appendable accum, int depth, Document.OutputSettings out) throws IOException {\n        if (out.prettyPrint() && ((isEffectivelyFirst() && parentNode instanceof Element && ((Element) parentNode).tag().formatAsBlock()) || (out.outline() )))\n            indent(accum, depth, out);\n        accum\n                .append(\"<!--\")\n                .append(getData())\n                .append(\"-->\");\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Comment.java",
        "class_name": "Comment",
        "class_uri": "src/main/java/org/jsoup/nodes/Comment.java.Comment",
        "attributes": {
            "modifiers": "@Override",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Comment.java.Comment.[void]outerHtmlTail(Appendable,int,Document.OutputSettings)",
        "name": "outerHtmlTail",
        "arg_nums": 3,
        "params": [
            {
                "name": "accum",
                "type": "Appendable"
            },
            {
                "name": "depth",
                "type": "int"
            },
            {
                "name": "out",
                "type": "Document.OutputSettings"
            }
        ],
        "return_type": "void",
        "signature": "@Override\n    void outerHtmlTail(Appendable accum, int depth, Document.OutputSettings out)",
        "original_string": "    @Override\n    void outerHtmlTail(Appendable accum, int depth, Document.OutputSettings out) {}",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Comment.java",
        "class_name": "Comment",
        "class_uri": "src/main/java/org/jsoup/nodes/Comment.java.Comment",
        "attributes": {
            "modifiers": "@Override",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Comment.java.Comment.[Comment]clone()",
        "name": "clone",
        "arg_nums": 0,
        "params": [],
        "return_type": "Comment",
        "signature": "@Override\n    public Comment clone()",
        "original_string": "    @Override\n    public Comment clone() {\n        return (Comment) super.clone();\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Comment.java",
        "class_name": "Comment",
        "class_uri": "src/main/java/org/jsoup/nodes/Comment.java.Comment",
        "attributes": {
            "modifiers": "@Override\n    public",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Comment",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Comment.java.Comment.[boolean]isXmlDeclaration()",
        "name": "isXmlDeclaration",
        "arg_nums": 0,
        "params": [],
        "return_type": "boolean",
        "signature": "public boolean isXmlDeclaration()",
        "original_string": "    public boolean isXmlDeclaration() {\n        String data = getData();\n        return isXmlDeclarationData(data);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Comment.java",
        "class_name": "Comment",
        "class_uri": "src/main/java/org/jsoup/nodes/Comment.java.Comment",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": "\nCheck if this comment looks like an XML Declaration.\n@return true if it looks like, maybe, it's an XML Declaration.\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Comment.java.Comment.[boolean]isXmlDeclarationData(String)",
        "name": "isXmlDeclarationData",
        "arg_nums": 1,
        "params": [
            {
                "name": "data",
                "type": "String"
            }
        ],
        "return_type": "boolean",
        "signature": "private static boolean isXmlDeclarationData(String data)",
        "original_string": "    private static boolean isXmlDeclarationData(String data) {\n        return (data.length() > 1 && (data.startsWith(\"!\") || data.startsWith(\"?\")));\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Comment.java",
        "class_name": "Comment",
        "class_uri": "src/main/java/org/jsoup/nodes/Comment.java.Comment",
        "attributes": {
            "modifiers": "private static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "private",
                "static"
            ],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Comment.java.Comment.[XmlDeclaration]asXmlDeclaration()",
        "name": "asXmlDeclaration",
        "arg_nums": 0,
        "params": [],
        "return_type": "XmlDeclaration",
        "signature": "public @Nullable XmlDeclaration asXmlDeclaration()",
        "original_string": "    public @Nullable XmlDeclaration asXmlDeclaration() {\n        String data = getData();\n\n        XmlDeclaration decl = null;\n        String declContent = data.substring(1, data.length() - 1);\n        // make sure this bogus comment is not immediately followed by another, treat as comment if so\n        if (isXmlDeclarationData(declContent))\n            return null;\n\n        String fragment = \"<\" + declContent + \">\";\n        // use the HTML parser not XML, so we don't get into a recursive XML Declaration on contrived data\n        Document doc = Parser.htmlParser().settings(ParseSettings.preserveCase).parseInput(fragment, baseUri());\n        if (doc.body().childrenSize() > 0) {\n            Element el = doc.body().child(0);\n            decl = new XmlDeclaration(NodeUtils.parser(doc).settings().normalizeTag(el.tagName()), data.startsWith(\"!\"));\n            decl.attributes().addAll(el.attributes());\n        }\n        return decl;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Comment.java",
        "class_name": "Comment",
        "class_uri": "src/main/java/org/jsoup/nodes/Comment.java.Comment",
        "attributes": {
            "modifiers": "public @Nullable",
            "marker_annotations": [
                "@Nullable"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "XmlDeclaration",
            "classes": []
        },
        "docstring": "\nAttempt to cast this comment to an XML Declaration node.\n@return an XML declaration if it could be parsed as one, null otherwise.\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/DocumentType.java.DocumentType.[]DocumentType(String,String,String)",
        "name": "DocumentType",
        "arg_nums": 3,
        "params": [
            {
                "name": "name",
                "type": "String"
            },
            {
                "name": "publicId",
                "type": "String"
            },
            {
                "name": "systemId",
                "type": "String"
            }
        ],
        "return_type": "",
        "signature": "public DocumentType(String name, String publicId, String systemId)",
        "original_string": "    public DocumentType(String name, String publicId, String systemId) {\n        super(name);\n        Validate.notNull(publicId);\n        Validate.notNull(systemId);\n        attr(Name, name);\n        attr(PublicId, publicId);\n        attr(SystemId, systemId);\n        updatePubSyskey();\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/DocumentType.java",
        "class_name": "DocumentType",
        "class_uri": "src/main/java/org/jsoup/nodes/DocumentType.java.DocumentType",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "",
            "classes": []
        },
        "docstring": "\nCreate a new doctype element.\n@param name the doctype's name\n@param publicId the doctype's public ID\n@param systemId the doctype's system ID\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/DocumentType.java.DocumentType.[void]setPubSysKey(String)",
        "name": "setPubSysKey",
        "arg_nums": 1,
        "params": [
            {
                "name": "value",
                "type": "String"
            }
        ],
        "return_type": "void",
        "signature": "public void setPubSysKey(@Nullable String value)",
        "original_string": "    public void setPubSysKey(@Nullable String value) {\n        if (value != null)\n            attr(PubSysKey, value);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/DocumentType.java",
        "class_name": "DocumentType",
        "class_uri": "src/main/java/org/jsoup/nodes/DocumentType.java.DocumentType",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/DocumentType.java.DocumentType.[void]updatePubSyskey()",
        "name": "updatePubSyskey",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "private void updatePubSyskey()",
        "original_string": "    private void updatePubSyskey() {\n        if (has(PublicId)) {\n            attr(PubSysKey, PUBLIC_KEY);\n        } else if (has(SystemId))\n            attr(PubSysKey, SYSTEM_KEY);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/DocumentType.java",
        "class_name": "DocumentType",
        "class_uri": "src/main/java/org/jsoup/nodes/DocumentType.java.DocumentType",
        "attributes": {
            "modifiers": "private",
            "marker_annotations": [],
            "non_marker_annotations": [
                "private"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/DocumentType.java.DocumentType.[String]name()",
        "name": "name",
        "arg_nums": 0,
        "params": [],
        "return_type": "String",
        "signature": "public String name()",
        "original_string": "    public String name() {\n        return attr(Name);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/DocumentType.java",
        "class_name": "DocumentType",
        "class_uri": "src/main/java/org/jsoup/nodes/DocumentType.java.DocumentType",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": "\nGet this doctype's name (when set, or empty string)\n@return doctype name\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/DocumentType.java.DocumentType.[String]publicId()",
        "name": "publicId",
        "arg_nums": 0,
        "params": [],
        "return_type": "String",
        "signature": "public String publicId()",
        "original_string": "    public String publicId() {\n        return attr(PublicId);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/DocumentType.java",
        "class_name": "DocumentType",
        "class_uri": "src/main/java/org/jsoup/nodes/DocumentType.java.DocumentType",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": "\nGet this doctype's Public ID (when set, or empty string)\n@return doctype Public ID\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/DocumentType.java.DocumentType.[String]systemId()",
        "name": "systemId",
        "arg_nums": 0,
        "params": [],
        "return_type": "String",
        "signature": "public String systemId()",
        "original_string": "    public String systemId() {\n        return attr(SystemId);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/DocumentType.java",
        "class_name": "DocumentType",
        "class_uri": "src/main/java/org/jsoup/nodes/DocumentType.java.DocumentType",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": "\nGet this doctype's System ID (when set, or empty string)\n@return doctype System ID\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/DocumentType.java.DocumentType.[String]nodeName()",
        "name": "nodeName",
        "arg_nums": 0,
        "params": [],
        "return_type": "String",
        "signature": "@Override\n    public String nodeName()",
        "original_string": "    @Override\n    public String nodeName() {\n        return Name;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/DocumentType.java",
        "class_name": "DocumentType",
        "class_uri": "src/main/java/org/jsoup/nodes/DocumentType.java.DocumentType",
        "attributes": {
            "modifiers": "@Override\n    public",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/DocumentType.java.DocumentType.[void]outerHtmlHead(Appendable,int,Document.OutputSettings)",
        "name": "outerHtmlHead",
        "arg_nums": 3,
        "params": [
            {
                "name": "accum",
                "type": "Appendable"
            },
            {
                "name": "depth",
                "type": "int"
            },
            {
                "name": "out",
                "type": "Document.OutputSettings"
            }
        ],
        "return_type": "void",
        "signature": "@Override\n    void outerHtmlHead(Appendable accum, int depth, Document.OutputSettings out)",
        "original_string": "    @Override\n    void outerHtmlHead(Appendable accum, int depth, Document.OutputSettings out) throws IOException {\n        // add a newline if the doctype has a preceding node (which must be a comment)\n        if (siblingIndex > 0 && out.prettyPrint())\n            accum.append('\\n');\n\n        if (out.syntax() == Syntax.html && !has(PublicId) && !has(SystemId)) {\n            // looks like a html5 doctype, go lowercase for aesthetics\n            accum.append(\"<!doctype\");\n        } else {\n            accum.append(\"<!DOCTYPE\");\n        }\n        if (has(Name))\n            accum.append(\" \").append(attr(Name));\n        if (has(PubSysKey))\n            accum.append(\" \").append(attr(PubSysKey));\n        if (has(PublicId))\n            accum.append(\" \\\"\").append(attr(PublicId)).append('\"');\n        if (has(SystemId))\n            accum.append(\" \\\"\").append(attr(SystemId)).append('\"');\n        accum.append('>');\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/DocumentType.java",
        "class_name": "DocumentType",
        "class_uri": "src/main/java/org/jsoup/nodes/DocumentType.java.DocumentType",
        "attributes": {
            "modifiers": "@Override",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/DocumentType.java.DocumentType.[void]outerHtmlTail(Appendable,int,Document.OutputSettings)",
        "name": "outerHtmlTail",
        "arg_nums": 3,
        "params": [
            {
                "name": "accum",
                "type": "Appendable"
            },
            {
                "name": "depth",
                "type": "int"
            },
            {
                "name": "out",
                "type": "Document.OutputSettings"
            }
        ],
        "return_type": "void",
        "signature": "@Override\n    void outerHtmlTail(Appendable accum, int depth, Document.OutputSettings out)",
        "original_string": "    @Override\n    void outerHtmlTail(Appendable accum, int depth, Document.OutputSettings out) {\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/DocumentType.java",
        "class_name": "DocumentType",
        "class_uri": "src/main/java/org/jsoup/nodes/DocumentType.java.DocumentType",
        "attributes": {
            "modifiers": "@Override",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/DocumentType.java.DocumentType.[boolean]has(String)",
        "name": "has",
        "arg_nums": 1,
        "params": [
            {
                "name": "attribute",
                "type": "String"
            }
        ],
        "return_type": "boolean",
        "signature": "private boolean has(final String attribute)",
        "original_string": "    private boolean has(final String attribute) {\n        return !StringUtil.isBlank(attr(attribute));\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/DocumentType.java",
        "class_name": "DocumentType",
        "class_uri": "src/main/java/org/jsoup/nodes/DocumentType.java.DocumentType",
        "attributes": {
            "modifiers": "private",
            "marker_annotations": [],
            "non_marker_annotations": [
                "private"
            ],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/CDataNode.java.CDataNode.[]CDataNode(String)",
        "name": "CDataNode",
        "arg_nums": 1,
        "params": [
            {
                "name": "text",
                "type": "String"
            }
        ],
        "return_type": "",
        "signature": "public CDataNode(String text)",
        "original_string": "    public CDataNode(String text) {\n        super(text);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/CDataNode.java",
        "class_name": "CDataNode",
        "class_uri": "src/main/java/org/jsoup/nodes/CDataNode.java.CDataNode",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/CDataNode.java.CDataNode.[String]nodeName()",
        "name": "nodeName",
        "arg_nums": 0,
        "params": [],
        "return_type": "String",
        "signature": "@Override\n    public String nodeName()",
        "original_string": "    @Override\n    public String nodeName() {\n        return \"#cdata\";\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/CDataNode.java",
        "class_name": "CDataNode",
        "class_uri": "src/main/java/org/jsoup/nodes/CDataNode.java.CDataNode",
        "attributes": {
            "modifiers": "@Override\n    public",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/CDataNode.java.CDataNode.[String]text()",
        "name": "text",
        "arg_nums": 0,
        "params": [],
        "return_type": "String",
        "signature": "@Override\n    public String text()",
        "original_string": "    @Override\n    public String text() {\n        return getWholeText();\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/CDataNode.java",
        "class_name": "CDataNode",
        "class_uri": "src/main/java/org/jsoup/nodes/CDataNode.java.CDataNode",
        "attributes": {
            "modifiers": "@Override\n    public",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": "\nGet the un-encoded, <b>non-normalized</b> text content of this CDataNode.\n@return un-encoded, non-normalized text\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/CDataNode.java.CDataNode.[void]outerHtmlHead(Appendable,int,Document.OutputSettings)",
        "name": "outerHtmlHead",
        "arg_nums": 3,
        "params": [
            {
                "name": "accum",
                "type": "Appendable"
            },
            {
                "name": "depth",
                "type": "int"
            },
            {
                "name": "out",
                "type": "Document.OutputSettings"
            }
        ],
        "return_type": "void",
        "signature": "@Override\n    void outerHtmlHead(Appendable accum, int depth, Document.OutputSettings out)",
        "original_string": "    @Override\n    void outerHtmlHead(Appendable accum, int depth, Document.OutputSettings out) throws IOException {\n        accum\n            .append(\"<![CDATA[\")\n            .append(getWholeText());\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/CDataNode.java",
        "class_name": "CDataNode",
        "class_uri": "src/main/java/org/jsoup/nodes/CDataNode.java.CDataNode",
        "attributes": {
            "modifiers": "@Override",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/CDataNode.java.CDataNode.[void]outerHtmlTail(Appendable,int,Document.OutputSettings)",
        "name": "outerHtmlTail",
        "arg_nums": 3,
        "params": [
            {
                "name": "accum",
                "type": "Appendable"
            },
            {
                "name": "depth",
                "type": "int"
            },
            {
                "name": "out",
                "type": "Document.OutputSettings"
            }
        ],
        "return_type": "void",
        "signature": "@Override\n    void outerHtmlTail(Appendable accum, int depth, Document.OutputSettings out)",
        "original_string": "    @Override\n    void outerHtmlTail(Appendable accum, int depth, Document.OutputSettings out) throws IOException {\n        accum.append(\"]]>\");\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/CDataNode.java",
        "class_name": "CDataNode",
        "class_uri": "src/main/java/org/jsoup/nodes/CDataNode.java.CDataNode",
        "attributes": {
            "modifiers": "@Override",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/CDataNode.java.CDataNode.[CDataNode]clone()",
        "name": "clone",
        "arg_nums": 0,
        "params": [],
        "return_type": "CDataNode",
        "signature": "@Override\n    public CDataNode clone()",
        "original_string": "    @Override\n    public CDataNode clone() {\n        return (CDataNode) super.clone();\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/CDataNode.java",
        "class_name": "CDataNode",
        "class_uri": "src/main/java/org/jsoup/nodes/CDataNode.java.CDataNode",
        "attributes": {
            "modifiers": "@Override\n    public",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "CDataNode",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/PseudoTextElement.java.PseudoTextElement.[]PseudoTextElement(Tag,String,Attributes)",
        "name": "PseudoTextElement",
        "arg_nums": 3,
        "params": [
            {
                "name": "tag",
                "type": "Tag"
            },
            {
                "name": "baseUri",
                "type": "String"
            },
            {
                "name": "attributes",
                "type": "Attributes"
            }
        ],
        "return_type": "",
        "signature": "public PseudoTextElement(Tag tag, String baseUri, Attributes attributes)",
        "original_string": "    public PseudoTextElement(Tag tag, String baseUri, Attributes attributes) {\n        super(tag, baseUri, attributes);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/PseudoTextElement.java",
        "class_name": "PseudoTextElement",
        "class_uri": "src/main/java/org/jsoup/nodes/PseudoTextElement.java.PseudoTextElement",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/PseudoTextElement.java.PseudoTextElement.[void]outerHtmlHead(Appendable,int,Document.OutputSettings)",
        "name": "outerHtmlHead",
        "arg_nums": 3,
        "params": [
            {
                "name": "accum",
                "type": "Appendable"
            },
            {
                "name": "depth",
                "type": "int"
            },
            {
                "name": "out",
                "type": "Document.OutputSettings"
            }
        ],
        "return_type": "void",
        "signature": "@Override\n    void outerHtmlHead(Appendable accum, int depth, Document.OutputSettings out)",
        "original_string": "    @Override\n    void outerHtmlHead(Appendable accum, int depth, Document.OutputSettings out) {\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/PseudoTextElement.java",
        "class_name": "PseudoTextElement",
        "class_uri": "src/main/java/org/jsoup/nodes/PseudoTextElement.java.PseudoTextElement",
        "attributes": {
            "modifiers": "@Override",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/PseudoTextElement.java.PseudoTextElement.[void]outerHtmlTail(Appendable,int,Document.OutputSettings)",
        "name": "outerHtmlTail",
        "arg_nums": 3,
        "params": [
            {
                "name": "accum",
                "type": "Appendable"
            },
            {
                "name": "depth",
                "type": "int"
            },
            {
                "name": "out",
                "type": "Document.OutputSettings"
            }
        ],
        "return_type": "void",
        "signature": "@Override\n    void outerHtmlTail(Appendable accum, int depth, Document.OutputSettings out)",
        "original_string": "    @Override\n    void outerHtmlTail(Appendable accum, int depth, Document.OutputSettings out) {\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/PseudoTextElement.java",
        "class_name": "PseudoTextElement",
        "class_uri": "src/main/java/org/jsoup/nodes/PseudoTextElement.java.PseudoTextElement",
        "attributes": {
            "modifiers": "@Override",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/TextNode.java.TextNode.[]TextNode(String)",
        "name": "TextNode",
        "arg_nums": 1,
        "params": [
            {
                "name": "text",
                "type": "String"
            }
        ],
        "return_type": "",
        "signature": "public TextNode(String text)",
        "original_string": "    public TextNode(String text) {\n        super(text);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/TextNode.java",
        "class_name": "TextNode",
        "class_uri": "src/main/java/org/jsoup/nodes/TextNode.java.TextNode",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "",
            "classes": []
        },
        "docstring": "\nCreate a new TextNode representing the supplied (unencoded) text).\n\n@param text raw text\n@see #createFromEncoded(String)\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/TextNode.java.TextNode.[String]nodeName()",
        "name": "nodeName",
        "arg_nums": 0,
        "params": [],
        "return_type": "String",
        "signature": "@Override public String nodeName()",
        "original_string": " @Override public String nodeName() {\n        return \"#text\";\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/TextNode.java",
        "class_name": "TextNode",
        "class_uri": "src/main/java/org/jsoup/nodes/TextNode.java.TextNode",
        "attributes": {
            "modifiers": "@Override public",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/TextNode.java.TextNode.[String]text()",
        "name": "text",
        "arg_nums": 0,
        "params": [],
        "return_type": "String",
        "signature": "public String text()",
        "original_string": "    public String text() {\n        return StringUtil.normaliseWhitespace(getWholeText());\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/TextNode.java",
        "class_name": "TextNode",
        "class_uri": "src/main/java/org/jsoup/nodes/TextNode.java.TextNode",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": "\nGet the text content of this text node.\n@return Unencoded, normalised text.\n@see TextNode#getWholeText()\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/TextNode.java.TextNode.[TextNode]text(String)",
        "name": "text",
        "arg_nums": 1,
        "params": [
            {
                "name": "text",
                "type": "String"
            }
        ],
        "return_type": "TextNode",
        "signature": "public TextNode text(String text)",
        "original_string": "    public TextNode text(String text) {\n        coreValue(text);\n        return this;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/TextNode.java",
        "class_name": "TextNode",
        "class_uri": "src/main/java/org/jsoup/nodes/TextNode.java.TextNode",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "TextNode",
            "classes": []
        },
        "docstring": "\nSet the text content of this text node.\n@param text unencoded text\n@return this, for chaining\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/TextNode.java.TextNode.[String]getWholeText()",
        "name": "getWholeText",
        "arg_nums": 0,
        "params": [],
        "return_type": "String",
        "signature": "public String getWholeText()",
        "original_string": "    public String getWholeText() {\n        return coreValue();\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/TextNode.java",
        "class_name": "TextNode",
        "class_uri": "src/main/java/org/jsoup/nodes/TextNode.java.TextNode",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": "\nGet the (unencoded) text of this text node, including any newlines and spaces present in the original.\n@return text\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/TextNode.java.TextNode.[boolean]isBlank()",
        "name": "isBlank",
        "arg_nums": 0,
        "params": [],
        "return_type": "boolean",
        "signature": "public boolean isBlank()",
        "original_string": "    public boolean isBlank() {\n        return StringUtil.isBlank(coreValue());\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/TextNode.java",
        "class_name": "TextNode",
        "class_uri": "src/main/java/org/jsoup/nodes/TextNode.java.TextNode",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": "\nTest if this text node is blank -- that is, empty or only whitespace (including newlines).\n@return true if this document is empty or only whitespace, false if it contains any text content.\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/TextNode.java.TextNode.[TextNode]splitText(int)",
        "name": "splitText",
        "arg_nums": 1,
        "params": [
            {
                "name": "offset",
                "type": "int"
            }
        ],
        "return_type": "TextNode",
        "signature": "public TextNode splitText(int offset)",
        "original_string": "    public TextNode splitText(int offset) {\n        final String text = coreValue();\n        Validate.isTrue(offset >= 0, \"Split offset must be not be negative\");\n        Validate.isTrue(offset < text.length(), \"Split offset must not be greater than current text length\");\n\n        String head = text.substring(0, offset);\n        String tail = text.substring(offset);\n        text(head);\n        TextNode tailNode = new TextNode(tail);\n        if (parentNode != null)\n            parentNode.addChildren(siblingIndex()+1, tailNode);\n\n        return tailNode;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/TextNode.java",
        "class_name": "TextNode",
        "class_uri": "src/main/java/org/jsoup/nodes/TextNode.java.TextNode",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "TextNode",
            "classes": []
        },
        "docstring": "\nSplit this text node into two nodes at the specified string offset. After splitting, this node will contain the\noriginal text up to the offset, and will have a new text node sibling containing the text after the offset.\n@param offset string offset point to split node at.\n@return the newly created text node containing the text after the offset.\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/TextNode.java.TextNode.[void]outerHtmlHead(Appendable,int,Document.OutputSettings)",
        "name": "outerHtmlHead",
        "arg_nums": 3,
        "params": [
            {
                "name": "accum",
                "type": "Appendable"
            },
            {
                "name": "depth",
                "type": "int"
            },
            {
                "name": "out",
                "type": "Document.OutputSettings"
            }
        ],
        "return_type": "void",
        "signature": "@Override\n    void outerHtmlHead(Appendable accum, int depth, Document.OutputSettings out)",
        "original_string": "    @Override\n    void outerHtmlHead(Appendable accum, int depth, Document.OutputSettings out) throws IOException {\n        final boolean prettyPrint = out.prettyPrint();\n        final boolean normaliseWhite = prettyPrint && !Element.preserveWhitespace(parentNode);\n        int escape = Entities.ForText;\n\n        if (normaliseWhite) {\n            escape |= Entities.Normalise;\n            final Element parent = parentNode instanceof Element ? ((Element) parentNode) : null;\n            final boolean trimLikeBlock = parent != null && (parent.tag().isBlock() || parent.tag().formatAsBlock());\n            if ((trimLikeBlock && siblingIndex == 0) || parentNode instanceof Document)\n                escape |= Entities.TrimLeading;\n            if (trimLikeBlock && nextSibling() == null)\n                escape |= Entities.TrimTrailing;\n\n            // if this text is just whitespace, and the next node will cause an indent, skip this text:\n            Node next = nextSibling();\n            Node prev = previousSibling();\n            boolean isBlank = isBlank();\n            boolean couldSkip = (next instanceof Element && ((Element) next).shouldIndent(out)) // next will indent\n                || (next instanceof TextNode && (((TextNode) next).isBlank())) // next is blank text, from re-parenting\n                || (prev instanceof Element && (((Element) prev).isBlock() || prev.nameIs(\"br\"))) // br is a bit special - make sure we don't get a dangling blank line, but not a block otherwise wraps in head\n                ;\n            if (couldSkip && isBlank) return;\n\n            if (\n                (prev == null && parent != null && parent.tag().formatAsBlock() && !isBlank) ||\n                (out.outline() && siblingNodes().size() > 0 && !isBlank) ||\n                (prev != null && prev.nameIs(\"br\")) // special case wrap on inline <br> - doesn't make sense as a block tag\n            )\n                indent(accum, depth, out);\n        }\n\n        Entities.escape(accum, coreValue(), out, escape);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/TextNode.java",
        "class_name": "TextNode",
        "class_uri": "src/main/java/org/jsoup/nodes/TextNode.java.TextNode",
        "attributes": {
            "modifiers": "@Override",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/TextNode.java.TextNode.[void]outerHtmlTail(Appendable,int,Document.OutputSettings)",
        "name": "outerHtmlTail",
        "arg_nums": 3,
        "params": [
            {
                "name": "accum",
                "type": "Appendable"
            },
            {
                "name": "depth",
                "type": "int"
            },
            {
                "name": "out",
                "type": "Document.OutputSettings"
            }
        ],
        "return_type": "void",
        "signature": "@Override\n    void outerHtmlTail(Appendable accum, int depth, Document.OutputSettings out)",
        "original_string": "    @Override\n    void outerHtmlTail(Appendable accum, int depth, Document.OutputSettings out) throws IOException {}",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/TextNode.java",
        "class_name": "TextNode",
        "class_uri": "src/main/java/org/jsoup/nodes/TextNode.java.TextNode",
        "attributes": {
            "modifiers": "@Override",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/TextNode.java.TextNode.[String]toString()",
        "name": "toString",
        "arg_nums": 0,
        "params": [],
        "return_type": "String",
        "signature": "@Override\n    public String toString()",
        "original_string": "    @Override\n    public String toString() {\n        return outerHtml();\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/TextNode.java",
        "class_name": "TextNode",
        "class_uri": "src/main/java/org/jsoup/nodes/TextNode.java.TextNode",
        "attributes": {
            "modifiers": "@Override\n    public",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/TextNode.java.TextNode.[TextNode]clone()",
        "name": "clone",
        "arg_nums": 0,
        "params": [],
        "return_type": "TextNode",
        "signature": "@Override\n    public TextNode clone()",
        "original_string": "    @Override\n    public TextNode clone() {\n        return (TextNode) super.clone();\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/TextNode.java",
        "class_name": "TextNode",
        "class_uri": "src/main/java/org/jsoup/nodes/TextNode.java.TextNode",
        "attributes": {
            "modifiers": "@Override\n    public",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "TextNode",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/TextNode.java.TextNode.[TextNode]createFromEncoded(String)",
        "name": "createFromEncoded",
        "arg_nums": 1,
        "params": [
            {
                "name": "encodedText",
                "type": "String"
            }
        ],
        "return_type": "TextNode",
        "signature": "public static TextNode createFromEncoded(String encodedText)",
        "original_string": "    public static TextNode createFromEncoded(String encodedText) {\n        String text = Entities.unescape(encodedText);\n        return new TextNode(text);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/TextNode.java",
        "class_name": "TextNode",
        "class_uri": "src/main/java/org/jsoup/nodes/TextNode.java.TextNode",
        "attributes": {
            "modifiers": "public static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public",
                "static"
            ],
            "comments": [],
            "return_type": "TextNode",
            "classes": []
        },
        "docstring": "\nCreate a new TextNode from HTML encoded (aka escaped) data.\n@param encodedText Text containing encoded HTML (e.g. {@code &lt;})\n@return TextNode containing unencoded data (e.g. {@code <})\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/TextNode.java.TextNode.[String]normaliseWhitespace(String)",
        "name": "normaliseWhitespace",
        "arg_nums": 1,
        "params": [
            {
                "name": "text",
                "type": "String"
            }
        ],
        "return_type": "String",
        "signature": "static String normaliseWhitespace(String text)",
        "original_string": "    static String normaliseWhitespace(String text) {\n        text = StringUtil.normaliseWhitespace(text);\n        return text;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/TextNode.java",
        "class_name": "TextNode",
        "class_uri": "src/main/java/org/jsoup/nodes/TextNode.java.TextNode",
        "attributes": {
            "modifiers": "static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "static"
            ],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/TextNode.java.TextNode.[String]stripLeadingWhitespace(String)",
        "name": "stripLeadingWhitespace",
        "arg_nums": 1,
        "params": [
            {
                "name": "text",
                "type": "String"
            }
        ],
        "return_type": "String",
        "signature": "static String stripLeadingWhitespace(String text)",
        "original_string": "    static String stripLeadingWhitespace(String text) {\n        return text.replaceFirst(\"^\\\\s+\", \"\");\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/TextNode.java",
        "class_name": "TextNode",
        "class_uri": "src/main/java/org/jsoup/nodes/TextNode.java.TextNode",
        "attributes": {
            "modifiers": "static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "static"
            ],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/TextNode.java.TextNode.[boolean]lastCharIsWhitespace(StringBuilder)",
        "name": "lastCharIsWhitespace",
        "arg_nums": 1,
        "params": [
            {
                "name": "sb",
                "type": "StringBuilder"
            }
        ],
        "return_type": "boolean",
        "signature": "static boolean lastCharIsWhitespace(StringBuilder sb)",
        "original_string": "    static boolean lastCharIsWhitespace(StringBuilder sb) {\n        return sb.length() != 0 && sb.charAt(sb.length() - 1) == ' ';\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/TextNode.java",
        "class_name": "TextNode",
        "class_uri": "src/main/java/org/jsoup/nodes/TextNode.java.TextNode",
        "attributes": {
            "modifiers": "static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "static"
            ],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Element.java.Element.[]Element(String,String)",
        "name": "Element",
        "arg_nums": 2,
        "params": [
            {
                "name": "tag",
                "type": "String"
            },
            {
                "name": "namespace",
                "type": "String"
            }
        ],
        "return_type": "",
        "signature": "public Element(String tag, String namespace)",
        "original_string": "    public Element(String tag, String namespace) {\n        this(Tag.valueOf(tag, namespace, ParseSettings.preserveCase), null);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "Element",
        "class_uri": "src/main/java/org/jsoup/nodes/Element.java.Element",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "",
            "classes": []
        },
        "docstring": "\nCreate a new, standalone element, in the specified namespace.\n@param tag tag name\n@param namespace namespace for this element\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Element.java.Element.[]Element(String)",
        "name": "Element",
        "arg_nums": 1,
        "params": [
            {
                "name": "tag",
                "type": "String"
            }
        ],
        "return_type": "",
        "signature": "public Element(String tag)",
        "original_string": "    public Element(String tag) {\n        this(Tag.valueOf(tag, Parser.NamespaceHtml, ParseSettings.preserveCase), \"\", null);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "Element",
        "class_uri": "src/main/java/org/jsoup/nodes/Element.java.Element",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "",
            "classes": []
        },
        "docstring": "\nCreate a new, standalone element, in the HTML namespace.\n@param tag tag name\n@see #Element(String tag, String namespace)\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Element.java.Element.[]Element(Tag,String,Attributes)",
        "name": "Element",
        "arg_nums": 3,
        "params": [
            {
                "name": "tag",
                "type": "Tag"
            },
            {
                "name": "baseUri",
                "type": "String"
            },
            {
                "name": "attributes",
                "type": "Attributes"
            }
        ],
        "return_type": "",
        "signature": "public Element(Tag tag, @Nullable String baseUri, @Nullable Attributes attributes)",
        "original_string": "    public Element(Tag tag, @Nullable String baseUri, @Nullable Attributes attributes) {\n        Validate.notNull(tag);\n        childNodes = EmptyNodes;\n        this.attributes = attributes;\n        this.tag = tag;\n        if (baseUri != null)\n            this.setBaseUri(baseUri);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "Element",
        "class_uri": "src/main/java/org/jsoup/nodes/Element.java.Element",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "",
            "classes": []
        },
        "docstring": "\nCreate a new, standalone Element. (Standalone in that it has no parent.)\n\n@param tag tag of this element\n@param baseUri the base URI (optional, may be null to inherit from parent, or \"\" to clear parent's)\n@param attributes initial attributes (optional, may be null)\n@see #appendChild(Node)\n@see #appendElement(String)\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Element.java.Element.[]Element(Tag,String)",
        "name": "Element",
        "arg_nums": 2,
        "params": [
            {
                "name": "tag",
                "type": "Tag"
            },
            {
                "name": "baseUri",
                "type": "String"
            }
        ],
        "return_type": "",
        "signature": "public Element(Tag tag, @Nullable String baseUri)",
        "original_string": "    public Element(Tag tag, @Nullable String baseUri) {\n        this(tag, baseUri, null);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "Element",
        "class_uri": "src/main/java/org/jsoup/nodes/Element.java.Element",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "",
            "classes": []
        },
        "docstring": "\nCreate a new Element from a Tag and a base URI.\n\n@param tag element tag\n@param baseUri the base URI of this element. Optional, and will inherit from its parent, if any.\n@see Tag#valueOf(String, ParseSettings)\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Element.java.Element.[boolean]hasChildNodes()",
        "name": "hasChildNodes",
        "arg_nums": 0,
        "params": [],
        "return_type": "boolean",
        "signature": "protected boolean hasChildNodes()",
        "original_string": "    protected boolean hasChildNodes() {\n        return childNodes != EmptyNodes;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "Element",
        "class_uri": "src/main/java/org/jsoup/nodes/Element.java.Element",
        "attributes": {
            "modifiers": "protected",
            "marker_annotations": [],
            "non_marker_annotations": [
                "protected"
            ],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": "\nInternal test to check if a nodelist object has been created.\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Element.java.Element.[List<Node>]ensureChildNodes()",
        "name": "ensureChildNodes",
        "arg_nums": 0,
        "params": [],
        "return_type": "List<Node>",
        "signature": "@Override protected List<Node> ensureChildNodes()",
        "original_string": "    @Override protected List<Node> ensureChildNodes() {\n        if (childNodes == EmptyNodes) {\n            childNodes = new NodeList(this, 4);\n        }\n        return childNodes;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "Element",
        "class_uri": "src/main/java/org/jsoup/nodes/Element.java.Element",
        "attributes": {
            "modifiers": "@Override protected",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "protected"
            ],
            "comments": [],
            "return_type": "List<Node>",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Element.java.Element.[boolean]hasAttributes()",
        "name": "hasAttributes",
        "arg_nums": 0,
        "params": [],
        "return_type": "boolean",
        "signature": "@Override\n    protected boolean hasAttributes()",
        "original_string": "    @Override\n    protected boolean hasAttributes() {\n        return attributes != null;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "Element",
        "class_uri": "src/main/java/org/jsoup/nodes/Element.java.Element",
        "attributes": {
            "modifiers": "@Override\n    protected",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "protected"
            ],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Element.java.Element.[Attributes]attributes()",
        "name": "attributes",
        "arg_nums": 0,
        "params": [],
        "return_type": "Attributes",
        "signature": "@Override\n    public Attributes attributes()",
        "original_string": "    @Override\n    public Attributes attributes() {\n        if (attributes == null) // not using hasAttributes, as doesn't clear warning\n            attributes = new Attributes();\n        return attributes;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "Element",
        "class_uri": "src/main/java/org/jsoup/nodes/Element.java.Element",
        "attributes": {
            "modifiers": "@Override\n    public",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Attributes",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Element.java.Element.[String]baseUri()",
        "name": "baseUri",
        "arg_nums": 0,
        "params": [],
        "return_type": "String",
        "signature": "@Override\n    public String baseUri()",
        "original_string": "    @Override\n    public String baseUri() {\n        return searchUpForAttribute(this, BaseUriKey);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "Element",
        "class_uri": "src/main/java/org/jsoup/nodes/Element.java.Element",
        "attributes": {
            "modifiers": "@Override\n    public",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Element.java.Element.[String]searchUpForAttribute(Element,String)",
        "name": "searchUpForAttribute",
        "arg_nums": 2,
        "params": [
            {
                "name": "start",
                "type": "Element"
            },
            {
                "name": "key",
                "type": "String"
            }
        ],
        "return_type": "String",
        "signature": "private static String searchUpForAttribute(final Element start, final String key)",
        "original_string": "    private static String searchUpForAttribute(final Element start, final String key) {\n        Element el = start;\n        while (el != null) {\n            if (el.attributes != null && el.attributes.hasKey(key))\n                return el.attributes.get(key);\n            el = el.parent();\n        }\n        return \"\";\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "Element",
        "class_uri": "src/main/java/org/jsoup/nodes/Element.java.Element",
        "attributes": {
            "modifiers": "private static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "private",
                "static"
            ],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Element.java.Element.[void]doSetBaseUri(String)",
        "name": "doSetBaseUri",
        "arg_nums": 1,
        "params": [
            {
                "name": "baseUri",
                "type": "String"
            }
        ],
        "return_type": "void",
        "signature": "@Override\n    protected void doSetBaseUri(String baseUri)",
        "original_string": "    @Override\n    protected void doSetBaseUri(String baseUri) {\n        attributes().put(BaseUriKey, baseUri);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "Element",
        "class_uri": "src/main/java/org/jsoup/nodes/Element.java.Element",
        "attributes": {
            "modifiers": "@Override\n    protected",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "protected"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Element.java.Element.[int]childNodeSize()",
        "name": "childNodeSize",
        "arg_nums": 0,
        "params": [],
        "return_type": "int",
        "signature": "@Override\n    public int childNodeSize()",
        "original_string": "    @Override\n    public int childNodeSize() {\n        return childNodes.size();\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "Element",
        "class_uri": "src/main/java/org/jsoup/nodes/Element.java.Element",
        "attributes": {
            "modifiers": "@Override\n    public",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "int",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Element.java.Element.[String]nodeName()",
        "name": "nodeName",
        "arg_nums": 0,
        "params": [],
        "return_type": "String",
        "signature": "@Override\n    public String nodeName()",
        "original_string": "    @Override\n    public String nodeName() {\n        return tag.getName();\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "Element",
        "class_uri": "src/main/java/org/jsoup/nodes/Element.java.Element",
        "attributes": {
            "modifiers": "@Override\n    public",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Element.java.Element.[String]tagName()",
        "name": "tagName",
        "arg_nums": 0,
        "params": [],
        "return_type": "String",
        "signature": "public String tagName()",
        "original_string": "    public String tagName() {\n        return tag.getName();\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "Element",
        "class_uri": "src/main/java/org/jsoup/nodes/Element.java.Element",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": "\nGet the name of the tag for this element. E.g. {@code div}. If you are using {@link ParseSettings#preserveCase\ncase preserving parsing}, this will return the source's original case.\n\n@return the tag name\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Element.java.Element.[String]normalName()",
        "name": "normalName",
        "arg_nums": 0,
        "params": [],
        "return_type": "String",
        "signature": "@Override\n    public String normalName()",
        "original_string": "    @Override\n    public String normalName() {\n        return tag.normalName();\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "Element",
        "class_uri": "src/main/java/org/jsoup/nodes/Element.java.Element",
        "attributes": {
            "modifiers": "@Override\n    public",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": "\nGet the normalized name of this Element's tag. This will always be the lower-cased version of the tag, regardless\nof the tag case preserving setting of the parser. For e.g., {@code <DIV>} and {@code <div>} both have a\nnormal name of {@code div}.\n@return normal name\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Element.java.Element.[boolean]elementIs(String,String)",
        "name": "elementIs",
        "arg_nums": 2,
        "params": [
            {
                "name": "normalName",
                "type": "String"
            },
            {
                "name": "namespace",
                "type": "String"
            }
        ],
        "return_type": "boolean",
        "signature": "public boolean elementIs(String normalName, String namespace)",
        "original_string": "    public boolean elementIs(String normalName, String namespace) {\n        return tag.normalName().equals(normalName) && tag.namespace().equals(namespace);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "Element",
        "class_uri": "src/main/java/org/jsoup/nodes/Element.java.Element",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": "\nTest if this Element has the specified normalized name, and is in the specified namespace.\n@param normalName a normalized element name (e.g. {@code div}).\n@param namespace the namespace\n@return true if the element's normal name matches exactly, and is in the specified namespace\n@since 1.17.2\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Element.java.Element.[Element]tagName(String)",
        "name": "tagName",
        "arg_nums": 1,
        "params": [
            {
                "name": "tagName",
                "type": "String"
            }
        ],
        "return_type": "Element",
        "signature": "public Element tagName(String tagName)",
        "original_string": "    public Element tagName(String tagName) {\n        return tagName(tagName, tag.namespace());\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "Element",
        "class_uri": "src/main/java/org/jsoup/nodes/Element.java.Element",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Element",
            "classes": []
        },
        "docstring": "\nChange (rename) the tag of this element. For example, convert a {@code <span>} to a {@code <div>} with\n{@code el.tagName(\"div\");}.\n\n@param tagName new tag name for this element\n@return this element, for chaining\n@see Elements#tagName(String)\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Element.java.Element.[Element]tagName(String,String)",
        "name": "tagName",
        "arg_nums": 2,
        "params": [
            {
                "name": "tagName",
                "type": "String"
            },
            {
                "name": "namespace",
                "type": "String"
            }
        ],
        "return_type": "Element",
        "signature": "public Element tagName(String tagName, String namespace)",
        "original_string": "    public Element tagName(String tagName, String namespace) {\n        Validate.notEmptyParam(tagName, \"tagName\");\n        Validate.notEmptyParam(namespace, \"namespace\");\n        tag = Tag.valueOf(tagName, namespace, NodeUtils.parser(this).settings()); // maintains the case option of the original parse\n        return this;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "Element",
        "class_uri": "src/main/java/org/jsoup/nodes/Element.java.Element",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Element",
            "classes": []
        },
        "docstring": "\nChange (rename) the tag of this element. For example, convert a {@code <span>} to a {@code <div>} with\n{@code el.tagName(\"div\");}.\n\n@param tagName new tag name for this element\n@param namespace the new namespace for this element\n@return this element, for chaining\n@see Elements#tagName(String)\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Element.java.Element.[Tag]tag()",
        "name": "tag",
        "arg_nums": 0,
        "params": [],
        "return_type": "Tag",
        "signature": "public Tag tag()",
        "original_string": "    public Tag tag() {\n        return tag;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "Element",
        "class_uri": "src/main/java/org/jsoup/nodes/Element.java.Element",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Tag",
            "classes": []
        },
        "docstring": "\nGet the Tag for this element.\n\n@return the tag object\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Element.java.Element.[boolean]isBlock()",
        "name": "isBlock",
        "arg_nums": 0,
        "params": [],
        "return_type": "boolean",
        "signature": "public boolean isBlock()",
        "original_string": "    public boolean isBlock() {\n        return tag.isBlock();\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "Element",
        "class_uri": "src/main/java/org/jsoup/nodes/Element.java.Element",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": "\nTest if this element is a block-level element. (E.g. {@code <div> == true} or an inline element\n{@code <span> == false}).\n\n@return true if block, false if not (and thus inline)\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Element.java.Element.[String]id()",
        "name": "id",
        "arg_nums": 0,
        "params": [],
        "return_type": "String",
        "signature": "public String id()",
        "original_string": "    public String id() {\n        return attributes != null ? attributes.getIgnoreCase(\"id\") :\"\";\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "Element",
        "class_uri": "src/main/java/org/jsoup/nodes/Element.java.Element",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": "\nGet the {@code id} attribute of this element.\n\n@return The id attribute, if present, or an empty string if not.\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Element.java.Element.[Element]id(String)",
        "name": "id",
        "arg_nums": 1,
        "params": [
            {
                "name": "id",
                "type": "String"
            }
        ],
        "return_type": "Element",
        "signature": "public Element id(String id)",
        "original_string": "    public Element id(String id) {\n        Validate.notNull(id);\n        attr(\"id\", id);\n        return this;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "Element",
        "class_uri": "src/main/java/org/jsoup/nodes/Element.java.Element",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Element",
            "classes": []
        },
        "docstring": "\nSet the {@code id} attribute of this element.\n@param id the ID value to use\n@return this Element, for chaining\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Element.java.Element.[Element]attr(String,String)",
        "name": "attr",
        "arg_nums": 2,
        "params": [
            {
                "name": "attributeKey",
                "type": "String"
            },
            {
                "name": "attributeValue",
                "type": "String"
            }
        ],
        "return_type": "Element",
        "signature": "@Override public Element attr(String attributeKey, String attributeValue)",
        "original_string": "    @Override public Element attr(String attributeKey, String attributeValue) {\n        super.attr(attributeKey, attributeValue);\n        return this;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "Element",
        "class_uri": "src/main/java/org/jsoup/nodes/Element.java.Element",
        "attributes": {
            "modifiers": "@Override public",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Element",
            "classes": []
        },
        "docstring": "\nSet an attribute value on this element. If this element already has an attribute with the\nkey, its value is updated; otherwise, a new attribute is added.\n\n@return this element\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Element.java.Element.[Element]attr(String,boolean)",
        "name": "attr",
        "arg_nums": 2,
        "params": [
            {
                "name": "attributeKey",
                "type": "String"
            },
            {
                "name": "attributeValue",
                "type": "boolean"
            }
        ],
        "return_type": "Element",
        "signature": "public Element attr(String attributeKey, boolean attributeValue)",
        "original_string": "    public Element attr(String attributeKey, boolean attributeValue) {\n        attributes().put(attributeKey, attributeValue);\n        return this;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "Element",
        "class_uri": "src/main/java/org/jsoup/nodes/Element.java.Element",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Element",
            "classes": []
        },
        "docstring": "\nSet a boolean attribute value on this element. Setting to <code>true</code> sets the attribute value to \"\" and\nmarks the attribute as boolean so no value is written out. Setting to <code>false</code> removes the attribute\nwith the same key if it exists.\n\n@param attributeKey the attribute key\n@param attributeValue the attribute value\n\n@return this element\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Element.java.Element.[Attribute]attribute(String)",
        "name": "attribute",
        "arg_nums": 1,
        "params": [
            {
                "name": "key",
                "type": "String"
            }
        ],
        "return_type": "Attribute",
        "signature": "@Nullable public Attribute attribute(String key)",
        "original_string": "    @Nullable public Attribute attribute(String key) {\n        return hasAttributes() ? attributes().attribute(key) : null;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "Element",
        "class_uri": "src/main/java/org/jsoup/nodes/Element.java.Element",
        "attributes": {
            "modifiers": "@Nullable public",
            "marker_annotations": [
                "@Nullable"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Attribute",
            "classes": []
        },
        "docstring": "\nGet an Attribute by key. Changes made via {@link Attribute#setKey(String)}, {@link Attribute#setValue(String)} etc\nwill cascade back to this Element.\n@param key the (case-sensitive) attribute key\n@return the Attribute for this key, or null if not present.\n@since 1.17.2\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Element.java.Element.[Map<String, String>]dataset()",
        "name": "dataset",
        "arg_nums": 0,
        "params": [],
        "return_type": "Map<String, String>",
        "signature": "public Map<String, String> dataset()",
        "original_string": "    public Map<String, String> dataset() {\n        return attributes().dataset();\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "Element",
        "class_uri": "src/main/java/org/jsoup/nodes/Element.java.Element",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Map<String, String>",
            "classes": []
        },
        "docstring": "\nGet this element's HTML5 custom data attributes. Each attribute in the element that has a key\nstarting with \"data-\" is included the dataset.\n<p>\nE.g., the element {@code <div data-package=\"jsoup\" data-language=\"Java\" class=\"group\">...} has the dataset\n{@code package=jsoup, language=java}.\n<p>\nThis map is a filtered view of the element's attribute map. Changes to one map (add, remove, update) are reflected\nin the other map.\n<p>\nYou can find elements that have data attributes using the {@code [^data-]} attribute key prefix selector.\n@return a map of {@code key=value} custom data attributes.\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Element.java.Element.[Element]parent()",
        "name": "parent",
        "arg_nums": 0,
        "params": [],
        "return_type": "Element",
        "signature": "@Override @Nullable\n    public final Element parent()",
        "original_string": "    @Override @Nullable\n    public final Element parent() {\n        return (Element) parentNode;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "Element",
        "class_uri": "src/main/java/org/jsoup/nodes/Element.java.Element",
        "attributes": {
            "modifiers": "@Override @Nullable\n    public final",
            "marker_annotations": [
                "@Override",
                "@Nullable"
            ],
            "non_marker_annotations": [
                "public",
                "final"
            ],
            "comments": [],
            "return_type": "Element",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Element.java.Element.[Elements]parents()",
        "name": "parents",
        "arg_nums": 0,
        "params": [],
        "return_type": "Elements",
        "signature": "public Elements parents()",
        "original_string": "    public Elements parents() {\n        Elements parents = new Elements();\n        Element parent = this.parent();\n        while (parent != null && !parent.nameIs(\"#root\")) {\n            parents.add(parent);\n            parent = parent.parent();\n        }\n        return parents;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "Element",
        "class_uri": "src/main/java/org/jsoup/nodes/Element.java.Element",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Elements",
            "classes": []
        },
        "docstring": "\nGet this element's parent and ancestors, up to the document root.\n@return this element's stack of parents, starting with the closest first.\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Element.java.Element.[Element]child(int)",
        "name": "child",
        "arg_nums": 1,
        "params": [
            {
                "name": "index",
                "type": "int"
            }
        ],
        "return_type": "Element",
        "signature": "public Element child(int index)",
        "original_string": "    public Element child(int index) {\n        return childElementsList().get(index);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "Element",
        "class_uri": "src/main/java/org/jsoup/nodes/Element.java.Element",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Element",
            "classes": []
        },
        "docstring": "\nGet a child element of this element, by its 0-based index number.\n<p>\nNote that an element can have both mixed Nodes and Elements as children. This method inspects\na filtered list of children that are elements, and the index is based on that filtered list.\n</p>\n\n@param index the index number of the element to retrieve\n@return the child element, if it exists, otherwise throws an {@code IndexOutOfBoundsException}\n@see #childNode(int)\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Element.java.Element.[int]childrenSize()",
        "name": "childrenSize",
        "arg_nums": 0,
        "params": [],
        "return_type": "int",
        "signature": "public int childrenSize()",
        "original_string": "    public int childrenSize() {\n        return childElementsList().size();\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "Element",
        "class_uri": "src/main/java/org/jsoup/nodes/Element.java.Element",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "int",
            "classes": []
        },
        "docstring": "\nGet the number of child nodes of this element that are elements.\n<p>\nThis method works on the same filtered list like {@link #child(int)}. Use {@link #childNodes()} and {@link\n#childNodeSize()} to get the unfiltered Nodes (e.g. includes TextNodes etc.)\n</p>\n\n@return the number of child nodes that are elements\n@see #children()\n@see #child(int)\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Element.java.Element.[Elements]children()",
        "name": "children",
        "arg_nums": 0,
        "params": [],
        "return_type": "Elements",
        "signature": "public Elements children()",
        "original_string": "    public Elements children() {\n        return new Elements(childElementsList());\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "Element",
        "class_uri": "src/main/java/org/jsoup/nodes/Element.java.Element",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Elements",
            "classes": []
        },
        "docstring": "\nGet this element's child elements.\n<p>\nThis is effectively a filter on {@link #childNodes()} to get Element nodes.\n</p>\n@return child elements. If this element has no children, returns an empty list.\n@see #childNodes()\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Element.java.Element.[List<Element>]childElementsList()",
        "name": "childElementsList",
        "arg_nums": 0,
        "params": [],
        "return_type": "List<Element>",
        "signature": "List<Element> childElementsList()",
        "original_string": "    List<Element> childElementsList() {\n        if (childNodeSize() == 0)\n            return EmptyChildren; // short circuit creating empty\n\n        List<Element> children;\n        if (shadowChildrenRef == null || (children = shadowChildrenRef.get()) == null) {\n            final int size = childNodes.size();\n            children = new ArrayList<>(size);\n            //noinspection ForLoopReplaceableByForEach (beacause it allocates an Iterator which is wasteful here)\n            for (int i = 0; i < size; i++) {\n                final Node node = childNodes.get(i);\n                if (node instanceof Element)\n                    children.add((Element) node);\n            }\n            shadowChildrenRef = new WeakReference<>(children);\n        }\n        return children;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "Element",
        "class_uri": "src/main/java/org/jsoup/nodes/Element.java.Element",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "List<Element>",
            "classes": []
        },
        "docstring": "\nMaintains a shadow copy of this element's child elements. If the nodelist is changed, this cache is invalidated.\nTODO - think about pulling this out as a helper as there are other shadow lists (like in Attributes) kept around.\n@return a list of child elements\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Element.java.Element.[void]nodelistChanged()",
        "name": "nodelistChanged",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "@Override\n    void nodelistChanged()",
        "original_string": "    @Override\n    void nodelistChanged() {\n        super.nodelistChanged();\n        shadowChildrenRef = null;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "Element",
        "class_uri": "src/main/java/org/jsoup/nodes/Element.java.Element",
        "attributes": {
            "modifiers": "@Override",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": "\nClears the cached shadow child elements.\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Element.java.Element.[Stream<Element>]stream()",
        "name": "stream",
        "arg_nums": 0,
        "params": [],
        "return_type": "Stream<Element>",
        "signature": "public Stream<Element> stream()",
        "original_string": "    public Stream<Element> stream() {\n        return NodeUtils.stream(this, Element.class);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "Element",
        "class_uri": "src/main/java/org/jsoup/nodes/Element.java.Element",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Stream<Element>",
            "classes": []
        },
        "docstring": "\nReturns a Stream of this Element and all of its descendant Elements. The stream has document order.\n@return a stream of this element and its descendants.\n@see #nodeStream()\n@since 1.17.1\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Element.java.Element.[List<T>]filterNodes(Class<T>)",
        "name": "filterNodes",
        "arg_nums": 1,
        "params": [
            {
                "name": "clazz",
                "type": "Class<T>"
            }
        ],
        "return_type": "List<T>",
        "signature": "private <T> List<T> filterNodes(Class<T> clazz)",
        "original_string": "    private <T> List<T> filterNodes(Class<T> clazz) {\n        return childNodes.stream()\n                .filter(clazz::isInstance)\n                .map(clazz::cast)\n                .collect(Collectors.collectingAndThen(Collectors.toList(), Collections::unmodifiableList));\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "Element",
        "class_uri": "src/main/java/org/jsoup/nodes/Element.java.Element",
        "attributes": {
            "modifiers": "private",
            "marker_annotations": [],
            "non_marker_annotations": [
                "private"
            ],
            "comments": [],
            "return_type": "List<T>",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Element.java.Element.[List<TextNode>]textNodes()",
        "name": "textNodes",
        "arg_nums": 0,
        "params": [],
        "return_type": "List<TextNode>",
        "signature": "public List<TextNode> textNodes()",
        "original_string": "    public List<TextNode> textNodes() {\n        return filterNodes(TextNode.class);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "Element",
        "class_uri": "src/main/java/org/jsoup/nodes/Element.java.Element",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "List<TextNode>",
            "classes": []
        },
        "docstring": "\nGet this element's child text nodes. The list is unmodifiable but the text nodes may be manipulated.\n<p>\nThis is effectively a filter on {@link #childNodes()} to get Text nodes.\n@return child text nodes. If this element has no text nodes, returns an\nempty list.\n</p>\nFor example, with the input HTML: {@code <p>One <span>Two</span> Three <br> Four</p>} with the {@code p} element selected:\n<ul>\n    <li>{@code p.text()} = {@code \"One Two Three Four\"}</li>\n    <li>{@code p.ownText()} = {@code \"One Three Four\"}</li>\n    <li>{@code p.children()} = {@code Elements[<span>, <br>]}</li>\n    <li>{@code p.childNodes()} = {@code List<Node>[\"One \", <span>, \" Three \", <br>, \" Four\"]}</li>\n    <li>{@code p.textNodes()} = {@code List<TextNode>[\"One \", \" Three \", \" Four\"]}</li>\n</ul>\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Element.java.Element.[List<DataNode>]dataNodes()",
        "name": "dataNodes",
        "arg_nums": 0,
        "params": [],
        "return_type": "List<DataNode>",
        "signature": "public List<DataNode> dataNodes()",
        "original_string": "    public List<DataNode> dataNodes() {\n        return filterNodes(DataNode.class);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "Element",
        "class_uri": "src/main/java/org/jsoup/nodes/Element.java.Element",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "List<DataNode>",
            "classes": []
        },
        "docstring": "\nGet this element's child data nodes. The list is unmodifiable but the data nodes may be manipulated.\n<p>\nThis is effectively a filter on {@link #childNodes()} to get Data nodes.\n</p>\n@return child data nodes. If this element has no data nodes, returns an\nempty list.\n@see #data()\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Element.java.Element.[Elements]select(String)",
        "name": "select",
        "arg_nums": 1,
        "params": [
            {
                "name": "cssQuery",
                "type": "String"
            }
        ],
        "return_type": "Elements",
        "signature": "public Elements select(String cssQuery)",
        "original_string": "    public Elements select(String cssQuery) {\n        return Selector.select(cssQuery, this);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "Element",
        "class_uri": "src/main/java/org/jsoup/nodes/Element.java.Element",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Elements",
            "classes": []
        },
        "docstring": "\nFind elements that match the {@link Selector} CSS query, with this element as the starting context. Matched elements\nmay include this element, or any of its children.\n<p>This method is generally more powerful to use than the DOM-type {@code getElementBy*} methods, because\nmultiple filters can be combined, e.g.:</p>\n<ul>\n<li>{@code el.select(\"a[href]\")} - finds links ({@code a} tags with {@code href} attributes)\n<li>{@code el.select(\"a[href*=example.com]\")} - finds links pointing to example.com (loosely)\n</ul>\n<p>See the query syntax documentation in {@link org.jsoup.select.Selector}.</p>\n<p>Also known as {@code querySelectorAll()} in the Web DOM.</p>\n\n@param cssQuery a {@link Selector} CSS-like query\n@return an {@link Elements} list containing elements that match the query (empty if none match)\n@see Selector selector query syntax\n@see QueryParser#parse(String)\n@throws Selector.SelectorParseException (unchecked) on an invalid CSS query.\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Element.java.Element.[Elements]select(Evaluator)",
        "name": "select",
        "arg_nums": 1,
        "params": [
            {
                "name": "evaluator",
                "type": "Evaluator"
            }
        ],
        "return_type": "Elements",
        "signature": "public Elements select(Evaluator evaluator)",
        "original_string": "    public Elements select(Evaluator evaluator) {\n        return Selector.select(evaluator, this);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "Element",
        "class_uri": "src/main/java/org/jsoup/nodes/Element.java.Element",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Elements",
            "classes": []
        },
        "docstring": "\nFind elements that match the supplied Evaluator. This has the same functionality as {@link #select(String)}, but\nmay be useful if you are running the same query many times (on many documents) and want to save the overhead of\nrepeatedly parsing the CSS query.\n@param evaluator an element evaluator\n@return an {@link Elements} list containing elements that match the query (empty if none match)\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Element.java.Element.[Element]selectFirst(String)",
        "name": "selectFirst",
        "arg_nums": 1,
        "params": [
            {
                "name": "cssQuery",
                "type": "String"
            }
        ],
        "return_type": "Element",
        "signature": "public @Nullable Element selectFirst(String cssQuery)",
        "original_string": "    public @Nullable Element selectFirst(String cssQuery) {\n        return Selector.selectFirst(cssQuery, this);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "Element",
        "class_uri": "src/main/java/org/jsoup/nodes/Element.java.Element",
        "attributes": {
            "modifiers": "public @Nullable",
            "marker_annotations": [
                "@Nullable"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Element",
            "classes": []
        },
        "docstring": "\nFind the first Element that matches the {@link Selector} CSS query, with this element as the starting context.\n<p>This is effectively the same as calling {@code element.select(query).first()}, but is more efficient as query\nexecution stops on the first hit.</p>\n<p>Also known as {@code querySelector()} in the Web DOM.</p>\n@param cssQuery cssQuery a {@link Selector} CSS-like query\n@return the first matching element, or <b>{@code null}</b> if there is no match.\n@see #expectFirst(String)\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Element.java.Element.[Element]selectFirst(Evaluator)",
        "name": "selectFirst",
        "arg_nums": 1,
        "params": [
            {
                "name": "evaluator",
                "type": "Evaluator"
            }
        ],
        "return_type": "Element",
        "signature": "public @Nullable Element selectFirst(Evaluator evaluator)",
        "original_string": "    public @Nullable Element selectFirst(Evaluator evaluator) {\n        return Collector.findFirst(evaluator, this);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "Element",
        "class_uri": "src/main/java/org/jsoup/nodes/Element.java.Element",
        "attributes": {
            "modifiers": "public @Nullable",
            "marker_annotations": [
                "@Nullable"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Element",
            "classes": []
        },
        "docstring": "\nFinds the first Element that matches the supplied Evaluator, with this element as the starting context, or\n{@code null} if none match.\n\n@param evaluator an element evaluator\n@return the first matching element (walking down the tree, starting from this element), or {@code null} if none\nmatch.\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Element.java.Element.[Element]expectFirst(String)",
        "name": "expectFirst",
        "arg_nums": 1,
        "params": [
            {
                "name": "cssQuery",
                "type": "String"
            }
        ],
        "return_type": "Element",
        "signature": "public Element expectFirst(String cssQuery)",
        "original_string": "    public Element expectFirst(String cssQuery) {\n        return (Element) Validate.ensureNotNull(\n            Selector.selectFirst(cssQuery, this),\n            parent() != null ?\n                \"No elements matched the query '%s' on element '%s'.\":\n                \"No elements matched the query '%s' in the document.\"\n            , cssQuery, this.tagName()\n        );\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "Element",
        "class_uri": "src/main/java/org/jsoup/nodes/Element.java.Element",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Element",
            "classes": []
        },
        "docstring": "\nJust like {@link #selectFirst(String)}, but if there is no match, throws an {@link IllegalArgumentException}. This\nis useful if you want to simply abort processing on a failed match.\n@param cssQuery a {@link Selector} CSS-like query\n@return the first matching element\n@throws IllegalArgumentException if no match is found\n@since 1.15.2\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Element.java.Element.[boolean]is(String)",
        "name": "is",
        "arg_nums": 1,
        "params": [
            {
                "name": "cssQuery",
                "type": "String"
            }
        ],
        "return_type": "boolean",
        "signature": "public boolean is(String cssQuery)",
        "original_string": "    public boolean is(String cssQuery) {\n        return is(QueryParser.parse(cssQuery));\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "Element",
        "class_uri": "src/main/java/org/jsoup/nodes/Element.java.Element",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": "\nChecks if this element matches the given {@link Selector} CSS query. Also knows as {@code matches()} in the Web\nDOM.\n\n@param cssQuery a {@link Selector} CSS query\n@return if this element matches the query\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Element.java.Element.[boolean]is(Evaluator)",
        "name": "is",
        "arg_nums": 1,
        "params": [
            {
                "name": "evaluator",
                "type": "Evaluator"
            }
        ],
        "return_type": "boolean",
        "signature": "public boolean is(Evaluator evaluator)",
        "original_string": "    public boolean is(Evaluator evaluator) {\n        return evaluator.matches(this.root(), this);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "Element",
        "class_uri": "src/main/java/org/jsoup/nodes/Element.java.Element",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": "\nCheck if this element matches the given evaluator.\n@param evaluator an element evaluator\n@return if this element matches\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Element.java.Element.[Element]closest(String)",
        "name": "closest",
        "arg_nums": 1,
        "params": [
            {
                "name": "cssQuery",
                "type": "String"
            }
        ],
        "return_type": "Element",
        "signature": "public @Nullable Element closest(String cssQuery)",
        "original_string": "    public @Nullable Element closest(String cssQuery) {\n        return closest(QueryParser.parse(cssQuery));\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "Element",
        "class_uri": "src/main/java/org/jsoup/nodes/Element.java.Element",
        "attributes": {
            "modifiers": "public @Nullable",
            "marker_annotations": [
                "@Nullable"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Element",
            "classes": []
        },
        "docstring": "\nFind the closest element up the tree of parents that matches the specified CSS query. Will return itself, an\nancestor, or {@code null} if there is no such matching element.\n@param cssQuery a {@link Selector} CSS query\n@return the closest ancestor element (possibly itself) that matches the provided evaluator. {@code null} if not\nfound.\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Element.java.Element.[Element]closest(Evaluator)",
        "name": "closest",
        "arg_nums": 1,
        "params": [
            {
                "name": "evaluator",
                "type": "Evaluator"
            }
        ],
        "return_type": "Element",
        "signature": "public @Nullable Element closest(Evaluator evaluator)",
        "original_string": "    public @Nullable Element closest(Evaluator evaluator) {\n        Validate.notNull(evaluator);\n        Element el = this;\n        final Element root = root();\n        do {\n            if (evaluator.matches(root, el))\n                return el;\n            el = el.parent();\n        } while (el != null);\n        return null;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "Element",
        "class_uri": "src/main/java/org/jsoup/nodes/Element.java.Element",
        "attributes": {
            "modifiers": "public @Nullable",
            "marker_annotations": [
                "@Nullable"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Element",
            "classes": []
        },
        "docstring": "\nFind the closest element up the tree of parents that matches the specified evaluator. Will return itself, an\nancestor, or {@code null} if there is no such matching element.\n@param evaluator a query evaluator\n@return the closest ancestor element (possibly itself) that matches the provided evaluator. {@code null} if not\nfound.\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Element.java.Element.[Elements]selectXpath(String)",
        "name": "selectXpath",
        "arg_nums": 1,
        "params": [
            {
                "name": "xpath",
                "type": "String"
            }
        ],
        "return_type": "Elements",
        "signature": "public Elements selectXpath(String xpath)",
        "original_string": "    public Elements selectXpath(String xpath) {\n        return new Elements(NodeUtils.selectXpath(xpath, this, Element.class));\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "Element",
        "class_uri": "src/main/java/org/jsoup/nodes/Element.java.Element",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Elements",
            "classes": []
        },
        "docstring": "\nFind Elements that match the supplied {@index XPath} expression.\n<p>Note that for convenience of writing the Xpath expression, namespaces are disabled, and queries can be\nexpressed using the element's local name only.</p>\n<p>By default, XPath 1.0 expressions are supported. If you would to use XPath 2.0 or higher, you can provide an\nalternate XPathFactory implementation:</p>\n<ol>\n<li>Add the implementation to your classpath. E.g. to use <a href=\"https://www.saxonica.com/products/products.xml\">Saxon-HE</a>, add <a href=\"https://mvnrepository.com/artifact/net.sf.saxon/Saxon-HE\">net.sf.saxon:Saxon-HE</a> to your build.</li>\n<li>Set the system property <code>javax.xml.xpath.XPathFactory:jsoup</code> to the implementing classname. E.g.:<br>\n<code>System.setProperty(W3CDom.XPathFactoryProperty, \"net.sf.saxon.xpath.XPathFactoryImpl\");</code>\n</li>\n</ol>\n\n@param xpath XPath expression\n@return matching elements, or an empty list if none match.\n@see #selectXpath(String, Class)\n@since 1.14.3\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Element.java.Element.[List<T>]selectXpath(String,Class<T>)",
        "name": "selectXpath",
        "arg_nums": 2,
        "params": [
            {
                "name": "xpath",
                "type": "String"
            },
            {
                "name": "nodeType",
                "type": "Class<T>"
            }
        ],
        "return_type": "List<T>",
        "signature": "public <T extends Node> List<T> selectXpath(String xpath, Class<T> nodeType)",
        "original_string": "    public <T extends Node> List<T> selectXpath(String xpath, Class<T> nodeType) {\n        return NodeUtils.selectXpath(xpath, this, nodeType);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "Element",
        "class_uri": "src/main/java/org/jsoup/nodes/Element.java.Element",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "List<T>",
            "classes": []
        },
        "docstring": "\nFind Nodes that match the supplied XPath expression.\n<p>For example, to select TextNodes under {@code p} elements: </p>\n<pre>List&lt;TextNode&gt; textNodes = doc.selectXpath(\"//body//p//text()\", TextNode.class);</pre>\n<p>Note that in the jsoup DOM, Attribute objects are not Nodes. To directly select attribute values, do something\nlike:</p>\n<pre>List&lt;String&gt; hrefs = doc.selectXpath(\"//a\").eachAttr(\"href\");</pre>\n@param xpath XPath expression\n@param nodeType the jsoup node type to return\n@see #selectXpath(String)\n@return a list of matching nodes\n@since 1.14.3\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Element.java.Element.[Element]appendChild(Node)",
        "name": "appendChild",
        "arg_nums": 1,
        "params": [
            {
                "name": "child",
                "type": "Node"
            }
        ],
        "return_type": "Element",
        "signature": "public Element appendChild(Node child)",
        "original_string": "    public Element appendChild(Node child) {\n        Validate.notNull(child);\n\n        // was - Node#addChildren(child). short-circuits an array create and a loop.\n        reparentChild(child);\n        ensureChildNodes();\n        childNodes.add(child);\n        child.setSiblingIndex(childNodes.size() - 1);\n        return this;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "Element",
        "class_uri": "src/main/java/org/jsoup/nodes/Element.java.Element",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Element",
            "classes": []
        },
        "docstring": "\nInsert a node to the end of this Element's children. The incoming node will be re-parented.\n\n@param child node to add.\n@return this Element, for chaining\n@see #prependChild(Node)\n@see #insertChildren(int, Collection)\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Element.java.Element.[Element]appendChildren(Collection<? extends Node>)",
        "name": "appendChildren",
        "arg_nums": 1,
        "params": [
            {
                "name": "children",
                "type": "Collection<? extends Node>"
            }
        ],
        "return_type": "Element",
        "signature": "public Element appendChildren(Collection<? extends Node> children)",
        "original_string": "    public Element appendChildren(Collection<? extends Node> children) {\n        insertChildren(-1, children);\n        return this;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "Element",
        "class_uri": "src/main/java/org/jsoup/nodes/Element.java.Element",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Element",
            "classes": []
        },
        "docstring": "\nInsert the given nodes to the end of this Element's children.\n\n@param children nodes to add\n@return this Element, for chaining\n@see #insertChildren(int, Collection)\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Element.java.Element.[Element]appendTo(Element)",
        "name": "appendTo",
        "arg_nums": 1,
        "params": [
            {
                "name": "parent",
                "type": "Element"
            }
        ],
        "return_type": "Element",
        "signature": "public Element appendTo(Element parent)",
        "original_string": "    public Element appendTo(Element parent) {\n        Validate.notNull(parent);\n        parent.appendChild(this);\n        return this;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "Element",
        "class_uri": "src/main/java/org/jsoup/nodes/Element.java.Element",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Element",
            "classes": []
        },
        "docstring": "\nAdd this element to the supplied parent element, as its next child.\n\n@param parent element to which this element will be appended\n@return this element, so that you can continue modifying the element\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Element.java.Element.[Element]prependChild(Node)",
        "name": "prependChild",
        "arg_nums": 1,
        "params": [
            {
                "name": "child",
                "type": "Node"
            }
        ],
        "return_type": "Element",
        "signature": "public Element prependChild(Node child)",
        "original_string": "    public Element prependChild(Node child) {\n        Validate.notNull(child);\n\n        addChildren(0, child);\n        return this;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "Element",
        "class_uri": "src/main/java/org/jsoup/nodes/Element.java.Element",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Element",
            "classes": []
        },
        "docstring": "\nAdd a node to the start of this element's children.\n\n@param child node to add.\n@return this element, so that you can add more child nodes or elements.\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Element.java.Element.[Element]prependChildren(Collection<? extends Node>)",
        "name": "prependChildren",
        "arg_nums": 1,
        "params": [
            {
                "name": "children",
                "type": "Collection<? extends Node>"
            }
        ],
        "return_type": "Element",
        "signature": "public Element prependChildren(Collection<? extends Node> children)",
        "original_string": "    public Element prependChildren(Collection<? extends Node> children) {\n        insertChildren(0, children);\n        return this;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "Element",
        "class_uri": "src/main/java/org/jsoup/nodes/Element.java.Element",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Element",
            "classes": []
        },
        "docstring": "\nInsert the given nodes to the start of this Element's children.\n\n@param children nodes to add\n@return this Element, for chaining\n@see #insertChildren(int, Collection)\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Element.java.Element.[Element]insertChildren(int,Collection<? extends Node>)",
        "name": "insertChildren",
        "arg_nums": 2,
        "params": [
            {
                "name": "index",
                "type": "int"
            },
            {
                "name": "children",
                "type": "Collection<? extends Node>"
            }
        ],
        "return_type": "Element",
        "signature": "public Element insertChildren(int index, Collection<? extends Node> children)",
        "original_string": "    public Element insertChildren(int index, Collection<? extends Node> children) {\n        Validate.notNull(children, \"Children collection to be inserted must not be null.\");\n        int currentSize = childNodeSize();\n        if (index < 0) index += currentSize +1; // roll around\n        Validate.isTrue(index >= 0 && index <= currentSize, \"Insert position out of bounds.\");\n\n        ArrayList<Node> nodes = new ArrayList<>(children);\n        Node[] nodeArray = nodes.toArray(new Node[0]);\n        addChildren(index, nodeArray);\n        return this;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "Element",
        "class_uri": "src/main/java/org/jsoup/nodes/Element.java.Element",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Element",
            "classes": []
        },
        "docstring": "\nInserts the given child nodes into this element at the specified index. Current nodes will be shifted to the\nright. The inserted nodes will be moved from their current parent. To prevent moving, copy the nodes first.\n\n@param index 0-based index to insert children at. Specify {@code 0} to insert at the start, {@code -1} at the\nend\n@param children child nodes to insert\n@return this element, for chaining.\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Element.java.Element.[Element]insertChildren(int)",
        "name": "insertChildren",
        "arg_nums": 1,
        "params": [
            {
                "name": "index",
                "type": "int"
            }
        ],
        "return_type": "Element",
        "signature": "public Element insertChildren(int index, Node... children)",
        "original_string": "    public Element insertChildren(int index, Node... children) {\n        Validate.notNull(children, \"Children collection to be inserted must not be null.\");\n        int currentSize = childNodeSize();\n        if (index < 0) index += currentSize +1; // roll around\n        Validate.isTrue(index >= 0 && index <= currentSize, \"Insert position out of bounds.\");\n\n        addChildren(index, children);\n        return this;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "Element",
        "class_uri": "src/main/java/org/jsoup/nodes/Element.java.Element",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Element",
            "classes": []
        },
        "docstring": "\nInserts the given child nodes into this element at the specified index. Current nodes will be shifted to the\nright. The inserted nodes will be moved from their current parent. To prevent moving, copy the nodes first.\n\n@param index 0-based index to insert children at. Specify {@code 0} to insert at the start, {@code -1} at the\nend\n@param children child nodes to insert\n@return this element, for chaining.\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Element.java.Element.[Element]appendElement(String)",
        "name": "appendElement",
        "arg_nums": 1,
        "params": [
            {
                "name": "tagName",
                "type": "String"
            }
        ],
        "return_type": "Element",
        "signature": "public Element appendElement(String tagName)",
        "original_string": "    public Element appendElement(String tagName) {\n        return appendElement(tagName, tag.namespace());\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "Element",
        "class_uri": "src/main/java/org/jsoup/nodes/Element.java.Element",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Element",
            "classes": []
        },
        "docstring": "\nCreate a new element by tag name, and add it as this Element's last child.\n\n@param tagName the name of the tag (e.g. {@code div}).\n@return the new element, to allow you to add content to it, e.g.:\n {@code parent.appendElement(\"h1\").attr(\"id\", \"header\").text(\"Welcome\");}\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Element.java.Element.[Element]appendElement(String,String)",
        "name": "appendElement",
        "arg_nums": 2,
        "params": [
            {
                "name": "tagName",
                "type": "String"
            },
            {
                "name": "namespace",
                "type": "String"
            }
        ],
        "return_type": "Element",
        "signature": "public Element appendElement(String tagName, String namespace)",
        "original_string": "    public Element appendElement(String tagName, String namespace) {\n        Element child = new Element(Tag.valueOf(tagName, namespace, NodeUtils.parser(this).settings()), baseUri());\n        appendChild(child);\n        return child;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "Element",
        "class_uri": "src/main/java/org/jsoup/nodes/Element.java.Element",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Element",
            "classes": []
        },
        "docstring": "\nCreate a new element by tag name and namespace, add it as this Element's last child.\n\n@param tagName the name of the tag (e.g. {@code div}).\n@param namespace the namespace of the tag (e.g. {@link Parser#NamespaceHtml})\n@return the new element, in the specified namespace\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Element.java.Element.[Element]prependElement(String)",
        "name": "prependElement",
        "arg_nums": 1,
        "params": [
            {
                "name": "tagName",
                "type": "String"
            }
        ],
        "return_type": "Element",
        "signature": "public Element prependElement(String tagName)",
        "original_string": "    public Element prependElement(String tagName) {\n        return prependElement(tagName, tag.namespace());\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "Element",
        "class_uri": "src/main/java/org/jsoup/nodes/Element.java.Element",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Element",
            "classes": []
        },
        "docstring": "\nCreate a new element by tag name, and add it as this Element's first child.\n\n@param tagName the name of the tag (e.g. {@code div}).\n@return the new element, to allow you to add content to it, e.g.:\n {@code parent.prependElement(\"h1\").attr(\"id\", \"header\").text(\"Welcome\");}\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Element.java.Element.[Element]prependElement(String,String)",
        "name": "prependElement",
        "arg_nums": 2,
        "params": [
            {
                "name": "tagName",
                "type": "String"
            },
            {
                "name": "namespace",
                "type": "String"
            }
        ],
        "return_type": "Element",
        "signature": "public Element prependElement(String tagName, String namespace)",
        "original_string": "    public Element prependElement(String tagName, String namespace) {\n        Element child = new Element(Tag.valueOf(tagName, namespace, NodeUtils.parser(this).settings()), baseUri());\n        prependChild(child);\n        return child;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "Element",
        "class_uri": "src/main/java/org/jsoup/nodes/Element.java.Element",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Element",
            "classes": []
        },
        "docstring": "\nCreate a new element by tag name and namespace, and add it as this Element's first child.\n\n@param tagName the name of the tag (e.g. {@code div}).\n@param namespace the namespace of the tag (e.g. {@link Parser#NamespaceHtml})\n@return the new element, in the specified namespace\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Element.java.Element.[Element]appendText(String)",
        "name": "appendText",
        "arg_nums": 1,
        "params": [
            {
                "name": "text",
                "type": "String"
            }
        ],
        "return_type": "Element",
        "signature": "public Element appendText(String text)",
        "original_string": "    public Element appendText(String text) {\n        Validate.notNull(text);\n        TextNode node = new TextNode(text);\n        appendChild(node);\n        return this;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "Element",
        "class_uri": "src/main/java/org/jsoup/nodes/Element.java.Element",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Element",
            "classes": []
        },
        "docstring": "\nCreate and append a new TextNode to this element.\n\n@param text the (un-encoded) text to add\n@return this element\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Element.java.Element.[Element]prependText(String)",
        "name": "prependText",
        "arg_nums": 1,
        "params": [
            {
                "name": "text",
                "type": "String"
            }
        ],
        "return_type": "Element",
        "signature": "public Element prependText(String text)",
        "original_string": "    public Element prependText(String text) {\n        Validate.notNull(text);\n        TextNode node = new TextNode(text);\n        prependChild(node);\n        return this;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "Element",
        "class_uri": "src/main/java/org/jsoup/nodes/Element.java.Element",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Element",
            "classes": []
        },
        "docstring": "\nCreate and prepend a new TextNode to this element.\n\n@param text the decoded text to add\n@return this element\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Element.java.Element.[Element]append(String)",
        "name": "append",
        "arg_nums": 1,
        "params": [
            {
                "name": "html",
                "type": "String"
            }
        ],
        "return_type": "Element",
        "signature": "public Element append(String html)",
        "original_string": "    public Element append(String html) {\n        Validate.notNull(html);\n        List<Node> nodes = NodeUtils.parser(this).parseFragmentInput(html, this, baseUri());\n        addChildren(nodes.toArray(new Node[0]));\n        return this;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "Element",
        "class_uri": "src/main/java/org/jsoup/nodes/Element.java.Element",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Element",
            "classes": []
        },
        "docstring": "\nAdd inner HTML to this element. The supplied HTML will be parsed, and each node appended to the end of the children.\n@param html HTML to add inside this element, after the existing HTML\n@return this element\n@see #html(String)\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Element.java.Element.[Element]prepend(String)",
        "name": "prepend",
        "arg_nums": 1,
        "params": [
            {
                "name": "html",
                "type": "String"
            }
        ],
        "return_type": "Element",
        "signature": "public Element prepend(String html)",
        "original_string": "    public Element prepend(String html) {\n        Validate.notNull(html);\n        List<Node> nodes = NodeUtils.parser(this).parseFragmentInput(html, this, baseUri());\n        addChildren(0, nodes.toArray(new Node[0]));\n        return this;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "Element",
        "class_uri": "src/main/java/org/jsoup/nodes/Element.java.Element",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Element",
            "classes": []
        },
        "docstring": "\nAdd inner HTML into this element. The supplied HTML will be parsed, and each node prepended to the start of the element's children.\n@param html HTML to add inside this element, before the existing HTML\n@return this element\n@see #html(String)\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Element.java.Element.[Element]before(String)",
        "name": "before",
        "arg_nums": 1,
        "params": [
            {
                "name": "html",
                "type": "String"
            }
        ],
        "return_type": "Element",
        "signature": "@Override\n    public Element before(String html)",
        "original_string": "    @Override\n    public Element before(String html) {\n        return (Element) super.before(html);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "Element",
        "class_uri": "src/main/java/org/jsoup/nodes/Element.java.Element",
        "attributes": {
            "modifiers": "@Override\n    public",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Element",
            "classes": []
        },
        "docstring": "\nInsert the specified HTML into the DOM before this element (as a preceding sibling).\n\n@param html HTML to add before this element\n@return this element, for chaining\n@see #after(String)\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Element.java.Element.[Element]before(Node)",
        "name": "before",
        "arg_nums": 1,
        "params": [
            {
                "name": "node",
                "type": "Node"
            }
        ],
        "return_type": "Element",
        "signature": "@Override\n    public Element before(Node node)",
        "original_string": "    @Override\n    public Element before(Node node) {\n        return (Element) super.before(node);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "Element",
        "class_uri": "src/main/java/org/jsoup/nodes/Element.java.Element",
        "attributes": {
            "modifiers": "@Override\n    public",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Element",
            "classes": []
        },
        "docstring": "\nInsert the specified node into the DOM before this node (as a preceding sibling).\n@param node to add before this element\n@return this Element, for chaining\n@see #after(Node)\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Element.java.Element.[Element]after(String)",
        "name": "after",
        "arg_nums": 1,
        "params": [
            {
                "name": "html",
                "type": "String"
            }
        ],
        "return_type": "Element",
        "signature": "@Override\n    public Element after(String html)",
        "original_string": "    @Override\n    public Element after(String html) {\n        return (Element) super.after(html);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "Element",
        "class_uri": "src/main/java/org/jsoup/nodes/Element.java.Element",
        "attributes": {
            "modifiers": "@Override\n    public",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Element",
            "classes": []
        },
        "docstring": "\nInsert the specified HTML into the DOM after this element (as a following sibling).\n\n@param html HTML to add after this element\n@return this element, for chaining\n@see #before(String)\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Element.java.Element.[Element]after(Node)",
        "name": "after",
        "arg_nums": 1,
        "params": [
            {
                "name": "node",
                "type": "Node"
            }
        ],
        "return_type": "Element",
        "signature": "@Override\n    public Element after(Node node)",
        "original_string": "    @Override\n    public Element after(Node node) {\n        return (Element) super.after(node);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "Element",
        "class_uri": "src/main/java/org/jsoup/nodes/Element.java.Element",
        "attributes": {
            "modifiers": "@Override\n    public",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Element",
            "classes": []
        },
        "docstring": "\nInsert the specified node into the DOM after this node (as a following sibling).\n@param node to add after this element\n@return this element, for chaining\n@see #before(Node)\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Element.java.Element.[Element]empty()",
        "name": "empty",
        "arg_nums": 0,
        "params": [],
        "return_type": "Element",
        "signature": "@Override\n    public Element empty()",
        "original_string": "    @Override\n    public Element empty() {\n        // Detach each of the children -> parent links:\n        for (Node child : childNodes) {\n            child.parentNode = null;\n        }\n        childNodes.clear();\n        return this;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "Element",
        "class_uri": "src/main/java/org/jsoup/nodes/Element.java.Element",
        "attributes": {
            "modifiers": "@Override\n    public",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Element",
            "classes": []
        },
        "docstring": "\nRemove all the element's child nodes. Any attributes are left as-is. Each child node has its parent set to\n{@code null}.\n@return this element\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Element.java.Element.[Element]wrap(String)",
        "name": "wrap",
        "arg_nums": 1,
        "params": [
            {
                "name": "html",
                "type": "String"
            }
        ],
        "return_type": "Element",
        "signature": "@Override\n    public Element wrap(String html)",
        "original_string": "    @Override\n    public Element wrap(String html) {\n        return (Element) super.wrap(html);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "Element",
        "class_uri": "src/main/java/org/jsoup/nodes/Element.java.Element",
        "attributes": {
            "modifiers": "@Override\n    public",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Element",
            "classes": []
        },
        "docstring": "\nWrap the supplied HTML around this element.\n\n@param html HTML to wrap around this element, e.g. {@code <div class=\"head\"></div>}. Can be arbitrarily deep.\n@return this element, for chaining.\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Element.java.Element.[String]cssSelector()",
        "name": "cssSelector",
        "arg_nums": 0,
        "params": [],
        "return_type": "String",
        "signature": "public String cssSelector()",
        "original_string": "    public String cssSelector() {\n        if (id().length() > 0) {\n            // prefer to return the ID - but check that it's actually unique first!\n            String idSel = \"#\" + escapeCssIdentifier(id());\n            Document doc = ownerDocument();\n            if (doc != null) {\n                Elements els = doc.select(idSel);\n                if (els.size() == 1 && els.get(0) == this) // otherwise, continue to the nth-child impl\n                    return idSel;\n            } else {\n                return idSel; // no ownerdoc, return the ID selector\n            }\n        }\n\n        StringBuilder selector = StringUtil.borrowBuilder();\n        Element el = this;\n        while (el != null && !(el instanceof Document)) {\n            selector.insert(0, el.cssSelectorComponent());\n            el = el.parent();\n        }\n        return StringUtil.releaseBuilder(selector);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "Element",
        "class_uri": "src/main/java/org/jsoup/nodes/Element.java.Element",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": "\nGet a CSS selector that will uniquely select this element.\n<p>\nIf the element has an ID, returns #id;\notherwise returns the parent (if any) CSS selector, followed by {@literal '>'},\nfollowed by a unique selector for the element (tag.class.class:nth-child(n)).\n</p>\n\n@return the CSS Path that can be used to retrieve the element in a selector.\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Element.java.Element.[String]cssSelectorComponent()",
        "name": "cssSelectorComponent",
        "arg_nums": 0,
        "params": [],
        "return_type": "String",
        "signature": "private String cssSelectorComponent()",
        "original_string": "    private String cssSelectorComponent() {\n        // Escape tagname, and translate HTML namespace ns:tag to CSS namespace syntax ns|tag\n        String tagName = escapeCssIdentifier(tagName()).replace(\"\\\\:\", \"|\");\n        StringBuilder selector = StringUtil.borrowBuilder().append(tagName);\n        String classes = classNames().stream().map(TokenQueue::escapeCssIdentifier)\n                .collect(StringUtil.joining(\".\"));\n        if (!classes.isEmpty())\n            selector.append('.').append(classes);\n\n        if (parent() == null || parent() instanceof Document) // don't add Document to selector, as will always have a html node\n            return StringUtil.releaseBuilder(selector);\n\n        selector.insert(0, \" > \");\n        if (parent().select(selector.toString()).size() > 1)\n            selector.append(String.format(\n                \":nth-child(%d)\", elementSiblingIndex() + 1));\n\n        return StringUtil.releaseBuilder(selector);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "Element",
        "class_uri": "src/main/java/org/jsoup/nodes/Element.java.Element",
        "attributes": {
            "modifiers": "private",
            "marker_annotations": [],
            "non_marker_annotations": [
                "private"
            ],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Element.java.Element.[Elements]siblingElements()",
        "name": "siblingElements",
        "arg_nums": 0,
        "params": [],
        "return_type": "Elements",
        "signature": "public Elements siblingElements()",
        "original_string": "    public Elements siblingElements() {\n        if (parentNode == null)\n            return new Elements(0);\n\n        List<Element> elements = parent().childElementsList();\n        Elements siblings = new Elements(elements.size() - 1);\n        for (Element el: elements)\n            if (el != this)\n                siblings.add(el);\n        return siblings;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "Element",
        "class_uri": "src/main/java/org/jsoup/nodes/Element.java.Element",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Elements",
            "classes": []
        },
        "docstring": "\nGet sibling elements. If the element has no sibling elements, returns an empty list. An element is not a sibling\nof itself, so will not be included in the returned list.\n@return sibling elements\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Element.java.Element.[Element]nextElementSibling()",
        "name": "nextElementSibling",
        "arg_nums": 0,
        "params": [],
        "return_type": "Element",
        "signature": "public @Nullable Element nextElementSibling()",
        "original_string": "    public @Nullable Element nextElementSibling() {\n        Node next = this;\n        while ((next = next.nextSibling()) != null) {\n            if (next instanceof Element) return (Element) next;\n        }\n        return null;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "Element",
        "class_uri": "src/main/java/org/jsoup/nodes/Element.java.Element",
        "attributes": {
            "modifiers": "public @Nullable",
            "marker_annotations": [
                "@Nullable"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Element",
            "classes": []
        },
        "docstring": "\nGets the next sibling element of this element. E.g., if a {@code div} contains two {@code p}s,\nthe {@code nextElementSibling} of the first {@code p} is the second {@code p}.\n<p>\nThis is similar to {@link #nextSibling()}, but specifically finds only Elements\n</p>\n@return the next element, or null if there is no next element\n@see #previousElementSibling()\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Element.java.Element.[Elements]nextElementSiblings()",
        "name": "nextElementSiblings",
        "arg_nums": 0,
        "params": [],
        "return_type": "Elements",
        "signature": "public Elements nextElementSiblings()",
        "original_string": "    public Elements nextElementSiblings() {\n        return nextElementSiblings(true);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "Element",
        "class_uri": "src/main/java/org/jsoup/nodes/Element.java.Element",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Elements",
            "classes": []
        },
        "docstring": "\nGet each of the sibling elements that come after this element.\n\n@return each of the element siblings after this element, or an empty list if there are no next sibling elements\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Element.java.Element.[Element]previousElementSibling()",
        "name": "previousElementSibling",
        "arg_nums": 0,
        "params": [],
        "return_type": "Element",
        "signature": "public @Nullable Element previousElementSibling()",
        "original_string": "    public @Nullable Element previousElementSibling() {\n        Node prev = this;\n        while ((prev = prev.previousSibling()) != null) {\n            if (prev instanceof Element) return (Element) prev;\n        }\n        return null;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "Element",
        "class_uri": "src/main/java/org/jsoup/nodes/Element.java.Element",
        "attributes": {
            "modifiers": "public @Nullable",
            "marker_annotations": [
                "@Nullable"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Element",
            "classes": []
        },
        "docstring": "\nGets the previous element sibling of this element.\n@return the previous element, or null if there is no previous element\n@see #nextElementSibling()\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Element.java.Element.[Elements]previousElementSiblings()",
        "name": "previousElementSiblings",
        "arg_nums": 0,
        "params": [],
        "return_type": "Elements",
        "signature": "public Elements previousElementSiblings()",
        "original_string": "    public Elements previousElementSiblings() {\n        return nextElementSiblings(false);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "Element",
        "class_uri": "src/main/java/org/jsoup/nodes/Element.java.Element",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Elements",
            "classes": []
        },
        "docstring": "\nGet each of the element siblings before this element.\n\n@return the previous element siblings, or an empty list if there are none.\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Element.java.Element.[Elements]nextElementSiblings(boolean)",
        "name": "nextElementSiblings",
        "arg_nums": 1,
        "params": [
            {
                "name": "next",
                "type": "boolean"
            }
        ],
        "return_type": "Elements",
        "signature": "private Elements nextElementSiblings(boolean next)",
        "original_string": "    private Elements nextElementSiblings(boolean next) {\n        Elements els = new Elements();\n        if (parentNode == null)\n            return  els;\n        els.add(this);\n        return next ?  els.nextAll() : els.prevAll();\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "Element",
        "class_uri": "src/main/java/org/jsoup/nodes/Element.java.Element",
        "attributes": {
            "modifiers": "private",
            "marker_annotations": [],
            "non_marker_annotations": [
                "private"
            ],
            "comments": [],
            "return_type": "Elements",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Element.java.Element.[Element]firstElementSibling()",
        "name": "firstElementSibling",
        "arg_nums": 0,
        "params": [],
        "return_type": "Element",
        "signature": "public Element firstElementSibling()",
        "original_string": "    public Element firstElementSibling() {\n        if (parent() != null) {\n            //noinspection DataFlowIssue (not nullable, would be this is no other sibs)\n            return parent().firstElementChild();\n        } else\n            return this; // orphan is its own first sibling\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "Element",
        "class_uri": "src/main/java/org/jsoup/nodes/Element.java.Element",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Element",
            "classes": []
        },
        "docstring": "\nGets the first Element sibling of this element. That may be this element.\n@return the first sibling that is an element (aka the parent's first element child)\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Element.java.Element.[int]elementSiblingIndex()",
        "name": "elementSiblingIndex",
        "arg_nums": 0,
        "params": [],
        "return_type": "int",
        "signature": "public int elementSiblingIndex()",
        "original_string": "    public int elementSiblingIndex() {\n       if (parent() == null) return 0;\n       return indexInList(this, parent().childElementsList());\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "Element",
        "class_uri": "src/main/java/org/jsoup/nodes/Element.java.Element",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "int",
            "classes": []
        },
        "docstring": "\nGet the list index of this element in its element sibling list. I.e. if this is the first element\nsibling, returns 0.\n@return position in element sibling list\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Element.java.Element.[Element]lastElementSibling()",
        "name": "lastElementSibling",
        "arg_nums": 0,
        "params": [],
        "return_type": "Element",
        "signature": "public Element lastElementSibling()",
        "original_string": "    public Element lastElementSibling() {\n        if (parent() != null) {\n            //noinspection DataFlowIssue (not nullable, would be this if no other sibs)\n            return parent().lastElementChild();\n        } else\n            return this;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "Element",
        "class_uri": "src/main/java/org/jsoup/nodes/Element.java.Element",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Element",
            "classes": []
        },
        "docstring": "\nGets the last element sibling of this element. That may be this element.\n@return the last sibling that is an element (aka the parent's last element child)\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Element.java.Element.[int]indexInList(Element,List<E>)",
        "name": "indexInList",
        "arg_nums": 2,
        "params": [
            {
                "name": "search",
                "type": "Element"
            },
            {
                "name": "elements",
                "type": "List<E>"
            }
        ],
        "return_type": "int",
        "signature": "private static <E extends Element> int indexInList(Element search, List<E> elements)",
        "original_string": "    private static <E extends Element> int indexInList(Element search, List<E> elements) {\n        final int size = elements.size();\n        for (int i = 0; i < size; i++) {\n            if (elements.get(i) == search)\n                return i;\n        }\n        return 0;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "Element",
        "class_uri": "src/main/java/org/jsoup/nodes/Element.java.Element",
        "attributes": {
            "modifiers": "private static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "private",
                "static"
            ],
            "comments": [],
            "return_type": "int",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Element.java.Element.[Element]firstElementChild()",
        "name": "firstElementChild",
        "arg_nums": 0,
        "params": [],
        "return_type": "Element",
        "signature": "public @Nullable Element firstElementChild()",
        "original_string": "    public @Nullable Element firstElementChild() {\n        Node child = firstChild();\n        while (child != null) {\n            if (child instanceof Element) return (Element) child;\n            child = child.nextSibling();\n        }\n        return null;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "Element",
        "class_uri": "src/main/java/org/jsoup/nodes/Element.java.Element",
        "attributes": {
            "modifiers": "public @Nullable",
            "marker_annotations": [
                "@Nullable"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Element",
            "classes": []
        },
        "docstring": "\nGets the first child of this Element that is an Element, or {@code null} if there is none.\n@return the first Element child node, or null.\n@see #firstChild()\n@see #lastElementChild()\n@since 1.15.2\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Element.java.Element.[Element]lastElementChild()",
        "name": "lastElementChild",
        "arg_nums": 0,
        "params": [],
        "return_type": "Element",
        "signature": "public @Nullable Element lastElementChild()",
        "original_string": "    public @Nullable Element lastElementChild() {\n        Node child = lastChild();\n        while (child != null) {\n            if (child instanceof Element) return (Element) child;\n            child = child.previousSibling();\n        }\n        return null;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "Element",
        "class_uri": "src/main/java/org/jsoup/nodes/Element.java.Element",
        "attributes": {
            "modifiers": "public @Nullable",
            "marker_annotations": [
                "@Nullable"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Element",
            "classes": []
        },
        "docstring": "\nGets the last child of this Element that is an Element, or @{code null} if there is none.\n@return the last Element child node, or null.\n@see #lastChild()\n@see #firstElementChild()\n@since 1.15.2\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Element.java.Element.[Elements]getElementsByTag(String)",
        "name": "getElementsByTag",
        "arg_nums": 1,
        "params": [
            {
                "name": "tagName",
                "type": "String"
            }
        ],
        "return_type": "Elements",
        "signature": "public Elements getElementsByTag(String tagName)",
        "original_string": "    public Elements getElementsByTag(String tagName) {\n        Validate.notEmpty(tagName);\n        tagName = normalize(tagName);\n\n        return Collector.collect(new Evaluator.Tag(tagName), this);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "Element",
        "class_uri": "src/main/java/org/jsoup/nodes/Element.java.Element",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Elements",
            "classes": []
        },
        "docstring": "\nFinds elements, including and recursively under this element, with the specified tag name.\n@param tagName The tag name to search for (case insensitively).\n@return a matching unmodifiable list of elements. Will be empty if this element and none of its children match.\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Element.java.Element.[Element]getElementById(String)",
        "name": "getElementById",
        "arg_nums": 1,
        "params": [
            {
                "name": "id",
                "type": "String"
            }
        ],
        "return_type": "Element",
        "signature": "public @Nullable Element getElementById(String id)",
        "original_string": "    public @Nullable Element getElementById(String id) {\n        Validate.notEmpty(id);\n\n        Elements elements = Collector.collect(new Evaluator.Id(id), this);\n        if (elements.size() > 0)\n            return elements.get(0);\n        else\n            return null;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "Element",
        "class_uri": "src/main/java/org/jsoup/nodes/Element.java.Element",
        "attributes": {
            "modifiers": "public @Nullable",
            "marker_annotations": [
                "@Nullable"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Element",
            "classes": []
        },
        "docstring": "\nFind an element by ID, including or under this element.\n<p>\nNote that this finds the first matching ID, starting with this element. If you search down from a different\nstarting point, it is possible to find a different element by ID. For unique element by ID within a Document,\nuse {@link Document#getElementById(String)}\n@param id The ID to search for.\n@return The first matching element by ID, starting with this element, or null if none found.\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Element.java.Element.[Elements]getElementsByClass(String)",
        "name": "getElementsByClass",
        "arg_nums": 1,
        "params": [
            {
                "name": "className",
                "type": "String"
            }
        ],
        "return_type": "Elements",
        "signature": "public Elements getElementsByClass(String className)",
        "original_string": "    public Elements getElementsByClass(String className) {\n        Validate.notEmpty(className);\n\n        return Collector.collect(new Evaluator.Class(className), this);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "Element",
        "class_uri": "src/main/java/org/jsoup/nodes/Element.java.Element",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Elements",
            "classes": []
        },
        "docstring": "\nFind elements that have this class, including or under this element. Case-insensitive.\n<p>\nElements can have multiple classes (e.g. {@code <div class=\"header round first\">}). This method\nchecks each class, so you can find the above with {@code el.getElementsByClass(\"header\");}.\n\n@param className the name of the class to search for.\n@return elements with the supplied class name, empty if none\n@see #hasClass(String)\n@see #classNames()\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Element.java.Element.[Elements]getElementsByAttribute(String)",
        "name": "getElementsByAttribute",
        "arg_nums": 1,
        "params": [
            {
                "name": "key",
                "type": "String"
            }
        ],
        "return_type": "Elements",
        "signature": "public Elements getElementsByAttribute(String key)",
        "original_string": "    public Elements getElementsByAttribute(String key) {\n        Validate.notEmpty(key);\n        key = key.trim();\n\n        return Collector.collect(new Evaluator.Attribute(key), this);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "Element",
        "class_uri": "src/main/java/org/jsoup/nodes/Element.java.Element",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Elements",
            "classes": []
        },
        "docstring": "\nFind elements that have a named attribute set. Case-insensitive.\n\n@param key name of the attribute, e.g. {@code href}\n@return elements that have this attribute, empty if none\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Element.java.Element.[Elements]getElementsByAttributeStarting(String)",
        "name": "getElementsByAttributeStarting",
        "arg_nums": 1,
        "params": [
            {
                "name": "keyPrefix",
                "type": "String"
            }
        ],
        "return_type": "Elements",
        "signature": "public Elements getElementsByAttributeStarting(String keyPrefix)",
        "original_string": "    public Elements getElementsByAttributeStarting(String keyPrefix) {\n        Validate.notEmpty(keyPrefix);\n        keyPrefix = keyPrefix.trim();\n\n        return Collector.collect(new Evaluator.AttributeStarting(keyPrefix), this);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "Element",
        "class_uri": "src/main/java/org/jsoup/nodes/Element.java.Element",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Elements",
            "classes": []
        },
        "docstring": "\nFind elements that have an attribute name starting with the supplied prefix. Use {@code data-} to find elements\nthat have HTML5 datasets.\n@param keyPrefix name prefix of the attribute e.g. {@code data-}\n@return elements that have attribute names that start with the prefix, empty if none.\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Element.java.Element.[Elements]getElementsByAttributeValue(String,String)",
        "name": "getElementsByAttributeValue",
        "arg_nums": 2,
        "params": [
            {
                "name": "key",
                "type": "String"
            },
            {
                "name": "value",
                "type": "String"
            }
        ],
        "return_type": "Elements",
        "signature": "public Elements getElementsByAttributeValue(String key, String value)",
        "original_string": "    public Elements getElementsByAttributeValue(String key, String value) {\n        return Collector.collect(new Evaluator.AttributeWithValue(key, value), this);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "Element",
        "class_uri": "src/main/java/org/jsoup/nodes/Element.java.Element",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Elements",
            "classes": []
        },
        "docstring": "\nFind elements that have an attribute with the specific value. Case-insensitive.\n\n@param key name of the attribute\n@param value value of the attribute\n@return elements that have this attribute with this value, empty if none\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Element.java.Element.[Elements]getElementsByAttributeValueNot(String,String)",
        "name": "getElementsByAttributeValueNot",
        "arg_nums": 2,
        "params": [
            {
                "name": "key",
                "type": "String"
            },
            {
                "name": "value",
                "type": "String"
            }
        ],
        "return_type": "Elements",
        "signature": "public Elements getElementsByAttributeValueNot(String key, String value)",
        "original_string": "    public Elements getElementsByAttributeValueNot(String key, String value) {\n        return Collector.collect(new Evaluator.AttributeWithValueNot(key, value), this);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "Element",
        "class_uri": "src/main/java/org/jsoup/nodes/Element.java.Element",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Elements",
            "classes": []
        },
        "docstring": "\nFind elements that either do not have this attribute, or have it with a different value. Case-insensitive.\n\n@param key name of the attribute\n@param value value of the attribute\n@return elements that do not have a matching attribute\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Element.java.Element.[Elements]getElementsByAttributeValueStarting(String,String)",
        "name": "getElementsByAttributeValueStarting",
        "arg_nums": 2,
        "params": [
            {
                "name": "key",
                "type": "String"
            },
            {
                "name": "valuePrefix",
                "type": "String"
            }
        ],
        "return_type": "Elements",
        "signature": "public Elements getElementsByAttributeValueStarting(String key, String valuePrefix)",
        "original_string": "    public Elements getElementsByAttributeValueStarting(String key, String valuePrefix) {\n        return Collector.collect(new Evaluator.AttributeWithValueStarting(key, valuePrefix), this);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "Element",
        "class_uri": "src/main/java/org/jsoup/nodes/Element.java.Element",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Elements",
            "classes": []
        },
        "docstring": "\nFind elements that have attributes that start with the value prefix. Case-insensitive.\n\n@param key name of the attribute\n@param valuePrefix start of attribute value\n@return elements that have attributes that start with the value prefix\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Element.java.Element.[Elements]getElementsByAttributeValueEnding(String,String)",
        "name": "getElementsByAttributeValueEnding",
        "arg_nums": 2,
        "params": [
            {
                "name": "key",
                "type": "String"
            },
            {
                "name": "valueSuffix",
                "type": "String"
            }
        ],
        "return_type": "Elements",
        "signature": "public Elements getElementsByAttributeValueEnding(String key, String valueSuffix)",
        "original_string": "    public Elements getElementsByAttributeValueEnding(String key, String valueSuffix) {\n        return Collector.collect(new Evaluator.AttributeWithValueEnding(key, valueSuffix), this);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "Element",
        "class_uri": "src/main/java/org/jsoup/nodes/Element.java.Element",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Elements",
            "classes": []
        },
        "docstring": "\nFind elements that have attributes that end with the value suffix. Case-insensitive.\n\n@param key name of the attribute\n@param valueSuffix end of the attribute value\n@return elements that have attributes that end with the value suffix\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Element.java.Element.[Elements]getElementsByAttributeValueContaining(String,String)",
        "name": "getElementsByAttributeValueContaining",
        "arg_nums": 2,
        "params": [
            {
                "name": "key",
                "type": "String"
            },
            {
                "name": "match",
                "type": "String"
            }
        ],
        "return_type": "Elements",
        "signature": "public Elements getElementsByAttributeValueContaining(String key, String match)",
        "original_string": "    public Elements getElementsByAttributeValueContaining(String key, String match) {\n        return Collector.collect(new Evaluator.AttributeWithValueContaining(key, match), this);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "Element",
        "class_uri": "src/main/java/org/jsoup/nodes/Element.java.Element",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Elements",
            "classes": []
        },
        "docstring": "\nFind elements that have attributes whose value contains the match string. Case-insensitive.\n\n@param key name of the attribute\n@param match substring of value to search for\n@return elements that have attributes containing this text\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Element.java.Element.[Elements]getElementsByAttributeValueMatching(String,Pattern)",
        "name": "getElementsByAttributeValueMatching",
        "arg_nums": 2,
        "params": [
            {
                "name": "key",
                "type": "String"
            },
            {
                "name": "pattern",
                "type": "Pattern"
            }
        ],
        "return_type": "Elements",
        "signature": "public Elements getElementsByAttributeValueMatching(String key, Pattern pattern)",
        "original_string": "    public Elements getElementsByAttributeValueMatching(String key, Pattern pattern) {\n        return Collector.collect(new Evaluator.AttributeWithValueMatching(key, pattern), this);\n\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "Element",
        "class_uri": "src/main/java/org/jsoup/nodes/Element.java.Element",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Elements",
            "classes": []
        },
        "docstring": "\nFind elements that have an attribute whose value matches the supplied regular expression.\n@param key name of the attribute\n@param pattern compiled regular expression to match against attribute values\n@return elements that have attributes matching this regular expression\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Element.java.Element.[Elements]getElementsByAttributeValueMatching(String,String)",
        "name": "getElementsByAttributeValueMatching",
        "arg_nums": 2,
        "params": [
            {
                "name": "key",
                "type": "String"
            },
            {
                "name": "regex",
                "type": "String"
            }
        ],
        "return_type": "Elements",
        "signature": "public Elements getElementsByAttributeValueMatching(String key, String regex)",
        "original_string": "    public Elements getElementsByAttributeValueMatching(String key, String regex) {\n        Pattern pattern;\n        try {\n            pattern = Pattern.compile(regex);\n        } catch (PatternSyntaxException e) {\n            throw new IllegalArgumentException(\"Pattern syntax error: \" + regex, e);\n        }\n        return getElementsByAttributeValueMatching(key, pattern);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "Element",
        "class_uri": "src/main/java/org/jsoup/nodes/Element.java.Element",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Elements",
            "classes": []
        },
        "docstring": "\nFind elements that have attributes whose values match the supplied regular expression.\n@param key name of the attribute\n@param regex regular expression to match against attribute values. You can use <a href=\"http://java.sun.com/docs/books/tutorial/essential/regex/pattern.html#embedded\">embedded flags</a> (such as {@code (?i)} and {@code (?m)}) to control regex options.\n@return elements that have attributes matching this regular expression\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Element.java.Element.[Elements]getElementsByIndexLessThan(int)",
        "name": "getElementsByIndexLessThan",
        "arg_nums": 1,
        "params": [
            {
                "name": "index",
                "type": "int"
            }
        ],
        "return_type": "Elements",
        "signature": "public Elements getElementsByIndexLessThan(int index)",
        "original_string": "    public Elements getElementsByIndexLessThan(int index) {\n        return Collector.collect(new Evaluator.IndexLessThan(index), this);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "Element",
        "class_uri": "src/main/java/org/jsoup/nodes/Element.java.Element",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Elements",
            "classes": []
        },
        "docstring": "\nFind elements whose sibling index is less than the supplied index.\n@param index 0-based index\n@return elements less than index\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Element.java.Element.[Elements]getElementsByIndexGreaterThan(int)",
        "name": "getElementsByIndexGreaterThan",
        "arg_nums": 1,
        "params": [
            {
                "name": "index",
                "type": "int"
            }
        ],
        "return_type": "Elements",
        "signature": "public Elements getElementsByIndexGreaterThan(int index)",
        "original_string": "    public Elements getElementsByIndexGreaterThan(int index) {\n        return Collector.collect(new Evaluator.IndexGreaterThan(index), this);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "Element",
        "class_uri": "src/main/java/org/jsoup/nodes/Element.java.Element",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Elements",
            "classes": []
        },
        "docstring": "\nFind elements whose sibling index is greater than the supplied index.\n@param index 0-based index\n@return elements greater than index\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Element.java.Element.[Elements]getElementsByIndexEquals(int)",
        "name": "getElementsByIndexEquals",
        "arg_nums": 1,
        "params": [
            {
                "name": "index",
                "type": "int"
            }
        ],
        "return_type": "Elements",
        "signature": "public Elements getElementsByIndexEquals(int index)",
        "original_string": "    public Elements getElementsByIndexEquals(int index) {\n        return Collector.collect(new Evaluator.IndexEquals(index), this);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "Element",
        "class_uri": "src/main/java/org/jsoup/nodes/Element.java.Element",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Elements",
            "classes": []
        },
        "docstring": "\nFind elements whose sibling index is equal to the supplied index.\n@param index 0-based index\n@return elements equal to index\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Element.java.Element.[Elements]getElementsContainingText(String)",
        "name": "getElementsContainingText",
        "arg_nums": 1,
        "params": [
            {
                "name": "searchText",
                "type": "String"
            }
        ],
        "return_type": "Elements",
        "signature": "public Elements getElementsContainingText(String searchText)",
        "original_string": "    public Elements getElementsContainingText(String searchText) {\n        return Collector.collect(new Evaluator.ContainsText(searchText), this);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "Element",
        "class_uri": "src/main/java/org/jsoup/nodes/Element.java.Element",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Elements",
            "classes": []
        },
        "docstring": "\nFind elements that contain the specified string. The search is case-insensitive. The text may appear directly\nin the element, or in any of its descendants.\n@param searchText to look for in the element's text\n@return elements that contain the string, case-insensitive.\n@see Element#text()\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Element.java.Element.[Elements]getElementsContainingOwnText(String)",
        "name": "getElementsContainingOwnText",
        "arg_nums": 1,
        "params": [
            {
                "name": "searchText",
                "type": "String"
            }
        ],
        "return_type": "Elements",
        "signature": "public Elements getElementsContainingOwnText(String searchText)",
        "original_string": "    public Elements getElementsContainingOwnText(String searchText) {\n        return Collector.collect(new Evaluator.ContainsOwnText(searchText), this);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "Element",
        "class_uri": "src/main/java/org/jsoup/nodes/Element.java.Element",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Elements",
            "classes": []
        },
        "docstring": "\nFind elements that directly contain the specified string. The search is case-insensitive. The text must appear directly\nin the element, not in any of its descendants.\n@param searchText to look for in the element's own text\n@return elements that contain the string, case-insensitive.\n@see Element#ownText()\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Element.java.Element.[Elements]getElementsMatchingText(Pattern)",
        "name": "getElementsMatchingText",
        "arg_nums": 1,
        "params": [
            {
                "name": "pattern",
                "type": "Pattern"
            }
        ],
        "return_type": "Elements",
        "signature": "public Elements getElementsMatchingText(Pattern pattern)",
        "original_string": "    public Elements getElementsMatchingText(Pattern pattern) {\n        return Collector.collect(new Evaluator.Matches(pattern), this);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "Element",
        "class_uri": "src/main/java/org/jsoup/nodes/Element.java.Element",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Elements",
            "classes": []
        },
        "docstring": "\nFind elements whose text matches the supplied regular expression.\n@param pattern regular expression to match text against\n@return elements matching the supplied regular expression.\n@see Element#text()\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Element.java.Element.[Elements]getElementsMatchingText(String)",
        "name": "getElementsMatchingText",
        "arg_nums": 1,
        "params": [
            {
                "name": "regex",
                "type": "String"
            }
        ],
        "return_type": "Elements",
        "signature": "public Elements getElementsMatchingText(String regex)",
        "original_string": "    public Elements getElementsMatchingText(String regex) {\n        Pattern pattern;\n        try {\n            pattern = Pattern.compile(regex);\n        } catch (PatternSyntaxException e) {\n            throw new IllegalArgumentException(\"Pattern syntax error: \" + regex, e);\n        }\n        return getElementsMatchingText(pattern);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "Element",
        "class_uri": "src/main/java/org/jsoup/nodes/Element.java.Element",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Elements",
            "classes": []
        },
        "docstring": "\nFind elements whose text matches the supplied regular expression.\n@param regex regular expression to match text against. You can use <a href=\"http://java.sun.com/docs/books/tutorial/essential/regex/pattern.html#embedded\">embedded flags</a> (such as {@code (?i)} and {@code (?m)}) to control regex options.\n@return elements matching the supplied regular expression.\n@see Element#text()\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Element.java.Element.[Elements]getElementsMatchingOwnText(Pattern)",
        "name": "getElementsMatchingOwnText",
        "arg_nums": 1,
        "params": [
            {
                "name": "pattern",
                "type": "Pattern"
            }
        ],
        "return_type": "Elements",
        "signature": "public Elements getElementsMatchingOwnText(Pattern pattern)",
        "original_string": "    public Elements getElementsMatchingOwnText(Pattern pattern) {\n        return Collector.collect(new Evaluator.MatchesOwn(pattern), this);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "Element",
        "class_uri": "src/main/java/org/jsoup/nodes/Element.java.Element",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Elements",
            "classes": []
        },
        "docstring": "\nFind elements whose own text matches the supplied regular expression.\n@param pattern regular expression to match text against\n@return elements matching the supplied regular expression.\n@see Element#ownText()\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Element.java.Element.[Elements]getElementsMatchingOwnText(String)",
        "name": "getElementsMatchingOwnText",
        "arg_nums": 1,
        "params": [
            {
                "name": "regex",
                "type": "String"
            }
        ],
        "return_type": "Elements",
        "signature": "public Elements getElementsMatchingOwnText(String regex)",
        "original_string": "    public Elements getElementsMatchingOwnText(String regex) {\n        Pattern pattern;\n        try {\n            pattern = Pattern.compile(regex);\n        } catch (PatternSyntaxException e) {\n            throw new IllegalArgumentException(\"Pattern syntax error: \" + regex, e);\n        }\n        return getElementsMatchingOwnText(pattern);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "Element",
        "class_uri": "src/main/java/org/jsoup/nodes/Element.java.Element",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Elements",
            "classes": []
        },
        "docstring": "\nFind elements whose own text matches the supplied regular expression.\n@param regex regular expression to match text against. You can use <a href=\"http://java.sun.com/docs/books/tutorial/essential/regex/pattern.html#embedded\">embedded flags</a> (such as {@code (?i)} and {@code (?m)}) to control regex options.\n@return elements matching the supplied regular expression.\n@see Element#ownText()\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Element.java.Element.[Elements]getAllElements()",
        "name": "getAllElements",
        "arg_nums": 0,
        "params": [],
        "return_type": "Elements",
        "signature": "public Elements getAllElements()",
        "original_string": "    public Elements getAllElements() {\n        return Collector.collect(new Evaluator.AllElements(), this);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "Element",
        "class_uri": "src/main/java/org/jsoup/nodes/Element.java.Element",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Elements",
            "classes": []
        },
        "docstring": "\nFind all elements under this element (including self, and children of children).\n\n@return all elements\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Element.java.Element.[String]text()",
        "name": "text",
        "arg_nums": 0,
        "params": [],
        "return_type": "String",
        "signature": "public String text()",
        "original_string": "    public String text() {\n        final StringBuilder accum = StringUtil.borrowBuilder();\n        NodeTraversor.traverse(new TextAccumulator(accum), this);\n        return StringUtil.releaseBuilder(accum).trim();\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "Element",
        "class_uri": "src/main/java/org/jsoup/nodes/Element.java.Element",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": "\nGets the <b>normalized, combined text</b> of this element and all its children. Whitespace is normalized and\ntrimmed.\n<p>For example, given HTML {@code <p>Hello  <b>there</b> now! </p>}, {@code p.text()} returns {@code \"Hello there\nnow!\"}\n<p>If you do not want normalized text, use {@link #wholeText()}. If you want just the text of this node (and not\nchildren), use {@link #ownText()}\n<p>Note that this method returns the textual content that would be presented to a reader. The contents of data\nnodes (such as {@code <script>} tags) are not considered text. Use {@link #data()} or {@link #html()} to retrieve\nthat content.\n\n@return decoded, normalized text, or empty string if none.\n@see #wholeText()\n@see #ownText()\n@see #textNodes()\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Element.java.Element.[String]wholeText()",
        "name": "wholeText",
        "arg_nums": 0,
        "params": [],
        "return_type": "String",
        "signature": "public String wholeText()",
        "original_string": "    public String wholeText() {\n        return wholeTextOf(nodeStream());\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "Element",
        "class_uri": "src/main/java/org/jsoup/nodes/Element.java.Element",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": "\nGet the non-normalized, decoded text of this element and its children, including only any newlines and spaces\npresent in the original source.\n@return decoded, non-normalized text\n@see #text()\n@see #wholeOwnText()\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Element.java.Element.[String]wholeTextOf(Stream<Node>)",
        "name": "wholeTextOf",
        "arg_nums": 1,
        "params": [
            {
                "name": "stream",
                "type": "Stream<Node>"
            }
        ],
        "return_type": "String",
        "signature": "private static String wholeTextOf(Stream<Node> stream)",
        "original_string": "    private static String wholeTextOf(Stream<Node> stream) {\n        return stream.map(node -> {\n            if (node instanceof TextNode) return ((TextNode) node).getWholeText();\n            if (node.nameIs(\"br\")) return \"\\n\";\n            return \"\";\n        }).collect(StringUtil.joining(\"\"));\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "Element",
        "class_uri": "src/main/java/org/jsoup/nodes/Element.java.Element",
        "attributes": {
            "modifiers": "private static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "private",
                "static"
            ],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Element.java.Element.[String]wholeOwnText()",
        "name": "wholeOwnText",
        "arg_nums": 0,
        "params": [],
        "return_type": "String",
        "signature": "public String wholeOwnText()",
        "original_string": "    public String wholeOwnText() {\n        return wholeTextOf(childNodes.stream());\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "Element",
        "class_uri": "src/main/java/org/jsoup/nodes/Element.java.Element",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": "\nGet the non-normalized, decoded text of this element, <b>not including</b> any child elements, including any\nnewlines and spaces present in the original source.\n@return decoded, non-normalized text that is a direct child of this Element\n@see #text()\n@see #wholeText()\n@see #ownText()\n@since 1.15.1\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Element.java.Element.[String]ownText()",
        "name": "ownText",
        "arg_nums": 0,
        "params": [],
        "return_type": "String",
        "signature": "public String ownText()",
        "original_string": "    public String ownText() {\n        StringBuilder sb = StringUtil.borrowBuilder();\n        ownText(sb);\n        return StringUtil.releaseBuilder(sb).trim();\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "Element",
        "class_uri": "src/main/java/org/jsoup/nodes/Element.java.Element",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": "\nGets the (normalized) text owned by this element only; does not get the combined text of all children.\n<p>\nFor example, given HTML {@code <p>Hello <b>there</b> now!</p>}, {@code p.ownText()} returns {@code \"Hello now!\"},\nwhereas {@code p.text()} returns {@code \"Hello there now!\"}.\nNote that the text within the {@code b} element is not returned, as it is not a direct child of the {@code p} element.\n\n@return decoded text, or empty string if none.\n@see #text()\n@see #textNodes()\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Element.java.Element.[void]ownText(StringBuilder)",
        "name": "ownText",
        "arg_nums": 1,
        "params": [
            {
                "name": "accum",
                "type": "StringBuilder"
            }
        ],
        "return_type": "void",
        "signature": "private void ownText(StringBuilder accum)",
        "original_string": "    private void ownText(StringBuilder accum) {\n        for (int i = 0; i < childNodeSize(); i++) {\n            Node child = childNodes.get(i);\n            if (child instanceof TextNode) {\n                TextNode textNode = (TextNode) child;\n                appendNormalisedText(accum, textNode);\n            } else if (child.nameIs(\"br\") && !lastCharIsWhitespace(accum)) {\n                accum.append(\" \");\n            }\n        }\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "Element",
        "class_uri": "src/main/java/org/jsoup/nodes/Element.java.Element",
        "attributes": {
            "modifiers": "private",
            "marker_annotations": [],
            "non_marker_annotations": [
                "private"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Element.java.Element.[void]appendNormalisedText(StringBuilder,TextNode)",
        "name": "appendNormalisedText",
        "arg_nums": 2,
        "params": [
            {
                "name": "accum",
                "type": "StringBuilder"
            },
            {
                "name": "textNode",
                "type": "TextNode"
            }
        ],
        "return_type": "void",
        "signature": "private static void appendNormalisedText(StringBuilder accum, TextNode textNode)",
        "original_string": "    private static void appendNormalisedText(StringBuilder accum, TextNode textNode) {\n        String text = textNode.getWholeText();\n        if (preserveWhitespace(textNode.parentNode) || textNode instanceof CDataNode)\n            accum.append(text);\n        else\n            StringUtil.appendNormalisedWhitespace(accum, text, lastCharIsWhitespace(accum));\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "Element",
        "class_uri": "src/main/java/org/jsoup/nodes/Element.java.Element",
        "attributes": {
            "modifiers": "private static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "private",
                "static"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Element.java.Element.[boolean]preserveWhitespace(Node)",
        "name": "preserveWhitespace",
        "arg_nums": 1,
        "params": [
            {
                "name": "node",
                "type": "Node"
            }
        ],
        "return_type": "boolean",
        "signature": "static boolean preserveWhitespace(@Nullable Node node)",
        "original_string": "    static boolean preserveWhitespace(@Nullable Node node) {\n        // looks only at this element and five levels up, to prevent recursion & needless stack searches\n        if (node instanceof Element) {\n            Element el = (Element) node;\n            int i = 0;\n            do {\n                if (el.tag.preserveWhitespace())\n                    return true;\n                el = el.parent();\n                i++;\n            } while (i < 6 && el != null);\n        }\n        return false;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "Element",
        "class_uri": "src/main/java/org/jsoup/nodes/Element.java.Element",
        "attributes": {
            "modifiers": "static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "static"
            ],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Element.java.Element.[Element]text(String)",
        "name": "text",
        "arg_nums": 1,
        "params": [
            {
                "name": "text",
                "type": "String"
            }
        ],
        "return_type": "Element",
        "signature": "public Element text(String text)",
        "original_string": "    public Element text(String text) {\n        Validate.notNull(text);\n        empty();\n        // special case for script/style in HTML: should be data node\n        Document owner = ownerDocument();\n        // an alternate impl would be to run through the parser\n        if (owner != null && owner.parser().isContentForTagData(normalName()))\n            appendChild(new DataNode(text));\n        else\n            appendChild(new TextNode(text));\n\n        return this;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "Element",
        "class_uri": "src/main/java/org/jsoup/nodes/Element.java.Element",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Element",
            "classes": []
        },
        "docstring": "\nSet the text of this element. Any existing contents (text or elements) will be cleared.\n<p>As a special case, for {@code <script>} and {@code <style>} tags, the input text will be treated as data,\nnot visible text.</p>\n@param text decoded text\n@return this element\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Element.java.Element.[boolean]hasText()",
        "name": "hasText",
        "arg_nums": 0,
        "params": [],
        "return_type": "boolean",
        "signature": "public boolean hasText()",
        "original_string": "    public boolean hasText() {\n        AtomicBoolean hasText = new AtomicBoolean(false);\n        filter((node, depth) -> {\n            if (node instanceof TextNode) {\n                TextNode textNode = (TextNode) node;\n                if (!textNode.isBlank()) {\n                    hasText.set(true);\n                    return NodeFilter.FilterResult.STOP;\n                }\n            }\n            return NodeFilter.FilterResult.CONTINUE;\n        });\n        return hasText.get();\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "Element",
        "class_uri": "src/main/java/org/jsoup/nodes/Element.java.Element",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": "\nChecks if the current element or any of its child elements contain non-whitespace text.\n@return {@code true} if the element has non-blank text content, {@code false} otherwise.\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Element.java.Element.[String]data()",
        "name": "data",
        "arg_nums": 0,
        "params": [],
        "return_type": "String",
        "signature": "public String data()",
        "original_string": "    public String data() {\n        StringBuilder sb = StringUtil.borrowBuilder();\n        traverse((childNode, depth) -> {\n            if (childNode instanceof DataNode) {\n                DataNode data = (DataNode) childNode;\n                sb.append(data.getWholeData());\n            } else if (childNode instanceof Comment) {\n                Comment comment = (Comment) childNode;\n                sb.append(comment.getData());\n            } else if (childNode instanceof CDataNode) {\n                // this shouldn't really happen because the html parser won't see the cdata as anything special when parsing script.\n                // but in case another type gets through.\n                CDataNode cDataNode = (CDataNode) childNode;\n                sb.append(cDataNode.getWholeText());\n            }\n        });\n        return StringUtil.releaseBuilder(sb);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "Element",
        "class_uri": "src/main/java/org/jsoup/nodes/Element.java.Element",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": "\nGet the combined data of this element. Data is e.g. the inside of a {@code <script>} tag. Note that data is NOT the\ntext of the element. Use {@link #text()} to get the text that would be visible to a user, and {@code data()}\nfor the contents of scripts, comments, CSS styles, etc.\n\n@return the data, or empty string if none\n\n@see #dataNodes()\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Element.java.Element.[String]className()",
        "name": "className",
        "arg_nums": 0,
        "params": [],
        "return_type": "String",
        "signature": "public String className()",
        "original_string": "    public String className() {\n        return attr(\"class\").trim();\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "Element",
        "class_uri": "src/main/java/org/jsoup/nodes/Element.java.Element",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": "\nGets the literal value of this element's \"class\" attribute, which may include multiple class names, space\nseparated. (E.g. on <code>&lt;div class=\"header gray\"&gt;</code> returns, \"<code>header gray</code>\")\n@return The literal class attribute, or <b>empty string</b> if no class attribute set.\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Element.java.Element.[Set<String>]classNames()",
        "name": "classNames",
        "arg_nums": 0,
        "params": [],
        "return_type": "Set<String>",
        "signature": "public Set<String> classNames()",
        "original_string": "    public Set<String> classNames() {\n    \tString[] names = ClassSplit.split(className());\n    \tSet<String> classNames = new LinkedHashSet<>(Arrays.asList(names));\n    \tclassNames.remove(\"\"); // if classNames() was empty, would include an empty class\n\n        return classNames;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "Element",
        "class_uri": "src/main/java/org/jsoup/nodes/Element.java.Element",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Set<String>",
            "classes": []
        },
        "docstring": "\nGet each of the element's class names. E.g. on element {@code <div class=\"header gray\">},\nreturns a set of two elements {@code \"header\", \"gray\"}. Note that modifications to this set are not pushed to\nthe backing {@code class} attribute; use the {@link #classNames(java.util.Set)} method to persist them.\n@return set of classnames, empty if no class attribute\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Element.java.Element.[Element]classNames(Set<String>)",
        "name": "classNames",
        "arg_nums": 1,
        "params": [
            {
                "name": "classNames",
                "type": "Set<String>"
            }
        ],
        "return_type": "Element",
        "signature": "public Element classNames(Set<String> classNames)",
        "original_string": "    public Element classNames(Set<String> classNames) {\n        Validate.notNull(classNames);\n        if (classNames.isEmpty()) {\n            attributes().remove(\"class\");\n        } else {\n            attributes().put(\"class\", StringUtil.join(classNames, \" \"));\n        }\n        return this;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "Element",
        "class_uri": "src/main/java/org/jsoup/nodes/Element.java.Element",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Element",
            "classes": []
        },
        "docstring": "\nSet the element's {@code class} attribute to the supplied class names.\n@param classNames set of classes\n@return this element, for chaining\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Element.java.Element.[boolean]hasClass(String)",
        "name": "hasClass",
        "arg_nums": 1,
        "params": [
            {
                "name": "className",
                "type": "String"
            }
        ],
        "return_type": "boolean",
        "signature": "public boolean hasClass(String className)",
        "original_string": "    public boolean hasClass(String className) {\n        if (attributes == null)\n            return false;\n\n        final String classAttr = attributes.getIgnoreCase(\"class\");\n        final int len = classAttr.length();\n        final int wantLen = className.length();\n\n        if (len == 0 || len < wantLen) {\n            return false;\n        }\n\n        // if both lengths are equal, only need compare the className with the attribute\n        if (len == wantLen) {\n            return className.equalsIgnoreCase(classAttr);\n        }\n\n        // otherwise, scan for whitespace and compare regions (with no string or arraylist allocations)\n        boolean inClass = false;\n        int start = 0;\n        for (int i = 0; i < len; i++) {\n            if (Character.isWhitespace(classAttr.charAt(i))) {\n                if (inClass) {\n                    // white space ends a class name, compare it with the requested one, ignore case\n                    if (i - start == wantLen && classAttr.regionMatches(true, start, className, 0, wantLen)) {\n                        return true;\n                    }\n                    inClass = false;\n                }\n            } else {\n                if (!inClass) {\n                    // we're in a class name : keep the start of the substring\n                    inClass = true;\n                    start = i;\n                }\n            }\n        }\n\n        // check the last entry\n        if (inClass && len - start == wantLen) {\n            return classAttr.regionMatches(true, start, className, 0, wantLen);\n        }\n\n        return false;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "Element",
        "class_uri": "src/main/java/org/jsoup/nodes/Element.java.Element",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": " performance sensitive"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Element.java.Element.[Element]addClass(String)",
        "name": "addClass",
        "arg_nums": 1,
        "params": [
            {
                "name": "className",
                "type": "String"
            }
        ],
        "return_type": "Element",
        "signature": "public Element addClass(String className)",
        "original_string": "    public Element addClass(String className) {\n        Validate.notNull(className);\n\n        Set<String> classes = classNames();\n        classes.add(className);\n        classNames(classes);\n\n        return this;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "Element",
        "class_uri": "src/main/java/org/jsoup/nodes/Element.java.Element",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Element",
            "classes": []
        },
        "docstring": "\nAdd a class name to this element's {@code class} attribute.\n@param className class name to add\n@return this element\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Element.java.Element.[Element]removeClass(String)",
        "name": "removeClass",
        "arg_nums": 1,
        "params": [
            {
                "name": "className",
                "type": "String"
            }
        ],
        "return_type": "Element",
        "signature": "public Element removeClass(String className)",
        "original_string": "    public Element removeClass(String className) {\n        Validate.notNull(className);\n\n        Set<String> classes = classNames();\n        classes.remove(className);\n        classNames(classes);\n\n        return this;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "Element",
        "class_uri": "src/main/java/org/jsoup/nodes/Element.java.Element",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Element",
            "classes": []
        },
        "docstring": "\nRemove a class name from this element's {@code class} attribute.\n@param className class name to remove\n@return this element\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Element.java.Element.[Element]toggleClass(String)",
        "name": "toggleClass",
        "arg_nums": 1,
        "params": [
            {
                "name": "className",
                "type": "String"
            }
        ],
        "return_type": "Element",
        "signature": "public Element toggleClass(String className)",
        "original_string": "    public Element toggleClass(String className) {\n        Validate.notNull(className);\n\n        Set<String> classes = classNames();\n        if (classes.contains(className))\n            classes.remove(className);\n        else\n            classes.add(className);\n        classNames(classes);\n\n        return this;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "Element",
        "class_uri": "src/main/java/org/jsoup/nodes/Element.java.Element",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Element",
            "classes": []
        },
        "docstring": "\nToggle a class name on this element's {@code class} attribute: if present, remove it; otherwise add it.\n@param className class name to toggle\n@return this element\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Element.java.Element.[String]val()",
        "name": "val",
        "arg_nums": 0,
        "params": [],
        "return_type": "String",
        "signature": "public String val()",
        "original_string": "    public String val() {\n        if (elementIs(\"textarea\", NamespaceHtml))\n            return text();\n        else\n            return attr(\"value\");\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "Element",
        "class_uri": "src/main/java/org/jsoup/nodes/Element.java.Element",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": "\nGet the value of a form element (input, textarea, etc).\n@return the value of the form element, or empty string if not set.\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Element.java.Element.[Element]val(String)",
        "name": "val",
        "arg_nums": 1,
        "params": [
            {
                "name": "value",
                "type": "String"
            }
        ],
        "return_type": "Element",
        "signature": "public Element val(String value)",
        "original_string": "    public Element val(String value) {\n        if (elementIs(\"textarea\", NamespaceHtml))\n            text(value);\n        else\n            attr(\"value\", value);\n        return this;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "Element",
        "class_uri": "src/main/java/org/jsoup/nodes/Element.java.Element",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Element",
            "classes": []
        },
        "docstring": "\nSet the value of a form element (input, textarea, etc).\n@param value value to set\n@return this element (for chaining)\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Element.java.Element.[Range]endSourceRange()",
        "name": "endSourceRange",
        "arg_nums": 0,
        "params": [],
        "return_type": "Range",
        "signature": "public Range endSourceRange()",
        "original_string": "    public Range endSourceRange() {\n        return Range.of(this, false);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "Element",
        "class_uri": "src/main/java/org/jsoup/nodes/Element.java.Element",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Range",
            "classes": []
        },
        "docstring": "\nGet the source range (start and end positions) of the end (closing) tag for this Element. Position tracking must be\nenabled prior to parsing the content.\n@return the range of the closing tag for this element, or {@code untracked} if its range was not tracked.\n@see org.jsoup.parser.Parser#setTrackPosition(boolean)\n@see Node#sourceRange()\n@see Range#isImplicit()\n@since 1.15.2\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Element.java.Element.[boolean]shouldIndent(Document.OutputSettings)",
        "name": "shouldIndent",
        "arg_nums": 1,
        "params": [
            {
                "name": "out",
                "type": "Document.OutputSettings"
            }
        ],
        "return_type": "boolean",
        "signature": "boolean shouldIndent(final Document.OutputSettings out)",
        "original_string": "    boolean shouldIndent(final Document.OutputSettings out) {\n        return out.prettyPrint() && isFormatAsBlock(out) && !isInlineable(out) && !preserveWhitespace(parentNode);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "Element",
        "class_uri": "src/main/java/org/jsoup/nodes/Element.java.Element",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Element.java.Element.[void]outerHtmlHead(Appendable,int,Document.OutputSettings)",
        "name": "outerHtmlHead",
        "arg_nums": 3,
        "params": [
            {
                "name": "accum",
                "type": "Appendable"
            },
            {
                "name": "depth",
                "type": "int"
            },
            {
                "name": "out",
                "type": "Document.OutputSettings"
            }
        ],
        "return_type": "void",
        "signature": "@Override\n    void outerHtmlHead(final Appendable accum, int depth, final Document.OutputSettings out)",
        "original_string": "    @Override\n    void outerHtmlHead(final Appendable accum, int depth, final Document.OutputSettings out) throws IOException {\n        if (shouldIndent(out)) {\n            if (accum instanceof StringBuilder) {\n                if (((StringBuilder) accum).length() > 0)\n                    indent(accum, depth, out);\n            } else {\n                indent(accum, depth, out);\n            }\n        }\n        accum.append('<').append(tagName());\n        if (attributes != null) attributes.html(accum, out);\n\n        // selfclosing includes unknown tags, isEmpty defines tags that are always empty\n        if (childNodes.isEmpty() && tag.isSelfClosing()) {\n            if (out.syntax() == Document.OutputSettings.Syntax.html && tag.isEmpty())\n                accum.append('>');\n            else\n                accum.append(\" />\"); // <img> in html, <img /> in xml\n        }\n        else\n            accum.append('>');\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "Element",
        "class_uri": "src/main/java/org/jsoup/nodes/Element.java.Element",
        "attributes": {
            "modifiers": "@Override",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Element.java.Element.[void]outerHtmlTail(Appendable,int,Document.OutputSettings)",
        "name": "outerHtmlTail",
        "arg_nums": 3,
        "params": [
            {
                "name": "accum",
                "type": "Appendable"
            },
            {
                "name": "depth",
                "type": "int"
            },
            {
                "name": "out",
                "type": "Document.OutputSettings"
            }
        ],
        "return_type": "void",
        "signature": "@Override\n    void outerHtmlTail(Appendable accum, int depth, Document.OutputSettings out)",
        "original_string": "    @Override\n    void outerHtmlTail(Appendable accum, int depth, Document.OutputSettings out) throws IOException {\n        if (!(childNodes.isEmpty() && tag.isSelfClosing())) {\n            if (out.prettyPrint() && (!childNodes.isEmpty() && (\n                (tag.formatAsBlock() && !preserveWhitespace(parentNode)) ||\n                    (out.outline() && (childNodes.size()>1 || (childNodes.size()==1 && (childNodes.get(0) instanceof Element))))\n            )))\n                indent(accum, depth, out);\n            accum.append(\"</\").append(tagName()).append('>');\n        }\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "Element",
        "class_uri": "src/main/java/org/jsoup/nodes/Element.java.Element",
        "attributes": {
            "modifiers": "@Override",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Element.java.Element.[String]html()",
        "name": "html",
        "arg_nums": 0,
        "params": [],
        "return_type": "String",
        "signature": "public String html()",
        "original_string": "    public String html() {\n        StringBuilder accum = StringUtil.borrowBuilder();\n        html(accum);\n        String html = StringUtil.releaseBuilder(accum);\n        return NodeUtils.outputSettings(this).prettyPrint() ? html.trim() : html;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "Element",
        "class_uri": "src/main/java/org/jsoup/nodes/Element.java.Element",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": "\nRetrieves the element's inner HTML. E.g. on a {@code <div>} with one empty {@code <p>}, would return\n{@code <p></p>}. (Whereas {@link #outerHtml()} would return {@code <div><p></p></div>}.)\n\n@return String of HTML.\n@see #outerHtml()\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Element.java.Element.[T]html(T)",
        "name": "html",
        "arg_nums": 1,
        "params": [
            {
                "name": "appendable",
                "type": "T"
            }
        ],
        "return_type": "T",
        "signature": "@Override\n    public <T extends Appendable> T html(T appendable)",
        "original_string": "    @Override\n    public <T extends Appendable> T html(T appendable) {\n        final int size = childNodes.size();\n        for (int i = 0; i < size; i++)\n            childNodes.get(i).outerHtml(appendable);\n\n        return appendable;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "Element",
        "class_uri": "src/main/java/org/jsoup/nodes/Element.java.Element",
        "attributes": {
            "modifiers": "@Override\n    public",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "T",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Element.java.Element.[Element]html(String)",
        "name": "html",
        "arg_nums": 1,
        "params": [
            {
                "name": "html",
                "type": "String"
            }
        ],
        "return_type": "Element",
        "signature": "public Element html(String html)",
        "original_string": "    public Element html(String html) {\n        empty();\n        append(html);\n        return this;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "Element",
        "class_uri": "src/main/java/org/jsoup/nodes/Element.java.Element",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Element",
            "classes": []
        },
        "docstring": "\nSet this element's inner HTML. Clears the existing HTML first.\n@param html HTML to parse and set into this element\n@return this element\n@see #append(String)\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Element.java.Element.[Element]clone()",
        "name": "clone",
        "arg_nums": 0,
        "params": [],
        "return_type": "Element",
        "signature": "@Override\n    public Element clone()",
        "original_string": "    @Override\n    public Element clone() {\n        return (Element) super.clone();\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "Element",
        "class_uri": "src/main/java/org/jsoup/nodes/Element.java.Element",
        "attributes": {
            "modifiers": "@Override\n    public",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Element",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Element.java.Element.[Element]shallowClone()",
        "name": "shallowClone",
        "arg_nums": 0,
        "params": [],
        "return_type": "Element",
        "signature": "@Override\n    public Element shallowClone()",
        "original_string": "    @Override\n    public Element shallowClone() {\n        // simpler than implementing a clone version with no child copy\n        String baseUri = baseUri();\n        if (baseUri.isEmpty()) baseUri = null; // saves setting a blank internal attribute\n        return new Element(tag, baseUri, attributes == null ? null : attributes.clone());\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "Element",
        "class_uri": "src/main/java/org/jsoup/nodes/Element.java.Element",
        "attributes": {
            "modifiers": "@Override\n    public",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Element",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Element.java.Element.[Element]doClone(Node)",
        "name": "doClone",
        "arg_nums": 1,
        "params": [
            {
                "name": "parent",
                "type": "Node"
            }
        ],
        "return_type": "Element",
        "signature": "@Override\n    protected Element doClone(@Nullable Node parent)",
        "original_string": "    @Override\n    protected Element doClone(@Nullable Node parent) {\n        Element clone = (Element) super.doClone(parent);\n        clone.attributes = attributes != null ? attributes.clone() : null;\n        clone.childNodes = new NodeList(clone, childNodes.size());\n        clone.childNodes.addAll(childNodes); // the children then get iterated and cloned in Node.clone\n\n        return clone;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "Element",
        "class_uri": "src/main/java/org/jsoup/nodes/Element.java.Element",
        "attributes": {
            "modifiers": "@Override\n    protected",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "protected"
            ],
            "comments": [],
            "return_type": "Element",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Element.java.Element.[Element]clearAttributes()",
        "name": "clearAttributes",
        "arg_nums": 0,
        "params": [],
        "return_type": "Element",
        "signature": "@Override\n    public Element clearAttributes()",
        "original_string": "    @Override\n    public Element clearAttributes() {\n        if (attributes != null) {\n            super.clearAttributes(); // keeps internal attributes via iterator\n            if (attributes.size() == 0)\n                attributes = null; // only remove entirely if no internal attributes\n        }\n\n        return this;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "Element",
        "class_uri": "src/main/java/org/jsoup/nodes/Element.java.Element",
        "attributes": {
            "modifiers": "@Override\n    public",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Element",
            "classes": []
        },
        "docstring": " overrides of Node for call chaining"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Element.java.Element.[Element]removeAttr(String)",
        "name": "removeAttr",
        "arg_nums": 1,
        "params": [
            {
                "name": "attributeKey",
                "type": "String"
            }
        ],
        "return_type": "Element",
        "signature": "@Override\n    public Element removeAttr(String attributeKey)",
        "original_string": "    @Override\n    public Element removeAttr(String attributeKey) {\n        return (Element) super.removeAttr(attributeKey);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "Element",
        "class_uri": "src/main/java/org/jsoup/nodes/Element.java.Element",
        "attributes": {
            "modifiers": "@Override\n    public",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Element",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Element.java.Element.[Element]root()",
        "name": "root",
        "arg_nums": 0,
        "params": [],
        "return_type": "Element",
        "signature": "@Override\n    public Element root()",
        "original_string": "    @Override\n    public Element root() {\n        return (Element) super.root(); // probably a document, but always at least an element\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "Element",
        "class_uri": "src/main/java/org/jsoup/nodes/Element.java.Element",
        "attributes": {
            "modifiers": "@Override\n    public",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Element",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Element.java.Element.[Element]traverse(NodeVisitor)",
        "name": "traverse",
        "arg_nums": 1,
        "params": [
            {
                "name": "nodeVisitor",
                "type": "NodeVisitor"
            }
        ],
        "return_type": "Element",
        "signature": "@Override\n    public Element traverse(NodeVisitor nodeVisitor)",
        "original_string": "    @Override\n    public Element traverse(NodeVisitor nodeVisitor) {\n        return (Element) super.traverse(nodeVisitor);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "Element",
        "class_uri": "src/main/java/org/jsoup/nodes/Element.java.Element",
        "attributes": {
            "modifiers": "@Override\n    public",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Element",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Element.java.Element.[Element]forEachNode(Consumer<? super Node>)",
        "name": "forEachNode",
        "arg_nums": 1,
        "params": [
            {
                "name": "action",
                "type": "Consumer<? super Node>"
            }
        ],
        "return_type": "Element",
        "signature": "@Override\n    public Element forEachNode(Consumer<? super Node> action)",
        "original_string": "    @Override\n    public Element forEachNode(Consumer<? super Node> action) {\n        return (Element) super.forEachNode(action);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "Element",
        "class_uri": "src/main/java/org/jsoup/nodes/Element.java.Element",
        "attributes": {
            "modifiers": "@Override\n    public",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Element",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Element.java.Element.[Element]forEach(Consumer<? super Element>)",
        "name": "forEach",
        "arg_nums": 1,
        "params": [
            {
                "name": "action",
                "type": "Consumer<? super Element>"
            }
        ],
        "return_type": "Element",
        "signature": "@Deprecated\n    public Element forEach(Consumer<? super Element> action)",
        "original_string": "    @Deprecated\n    public Element forEach(Consumer<? super Element> action) {\n        stream().forEach(action);\n        return this;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "Element",
        "class_uri": "src/main/java/org/jsoup/nodes/Element.java.Element",
        "attributes": {
            "modifiers": "@Deprecated\n    public",
            "marker_annotations": [
                "@Deprecated"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Element",
            "classes": []
        },
        "docstring": "\nPerform the supplied action on this Element and each of its descendant Elements, during a depth-first traversal.\nElements may be inspected, changed, added, replaced, or removed.\n@param action the function to perform on the element\n@return this Element, for chaining\n@see Node#forEachNode(Consumer)\n@deprecated use {@link #stream()}.{@link Stream#forEach(Consumer) forEach(Consumer)} instead. (Removing this method\nso Element can implement Iterable, which this signature conflicts with due to the non-void return.)\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Element.java.Element.[Element]filter(NodeFilter)",
        "name": "filter",
        "arg_nums": 1,
        "params": [
            {
                "name": "nodeFilter",
                "type": "NodeFilter"
            }
        ],
        "return_type": "Element",
        "signature": "@Override\n    public Element filter(NodeFilter nodeFilter)",
        "original_string": "    @Override\n    public Element filter(NodeFilter nodeFilter) {\n        return  (Element) super.filter(nodeFilter);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "Element",
        "class_uri": "src/main/java/org/jsoup/nodes/Element.java.Element",
        "attributes": {
            "modifiers": "@Override\n    public",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Element",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Element.java.Element.[boolean]isFormatAsBlock(Document.OutputSettings)",
        "name": "isFormatAsBlock",
        "arg_nums": 1,
        "params": [
            {
                "name": "out",
                "type": "Document.OutputSettings"
            }
        ],
        "return_type": "boolean",
        "signature": "private boolean isFormatAsBlock(Document.OutputSettings out)",
        "original_string": "    private boolean isFormatAsBlock(Document.OutputSettings out) {\n        return tag.isBlock() || (parent() != null && parent().tag().formatAsBlock()) || out.outline();\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "Element",
        "class_uri": "src/main/java/org/jsoup/nodes/Element.java.Element",
        "attributes": {
            "modifiers": "private",
            "marker_annotations": [],
            "non_marker_annotations": [
                "private"
            ],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Element.java.Element.[boolean]isInlineable(Document.OutputSettings)",
        "name": "isInlineable",
        "arg_nums": 1,
        "params": [
            {
                "name": "out",
                "type": "Document.OutputSettings"
            }
        ],
        "return_type": "boolean",
        "signature": "private boolean isInlineable(Document.OutputSettings out)",
        "original_string": "    private boolean isInlineable(Document.OutputSettings out) {\n        if (!tag.isInline())\n            return false;\n        return (parent() == null || parent().isBlock())\n            && !isEffectivelyFirst()\n            && !out.outline()\n            && !nameIs(\"br\");\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "Element",
        "class_uri": "src/main/java/org/jsoup/nodes/Element.java.Element",
        "attributes": {
            "modifiers": "private",
            "marker_annotations": [],
            "non_marker_annotations": [
                "private"
            ],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Range.java.Range.[]Range(Position,Position)",
        "name": "Range",
        "arg_nums": 2,
        "params": [
            {
                "name": "start",
                "type": "Position"
            },
            {
                "name": "end",
                "type": "Position"
            }
        ],
        "return_type": "",
        "signature": "public Range(Position start, Position end)",
        "original_string": "    public Range(Position start, Position end) {\n        this.start = start;\n        this.end = end;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Range.java",
        "class_name": "Range",
        "class_uri": "src/main/java/org/jsoup/nodes/Range.java.Range",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "",
            "classes": []
        },
        "docstring": "\nCreates a new Range with start and end Positions. Called by TreeBuilder when position tracking is on.\n@param start the start position\n@param end the end position\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Range.java.Range.[Position]start()",
        "name": "start",
        "arg_nums": 0,
        "params": [],
        "return_type": "Position",
        "signature": "public Position start()",
        "original_string": "    public Position start() {\n        return start;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Range.java",
        "class_name": "Range",
        "class_uri": "src/main/java/org/jsoup/nodes/Range.java.Range",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Position",
            "classes": []
        },
        "docstring": "\nGet the start position of this node.\n@return the start position\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Range.java.Range.[int]startPos()",
        "name": "startPos",
        "arg_nums": 0,
        "params": [],
        "return_type": "int",
        "signature": "public int startPos()",
        "original_string": "    public int startPos() {\n        return start.pos;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Range.java",
        "class_name": "Range",
        "class_uri": "src/main/java/org/jsoup/nodes/Range.java.Range",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "int",
            "classes": []
        },
        "docstring": "\nGet the starting cursor position of this range.\n@return the 0-based start cursor position.\n@since 1.17.1\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Range.java.Range.[Position]end()",
        "name": "end",
        "arg_nums": 0,
        "params": [],
        "return_type": "Position",
        "signature": "public Position end()",
        "original_string": "    public Position end() {\n        return end;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Range.java",
        "class_name": "Range",
        "class_uri": "src/main/java/org/jsoup/nodes/Range.java.Range",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Position",
            "classes": []
        },
        "docstring": "\nGet the end position of this node.\n@return the end position\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Range.java.Range.[int]endPos()",
        "name": "endPos",
        "arg_nums": 0,
        "params": [],
        "return_type": "int",
        "signature": "public int endPos()",
        "original_string": "    public int endPos() {\n        return end.pos;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Range.java",
        "class_name": "Range",
        "class_uri": "src/main/java/org/jsoup/nodes/Range.java.Range",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "int",
            "classes": []
        },
        "docstring": "\nGet the ending cursor position of this range.\n@return the 0-based ending cursor position.\n@since 1.17.1\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Range.java.Range.[boolean]isTracked()",
        "name": "isTracked",
        "arg_nums": 0,
        "params": [],
        "return_type": "boolean",
        "signature": "public boolean isTracked()",
        "original_string": "    public boolean isTracked() {\n        return this != Untracked;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Range.java",
        "class_name": "Range",
        "class_uri": "src/main/java/org/jsoup/nodes/Range.java.Range",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": "\nTest if this source range was tracked during parsing.\n@return true if this was tracked during parsing, false otherwise (and all fields will be {@code -1}).\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Range.java.Range.[boolean]isImplicit()",
        "name": "isImplicit",
        "arg_nums": 0,
        "params": [],
        "return_type": "boolean",
        "signature": "public boolean isImplicit()",
        "original_string": "    public boolean isImplicit() {\n        if (!isTracked()) return false;\n        return start.equals(end);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Range.java",
        "class_name": "Range",
        "class_uri": "src/main/java/org/jsoup/nodes/Range.java.Range",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": "\nChecks if the range represents a node that was implicitly created / closed.\n<p>For example, with HTML of {@code <p>One<p>Two}, both {@code p} elements will have an explicit\n{@link Element#sourceRange()} but an implicit {@link Element#endSourceRange()} marking the end position, as neither\nhave closing {@code </p>} tags. The TextNodes will have explicit sourceRanges.\n<p>A range is considered implicit if its start and end positions are the same.\n@return true if the range is tracked and its start and end positions are the same, false otherwise.\n@since 1.17.1\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Range.java.Range.[Range]of(Node,boolean)",
        "name": "of",
        "arg_nums": 2,
        "params": [
            {
                "name": "node",
                "type": "Node"
            },
            {
                "name": "start",
                "type": "boolean"
            }
        ],
        "return_type": "Range",
        "signature": "static Range of(Node node, boolean start)",
        "original_string": "    static Range of(Node node, boolean start) {\n        final String key = start ? RangeKey : EndRangeKey;\n        if (!node.hasAttributes()) return Untracked;\n        Object range = node.attributes().userData(key);\n        return range != null ? (Range) range : Untracked;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Range.java",
        "class_name": "Range",
        "class_uri": "src/main/java/org/jsoup/nodes/Range.java.Range",
        "attributes": {
            "modifiers": "static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "static"
            ],
            "comments": [],
            "return_type": "Range",
            "classes": []
        },
        "docstring": "\nRetrieves the source range for a given Node.\n@param node the node to retrieve the position for\n@param start if this is the starting range. {@code false} for Element end tags.\n@return the Range, or the Untracked (-1) position if tracking is disabled.\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Range.java.Range.[boolean]equals(Object)",
        "name": "equals",
        "arg_nums": 1,
        "params": [
            {
                "name": "o",
                "type": "Object"
            }
        ],
        "return_type": "boolean",
        "signature": "@Override\n    public boolean equals(Object o)",
        "original_string": "    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n\n        Range range = (Range) o;\n\n        if (!start.equals(range.start)) return false;\n        return end.equals(range.end);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Range.java",
        "class_name": "Range",
        "class_uri": "src/main/java/org/jsoup/nodes/Range.java.Range",
        "attributes": {
            "modifiers": "@Override\n    public",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Range.java.Range.[int]hashCode()",
        "name": "hashCode",
        "arg_nums": 0,
        "params": [],
        "return_type": "int",
        "signature": "@Override\n    public int hashCode()",
        "original_string": "    @Override\n    public int hashCode() {\n        return Objects.hash(start, end);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Range.java",
        "class_name": "Range",
        "class_uri": "src/main/java/org/jsoup/nodes/Range.java.Range",
        "attributes": {
            "modifiers": "@Override\n    public",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "int",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Range.java.Range.[String]toString()",
        "name": "toString",
        "arg_nums": 0,
        "params": [],
        "return_type": "String",
        "signature": "@Override\n    public String toString()",
        "original_string": "    @Override\n    public String toString() {\n        return start + \"-\" + end;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Range.java",
        "class_name": "Range",
        "class_uri": "src/main/java/org/jsoup/nodes/Range.java.Range",
        "attributes": {
            "modifiers": "@Override\n    public",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": "\nGets a String presentation of this Range, in the format {@code line,column:pos-line,column:pos}.\n@return a String\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/FormElement.java.FormElement.[]FormElement(Tag,String,Attributes)",
        "name": "FormElement",
        "arg_nums": 3,
        "params": [
            {
                "name": "tag",
                "type": "Tag"
            },
            {
                "name": "baseUri",
                "type": "String"
            },
            {
                "name": "attributes",
                "type": "Attributes"
            }
        ],
        "return_type": "",
        "signature": "public FormElement(Tag tag, @Nullable String baseUri, @Nullable Attributes attributes)",
        "original_string": "    public FormElement(Tag tag, @Nullable String baseUri, @Nullable Attributes attributes) {\n        super(tag, baseUri, attributes);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/FormElement.java",
        "class_name": "FormElement",
        "class_uri": "src/main/java/org/jsoup/nodes/FormElement.java.FormElement",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "",
            "classes": []
        },
        "docstring": "\nCreate a new, standalone form element.\n\n@param tag        tag of this element\n@param baseUri    the base URI\n@param attributes initial attributes\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/FormElement.java.FormElement.[Elements]elements()",
        "name": "elements",
        "arg_nums": 0,
        "params": [],
        "return_type": "Elements",
        "signature": "public Elements elements()",
        "original_string": "    public Elements elements() {\n        // As elements may have been added or removed from the DOM after parse, prepare a new list that unions them:\n        Elements els = select(submittable); // current form children\n        for (Element linkedEl : linkedEls) {\n            if (linkedEl.ownerDocument() != null && !els.contains(linkedEl)) {\n                els.add(linkedEl); // adds previously linked elements, that weren't previously removed from the DOM\n            }\n        }\n\n        return els;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/FormElement.java",
        "class_name": "FormElement",
        "class_uri": "src/main/java/org/jsoup/nodes/FormElement.java.FormElement",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Elements",
            "classes": []
        },
        "docstring": "\nGet the list of form control elements associated with this form.\n@return form controls associated with this element.\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/FormElement.java.FormElement.[FormElement]addElement(Element)",
        "name": "addElement",
        "arg_nums": 1,
        "params": [
            {
                "name": "element",
                "type": "Element"
            }
        ],
        "return_type": "FormElement",
        "signature": "public FormElement addElement(Element element)",
        "original_string": "    public FormElement addElement(Element element) {\n        linkedEls.add(element);\n        return this;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/FormElement.java",
        "class_name": "FormElement",
        "class_uri": "src/main/java/org/jsoup/nodes/FormElement.java.FormElement",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "FormElement",
            "classes": []
        },
        "docstring": "\nAdd a form control element to this form.\n@param element form control to add\n@return this form element, for chaining\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/FormElement.java.FormElement.[void]removeChild(Node)",
        "name": "removeChild",
        "arg_nums": 1,
        "params": [
            {
                "name": "out",
                "type": "Node"
            }
        ],
        "return_type": "void",
        "signature": "@Override\n    protected void removeChild(Node out)",
        "original_string": "    @Override\n    protected void removeChild(Node out) {\n        super.removeChild(out);\n        linkedEls.remove(out);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/FormElement.java",
        "class_name": "FormElement",
        "class_uri": "src/main/java/org/jsoup/nodes/FormElement.java.FormElement",
        "attributes": {
            "modifiers": "@Override\n    protected",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "protected"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/FormElement.java.FormElement.[Connection]submit()",
        "name": "submit",
        "arg_nums": 0,
        "params": [],
        "return_type": "Connection",
        "signature": "public Connection submit()",
        "original_string": "    public Connection submit() {\n        String action = hasAttr(\"action\") ? absUrl(\"action\") : baseUri();\n        Validate.notEmpty(action, \"Could not determine a form action URL for submit. Ensure you set a base URI when parsing.\");\n        Connection.Method method = attr(\"method\").equalsIgnoreCase(\"POST\") ?\n                Connection.Method.POST : Connection.Method.GET;\n\n        Document owner = ownerDocument();\n        Connection connection = owner != null? owner.connection().newRequest() : Jsoup.newSession();\n        return connection.url(action)\n                .data(formData())\n                .method(method);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/FormElement.java",
        "class_name": "FormElement",
        "class_uri": "src/main/java/org/jsoup/nodes/FormElement.java.FormElement",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Connection",
            "classes": []
        },
        "docstring": "\nPrepare to submit this form. A Connection object is created with the request set up from the form values. This\nConnection will inherit the settings and the cookies (etc) of the connection/session used to request this Document\n(if any), as available in {@link Document#connection()}\n<p>You can then set up other options (like user-agent, timeout, cookies), then execute it.</p>\n\n@return a connection prepared from the values of this form, in the same session as the one used to request it\n@throws IllegalArgumentException if the form's absolute action URL cannot be determined. Make sure you pass the\ndocument's base URI when parsing.\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/FormElement.java.FormElement.[List<Connection.KeyVal>]formData()",
        "name": "formData",
        "arg_nums": 0,
        "params": [],
        "return_type": "List<Connection.KeyVal>",
        "signature": "public List<Connection.KeyVal> formData()",
        "original_string": "    public List<Connection.KeyVal> formData() {\n        ArrayList<Connection.KeyVal> data = new ArrayList<>();\n\n        // iterate the form control elements and accumulate their values\n        Elements formEls = elements();\n        for (Element el: formEls) {\n            if (!el.tag().isFormSubmittable()) continue; // contents are form listable, superset of submitable\n            if (el.hasAttr(\"disabled\")) continue; // skip disabled form inputs\n            String name = el.attr(\"name\");\n            if (name.length() == 0) continue;\n            String type = el.attr(\"type\");\n\n            if (type.equalsIgnoreCase(\"button\") || type.equalsIgnoreCase(\"image\")) continue; // browsers don't submit these\n\n            if (el.nameIs(\"select\")) {\n                Elements options = el.select(\"option[selected]\");\n                boolean set = false;\n                for (Element option: options) {\n                    data.add(HttpConnection.KeyVal.create(name, option.val()));\n                    set = true;\n                }\n                if (!set) {\n                    Element option = el.selectFirst(\"option\");\n                    if (option != null)\n                        data.add(HttpConnection.KeyVal.create(name, option.val()));\n                }\n            } else if (\"checkbox\".equalsIgnoreCase(type) || \"radio\".equalsIgnoreCase(type)) {\n                // only add checkbox or radio if they have the checked attribute\n                if (el.hasAttr(\"checked\")) {\n                    final String val = el.val().length() >  0 ? el.val() : \"on\";\n                    data.add(HttpConnection.KeyVal.create(name, val));\n                }\n            } else {\n                data.add(HttpConnection.KeyVal.create(name, el.val()));\n            }\n        }\n        return data;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/FormElement.java",
        "class_name": "FormElement",
        "class_uri": "src/main/java/org/jsoup/nodes/FormElement.java.FormElement",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "List<Connection.KeyVal>",
            "classes": []
        },
        "docstring": "\nGet the data that this form submits. The returned list is a copy of the data, and changes to the contents of the\nlist will not be reflected in the DOM.\n@return a list of key vals\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/FormElement.java.FormElement.[FormElement]clone()",
        "name": "clone",
        "arg_nums": 0,
        "params": [],
        "return_type": "FormElement",
        "signature": "@Override\n    public FormElement clone()",
        "original_string": "    @Override\n    public FormElement clone() {\n        return (FormElement) super.clone();\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/FormElement.java",
        "class_name": "FormElement",
        "class_uri": "src/main/java/org/jsoup/nodes/FormElement.java.FormElement",
        "attributes": {
            "modifiers": "@Override\n    public",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "FormElement",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Document.java.Document.[]Document(String,String)",
        "name": "Document",
        "arg_nums": 2,
        "params": [
            {
                "name": "namespace",
                "type": "String"
            },
            {
                "name": "baseUri",
                "type": "String"
            }
        ],
        "return_type": "",
        "signature": "public Document(String namespace, String baseUri)",
        "original_string": "    public Document(String namespace, String baseUri) {\n        super(Tag.valueOf(\"#root\", namespace, ParseSettings.htmlDefault), baseUri);\n        this.location = baseUri;\n        this.parser = Parser.htmlParser(); // default, but overridable\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Document.java",
        "class_name": "Document",
        "class_uri": "src/main/java/org/jsoup/nodes/Document.java.Document",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "",
            "classes": []
        },
        "docstring": "\nCreate a new, empty Document, in the specified namespace.\n@param namespace the namespace of this Document's root node.\n@param baseUri base URI of document\n@see org.jsoup.Jsoup#parse\n@see #createShell\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Document.java.Document.[]Document(String)",
        "name": "Document",
        "arg_nums": 1,
        "params": [
            {
                "name": "baseUri",
                "type": "String"
            }
        ],
        "return_type": "",
        "signature": "public Document(String baseUri)",
        "original_string": "    public Document(String baseUri) {\n        this(NamespaceHtml, baseUri);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Document.java",
        "class_name": "Document",
        "class_uri": "src/main/java/org/jsoup/nodes/Document.java.Document",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "",
            "classes": []
        },
        "docstring": "\nCreate a new, empty Document, in the HTML namespace.\n@param baseUri base URI of document\n@see org.jsoup.Jsoup#parse\n@see #Document(String namespace, String baseUri)\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Document.java.Document.[Document]createShell(String)",
        "name": "createShell",
        "arg_nums": 1,
        "params": [
            {
                "name": "baseUri",
                "type": "String"
            }
        ],
        "return_type": "Document",
        "signature": "public static Document createShell(String baseUri)",
        "original_string": "    public static Document createShell(String baseUri) {\n        Validate.notNull(baseUri);\n\n        Document doc = new Document(baseUri);\n        Element html = doc.appendElement(\"html\");\n        html.appendElement(\"head\");\n        html.appendElement(\"body\");\n\n        return doc;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Document.java",
        "class_name": "Document",
        "class_uri": "src/main/java/org/jsoup/nodes/Document.java.Document",
        "attributes": {
            "modifiers": "public static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public",
                "static"
            ],
            "comments": [],
            "return_type": "Document",
            "classes": []
        },
        "docstring": "\nCreate a valid, empty shell of a document, suitable for adding more elements to.\n@param baseUri baseUri of document\n@return document with html, head, and body elements.\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Document.java.Document.[String]location()",
        "name": "location",
        "arg_nums": 0,
        "params": [],
        "return_type": "String",
        "signature": "public String location()",
        "original_string": "    public String location() {\n        return location;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Document.java",
        "class_name": "Document",
        "class_uri": "src/main/java/org/jsoup/nodes/Document.java.Document",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": "\nGet the URL this Document was parsed from. If the starting URL is a redirect,\nthis will return the final URL from which the document was served from.\n<p>Will return an empty string if the location is unknown (e.g. if parsed from a String).\n@return location\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Document.java.Document.[Connection]connection()",
        "name": "connection",
        "arg_nums": 0,
        "params": [],
        "return_type": "Connection",
        "signature": "public Connection connection()",
        "original_string": "    public Connection connection() {\n        if (connection == null)\n            return Jsoup.newSession();\n        else\n            return connection;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Document.java",
        "class_name": "Document",
        "class_uri": "src/main/java/org/jsoup/nodes/Document.java.Document",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Connection",
            "classes": []
        },
        "docstring": "\nReturns the Connection (Request/Response) object that was used to fetch this document, if any; otherwise, a new\ndefault Connection object. This can be used to continue a session, preserving settings and cookies, etc.\n@return the Connection (session) associated with this Document, or an empty one otherwise.\n@see Connection#newRequest()\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Document.java.Document.[DocumentType]documentType()",
        "name": "documentType",
        "arg_nums": 0,
        "params": [],
        "return_type": "DocumentType",
        "signature": "public @Nullable DocumentType documentType()",
        "original_string": "    public @Nullable DocumentType documentType() {\n        for (Node node : childNodes) {\n            if (node instanceof DocumentType)\n                return (DocumentType) node;\n            else if (!(node instanceof LeafNode)) // scans forward across comments, text, processing instructions etc\n                break;\n        }\n        return null;\n        // todo - add a set document type?\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Document.java",
        "class_name": "Document",
        "class_uri": "src/main/java/org/jsoup/nodes/Document.java.Document",
        "attributes": {
            "modifiers": "public @Nullable",
            "marker_annotations": [
                "@Nullable"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "DocumentType",
            "classes": []
        },
        "docstring": "\nReturns this Document's doctype.\n@return document type, or null if not set\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Document.java.Document.[Element]htmlEl()",
        "name": "htmlEl",
        "arg_nums": 0,
        "params": [],
        "return_type": "Element",
        "signature": "private Element htmlEl()",
        "original_string": "    private Element htmlEl() {\n        Element el = firstElementChild();\n        while (el != null) {\n            if (el.nameIs(\"html\"))\n                return el;\n            el = el.nextElementSibling();\n        }\n        return appendElement(\"html\");\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Document.java",
        "class_name": "Document",
        "class_uri": "src/main/java/org/jsoup/nodes/Document.java.Document",
        "attributes": {
            "modifiers": "private",
            "marker_annotations": [],
            "non_marker_annotations": [
                "private"
            ],
            "comments": [],
            "return_type": "Element",
            "classes": []
        },
        "docstring": "\nFind the root HTML element, or create it if it doesn't exist.\n@return the root HTML element.\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Document.java.Document.[Element]head()",
        "name": "head",
        "arg_nums": 0,
        "params": [],
        "return_type": "Element",
        "signature": "public Element head()",
        "original_string": "    public Element head() {\n        final Element html = htmlEl();\n        Element el = html.firstElementChild();\n        while (el != null) {\n            if (el.nameIs(\"head\"))\n                return el;\n            el = el.nextElementSibling();\n        }\n        return html.prependElement(\"head\");\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Document.java",
        "class_name": "Document",
        "class_uri": "src/main/java/org/jsoup/nodes/Document.java.Document",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Element",
            "classes": []
        },
        "docstring": "\nGet this document's {@code head} element.\n<p>\nAs a side effect, if this Document does not already have an HTML structure, it will be created. If you do not want\nthat, use {@code #selectFirst(\"head\")} instead.\n\n@return {@code head} element.\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Document.java.Document.[Element]body()",
        "name": "body",
        "arg_nums": 0,
        "params": [],
        "return_type": "Element",
        "signature": "public Element body()",
        "original_string": "    public Element body() {\n        final Element html = htmlEl();\n        Element el = html.firstElementChild();\n        while (el != null) {\n            if (el.nameIs(\"body\") || el.nameIs(\"frameset\"))\n                return el;\n            el = el.nextElementSibling();\n        }\n        return html.appendElement(\"body\");\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Document.java",
        "class_name": "Document",
        "class_uri": "src/main/java/org/jsoup/nodes/Document.java.Document",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Element",
            "classes": []
        },
        "docstring": "\nGet this document's {@code <body>} or {@code <frameset>} element.\n<p>\nAs a <b>side-effect</b>, if this Document does not already have an HTML structure, it will be created with a {@code\n<body>} element. If you do not want that, use {@code #selectFirst(\"body\")} instead.\n\n@return {@code body} element for documents with a {@code <body>}, a new {@code <body>} element if the document\nhad no contents, or the outermost {@code <frameset> element} for frameset documents.\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Document.java.Document.[List<FormElement>]forms()",
        "name": "forms",
        "arg_nums": 0,
        "params": [],
        "return_type": "List<FormElement>",
        "signature": "public List<FormElement> forms()",
        "original_string": "    public List<FormElement> forms() {\n        return select(\"form\").forms();\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Document.java",
        "class_name": "Document",
        "class_uri": "src/main/java/org/jsoup/nodes/Document.java.Document",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "List<FormElement>",
            "classes": []
        },
        "docstring": "\nGet each of the {@code <form>} elements contained in this document.\n@return a List of FormElement objects, which will be empty if there are none.\n@see Elements#forms()\n@see FormElement#elements()\n@since 1.15.4\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Document.java.Document.[FormElement]expectForm(String)",
        "name": "expectForm",
        "arg_nums": 1,
        "params": [
            {
                "name": "cssQuery",
                "type": "String"
            }
        ],
        "return_type": "FormElement",
        "signature": "public FormElement expectForm(String cssQuery)",
        "original_string": "    public FormElement expectForm(String cssQuery) {\n        Elements els = select(cssQuery);\n        for (Element el : els) {\n            if (el instanceof FormElement) return (FormElement) el;\n        }\n        Validate.fail(\"No form elements matched the query '%s' in the document.\", cssQuery);\n        return null; // (not really)\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Document.java",
        "class_name": "Document",
        "class_uri": "src/main/java/org/jsoup/nodes/Document.java.Document",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "FormElement",
            "classes": []
        },
        "docstring": "\nSelects the first {@link FormElement} in this document that matches the query. If none match, throws an\n{@link IllegalArgumentException}.\n@param cssQuery a {@link Selector} CSS query\n@return the first matching {@code <form>} element\n@throws IllegalArgumentException if no match is found\n@since 1.15.4\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Document.java.Document.[String]title()",
        "name": "title",
        "arg_nums": 0,
        "params": [],
        "return_type": "String",
        "signature": "public String title()",
        "original_string": "    public String title() {\n        // title is a preserve whitespace tag (for document output), but normalised here\n        Element titleEl = head().selectFirst(titleEval);\n        return titleEl != null ? StringUtil.normaliseWhitespace(titleEl.text()).trim() : \"\";\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Document.java",
        "class_name": "Document",
        "class_uri": "src/main/java/org/jsoup/nodes/Document.java.Document",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": "\nGet the string contents of the document's {@code title} element.\n@return Trimmed title, or empty string if none set.\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Document.java.Document.[void]title(String)",
        "name": "title",
        "arg_nums": 1,
        "params": [
            {
                "name": "title",
                "type": "String"
            }
        ],
        "return_type": "void",
        "signature": "public void title(String title)",
        "original_string": "    public void title(String title) {\n        Validate.notNull(title);\n        Element titleEl = head().selectFirst(titleEval);\n        if (titleEl == null) // add to head\n            titleEl = head().appendElement(\"title\");\n        titleEl.text(title);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Document.java",
        "class_name": "Document",
        "class_uri": "src/main/java/org/jsoup/nodes/Document.java.Document",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": "\nSet the document's {@code title} element. Updates the existing element, or adds {@code title} to {@code head} if\nnot present\n@param title string to set as title\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Document.java.Document.[Element]createElement(String)",
        "name": "createElement",
        "arg_nums": 1,
        "params": [
            {
                "name": "tagName",
                "type": "String"
            }
        ],
        "return_type": "Element",
        "signature": "public Element createElement(String tagName)",
        "original_string": "    public Element createElement(String tagName) {\n        return new Element(Tag.valueOf(tagName, parser.defaultNamespace(), ParseSettings.preserveCase), this.baseUri());\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Document.java",
        "class_name": "Document",
        "class_uri": "src/main/java/org/jsoup/nodes/Document.java.Document",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Element",
            "classes": []
        },
        "docstring": "\nCreate a new Element, with this document's base uri. Does not make the new element a child of this document.\n@param tagName element tag name (e.g. {@code a})\n@return new element\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Document.java.Document.[String]outerHtml()",
        "name": "outerHtml",
        "arg_nums": 0,
        "params": [],
        "return_type": "String",
        "signature": "@Override\n    public String outerHtml()",
        "original_string": "    @Override\n    public String outerHtml() {\n        return super.html(); // no outer wrapper tag\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Document.java",
        "class_name": "Document",
        "class_uri": "src/main/java/org/jsoup/nodes/Document.java.Document",
        "attributes": {
            "modifiers": "@Override\n    public",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Document.java.Document.[Element]text(String)",
        "name": "text",
        "arg_nums": 1,
        "params": [
            {
                "name": "text",
                "type": "String"
            }
        ],
        "return_type": "Element",
        "signature": "@Override\n    public Element text(String text)",
        "original_string": "    @Override\n    public Element text(String text) {\n        body().text(text); // overridden to not nuke doc structure\n        return this;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Document.java",
        "class_name": "Document",
        "class_uri": "src/main/java/org/jsoup/nodes/Document.java.Document",
        "attributes": {
            "modifiers": "@Override\n    public",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Element",
            "classes": []
        },
        "docstring": "\nSet the text of the {@code body} of this document. Any existing nodes within the body will be cleared.\n@param text un-encoded text\n@return this document\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Document.java.Document.[String]nodeName()",
        "name": "nodeName",
        "arg_nums": 0,
        "params": [],
        "return_type": "String",
        "signature": "@Override\n    public String nodeName()",
        "original_string": "    @Override\n    public String nodeName() {\n        return \"#document\";\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Document.java",
        "class_name": "Document",
        "class_uri": "src/main/java/org/jsoup/nodes/Document.java.Document",
        "attributes": {
            "modifiers": "@Override\n    public",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Document.java.Document.[void]charset(Charset)",
        "name": "charset",
        "arg_nums": 1,
        "params": [
            {
                "name": "charset",
                "type": "Charset"
            }
        ],
        "return_type": "void",
        "signature": "public void charset(Charset charset)",
        "original_string": "    public void charset(Charset charset) {\n        updateMetaCharsetElement(true);\n        outputSettings.charset(charset);\n        ensureMetaCharsetElement();\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Document.java",
        "class_name": "Document",
        "class_uri": "src/main/java/org/jsoup/nodes/Document.java.Document",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": "\nSets the charset used in this document. This method is equivalent\nto {@link OutputSettings#charset(java.nio.charset.Charset)\nOutputSettings.charset(Charset)} but in addition it updates the\ncharset / encoding element within the document.\n\n<p>This enables\n{@link #updateMetaCharsetElement(boolean) meta charset update}.</p>\n\n<p>If there's no element with charset / encoding information yet it will\nbe created. Obsolete charset / encoding definitions are removed!</p>\n\n<p><b>Elements used:</b></p>\n\n<ul>\n<li><b>Html:</b> <i>&lt;meta charset=\"CHARSET\"&gt;</i></li>\n<li><b>Xml:</b> <i>&lt;?xml version=\"1.0\" encoding=\"CHARSET\"&gt;</i></li>\n</ul>\n\n@param charset Charset\n\n@see #updateMetaCharsetElement(boolean) \n@see OutputSettings#charset(java.nio.charset.Charset) \n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Document.java.Document.[Charset]charset()",
        "name": "charset",
        "arg_nums": 0,
        "params": [],
        "return_type": "Charset",
        "signature": "public Charset charset()",
        "original_string": "    public Charset charset() {\n        return outputSettings.charset();\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Document.java",
        "class_name": "Document",
        "class_uri": "src/main/java/org/jsoup/nodes/Document.java.Document",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Charset",
            "classes": []
        },
        "docstring": "\nReturns the charset used in this document. This method is equivalent\nto {@link OutputSettings#charset()}.\n\n@return Current Charset\n\n@see OutputSettings#charset() \n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Document.java.Document.[void]updateMetaCharsetElement(boolean)",
        "name": "updateMetaCharsetElement",
        "arg_nums": 1,
        "params": [
            {
                "name": "update",
                "type": "boolean"
            }
        ],
        "return_type": "void",
        "signature": "public void updateMetaCharsetElement(boolean update)",
        "original_string": "    public void updateMetaCharsetElement(boolean update) {\n        this.updateMetaCharset = update;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Document.java",
        "class_name": "Document",
        "class_uri": "src/main/java/org/jsoup/nodes/Document.java.Document",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": "\nSets whether the element with charset information in this document is\nupdated on changes through {@link #charset(java.nio.charset.Charset)\nDocument.charset(Charset)} or not.\n\n<p>If set to <tt>false</tt> <i>(default)</i> there are no elements\nmodified.</p>\n\n@param update If <tt>true</tt> the element updated on charset\nchanges, <tt>false</tt> if not\n\n@see #charset(java.nio.charset.Charset) \n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Document.java.Document.[boolean]updateMetaCharsetElement()",
        "name": "updateMetaCharsetElement",
        "arg_nums": 0,
        "params": [],
        "return_type": "boolean",
        "signature": "public boolean updateMetaCharsetElement()",
        "original_string": "    public boolean updateMetaCharsetElement() {\n        return updateMetaCharset;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Document.java",
        "class_name": "Document",
        "class_uri": "src/main/java/org/jsoup/nodes/Document.java.Document",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": "\nReturns whether the element with charset information in this document is\nupdated on changes through {@link #charset(java.nio.charset.Charset)\nDocument.charset(Charset)} or not.\n\n@return Returns <tt>true</tt> if the element is updated on charset\nchanges, <tt>false</tt> if not\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Document.java.Document.[Document]clone()",
        "name": "clone",
        "arg_nums": 0,
        "params": [],
        "return_type": "Document",
        "signature": "@Override\n    public Document clone()",
        "original_string": "    @Override\n    public Document clone() {\n        Document clone = (Document) super.clone();\n        clone.outputSettings = this.outputSettings.clone();\n        return clone;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Document.java",
        "class_name": "Document",
        "class_uri": "src/main/java/org/jsoup/nodes/Document.java.Document",
        "attributes": {
            "modifiers": "@Override\n    public",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Document",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Document.java.Document.[Document]shallowClone()",
        "name": "shallowClone",
        "arg_nums": 0,
        "params": [],
        "return_type": "Document",
        "signature": "@Override\n    public Document shallowClone()",
        "original_string": "    @Override\n    public Document shallowClone() {\n        Document clone = new Document(this.tag().namespace(), baseUri());\n        if (attributes != null)\n            clone.attributes = attributes.clone();\n        clone.outputSettings = this.outputSettings.clone();\n        return clone;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Document.java",
        "class_name": "Document",
        "class_uri": "src/main/java/org/jsoup/nodes/Document.java.Document",
        "attributes": {
            "modifiers": "@Override\n    public",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Document",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Document.java.Document.[void]ensureMetaCharsetElement()",
        "name": "ensureMetaCharsetElement",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "private void ensureMetaCharsetElement()",
        "original_string": "    private void ensureMetaCharsetElement() {\n        if (updateMetaCharset) {\n            OutputSettings.Syntax syntax = outputSettings().syntax();\n\n            if (syntax == OutputSettings.Syntax.html) {\n                Element metaCharset = selectFirst(\"meta[charset]\");\n                if (metaCharset != null) {\n                    metaCharset.attr(\"charset\", charset().displayName());\n                } else {\n                    head().appendElement(\"meta\").attr(\"charset\", charset().displayName());\n                }\n                select(\"meta[name=charset]\").remove(); // Remove obsolete elements\n            } else if (syntax == OutputSettings.Syntax.xml) {\n                Node node = ensureChildNodes().get(0);\n                if (node instanceof XmlDeclaration) {\n                    XmlDeclaration decl = (XmlDeclaration) node;\n                    if (decl.name().equals(\"xml\")) {\n                        decl.attr(\"encoding\", charset().displayName());\n                        if (decl.hasAttr(\"version\"))\n                            decl.attr(\"version\", \"1.0\");\n                    } else {\n                        decl = new XmlDeclaration(\"xml\", false);\n                        decl.attr(\"version\", \"1.0\");\n                        decl.attr(\"encoding\", charset().displayName());\n                        prependChild(decl);\n                    }\n                } else {\n                    XmlDeclaration decl = new XmlDeclaration(\"xml\", false);\n                    decl.attr(\"version\", \"1.0\");\n                    decl.attr(\"encoding\", charset().displayName());\n                    prependChild(decl);\n                }\n            }\n        }\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Document.java",
        "class_name": "Document",
        "class_uri": "src/main/java/org/jsoup/nodes/Document.java.Document",
        "attributes": {
            "modifiers": "private",
            "marker_annotations": [],
            "non_marker_annotations": [
                "private"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": "\nEnsures a meta charset (html) or xml declaration (xml) with the current\nencoding used. This only applies with\n{@link #updateMetaCharsetElement(boolean) updateMetaCharset} set to\n<tt>true</tt>, otherwise this method does nothing.\n\n<ul>\n<li>An existing element gets updated with the current charset</li>\n<li>If there's no element yet it will be inserted</li>\n<li>Obsolete elements are removed</li>\n</ul>\n\n<p><b>Elements used:</b></p>\n\n<ul>\n<li><b>Html:</b> <i>&lt;meta charset=\"CHARSET\"&gt;</i></li>\n<li><b>Xml:</b> <i>&lt;?xml version=\"1.0\" encoding=\"CHARSET\"&gt;</i></li>\n</ul>\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Document.java.Document.[OutputSettings]outputSettings()",
        "name": "outputSettings",
        "arg_nums": 0,
        "params": [],
        "return_type": "OutputSettings",
        "signature": "public OutputSettings outputSettings()",
        "original_string": "    public OutputSettings outputSettings() {\n        return outputSettings;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Document.java",
        "class_name": "Document",
        "class_uri": "src/main/java/org/jsoup/nodes/Document.java.Document",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "OutputSettings",
            "classes": []
        },
        "docstring": "\nGet the document's current output settings.\n@return the document's current output settings.\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Document.java.Document.[Document]outputSettings(OutputSettings)",
        "name": "outputSettings",
        "arg_nums": 1,
        "params": [
            {
                "name": "outputSettings",
                "type": "OutputSettings"
            }
        ],
        "return_type": "Document",
        "signature": "public Document outputSettings(OutputSettings outputSettings)",
        "original_string": "    public Document outputSettings(OutputSettings outputSettings) {\n        Validate.notNull(outputSettings);\n        this.outputSettings = outputSettings;\n        return this;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Document.java",
        "class_name": "Document",
        "class_uri": "src/main/java/org/jsoup/nodes/Document.java.Document",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Document",
            "classes": []
        },
        "docstring": "\nSet the document's output settings.\n@param outputSettings new output settings.\n@return this document, for chaining.\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Document.java.Document.[QuirksMode]quirksMode()",
        "name": "quirksMode",
        "arg_nums": 0,
        "params": [],
        "return_type": "QuirksMode",
        "signature": "public QuirksMode quirksMode()",
        "original_string": "    public QuirksMode quirksMode() {\n        return quirksMode;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Document.java",
        "class_name": "Document",
        "class_uri": "src/main/java/org/jsoup/nodes/Document.java.Document",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "QuirksMode",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Document.java.Document.[Document]quirksMode(QuirksMode)",
        "name": "quirksMode",
        "arg_nums": 1,
        "params": [
            {
                "name": "quirksMode",
                "type": "QuirksMode"
            }
        ],
        "return_type": "Document",
        "signature": "public Document quirksMode(QuirksMode quirksMode)",
        "original_string": "    public Document quirksMode(QuirksMode quirksMode) {\n        this.quirksMode = quirksMode;\n        return this;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Document.java",
        "class_name": "Document",
        "class_uri": "src/main/java/org/jsoup/nodes/Document.java.Document",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Document",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Document.java.Document.[Parser]parser()",
        "name": "parser",
        "arg_nums": 0,
        "params": [],
        "return_type": "Parser",
        "signature": "public Parser parser()",
        "original_string": "    public Parser parser() {\n        return parser;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Document.java",
        "class_name": "Document",
        "class_uri": "src/main/java/org/jsoup/nodes/Document.java.Document",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Parser",
            "classes": []
        },
        "docstring": "\nGet the parser that was used to parse this document.\n@return the parser\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Document.java.Document.[Document]parser(Parser)",
        "name": "parser",
        "arg_nums": 1,
        "params": [
            {
                "name": "parser",
                "type": "Parser"
            }
        ],
        "return_type": "Document",
        "signature": "public Document parser(Parser parser)",
        "original_string": "    public Document parser(Parser parser) {\n        this.parser = parser;\n        return this;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Document.java",
        "class_name": "Document",
        "class_uri": "src/main/java/org/jsoup/nodes/Document.java.Document",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Document",
            "classes": []
        },
        "docstring": "\nSet the parser used to create this document. This parser is then used when further parsing within this document\nis required.\n@param parser the configured parser to use when further parsing is required for this document.\n@return this document, for chaining.\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Document.java.Document.[Document]connection(Connection)",
        "name": "connection",
        "arg_nums": 1,
        "params": [
            {
                "name": "connection",
                "type": "Connection"
            }
        ],
        "return_type": "Document",
        "signature": "public Document connection(Connection connection)",
        "original_string": "    public Document connection(Connection connection) {\n        Validate.notNull(connection);\n        this.connection = connection;\n        return this;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Document.java",
        "class_name": "Document",
        "class_uri": "src/main/java/org/jsoup/nodes/Document.java.Document",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Document",
            "classes": []
        },
        "docstring": "\nSet the Connection used to fetch this document. This Connection is used as a session object when further requests are\nmade (e.g. when a form is submitted).\n\n@param connection to set\n@return this document, for chaining\n@see Connection#newRequest()\n@since 1.14.1\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/LeafNode.java.LeafNode.[]LeafNode()",
        "name": "LeafNode",
        "arg_nums": 0,
        "params": [],
        "return_type": "",
        "signature": "public LeafNode()",
        "original_string": "    public LeafNode() {\n        value = \"\";\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/LeafNode.java",
        "class_name": "LeafNode",
        "class_uri": "src/main/java/org/jsoup/nodes/LeafNode.java.LeafNode",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "",
            "classes": []
        },
        "docstring": " either a string value, or an attribute map (in the rare case multiple attributes are set)"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/LeafNode.java.LeafNode.[]LeafNode(String)",
        "name": "LeafNode",
        "arg_nums": 1,
        "params": [
            {
                "name": "coreValue",
                "type": "String"
            }
        ],
        "return_type": "",
        "signature": "protected LeafNode(String coreValue)",
        "original_string": "    protected LeafNode(String coreValue) {\n        Validate.notNull(coreValue);\n        value = coreValue;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/LeafNode.java",
        "class_name": "LeafNode",
        "class_uri": "src/main/java/org/jsoup/nodes/LeafNode.java.LeafNode",
        "attributes": {
            "modifiers": "protected",
            "marker_annotations": [],
            "non_marker_annotations": [
                "protected"
            ],
            "comments": [],
            "return_type": "",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/LeafNode.java.LeafNode.[boolean]hasAttributes()",
        "name": "hasAttributes",
        "arg_nums": 0,
        "params": [],
        "return_type": "boolean",
        "signature": "@Override protected final boolean hasAttributes()",
        "original_string": "    @Override protected final boolean hasAttributes() {\n        return value instanceof Attributes;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/LeafNode.java",
        "class_name": "LeafNode",
        "class_uri": "src/main/java/org/jsoup/nodes/LeafNode.java.LeafNode",
        "attributes": {
            "modifiers": "@Override protected final",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "protected",
                "final"
            ],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/LeafNode.java.LeafNode.[Attributes]attributes()",
        "name": "attributes",
        "arg_nums": 0,
        "params": [],
        "return_type": "Attributes",
        "signature": "@Override\n    public final Attributes attributes()",
        "original_string": "    @Override\n    public final Attributes attributes() {\n        ensureAttributes();\n        return (Attributes) value;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/LeafNode.java",
        "class_name": "LeafNode",
        "class_uri": "src/main/java/org/jsoup/nodes/LeafNode.java.LeafNode",
        "attributes": {
            "modifiers": "@Override\n    public final",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "public",
                "final"
            ],
            "comments": [],
            "return_type": "Attributes",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/LeafNode.java.LeafNode.[void]ensureAttributes()",
        "name": "ensureAttributes",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "private void ensureAttributes()",
        "original_string": "    private void ensureAttributes() {\n        if (!hasAttributes()) { // then value is String coreValue\n            String coreValue = (String) value;\n            Attributes attributes = new Attributes();\n            value = attributes;\n            attributes.put(nodeName(), coreValue);\n        }\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/LeafNode.java",
        "class_name": "LeafNode",
        "class_uri": "src/main/java/org/jsoup/nodes/LeafNode.java.LeafNode",
        "attributes": {
            "modifiers": "private",
            "marker_annotations": [],
            "non_marker_annotations": [
                "private"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/LeafNode.java.LeafNode.[String]coreValue()",
        "name": "coreValue",
        "arg_nums": 0,
        "params": [],
        "return_type": "String",
        "signature": "String coreValue()",
        "original_string": "    String coreValue() {\n        return attr(nodeName());\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/LeafNode.java",
        "class_name": "LeafNode",
        "class_uri": "src/main/java/org/jsoup/nodes/LeafNode.java.LeafNode",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/LeafNode.java.LeafNode.[void]coreValue(String)",
        "name": "coreValue",
        "arg_nums": 1,
        "params": [
            {
                "name": "value",
                "type": "String"
            }
        ],
        "return_type": "void",
        "signature": "void coreValue(String value)",
        "original_string": "    void coreValue(String value) {\n        attr(nodeName(), value);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/LeafNode.java",
        "class_name": "LeafNode",
        "class_uri": "src/main/java/org/jsoup/nodes/LeafNode.java.LeafNode",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/LeafNode.java.LeafNode.[String]attr(String)",
        "name": "attr",
        "arg_nums": 1,
        "params": [
            {
                "name": "key",
                "type": "String"
            }
        ],
        "return_type": "String",
        "signature": "@Override\n    public String attr(String key)",
        "original_string": "    @Override\n    public String attr(String key) {\n        if (!hasAttributes()) {\n            return nodeName().equals(key) ? (String) value : EmptyString;\n        }\n        return super.attr(key);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/LeafNode.java",
        "class_name": "LeafNode",
        "class_uri": "src/main/java/org/jsoup/nodes/LeafNode.java.LeafNode",
        "attributes": {
            "modifiers": "@Override\n    public",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/LeafNode.java.LeafNode.[Node]attr(String,String)",
        "name": "attr",
        "arg_nums": 2,
        "params": [
            {
                "name": "key",
                "type": "String"
            },
            {
                "name": "value",
                "type": "String"
            }
        ],
        "return_type": "Node",
        "signature": "@Override\n    public Node attr(String key, String value)",
        "original_string": "    @Override\n    public Node attr(String key, String value) {\n        if (!hasAttributes() && key.equals(nodeName())) {\n            this.value = value;\n        } else {\n            ensureAttributes();\n            super.attr(key, value);\n        }\n        return this;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/LeafNode.java",
        "class_name": "LeafNode",
        "class_uri": "src/main/java/org/jsoup/nodes/LeafNode.java.LeafNode",
        "attributes": {
            "modifiers": "@Override\n    public",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Node",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/LeafNode.java.LeafNode.[boolean]hasAttr(String)",
        "name": "hasAttr",
        "arg_nums": 1,
        "params": [
            {
                "name": "key",
                "type": "String"
            }
        ],
        "return_type": "boolean",
        "signature": "@Override\n    public boolean hasAttr(String key)",
        "original_string": "    @Override\n    public boolean hasAttr(String key) {\n        ensureAttributes();\n        return super.hasAttr(key);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/LeafNode.java",
        "class_name": "LeafNode",
        "class_uri": "src/main/java/org/jsoup/nodes/LeafNode.java.LeafNode",
        "attributes": {
            "modifiers": "@Override\n    public",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/LeafNode.java.LeafNode.[Node]removeAttr(String)",
        "name": "removeAttr",
        "arg_nums": 1,
        "params": [
            {
                "name": "key",
                "type": "String"
            }
        ],
        "return_type": "Node",
        "signature": "@Override\n    public Node removeAttr(String key)",
        "original_string": "    @Override\n    public Node removeAttr(String key) {\n        ensureAttributes();\n        return super.removeAttr(key);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/LeafNode.java",
        "class_name": "LeafNode",
        "class_uri": "src/main/java/org/jsoup/nodes/LeafNode.java.LeafNode",
        "attributes": {
            "modifiers": "@Override\n    public",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Node",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/LeafNode.java.LeafNode.[String]absUrl(String)",
        "name": "absUrl",
        "arg_nums": 1,
        "params": [
            {
                "name": "key",
                "type": "String"
            }
        ],
        "return_type": "String",
        "signature": "@Override\n    public String absUrl(String key)",
        "original_string": "    @Override\n    public String absUrl(String key) {\n        ensureAttributes();\n        return super.absUrl(key);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/LeafNode.java",
        "class_name": "LeafNode",
        "class_uri": "src/main/java/org/jsoup/nodes/LeafNode.java.LeafNode",
        "attributes": {
            "modifiers": "@Override\n    public",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/LeafNode.java.LeafNode.[String]baseUri()",
        "name": "baseUri",
        "arg_nums": 0,
        "params": [],
        "return_type": "String",
        "signature": "@Override\n    public String baseUri()",
        "original_string": "    @Override\n    public String baseUri() {\n        return parentNode != null ? parentNode.baseUri() : \"\";\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/LeafNode.java",
        "class_name": "LeafNode",
        "class_uri": "src/main/java/org/jsoup/nodes/LeafNode.java.LeafNode",
        "attributes": {
            "modifiers": "@Override\n    public",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/LeafNode.java.LeafNode.[void]doSetBaseUri(String)",
        "name": "doSetBaseUri",
        "arg_nums": 1,
        "params": [
            {
                "name": "baseUri",
                "type": "String"
            }
        ],
        "return_type": "void",
        "signature": "@Override\n    protected void doSetBaseUri(String baseUri)",
        "original_string": "    @Override\n    protected void doSetBaseUri(String baseUri) {\n        // noop\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/LeafNode.java",
        "class_name": "LeafNode",
        "class_uri": "src/main/java/org/jsoup/nodes/LeafNode.java.LeafNode",
        "attributes": {
            "modifiers": "@Override\n    protected",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "protected"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/LeafNode.java.LeafNode.[int]childNodeSize()",
        "name": "childNodeSize",
        "arg_nums": 0,
        "params": [],
        "return_type": "int",
        "signature": "@Override\n    public int childNodeSize()",
        "original_string": "    @Override\n    public int childNodeSize() {\n        return 0;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/LeafNode.java",
        "class_name": "LeafNode",
        "class_uri": "src/main/java/org/jsoup/nodes/LeafNode.java.LeafNode",
        "attributes": {
            "modifiers": "@Override\n    public",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "int",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/LeafNode.java.LeafNode.[Node]empty()",
        "name": "empty",
        "arg_nums": 0,
        "params": [],
        "return_type": "Node",
        "signature": "@Override\n    public Node empty()",
        "original_string": "    @Override\n    public Node empty() {\n        return this;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/LeafNode.java",
        "class_name": "LeafNode",
        "class_uri": "src/main/java/org/jsoup/nodes/LeafNode.java.LeafNode",
        "attributes": {
            "modifiers": "@Override\n    public",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Node",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/LeafNode.java.LeafNode.[List<Node>]ensureChildNodes()",
        "name": "ensureChildNodes",
        "arg_nums": 0,
        "params": [],
        "return_type": "List<Node>",
        "signature": "@Override\n    protected List<Node> ensureChildNodes()",
        "original_string": "    @Override\n    protected List<Node> ensureChildNodes() {\n        return EmptyNodes;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/LeafNode.java",
        "class_name": "LeafNode",
        "class_uri": "src/main/java/org/jsoup/nodes/LeafNode.java.LeafNode",
        "attributes": {
            "modifiers": "@Override\n    protected",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "protected"
            ],
            "comments": [],
            "return_type": "List<Node>",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/LeafNode.java.LeafNode.[LeafNode]doClone(Node)",
        "name": "doClone",
        "arg_nums": 1,
        "params": [
            {
                "name": "parent",
                "type": "Node"
            }
        ],
        "return_type": "LeafNode",
        "signature": "@Override\n    protected LeafNode doClone(Node parent)",
        "original_string": "    @Override\n    protected LeafNode doClone(Node parent) {\n        LeafNode clone = (LeafNode) super.doClone(parent);\n\n        // Object value could be plain string or attributes - need to clone\n        if (hasAttributes())\n            clone.value = ((Attributes) value).clone();\n\n        return clone;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/LeafNode.java",
        "class_name": "LeafNode",
        "class_uri": "src/main/java/org/jsoup/nodes/LeafNode.java.LeafNode",
        "attributes": {
            "modifiers": "@Override\n    protected",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "protected"
            ],
            "comments": [],
            "return_type": "LeafNode",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/XmlDeclaration.java.XmlDeclaration.[]XmlDeclaration(String,boolean)",
        "name": "XmlDeclaration",
        "arg_nums": 2,
        "params": [
            {
                "name": "name",
                "type": "String"
            },
            {
                "name": "isProcessingInstruction",
                "type": "boolean"
            }
        ],
        "return_type": "",
        "signature": "public XmlDeclaration(String name, boolean isProcessingInstruction)",
        "original_string": "    public XmlDeclaration(String name, boolean isProcessingInstruction) {\n        super(name);\n        this.isProcessingInstruction = isProcessingInstruction;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/XmlDeclaration.java",
        "class_name": "XmlDeclaration",
        "class_uri": "src/main/java/org/jsoup/nodes/XmlDeclaration.java.XmlDeclaration",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "",
            "classes": []
        },
        "docstring": "\nCreate a new XML declaration\n@param name of declaration\n@param isProcessingInstruction is processing instruction\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/XmlDeclaration.java.XmlDeclaration.[String]nodeName()",
        "name": "nodeName",
        "arg_nums": 0,
        "params": [],
        "return_type": "String",
        "signature": "@Override public String nodeName()",
        "original_string": "    @Override public String nodeName() {\n        return \"#declaration\";\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/XmlDeclaration.java",
        "class_name": "XmlDeclaration",
        "class_uri": "src/main/java/org/jsoup/nodes/XmlDeclaration.java.XmlDeclaration",
        "attributes": {
            "modifiers": "@Override public",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/XmlDeclaration.java.XmlDeclaration.[String]name()",
        "name": "name",
        "arg_nums": 0,
        "params": [],
        "return_type": "String",
        "signature": "public String name()",
        "original_string": "    public String name() {\n        return coreValue();\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/XmlDeclaration.java",
        "class_name": "XmlDeclaration",
        "class_uri": "src/main/java/org/jsoup/nodes/XmlDeclaration.java.XmlDeclaration",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": "\nGet the name of this declaration.\n@return name of this declaration.\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/XmlDeclaration.java.XmlDeclaration.[String]getWholeDeclaration()",
        "name": "getWholeDeclaration",
        "arg_nums": 0,
        "params": [],
        "return_type": "String",
        "signature": "public String getWholeDeclaration()",
        "original_string": "    public String getWholeDeclaration() {\n        StringBuilder sb = StringUtil.borrowBuilder();\n        try {\n            getWholeDeclaration(sb, new Document.OutputSettings());\n        } catch (IOException e) {\n            throw new SerializationException(e);\n        }\n        return StringUtil.releaseBuilder(sb).trim();\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/XmlDeclaration.java",
        "class_name": "XmlDeclaration",
        "class_uri": "src/main/java/org/jsoup/nodes/XmlDeclaration.java.XmlDeclaration",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": "\nGet the unencoded XML declaration.\n@return XML declaration\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/XmlDeclaration.java.XmlDeclaration.[void]getWholeDeclaration(Appendable,Document.OutputSettings)",
        "name": "getWholeDeclaration",
        "arg_nums": 2,
        "params": [
            {
                "name": "accum",
                "type": "Appendable"
            },
            {
                "name": "out",
                "type": "Document.OutputSettings"
            }
        ],
        "return_type": "void",
        "signature": "private void getWholeDeclaration(Appendable accum, Document.OutputSettings out)",
        "original_string": "    private void getWholeDeclaration(Appendable accum, Document.OutputSettings out) throws IOException {\n        for (Attribute attribute : attributes()) {\n            String key = attribute.getKey();\n            String val = attribute.getValue();\n            if (!key.equals(nodeName())) { // skips coreValue (name)\n                accum.append(' ');\n                // basically like Attribute, but skip empty vals in XML\n                accum.append(key);\n                if (!val.isEmpty()) {\n                    accum.append(\"=\\\"\");\n                    Entities.escape(accum, val, out, Entities.ForAttribute);\n                    accum.append('\"');\n                }\n            }\n        }\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/XmlDeclaration.java",
        "class_name": "XmlDeclaration",
        "class_uri": "src/main/java/org/jsoup/nodes/XmlDeclaration.java.XmlDeclaration",
        "attributes": {
            "modifiers": "private",
            "marker_annotations": [],
            "non_marker_annotations": [
                "private"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/XmlDeclaration.java.XmlDeclaration.[void]outerHtmlHead(Appendable,int,Document.OutputSettings)",
        "name": "outerHtmlHead",
        "arg_nums": 3,
        "params": [
            {
                "name": "accum",
                "type": "Appendable"
            },
            {
                "name": "depth",
                "type": "int"
            },
            {
                "name": "out",
                "type": "Document.OutputSettings"
            }
        ],
        "return_type": "void",
        "signature": "@Override\n    void outerHtmlHead(Appendable accum, int depth, Document.OutputSettings out)",
        "original_string": "    @Override\n    void outerHtmlHead(Appendable accum, int depth, Document.OutputSettings out) throws IOException {\n        accum\n            .append(\"<\")\n            .append(isProcessingInstruction ? \"!\" : \"?\")\n            .append(coreValue());\n        getWholeDeclaration(accum, out);\n        accum\n            .append(isProcessingInstruction ? \"!\" : \"?\")\n            .append(\">\");\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/XmlDeclaration.java",
        "class_name": "XmlDeclaration",
        "class_uri": "src/main/java/org/jsoup/nodes/XmlDeclaration.java.XmlDeclaration",
        "attributes": {
            "modifiers": "@Override",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/XmlDeclaration.java.XmlDeclaration.[void]outerHtmlTail(Appendable,int,Document.OutputSettings)",
        "name": "outerHtmlTail",
        "arg_nums": 3,
        "params": [
            {
                "name": "accum",
                "type": "Appendable"
            },
            {
                "name": "depth",
                "type": "int"
            },
            {
                "name": "out",
                "type": "Document.OutputSettings"
            }
        ],
        "return_type": "void",
        "signature": "@Override\n    void outerHtmlTail(Appendable accum, int depth, Document.OutputSettings out)",
        "original_string": "    @Override\n    void outerHtmlTail(Appendable accum, int depth, Document.OutputSettings out) {\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/XmlDeclaration.java",
        "class_name": "XmlDeclaration",
        "class_uri": "src/main/java/org/jsoup/nodes/XmlDeclaration.java.XmlDeclaration",
        "attributes": {
            "modifiers": "@Override",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/XmlDeclaration.java.XmlDeclaration.[String]toString()",
        "name": "toString",
        "arg_nums": 0,
        "params": [],
        "return_type": "String",
        "signature": "@Override\n    public String toString()",
        "original_string": "    @Override\n    public String toString() {\n        return outerHtml();\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/XmlDeclaration.java",
        "class_name": "XmlDeclaration",
        "class_uri": "src/main/java/org/jsoup/nodes/XmlDeclaration.java.XmlDeclaration",
        "attributes": {
            "modifiers": "@Override\n    public",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/XmlDeclaration.java.XmlDeclaration.[XmlDeclaration]clone()",
        "name": "clone",
        "arg_nums": 0,
        "params": [],
        "return_type": "XmlDeclaration",
        "signature": "@Override\n    public XmlDeclaration clone()",
        "original_string": "    @Override\n    public XmlDeclaration clone() {\n        return (XmlDeclaration) super.clone();\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/XmlDeclaration.java",
        "class_name": "XmlDeclaration",
        "class_uri": "src/main/java/org/jsoup/nodes/XmlDeclaration.java.XmlDeclaration",
        "attributes": {
            "modifiers": "@Override\n    public",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "XmlDeclaration",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Attribute.java.Attribute.[]Attribute(String,String)",
        "name": "Attribute",
        "arg_nums": 2,
        "params": [
            {
                "name": "key",
                "type": "String"
            },
            {
                "name": "value",
                "type": "String"
            }
        ],
        "return_type": "",
        "signature": "public Attribute(String key, @Nullable String value)",
        "original_string": "    public Attribute(String key, @Nullable String value) {\n        this(key, value, null);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Attribute.java",
        "class_name": "Attribute",
        "class_uri": "src/main/java/org/jsoup/nodes/Attribute.java.Attribute",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "",
            "classes": []
        },
        "docstring": "\nCreate a new attribute from unencoded (raw) key and value.\n@param key attribute key; case is preserved.\n@param value attribute value (may be null)\n@see #createFromEncoded\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Attribute.java.Attribute.[]Attribute(String,String,Attributes)",
        "name": "Attribute",
        "arg_nums": 3,
        "params": [
            {
                "name": "key",
                "type": "String"
            },
            {
                "name": "val",
                "type": "String"
            },
            {
                "name": "parent",
                "type": "Attributes"
            }
        ],
        "return_type": "",
        "signature": "public Attribute(String key, @Nullable String val, @Nullable Attributes parent)",
        "original_string": "    public Attribute(String key, @Nullable String val, @Nullable Attributes parent) {\n        Validate.notNull(key);\n        key = key.trim();\n        Validate.notEmpty(key); // trimming could potentially make empty, so validate here\n        this.key = key;\n        this.val = val;\n        this.parent = parent;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Attribute.java",
        "class_name": "Attribute",
        "class_uri": "src/main/java/org/jsoup/nodes/Attribute.java.Attribute",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "",
            "classes": []
        },
        "docstring": "\nCreate a new attribute from unencoded (raw) key and value.\n@param key attribute key; case is preserved.\n@param val attribute value (may be null)\n@param parent the containing Attributes (this Attribute is not automatically added to said Attributes)\n@see #createFromEncoded"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Attribute.java.Attribute.[String]getKey()",
        "name": "getKey",
        "arg_nums": 0,
        "params": [],
        "return_type": "String",
        "signature": "@Override\n    public String getKey()",
        "original_string": "    @Override\n    public String getKey() {\n        return key;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Attribute.java",
        "class_name": "Attribute",
        "class_uri": "src/main/java/org/jsoup/nodes/Attribute.java.Attribute",
        "attributes": {
            "modifiers": "@Override\n    public",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": "\nGet the attribute key.\n@return the attribute key\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Attribute.java.Attribute.[void]setKey(String)",
        "name": "setKey",
        "arg_nums": 1,
        "params": [
            {
                "name": "key",
                "type": "String"
            }
        ],
        "return_type": "void",
        "signature": "public void setKey(String key)",
        "original_string": "    public void setKey(String key) {\n        Validate.notNull(key);\n        key = key.trim();\n        Validate.notEmpty(key); // trimming could potentially make empty, so validate here\n        if (parent != null) {\n            int i = parent.indexOfKey(this.key);\n            if (i != Attributes.NotFound) {\n                String oldKey = parent.keys[i];\n                parent.keys[i] = key;\n\n                // if tracking source positions, update the key in the range map\n                Map<String, Range.AttributeRange> ranges = parent.getRanges();\n                if (ranges != null) {\n                    Range.AttributeRange range = ranges.remove(oldKey);\n                    ranges.put(key, range);\n                }\n            }\n        }\n        this.key = key;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Attribute.java",
        "class_name": "Attribute",
        "class_uri": "src/main/java/org/jsoup/nodes/Attribute.java.Attribute",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": "\nSet the attribute key; case is preserved.\n@param key the new key; must not be null\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Attribute.java.Attribute.[String]getValue()",
        "name": "getValue",
        "arg_nums": 0,
        "params": [],
        "return_type": "String",
        "signature": "@Override\n    public String getValue()",
        "original_string": "    @Override\n    public String getValue() {\n        return Attributes.checkNotNull(val);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Attribute.java",
        "class_name": "Attribute",
        "class_uri": "src/main/java/org/jsoup/nodes/Attribute.java.Attribute",
        "attributes": {
            "modifiers": "@Override\n    public",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": "\nGet the attribute value. Will return an empty string if the value is not set.\n@return the attribute value\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Attribute.java.Attribute.[boolean]hasDeclaredValue()",
        "name": "hasDeclaredValue",
        "arg_nums": 0,
        "params": [],
        "return_type": "boolean",
        "signature": "public boolean hasDeclaredValue()",
        "original_string": "    public boolean hasDeclaredValue() {\n        return val != null;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Attribute.java",
        "class_name": "Attribute",
        "class_uri": "src/main/java/org/jsoup/nodes/Attribute.java.Attribute",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": "\nCheck if this Attribute has a value. Set boolean attributes have no value.\n@return if this is a boolean attribute / attribute without a value\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Attribute.java.Attribute.[String]setValue(String)",
        "name": "setValue",
        "arg_nums": 1,
        "params": [
            {
                "name": "val",
                "type": "String"
            }
        ],
        "return_type": "String",
        "signature": "@Override public String setValue(@Nullable String val)",
        "original_string": "    @Override public String setValue(@Nullable String val) {\n        String oldVal = this.val;\n        if (parent != null) {\n            int i = parent.indexOfKey(this.key);\n            if (i != Attributes.NotFound) {\n                oldVal = parent.get(this.key); // trust the container more\n                parent.vals[i] = val;\n            }\n        }\n        this.val = val;\n        return Attributes.checkNotNull(oldVal);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Attribute.java",
        "class_name": "Attribute",
        "class_uri": "src/main/java/org/jsoup/nodes/Attribute.java.Attribute",
        "attributes": {
            "modifiers": "@Override public",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": "\nSet the attribute value.\n@param val the new attribute value; may be null (to set an enabled boolean attribute)\n@return the previous value (if was null; an empty string)\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Attribute.java.Attribute.[String]html()",
        "name": "html",
        "arg_nums": 0,
        "params": [],
        "return_type": "String",
        "signature": "public String html()",
        "original_string": "    public String html() {\n        StringBuilder sb = StringUtil.borrowBuilder();\n        \n        try {\n        \thtml(sb, (new Document(\"\")).outputSettings());\n        } catch(IOException exception) {\n        \tthrow new SerializationException(exception);\n        }\n        return StringUtil.releaseBuilder(sb);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Attribute.java",
        "class_name": "Attribute",
        "class_uri": "src/main/java/org/jsoup/nodes/Attribute.java.Attribute",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": "\nGet the HTML representation of this attribute; e.g. {@code href=\"index.html\"}.\n@return HTML\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Attribute.java.Attribute.[Range.AttributeRange]sourceRange()",
        "name": "sourceRange",
        "arg_nums": 0,
        "params": [],
        "return_type": "Range.AttributeRange",
        "signature": "public Range.AttributeRange sourceRange()",
        "original_string": "    public Range.AttributeRange sourceRange() {\n        if (parent == null) return Range.AttributeRange.UntrackedAttr;\n        return parent.sourceRange(key);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Attribute.java",
        "class_name": "Attribute",
        "class_uri": "src/main/java/org/jsoup/nodes/Attribute.java.Attribute",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Range.AttributeRange",
            "classes": []
        },
        "docstring": "\nGet the source ranges (start to end positions) in the original input source from which this attribute's <b>name</b>\nand <b>value</b> were parsed.\n<p>Position tracking must be enabled prior to parsing the content.</p>\n@return the ranges for the attribute's name and value, or {@code untracked} if the attribute does not exist or its range\nwas not tracked.\n@see org.jsoup.parser.Parser#setTrackPosition(boolean)\n@see Attributes#sourceRange(String)\n@see Node#sourceRange()\n@see Element#endSourceRange()\n@since 1.17.1\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Attribute.java.Attribute.[void]html(Appendable,Document.OutputSettings)",
        "name": "html",
        "arg_nums": 2,
        "params": [
            {
                "name": "accum",
                "type": "Appendable"
            },
            {
                "name": "out",
                "type": "Document.OutputSettings"
            }
        ],
        "return_type": "void",
        "signature": "protected void html(Appendable accum, Document.OutputSettings out)",
        "original_string": "    protected void html(Appendable accum, Document.OutputSettings out) throws IOException {\n        html(key, val, accum, out);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Attribute.java",
        "class_name": "Attribute",
        "class_uri": "src/main/java/org/jsoup/nodes/Attribute.java.Attribute",
        "attributes": {
            "modifiers": "protected",
            "marker_annotations": [],
            "non_marker_annotations": [
                "protected"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Attribute.java.Attribute.[void]html(String,String,Appendable,Document.OutputSettings)",
        "name": "html",
        "arg_nums": 4,
        "params": [
            {
                "name": "key",
                "type": "String"
            },
            {
                "name": "val",
                "type": "String"
            },
            {
                "name": "accum",
                "type": "Appendable"
            },
            {
                "name": "out",
                "type": "Document.OutputSettings"
            }
        ],
        "return_type": "void",
        "signature": "protected static void html(String key, @Nullable String val, Appendable accum, Document.OutputSettings out)",
        "original_string": "    protected static void html(String key, @Nullable String val, Appendable accum, Document.OutputSettings out) throws IOException {\n        key = getValidKey(key, out.syntax());\n        if (key == null) return; // can't write it :(\n        htmlNoValidate(key, val, accum, out);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Attribute.java",
        "class_name": "Attribute",
        "class_uri": "src/main/java/org/jsoup/nodes/Attribute.java.Attribute",
        "attributes": {
            "modifiers": "protected static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "protected",
                "static"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Attribute.java.Attribute.[void]htmlNoValidate(String,String,Appendable,Document.OutputSettings)",
        "name": "htmlNoValidate",
        "arg_nums": 4,
        "params": [
            {
                "name": "key",
                "type": "String"
            },
            {
                "name": "val",
                "type": "String"
            },
            {
                "name": "accum",
                "type": "Appendable"
            },
            {
                "name": "out",
                "type": "Document.OutputSettings"
            }
        ],
        "return_type": "void",
        "signature": "static void htmlNoValidate(String key, @Nullable String val, Appendable accum, Document.OutputSettings out)",
        "original_string": "    static void htmlNoValidate(String key, @Nullable String val, Appendable accum, Document.OutputSettings out) throws IOException {\n        // structured like this so that Attributes can check we can write first, so it can add whitespace correctly\n        accum.append(key);\n        if (!shouldCollapseAttribute(key, val, out)) {\n            accum.append(\"=\\\"\");\n            Entities.escape(accum, Attributes.checkNotNull(val), out, Entities.ForAttribute); // preserves whitespace\n            accum.append('\"');\n        }\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Attribute.java",
        "class_name": "Attribute",
        "class_uri": "src/main/java/org/jsoup/nodes/Attribute.java.Attribute",
        "attributes": {
            "modifiers": "static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "static"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Attribute.java.Attribute.[String]getValidKey(String,Syntax)",
        "name": "getValidKey",
        "arg_nums": 2,
        "params": [
            {
                "name": "key",
                "type": "String"
            },
            {
                "name": "syntax",
                "type": "Syntax"
            }
        ],
        "return_type": "String",
        "signature": "@Nullable public static String getValidKey(String key, Syntax syntax)",
        "original_string": "    @Nullable public static String getValidKey(String key, Syntax syntax) {\n        if (syntax == Syntax.xml && !isValidXmlKey(key)) {\n            key = xmlKeyReplace.matcher(key).replaceAll(\"_\");\n            return isValidXmlKey(key) ? key : null; // null if could not be coerced\n        }\n        else if (syntax == Syntax.html && !isValidHtmlKey(key)) {\n            key = htmlKeyReplace.matcher(key).replaceAll(\"_\");\n            return isValidHtmlKey(key) ? key : null; // null if could not be coerced\n        }\n        return key;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Attribute.java",
        "class_name": "Attribute",
        "class_uri": "src/main/java/org/jsoup/nodes/Attribute.java.Attribute",
        "attributes": {
            "modifiers": "@Nullable public static",
            "marker_annotations": [
                "@Nullable"
            ],
            "non_marker_annotations": [
                "public",
                "static"
            ],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": "\nGet a valid attribute key for the given syntax. If the key is not valid, it will be coerced into a valid key.\n@param key the original attribute key\n@param syntax HTML or XML\n@return the original key if it's valid; a key with invalid characters replaced with \"_\" otherwise; or null if a valid key could not be created.\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Attribute.java.Attribute.[boolean]isValidXmlKey(String)",
        "name": "isValidXmlKey",
        "arg_nums": 1,
        "params": [
            {
                "name": "key",
                "type": "String"
            }
        ],
        "return_type": "boolean",
        "signature": "private static boolean isValidXmlKey(String key)",
        "original_string": "    private static boolean isValidXmlKey(String key) {\n        // =~ [a-zA-Z_:][-a-zA-Z0-9_:.]*\n        final int length = key.length();\n        if (length ==0) return false;\n        char c = key.charAt(0);\n        if (!((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '_' || c == ':'))\n            return false;\n        for (int i = 1; i < length; i++) {\n            c = key.charAt(i);\n            if (!((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '_' || c == ':'))\n                return false;\n        }\n        return true;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Attribute.java",
        "class_name": "Attribute",
        "class_uri": "src/main/java/org/jsoup/nodes/Attribute.java.Attribute",
        "attributes": {
            "modifiers": "private static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "private",
                "static"
            ],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": " note that we aren't using anything in supplemental space, so OK to iter charAt"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Attribute.java.Attribute.[boolean]isValidHtmlKey(String)",
        "name": "isValidHtmlKey",
        "arg_nums": 1,
        "params": [
            {
                "name": "key",
                "type": "String"
            }
        ],
        "return_type": "boolean",
        "signature": "private static boolean isValidHtmlKey(String key)",
        "original_string": "    private static boolean isValidHtmlKey(String key) {\n        // =~ [\\x00-\\x1f\\x7f-\\x9f \"'/=]+\n        final int length = key.length();\n        if (length ==0) return false;\n        for (int i = 0; i < length; i++) {\n            char c = key.charAt(i);\n            if (c <= 0x1f || c >= 0x7f && c <= 0x9f || c == ' ' || c == '\"' || c == '\\'' || c == '/' || c == '=')\n                return false;\n        }\n        return true;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Attribute.java",
        "class_name": "Attribute",
        "class_uri": "src/main/java/org/jsoup/nodes/Attribute.java.Attribute",
        "attributes": {
            "modifiers": "private static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "private",
                "static"
            ],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Attribute.java.Attribute.[String]toString()",
        "name": "toString",
        "arg_nums": 0,
        "params": [],
        "return_type": "String",
        "signature": "@Override\n    public String toString()",
        "original_string": "    @Override\n    public String toString() {\n        return html();\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Attribute.java",
        "class_name": "Attribute",
        "class_uri": "src/main/java/org/jsoup/nodes/Attribute.java.Attribute",
        "attributes": {
            "modifiers": "@Override\n    public",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": "\nGet the string representation of this attribute, implemented as {@link #html()}.\n@return string\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Attribute.java.Attribute.[Attribute]createFromEncoded(String,String)",
        "name": "createFromEncoded",
        "arg_nums": 2,
        "params": [
            {
                "name": "unencodedKey",
                "type": "String"
            },
            {
                "name": "encodedValue",
                "type": "String"
            }
        ],
        "return_type": "Attribute",
        "signature": "public static Attribute createFromEncoded(String unencodedKey, String encodedValue)",
        "original_string": "    public static Attribute createFromEncoded(String unencodedKey, String encodedValue) {\n        String value = Entities.unescape(encodedValue, true);\n        return new Attribute(unencodedKey, value, null); // parent will get set when Put\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Attribute.java",
        "class_name": "Attribute",
        "class_uri": "src/main/java/org/jsoup/nodes/Attribute.java.Attribute",
        "attributes": {
            "modifiers": "public static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public",
                "static"
            ],
            "comments": [],
            "return_type": "Attribute",
            "classes": []
        },
        "docstring": "\nCreate a new Attribute from an unencoded key and a HTML attribute encoded value.\n@param unencodedKey assumes the key is not encoded, as can be only run of simple \\w chars.\n@param encodedValue HTML attribute encoded value\n@return attribute\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Attribute.java.Attribute.[boolean]isDataAttribute()",
        "name": "isDataAttribute",
        "arg_nums": 0,
        "params": [],
        "return_type": "boolean",
        "signature": "protected boolean isDataAttribute()",
        "original_string": "    protected boolean isDataAttribute() {\n        return isDataAttribute(key);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Attribute.java",
        "class_name": "Attribute",
        "class_uri": "src/main/java/org/jsoup/nodes/Attribute.java.Attribute",
        "attributes": {
            "modifiers": "protected",
            "marker_annotations": [],
            "non_marker_annotations": [
                "protected"
            ],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Attribute.java.Attribute.[boolean]isDataAttribute(String)",
        "name": "isDataAttribute",
        "arg_nums": 1,
        "params": [
            {
                "name": "key",
                "type": "String"
            }
        ],
        "return_type": "boolean",
        "signature": "protected static boolean isDataAttribute(String key)",
        "original_string": "    protected static boolean isDataAttribute(String key) {\n        return key.startsWith(Attributes.dataPrefix) && key.length() > Attributes.dataPrefix.length();\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Attribute.java",
        "class_name": "Attribute",
        "class_uri": "src/main/java/org/jsoup/nodes/Attribute.java.Attribute",
        "attributes": {
            "modifiers": "protected static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "protected",
                "static"
            ],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Attribute.java.Attribute.[boolean]shouldCollapseAttribute(Document.OutputSettings)",
        "name": "shouldCollapseAttribute",
        "arg_nums": 1,
        "params": [
            {
                "name": "out",
                "type": "Document.OutputSettings"
            }
        ],
        "return_type": "boolean",
        "signature": "protected final boolean shouldCollapseAttribute(Document.OutputSettings out)",
        "original_string": "    protected final boolean shouldCollapseAttribute(Document.OutputSettings out) {\n        return shouldCollapseAttribute(key, val, out);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Attribute.java",
        "class_name": "Attribute",
        "class_uri": "src/main/java/org/jsoup/nodes/Attribute.java.Attribute",
        "attributes": {
            "modifiers": "protected final",
            "marker_annotations": [],
            "non_marker_annotations": [
                "protected",
                "final"
            ],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": "\nCollapsible if it's a boolean attribute and value is empty or same as name\n\n@param out output settings\n@return  Returns whether collapsible or not\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Attribute.java.Attribute.[boolean]shouldCollapseAttribute(String,String,Document.OutputSettings)",
        "name": "shouldCollapseAttribute",
        "arg_nums": 3,
        "params": [
            {
                "name": "key",
                "type": "String"
            },
            {
                "name": "val",
                "type": "String"
            },
            {
                "name": "out",
                "type": "Document.OutputSettings"
            }
        ],
        "return_type": "boolean",
        "signature": "protected static boolean shouldCollapseAttribute(final String key, @Nullable final String val, final Document.OutputSettings out)",
        "original_string": "    protected static boolean shouldCollapseAttribute(final String key, @Nullable final String val, final Document.OutputSettings out) {\n        return (\n            out.syntax() == Syntax.html &&\n                (val == null || (val.isEmpty() || val.equalsIgnoreCase(key)) && Attribute.isBooleanAttribute(key)));\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Attribute.java",
        "class_name": "Attribute",
        "class_uri": "src/main/java/org/jsoup/nodes/Attribute.java.Attribute",
        "attributes": {
            "modifiers": "protected static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "protected",
                "static"
            ],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": " collapse unknown foo=null, known checked=null, checked=\"\", checked=checked; write out others"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Attribute.java.Attribute.[boolean]isBooleanAttribute(String)",
        "name": "isBooleanAttribute",
        "arg_nums": 1,
        "params": [
            {
                "name": "key",
                "type": "String"
            }
        ],
        "return_type": "boolean",
        "signature": "public static boolean isBooleanAttribute(final String key)",
        "original_string": "    public static boolean isBooleanAttribute(final String key) {\n        return Arrays.binarySearch(booleanAttributes, Normalizer.lowerCase(key)) >= 0;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Attribute.java",
        "class_name": "Attribute",
        "class_uri": "src/main/java/org/jsoup/nodes/Attribute.java.Attribute",
        "attributes": {
            "modifiers": "public static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public",
                "static"
            ],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": "\nChecks if this attribute name is defined as a boolean attribute in HTML5\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Attribute.java.Attribute.[boolean]equals(Object)",
        "name": "equals",
        "arg_nums": 1,
        "params": [
            {
                "name": "o",
                "type": "Object"
            }
        ],
        "return_type": "boolean",
        "signature": "@Override\n    public boolean equals(@Nullable Object o)",
        "original_string": "    @Override\n    public boolean equals(@Nullable Object o) { // note parent not considered\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        Attribute attribute = (Attribute) o;\n        return Objects.equals(key, attribute.key) && Objects.equals(val, attribute.val);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Attribute.java",
        "class_name": "Attribute",
        "class_uri": "src/main/java/org/jsoup/nodes/Attribute.java.Attribute",
        "attributes": {
            "modifiers": "@Override\n    public",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Attribute.java.Attribute.[int]hashCode()",
        "name": "hashCode",
        "arg_nums": 0,
        "params": [],
        "return_type": "int",
        "signature": "@Override\n    public int hashCode()",
        "original_string": "    @Override\n    public int hashCode() { // note parent not considered\n        return Objects.hash(key, val);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Attribute.java",
        "class_name": "Attribute",
        "class_uri": "src/main/java/org/jsoup/nodes/Attribute.java.Attribute",
        "attributes": {
            "modifiers": "@Override\n    public",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "int",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Attribute.java.Attribute.[Attribute]clone()",
        "name": "clone",
        "arg_nums": 0,
        "params": [],
        "return_type": "Attribute",
        "signature": "@Override\n    public Attribute clone()",
        "original_string": "    @Override\n    public Attribute clone() {\n        try {\n            return (Attribute) super.clone();\n        } catch (CloneNotSupportedException e) {\n            throw new RuntimeException(e);\n        }\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Attribute.java",
        "class_name": "Attribute",
        "class_uri": "src/main/java/org/jsoup/nodes/Attribute.java.Attribute",
        "attributes": {
            "modifiers": "@Override\n    public",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Attribute",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Attributes.java.Attributes.[void]checkCapacity(int)",
        "name": "checkCapacity",
        "arg_nums": 1,
        "params": [
            {
                "name": "minNewSize",
                "type": "int"
            }
        ],
        "return_type": "void",
        "signature": "private void checkCapacity(int minNewSize)",
        "original_string": "    private void checkCapacity(int minNewSize) {\n        Validate.isTrue(minNewSize >= size);\n        int curCap = keys.length;\n        if (curCap >= minNewSize)\n            return;\n        int newCap = curCap >= InitialCapacity ? size * GrowthFactor : InitialCapacity;\n        if (minNewSize > newCap)\n            newCap = minNewSize;\n\n        keys = Arrays.copyOf(keys, newCap);\n        vals = Arrays.copyOf(vals, newCap);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Attributes.java",
        "class_name": "Attributes",
        "class_uri": "src/main/java/org/jsoup/nodes/Attributes.java.Attributes",
        "attributes": {
            "modifiers": "private",
            "marker_annotations": [],
            "non_marker_annotations": [
                "private"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": " check there's room for more"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Attributes.java.Attributes.[int]indexOfKey(String)",
        "name": "indexOfKey",
        "arg_nums": 1,
        "params": [
            {
                "name": "key",
                "type": "String"
            }
        ],
        "return_type": "int",
        "signature": "int indexOfKey(String key)",
        "original_string": "    int indexOfKey(String key) {\n        Validate.notNull(key);\n        for (int i = 0; i < size; i++) {\n            if (key.equals(keys[i]))\n                return i;\n        }\n        return NotFound;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Attributes.java",
        "class_name": "Attributes",
        "class_uri": "src/main/java/org/jsoup/nodes/Attributes.java.Attributes",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "int",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Attributes.java.Attributes.[int]indexOfKeyIgnoreCase(String)",
        "name": "indexOfKeyIgnoreCase",
        "arg_nums": 1,
        "params": [
            {
                "name": "key",
                "type": "String"
            }
        ],
        "return_type": "int",
        "signature": "private int indexOfKeyIgnoreCase(String key)",
        "original_string": "    private int indexOfKeyIgnoreCase(String key) {\n        Validate.notNull(key);\n        for (int i = 0; i < size; i++) {\n            if (key.equalsIgnoreCase(keys[i]))\n                return i;\n        }\n        return NotFound;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Attributes.java",
        "class_name": "Attributes",
        "class_uri": "src/main/java/org/jsoup/nodes/Attributes.java.Attributes",
        "attributes": {
            "modifiers": "private",
            "marker_annotations": [],
            "non_marker_annotations": [
                "private"
            ],
            "comments": [],
            "return_type": "int",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Attributes.java.Attributes.[String]checkNotNull(Object)",
        "name": "checkNotNull",
        "arg_nums": 1,
        "params": [
            {
                "name": "val",
                "type": "Object"
            }
        ],
        "return_type": "String",
        "signature": "static String checkNotNull(@Nullable Object val)",
        "original_string": "    static String checkNotNull(@Nullable Object val) {\n        return val == null ? EmptyString : (String) val;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Attributes.java",
        "class_name": "Attributes",
        "class_uri": "src/main/java/org/jsoup/nodes/Attributes.java.Attributes",
        "attributes": {
            "modifiers": "static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "static"
            ],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": " casts to String, so only for non-internal attributes"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Attributes.java.Attributes.[String]get(String)",
        "name": "get",
        "arg_nums": 1,
        "params": [
            {
                "name": "key",
                "type": "String"
            }
        ],
        "return_type": "String",
        "signature": "public String get(String key)",
        "original_string": "    public String get(String key) {\n        int i = indexOfKey(key);\n        return i == NotFound ? EmptyString : checkNotNull(vals[i]);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Attributes.java",
        "class_name": "Attributes",
        "class_uri": "src/main/java/org/jsoup/nodes/Attributes.java.Attributes",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": "\nGet an attribute value by key.\n@param key the (case-sensitive) attribute key\n@return the attribute value if set; or empty string if not set (or a boolean attribute).\n@see #hasKey(String)\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Attributes.java.Attributes.[Attribute]attribute(String)",
        "name": "attribute",
        "arg_nums": 1,
        "params": [
            {
                "name": "key",
                "type": "String"
            }
        ],
        "return_type": "Attribute",
        "signature": "@Nullable public Attribute attribute(String key)",
        "original_string": "    @Nullable public Attribute attribute(String key) {\n        int i = indexOfKey(key);\n        return i == NotFound ? null : new Attribute(key, checkNotNull(vals[i]), this);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Attributes.java",
        "class_name": "Attributes",
        "class_uri": "src/main/java/org/jsoup/nodes/Attributes.java.Attributes",
        "attributes": {
            "modifiers": "@Nullable public",
            "marker_annotations": [
                "@Nullable"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Attribute",
            "classes": []
        },
        "docstring": "\nGet an Attribute by key. The Attribute will remain connected to these Attributes, so changes made via\n{@link Attribute#setKey(String)}, {@link Attribute#setValue(String)} etc will cascade back to these Attributes and\ntheir owning Element.\n@param key the (case-sensitive) attribute key\n@return the Attribute for this key, or null if not present.\n@since 1.17.2\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Attributes.java.Attributes.[String]getIgnoreCase(String)",
        "name": "getIgnoreCase",
        "arg_nums": 1,
        "params": [
            {
                "name": "key",
                "type": "String"
            }
        ],
        "return_type": "String",
        "signature": "public String getIgnoreCase(String key)",
        "original_string": "    public String getIgnoreCase(String key) {\n        int i = indexOfKeyIgnoreCase(key);\n        return i == NotFound ? EmptyString : checkNotNull(vals[i]);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Attributes.java",
        "class_name": "Attributes",
        "class_uri": "src/main/java/org/jsoup/nodes/Attributes.java.Attributes",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": "\nGet an attribute's value by case-insensitive key\n@param key the attribute name\n@return the first matching attribute value if set; or empty string if not set (ora boolean attribute).\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Attributes.java.Attributes.[Attributes]add(String,String)",
        "name": "add",
        "arg_nums": 2,
        "params": [
            {
                "name": "key",
                "type": "String"
            },
            {
                "name": "value",
                "type": "String"
            }
        ],
        "return_type": "Attributes",
        "signature": "public Attributes add(String key, @Nullable String value)",
        "original_string": "    public Attributes add(String key, @Nullable String value) {\n        addObject(key, value);\n        return this;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Attributes.java",
        "class_name": "Attributes",
        "class_uri": "src/main/java/org/jsoup/nodes/Attributes.java.Attributes",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Attributes",
            "classes": []
        },
        "docstring": "\nAdds a new attribute. Will produce duplicates if the key already exists.\n@see Attributes#put(String, String)\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Attributes.java.Attributes.[void]addObject(String,Object)",
        "name": "addObject",
        "arg_nums": 2,
        "params": [
            {
                "name": "key",
                "type": "String"
            },
            {
                "name": "value",
                "type": "Object"
            }
        ],
        "return_type": "void",
        "signature": "private void addObject(String key, @Nullable Object value)",
        "original_string": "    private void addObject(String key, @Nullable Object value) {\n        checkCapacity(size + 1);\n        keys[size] = key;\n        vals[size] = value;\n        size++;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Attributes.java",
        "class_name": "Attributes",
        "class_uri": "src/main/java/org/jsoup/nodes/Attributes.java.Attributes",
        "attributes": {
            "modifiers": "private",
            "marker_annotations": [],
            "non_marker_annotations": [
                "private"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Attributes.java.Attributes.[Attributes]put(String,String)",
        "name": "put",
        "arg_nums": 2,
        "params": [
            {
                "name": "key",
                "type": "String"
            },
            {
                "name": "value",
                "type": "String"
            }
        ],
        "return_type": "Attributes",
        "signature": "public Attributes put(String key, @Nullable String value)",
        "original_string": "    public Attributes put(String key, @Nullable String value) {\n        Validate.notNull(key);\n        int i = indexOfKey(key);\n        if (i != NotFound)\n            vals[i] = value;\n        else\n            add(key, value);\n        return this;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Attributes.java",
        "class_name": "Attributes",
        "class_uri": "src/main/java/org/jsoup/nodes/Attributes.java.Attributes",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Attributes",
            "classes": []
        },
        "docstring": "\nSet a new attribute, or replace an existing one by key.\n@param key case sensitive attribute key (not null)\n@param value attribute value (which can be null, to set a true boolean attribute)\n@return these attributes, for chaining\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Attributes.java.Attributes.[Map<String, Object>]userData()",
        "name": "userData",
        "arg_nums": 0,
        "params": [],
        "return_type": "Map<String, Object>",
        "signature": "Map<String, Object> userData()",
        "original_string": "    Map<String, Object> userData() {\n        final Map<String, Object> userData;\n        int i = indexOfKey(SharedConstants.UserDataKey);\n        if (i == NotFound) {\n            userData = new HashMap<>();\n            addObject(SharedConstants.UserDataKey, userData);\n        } else {\n            //noinspection unchecked\n            userData = (Map<String, Object>) vals[i];\n        }\n        assert userData != null;\n        return userData;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Attributes.java",
        "class_name": "Attributes",
        "class_uri": "src/main/java/org/jsoup/nodes/Attributes.java.Attributes",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "Map<String, Object>",
            "classes": []
        },
        "docstring": "\nGet the map holding any user-data associated with these Attributes. Will be created empty on first use. Held as\nan internal attribute, not a field member, to reduce the memory footprint of Attributes when not used. Can hold\narbitrary objects; use for source ranges, connecting W3C nodes to Elements, etc.\n@return the map holding user-data\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Attributes.java.Attributes.[Object]userData(String)",
        "name": "userData",
        "arg_nums": 1,
        "params": [
            {
                "name": "key",
                "type": "String"
            }
        ],
        "return_type": "Object",
        "signature": "@Nullable\n    public Object userData(String key)",
        "original_string": "    @Nullable\n    public Object userData(String key) {\n        Validate.notNull(key);\n        if (!hasKey(SharedConstants.UserDataKey)) return null; // no user data exists\n        Map<String, Object> userData = userData();\n        return userData.get(key);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Attributes.java",
        "class_name": "Attributes",
        "class_uri": "src/main/java/org/jsoup/nodes/Attributes.java.Attributes",
        "attributes": {
            "modifiers": "@Nullable\n    public",
            "marker_annotations": [
                "@Nullable"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Object",
            "classes": []
        },
        "docstring": "\nGet an arbitrary user-data object by key.\n@param key case-sensitive key to the object.\n@return the object associated to this key, or {@code null} if not found.\n@see #userData(String key, Object val)\n@since 1.17.1\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Attributes.java.Attributes.[Attributes]userData(String,Object)",
        "name": "userData",
        "arg_nums": 2,
        "params": [
            {
                "name": "key",
                "type": "String"
            },
            {
                "name": "value",
                "type": "Object"
            }
        ],
        "return_type": "Attributes",
        "signature": "public Attributes userData(String key, Object value)",
        "original_string": "    public Attributes userData(String key, Object value) {\n        Validate.notNull(key);\n        userData().put(key, value);\n        return this;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Attributes.java",
        "class_name": "Attributes",
        "class_uri": "src/main/java/org/jsoup/nodes/Attributes.java.Attributes",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Attributes",
            "classes": []
        },
        "docstring": "\nSet an arbitrary user-data object by key. Will be treated as an internal attribute, so will not be emitted in HTML.\n@param key case-sensitive key\n@param value object value\n@return these attributes\n@see #userData(String key)\n@since 1.17.1\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Attributes.java.Attributes.[void]putIgnoreCase(String,String)",
        "name": "putIgnoreCase",
        "arg_nums": 2,
        "params": [
            {
                "name": "key",
                "type": "String"
            },
            {
                "name": "value",
                "type": "String"
            }
        ],
        "return_type": "void",
        "signature": "void putIgnoreCase(String key, @Nullable String value)",
        "original_string": "    void putIgnoreCase(String key, @Nullable String value) {\n        int i = indexOfKeyIgnoreCase(key);\n        if (i != NotFound) {\n            vals[i] = value;\n            String old = keys[i];\n            assert old != null;\n            if (!old.equals(key)) // case changed, update\n                keys[i] = key;\n        }\n        else\n            add(key, value);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Attributes.java",
        "class_name": "Attributes",
        "class_uri": "src/main/java/org/jsoup/nodes/Attributes.java.Attributes",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Attributes.java.Attributes.[Attributes]put(String,boolean)",
        "name": "put",
        "arg_nums": 2,
        "params": [
            {
                "name": "key",
                "type": "String"
            },
            {
                "name": "value",
                "type": "boolean"
            }
        ],
        "return_type": "Attributes",
        "signature": "public Attributes put(String key, boolean value)",
        "original_string": "    public Attributes put(String key, boolean value) {\n        if (value)\n            putIgnoreCase(key, null);\n        else\n            remove(key);\n        return this;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Attributes.java",
        "class_name": "Attributes",
        "class_uri": "src/main/java/org/jsoup/nodes/Attributes.java.Attributes",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Attributes",
            "classes": []
        },
        "docstring": "\nSet a new boolean attribute. Removes the attribute if the value is false.\n@param key case <b>insensitive</b> attribute key\n@param value attribute value\n@return these attributes, for chaining\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Attributes.java.Attributes.[Attributes]put(Attribute)",
        "name": "put",
        "arg_nums": 1,
        "params": [
            {
                "name": "attribute",
                "type": "Attribute"
            }
        ],
        "return_type": "Attributes",
        "signature": "public Attributes put(Attribute attribute)",
        "original_string": "    public Attributes put(Attribute attribute) {\n        Validate.notNull(attribute);\n        put(attribute.getKey(), attribute.getValue());\n        attribute.parent = this;\n        return this;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Attributes.java",
        "class_name": "Attributes",
        "class_uri": "src/main/java/org/jsoup/nodes/Attributes.java.Attributes",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Attributes",
            "classes": []
        },
        "docstring": "\nSet a new attribute, or replace an existing one by key.\n@param attribute attribute with case-sensitive key\n@return these attributes, for chaining\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Attributes.java.Attributes.[void]remove(int)",
        "name": "remove",
        "arg_nums": 1,
        "params": [
            {
                "name": "index",
                "type": "int"
            }
        ],
        "return_type": "void",
        "signature": "@SuppressWarnings(\"AssignmentToNull\")\n    private void remove(int index)",
        "original_string": "    @SuppressWarnings(\"AssignmentToNull\")\n    private void remove(int index) {\n        Validate.isFalse(index >= size);\n        int shifted = size - index - 1;\n        if (shifted > 0) {\n            System.arraycopy(keys, index + 1, keys, index, shifted);\n            System.arraycopy(vals, index + 1, vals, index, shifted);\n        }\n        size--;\n        keys[size] = null; // release hold\n        vals[size] = null;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Attributes.java",
        "class_name": "Attributes",
        "class_uri": "src/main/java/org/jsoup/nodes/Attributes.java.Attributes",
        "attributes": {
            "modifiers": "@SuppressWarnings(\"AssignmentToNull\")\n    private",
            "marker_annotations": [],
            "non_marker_annotations": [
                "@SuppressWarnings(\"AssignmentToNull\")",
                "private"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": " removes and shifts up"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Attributes.java.Attributes.[void]remove(String)",
        "name": "remove",
        "arg_nums": 1,
        "params": [
            {
                "name": "key",
                "type": "String"
            }
        ],
        "return_type": "void",
        "signature": "public void remove(String key)",
        "original_string": "    public void remove(String key) {\n        int i = indexOfKey(key);\n        if (i != NotFound)\n            remove(i);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Attributes.java",
        "class_name": "Attributes",
        "class_uri": "src/main/java/org/jsoup/nodes/Attributes.java.Attributes",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": "\nRemove an attribute by key. <b>Case sensitive.</b>\n@param key attribute key to remove\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Attributes.java.Attributes.[void]removeIgnoreCase(String)",
        "name": "removeIgnoreCase",
        "arg_nums": 1,
        "params": [
            {
                "name": "key",
                "type": "String"
            }
        ],
        "return_type": "void",
        "signature": "public void removeIgnoreCase(String key)",
        "original_string": "    public void removeIgnoreCase(String key) {\n        int i = indexOfKeyIgnoreCase(key);\n        if (i != NotFound)\n            remove(i);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Attributes.java",
        "class_name": "Attributes",
        "class_uri": "src/main/java/org/jsoup/nodes/Attributes.java.Attributes",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": "\nRemove an attribute by key. <b>Case insensitive.</b>\n@param key attribute key to remove\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Attributes.java.Attributes.[boolean]hasKey(String)",
        "name": "hasKey",
        "arg_nums": 1,
        "params": [
            {
                "name": "key",
                "type": "String"
            }
        ],
        "return_type": "boolean",
        "signature": "public boolean hasKey(String key)",
        "original_string": "    public boolean hasKey(String key) {\n        return indexOfKey(key) != NotFound;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Attributes.java",
        "class_name": "Attributes",
        "class_uri": "src/main/java/org/jsoup/nodes/Attributes.java.Attributes",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": "\nTests if these attributes contain an attribute with this key.\n@param key case-sensitive key to check for\n@return true if key exists, false otherwise\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Attributes.java.Attributes.[boolean]hasKeyIgnoreCase(String)",
        "name": "hasKeyIgnoreCase",
        "arg_nums": 1,
        "params": [
            {
                "name": "key",
                "type": "String"
            }
        ],
        "return_type": "boolean",
        "signature": "public boolean hasKeyIgnoreCase(String key)",
        "original_string": "    public boolean hasKeyIgnoreCase(String key) {\n        return indexOfKeyIgnoreCase(key) != NotFound;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Attributes.java",
        "class_name": "Attributes",
        "class_uri": "src/main/java/org/jsoup/nodes/Attributes.java.Attributes",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": "\nTests if these attributes contain an attribute with this key.\n@param key key to check for\n@return true if key exists, false otherwise\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Attributes.java.Attributes.[boolean]hasDeclaredValueForKey(String)",
        "name": "hasDeclaredValueForKey",
        "arg_nums": 1,
        "params": [
            {
                "name": "key",
                "type": "String"
            }
        ],
        "return_type": "boolean",
        "signature": "public boolean hasDeclaredValueForKey(String key)",
        "original_string": "    public boolean hasDeclaredValueForKey(String key) {\n        int i = indexOfKey(key);\n        return i != NotFound && vals[i] != null;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Attributes.java",
        "class_name": "Attributes",
        "class_uri": "src/main/java/org/jsoup/nodes/Attributes.java.Attributes",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": "\nCheck if these attributes contain an attribute with a value for this key.\n@param key key to check for\n@return true if key exists, and it has a value\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Attributes.java.Attributes.[boolean]hasDeclaredValueForKeyIgnoreCase(String)",
        "name": "hasDeclaredValueForKeyIgnoreCase",
        "arg_nums": 1,
        "params": [
            {
                "name": "key",
                "type": "String"
            }
        ],
        "return_type": "boolean",
        "signature": "public boolean hasDeclaredValueForKeyIgnoreCase(String key)",
        "original_string": "    public boolean hasDeclaredValueForKeyIgnoreCase(String key) {\n        int i = indexOfKeyIgnoreCase(key);\n        return i != NotFound && vals[i] != null;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Attributes.java",
        "class_name": "Attributes",
        "class_uri": "src/main/java/org/jsoup/nodes/Attributes.java.Attributes",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": "\nCheck if these attributes contain an attribute with a value for this key.\n@param key case-insensitive key to check for\n@return true if key exists, and it has a value\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Attributes.java.Attributes.[int]size()",
        "name": "size",
        "arg_nums": 0,
        "params": [],
        "return_type": "int",
        "signature": "public int size()",
        "original_string": "    public int size() {\n        return size;\n        // todo - exclude internal attributes from this count - maintain size, count of internals\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Attributes.java",
        "class_name": "Attributes",
        "class_uri": "src/main/java/org/jsoup/nodes/Attributes.java.Attributes",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "int",
            "classes": []
        },
        "docstring": "\nGet the number of attributes in this set, including any jsoup internal-only attributes. Internal attributes are\nexcluded from the {@link #html()}, {@link #asList()}, and {@link #iterator()} methods.\n@return size\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Attributes.java.Attributes.[boolean]isEmpty()",
        "name": "isEmpty",
        "arg_nums": 0,
        "params": [],
        "return_type": "boolean",
        "signature": "public boolean isEmpty()",
        "original_string": "    public boolean isEmpty() {\n        return size == 0;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Attributes.java",
        "class_name": "Attributes",
        "class_uri": "src/main/java/org/jsoup/nodes/Attributes.java.Attributes",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": "\nTest if this Attributes list is empty (size==0).\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Attributes.java.Attributes.[void]addAll(Attributes)",
        "name": "addAll",
        "arg_nums": 1,
        "params": [
            {
                "name": "incoming",
                "type": "Attributes"
            }
        ],
        "return_type": "void",
        "signature": "public void addAll(Attributes incoming)",
        "original_string": "    public void addAll(Attributes incoming) {\n        if (incoming.size() == 0)\n            return;\n        checkCapacity(size + incoming.size);\n\n        boolean needsPut = size != 0; // if this set is empty, no need to check existing set, so can add() vs put()\n        // (and save bashing on the indexOfKey()\n        for (Attribute attr : incoming) {\n            if (needsPut)\n                put(attr);\n            else\n                add(attr.getKey(), attr.getValue());\n        }\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Attributes.java",
        "class_name": "Attributes",
        "class_uri": "src/main/java/org/jsoup/nodes/Attributes.java.Attributes",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": "\nAdd all the attributes from the incoming set to this set.\n@param incoming attributes to add to these attributes.\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Attributes.java.Attributes.[Range.AttributeRange]sourceRange(String)",
        "name": "sourceRange",
        "arg_nums": 1,
        "params": [
            {
                "name": "key",
                "type": "String"
            }
        ],
        "return_type": "Range.AttributeRange",
        "signature": "public Range.AttributeRange sourceRange(String key)",
        "original_string": "    public Range.AttributeRange sourceRange(String key) {\n        if (!hasKey(key)) return UntrackedAttr;\n        Map<String, Range.AttributeRange> ranges = getRanges();\n        if (ranges == null) return Range.AttributeRange.UntrackedAttr;\n        Range.AttributeRange range = ranges.get(key);\n        return range != null ? range : Range.AttributeRange.UntrackedAttr;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Attributes.java",
        "class_name": "Attributes",
        "class_uri": "src/main/java/org/jsoup/nodes/Attributes.java.Attributes",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Range.AttributeRange",
            "classes": []
        },
        "docstring": "\nGet the source ranges (start to end position) in the original input source from which this attribute's <b>name</b>\nand <b>value</b> were parsed.\n<p>Position tracking must be enabled prior to parsing the content.</p>\n@param key the attribute name\n@return the ranges for the attribute's name and value, or {@code untracked} if the attribute does not exist or its range\nwas not tracked.\n@see org.jsoup.parser.Parser#setTrackPosition(boolean)\n@see Attribute#sourceRange()\n@see Node#sourceRange()\n@see Element#endSourceRange()\n@since 1.17.1\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Attributes.java.Attributes.[Map<String, Range.AttributeRange>]getRanges()",
        "name": "getRanges",
        "arg_nums": 0,
        "params": [],
        "return_type": "Map<String, Range.AttributeRange>",
        "signature": "@Nullable Map<String, Range.AttributeRange> getRanges()",
        "original_string": "    @Nullable Map<String, Range.AttributeRange> getRanges() {\n        //noinspection unchecked\n        return (Map<String, Range.AttributeRange>) userData(AttrRangeKey);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Attributes.java",
        "class_name": "Attributes",
        "class_uri": "src/main/java/org/jsoup/nodes/Attributes.java.Attributes",
        "attributes": {
            "modifiers": "@Nullable",
            "marker_annotations": [
                "@Nullable"
            ],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "Map<String, Range.AttributeRange>",
            "classes": []
        },
        "docstring": " Get the Ranges, if tracking is enabled; null otherwise."
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Attributes.java.Attributes.[Iterator<Attribute>]iterator()",
        "name": "iterator",
        "arg_nums": 0,
        "params": [],
        "return_type": "Iterator<Attribute>",
        "signature": "@Override\n    public Iterator<Attribute> iterator()",
        "original_string": "    @Override\n    public Iterator<Attribute> iterator() {\n        //noinspection ReturnOfInnerClass\n        return new Iterator<Attribute>() {\n            int expectedSize = size;\n            int i = 0;\n\n            @Override\n            public boolean hasNext() {\n                checkModified();\n                while (i < size) {\n                    String key = keys[i];\n                    assert key != null;\n                    if (isInternalKey(key)) // skip over internal keys\n                        i++;\n                    else\n                        break;\n                }\n\n                return i < size;\n            }\n\n            @Override\n            public Attribute next() {\n                checkModified();\n                if (i >= size) throw new NoSuchElementException();\n                String key = keys[i];\n                assert key != null;\n                final Attribute attr = new Attribute(key, (String) vals[i], Attributes.this);\n                i++;\n                return attr;\n            }\n\n            private void checkModified() {\n                if (size != expectedSize) throw new ConcurrentModificationException(\"Use Iterator#remove() instead to remove attributes while iterating.\");\n            }\n\n            @Override\n            public void remove() {\n                Attributes.this.remove(--i); // next() advanced, so rewind\n                expectedSize--;\n            }\n        };\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Attributes.java",
        "class_name": "Attributes",
        "class_uri": "src/main/java/org/jsoup/nodes/Attributes.java.Attributes",
        "attributes": {
            "modifiers": "@Override\n    public",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Iterator<Attribute>",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Attributes.java.Attributes.[List<Attribute>]asList()",
        "name": "asList",
        "arg_nums": 0,
        "params": [],
        "return_type": "List<Attribute>",
        "signature": "public List<Attribute> asList()",
        "original_string": "    public List<Attribute> asList() {\n        ArrayList<Attribute> list = new ArrayList<>(size);\n        for (int i = 0; i < size; i++) {\n            String key = keys[i];\n            assert key != null;\n            if (isInternalKey(key))\n                continue; // skip internal keys\n            Attribute attr = new Attribute(key, (String) vals[i], Attributes.this);\n            list.add(attr);\n        }\n        return Collections.unmodifiableList(list);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Attributes.java",
        "class_name": "Attributes",
        "class_uri": "src/main/java/org/jsoup/nodes/Attributes.java.Attributes",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "List<Attribute>",
            "classes": []
        },
        "docstring": "\nGet the attributes as a List, for iteration.\n@return a view of the attributes as an unmodifiable List.\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Attributes.java.Attributes.[Map<String, String>]dataset()",
        "name": "dataset",
        "arg_nums": 0,
        "params": [],
        "return_type": "Map<String, String>",
        "signature": "public Map<String, String> dataset()",
        "original_string": "    public Map<String, String> dataset() {\n        return new Dataset(this);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Attributes.java",
        "class_name": "Attributes",
        "class_uri": "src/main/java/org/jsoup/nodes/Attributes.java.Attributes",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Map<String, String>",
            "classes": []
        },
        "docstring": "\nRetrieves a filtered view of attributes that are HTML5 custom data attributes; that is, attributes with keys\nstarting with {@code data-}.\n@return map of custom data attributes.\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Attributes.java.Attributes.[String]html()",
        "name": "html",
        "arg_nums": 0,
        "params": [],
        "return_type": "String",
        "signature": "public String html()",
        "original_string": "    public String html() {\n        StringBuilder sb = StringUtil.borrowBuilder();\n        try {\n            html(sb, (new Document(\"\")).outputSettings()); // output settings a bit funky, but this html() seldom used\n        } catch (IOException e) { // ought never happen\n            throw new SerializationException(e);\n        }\n        return StringUtil.releaseBuilder(sb);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Attributes.java",
        "class_name": "Attributes",
        "class_uri": "src/main/java/org/jsoup/nodes/Attributes.java.Attributes",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": "\nGet the HTML representation of these attributes.\n@return HTML\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Attributes.java.Attributes.[void]html(Appendable,Document.OutputSettings)",
        "name": "html",
        "arg_nums": 2,
        "params": [
            {
                "name": "accum",
                "type": "Appendable"
            },
            {
                "name": "out",
                "type": "Document.OutputSettings"
            }
        ],
        "return_type": "void",
        "signature": "final void html(final Appendable accum, final Document.OutputSettings out)",
        "original_string": "    final void html(final Appendable accum, final Document.OutputSettings out) throws IOException {\n        final int sz = size;\n        for (int i = 0; i < sz; i++) {\n            String key = keys[i];\n            assert key != null;\n            if (isInternalKey(key))\n                continue;\n            final String validated = Attribute.getValidKey(key, out.syntax());\n            if (validated != null)\n                Attribute.htmlNoValidate(validated, (String) vals[i], accum.append(' '), out);\n        }\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Attributes.java",
        "class_name": "Attributes",
        "class_uri": "src/main/java/org/jsoup/nodes/Attributes.java.Attributes",
        "attributes": {
            "modifiers": "final",
            "marker_annotations": [],
            "non_marker_annotations": [
                "final"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Attributes.java.Attributes.[String]toString()",
        "name": "toString",
        "arg_nums": 0,
        "params": [],
        "return_type": "String",
        "signature": "@Override\n    public String toString()",
        "original_string": "    @Override\n    public String toString() {\n        return html();\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Attributes.java",
        "class_name": "Attributes",
        "class_uri": "src/main/java/org/jsoup/nodes/Attributes.java.Attributes",
        "attributes": {
            "modifiers": "@Override\n    public",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Attributes.java.Attributes.[boolean]equals(Object)",
        "name": "equals",
        "arg_nums": 1,
        "params": [
            {
                "name": "o",
                "type": "Object"
            }
        ],
        "return_type": "boolean",
        "signature": "@Override\n    public boolean equals(@Nullable Object o)",
        "original_string": "    @Override\n    public boolean equals(@Nullable Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n\n        Attributes that = (Attributes) o;\n        if (size != that.size) return false;\n        for (int i = 0; i < size; i++) {\n            String key = keys[i];\n            assert key != null;\n            int thatI = that.indexOfKey(key);\n            if (thatI == NotFound || !Objects.equals(vals[i], that.vals[thatI]))\n                return false;\n        }\n        return true;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Attributes.java",
        "class_name": "Attributes",
        "class_uri": "src/main/java/org/jsoup/nodes/Attributes.java.Attributes",
        "attributes": {
            "modifiers": "@Override\n    public",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": "\nChecks if these attributes are equal to another set of attributes, by comparing the two sets. Note that the order\nof the attributes does not impact this equality (as per the Map interface equals()).\n@param o attributes to compare with\n@return if both sets of attributes have the same content\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Attributes.java.Attributes.[int]hashCode()",
        "name": "hashCode",
        "arg_nums": 0,
        "params": [],
        "return_type": "int",
        "signature": "@Override\n    public int hashCode()",
        "original_string": "    @Override\n    public int hashCode() {\n        int result = size;\n        result = 31 * result + Arrays.hashCode(keys);\n        result = 31 * result + Arrays.hashCode(vals);\n        return result;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Attributes.java",
        "class_name": "Attributes",
        "class_uri": "src/main/java/org/jsoup/nodes/Attributes.java.Attributes",
        "attributes": {
            "modifiers": "@Override\n    public",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "int",
            "classes": []
        },
        "docstring": "\nCalculates the hashcode of these attributes, by iterating all attributes and summing their hashcodes.\n@return calculated hashcode\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Attributes.java.Attributes.[Attributes]clone()",
        "name": "clone",
        "arg_nums": 0,
        "params": [],
        "return_type": "Attributes",
        "signature": "@Override\n    public Attributes clone()",
        "original_string": "    @Override\n    public Attributes clone() {\n        Attributes clone;\n        try {\n            clone = (Attributes) super.clone();\n        } catch (CloneNotSupportedException e) {\n            throw new RuntimeException(e);\n        }\n        clone.size = size;\n        clone.keys = Arrays.copyOf(keys, size);\n        clone.vals = Arrays.copyOf(vals, size);\n        return clone;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Attributes.java",
        "class_name": "Attributes",
        "class_uri": "src/main/java/org/jsoup/nodes/Attributes.java.Attributes",
        "attributes": {
            "modifiers": "@Override\n    public",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Attributes",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Attributes.java.Attributes.[void]normalize()",
        "name": "normalize",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "public void normalize()",
        "original_string": "    public void normalize() {\n        for (int i = 0; i < size; i++) {\n            assert keys[i] != null;\n            String key = keys[i];\n            assert key != null;\n            if (!isInternalKey(key))\n                keys[i] = lowerCase(key);\n        }\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Attributes.java",
        "class_name": "Attributes",
        "class_uri": "src/main/java/org/jsoup/nodes/Attributes.java.Attributes",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": "\nInternal method. Lowercases all (non-internal) keys.\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Attributes.java.Attributes.[int]deduplicate(ParseSettings)",
        "name": "deduplicate",
        "arg_nums": 1,
        "params": [
            {
                "name": "settings",
                "type": "ParseSettings"
            }
        ],
        "return_type": "int",
        "signature": "public int deduplicate(ParseSettings settings)",
        "original_string": "    public int deduplicate(ParseSettings settings) {\n        if (isEmpty())\n            return 0;\n        boolean preserve = settings.preserveAttributeCase();\n        int dupes = 0;\n        for (int i = 0; i < size; i++) {\n            String keyI = keys[i];\n            assert keyI != null;\n            for (int j = i + 1; j < size; j++) {\n                if ((preserve && keyI.equals(keys[j])) || (!preserve && keyI.equalsIgnoreCase(keys[j]))) {\n                    dupes++;\n                    remove(j);\n                    j--;\n                }\n            }\n        }\n        return dupes;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Attributes.java",
        "class_name": "Attributes",
        "class_uri": "src/main/java/org/jsoup/nodes/Attributes.java.Attributes",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "int",
            "classes": []
        },
        "docstring": "\nInternal method. Removes duplicate attribute by name. Settings for case sensitivity of key names.\n@param settings case sensitivity\n@return number of removed dupes\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Attributes.java.Attributes.[String]dataKey(String)",
        "name": "dataKey",
        "arg_nums": 1,
        "params": [
            {
                "name": "key",
                "type": "String"
            }
        ],
        "return_type": "String",
        "signature": "private static String dataKey(String key)",
        "original_string": "    private static String dataKey(String key) {\n        return dataPrefix + key;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Attributes.java",
        "class_name": "Attributes",
        "class_uri": "src/main/java/org/jsoup/nodes/Attributes.java.Attributes",
        "attributes": {
            "modifiers": "private static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "private",
                "static"
            ],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Attributes.java.Attributes.[String]internalKey(String)",
        "name": "internalKey",
        "arg_nums": 1,
        "params": [
            {
                "name": "key",
                "type": "String"
            }
        ],
        "return_type": "String",
        "signature": "static String internalKey(String key)",
        "original_string": "    static String internalKey(String key) {\n        return InternalPrefix + key;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Attributes.java",
        "class_name": "Attributes",
        "class_uri": "src/main/java/org/jsoup/nodes/Attributes.java.Attributes",
        "attributes": {
            "modifiers": "static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "static"
            ],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Attributes.java.Attributes.[boolean]isInternalKey(String)",
        "name": "isInternalKey",
        "arg_nums": 1,
        "params": [
            {
                "name": "key",
                "type": "String"
            }
        ],
        "return_type": "boolean",
        "signature": "static boolean isInternalKey(String key)",
        "original_string": "    static boolean isInternalKey(String key) {\n        return key.length() > 1 && key.charAt(0) == InternalPrefix;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Attributes.java",
        "class_name": "Attributes",
        "class_uri": "src/main/java/org/jsoup/nodes/Attributes.java.Attributes",
        "attributes": {
            "modifiers": "static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "static"
            ],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Entities.java.Entities.[]Entities()",
        "name": "Entities",
        "arg_nums": 0,
        "params": [],
        "return_type": "",
        "signature": "private Entities()",
        "original_string": "    private Entities() {\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Entities.java",
        "class_name": "Entities",
        "class_uri": "src/main/java/org/jsoup/nodes/Entities.java.Entities",
        "attributes": {
            "modifiers": "private",
            "marker_annotations": [],
            "non_marker_annotations": [
                "private"
            ],
            "comments": [],
            "return_type": "",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Entities.java.Entities.[boolean]isNamedEntity(String)",
        "name": "isNamedEntity",
        "arg_nums": 1,
        "params": [
            {
                "name": "name",
                "type": "String"
            }
        ],
        "return_type": "boolean",
        "signature": "public static boolean isNamedEntity(final String name)",
        "original_string": "    public static boolean isNamedEntity(final String name) {\n        return extended.codepointForName(name) != empty;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Entities.java",
        "class_name": "Entities",
        "class_uri": "src/main/java/org/jsoup/nodes/Entities.java.Entities",
        "attributes": {
            "modifiers": "public static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public",
                "static"
            ],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": "\nCheck if the input is a known named entity\n\n@param name the possible entity name (e.g. \"lt\" or \"amp\")\n@return true if a known named entity\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Entities.java.Entities.[boolean]isBaseNamedEntity(String)",
        "name": "isBaseNamedEntity",
        "arg_nums": 1,
        "params": [
            {
                "name": "name",
                "type": "String"
            }
        ],
        "return_type": "boolean",
        "signature": "public static boolean isBaseNamedEntity(final String name)",
        "original_string": "    public static boolean isBaseNamedEntity(final String name) {\n        return base.codepointForName(name) != empty;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Entities.java",
        "class_name": "Entities",
        "class_uri": "src/main/java/org/jsoup/nodes/Entities.java.Entities",
        "attributes": {
            "modifiers": "public static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public",
                "static"
            ],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": "\nCheck if the input is a known named entity in the base entity set.\n\n@param name the possible entity name (e.g. \"lt\" or \"amp\")\n@return true if a known named entity in the base set\n@see #isNamedEntity(String)\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Entities.java.Entities.[String]getByName(String)",
        "name": "getByName",
        "arg_nums": 1,
        "params": [
            {
                "name": "name",
                "type": "String"
            }
        ],
        "return_type": "String",
        "signature": "public static String getByName(String name)",
        "original_string": "    public static String getByName(String name) {\n        String val = multipoints.get(name);\n        if (val != null)\n            return val;\n        int codepoint = extended.codepointForName(name);\n        if (codepoint != empty)\n            return new String(new int[]{codepoint}, 0, 1);\n        return emptyName;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Entities.java",
        "class_name": "Entities",
        "class_uri": "src/main/java/org/jsoup/nodes/Entities.java.Entities",
        "attributes": {
            "modifiers": "public static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public",
                "static"
            ],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": "\nGet the character(s) represented by the named entity\n\n@param name entity (e.g. \"lt\" or \"amp\")\n@return the string value of the character(s) represented by this entity, or \"\" if not defined\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Entities.java.Entities.[int]codepointsForName(String,int[])",
        "name": "codepointsForName",
        "arg_nums": 2,
        "params": [
            {
                "name": "name",
                "type": "String"
            },
            {
                "name": "codepoints",
                "type": "int[]"
            }
        ],
        "return_type": "int",
        "signature": "public static int codepointsForName(final String name, final int[] codepoints)",
        "original_string": "    public static int codepointsForName(final String name, final int[] codepoints) {\n        String val = multipoints.get(name);\n        if (val != null) {\n            codepoints[0] = val.codePointAt(0);\n            codepoints[1] = val.codePointAt(1);\n            return 2;\n        }\n        int codepoint = extended.codepointForName(name);\n        if (codepoint != empty) {\n            codepoints[0] = codepoint;\n            return 1;\n        }\n        return 0;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Entities.java",
        "class_name": "Entities",
        "class_uri": "src/main/java/org/jsoup/nodes/Entities.java.Entities",
        "attributes": {
            "modifiers": "public static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public",
                "static"
            ],
            "comments": [],
            "return_type": "int",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Entities.java.Entities.[String]escape(String,OutputSettings)",
        "name": "escape",
        "arg_nums": 2,
        "params": [
            {
                "name": "data",
                "type": "String"
            },
            {
                "name": "out",
                "type": "OutputSettings"
            }
        ],
        "return_type": "String",
        "signature": "public static String escape(String data, OutputSettings out)",
        "original_string": "    public static String escape(String data, OutputSettings out) {\n        return escapeString(data, out.escapeMode(), out.syntax(), out.charset());\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Entities.java",
        "class_name": "Entities",
        "class_uri": "src/main/java/org/jsoup/nodes/Entities.java.Entities",
        "attributes": {
            "modifiers": "public static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public",
                "static"
            ],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": "\nHTML escape an input string. That is, {@code <} is returned as {@code &lt;}. The escaped string is suitable for use\nboth in attributes and in text data.\n@param data the un-escaped string to escape\n@param out the output settings to use. This configures the character set escaped against (that is, if a\ncharacter is supported in the output character set, it doesn't have to be escaped), and also HTML or XML\nsettings.\n@return the escaped string\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Entities.java.Entities.[String]escape(String)",
        "name": "escape",
        "arg_nums": 1,
        "params": [
            {
                "name": "data",
                "type": "String"
            }
        ],
        "return_type": "String",
        "signature": "public static String escape(String data)",
        "original_string": "    public static String escape(String data) {\n        return escapeString(data, base, Syntax.html, DataUtil.UTF_8);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Entities.java",
        "class_name": "Entities",
        "class_uri": "src/main/java/org/jsoup/nodes/Entities.java.Entities",
        "attributes": {
            "modifiers": "public static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public",
                "static"
            ],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": "\nHTML escape an input string, using the default settings (UTF-8, base entities, HTML syntax). That is, {@code <} is\nreturned as {@code &lt;}. The escaped string is suitable for use both in attributes and in text data.\n@param data the un-escaped string to escape\n@return the escaped string\n@see #escape(String, OutputSettings)\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Entities.java.Entities.[String]escapeString(String,EscapeMode,Syntax,Charset)",
        "name": "escapeString",
        "arg_nums": 4,
        "params": [
            {
                "name": "data",
                "type": "String"
            },
            {
                "name": "escapeMode",
                "type": "EscapeMode"
            },
            {
                "name": "syntax",
                "type": "Syntax"
            },
            {
                "name": "charset",
                "type": "Charset"
            }
        ],
        "return_type": "String",
        "signature": "private static String escapeString(String data, EscapeMode escapeMode, Syntax syntax, Charset charset)",
        "original_string": "    private static String escapeString(String data, EscapeMode escapeMode, Syntax syntax, Charset charset) {\n        if (data == null)\n            return \"\";\n        StringBuilder accum = StringUtil.borrowBuilder();\n        try {\n            doEscape(data, accum, escapeMode, syntax, charset, ForText | ForAttribute);\n        } catch (IOException e) {\n            throw new SerializationException(e); // doesn't happen\n        }\n        return StringUtil.releaseBuilder(accum);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Entities.java",
        "class_name": "Entities",
        "class_uri": "src/main/java/org/jsoup/nodes/Entities.java.Entities",
        "attributes": {
            "modifiers": "private static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "private",
                "static"
            ],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Entities.java.Entities.[void]escape(Appendable,String,OutputSettings,int)",
        "name": "escape",
        "arg_nums": 4,
        "params": [
            {
                "name": "accum",
                "type": "Appendable"
            },
            {
                "name": "data",
                "type": "String"
            },
            {
                "name": "out",
                "type": "OutputSettings"
            },
            {
                "name": "options",
                "type": "int"
            }
        ],
        "return_type": "void",
        "signature": "static void escape(Appendable accum, String data, OutputSettings out, int options)",
        "original_string": "    static void escape(Appendable accum, String data, OutputSettings out, int options) throws IOException {\n        doEscape(data, accum, out.escapeMode(), out.syntax(), out.charset(), options);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Entities.java",
        "class_name": "Entities",
        "class_uri": "src/main/java/org/jsoup/nodes/Entities.java.Entities",
        "attributes": {
            "modifiers": "static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "static"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Entities.java.Entities.[void]doEscape(String,Appendable,EscapeMode,Syntax,Charset,int)",
        "name": "doEscape",
        "arg_nums": 6,
        "params": [
            {
                "name": "data",
                "type": "String"
            },
            {
                "name": "accum",
                "type": "Appendable"
            },
            {
                "name": "mode",
                "type": "EscapeMode"
            },
            {
                "name": "syntax",
                "type": "Syntax"
            },
            {
                "name": "charset",
                "type": "Charset"
            },
            {
                "name": "options",
                "type": "int"
            }
        ],
        "return_type": "void",
        "signature": "private static void doEscape(String data, Appendable accum, EscapeMode mode, Syntax syntax, Charset charset, int options)",
        "original_string": "    private static void doEscape(String data, Appendable accum, EscapeMode mode, Syntax syntax, Charset charset, int options) throws IOException {\n        final CoreCharset coreCharset = CoreCharset.byName(charset.name());\n        final CharsetEncoder fallback = encoderFor(charset);\n        final int length = data.length();\n\n        int codePoint;\n        boolean lastWasWhite = false;\n        boolean reachedNonWhite = false;\n        boolean skipped = false;\n        for (int offset = 0; offset < length; offset += Character.charCount(codePoint)) {\n            codePoint = data.codePointAt(offset);\n\n            if ((options & Normalise) != 0) {\n                if (StringUtil.isWhitespace(codePoint)) {\n                    if ((options & TrimLeading) != 0 && !reachedNonWhite) continue;\n                    if (lastWasWhite) continue;\n                    if ((options & TrimTrailing) != 0) {\n                        skipped = true;\n                        continue;\n                    }\n                    accum.append(' ');\n                    lastWasWhite = true;\n                    continue;\n                } else {\n                    lastWasWhite = false;\n                    reachedNonWhite = true;\n                    if (skipped) {\n                        accum.append(' '); // wasn't the end, so need to place a normalized space\n                        skipped = false;\n                    }\n                }\n            }\n            appendEscaped(codePoint, accum, options, mode, syntax, coreCharset, fallback);\n        }\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Entities.java",
        "class_name": "Entities",
        "class_uri": "src/main/java/org/jsoup/nodes/Entities.java.Entities",
        "attributes": {
            "modifiers": "private static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "private",
                "static"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Entities.java.Entities.[void]appendEscaped(int,Appendable,int,EscapeMode,Syntax,CoreCharset,CharsetEncoder)",
        "name": "appendEscaped",
        "arg_nums": 7,
        "params": [
            {
                "name": "codePoint",
                "type": "int"
            },
            {
                "name": "accum",
                "type": "Appendable"
            },
            {
                "name": "options",
                "type": "int"
            },
            {
                "name": "escapeMode",
                "type": "EscapeMode"
            },
            {
                "name": "syntax",
                "type": "Syntax"
            },
            {
                "name": "coreCharset",
                "type": "CoreCharset"
            },
            {
                "name": "fallback",
                "type": "CharsetEncoder"
            }
        ],
        "return_type": "void",
        "signature": "private static void appendEscaped(int codePoint, Appendable accum, int options, EscapeMode escapeMode,\n        Syntax syntax, CoreCharset coreCharset, CharsetEncoder fallback)",
        "original_string": "    private static void appendEscaped(int codePoint, Appendable accum, int options, EscapeMode escapeMode,\n        Syntax syntax, CoreCharset coreCharset, CharsetEncoder fallback) throws IOException {\n\n        // surrogate pairs, split implementation for efficiency on single char common case (saves creating strings, char[]):\n        final char c = (char) codePoint;\n        if (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n            // html specific and required escapes:\n            switch (c) {\n                case '&':\n                    accum.append(\"&amp;\");\n                    break;\n                case 0xA0:\n                    appendNbsp(accum, escapeMode);\n                    break;\n                case '<':\n                    // escape when in character data or when in a xml attribute val or XML syntax; not needed in html attr val\n                    appendLt(accum, options, escapeMode, syntax);\n                    break;\n                case '>':\n                    if ((options & ForText) != 0) accum.append(\"&gt;\");\n                    else accum.append(c);\n                    break;\n                case '\"':\n                    if ((options & ForAttribute) != 0) accum.append(\"&quot;\");\n                    else accum.append(c);\n                    break;\n                case '\\'':\n                    // special case for the Entities.escape(string) method when we are maximally escaping. Otherwise, because we output attributes in \"\", there's no need to escape.\n                    appendApos(accum, options, escapeMode);\n                    break;\n                // we escape ascii control <x20 (other than tab, line-feed, carriage return) for XML compliance (required) and HTML ease of reading (not required) - https://www.w3.org/TR/xml/#charsets\n                case 0x9:\n                case 0xA:\n                case 0xD:\n                    accum.append(c);\n                    break;\n                default:\n                    if (c < 0x20 || !canEncode(coreCharset, c, fallback)) appendEncoded(accum, escapeMode, codePoint);\n                    else accum.append(c);\n            }\n        } else {\n            if (canEncode(coreCharset, c, fallback)) {\n                // reads into charBuf - we go through these steps to avoid GC objects as much as possible (would be a new String and a new char[2] for each character)\n                char[] chars = charBuf.get();\n                int len = Character.toChars(codePoint, chars, 0);\n                if (accum instanceof StringBuilder) // true unless the user supplied their own\n                    ((StringBuilder) accum).append(chars, 0, len);\n                else\n                    accum.append(new String(chars, 0, len));\n            } else {\n                appendEncoded(accum, escapeMode, codePoint);\n            }\n        }\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Entities.java",
        "class_name": "Entities",
        "class_uri": "src/main/java/org/jsoup/nodes/Entities.java.Entities",
        "attributes": {
            "modifiers": "private static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "private",
                "static"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Entities.java.Entities.[void]appendNbsp(Appendable,EscapeMode)",
        "name": "appendNbsp",
        "arg_nums": 2,
        "params": [
            {
                "name": "accum",
                "type": "Appendable"
            },
            {
                "name": "escapeMode",
                "type": "EscapeMode"
            }
        ],
        "return_type": "void",
        "signature": "private static void appendNbsp(Appendable accum, EscapeMode escapeMode)",
        "original_string": "    private static void appendNbsp(Appendable accum, EscapeMode escapeMode) throws IOException {\n        if (escapeMode != EscapeMode.xhtml) accum.append(\"&nbsp;\");\n        else accum.append(\"&#xa0;\");\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Entities.java",
        "class_name": "Entities",
        "class_uri": "src/main/java/org/jsoup/nodes/Entities.java.Entities",
        "attributes": {
            "modifiers": "private static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "private",
                "static"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Entities.java.Entities.[void]appendLt(Appendable,int,EscapeMode,Syntax)",
        "name": "appendLt",
        "arg_nums": 4,
        "params": [
            {
                "name": "accum",
                "type": "Appendable"
            },
            {
                "name": "options",
                "type": "int"
            },
            {
                "name": "escapeMode",
                "type": "EscapeMode"
            },
            {
                "name": "syntax",
                "type": "Syntax"
            }
        ],
        "return_type": "void",
        "signature": "private static void appendLt(Appendable accum, int options, EscapeMode escapeMode, Syntax syntax)",
        "original_string": "    private static void appendLt(Appendable accum, int options, EscapeMode escapeMode, Syntax syntax) throws IOException {\n        if ((options & ForText) != 0 || escapeMode == EscapeMode.xhtml || syntax == Syntax.xml) accum.append(\"&lt;\");\n        else accum.append('<'); // no need to escape < when in an HTML attribute\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Entities.java",
        "class_name": "Entities",
        "class_uri": "src/main/java/org/jsoup/nodes/Entities.java.Entities",
        "attributes": {
            "modifiers": "private static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "private",
                "static"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Entities.java.Entities.[void]appendApos(Appendable,int,EscapeMode)",
        "name": "appendApos",
        "arg_nums": 3,
        "params": [
            {
                "name": "accum",
                "type": "Appendable"
            },
            {
                "name": "options",
                "type": "int"
            },
            {
                "name": "escapeMode",
                "type": "EscapeMode"
            }
        ],
        "return_type": "void",
        "signature": "private static void appendApos(Appendable accum, int options, EscapeMode escapeMode)",
        "original_string": "    private static void appendApos(Appendable accum, int options, EscapeMode escapeMode) throws IOException {\n        if ((options & ForAttribute) != 0 && (options & ForText) != 0) {\n            if (escapeMode == EscapeMode.xhtml) accum.append(\"&#x27;\");\n            else accum.append(\"&apos;\");\n        } else {\n            accum.append('\\'');\n        }\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Entities.java",
        "class_name": "Entities",
        "class_uri": "src/main/java/org/jsoup/nodes/Entities.java.Entities",
        "attributes": {
            "modifiers": "private static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "private",
                "static"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Entities.java.Entities.[void]appendEncoded(Appendable,EscapeMode,int)",
        "name": "appendEncoded",
        "arg_nums": 3,
        "params": [
            {
                "name": "accum",
                "type": "Appendable"
            },
            {
                "name": "escapeMode",
                "type": "EscapeMode"
            },
            {
                "name": "codePoint",
                "type": "int"
            }
        ],
        "return_type": "void",
        "signature": "private static void appendEncoded(Appendable accum, EscapeMode escapeMode, int codePoint)",
        "original_string": "    private static void appendEncoded(Appendable accum, EscapeMode escapeMode, int codePoint) throws IOException {\n        final String name = escapeMode.nameForCodepoint(codePoint);\n        if (!emptyName.equals(name)) // ok for identity check\n            accum.append('&').append(name).append(';');\n        else\n            accum.append(\"&#x\").append(Integer.toHexString(codePoint)).append(';');\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Entities.java",
        "class_name": "Entities",
        "class_uri": "src/main/java/org/jsoup/nodes/Entities.java.Entities",
        "attributes": {
            "modifiers": "private static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "private",
                "static"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Entities.java.Entities.[String]unescape(String)",
        "name": "unescape",
        "arg_nums": 1,
        "params": [
            {
                "name": "string",
                "type": "String"
            }
        ],
        "return_type": "String",
        "signature": "public static String unescape(String string)",
        "original_string": "    public static String unescape(String string) {\n        return unescape(string, false);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Entities.java",
        "class_name": "Entities",
        "class_uri": "src/main/java/org/jsoup/nodes/Entities.java.Entities",
        "attributes": {
            "modifiers": "public static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public",
                "static"
            ],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": "\nUn-escape an HTML escaped string. That is, {@code &lt;} is returned as {@code <}.\n\n@param string the HTML string to un-escape\n@return the unescaped string\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Entities.java.Entities.[String]unescape(String,boolean)",
        "name": "unescape",
        "arg_nums": 2,
        "params": [
            {
                "name": "string",
                "type": "String"
            },
            {
                "name": "strict",
                "type": "boolean"
            }
        ],
        "return_type": "String",
        "signature": "static String unescape(String string, boolean strict)",
        "original_string": "    static String unescape(String string, boolean strict) {\n        return Parser.unescapeEntities(string, strict);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Entities.java",
        "class_name": "Entities",
        "class_uri": "src/main/java/org/jsoup/nodes/Entities.java.Entities",
        "attributes": {
            "modifiers": "static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "static"
            ],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": "\nUnescape the input string.\n\n@param string to un-HTML-escape\n@param strict if \"strict\" (that is, requires trailing ';' char, otherwise that's optional)\n@return unescaped string\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Entities.java.Entities.[boolean]canEncode(CoreCharset,char,CharsetEncoder)",
        "name": "canEncode",
        "arg_nums": 3,
        "params": [
            {
                "name": "charset",
                "type": "CoreCharset"
            },
            {
                "name": "c",
                "type": "char"
            },
            {
                "name": "fallback",
                "type": "CharsetEncoder"
            }
        ],
        "return_type": "boolean",
        "signature": "private static boolean canEncode(final CoreCharset charset, final char c, final CharsetEncoder fallback)",
        "original_string": "    private static boolean canEncode(final CoreCharset charset, final char c, final CharsetEncoder fallback) {\n        // todo add more charset tests if impacted by Android's bad perf in canEncode\n        switch (charset) {\n            case ascii:\n                return c < 0x80;\n            case utf:\n                return !(c >= Character.MIN_SURROGATE && c < (Character.MAX_SURROGATE + 1)); // !Character.isSurrogate(c); but not in Android 10 desugar\n            default:\n                return fallback.canEncode(c);\n        }\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Entities.java",
        "class_name": "Entities",
        "class_uri": "src/main/java/org/jsoup/nodes/Entities.java.Entities",
        "attributes": {
            "modifiers": "private static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "private",
                "static"
            ],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": "\nProvides a fast-path for Encoder.canEncode, which drastically improves performance on Android post JellyBean.\nAfter KitKat, the implementation of canEncode degrades to the point of being useless. For non ASCII or UTF,\nperformance may be bad. We can add more encoders for common character sets that are impacted by performance\nissues on Android if required.\n\nBenchmarks:     *\nOLD toHtml() impl v New (fastpath) in millis\nWiki: 1895, 16\nCNN: 6378, 55\nAlterslash: 3013, 28\nJsoup: 167, 2\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Entities.java.Entities.[CharsetEncoder]encoderFor(Charset)",
        "name": "encoderFor",
        "arg_nums": 1,
        "params": [
            {
                "name": "charset",
                "type": "Charset"
            }
        ],
        "return_type": "CharsetEncoder",
        "signature": "private static CharsetEncoder encoderFor(Charset charset)",
        "original_string": "    private static CharsetEncoder encoderFor(Charset charset) {\n        CharsetEncoder encoder = LocalEncoder.get();\n        if (encoder == null || !encoder.charset().equals(charset)) {\n            encoder = charset.newEncoder();\n            LocalEncoder.set(encoder);\n        }\n        return encoder;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Entities.java",
        "class_name": "Entities",
        "class_uri": "src/main/java/org/jsoup/nodes/Entities.java.Entities",
        "attributes": {
            "modifiers": "private static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "private",
                "static"
            ],
            "comments": [],
            "return_type": "CharsetEncoder",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Entities.java.Entities.[void]load(EscapeMode,String,int)",
        "name": "load",
        "arg_nums": 3,
        "params": [
            {
                "name": "e",
                "type": "EscapeMode"
            },
            {
                "name": "pointsData",
                "type": "String"
            },
            {
                "name": "size",
                "type": "int"
            }
        ],
        "return_type": "void",
        "signature": "private static void load(EscapeMode e, String pointsData, int size)",
        "original_string": "    private static void load(EscapeMode e, String pointsData, int size) {\n        e.nameKeys = new String[size];\n        e.codeVals = new int[size];\n        e.codeKeys = new int[size];\n        e.nameVals = new String[size];\n\n        int i = 0;\n        CharacterReader reader = new CharacterReader(pointsData);\n        try {\n            while (!reader.isEmpty()) {\n                // NotNestedLessLess=10913,824;1887&\n\n                final String name = reader.consumeTo('=');\n                reader.advance();\n                final int cp1 = Integer.parseInt(reader.consumeToAny(codeDelims), codepointRadix);\n                final char codeDelim = reader.current();\n                reader.advance();\n                final int cp2;\n                if (codeDelim == ',') {\n                    cp2 = Integer.parseInt(reader.consumeTo(';'), codepointRadix);\n                    reader.advance();\n                } else {\n                    cp2 = empty;\n                }\n                final String indexS = reader.consumeTo('&');\n                final int index = Integer.parseInt(indexS, codepointRadix);\n                reader.advance();\n\n                e.nameKeys[i] = name;\n                e.codeVals[i] = cp1;\n                e.codeKeys[index] = cp1;\n                e.nameVals[index] = name;\n\n                if (cp2 != empty) {\n                    multipoints.put(name, new String(new int[]{cp1, cp2}, 0, 2));\n                }\n                i++;\n            }\n\n            Validate.isTrue(i == size, \"Unexpected count of entities loaded\");\n        } finally {\n            reader.close();\n        }\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Entities.java",
        "class_name": "Entities",
        "class_uri": "src/main/java/org/jsoup/nodes/Entities.java.Entities",
        "attributes": {
            "modifiers": "private static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "private",
                "static"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/NodeUtils.java.NodeUtils.[Document.OutputSettings]outputSettings(Node)",
        "name": "outputSettings",
        "arg_nums": 1,
        "params": [
            {
                "name": "node",
                "type": "Node"
            }
        ],
        "return_type": "Document.OutputSettings",
        "signature": "static Document.OutputSettings outputSettings(Node node)",
        "original_string": "    static Document.OutputSettings outputSettings(Node node) {\n        Document owner = node.ownerDocument();\n        return owner != null ? owner.outputSettings() : (new Document(\"\")).outputSettings();\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/NodeUtils.java",
        "class_name": "NodeUtils",
        "class_uri": "src/main/java/org/jsoup/nodes/NodeUtils.java.NodeUtils",
        "attributes": {
            "modifiers": "static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "static"
            ],
            "comments": [],
            "return_type": "Document.OutputSettings",
            "classes": []
        },
        "docstring": "\nGet the output setting for this node,  or if this node has no document (or parent), retrieve the default output\nsettings\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/NodeUtils.java.NodeUtils.[Parser]parser(Node)",
        "name": "parser",
        "arg_nums": 1,
        "params": [
            {
                "name": "node",
                "type": "Node"
            }
        ],
        "return_type": "Parser",
        "signature": "static Parser parser(Node node)",
        "original_string": "    static Parser parser(Node node) {\n        Document doc = node.ownerDocument();\n        return doc != null ? doc.parser() : new Parser(new HtmlTreeBuilder());\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/NodeUtils.java",
        "class_name": "NodeUtils",
        "class_uri": "src/main/java/org/jsoup/nodes/NodeUtils.java.NodeUtils",
        "attributes": {
            "modifiers": "static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "static"
            ],
            "comments": [],
            "return_type": "Parser",
            "classes": []
        },
        "docstring": "\nGet the parser that was used to make this node, or the default HTML parser if it has no parent.\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/NodeUtils.java.NodeUtils.[List<T>]selectXpath(String,Element,Class<T>)",
        "name": "selectXpath",
        "arg_nums": 3,
        "params": [
            {
                "name": "xpath",
                "type": "String"
            },
            {
                "name": "el",
                "type": "Element"
            },
            {
                "name": "nodeType",
                "type": "Class<T>"
            }
        ],
        "return_type": "List<T>",
        "signature": "static <T extends Node> List<T> selectXpath(String xpath, Element el, Class<T> nodeType)",
        "original_string": "    static <T extends Node> List<T> selectXpath(String xpath, Element el, Class<T> nodeType) {\n        Validate.notEmpty(xpath);\n        Validate.notNull(el);\n        Validate.notNull(nodeType);\n\n        W3CDom w3c = new W3CDom().namespaceAware(false);\n        org.w3c.dom.Document wDoc = w3c.fromJsoup(el);\n        org.w3c.dom.Node contextNode = w3c.contextNode(wDoc);\n        NodeList nodeList = w3c.selectXpath(xpath, contextNode);\n        return w3c.sourceNodes(nodeList, nodeType);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/NodeUtils.java",
        "class_name": "NodeUtils",
        "class_uri": "src/main/java/org/jsoup/nodes/NodeUtils.java.NodeUtils",
        "attributes": {
            "modifiers": "static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "static"
            ],
            "comments": [],
            "return_type": "List<T>",
            "classes": []
        },
        "docstring": "\nThis impl works by compiling the input xpath expression, and then evaluating it against a W3C Document converted\nfrom the original jsoup element. The original jsoup elements are then fetched from the w3c doc user data (where we\nstashed them during conversion). This process could potentially be optimized by transpiling the compiled xpath\nexpression to a jsoup Evaluator when there's 1:1 support, thus saving the W3C document conversion stage.\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/NodeUtils.java.NodeUtils.[Stream<T>]stream(Node,Class<T>)",
        "name": "stream",
        "arg_nums": 2,
        "params": [
            {
                "name": "start",
                "type": "Node"
            },
            {
                "name": "type",
                "type": "Class<T>"
            }
        ],
        "return_type": "Stream<T>",
        "signature": "static <T extends Node> Stream<T> stream(Node start, Class<T> type)",
        "original_string": "    static <T extends Node> Stream<T> stream(Node start, Class<T> type) {\n        NodeIterator<T> iterator = new NodeIterator<>(start, type);\n        Spliterator<T> spliterator = spliterator(iterator);\n\n        return StreamSupport.stream(spliterator, false);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/NodeUtils.java",
        "class_name": "NodeUtils",
        "class_uri": "src/main/java/org/jsoup/nodes/NodeUtils.java.NodeUtils",
        "attributes": {
            "modifiers": "static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "static"
            ],
            "comments": [],
            "return_type": "Stream<T>",
            "classes": []
        },
        "docstring": " Creates a Stream, starting with the supplied node."
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/NodeUtils.java.NodeUtils.[Spliterator<T>]spliterator(Iterator<T>)",
        "name": "spliterator",
        "arg_nums": 1,
        "params": [
            {
                "name": "iterator",
                "type": "Iterator<T>"
            }
        ],
        "return_type": "Spliterator<T>",
        "signature": "static <T extends Node> Spliterator<T> spliterator(Iterator<T> iterator)",
        "original_string": "    static <T extends Node> Spliterator<T> spliterator(Iterator<T> iterator) {\n        return Spliterators.spliteratorUnknownSize(\n                iterator,\n                Spliterator.DISTINCT | Spliterator.NONNULL | Spliterator.ORDERED);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/NodeUtils.java",
        "class_name": "NodeUtils",
        "class_uri": "src/main/java/org/jsoup/nodes/NodeUtils.java.NodeUtils",
        "attributes": {
            "modifiers": "static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "static"
            ],
            "comments": [],
            "return_type": "Spliterator<T>",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Node.java.Node.[]Node()",
        "name": "Node",
        "arg_nums": 0,
        "params": [],
        "return_type": "",
        "signature": "protected Node()",
        "original_string": "    protected Node() {\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Node.java",
        "class_name": "Node",
        "class_uri": "src/main/java/org/jsoup/nodes/Node.java.Node",
        "attributes": {
            "modifiers": "protected",
            "marker_annotations": [],
            "non_marker_annotations": [
                "protected"
            ],
            "comments": [],
            "return_type": "",
            "classes": []
        },
        "docstring": "\nDefault constructor. Doesn't set up base uri, children, or attributes; use with caution.\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Node.java.Node.[String]nodeName()",
        "name": "nodeName",
        "arg_nums": 0,
        "params": [],
        "return_type": "String",
        "signature": "public abstract String nodeName()",
        "original_string": "    public abstract String nodeName();",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Node.java",
        "class_name": "Node",
        "class_uri": "src/main/java/org/jsoup/nodes/Node.java.Node",
        "attributes": {
            "modifiers": "public abstract",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public",
                "abstract"
            ],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": "\nGet the node name of this node. Use for debugging purposes and not logic switching (for that, use instanceof).\n@return node name\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Node.java.Node.[String]normalName()",
        "name": "normalName",
        "arg_nums": 0,
        "params": [],
        "return_type": "String",
        "signature": "public String normalName()",
        "original_string": "    public String normalName() {\n        return nodeName();\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Node.java",
        "class_name": "Node",
        "class_uri": "src/main/java/org/jsoup/nodes/Node.java.Node",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": "\nGet the normalized name of this node. For node types other than Element, this is the same as {@link #nodeName()}.\nFor an Element, will be the lower-cased tag name.\n@return normalized node name\n@since 1.15.4.\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Node.java.Node.[boolean]nameIs(String)",
        "name": "nameIs",
        "arg_nums": 1,
        "params": [
            {
                "name": "normalName",
                "type": "String"
            }
        ],
        "return_type": "boolean",
        "signature": "public boolean nameIs(String normalName)",
        "original_string": "    public boolean nameIs(String normalName) {\n        return normalName().equals(normalName);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Node.java",
        "class_name": "Node",
        "class_uri": "src/main/java/org/jsoup/nodes/Node.java.Node",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": "\nTest if this node has the specified normalized name, in any namespace.\n@param normalName a normalized element name (e.g. {@code div}).\n@return true if the element's normal name matches exactly\n@since 1.17.2\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Node.java.Node.[boolean]parentNameIs(String)",
        "name": "parentNameIs",
        "arg_nums": 1,
        "params": [
            {
                "name": "normalName",
                "type": "String"
            }
        ],
        "return_type": "boolean",
        "signature": "public boolean parentNameIs(String normalName)",
        "original_string": "    public boolean parentNameIs(String normalName) {\n        return parentNode != null && parentNode.normalName().equals(normalName);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Node.java",
        "class_name": "Node",
        "class_uri": "src/main/java/org/jsoup/nodes/Node.java.Node",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": "\nTest if this node's parent has the specified normalized name.\n@param normalName a normalized name (e.g. {@code div}).\n@return true if the parent element's normal name matches exactly\n@since 1.17.2\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Node.java.Node.[boolean]parentElementIs(String,String)",
        "name": "parentElementIs",
        "arg_nums": 2,
        "params": [
            {
                "name": "normalName",
                "type": "String"
            },
            {
                "name": "namespace",
                "type": "String"
            }
        ],
        "return_type": "boolean",
        "signature": "public boolean parentElementIs(String normalName, String namespace)",
        "original_string": "    public boolean parentElementIs(String normalName, String namespace) {\n        return parentNode != null && parentNode instanceof Element\n            && ((Element) parentNode).elementIs(normalName, namespace);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Node.java",
        "class_name": "Node",
        "class_uri": "src/main/java/org/jsoup/nodes/Node.java.Node",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": "\nTest if this node's parent is an Element with the specified normalized name and namespace.\n@param normalName a normalized element name (e.g. {@code div}).\n@param namespace the namespace\n@return true if the parent element's normal name matches exactly, and that element is in the specified namespace\n@since 1.17.2\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Node.java.Node.[boolean]hasAttributes()",
        "name": "hasAttributes",
        "arg_nums": 0,
        "params": [],
        "return_type": "boolean",
        "signature": "protected abstract boolean hasAttributes()",
        "original_string": "    protected abstract boolean hasAttributes();",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Node.java",
        "class_name": "Node",
        "class_uri": "src/main/java/org/jsoup/nodes/Node.java.Node",
        "attributes": {
            "modifiers": "protected abstract",
            "marker_annotations": [],
            "non_marker_annotations": [
                "protected",
                "abstract"
            ],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": "\nCheck if this Node has an actual Attributes object.\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Node.java.Node.[boolean]hasParent()",
        "name": "hasParent",
        "arg_nums": 0,
        "params": [],
        "return_type": "boolean",
        "signature": "public boolean hasParent()",
        "original_string": "    public boolean hasParent() {\n        return parentNode != null;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Node.java",
        "class_name": "Node",
        "class_uri": "src/main/java/org/jsoup/nodes/Node.java.Node",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": "\nChecks if this node has a parent. Nodes won't have parents if (e.g.) they are newly created and not added as a child\nto an existing node, or if they are a {@link #shallowClone()}. In such cases, {@link #parent()} will return {@code null}.\n@return if this node has a parent.\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Node.java.Node.[String]attr(String)",
        "name": "attr",
        "arg_nums": 1,
        "params": [
            {
                "name": "attributeKey",
                "type": "String"
            }
        ],
        "return_type": "String",
        "signature": "public String attr(String attributeKey)",
        "original_string": "    public String attr(String attributeKey) {\n        Validate.notNull(attributeKey);\n        if (!hasAttributes())\n            return EmptyString;\n\n        String val = attributes().getIgnoreCase(attributeKey);\n        if (val.length() > 0)\n            return val;\n        else if (attributeKey.startsWith(\"abs:\"))\n            return absUrl(attributeKey.substring(\"abs:\".length()));\n        else return \"\";\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Node.java",
        "class_name": "Node",
        "class_uri": "src/main/java/org/jsoup/nodes/Node.java.Node",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": "\nGet an attribute's value by its key. <b>Case insensitive</b>\n<p>\nTo get an absolute URL from an attribute that may be a relative URL, prefix the key with <code><b>abs:</b></code>,\nwhich is a shortcut to the {@link #absUrl} method.\n</p>\nE.g.:\n<blockquote><code>String url = a.attr(\"abs:href\");</code></blockquote>\n\n@param attributeKey The attribute key.\n@return The attribute, or empty string if not present (to avoid nulls).\n@see #attributes()\n@see #hasAttr(String)\n@see #absUrl(String)\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Node.java.Node.[Attributes]attributes()",
        "name": "attributes",
        "arg_nums": 0,
        "params": [],
        "return_type": "Attributes",
        "signature": "public abstract Attributes attributes()",
        "original_string": "    public abstract Attributes attributes();",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Node.java",
        "class_name": "Node",
        "class_uri": "src/main/java/org/jsoup/nodes/Node.java.Node",
        "attributes": {
            "modifiers": "public abstract",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public",
                "abstract"
            ],
            "comments": [],
            "return_type": "Attributes",
            "classes": []
        },
        "docstring": "\nGet each of the Element's attributes.\n@return attributes (which implements Iterable, with the same order as presented in the original HTML).\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Node.java.Node.[int]attributesSize()",
        "name": "attributesSize",
        "arg_nums": 0,
        "params": [],
        "return_type": "int",
        "signature": "public int attributesSize()",
        "original_string": "    public int attributesSize() {\n        // added so that we can test how many attributes exist without implicitly creating the Attributes object\n        return hasAttributes() ? attributes().size() : 0;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Node.java",
        "class_name": "Node",
        "class_uri": "src/main/java/org/jsoup/nodes/Node.java.Node",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "int",
            "classes": []
        },
        "docstring": "\nGet the number of attributes that this Node has.\n@return the number of attributes\n@since 1.14.2\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Node.java.Node.[Node]attr(String,String)",
        "name": "attr",
        "arg_nums": 2,
        "params": [
            {
                "name": "attributeKey",
                "type": "String"
            },
            {
                "name": "attributeValue",
                "type": "String"
            }
        ],
        "return_type": "Node",
        "signature": "public Node attr(String attributeKey, String attributeValue)",
        "original_string": "    public Node attr(String attributeKey, String attributeValue) {\n        attributeKey = NodeUtils.parser(this).settings().normalizeAttribute(attributeKey);\n        attributes().putIgnoreCase(attributeKey, attributeValue);\n        return this;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Node.java",
        "class_name": "Node",
        "class_uri": "src/main/java/org/jsoup/nodes/Node.java.Node",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Node",
            "classes": []
        },
        "docstring": "\nSet an attribute (key=value). If the attribute already exists, it is replaced. The attribute key comparison is\n<b>case insensitive</b>. The key will be set with case sensitivity as set in the parser settings.\n@param attributeKey The attribute key.\n@param attributeValue The attribute value.\n@return this (for chaining)\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Node.java.Node.[boolean]hasAttr(String)",
        "name": "hasAttr",
        "arg_nums": 1,
        "params": [
            {
                "name": "attributeKey",
                "type": "String"
            }
        ],
        "return_type": "boolean",
        "signature": "public boolean hasAttr(String attributeKey)",
        "original_string": "    public boolean hasAttr(String attributeKey) {\n        Validate.notNull(attributeKey);\n        if (!hasAttributes())\n            return false;\n\n        if (attributeKey.startsWith(\"abs:\")) {\n            String key = attributeKey.substring(\"abs:\".length());\n            if (attributes().hasKeyIgnoreCase(key) && !absUrl(key).isEmpty())\n                return true;\n        }\n        return attributes().hasKeyIgnoreCase(attributeKey);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Node.java",
        "class_name": "Node",
        "class_uri": "src/main/java/org/jsoup/nodes/Node.java.Node",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": "\nTest if this Node has an attribute. <b>Case insensitive</b>.\n@param attributeKey The attribute key to check.\n@return true if the attribute exists, false if not.\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Node.java.Node.[Node]removeAttr(String)",
        "name": "removeAttr",
        "arg_nums": 1,
        "params": [
            {
                "name": "attributeKey",
                "type": "String"
            }
        ],
        "return_type": "Node",
        "signature": "public Node removeAttr(String attributeKey)",
        "original_string": "    public Node removeAttr(String attributeKey) {\n        Validate.notNull(attributeKey);\n        if (hasAttributes())\n            attributes().removeIgnoreCase(attributeKey);\n        return this;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Node.java",
        "class_name": "Node",
        "class_uri": "src/main/java/org/jsoup/nodes/Node.java.Node",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Node",
            "classes": []
        },
        "docstring": "\nRemove an attribute from this node.\n@param attributeKey The attribute to remove.\n@return this (for chaining)\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Node.java.Node.[Node]clearAttributes()",
        "name": "clearAttributes",
        "arg_nums": 0,
        "params": [],
        "return_type": "Node",
        "signature": "public Node clearAttributes()",
        "original_string": "    public Node clearAttributes() {\n        if (hasAttributes()) {\n            Iterator<Attribute> it = attributes().iterator();\n            while (it.hasNext()) {\n                it.next();\n                it.remove();\n            }\n        }\n        return this;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Node.java",
        "class_name": "Node",
        "class_uri": "src/main/java/org/jsoup/nodes/Node.java.Node",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Node",
            "classes": []
        },
        "docstring": "\nClear (remove) each of the attributes in this node.\n@return this, for chaining\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Node.java.Node.[String]baseUri()",
        "name": "baseUri",
        "arg_nums": 0,
        "params": [],
        "return_type": "String",
        "signature": "public abstract String baseUri()",
        "original_string": "    public abstract String baseUri();",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Node.java",
        "class_name": "Node",
        "class_uri": "src/main/java/org/jsoup/nodes/Node.java.Node",
        "attributes": {
            "modifiers": "public abstract",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public",
                "abstract"
            ],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": "\nGet the base URI that applies to this node. Will return an empty string if not defined. Used to make relative links\nabsolute.\n\n@return base URI\n@see #absUrl\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Node.java.Node.[void]doSetBaseUri(String)",
        "name": "doSetBaseUri",
        "arg_nums": 1,
        "params": [
            {
                "name": "baseUri",
                "type": "String"
            }
        ],
        "return_type": "void",
        "signature": "protected abstract void doSetBaseUri(String baseUri)",
        "original_string": "    protected abstract void doSetBaseUri(String baseUri);",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Node.java",
        "class_name": "Node",
        "class_uri": "src/main/java/org/jsoup/nodes/Node.java.Node",
        "attributes": {
            "modifiers": "protected abstract",
            "marker_annotations": [],
            "non_marker_annotations": [
                "protected",
                "abstract"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": "\nSet the baseUri for just this node (not its descendants), if this Node tracks base URIs.\n@param baseUri new URI\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Node.java.Node.[void]setBaseUri(String)",
        "name": "setBaseUri",
        "arg_nums": 1,
        "params": [
            {
                "name": "baseUri",
                "type": "String"
            }
        ],
        "return_type": "void",
        "signature": "public void setBaseUri(final String baseUri)",
        "original_string": "    public void setBaseUri(final String baseUri) {\n        Validate.notNull(baseUri);\n        doSetBaseUri(baseUri);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Node.java",
        "class_name": "Node",
        "class_uri": "src/main/java/org/jsoup/nodes/Node.java.Node",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": "\nUpdate the base URI of this node and all of its descendants.\n@param baseUri base URI to set\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Node.java.Node.[String]absUrl(String)",
        "name": "absUrl",
        "arg_nums": 1,
        "params": [
            {
                "name": "attributeKey",
                "type": "String"
            }
        ],
        "return_type": "String",
        "signature": "public String absUrl(String attributeKey)",
        "original_string": "    public String absUrl(String attributeKey) {\n        Validate.notEmpty(attributeKey);\n        if (!(hasAttributes() && attributes().hasKeyIgnoreCase(attributeKey))) // not using hasAttr, so that we don't recurse down hasAttr->absUrl\n            return \"\";\n\n        return StringUtil.resolve(baseUri(), attributes().getIgnoreCase(attributeKey));\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Node.java",
        "class_name": "Node",
        "class_uri": "src/main/java/org/jsoup/nodes/Node.java.Node",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": "\nGet an absolute URL from a URL attribute that may be relative (such as an <code>&lt;a href&gt;</code> or\n<code>&lt;img src&gt;</code>).\n<p>\nE.g.: <code>String absUrl = linkEl.absUrl(\"href\");</code>\n</p>\n<p>\nIf the attribute value is already absolute (i.e. it starts with a protocol, like\n<code>http://</code> or <code>https://</code> etc), and it successfully parses as a URL, the attribute is\nreturned directly. Otherwise, it is treated as a URL relative to the element's {@link #baseUri}, and made\nabsolute using that.\n</p>\n<p>\nAs an alternate, you can use the {@link #attr} method with the <code>abs:</code> prefix, e.g.:\n<code>String absUrl = linkEl.attr(\"abs:href\");</code>\n</p>\n\n@param attributeKey The attribute key\n@return An absolute URL if one could be made, or an empty string (not null) if the attribute was missing or\ncould not be made successfully into a URL.\n@see #attr\n@see java.net.URL#URL(java.net.URL, String)\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Node.java.Node.[List<Node>]ensureChildNodes()",
        "name": "ensureChildNodes",
        "arg_nums": 0,
        "params": [],
        "return_type": "List<Node>",
        "signature": "protected abstract List<Node> ensureChildNodes()",
        "original_string": "    protected abstract List<Node> ensureChildNodes();",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Node.java",
        "class_name": "Node",
        "class_uri": "src/main/java/org/jsoup/nodes/Node.java.Node",
        "attributes": {
            "modifiers": "protected abstract",
            "marker_annotations": [],
            "non_marker_annotations": [
                "protected",
                "abstract"
            ],
            "comments": [],
            "return_type": "List<Node>",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Node.java.Node.[Node]childNode(int)",
        "name": "childNode",
        "arg_nums": 1,
        "params": [
            {
                "name": "index",
                "type": "int"
            }
        ],
        "return_type": "Node",
        "signature": "public Node childNode(int index)",
        "original_string": "    public Node childNode(int index) {\n        return ensureChildNodes().get(index);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Node.java",
        "class_name": "Node",
        "class_uri": "src/main/java/org/jsoup/nodes/Node.java.Node",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Node",
            "classes": []
        },
        "docstring": "\nGet a child node by its 0-based index.\n@param index index of child node\n@return the child node at this index.\n@throws IndexOutOfBoundsException if the index is out of bounds.\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Node.java.Node.[List<Node>]childNodes()",
        "name": "childNodes",
        "arg_nums": 0,
        "params": [],
        "return_type": "List<Node>",
        "signature": "public List<Node> childNodes()",
        "original_string": "    public List<Node> childNodes() {\n        if (childNodeSize() == 0)\n            return EmptyNodes;\n\n        List<Node> children = ensureChildNodes();\n        List<Node> rewrap = new ArrayList<>(children.size()); // wrapped so that looping and moving will not throw a CME as the source changes\n        rewrap.addAll(children);\n        return Collections.unmodifiableList(rewrap);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Node.java",
        "class_name": "Node",
        "class_uri": "src/main/java/org/jsoup/nodes/Node.java.Node",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "List<Node>",
            "classes": []
        },
        "docstring": "\nGet this node's children. Presented as an unmodifiable list: new children can not be added, but the child nodes\nthemselves can be manipulated.\n@return list of children. If no children, returns an empty list.\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Node.java.Node.[List<Node>]childNodesCopy()",
        "name": "childNodesCopy",
        "arg_nums": 0,
        "params": [],
        "return_type": "List<Node>",
        "signature": "public List<Node> childNodesCopy()",
        "original_string": "    public List<Node> childNodesCopy() {\n        final List<Node> nodes = ensureChildNodes();\n        final ArrayList<Node> children = new ArrayList<>(nodes.size());\n        for (Node node : nodes) {\n            children.add(node.clone());\n        }\n        return children;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Node.java",
        "class_name": "Node",
        "class_uri": "src/main/java/org/jsoup/nodes/Node.java.Node",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "List<Node>",
            "classes": []
        },
        "docstring": "\nReturns a deep copy of this node's children. Changes made to these nodes will not be reflected in the original\nnodes\n@return a deep copy of this node's children\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Node.java.Node.[int]childNodeSize()",
        "name": "childNodeSize",
        "arg_nums": 0,
        "params": [],
        "return_type": "int",
        "signature": "public abstract int childNodeSize()",
        "original_string": "    public abstract int childNodeSize();",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Node.java",
        "class_name": "Node",
        "class_uri": "src/main/java/org/jsoup/nodes/Node.java.Node",
        "attributes": {
            "modifiers": "public abstract",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public",
                "abstract"
            ],
            "comments": [],
            "return_type": "int",
            "classes": []
        },
        "docstring": "\nGet the number of child nodes that this node holds.\n@return the number of child nodes that this node holds.\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Node.java.Node.[Node[]]childNodesAsArray()",
        "name": "childNodesAsArray",
        "arg_nums": 0,
        "params": [],
        "return_type": "Node[]",
        "signature": "protected Node[] childNodesAsArray()",
        "original_string": "    protected Node[] childNodesAsArray() {\n        return ensureChildNodes().toArray(new Node[0]);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Node.java",
        "class_name": "Node",
        "class_uri": "src/main/java/org/jsoup/nodes/Node.java.Node",
        "attributes": {
            "modifiers": "protected",
            "marker_annotations": [],
            "non_marker_annotations": [
                "protected"
            ],
            "comments": [],
            "return_type": "Node[]",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Node.java.Node.[Node]empty()",
        "name": "empty",
        "arg_nums": 0,
        "params": [],
        "return_type": "Node",
        "signature": "public abstract Node empty()",
        "original_string": "    public abstract Node empty();",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Node.java",
        "class_name": "Node",
        "class_uri": "src/main/java/org/jsoup/nodes/Node.java.Node",
        "attributes": {
            "modifiers": "public abstract",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public",
                "abstract"
            ],
            "comments": [],
            "return_type": "Node",
            "classes": []
        },
        "docstring": "\nDelete all this node's children.\n@return this node, for chaining\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Node.java.Node.[Node]parent()",
        "name": "parent",
        "arg_nums": 0,
        "params": [],
        "return_type": "Node",
        "signature": "public @Nullable Node parent()",
        "original_string": "    public @Nullable Node parent() {\n        return parentNode;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Node.java",
        "class_name": "Node",
        "class_uri": "src/main/java/org/jsoup/nodes/Node.java.Node",
        "attributes": {
            "modifiers": "public @Nullable",
            "marker_annotations": [
                "@Nullable"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Node",
            "classes": []
        },
        "docstring": "\nGets this node's parent node.\n@return parent node; or null if no parent.\n@see #hasParent()\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Node.java.Node.[Node]parentNode()",
        "name": "parentNode",
        "arg_nums": 0,
        "params": [],
        "return_type": "Node",
        "signature": "public @Nullable final Node parentNode()",
        "original_string": "    public @Nullable final Node parentNode() {\n        return parentNode;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Node.java",
        "class_name": "Node",
        "class_uri": "src/main/java/org/jsoup/nodes/Node.java.Node",
        "attributes": {
            "modifiers": "public @Nullable final",
            "marker_annotations": [
                "@Nullable"
            ],
            "non_marker_annotations": [
                "public",
                "final"
            ],
            "comments": [],
            "return_type": "Node",
            "classes": []
        },
        "docstring": "\nGets this node's parent node. Not overridable by extending classes, so useful if you really just need the Node type.\n@return parent node; or null if no parent.\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Node.java.Node.[Node]root()",
        "name": "root",
        "arg_nums": 0,
        "params": [],
        "return_type": "Node",
        "signature": "public Node root()",
        "original_string": "    public Node root() {\n        Node node = this;\n        while (node.parentNode != null)\n            node = node.parentNode;\n        return node;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Node.java",
        "class_name": "Node",
        "class_uri": "src/main/java/org/jsoup/nodes/Node.java.Node",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Node",
            "classes": []
        },
        "docstring": "\nGet this node's root node; that is, its topmost ancestor. If this node is the top ancestor, returns {@code this}.\n@return topmost ancestor.\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Node.java.Node.[Document]ownerDocument()",
        "name": "ownerDocument",
        "arg_nums": 0,
        "params": [],
        "return_type": "Document",
        "signature": "public @Nullable Document ownerDocument()",
        "original_string": "    public @Nullable Document ownerDocument() {\n        Node root = root();\n        return (root instanceof Document) ? (Document) root : null;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Node.java",
        "class_name": "Node",
        "class_uri": "src/main/java/org/jsoup/nodes/Node.java.Node",
        "attributes": {
            "modifiers": "public @Nullable",
            "marker_annotations": [
                "@Nullable"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Document",
            "classes": []
        },
        "docstring": "\nGets the Document associated with this Node.\n@return the Document associated with this Node, or null if there is no such Document.\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Node.java.Node.[void]remove()",
        "name": "remove",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "public void remove()",
        "original_string": "    public void remove() {\n        if (parentNode != null)\n            parentNode.removeChild(this);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Node.java",
        "class_name": "Node",
        "class_uri": "src/main/java/org/jsoup/nodes/Node.java.Node",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": "\nRemove (delete) this node from the DOM tree. If this node has children, they are also removed. If this node is\nan orphan, nothing happens.\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Node.java.Node.[Node]before(String)",
        "name": "before",
        "arg_nums": 1,
        "params": [
            {
                "name": "html",
                "type": "String"
            }
        ],
        "return_type": "Node",
        "signature": "public Node before(String html)",
        "original_string": "    public Node before(String html) {\n        addSiblingHtml(siblingIndex, html);\n        return this;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Node.java",
        "class_name": "Node",
        "class_uri": "src/main/java/org/jsoup/nodes/Node.java.Node",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Node",
            "classes": []
        },
        "docstring": "\nInsert the specified HTML into the DOM before this node (as a preceding sibling).\n@param html HTML to add before this node\n@return this node, for chaining\n@see #after(String)\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Node.java.Node.[Node]before(Node)",
        "name": "before",
        "arg_nums": 1,
        "params": [
            {
                "name": "node",
                "type": "Node"
            }
        ],
        "return_type": "Node",
        "signature": "public Node before(Node node)",
        "original_string": "    public Node before(Node node) {\n        Validate.notNull(node);\n        Validate.notNull(parentNode);\n\n        // if the incoming node is a sibling of this, remove it first so siblingIndex is correct on add\n        if (node.parentNode == parentNode) node.remove();\n\n        parentNode.addChildren(siblingIndex, node);\n        return this;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Node.java",
        "class_name": "Node",
        "class_uri": "src/main/java/org/jsoup/nodes/Node.java.Node",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Node",
            "classes": []
        },
        "docstring": "\nInsert the specified node into the DOM before this node (as a preceding sibling).\n@param node to add before this node\n@return this node, for chaining\n@see #after(Node)\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Node.java.Node.[Node]after(String)",
        "name": "after",
        "arg_nums": 1,
        "params": [
            {
                "name": "html",
                "type": "String"
            }
        ],
        "return_type": "Node",
        "signature": "public Node after(String html)",
        "original_string": "    public Node after(String html) {\n        addSiblingHtml(siblingIndex + 1, html);\n        return this;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Node.java",
        "class_name": "Node",
        "class_uri": "src/main/java/org/jsoup/nodes/Node.java.Node",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Node",
            "classes": []
        },
        "docstring": "\nInsert the specified HTML into the DOM after this node (as a following sibling).\n@param html HTML to add after this node\n@return this node, for chaining\n@see #before(String)\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Node.java.Node.[Node]after(Node)",
        "name": "after",
        "arg_nums": 1,
        "params": [
            {
                "name": "node",
                "type": "Node"
            }
        ],
        "return_type": "Node",
        "signature": "public Node after(Node node)",
        "original_string": "    public Node after(Node node) {\n        Validate.notNull(node);\n        Validate.notNull(parentNode);\n\n        // if the incoming node is a sibling of this, remove it first so siblingIndex is correct on add\n        if (node.parentNode == parentNode) node.remove();\n\n        parentNode.addChildren(siblingIndex + 1, node);\n        return this;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Node.java",
        "class_name": "Node",
        "class_uri": "src/main/java/org/jsoup/nodes/Node.java.Node",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Node",
            "classes": []
        },
        "docstring": "\nInsert the specified node into the DOM after this node (as a following sibling).\n@param node to add after this node\n@return this node, for chaining\n@see #before(Node)\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Node.java.Node.[void]addSiblingHtml(int,String)",
        "name": "addSiblingHtml",
        "arg_nums": 2,
        "params": [
            {
                "name": "index",
                "type": "int"
            },
            {
                "name": "html",
                "type": "String"
            }
        ],
        "return_type": "void",
        "signature": "private void addSiblingHtml(int index, String html)",
        "original_string": "    private void addSiblingHtml(int index, String html) {\n        Validate.notNull(html);\n        Validate.notNull(parentNode);\n\n        Element context = parentNode instanceof Element ? (Element) parentNode : null;\n        List<Node> nodes = NodeUtils.parser(this).parseFragmentInput(html, context, baseUri());\n        parentNode.addChildren(index, nodes.toArray(new Node[0]));\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Node.java",
        "class_name": "Node",
        "class_uri": "src/main/java/org/jsoup/nodes/Node.java.Node",
        "attributes": {
            "modifiers": "private",
            "marker_annotations": [],
            "non_marker_annotations": [
                "private"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Node.java.Node.[Node]wrap(String)",
        "name": "wrap",
        "arg_nums": 1,
        "params": [
            {
                "name": "html",
                "type": "String"
            }
        ],
        "return_type": "Node",
        "signature": "public Node wrap(String html)",
        "original_string": "    public Node wrap(String html) {\n        Validate.notEmpty(html);\n\n        // Parse context - parent (because wrapping), this, or null\n        Element context =\n            parentNode != null && parentNode instanceof Element ? (Element) parentNode :\n                this instanceof Element ? (Element) this :\n                    null;\n        List<Node> wrapChildren = NodeUtils.parser(this).parseFragmentInput(html, context, baseUri());\n        Node wrapNode = wrapChildren.get(0);\n        if (!(wrapNode instanceof Element)) // nothing to wrap with; noop\n            return this;\n\n        Element wrap = (Element) wrapNode;\n        Element deepest = getDeepChild(wrap);\n        if (parentNode != null)\n            parentNode.replaceChild(this, wrap);\n        deepest.addChildren(this); // side effect of tricking wrapChildren to lose first\n\n        // remainder (unbalanced wrap, like <div></div><p></p> -- The <p> is remainder\n        if (wrapChildren.size() > 0) {\n            //noinspection ForLoopReplaceableByForEach (beacause it allocates an Iterator which is wasteful here)\n            for (int i = 0; i < wrapChildren.size(); i++) {\n                Node remainder = wrapChildren.get(i);\n                // if no parent, this could be the wrap node, so skip\n                if (wrap == remainder)\n                    continue;\n\n                if (remainder.parentNode != null)\n                    remainder.parentNode.removeChild(remainder);\n                wrap.after(remainder);\n            }\n        }\n        return this;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Node.java",
        "class_name": "Node",
        "class_uri": "src/main/java/org/jsoup/nodes/Node.java.Node",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Node",
            "classes": []
        },
        "docstring": "\nWrap the supplied HTML around this node.\n\n@param html HTML to wrap around this node, e.g. {@code <div class=\"head\"></div>}. Can be arbitrarily deep. If\nthe input HTML does not parse to a result starting with an Element, this will be a no-op.\n@return this node, for chaining.\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Node.java.Node.[Node]unwrap()",
        "name": "unwrap",
        "arg_nums": 0,
        "params": [],
        "return_type": "Node",
        "signature": "public @Nullable Node unwrap()",
        "original_string": "    public @Nullable Node unwrap() {\n        Validate.notNull(parentNode);\n        Node firstChild = firstChild();\n        parentNode.addChildren(siblingIndex, this.childNodesAsArray());\n        this.remove();\n\n        return firstChild;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Node.java",
        "class_name": "Node",
        "class_uri": "src/main/java/org/jsoup/nodes/Node.java.Node",
        "attributes": {
            "modifiers": "public @Nullable",
            "marker_annotations": [
                "@Nullable"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Node",
            "classes": []
        },
        "docstring": "\nRemoves this node from the DOM, and moves its children up into the node's parent. This has the effect of dropping\nthe node but keeping its children.\n<p>\nFor example, with the input html:\n</p>\n<p>{@code <div>One <span>Two <b>Three</b></span></div>}</p>\nCalling {@code element.unwrap()} on the {@code span} element will result in the html:\n<p>{@code <div>One Two <b>Three</b></div>}</p>\nand the {@code \"Two \"} {@link TextNode} being returned.\n\n@return the first child of this node, after the node has been unwrapped. @{code Null} if the node had no children.\n@see #remove()\n@see #wrap(String)\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Node.java.Node.[Element]getDeepChild(Element)",
        "name": "getDeepChild",
        "arg_nums": 1,
        "params": [
            {
                "name": "el",
                "type": "Element"
            }
        ],
        "return_type": "Element",
        "signature": "private static Element getDeepChild(Element el)",
        "original_string": "    private static Element getDeepChild(Element el) {\n        Element child = el.firstElementChild();\n        while (child != null) {\n            el = child;\n            child = child.firstElementChild();\n        }\n        return el;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Node.java",
        "class_name": "Node",
        "class_uri": "src/main/java/org/jsoup/nodes/Node.java.Node",
        "attributes": {
            "modifiers": "private static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "private",
                "static"
            ],
            "comments": [],
            "return_type": "Element",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Node.java.Node.[void]nodelistChanged()",
        "name": "nodelistChanged",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "void nodelistChanged()",
        "original_string": "    void nodelistChanged() {\n        // Element overrides this to clear its shadow children elements\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Node.java",
        "class_name": "Node",
        "class_uri": "src/main/java/org/jsoup/nodes/Node.java.Node",
        "attributes": {
            "modifiers": "",
            "marker_annotations": [],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Node.java.Node.[void]replaceWith(Node)",
        "name": "replaceWith",
        "arg_nums": 1,
        "params": [
            {
                "name": "in",
                "type": "Node"
            }
        ],
        "return_type": "void",
        "signature": "public void replaceWith(Node in)",
        "original_string": "    public void replaceWith(Node in) {\n        Validate.notNull(in);\n        Validate.notNull(parentNode);\n        parentNode.replaceChild(this, in);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Node.java",
        "class_name": "Node",
        "class_uri": "src/main/java/org/jsoup/nodes/Node.java.Node",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": "\nReplace this node in the DOM with the supplied node.\n@param in the node that will replace the existing node.\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Node.java.Node.[void]setParentNode(Node)",
        "name": "setParentNode",
        "arg_nums": 1,
        "params": [
            {
                "name": "parentNode",
                "type": "Node"
            }
        ],
        "return_type": "void",
        "signature": "protected void setParentNode(Node parentNode)",
        "original_string": "    protected void setParentNode(Node parentNode) {\n        Validate.notNull(parentNode);\n        if (this.parentNode != null)\n            this.parentNode.removeChild(this);\n        this.parentNode = parentNode;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Node.java",
        "class_name": "Node",
        "class_uri": "src/main/java/org/jsoup/nodes/Node.java.Node",
        "attributes": {
            "modifiers": "protected",
            "marker_annotations": [],
            "non_marker_annotations": [
                "protected"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Node.java.Node.[void]replaceChild(Node,Node)",
        "name": "replaceChild",
        "arg_nums": 2,
        "params": [
            {
                "name": "out",
                "type": "Node"
            },
            {
                "name": "in",
                "type": "Node"
            }
        ],
        "return_type": "void",
        "signature": "protected void replaceChild(Node out, Node in)",
        "original_string": "    protected void replaceChild(Node out, Node in) {\n        Validate.isTrue(out.parentNode == this);\n        Validate.notNull(in);\n        if (out == in) return; // no-op self replacement\n\n        if (in.parentNode != null)\n            in.parentNode.removeChild(in);\n\n        final int index = out.siblingIndex;\n        ensureChildNodes().set(index, in);\n        in.parentNode = this;\n        in.setSiblingIndex(index);\n        out.parentNode = null;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Node.java",
        "class_name": "Node",
        "class_uri": "src/main/java/org/jsoup/nodes/Node.java.Node",
        "attributes": {
            "modifiers": "protected",
            "marker_annotations": [],
            "non_marker_annotations": [
                "protected"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Node.java.Node.[void]removeChild(Node)",
        "name": "removeChild",
        "arg_nums": 1,
        "params": [
            {
                "name": "out",
                "type": "Node"
            }
        ],
        "return_type": "void",
        "signature": "protected void removeChild(Node out)",
        "original_string": "    protected void removeChild(Node out) {\n        Validate.isTrue(out.parentNode == this);\n        final int index = out.siblingIndex;\n        ensureChildNodes().remove(index);\n        reindexChildren(index);\n        out.parentNode = null;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Node.java",
        "class_name": "Node",
        "class_uri": "src/main/java/org/jsoup/nodes/Node.java.Node",
        "attributes": {
            "modifiers": "protected",
            "marker_annotations": [],
            "non_marker_annotations": [
                "protected"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Node.java.Node.[void]addChildren()",
        "name": "addChildren",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "protected void addChildren(Node... children)",
        "original_string": "    protected void addChildren(Node... children) {\n        //most used. short circuit addChildren(int), which hits reindex children and array copy\n        final List<Node> nodes = ensureChildNodes();\n\n        for (Node child: children) {\n            reparentChild(child);\n            nodes.add(child);\n            child.setSiblingIndex(nodes.size()-1);\n        }\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Node.java",
        "class_name": "Node",
        "class_uri": "src/main/java/org/jsoup/nodes/Node.java.Node",
        "attributes": {
            "modifiers": "protected",
            "marker_annotations": [],
            "non_marker_annotations": [
                "protected"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Node.java.Node.[void]addChildren(int)",
        "name": "addChildren",
        "arg_nums": 1,
        "params": [
            {
                "name": "index",
                "type": "int"
            }
        ],
        "return_type": "void",
        "signature": "protected void addChildren(int index, Node... children)",
        "original_string": "    protected void addChildren(int index, Node... children) {\n        Validate.notNull(children);\n        if (children.length == 0) {\n            return;\n        }\n        final List<Node> nodes = ensureChildNodes();\n\n        // fast path - if used as a wrap (index=0, children = child[0].parent.children - do inplace\n        final Node firstParent = children[0].parent();\n        if (firstParent != null && firstParent.childNodeSize() == children.length) {\n            boolean sameList = true;\n            final List<Node> firstParentNodes = firstParent.ensureChildNodes();\n            // identity check contents to see if same\n            int i = children.length;\n            while (i-- > 0) {\n                if (children[i] != firstParentNodes.get(i)) {\n                    sameList = false;\n                    break;\n                }\n            }\n            if (sameList) { // moving, so OK to empty firstParent and short-circuit\n                boolean wasEmpty = childNodeSize() == 0;\n                firstParent.empty();\n                nodes.addAll(index, Arrays.asList(children));\n                i = children.length;\n                while (i-- > 0) {\n                    children[i].parentNode = this;\n                }\n                if (!(wasEmpty && children[0].siblingIndex == 0)) // skip reindexing if we just moved\n                    reindexChildren(index);\n                return;\n            }\n        }\n\n        Validate.noNullElements(children);\n        for (Node child : children) {\n            reparentChild(child);\n        }\n        nodes.addAll(index, Arrays.asList(children));\n        reindexChildren(index);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Node.java",
        "class_name": "Node",
        "class_uri": "src/main/java/org/jsoup/nodes/Node.java.Node",
        "attributes": {
            "modifiers": "protected",
            "marker_annotations": [],
            "non_marker_annotations": [
                "protected"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Node.java.Node.[void]reparentChild(Node)",
        "name": "reparentChild",
        "arg_nums": 1,
        "params": [
            {
                "name": "child",
                "type": "Node"
            }
        ],
        "return_type": "void",
        "signature": "protected void reparentChild(Node child)",
        "original_string": "    protected void reparentChild(Node child) {\n        child.setParentNode(this);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Node.java",
        "class_name": "Node",
        "class_uri": "src/main/java/org/jsoup/nodes/Node.java.Node",
        "attributes": {
            "modifiers": "protected",
            "marker_annotations": [],
            "non_marker_annotations": [
                "protected"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Node.java.Node.[void]reindexChildren(int)",
        "name": "reindexChildren",
        "arg_nums": 1,
        "params": [
            {
                "name": "start",
                "type": "int"
            }
        ],
        "return_type": "void",
        "signature": "private void reindexChildren(int start)",
        "original_string": "    private void reindexChildren(int start) {\n        final int size = childNodeSize();\n        if (size == 0) return;\n        final List<Node> childNodes = ensureChildNodes();\n        for (int i = start; i < size; i++) {\n            childNodes.get(i).setSiblingIndex(i);\n        }\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Node.java",
        "class_name": "Node",
        "class_uri": "src/main/java/org/jsoup/nodes/Node.java.Node",
        "attributes": {
            "modifiers": "private",
            "marker_annotations": [],
            "non_marker_annotations": [
                "private"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Node.java.Node.[List<Node>]siblingNodes()",
        "name": "siblingNodes",
        "arg_nums": 0,
        "params": [],
        "return_type": "List<Node>",
        "signature": "public List<Node> siblingNodes()",
        "original_string": "    public List<Node> siblingNodes() {\n        if (parentNode == null)\n            return Collections.emptyList();\n\n        List<Node> nodes = parentNode.ensureChildNodes();\n        List<Node> siblings = new ArrayList<>(nodes.size() - 1);\n        for (Node node: nodes)\n            if (node != this)\n                siblings.add(node);\n        return siblings;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Node.java",
        "class_name": "Node",
        "class_uri": "src/main/java/org/jsoup/nodes/Node.java.Node",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "List<Node>",
            "classes": []
        },
        "docstring": "\nRetrieves this node's sibling nodes. Similar to {@link #childNodes() node.parent.childNodes()}, but does not\ninclude this node (a node is not a sibling of itself).\n@return node siblings. If the node has no parent, returns an empty list.\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Node.java.Node.[Node]nextSibling()",
        "name": "nextSibling",
        "arg_nums": 0,
        "params": [],
        "return_type": "Node",
        "signature": "public @Nullable Node nextSibling()",
        "original_string": "    public @Nullable Node nextSibling() {\n        if (parentNode == null)\n            return null; // root\n\n        final List<Node> siblings = parentNode.ensureChildNodes();\n        final int index = siblingIndex+1;\n        if (siblings.size() > index)\n            return siblings.get(index);\n        else\n            return null;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Node.java",
        "class_name": "Node",
        "class_uri": "src/main/java/org/jsoup/nodes/Node.java.Node",
        "attributes": {
            "modifiers": "public @Nullable",
            "marker_annotations": [
                "@Nullable"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Node",
            "classes": []
        },
        "docstring": "\nGet this node's next sibling.\n@return next sibling, or {@code null} if this is the last sibling\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Node.java.Node.[Node]previousSibling()",
        "name": "previousSibling",
        "arg_nums": 0,
        "params": [],
        "return_type": "Node",
        "signature": "public @Nullable Node previousSibling()",
        "original_string": "    public @Nullable Node previousSibling() {\n        if (parentNode == null)\n            return null; // root\n\n        if (siblingIndex > 0)\n            return parentNode.ensureChildNodes().get(siblingIndex-1);\n        else\n            return null;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Node.java",
        "class_name": "Node",
        "class_uri": "src/main/java/org/jsoup/nodes/Node.java.Node",
        "attributes": {
            "modifiers": "public @Nullable",
            "marker_annotations": [
                "@Nullable"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Node",
            "classes": []
        },
        "docstring": "\nGet this node's previous sibling.\n@return the previous sibling, or @{code null} if this is the first sibling\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Node.java.Node.[int]siblingIndex()",
        "name": "siblingIndex",
        "arg_nums": 0,
        "params": [],
        "return_type": "int",
        "signature": "public int siblingIndex()",
        "original_string": "    public int siblingIndex() {\n        return siblingIndex;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Node.java",
        "class_name": "Node",
        "class_uri": "src/main/java/org/jsoup/nodes/Node.java.Node",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "int",
            "classes": []
        },
        "docstring": "\nGet the list index of this node in its node sibling list. E.g. if this is the first node\nsibling, returns 0.\n@return position in node sibling list\n@see org.jsoup.nodes.Element#elementSiblingIndex()\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Node.java.Node.[void]setSiblingIndex(int)",
        "name": "setSiblingIndex",
        "arg_nums": 1,
        "params": [
            {
                "name": "siblingIndex",
                "type": "int"
            }
        ],
        "return_type": "void",
        "signature": "protected void setSiblingIndex(int siblingIndex)",
        "original_string": "    protected void setSiblingIndex(int siblingIndex) {\n        this.siblingIndex = siblingIndex;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Node.java",
        "class_name": "Node",
        "class_uri": "src/main/java/org/jsoup/nodes/Node.java.Node",
        "attributes": {
            "modifiers": "protected",
            "marker_annotations": [],
            "non_marker_annotations": [
                "protected"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Node.java.Node.[Node]firstChild()",
        "name": "firstChild",
        "arg_nums": 0,
        "params": [],
        "return_type": "Node",
        "signature": "public @Nullable Node firstChild()",
        "original_string": "    public @Nullable Node firstChild() {\n        if (childNodeSize() == 0) return null;\n        return ensureChildNodes().get(0);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Node.java",
        "class_name": "Node",
        "class_uri": "src/main/java/org/jsoup/nodes/Node.java.Node",
        "attributes": {
            "modifiers": "public @Nullable",
            "marker_annotations": [
                "@Nullable"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Node",
            "classes": []
        },
        "docstring": "\nGets the first child node of this node, or {@code null} if there is none. This could be any Node type, such as an\nElement, TextNode, Comment, etc. Use {@link Element#firstElementChild()} to get the first Element child.\n@return the first child node, or null if there are no children.\n@see Element#firstElementChild()\n@see #lastChild()\n@since 1.15.2\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Node.java.Node.[Node]lastChild()",
        "name": "lastChild",
        "arg_nums": 0,
        "params": [],
        "return_type": "Node",
        "signature": "public @Nullable Node lastChild()",
        "original_string": "    public @Nullable Node lastChild() {\n        final int size = childNodeSize();\n        if (size == 0) return null;\n        List<Node> children = ensureChildNodes();\n        return children.get(size - 1);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Node.java",
        "class_name": "Node",
        "class_uri": "src/main/java/org/jsoup/nodes/Node.java.Node",
        "attributes": {
            "modifiers": "public @Nullable",
            "marker_annotations": [
                "@Nullable"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Node",
            "classes": []
        },
        "docstring": "\nGets the last child node of this node, or {@code null} if there is none.\n@return the last child node, or null if there are no children.\n@see Element#lastElementChild()\n@see #firstChild()\n@since 1.15.2\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Node.java.Node.[Node]traverse(NodeVisitor)",
        "name": "traverse",
        "arg_nums": 1,
        "params": [
            {
                "name": "nodeVisitor",
                "type": "NodeVisitor"
            }
        ],
        "return_type": "Node",
        "signature": "public Node traverse(NodeVisitor nodeVisitor)",
        "original_string": "    public Node traverse(NodeVisitor nodeVisitor) {\n        Validate.notNull(nodeVisitor);\n        NodeTraversor.traverse(nodeVisitor, this);\n        return this;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Node.java",
        "class_name": "Node",
        "class_uri": "src/main/java/org/jsoup/nodes/Node.java.Node",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Node",
            "classes": []
        },
        "docstring": "\nPerform a depth-first traversal through this node and its descendants.\n@param nodeVisitor the visitor callbacks to perform on each node\n@return this node, for chaining\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Node.java.Node.[Node]forEachNode(Consumer<? super Node>)",
        "name": "forEachNode",
        "arg_nums": 1,
        "params": [
            {
                "name": "action",
                "type": "Consumer<? super Node>"
            }
        ],
        "return_type": "Node",
        "signature": "public Node forEachNode(Consumer<? super Node> action)",
        "original_string": "    public Node forEachNode(Consumer<? super Node> action) {\n        Validate.notNull(action);\n        nodeStream().forEach(action);\n        return this;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Node.java",
        "class_name": "Node",
        "class_uri": "src/main/java/org/jsoup/nodes/Node.java.Node",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Node",
            "classes": []
        },
        "docstring": "\nPerform the supplied action on this Node and each of its descendants, during a depth-first traversal. Nodes may be\ninspected, changed, added, replaced, or removed.\n@param action the function to perform on the node\n@return this Node, for chaining\n@see Element#forEach(Consumer)\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Node.java.Node.[Node]filter(NodeFilter)",
        "name": "filter",
        "arg_nums": 1,
        "params": [
            {
                "name": "nodeFilter",
                "type": "NodeFilter"
            }
        ],
        "return_type": "Node",
        "signature": "public Node filter(NodeFilter nodeFilter)",
        "original_string": "    public Node filter(NodeFilter nodeFilter) {\n        Validate.notNull(nodeFilter);\n        NodeTraversor.filter(nodeFilter, this);\n        return this;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Node.java",
        "class_name": "Node",
        "class_uri": "src/main/java/org/jsoup/nodes/Node.java.Node",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Node",
            "classes": []
        },
        "docstring": "\nPerform a depth-first filtered traversal through this node and its descendants.\n@param nodeFilter the filter callbacks to perform on each node\n@return this node, for chaining\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Node.java.Node.[Stream<Node>]nodeStream()",
        "name": "nodeStream",
        "arg_nums": 0,
        "params": [],
        "return_type": "Stream<Node>",
        "signature": "public Stream<Node> nodeStream()",
        "original_string": "    public Stream<Node> nodeStream() {\n        return NodeUtils.stream(this, Node.class);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Node.java",
        "class_name": "Node",
        "class_uri": "src/main/java/org/jsoup/nodes/Node.java.Node",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Stream<Node>",
            "classes": []
        },
        "docstring": "\nReturns a Stream of this Node and all of its descendant Nodes. The stream has document order.\n@return a stream of all nodes.\n@see Element#stream()\n@since 1.17.1\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Node.java.Node.[Stream<T>]nodeStream(Class<T>)",
        "name": "nodeStream",
        "arg_nums": 1,
        "params": [
            {
                "name": "type",
                "type": "Class<T>"
            }
        ],
        "return_type": "Stream<T>",
        "signature": "public <T extends Node> Stream<T> nodeStream(Class<T> type)",
        "original_string": "    public <T extends Node> Stream<T> nodeStream(Class<T> type) {\n        return NodeUtils.stream(this, type);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Node.java",
        "class_name": "Node",
        "class_uri": "src/main/java/org/jsoup/nodes/Node.java.Node",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Stream<T>",
            "classes": []
        },
        "docstring": "\nReturns a Stream of this and descendant nodes, containing only nodes of the specified type. The stream has document\norder.\n@return a stream of nodes filtered by type.\n@see Element#stream()\n@since 1.17.1\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Node.java.Node.[String]outerHtml()",
        "name": "outerHtml",
        "arg_nums": 0,
        "params": [],
        "return_type": "String",
        "signature": "public String outerHtml()",
        "original_string": "    public String outerHtml() {\n        StringBuilder accum = StringUtil.borrowBuilder();\n        outerHtml(accum);\n        return StringUtil.releaseBuilder(accum);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Node.java",
        "class_name": "Node",
        "class_uri": "src/main/java/org/jsoup/nodes/Node.java.Node",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": "\nGet the outer HTML of this node. For example, on a {@code p} element, may return {@code <p>Para</p>}.\n@return outer HTML\n@see Element#html()\n@see Element#text()\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Node.java.Node.[void]outerHtml(Appendable)",
        "name": "outerHtml",
        "arg_nums": 1,
        "params": [
            {
                "name": "accum",
                "type": "Appendable"
            }
        ],
        "return_type": "void",
        "signature": "protected void outerHtml(Appendable accum)",
        "original_string": "    protected void outerHtml(Appendable accum) {\n        NodeTraversor.traverse(new OuterHtmlVisitor(accum, NodeUtils.outputSettings(this)), this);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Node.java",
        "class_name": "Node",
        "class_uri": "src/main/java/org/jsoup/nodes/Node.java.Node",
        "attributes": {
            "modifiers": "protected",
            "marker_annotations": [],
            "non_marker_annotations": [
                "protected"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Node.java.Node.[void]outerHtmlHead(Appendable,int,Document.OutputSettings)",
        "name": "outerHtmlHead",
        "arg_nums": 3,
        "params": [
            {
                "name": "accum",
                "type": "Appendable"
            },
            {
                "name": "depth",
                "type": "int"
            },
            {
                "name": "out",
                "type": "Document.OutputSettings"
            }
        ],
        "return_type": "void",
        "signature": "abstract void outerHtmlHead(final Appendable accum, int depth, final Document.OutputSettings out)",
        "original_string": "    abstract void outerHtmlHead(final Appendable accum, int depth, final Document.OutputSettings out) throws IOException;",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Node.java",
        "class_name": "Node",
        "class_uri": "src/main/java/org/jsoup/nodes/Node.java.Node",
        "attributes": {
            "modifiers": "abstract",
            "marker_annotations": [],
            "non_marker_annotations": [
                "abstract"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": "\nGet the outer HTML of this node.\n@param accum accumulator to place HTML into\n@throws IOException if appending to the given accumulator fails.\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Node.java.Node.[void]outerHtmlTail(Appendable,int,Document.OutputSettings)",
        "name": "outerHtmlTail",
        "arg_nums": 3,
        "params": [
            {
                "name": "accum",
                "type": "Appendable"
            },
            {
                "name": "depth",
                "type": "int"
            },
            {
                "name": "out",
                "type": "Document.OutputSettings"
            }
        ],
        "return_type": "void",
        "signature": "abstract void outerHtmlTail(final Appendable accum, int depth, final Document.OutputSettings out)",
        "original_string": "    abstract void outerHtmlTail(final Appendable accum, int depth, final Document.OutputSettings out) throws IOException;",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Node.java",
        "class_name": "Node",
        "class_uri": "src/main/java/org/jsoup/nodes/Node.java.Node",
        "attributes": {
            "modifiers": "abstract",
            "marker_annotations": [],
            "non_marker_annotations": [
                "abstract"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Node.java.Node.[T]html(T)",
        "name": "html",
        "arg_nums": 1,
        "params": [
            {
                "name": "appendable",
                "type": "T"
            }
        ],
        "return_type": "T",
        "signature": "public <T extends Appendable> T html(T appendable)",
        "original_string": "    public <T extends Appendable> T html(T appendable) {\n        outerHtml(appendable);\n        return appendable;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Node.java",
        "class_name": "Node",
        "class_uri": "src/main/java/org/jsoup/nodes/Node.java.Node",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "T",
            "classes": []
        },
        "docstring": "\nWrite this node and its children to the given {@link Appendable}.\n\n@param appendable the {@link Appendable} to write to.\n@return the supplied {@link Appendable}, for chaining.\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Node.java.Node.[Range]sourceRange()",
        "name": "sourceRange",
        "arg_nums": 0,
        "params": [],
        "return_type": "Range",
        "signature": "public Range sourceRange()",
        "original_string": "    public Range sourceRange() {\n        return Range.of(this, true);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Node.java",
        "class_name": "Node",
        "class_uri": "src/main/java/org/jsoup/nodes/Node.java.Node",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Range",
            "classes": []
        },
        "docstring": "\nGet the source range (start and end positions) in the original input source from which this node was parsed.\nPosition tracking must be enabled prior to parsing the content. For an Element, this will be the positions of the\nstart tag.\n@return the range for the start of the node, or {@code untracked} if its range was not tracked.\n@see org.jsoup.parser.Parser#setTrackPosition(boolean)\n@see Range#isImplicit()\n@see Element#endSourceRange()\n@see Attributes#sourceRange(String name)\n@since 1.15.2\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Node.java.Node.[boolean]isEffectivelyFirst()",
        "name": "isEffectivelyFirst",
        "arg_nums": 0,
        "params": [],
        "return_type": "boolean",
        "signature": "final boolean isEffectivelyFirst()",
        "original_string": "    final boolean isEffectivelyFirst() {\n        if (siblingIndex == 0) return true;\n        if (siblingIndex == 1) {\n            final Node prev = previousSibling();\n            return prev instanceof TextNode && (((TextNode) prev).isBlank());\n        }\n        return false;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Node.java",
        "class_name": "Node",
        "class_uri": "src/main/java/org/jsoup/nodes/Node.java.Node",
        "attributes": {
            "modifiers": "final",
            "marker_annotations": [],
            "non_marker_annotations": [
                "final"
            ],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": " Test if this node is the first child, or first following blank text."
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Node.java.Node.[String]toString()",
        "name": "toString",
        "arg_nums": 0,
        "params": [],
        "return_type": "String",
        "signature": "public String toString()",
        "original_string": " public String toString() {\n        return outerHtml();\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Node.java",
        "class_name": "Node",
        "class_uri": "src/main/java/org/jsoup/nodes/Node.java.Node",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": "\nGets this node's outer HTML.\n@return outer HTML.\n@see #outerHtml()\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Node.java.Node.[void]indent(Appendable,int,Document.OutputSettings)",
        "name": "indent",
        "arg_nums": 3,
        "params": [
            {
                "name": "accum",
                "type": "Appendable"
            },
            {
                "name": "depth",
                "type": "int"
            },
            {
                "name": "out",
                "type": "Document.OutputSettings"
            }
        ],
        "return_type": "void",
        "signature": "protected void indent(Appendable accum, int depth, Document.OutputSettings out)",
        "original_string": "    protected void indent(Appendable accum, int depth, Document.OutputSettings out) throws IOException {\n        accum.append('\\n').append(StringUtil.padding(depth * out.indentAmount(), out.maxPaddingWidth()));\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Node.java",
        "class_name": "Node",
        "class_uri": "src/main/java/org/jsoup/nodes/Node.java.Node",
        "attributes": {
            "modifiers": "protected",
            "marker_annotations": [],
            "non_marker_annotations": [
                "protected"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Node.java.Node.[boolean]equals(Object)",
        "name": "equals",
        "arg_nums": 1,
        "params": [
            {
                "name": "o",
                "type": "Object"
            }
        ],
        "return_type": "boolean",
        "signature": "@Override\n    public boolean equals(@Nullable Object o)",
        "original_string": "    @Override\n    public boolean equals(@Nullable Object o) {\n        // implemented just so that javadoc is clear this is an identity test\n        return this == o;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Node.java",
        "class_name": "Node",
        "class_uri": "src/main/java/org/jsoup/nodes/Node.java.Node",
        "attributes": {
            "modifiers": "@Override\n    public",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": "\nCheck if this node is the same instance of another (object identity test).\n<p>For an node value equality check, see {@link #hasSameValue(Object)}</p>\n@param o other object to compare to\n@return true if the content of this node is the same as the other\n@see Node#hasSameValue(Object)\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Node.java.Node.[int]hashCode()",
        "name": "hashCode",
        "arg_nums": 0,
        "params": [],
        "return_type": "int",
        "signature": "@Override\n    public int hashCode()",
        "original_string": "    @Override\n    public int hashCode() {\n        // implemented so that javadoc and scanners are clear this is an identity test\n        return super.hashCode();\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Node.java",
        "class_name": "Node",
        "class_uri": "src/main/java/org/jsoup/nodes/Node.java.Node",
        "attributes": {
            "modifiers": "@Override\n    public",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "int",
            "classes": []
        },
        "docstring": "\nProvides a hashCode for this Node, based on its object identity. Changes to the Node's content will not impact the\nresult.\n@return an object identity based hashcode for this Node\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Node.java.Node.[boolean]hasSameValue(Object)",
        "name": "hasSameValue",
        "arg_nums": 1,
        "params": [
            {
                "name": "o",
                "type": "Object"
            }
        ],
        "return_type": "boolean",
        "signature": "public boolean hasSameValue(@Nullable Object o)",
        "original_string": "    public boolean hasSameValue(@Nullable Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n\n        return this.outerHtml().equals(((Node) o).outerHtml());\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Node.java",
        "class_name": "Node",
        "class_uri": "src/main/java/org/jsoup/nodes/Node.java.Node",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": "\nCheck if this node has the same content as another node. A node is considered the same if its name, attributes and content match the\nother node; particularly its position in the tree does not influence its similarity.\n@param o other object to compare to\n@return true if the content of this node is the same as the other\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Node.java.Node.[Node]clone()",
        "name": "clone",
        "arg_nums": 0,
        "params": [],
        "return_type": "Node",
        "signature": "@SuppressWarnings(\"MethodDoesntCallSuperMethod\") // because it does call super.clone in doClone - analysis just isn't following\n    @Override\n    public Node clone()",
        "original_string": "    @SuppressWarnings(\"MethodDoesntCallSuperMethod\") // because it does call super.clone in doClone - analysis just isn't following\n    @Override\n    public Node clone() {\n        Node thisClone = doClone(null); // splits for orphan\n\n        // Queue up nodes that need their children cloned (BFS).\n        final LinkedList<Node> nodesToProcess = new LinkedList<>();\n        nodesToProcess.add(thisClone);\n\n        while (!nodesToProcess.isEmpty()) {\n            Node currParent = nodesToProcess.remove();\n\n            final int size = currParent.childNodeSize();\n            for (int i = 0; i < size; i++) {\n                final List<Node> childNodes = currParent.ensureChildNodes();\n                Node childClone = childNodes.get(i).doClone(currParent);\n                childNodes.set(i, childClone);\n                nodesToProcess.add(childClone);\n            }\n        }\n\n        return thisClone;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Node.java",
        "class_name": "Node",
        "class_uri": "src/main/java/org/jsoup/nodes/Node.java.Node",
        "attributes": {
            "modifiers": "@SuppressWarnings(\"MethodDoesntCallSuperMethod\") // because it does call super.clone in doClone - analysis just isn't following\n    @Override\n    public",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "@SuppressWarnings(\"MethodDoesntCallSuperMethod\")",
                "public"
            ],
            "comments": [
                "// because it does call super.clone in doClone - analysis just isn't following"
            ],
            "return_type": "Node",
            "classes": []
        },
        "docstring": "\nCreate a stand-alone, deep copy of this node, and all of its children. The cloned node will have no siblings or\nparent node. As a stand-alone object, any changes made to the clone or any of its children will not impact the\noriginal node.\n<p>\nThe cloned node may be adopted into another Document or node structure using {@link Element#appendChild(Node)}.\n@return a stand-alone cloned node, including clones of any children\n@see #shallowClone()\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Node.java.Node.[Node]shallowClone()",
        "name": "shallowClone",
        "arg_nums": 0,
        "params": [],
        "return_type": "Node",
        "signature": "public Node shallowClone()",
        "original_string": "    public Node shallowClone() {\n        return doClone(null);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Node.java",
        "class_name": "Node",
        "class_uri": "src/main/java/org/jsoup/nodes/Node.java.Node",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "Node",
            "classes": []
        },
        "docstring": "\nCreate a stand-alone, shallow copy of this node. None of its children (if any) will be cloned, and it will have\nno parent or sibling nodes.\n@return a single independent copy of this node\n@see #clone()\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/Node.java.Node.[Node]doClone(Node)",
        "name": "doClone",
        "arg_nums": 1,
        "params": [
            {
                "name": "parent",
                "type": "Node"
            }
        ],
        "return_type": "Node",
        "signature": "protected Node doClone(@Nullable Node parent)",
        "original_string": "    protected Node doClone(@Nullable Node parent) {\n        Node clone;\n\n        try {\n            clone = (Node) super.clone();\n        } catch (CloneNotSupportedException e) {\n            throw new RuntimeException(e);\n        }\n\n        clone.parentNode = parent; // can be null, to create an orphan split\n        clone.siblingIndex = parent == null ? 0 : siblingIndex;\n        // if not keeping the parent, shallowClone the ownerDocument to preserve its settings\n        if (parent == null && !(this instanceof Document)) {\n            Document doc = ownerDocument();\n            if (doc != null) {\n                Document docClone = doc.shallowClone();\n                clone.parentNode = docClone;\n                docClone.ensureChildNodes().add(clone);\n            }\n        }\n\n        return clone;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/Node.java",
        "class_name": "Node",
        "class_uri": "src/main/java/org/jsoup/nodes/Node.java.Node",
        "attributes": {
            "modifiers": "protected",
            "marker_annotations": [],
            "non_marker_annotations": [
                "protected"
            ],
            "comments": [],
            "return_type": "Node",
            "classes": []
        },
        "docstring": "\nReturn a clone of the node using the given parent (which can be null).\nNot a deep copy of children.\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/DataNode.java.DataNode.[]DataNode(String)",
        "name": "DataNode",
        "arg_nums": 1,
        "params": [
            {
                "name": "data",
                "type": "String"
            }
        ],
        "return_type": "",
        "signature": "public DataNode(String data)",
        "original_string": "    public DataNode(String data) {\n        super(data);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/DataNode.java",
        "class_name": "DataNode",
        "class_uri": "src/main/java/org/jsoup/nodes/DataNode.java.DataNode",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "",
            "classes": []
        },
        "docstring": "\nCreate a new DataNode.\n@param data data contents\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/DataNode.java.DataNode.[String]nodeName()",
        "name": "nodeName",
        "arg_nums": 0,
        "params": [],
        "return_type": "String",
        "signature": "@Override public String nodeName()",
        "original_string": "    @Override public String nodeName() {\n        return \"#data\";\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/DataNode.java",
        "class_name": "DataNode",
        "class_uri": "src/main/java/org/jsoup/nodes/DataNode.java.DataNode",
        "attributes": {
            "modifiers": "@Override public",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/DataNode.java.DataNode.[String]getWholeData()",
        "name": "getWholeData",
        "arg_nums": 0,
        "params": [],
        "return_type": "String",
        "signature": "public String getWholeData()",
        "original_string": "    public String getWholeData() {\n        return coreValue();\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/DataNode.java",
        "class_name": "DataNode",
        "class_uri": "src/main/java/org/jsoup/nodes/DataNode.java.DataNode",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": "\nGet the data contents of this node. Will be unescaped and with original new lines, space etc.\n@return data\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/DataNode.java.DataNode.[DataNode]setWholeData(String)",
        "name": "setWholeData",
        "arg_nums": 1,
        "params": [
            {
                "name": "data",
                "type": "String"
            }
        ],
        "return_type": "DataNode",
        "signature": "public DataNode setWholeData(String data)",
        "original_string": "    public DataNode setWholeData(String data) {\n        coreValue(data);\n        return this;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/DataNode.java",
        "class_name": "DataNode",
        "class_uri": "src/main/java/org/jsoup/nodes/DataNode.java.DataNode",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "DataNode",
            "classes": []
        },
        "docstring": "\nSet the data contents of this node.\n@param data un-encoded data\n@return this node, for chaining\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/DataNode.java.DataNode.[void]outerHtmlHead(Appendable,int,Document.OutputSettings)",
        "name": "outerHtmlHead",
        "arg_nums": 3,
        "params": [
            {
                "name": "accum",
                "type": "Appendable"
            },
            {
                "name": "depth",
                "type": "int"
            },
            {
                "name": "out",
                "type": "Document.OutputSettings"
            }
        ],
        "return_type": "void",
        "signature": "@Override\n    void outerHtmlHead(Appendable accum, int depth, Document.OutputSettings out)",
        "original_string": "    @Override\n    void outerHtmlHead(Appendable accum, int depth, Document.OutputSettings out) throws IOException {\n        /* For XML output, escape the DataNode in a CData section. The data may contain pseudo-CData content if it was\n        parsed as HTML, so don't double up Cdata. Output in polyglot HTML / XHTML / XML format. */\n        final String data = getWholeData();\n        if (out.syntax() == Document.OutputSettings.Syntax.xml && !data.contains(\"<![CDATA[\")) {\n            if (parentNameIs(\"script\"))\n                accum.append(\"//<![CDATA[\\n\").append(data).append(\"\\n//]]>\");\n            else if (parentNameIs(\"style\"))\n                accum.append(\"/*<![CDATA[*/\\n\").append(data).append(\"\\n/*]]>*/\");\n            else\n                accum.append(\"<![CDATA[\").append(data).append(\"]]>\");\n        } else {\n            // In HTML, data is not escaped in the output of data nodes, so < and & in script, style is OK\n            accum.append(getWholeData());\n        }\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/DataNode.java",
        "class_name": "DataNode",
        "class_uri": "src/main/java/org/jsoup/nodes/DataNode.java.DataNode",
        "attributes": {
            "modifiers": "@Override",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/DataNode.java.DataNode.[void]outerHtmlTail(Appendable,int,Document.OutputSettings)",
        "name": "outerHtmlTail",
        "arg_nums": 3,
        "params": [
            {
                "name": "accum",
                "type": "Appendable"
            },
            {
                "name": "depth",
                "type": "int"
            },
            {
                "name": "out",
                "type": "Document.OutputSettings"
            }
        ],
        "return_type": "void",
        "signature": "@Override\n    void outerHtmlTail(Appendable accum, int depth, Document.OutputSettings out)",
        "original_string": "    @Override\n    void outerHtmlTail(Appendable accum, int depth, Document.OutputSettings out) {}",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/DataNode.java",
        "class_name": "DataNode",
        "class_uri": "src/main/java/org/jsoup/nodes/DataNode.java.DataNode",
        "attributes": {
            "modifiers": "@Override",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/DataNode.java.DataNode.[DataNode]clone()",
        "name": "clone",
        "arg_nums": 0,
        "params": [],
        "return_type": "DataNode",
        "signature": "@Override\n    public DataNode clone()",
        "original_string": "    @Override\n    public DataNode clone() {\n        return (DataNode) super.clone();\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/DataNode.java",
        "class_name": "DataNode",
        "class_uri": "src/main/java/org/jsoup/nodes/DataNode.java.DataNode",
        "attributes": {
            "modifiers": "@Override\n    public",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "DataNode",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/NodeIterator.java.NodeIterator.[]NodeIterator(Node,Class<T>)",
        "name": "NodeIterator",
        "arg_nums": 2,
        "params": [
            {
                "name": "start",
                "type": "Node"
            },
            {
                "name": "type",
                "type": "Class<T>"
            }
        ],
        "return_type": "",
        "signature": "public NodeIterator(Node start, Class<T> type)",
        "original_string": "    public NodeIterator(Node start, Class<T> type) {\n        Validate.notNull(start);\n        Validate.notNull(type);\n        this.type = type;\n\n        restart(start);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/NodeIterator.java",
        "class_name": "NodeIterator",
        "class_uri": "src/main/java/org/jsoup/nodes/NodeIterator.java.NodeIterator",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "",
            "classes": []
        },
        "docstring": "\nCreate a NoteIterator that will iterate the supplied node, and all of its descendants. The returned {@link #next}\ntype will be filtered to the input type.\n@param start initial node\n@param type node type to filter for\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/NodeIterator.java.NodeIterator.[NodeIterator<Node>]from(Node)",
        "name": "from",
        "arg_nums": 1,
        "params": [
            {
                "name": "start",
                "type": "Node"
            }
        ],
        "return_type": "NodeIterator<Node>",
        "signature": "public static NodeIterator<Node> from(Node start)",
        "original_string": "    public static NodeIterator<Node> from(Node start) {\n        return new NodeIterator<>(start, Node.class);\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/NodeIterator.java",
        "class_name": "NodeIterator",
        "class_uri": "src/main/java/org/jsoup/nodes/NodeIterator.java.NodeIterator",
        "attributes": {
            "modifiers": "public static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public",
                "static"
            ],
            "comments": [],
            "return_type": "NodeIterator<Node>",
            "classes": []
        },
        "docstring": "\nCreate a NoteIterator that will iterate the supplied node, and all of its descendants. All node types will be\nreturned.\n@param start initial node\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/NodeIterator.java.NodeIterator.[void]restart(Node)",
        "name": "restart",
        "arg_nums": 1,
        "params": [
            {
                "name": "start",
                "type": "Node"
            }
        ],
        "return_type": "void",
        "signature": "public void restart(Node start)",
        "original_string": "    public void restart(Node start) {\n        if (type.isInstance(start))\n            //noinspection unchecked\n            next = (T) start; // first next() will be the start node\n\n        root = previous = current = start;\n        currentParent = current.parent();\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/NodeIterator.java",
        "class_name": "NodeIterator",
        "class_uri": "src/main/java/org/jsoup/nodes/NodeIterator.java.NodeIterator",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": "\nRestart this Iterator from the specified start node. Will act as if it were newly constructed. Useful for e.g. to\nsave some GC if the iterator is used in a tight loop.\n@param start the new start node.\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/NodeIterator.java.NodeIterator.[boolean]hasNext()",
        "name": "hasNext",
        "arg_nums": 0,
        "params": [],
        "return_type": "boolean",
        "signature": "@Override public boolean hasNext()",
        "original_string": "    @Override public boolean hasNext() {\n        maybeFindNext();\n        return next != null;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/NodeIterator.java",
        "class_name": "NodeIterator",
        "class_uri": "src/main/java/org/jsoup/nodes/NodeIterator.java.NodeIterator",
        "attributes": {
            "modifiers": "@Override public",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "boolean",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/NodeIterator.java.NodeIterator.[T]next()",
        "name": "next",
        "arg_nums": 0,
        "params": [],
        "return_type": "T",
        "signature": "@Override public T next()",
        "original_string": "    @Override public T next() {\n        maybeFindNext();\n        if (next == null) throw new NoSuchElementException();\n\n        T result = next;\n        previous = current;\n        current = next;\n        currentParent = current.parent();\n        next = null;\n        return result;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/NodeIterator.java",
        "class_name": "NodeIterator",
        "class_uri": "src/main/java/org/jsoup/nodes/NodeIterator.java.NodeIterator",
        "attributes": {
            "modifiers": "@Override public",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "T",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/NodeIterator.java.NodeIterator.[void]maybeFindNext()",
        "name": "maybeFindNext",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "private void maybeFindNext()",
        "original_string": "    private void maybeFindNext() {\n        if (next != null) return;\n\n        //  change detected (removed or replaced), redo from previous\n        if (currentParent != null && !current.hasParent())\n            current = previous;\n\n        next = findNextNode();\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/NodeIterator.java",
        "class_name": "NodeIterator",
        "class_uri": "src/main/java/org/jsoup/nodes/NodeIterator.java.NodeIterator",
        "attributes": {
            "modifiers": "private",
            "marker_annotations": [],
            "non_marker_annotations": [
                "private"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": "\nIf next is not null, looks for and sets next. If next is null after this, we have reached the end.\n"
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/NodeIterator.java.NodeIterator.[T]findNextNode()",
        "name": "findNextNode",
        "arg_nums": 0,
        "params": [],
        "return_type": "T",
        "signature": "private @Nullable T findNextNode()",
        "original_string": "    private @Nullable T findNextNode() {\n        Node node = current;\n        while (true) {\n            if (node.childNodeSize() > 0)\n                node = node.childNode(0);                   // descend children\n            else if (root.equals(node))\n                node = null;                                // complete when all children of root are fully visited\n            else if (node.nextSibling() != null)\n                node = node.nextSibling();                  // in a descendant with no more children; traverse\n            else {\n                while (true) {\n                    node = node.parent();                   // pop out of descendants\n                    if (node == null || root.equals(node))\n                        return null;                        // got back to root; complete\n                    if (node.nextSibling() != null) {\n                        node = node.nextSibling();          // traverse\n                        break;\n                    }\n                }\n            }\n            if (node == null)\n                return null;                                // reached the end\n\n            if (type.isInstance(node))\n                //noinspection unchecked\n                return (T) node;\n        }\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/NodeIterator.java",
        "class_name": "NodeIterator",
        "class_uri": "src/main/java/org/jsoup/nodes/NodeIterator.java.NodeIterator",
        "attributes": {
            "modifiers": "private @Nullable",
            "marker_annotations": [
                "@Nullable"
            ],
            "non_marker_annotations": [
                "private"
            ],
            "comments": [],
            "return_type": "T",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/nodes/NodeIterator.java.NodeIterator.[void]remove()",
        "name": "remove",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "@Override public void remove()",
        "original_string": "    @Override public void remove() {\n        current.remove();\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/nodes/NodeIterator.java",
        "class_name": "NodeIterator",
        "class_uri": "src/main/java/org/jsoup/nodes/NodeIterator.java.NodeIterator",
        "attributes": {
            "modifiers": "@Override public",
            "marker_annotations": [
                "@Override"
            ],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/examples/ListLinks.java.ListLinks.[void]main(String[])",
        "name": "main",
        "arg_nums": 1,
        "params": [
            {
                "name": "args",
                "type": "String[]"
            }
        ],
        "return_type": "void",
        "signature": "public static void main(String[] args)",
        "original_string": "    public static void main(String[] args) throws IOException {\n        Validate.isTrue(args.length == 1, \"usage: supply url to fetch\");\n        String url = args[0];\n        print(\"Fetching %s...\", url);\n\n        Document doc = Jsoup.connect(url).get();\n        Elements links = doc.select(\"a[href]\");\n        Elements media = doc.select(\"[src]\");\n        Elements imports = doc.select(\"link[href]\");\n\n        print(\"\\nMedia: (%d)\", media.size());\n        for (Element src : media) {\n            if (src.nameIs(\"img\"))\n                print(\" * %s: <%s> %sx%s (%s)\",\n                        src.tagName(), src.attr(\"abs:src\"), src.attr(\"width\"), src.attr(\"height\"),\n                        trim(src.attr(\"alt\"), 20));\n            else\n                print(\" * %s: <%s>\", src.tagName(), src.attr(\"abs:src\"));\n        }\n\n        print(\"\\nImports: (%d)\", imports.size());\n        for (Element link : imports) {\n            print(\" * %s <%s> (%s)\", link.tagName(),link.attr(\"abs:href\"), link.attr(\"rel\"));\n        }\n\n        print(\"\\nLinks: (%d)\", links.size());\n        for (Element link : links) {\n            print(\" * a: <%s>  (%s)\", link.attr(\"abs:href\"), trim(link.text(), 35));\n        }\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/examples/ListLinks.java",
        "class_name": "ListLinks",
        "class_uri": "src/main/java/org/jsoup/examples/ListLinks.java.ListLinks",
        "attributes": {
            "modifiers": "public static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public",
                "static"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/examples/ListLinks.java.ListLinks.[void]print(String)",
        "name": "print",
        "arg_nums": 1,
        "params": [
            {
                "name": "msg",
                "type": "String"
            }
        ],
        "return_type": "void",
        "signature": "private static void print(String msg, Object... args)",
        "original_string": "    private static void print(String msg, Object... args) {\n        System.out.println(String.format(msg, args));\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/examples/ListLinks.java",
        "class_name": "ListLinks",
        "class_uri": "src/main/java/org/jsoup/examples/ListLinks.java.ListLinks",
        "attributes": {
            "modifiers": "private static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "private",
                "static"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/examples/ListLinks.java.ListLinks.[String]trim(String,int)",
        "name": "trim",
        "arg_nums": 2,
        "params": [
            {
                "name": "s",
                "type": "String"
            },
            {
                "name": "width",
                "type": "int"
            }
        ],
        "return_type": "String",
        "signature": "private static String trim(String s, int width)",
        "original_string": "    private static String trim(String s, int width) {\n        if (s.length() > width)\n            return s.substring(0, width-1) + \".\";\n        else\n            return s;\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/examples/ListLinks.java",
        "class_name": "ListLinks",
        "class_uri": "src/main/java/org/jsoup/examples/ListLinks.java.ListLinks",
        "attributes": {
            "modifiers": "private static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "private",
                "static"
            ],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/examples/HtmlToPlainText.java.HtmlToPlainText.[void]main()",
        "name": "main",
        "arg_nums": 0,
        "params": [],
        "return_type": "void",
        "signature": "public static void main(String... args)",
        "original_string": "    public static void main(String... args) throws IOException {\n        Validate.isTrue(args.length == 1 || args.length == 2, \"usage: java -cp jsoup.jar org.jsoup.examples.HtmlToPlainText url [selector]\");\n        final String url = args[0];\n        final String selector = args.length == 2 ? args[1] : null;\n\n        // fetch the specified URL and parse to a HTML DOM\n        Document doc = Jsoup.connect(url).userAgent(userAgent).timeout(timeout).get();\n\n        HtmlToPlainText formatter = new HtmlToPlainText();\n\n        if (selector != null) {\n            Elements elements = doc.select(selector); // get each element that matches the CSS selector\n            for (Element element : elements) {\n                String plainText = formatter.getPlainText(element); // format that element to plain text\n                System.out.println(plainText);\n            }\n        } else { // format the whole doc\n            String plainText = formatter.getPlainText(doc);\n            System.out.println(plainText);\n        }\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/examples/HtmlToPlainText.java",
        "class_name": "HtmlToPlainText",
        "class_uri": "src/main/java/org/jsoup/examples/HtmlToPlainText.java.HtmlToPlainText",
        "attributes": {
            "modifiers": "public static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public",
                "static"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/examples/HtmlToPlainText.java.HtmlToPlainText.[String]getPlainText(Element)",
        "name": "getPlainText",
        "arg_nums": 1,
        "params": [
            {
                "name": "element",
                "type": "Element"
            }
        ],
        "return_type": "String",
        "signature": "public String getPlainText(Element element)",
        "original_string": "    public String getPlainText(Element element) {\n        FormattingVisitor formatter = new FormattingVisitor();\n        NodeTraversor.traverse(formatter, element); // walk the DOM, and call .head() and .tail() for each node\n\n        return formatter.toString();\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/examples/HtmlToPlainText.java",
        "class_name": "HtmlToPlainText",
        "class_uri": "src/main/java/org/jsoup/examples/HtmlToPlainText.java.HtmlToPlainText",
        "attributes": {
            "modifiers": "public",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public"
            ],
            "comments": [],
            "return_type": "String",
            "classes": []
        },
        "docstring": "\nFormat an Element to plain-text\n@param element the root element to format\n@return formatted text\n"
    },
    {
        "uris": "src/main/java/org/jsoup/examples/Wikipedia.java.Wikipedia.[void]main(String[])",
        "name": "main",
        "arg_nums": 1,
        "params": [
            {
                "name": "args",
                "type": "String[]"
            }
        ],
        "return_type": "void",
        "signature": "public static void main(String[] args)",
        "original_string": "    public static void main(String[] args) throws IOException {\n        Document doc = Jsoup.connect(\"http://en.wikipedia.org/\").get();\n        log(doc.title());\n\n        Elements newsHeadlines = doc.select(\"#mp-itn b a\");\n        for (Element headline : newsHeadlines) {\n            log(\"%s\\n\\t%s\", headline.attr(\"title\"), headline.absUrl(\"href\"));\n        }\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/examples/Wikipedia.java",
        "class_name": "Wikipedia",
        "class_uri": "src/main/java/org/jsoup/examples/Wikipedia.java.Wikipedia",
        "attributes": {
            "modifiers": "public static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "public",
                "static"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    },
    {
        "uris": "src/main/java/org/jsoup/examples/Wikipedia.java.Wikipedia.[void]log(String)",
        "name": "log",
        "arg_nums": 1,
        "params": [
            {
                "name": "msg",
                "type": "String"
            }
        ],
        "return_type": "void",
        "signature": "private static void log(String msg, String... vals)",
        "original_string": "    private static void log(String msg, String... vals) {\n        System.out.println(String.format(msg, vals));\n    }",
        "default_arguments": null,
        "file": "src/main/java/org/jsoup/examples/Wikipedia.java",
        "class_name": "Wikipedia",
        "class_uri": "src/main/java/org/jsoup/examples/Wikipedia.java.Wikipedia",
        "attributes": {
            "modifiers": "private static",
            "marker_annotations": [],
            "non_marker_annotations": [
                "private",
                "static"
            ],
            "comments": [],
            "return_type": "void",
            "classes": []
        },
        "docstring": ""
    }
]