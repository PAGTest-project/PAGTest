[{"uris": "src/main/java/org/jsoup/Progress.java.Progress", "name": "Progress", "file_path": "src/main/java/org/jsoup/Progress.java", "superclasses": [], "methods": ["[void]onProgress(int,int,float,ProgressContext)"], "method_uris": ["src/main/java/org/jsoup/Progress.java.Progress.[void]onProgress(int,int,float,ProgressContext)"], "overrides": null, "attributes": null, "class_docstring": "", "original_string": "@FunctionalInterface\n\npublic interface Progress<ProgressContext> {\n    /**\n     Called to report progress. Note that this will be executed by the same thread that is doing the work, so either\n     don't take to long, or hand it off to another thread.\n     @param processed the number of bytes processed so far.\n     @param total the total number of expected bytes, or -1 if unknown.\n     @param percent the percentage of completion, 0.0..100.0. If the expected total is unknown, % will remain at zero\n     until complete.\n     @param context the object that progress was made on.\n     @since 1.18.1\n     */\n    void onProgress(int processed, int total, float percent, ProgressContext context);\n}"}, {"uris": "src/main/java/org/jsoup/Connection.java.Connection", "name": "Connection", "file_path": "src/main/java/org/jsoup/Connection.java", "superclasses": [], "methods": ["[Connection]newRequest()", "[Connection]newRequest(String)", "[Connection]newRequest(URL)", "[Connection]url(URL)", "[Connection]url(String)", "[Connection]proxy(Proxy)", "[Connection]proxy(String,int)", "[Connection]userAgent(String)", "[Connection]timeout(int)", "[Connection]maxBodySize(int)", "[Connection]referrer(String)", "[Connection]followRedirects(boolean)", "[Connection]method(Method)", "[Connection]ignoreHttpErrors(boolean)", "[Connection]ignoreContentType(boolean)", "[Connection]sslSocketFactory(SSLSocketFactory)", "[Connection]data(String,String)", "[Connection]data(String,String,InputStream)", "[Connection]data(String,String,InputStream,String)", "[Connection]data(Collection<KeyVal>)", "[Connection]data(Map<String, String>)", "[Connection]data()", "[KeyVal]data(String)", "[Connection]requestBody(String)", "[Connection]header(String,String)", "[Connection]headers(Map<String,String>)", "[Connection]cookie(String,String)", "[Connection]cookies(Map<String, String>)", "[Connection]cookieStore(CookieStore)", "[CookieStore]cookieStore()", "[Connection]parser(Parser)", "[Connection]postDataCharset(String)", "[Connection]auth(RequestAuthenticator)", "[Document]get()", "[Document]post()", "[Response]execute()", "[Request]request()", "[Connection]request(Request)", "[Response]response()", "[Connection]response(Response)", "[Connection]onResponseProgress(Progress<Response>)"], "method_uris": ["src/main/java/org/jsoup/Connection.java.Connection.[Connection]newRequest()", "src/main/java/org/jsoup/Connection.java.Connection.[Connection]newRequest(String)", "src/main/java/org/jsoup/Connection.java.Connection.[Connection]newRequest(URL)", "src/main/java/org/jsoup/Connection.java.Connection.[Connection]url(URL)", "src/main/java/org/jsoup/Connection.java.Connection.[Connection]url(String)", "src/main/java/org/jsoup/Connection.java.Connection.[Connection]proxy(Proxy)", "src/main/java/org/jsoup/Connection.java.Connection.[Connection]proxy(String,int)", "src/main/java/org/jsoup/Connection.java.Connection.[Connection]userAgent(String)", "src/main/java/org/jsoup/Connection.java.Connection.[Connection]timeout(int)", "src/main/java/org/jsoup/Connection.java.Connection.[Connection]maxBodySize(int)", "src/main/java/org/jsoup/Connection.java.Connection.[Connection]referrer(String)", "src/main/java/org/jsoup/Connection.java.Connection.[Connection]followRedirects(boolean)", "src/main/java/org/jsoup/Connection.java.Connection.[Connection]method(Method)", "src/main/java/org/jsoup/Connection.java.Connection.[Connection]ignoreHttpErrors(boolean)", "src/main/java/org/jsoup/Connection.java.Connection.[Connection]ignoreContentType(boolean)", "src/main/java/org/jsoup/Connection.java.Connection.[Connection]sslSocketFactory(SSLSocketFactory)", "src/main/java/org/jsoup/Connection.java.Connection.[Connection]data(String,String)", "src/main/java/org/jsoup/Connection.java.Connection.[Connection]data(String,String,InputStream)", "src/main/java/org/jsoup/Connection.java.Connection.[Connection]data(String,String,InputStream,String)", "src/main/java/org/jsoup/Connection.java.Connection.[Connection]data(Collection<KeyVal>)", "src/main/java/org/jsoup/Connection.java.Connection.[Connection]data(Map<String, String>)", "src/main/java/org/jsoup/Connection.java.Connection.[Connection]data()", "src/main/java/org/jsoup/Connection.java.Connection.[KeyVal]data(String)", "src/main/java/org/jsoup/Connection.java.Connection.[Connection]requestBody(String)", "src/main/java/org/jsoup/Connection.java.Connection.[Connection]header(String,String)", "src/main/java/org/jsoup/Connection.java.Connection.[Connection]headers(Map<String,String>)", "src/main/java/org/jsoup/Connection.java.Connection.[Connection]cookie(String,String)", "src/main/java/org/jsoup/Connection.java.Connection.[Connection]cookies(Map<String, String>)", "src/main/java/org/jsoup/Connection.java.Connection.[Connection]cookieStore(CookieStore)", "src/main/java/org/jsoup/Connection.java.Connection.[CookieStore]cookieStore()", "src/main/java/org/jsoup/Connection.java.Connection.[Connection]parser(Parser)", "src/main/java/org/jsoup/Connection.java.Connection.[Connection]postDataCharset(String)", "src/main/java/org/jsoup/Connection.java.Connection.[Connection]auth(RequestAuthenticator)", "src/main/java/org/jsoup/Connection.java.Connection.[Document]get()", "src/main/java/org/jsoup/Connection.java.Connection.[Document]post()", "src/main/java/org/jsoup/Connection.java.Connection.[Response]execute()", "src/main/java/org/jsoup/Connection.java.Connection.[Request]request()", "src/main/java/org/jsoup/Connection.java.Connection.[Connection]request(Request)", "src/main/java/org/jsoup/Connection.java.Connection.[Response]response()", "src/main/java/org/jsoup/Connection.java.Connection.[Connection]response(Response)", "src/main/java/org/jsoup/Connection.java.Connection.[Connection]onResponseProgress(Progress<Response>)"], "overrides": null, "attributes": null, "class_docstring": "\nThe Connection interface is a convenient HTTP client and session object to fetch content from the web, and parse them\ninto Documents.\n<p>To start a new session, use either {@link org.jsoup.Jsoup#newSession()} or {@link org.jsoup.Jsoup#connect(String)}.\nConnections contain {@link Connection.Request} and {@link Connection.Response} objects (once executed). Configuration\nsettings (URL, timeout, useragent, etc) set on a session will be applied by default to each subsequent request.</p>\n<p>To start a new request from the session, use {@link #newRequest()}.</p>\n<p>Cookies are stored in memory for the duration of the session. For that reason, do not use one single session for all\nrequests in a long-lived application, or you are likely to run out of memory, unless care is taken to clean up the\ncookie store. The cookie store for the session is available via {@link #cookieStore()}. You may provide your own\nimplementation via {@link #cookieStore(java.net.CookieStore)} before making requests.</p>\n<p>Request configuration can be made using either the shortcut methods in Connection (e.g. {@link #userAgent(String)}),\nor by methods in the {@link Connection.Request} object directly. All request configuration must be made before the request is\nexecuted. When used as an ongoing session, initialize all defaults prior to making multi-threaded {@link\n#newRequest()}s.</p>\n<p>Note that the term \"Connection\" used here does not mean that a long-lived connection is held against a server for\nthe lifetime of the Connection object. A socket connection is only made at the point of request execution ({@link\n#execute()}, {@link #get()}, or {@link #post()}), and the server's response consumed.</p>\n<p>For multi-threaded implementations, it is important to use a {@link #newRequest()} for each request. The session may\nbe shared across concurrent threads, but a not a specific request.</p>\n", "original_string": "@SuppressWarnings(\"unused\")\npublic interface Connection {\n\n    /**\n     * GET and POST http methods.\n     */\n    enum Method {\n        GET(false),\n        POST(true),\n        PUT(true),\n        DELETE(true),\n        /**\n         Note that unfortunately, PATCH is not supported in many JDKs.\n         */\n        PATCH(true),\n        HEAD(false),\n        OPTIONS(false),\n        TRACE(false);\n\n        private final boolean hasBody;\n\n        Method(boolean hasBody) {\n            this.hasBody = hasBody;\n        }\n\n        /**\n         * Check if this HTTP method has/needs a request body\n         * @return if body needed\n         */\n        public final boolean hasBody() {\n            return hasBody;\n        }\n    }\n\n    /**\n     Creates a new request, using this Connection as the session-state and to initialize the connection settings (which\n     may then be independently changed on the returned {@link Connection.Request} object).\n     @return a new Connection object, with a shared Cookie Store and initialized settings from this Connection and Request\n     @since 1.14.1\n     */\n    Connection newRequest();\n\n    /**\n     Creates a new request, using this Connection as the session-state and to initialize the connection settings (which\n     may then be independently changed on the returned {@link Connection.Request} object).\n     @return a new Connection object, with a shared Cookie Store and initialized settings from this Connection and Request\n     @param url URL for the new request\n     @since 1.17.1\n     */\n    default Connection newRequest(String url) {\n        return newRequest().url(url);\n    }\n\n    /**\n     Creates a new request, using this Connection as the session-state and to initialize the connection settings (which\n     may then be independently changed on the returned {@link Connection.Request} object).\n     @return a new Connection object, with a shared Cookie Store and initialized settings from this Connection and Request\n     @param url URL for the new request\n     @since 1.17.1\n     */\n    default Connection newRequest(URL url) {\n        return newRequest().url(url);\n    }\n\n    /**\n     * Set the request URL to fetch. The protocol must be HTTP or HTTPS.\n     * @param url URL to connect to\n     * @return this Connection, for chaining\n     */\n    Connection url(URL url);\n\n    /**\n     * Set the request URL to fetch. The protocol must be HTTP or HTTPS.\n     * @param url URL to connect to\n     * @return this Connection, for chaining\n     */\n    Connection url(String url);\n\n    /**\n     * Set the proxy to use for this request. Set to <code>null</code> to disable a previously set proxy.\n     * @param proxy proxy to use\n     * @return this Connection, for chaining\n     */\n    Connection proxy(@Nullable Proxy proxy);\n\n    /**\n     * Set the HTTP proxy to use for this request.\n     * @param host the proxy hostname\n     * @param port the proxy port\n     * @return this Connection, for chaining\n     */\n    Connection proxy(String host, int port);\n\n    /**\n     * Set the request user-agent header.\n     * @param userAgent user-agent to use\n     * @return this Connection, for chaining\n     * @see org.jsoup.helper.HttpConnection#DEFAULT_UA\n     */\n    Connection userAgent(String userAgent);\n\n    /**\n     * Set the total request timeout duration. If a timeout occurs, an {@link java.net.SocketTimeoutException} will be thrown.\n     * <p>The default timeout is <b>30 seconds</b> (30,000 millis). A timeout of zero is treated as an infinite timeout.\n     * <p>Note that this timeout specifies the combined maximum duration of the connection time and the time to read\n     * the full response.\n     * @param millis number of milliseconds (thousandths of a second) before timing out connects or reads.\n     * @return this Connection, for chaining\n     * @see #maxBodySize(int)\n     */\n    Connection timeout(int millis);\n\n    /**\n     * Set the maximum bytes to read from the (uncompressed) connection into the body, before the connection is closed,\n     * and the input truncated (i.e. the body content will be trimmed). <b>The default maximum is 2MB</b>. A max size of\n     * <code>0</code> is treated as an infinite amount (bounded only by your patience and the memory available on your\n     * machine).\n     *\n     * @param bytes number of bytes to read from the input before truncating\n     * @return this Connection, for chaining\n     */\n    Connection maxBodySize(int bytes);\n\n    /**\n     * Set the request referrer (aka \"referer\") header.\n     * @param referrer referrer to use\n     * @return this Connection, for chaining\n     */\n    Connection referrer(String referrer);\n\n    /**\n     * Configures the connection to (not) follow server redirects. By default, this is <b>true</b>.\n     * @param followRedirects true if server redirects should be followed.\n     * @return this Connection, for chaining\n     */\n    Connection followRedirects(boolean followRedirects);\n\n    /**\n     * Set the request method to use, GET or POST. Default is GET.\n     * @param method HTTP request method\n     * @return this Connection, for chaining\n     */\n    Connection method(Method method);\n\n    /**\n     * Configures the connection to not throw exceptions when an HTTP error occurs. (4xx - 5xx, e.g. 404 or 500). By\n     * default, this is <b>false</b>; an IOException is thrown if an error is encountered. If set to <b>true</b>, the\n     * response is populated with the error body, and the status message will reflect the error.\n     * @param ignoreHttpErrors - false (default) if HTTP errors should be ignored.\n     * @return this Connection, for chaining\n     */\n    Connection ignoreHttpErrors(boolean ignoreHttpErrors);\n\n    /**\n     * Ignore the document's Content-Type when parsing the response. By default, this is <b>false</b>, an unrecognised\n     * content-type will cause an IOException to be thrown. (This is to prevent producing garbage by attempting to parse\n     * a JPEG binary image, for example.) Set to true to force a parse attempt regardless of content type.\n     * @param ignoreContentType set to true if you would like the content type ignored on parsing the response into a\n     * Document.\n     * @return this Connection, for chaining\n     */\n    Connection ignoreContentType(boolean ignoreContentType);\n\n    /**\n     * Set custom SSL socket factory\n     * @param sslSocketFactory custom SSL socket factory\n     * @return this Connection, for chaining\n     */\n    Connection sslSocketFactory(SSLSocketFactory sslSocketFactory);\n\n    /**\n     * Add a request data parameter. Request parameters are sent in the request query string for GETs, and in the\n     * request body for POSTs. A request may have multiple values of the same name.\n     * @param key data key\n     * @param value data value\n     * @return this Connection, for chaining\n     */\n    Connection data(String key, String value);\n\n    /**\n     * Add an input stream as a request data parameter. For GETs, has no effect, but for POSTS this will upload the\n     * input stream.\n     * <p>Use the {@link #data(String, String, InputStream, String)} method to set the uploaded file's mimetype.</p>\n     * @param key data key (form item name)\n     * @param filename the name of the file to present to the remove server. Typically just the name, not path,\n     * component.\n     * @param inputStream the input stream to upload, that you probably obtained from a {@link java.io.FileInputStream}.\n     * You must close the InputStream in a {@code finally} block.\n     * @return this Connection, for chaining\n     * @see #data(String, String, InputStream, String)\n     */\n    Connection data(String key, String filename, InputStream inputStream);\n\n    /**\n     * Add an input stream as a request data parameter. For GETs, has no effect, but for POSTS this will upload the\n     * input stream.\n     * @param key data key (form item name)\n     * @param filename the name of the file to present to the remove server. Typically just the name, not path,\n     * component.\n     * @param inputStream the input stream to upload, that you probably obtained from a {@link java.io.FileInputStream}.\n     * @param contentType the Content Type (aka mimetype) to specify for this file.\n     * You must close the InputStream in a {@code finally} block.\n     * @return this Connection, for chaining\n     */\n    Connection data(String key, String filename, InputStream inputStream, String contentType);\n\n    /**\n     * Adds all of the supplied data to the request data parameters\n     * @param data collection of data parameters\n     * @return this Connection, for chaining\n     */\n    Connection data(Collection<KeyVal> data);\n\n    /**\n     * Adds all of the supplied data to the request data parameters\n     * @param data map of data parameters\n     * @return this Connection, for chaining\n     */\n    Connection data(Map<String, String> data);\n\n    /**\n     Add one or more request {@code key, val} data parameter pairs.\n     <p>Multiple parameters may be set at once, e.g.:\n     <code>.data(\"name\", \"jsoup\", \"language\", \"Java\", \"language\", \"English\");</code> creates a query string like:\n     <code>{@literal ?name=jsoup&language=Java&language=English}</code></p>\n     <p>For GET requests, data parameters will be sent on the request query string. For POST (and other methods that\n     contain a body), they will be sent as body form parameters, unless the body is explicitly set by\n     {@link #requestBody(String)}, in which case they will be query string parameters.</p>\n\n     @param keyvals a set of key value pairs.\n     @return this Connection, for chaining\n     */\n    Connection data(String... keyvals);\n\n    /**\n     * Get the data KeyVal for this key, if any\n     * @param key the data key\n     * @return null if not set\n     */\n    @Nullable KeyVal data(String key);\n\n    /**\n     * Set a POST (or PUT) request body. Useful when a server expects a plain request body (such as JSON), and not a set\n     * of URL encoded form key/value pairs. E.g.:\n     * <code><pre>Jsoup.connect(url)\n     * .requestBody(json)\n     * .header(\"Content-Type\", \"application/json\")\n     * .post();</pre></code>\n     * If any data key/vals are supplied, they will be sent as URL query params.\n     * @return this Request, for chaining\n     */\n    Connection requestBody(String body);\n\n    /**\n     * Set a request header. Replaces any existing header with the same case-insensitive name.\n     * @param name header name\n     * @param value header value\n     * @return this Connection, for chaining\n     * @see org.jsoup.Connection.Request#header(String, String)\n     * @see org.jsoup.Connection.Request#headers()\n     */\n    Connection header(String name, String value);\n\n    /**\n     * Sets each of the supplied headers on the request. Existing headers with the same case-insensitive name will be\n     * replaced with the new value.\n     * @param headers map of headers name {@literal ->} value pairs\n     * @return this Connection, for chaining\n     * @see org.jsoup.Connection.Request#headers()\n     */\n    Connection headers(Map<String,String> headers);\n\n    /**\n     * Set a cookie to be sent in the request.\n     * @param name name of cookie\n     * @param value value of cookie\n     * @return this Connection, for chaining\n     */\n    Connection cookie(String name, String value);\n\n    /**\n     * Adds each of the supplied cookies to the request.\n     * @param cookies map of cookie name {@literal ->} value pairs\n     * @return this Connection, for chaining\n     */\n    Connection cookies(Map<String, String> cookies);\n\n    /**\n     Provide a custom or pre-filled CookieStore to be used on requests made by this Connection.\n     @param cookieStore a cookie store to use for subsequent requests\n     @return this Connection, for chaining\n     @since 1.14.1\n     */\n    Connection cookieStore(CookieStore cookieStore);\n\n    /**\n     Get the cookie store used by this Connection.\n     @return the cookie store\n     @since 1.14.1\n     */\n    CookieStore cookieStore();\n\n    /**\n     * Provide a specific parser to use when parsing the response to a Document. If not set, jsoup defaults to the\n     * {@link Parser#htmlParser() HTML parser}, unless the response content-type is XML, in which case the\n     * {@link Parser#xmlParser() XML parser} is used.\n     * @param parser alternate parser\n     * @return this Connection, for chaining\n     */\n    Connection parser(Parser parser);\n\n    /**\n     * Set the character-set used to encode for x-www-form-urlencoded post data. Defaults to {@code UTF-8}.\n     * @param charset character set to encode post data\n     * @return this Connection, for chaining\n     */\n    Connection postDataCharset(String charset);\n\n    /**\n     Set the authenticator to use for this connection, enabling requests to URLs, and via proxies, that require\n     authentication credentials.\n     <p>The authentication scheme used is automatically detected during the request execution.\n     Supported schemes (subject to the platform) are {@code basic}, {@code digest}, {@code NTLM},\n     and {@code Kerberos}.</p>\n\n     <p>To use, supply a {@link RequestAuthenticator} function that:\n     <ol>\n     <li>validates the URL that is requesting authentication, and</li>\n     <li>returns the appropriate credentials (username and password)</li>\n     </ol>\n     </p>\n\n     <p>For example, to authenticate both to a proxy and a downstream web server:\n     <code><pre>\n     Connection session = Jsoup.newSession()\n         .proxy(\"proxy.example.com\", 8080)\n         .auth(auth -> {\n             if (auth.isServer()) { // provide credentials for the request url\n                 Validate.isTrue(auth.url().getHost().equals(\"example.com\"));\n                 // check that we're sending credentials were we expect, and not redirected out\n                 return auth.credentials(\"username\", \"password\");\n             } else { // auth.isProxy()\n                 return auth.credentials(\"proxy-user\", \"proxy-password\");\n             }\n         });\n\n     Connection.Response response = session.newRequest(\"https://example.com/adminzone/\").execute();\n     </pre></code>\n     </p>\n\n     <p>The system may cache the authentication and use it for subsequent requests to the same resource.</p>\n\n     <p><b>Implementation notes</b></p>\n     <p>For compatibility, on a Java 8 platform, authentication is set up via the system-wide default\n     {@link java.net.Authenticator#setDefault(Authenticator)} method via a ThreadLocal delegator. Whilst the\n     authenticator used is request specific and thread-safe, if you have other calls to {@code setDefault}, they will be\n     incompatible with this implementation.</p>\n     <p>On Java 9 and above, the preceding note does not apply; authenticators are directly set on the request. </p>\n     <p>If you are attempting to authenticate to a proxy that uses the {@code basic} scheme and will be fetching HTTPS\n     URLs, you need to configure your Java platform to enable that, by setting the\n     {@code jdk.http.auth.tunneling.disabledSchemes} system property to {@code \"\"}.\n     This must be executed prior to any authorization attempts. E.g.:\n     <code><pre>\n     static {\n        System.setProperty(\"jdk.http.auth.tunneling.disabledSchemes\", \"\");\n        // removes Basic, which is otherwise excluded from auth for CONNECT tunnels\n     }</pre></code>\n     </p>\n     * @param authenticator the authenticator to use in this connection\n     * @return this Connection, for chaining\n     * @since 1.17.1\n     */\n    default Connection auth(@Nullable RequestAuthenticator authenticator) {\n        throw new UnsupportedOperationException();\n    }\n\n    /**\n     * Execute the request as a GET, and parse the result.\n     * @return parsed Document\n     * @throws java.net.MalformedURLException if the request URL is not an HTTP or HTTPS URL, or is otherwise malformed\n     * @throws HttpStatusException if the response is not OK and HTTP response errors are not ignored\n     * @throws UnsupportedMimeTypeException if the response mime type is not supported and those errors are not ignored\n     * @throws java.net.SocketTimeoutException if the connection times out\n     * @throws IOException on error\n     */\n    Document get() throws IOException;\n\n    /**\n     * Execute the request as a POST, and parse the result.\n     * @return parsed Document\n     * @throws java.net.MalformedURLException if the request URL is not a HTTP or HTTPS URL, or is otherwise malformed\n     * @throws HttpStatusException if the response is not OK and HTTP response errors are not ignored\n     * @throws UnsupportedMimeTypeException if the response mime type is not supported and those errors are not ignored\n     * @throws java.net.SocketTimeoutException if the connection times out\n     * @throws IOException on error\n     */\n    Document post() throws IOException;\n\n    /**\n     * Execute the request.\n     * @return the executed {@link Response}\n     * @throws java.net.MalformedURLException if the request URL is not a HTTP or HTTPS URL, or is otherwise malformed\n     * @throws HttpStatusException if the response is not OK and HTTP response errors are not ignored\n     * @throws UnsupportedMimeTypeException if the response mime type is not supported and those errors are not ignored\n     * @throws java.net.SocketTimeoutException if the connection times out\n     * @throws IOException on error\n     */\n    Response execute() throws IOException;\n\n    /**\n     * Get the request object associated with this connection\n     * @return request\n     */\n    Request request();\n\n    /**\n     * Set the connection's request\n     * @param request new request object\n     * @return this Connection, for chaining\n     */\n    Connection request(Request request);\n\n    /**\n     * Get the response, once the request has been executed.\n     * @return response\n     * @throws IllegalArgumentException if called before the response has been executed.\n     */\n    Response response();\n\n    /**\n     * Set the connection's response\n     * @param response new response\n     * @return this Connection, for chaining\n     */\n    Connection response(Response response);\n\n    /**\n     Set the response progress handler, which will be called periodically as the response body is downloaded. Since\n     documents are parsed as they are downloaded, this is also a good proxy for the parse progress.\n     <p>The Response object is supplied as the progress context, and may be read from to obtain headers etc.</p>\n     @param handler the progress handler\n     @return this Connection, for chaining\n     @since 1.18.1\n     */\n    default Connection onResponseProgress(Progress<Response> handler) {\n        throw new UnsupportedOperationException();\n    }\n\n    /**\n     * Common methods for Requests and Responses\n     * @param <T> Type of Base, either Request or Response\n     */\n    @SuppressWarnings(\"UnusedReturnValue\")\n    interface Base<T extends Base<T>> {\n        /**\n         * Get the URL of this Request or Response. For redirected responses, this will be the final destination URL.\n         * @return URL\n         * @throws IllegalArgumentException if called on a Request that was created without a URL.\n         */\n        URL url();\n\n        /**\n         * Set the URL\n         * @param url new URL\n         * @return this, for chaining\n         */\n        T url(URL url);\n\n        /**\n         * Get the request method, which defaults to <code>GET</code>\n         * @return method\n         */\n        Method method();\n\n        /**\n         * Set the request method\n         * @param method new method\n         * @return this, for chaining\n         */\n        T method(Method method);\n\n        /**\n         * Get the value of a header. If there is more than one header value with the same name, the headers are returned\n         * comma separated, per <a href=\"https://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.2\">rfc2616-sec4</a>.\n         * <p>\n         * Header names are case-insensitive.\n         * </p>\n         * @param name name of header (case-insensitive)\n         * @return value of header, or null if not set.\n         * @see #hasHeader(String)\n         * @see #cookie(String)\n         */\n        @Nullable String header(String name);\n\n        /**\n         * Get the values of a header.\n         * @param name header name, case-insensitive.\n         * @return a list of values for this header, or an empty list if not set.\n         */\n        List<String> headers(String name);\n\n        /**\n         * Set a header. This method will overwrite any existing header with the same case-insensitive name. If there\n         * is more than one value for this header, this method will update the first matching header.\n         * <p>For compatibility, if the content of the header includes text that cannot be represented by ISO-8859-1,\n         * then it should be encoded first per <a href=\"https://www.ietf.org/rfc/rfc2047.txt\">RFC 2047</a>.</p>\n         * @param name Name of header\n         * @param value Value of header\n         * @return this, for chaining\n         * @see #addHeader(String, String)\n         */\n        T header(String name, String value);\n\n        /**\n         * Add a header. The header will be added regardless of whether a header with the same name already exists.\n         * <p>For compatibility, if the content of the header includes text that cannot be represented by ISO-8859-1,\n         * then it should be encoded first per <a href=\"https://www.ietf.org/rfc/rfc2047.txt\">RFC 2047</a>.</p>\n         * @param name Name of new header\n         * @param value Value of new header\n         * @return this, for chaining\n         */\n        T addHeader(String name, String value);\n\n        /**\n         * Check if a header is present\n         * @param name name of header (case-insensitive)\n         * @return if the header is present in this request/response\n         */\n        boolean hasHeader(String name);\n\n        /**\n         * Check if a header is present, with the given value\n         * @param name header name (case-insensitive)\n         * @param value value (case-insensitive)\n         * @return if the header and value pair are set in this req/res\n         */\n        boolean hasHeaderWithValue(String name, String value);\n\n        /**\n         * Remove headers by name. If there is more than one header with this name, they will all be removed.\n         * @param name name of header to remove (case-insensitive)\n         * @return this, for chaining\n         */\n        T removeHeader(String name);\n\n        /**\n         * Retrieve all of the request/response header names and corresponding values as a map. For headers with multiple\n         * values, only the first header is returned.\n         * <p>Note that this is a view of the headers only, and changes made to this map will not be reflected in the\n         * request/response object.</p>\n         * @return headers\n         * @see #multiHeaders()\n\n         */\n        Map<String, String> headers();\n\n        /**\n         * Retreive all of the headers, keyed by the header name, and with a list of values per header.\n         * @return a list of multiple values per header.\n         */\n        Map<String, List<String>> multiHeaders();\n\n        /**\n         * Get a cookie value by name from this request/response.\n         * @param name name of cookie to retrieve.\n         * @return value of cookie, or null if not set\n         */\n        @Nullable String cookie(String name);\n\n        /**\n         * Set a cookie in this request/response.\n         * @param name name of cookie\n         * @param value value of cookie\n         * @return this, for chaining\n         */\n        T cookie(String name, String value);\n\n        /**\n         * Check if a cookie is present\n         * @param name name of cookie\n         * @return if the cookie is present in this request/response\n         */\n        boolean hasCookie(String name);\n\n        /**\n         * Remove a cookie by name\n         * @param name name of cookie to remove\n         * @return this, for chaining\n         */\n        T removeCookie(String name);\n\n        /**\n         * Retrieve all of the request/response cookies as a map\n         * @return cookies\n         * @see #cookieStore()\n         */\n        Map<String, String> cookies();\n    }\n\n    /**\n     * Represents a HTTP request.\n     */\n    @SuppressWarnings(\"UnusedReturnValue\")\n    interface Request extends Base<Request> {\n        /**\n         * Get the proxy used for this request.\n         * @return the proxy; <code>null</code> if not enabled.\n         */\n        @Nullable Proxy proxy();\n\n        /**\n         * Update the proxy for this request.\n         * @param proxy the proxy ot use; <code>null</code> to disable.\n         * @return this Request, for chaining\n         */\n        Request proxy(@Nullable Proxy proxy);\n\n        /**\n         * Set the HTTP proxy to use for this request.\n         * @param host the proxy hostname\n         * @param port the proxy port\n         * @return this Connection, for chaining\n         */\n        Request proxy(String host, int port);\n\n        /**\n         * Get the request timeout, in milliseconds.\n         * @return the timeout in milliseconds.\n         */\n        int timeout();\n\n        /**\n         * Update the request timeout.\n         * @param millis timeout, in milliseconds\n         * @return this Request, for chaining\n         */\n        Request timeout(int millis);\n\n        /**\n         * Get the maximum body size, in bytes.\n         * @return the maximum body size, in bytes.\n         */\n        int maxBodySize();\n\n        /**\n         * Update the maximum body size, in bytes.\n         * @param bytes maximum body size, in bytes.\n         * @return this Request, for chaining\n         */\n        Request maxBodySize(int bytes);\n\n        /**\n         * Get the current followRedirects configuration.\n         * @return true if followRedirects is enabled.\n         */\n        boolean followRedirects();\n\n        /**\n         * Configures the request to (not) follow server redirects. By default this is <b>true</b>.\n         * @param followRedirects true if server redirects should be followed.\n         * @return this Request, for chaining\n         */\n        Request followRedirects(boolean followRedirects);\n\n        /**\n         * Get the current ignoreHttpErrors configuration.\n         * @return true if errors will be ignored; false (default) if HTTP errors will cause an IOException to be\n         * thrown.\n         */\n        boolean ignoreHttpErrors();\n\n        /**\n         * Configures the request to ignore HTTP errors in the response.\n         * @param ignoreHttpErrors set to true to ignore HTTP errors.\n         * @return this Request, for chaining\n         */\n        Request ignoreHttpErrors(boolean ignoreHttpErrors);\n\n        /**\n         * Get the current ignoreContentType configuration.\n         * @return true if invalid content-types will be ignored; false (default) if they will cause an IOException to\n         * be thrown.\n         */\n        boolean ignoreContentType();\n\n        /**\n         * Configures the request to ignore the Content-Type of the response.\n         * @param ignoreContentType set to true to ignore the content type.\n         * @return this Request, for chaining\n         */\n        Request ignoreContentType(boolean ignoreContentType);\n\n        /**\n         * Get the current custom SSL socket factory, if any.\n         * @return custom SSL socket factory if set, null otherwise\n         */\n        @Nullable SSLSocketFactory sslSocketFactory();\n\n        /**\n         * Set a custom SSL socket factory.\n         * @param sslSocketFactory SSL socket factory\n         */\n        void sslSocketFactory(SSLSocketFactory sslSocketFactory);\n\n        /**\n         * Add a data parameter to the request\n         * @param keyval data to add.\n         * @return this Request, for chaining\n         */\n        Request data(KeyVal keyval);\n\n        /**\n         * Get all of the request's data parameters\n         * @return collection of keyvals\n         */\n        Collection<KeyVal> data();\n\n        /**\n         * Set a POST (or PUT) request body. Useful when a server expects a plain request body, not a set of URL\n         * encoded form key/value pairs. E.g.:\n         * <code><pre>Jsoup.connect(url)\n         * .requestBody(json)\n         * .header(\"Content-Type\", \"application/json\")\n         * .post();</pre></code>\n         * If any data key/vals are supplied, they will be sent as URL query params.\n         * @param body to use as the request body. Set to null to clear a previously set body.\n         * @return this Request, for chaining\n         */\n        Request requestBody(@Nullable String body);\n\n        /**\n         * Get the current request body.\n         * @return null if not set.\n         */\n        @Nullable String requestBody();\n\n        /**\n         * Specify the parser to use when parsing the document.\n         * @param parser parser to use.\n         * @return this Request, for chaining\n         */\n        Request parser(Parser parser);\n\n        /**\n         * Get the current parser to use when parsing the document.\n         * @return current Parser\n         */\n        Parser parser();\n\n        /**\n         * Sets the post data character set for x-www-form-urlencoded post data\n         * @param charset character set to encode post data\n         * @return this Request, for chaining\n         */\n        Request postDataCharset(String charset);\n\n        /**\n         * Gets the post data character set for x-www-form-urlencoded post data\n         * @return character set to encode post data\n         */\n        String postDataCharset();\n\n        /**\n         Set the authenticator to use for this request.\n         See {@link Connection#auth(RequestAuthenticator) Connection.auth(authenticator)} for examples and\n         implementation notes.\n         * @param authenticator the authenticator\n         * @return this Request, for chaining.\n         * @since 1.17.1\n         */\n        default Request auth(@Nullable RequestAuthenticator authenticator)  {\n            throw new UnsupportedOperationException();\n        }\n\n        /**\n         Get the RequestAuthenticator, if any, that will be used on this request.\n         * @return the RequestAuthenticator, or {@code null} if not set\n         * @since 1.17.1\n         */\n        @Nullable\n        default RequestAuthenticator auth() {\n            throw new UnsupportedOperationException();\n        }\n    }\n\n    /**\n     * Represents a HTTP response.\n     */\n    interface Response extends Base<Response> {\n\n        /**\n         * Get the status code of the response.\n         * @return status code\n         */\n        int statusCode();\n\n        /**\n         * Get the status message of the response.\n         * @return status message\n         */\n        String statusMessage();\n\n        /**\n         * Get the character set name of the response, derived from the content-type header.\n         * @return character set name if set, <b>null</b> if not\n         */\n        @Nullable String charset();\n\n        /**\n         * Set / override the response character set. When the document body is parsed it will be with this charset.\n         * @param charset to decode body as\n         * @return this Response, for chaining\n         */\n        Response charset(String charset);\n\n        /**\n         * Get the response content type (e.g. \"text/html\");\n         * @return the response content type, or <b>null</b> if one was not set\n         */\n        @Nullable String contentType();\n\n        /**\n         * Read and parse the body of the response as a Document. If you intend to parse the same response multiple\n         * times, you should {@link #bufferUp()} first.\n         * @return a parsed Document\n         * @throws IOException on error\n         */\n        Document parse() throws IOException;\n\n        /**\n         * Get the body of the response as a plain string.\n         * @return body\n         */\n        String body();\n\n        /**\n         * Get the body of the response as an array of bytes.\n         * @return body bytes\n         */\n        byte[] bodyAsBytes();\n\n        /**\n         * Read the body of the response into a local buffer, so that {@link #parse()} may be called repeatedly on the\n         * same connection response. Otherwise, once the response is read, its InputStream will have been drained and\n         * may not be re-read.\n         * <p>Calling {@link #body() } or {@link #bodyAsBytes()} has the same effect.</p>\n         * @return this response, for chaining\n         * @throws UncheckedIOException if an IO exception occurs during buffering.\n         */\n        Response bufferUp();\n\n        /**\n         Get the body of the response as a (buffered) InputStream. You should close the input stream when you're done\n         with it.\n         <p>Other body methods (like bufferUp, body, parse, etc) will generally not work in conjunction with this method,\n         as it consumes the InputStream.</p>\n         <p>Any configured max size or maximum read timeout applied to the connection will not be applied to this stream,\n         unless {@link #bufferUp()} is called prior.</p>\n         <p>This method is useful for writing large responses to disk, without buffering them completely into memory\n         first.</p>\n         @return the response body input stream\n         */\n        BufferedInputStream bodyStream();\n\n        /**\n         Returns a {@link StreamParser} that will parse the Response progressively.\n         * @return a StreamParser, prepared to parse this response.\n         * @throws IOException if an IO exception occurs preparing the parser.\n         */\n        default StreamParser streamParser() throws IOException {\n            throw new UnsupportedOperationException();\n        }\n    }\n\n    /**\n     * A Key:Value tuple(+), used for form data.\n     */\n    interface KeyVal {\n\n        /**\n         * Update the key of a keyval\n         * @param key new key\n         * @return this KeyVal, for chaining\n         */\n        KeyVal key(String key);\n\n        /**\n         * Get the key of a keyval\n         * @return the key\n         */\n        String key();\n\n        /**\n         * Update the value of a keyval\n         * @param value the new value\n         * @return this KeyVal, for chaining\n         */\n        KeyVal value(String value);\n\n        /**\n         * Get the value of a keyval\n         * @return the value\n         */\n        String value();\n\n        /**\n         * Add or update an input stream to this keyVal\n         * @param inputStream new input stream\n         * @return this KeyVal, for chaining\n         */\n        KeyVal inputStream(InputStream inputStream);\n\n        /**\n         * Get the input stream associated with this keyval, if any\n         * @return input stream if set, or null\n         */\n        @Nullable InputStream inputStream();\n\n        /**\n         * Does this keyval have an input stream?\n         * @return true if this keyval does indeed have an input stream\n         */\n        boolean hasInputStream();\n\n        /**\n         * Set the Content Type header used in the MIME body (aka mimetype) when uploading files.\n         * Only useful if {@link #inputStream(InputStream)} is set.\n         * <p>Will default to {@code application/octet-stream}.</p>\n         * @param contentType the new content type\n         * @return this KeyVal\n         */\n        KeyVal contentType(String contentType);\n\n        /**\n         * Get the current Content Type, or {@code null} if not set.\n         * @return the current Content Type.\n         */\n        @Nullable String contentType();\n    }\n}"}, {"uris": "src/main/java/org/jsoup/helper/RequestAuthenticator.java.RequestAuthenticator", "name": "RequestAuthenticator", "file_path": "src/main/java/org/jsoup/helper/RequestAuthenticator.java", "superclasses": [], "methods": ["[PasswordAuthentication]authenticate(Context)"], "method_uris": ["src/main/java/org/jsoup/helper/RequestAuthenticator.java.RequestAuthenticator.[PasswordAuthentication]authenticate(Context)"], "overrides": null, "attributes": null, "class_docstring": "\nA {@code RequestAuthenticator} is used in {@link Connection} to authenticate if required to proxies and web\nservers. See {@link Connection#auth(RequestAuthenticator)}.\n", "original_string": "@FunctionalInterface\npublic interface RequestAuthenticator {\n\n    /**\n     Provide authentication credentials for the provided Request Context.\n     * @param auth the request context including URL, type (Server or Proxy), and realm.\n     * @return credentials for the request. May return {@code null} if they are not applicable -- but the request will\n     * likely fail, as this method is only called if the request asked for authentication.\n     */\n    @Nullable\n    PasswordAuthentication authenticate(Context auth);\n\n    /**\n     Provides details for the request, to determine the appropriate credentials to return.\n     */\n    class Context {\n        private final URL url;\n        private final Authenticator.RequestorType type;\n        private final String realm;\n\n        Context(URL url, Authenticator.RequestorType type, String realm) {\n            this.url = url;\n            this.type = type;\n            this.realm = realm;\n        }\n\n        /**\n         Get he URL that is being requested.\n         * @return URL\n         */\n        public URL url() {\n            return url;\n        }\n\n        /**\n         Get the requestor type: {@link Authenticator.RequestorType#PROXY PROXY} if a proxy is requesting\n         authentication, or {@link Authenticator.RequestorType#SERVER SERVER} if the URL's server is requesting.\n         * @return requestor type\n         */\n        public Authenticator.RequestorType type() {\n            return type;\n        }\n\n        /**\n         Get the realm of the authentication request.\n         * @return realm of the authentication request\n         */\n        public String realm() {\n            return realm;\n        }\n\n        /**\n         Gets if the authentication request is for a proxy.\n         * @return true if type==proxy.\n         */\n        public boolean isProxy() {\n            return type == Authenticator.RequestorType.PROXY;\n        }\n\n        /**\n         Gets if the authentication request is for a server.\n         * @return true if type==server.\n         */\n        public boolean isServer() {\n            return type == Authenticator.RequestorType.SERVER;\n        }\n\n        /**\n         Helper method to return a PasswordAuthentication object.\n         * @param username username credential\n         * @param password password credential\n         * @return a constructed PasswordAuthentication\n         */\n        public PasswordAuthentication credentials(String username, String password) {\n            return new PasswordAuthentication(username, password.toCharArray());\n        }\n    }\n\n}"}, {"uris": "src/main/java/org/jsoup/select/NodeFilter.java.NodeFilter", "name": "NodeFilter", "file_path": "src/main/java/org/jsoup/select/NodeFilter.java", "superclasses": [], "methods": ["[FilterResult]head(Node,int)", "[FilterResult]tail(Node,int)"], "method_uris": ["src/main/java/org/jsoup/select/NodeFilter.java.NodeFilter.[FilterResult]head(Node,int)", "src/main/java/org/jsoup/select/NodeFilter.java.NodeFilter.[FilterResult]tail(Node,int)"], "overrides": null, "attributes": null, "class_docstring": "\nNode filter interface. Provide an implementing class to {@link NodeTraversor} to iterate through nodes.\n<p>\nThis interface provides two methods, {@code head} and {@code tail}. The head method is called when the node is first\nseen, and the tail method when all of the node's children have been visited. As an example, head can be used to\ncreate a start tag for a node, and tail to create the end tag.\n</p>\n<p>\nFor every node, the filter has to decide whether to:\n<ul>\n<li>continue ({@link FilterResult#CONTINUE}),</li>\n<li>skip all children ({@link FilterResult#SKIP_CHILDREN}),</li>\n<li>skip node entirely ({@link FilterResult#SKIP_ENTIRELY}),</li>\n<li>remove the subtree ({@link FilterResult#REMOVE}),</li>\n<li>interrupt the iteration and return ({@link FilterResult#STOP}).</li>\n</ul>\nThe difference between {@link FilterResult#SKIP_CHILDREN} and {@link FilterResult#SKIP_ENTIRELY} is that the first\nwill invoke {@link NodeFilter#tail(Node, int)} on the node, while the latter will not.\nWithin {@link NodeFilter#tail(Node, int)}, both are equivalent to {@link FilterResult#CONTINUE}.\n</p>\n", "original_string": "public interface NodeFilter {\n    /**\n     * Filter decision.\n     */\n    enum FilterResult {\n        /** Continue processing the tree */\n        CONTINUE,\n        /** Skip the child nodes, but do call {@link NodeFilter#tail(Node, int)} next. */\n        SKIP_CHILDREN,\n        /** Skip the subtree, and do not call {@link NodeFilter#tail(Node, int)}. */\n        SKIP_ENTIRELY,\n        /** Remove the node and its children */\n        REMOVE,\n        /** Stop processing */\n        STOP\n    }\n\n    /**\n     * Callback for when a node is first visited.\n     * @param node the node being visited.\n     * @param depth the depth of the node, relative to the root node. E.g., the root node has depth 0, and a child node of that will have depth 1.\n     * @return Filter decision\n     */\n    FilterResult head(Node node, int depth);\n\n    /**\n     * Callback for when a node is last visited, after all of its descendants have been visited.\n     * <p>This method has a default implementation to return {@link FilterResult#CONTINUE}.</p>\n     * @param node the node being visited.\n     * @param depth the depth of the node, relative to the root node. E.g., the root node has depth 0, and a child node of that will have depth 1.\n     * @return Filter decision\n     */\n    default FilterResult tail(Node node, int depth) {\n        return FilterResult.CONTINUE;\n    }\n}"}, {"uris": "src/main/java/org/jsoup/select/NodeVisitor.java.NodeVisitor", "name": "NodeVisitor", "file_path": "src/main/java/org/jsoup/select/NodeVisitor.java", "superclasses": [], "methods": ["[void]head(Node,int)", "[void]tail(Node,int)"], "method_uris": ["src/main/java/org/jsoup/select/NodeVisitor.java.NodeVisitor.[void]head(Node,int)", "src/main/java/org/jsoup/select/NodeVisitor.java.NodeVisitor.[void]tail(Node,int)"], "overrides": null, "attributes": null, "class_docstring": "\nNode visitor interface. Provide an implementing class to {@link NodeTraversor} or to {@link Node#traverse(NodeVisitor)}\nto iterate through nodes.\n<p>\nThis interface provides two methods, {@link #head} and {@link #tail}. The head method is called when the node is first\nseen, and the tail method when all of the node's children have been visited. As an example, {@code head} can be used to\nemit a start tag for a node, and {@code tail} to create the end tag. The {@code tail} method defaults to a no-op, so\nthe {@code head} method is the {@link FunctionalInterface}.\n</p>\n<p><b>Example:</b></p>\n<pre><code>\ndoc.body().traverse((node, depth) -> {\nswitch (node) {\ncase Element el     -> print(el.tag() + \": \" + el.ownText());\ncase DataNode data  -> print(\"Data: \" + data.getWholeData());\ndefault             -> print(node.nodeName() + \" at depth \" + depth);\n}\n});\n</code></pre>\n", "original_string": "@FunctionalInterface\npublic interface NodeVisitor {\n    /**\n     Callback for when a node is first visited.\n     <p>The node may be modified (e.g. {@link Node#attr(String)}, replaced {@link Node#replaceWith(Node)}) or removed\n     {@link Node#remove()}. If it's {@code instanceOf Element}, you may cast it to an {@link Element} and access those\n     methods.</p>\n\n     @param node the node being visited.\n     @param depth the depth of the node, relative to the root node. E.g., the root node has depth 0, and a child node\n     of that will have depth 1.\n     */\n    void head(Node node, int depth);\n\n    /**\n     Callback for when a node is last visited, after all of its descendants have been visited.\n     <p>This method has a default no-op implementation.</p>\n     <p>Note that neither replacement with {@link Node#replaceWith(Node)} nor removal with {@link Node#remove()} is\n     supported during {@code tail()}.\n\n     @param node the node being visited.\n     @param depth the depth of the node, relative to the root node. E.g., the root node has depth 0, and a child node\n     of that will have depth 1.\n     */\n    default void tail(Node node, int depth) {\n        // no-op by default, to allow just specifying the head() method\n    }\n}"}]