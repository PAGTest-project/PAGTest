[{"uris": "src/test/java/org/jsoup/integration/servlets/BaseServlet.java.BaseServlet", "name": "BaseServlet", "file_path": "src/test/java/org/jsoup/integration/servlets/BaseServlet.java", "superclasses": "HttpServlet", "methods": ["[void]doIt(HttpServletRequest,HttpServletResponse)", "[void]doGet(HttpServletRequest,HttpServletResponse)", "[void]doPost(HttpServletRequest,HttpServletResponse)", "[void]doPut(HttpServletRequest,HttpServletResponse)", "[void]doDelete(HttpServletRequest,HttpServletResponse)"], "method_uris": ["src/test/java/org/jsoup/integration/servlets/BaseServlet.java.BaseServlet.[void]doIt(HttpServletRequest,HttpServletResponse)", "src/test/java/org/jsoup/integration/servlets/BaseServlet.java.BaseServlet.[void]doGet(HttpServletRequest,HttpServletResponse)", "src/test/java/org/jsoup/integration/servlets/BaseServlet.java.BaseServlet.[void]doPost(HttpServletRequest,HttpServletResponse)", "src/test/java/org/jsoup/integration/servlets/BaseServlet.java.BaseServlet.[void]doPut(HttpServletRequest,HttpServletResponse)", "src/test/java/org/jsoup/integration/servlets/BaseServlet.java.BaseServlet.[void]doDelete(HttpServletRequest,HttpServletResponse)"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public abstract class BaseServlet extends HttpServlet {\n    static final String TextHtml = \"text/html; charset=UTF-8\";\n\n    abstract protected void doIt(HttpServletRequest req, HttpServletResponse res) throws IOException, ServletException;\n\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse res) throws IOException, ServletException {\n        doIt(req, res);\n    }\n\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse res) throws IOException, ServletException {\n        doIt(req, res);\n    }\n\n    @Override\n    protected void doPut(HttpServletRequest req, HttpServletResponse res) throws IOException, ServletException {\n        doIt(req, res);\n    }\n\n    @Override\n    protected void doDelete(HttpServletRequest req, HttpServletResponse res) throws IOException, ServletException {\n        doIt(req, res);\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "static final String TextHtml = \"text/html; charset=UTF-8\";", "docstring": "", "modifiers": "static final", "marker_annotations": [], "non_marker_annotations": ["static", "final"], "comments": [], "type": "String", "name": "TextHtml = \"text/html; charset=UTF-8\"", "syntax_pass": true}]}, {"uris": "src/main/java/org/jsoup/helper/ChangeNotifyingArrayList.java.ChangeNotifyingArrayList", "name": "ChangeNotifyingArrayList", "file_path": "src/main/java/org/jsoup/helper/ChangeNotifyingArrayList.java", "superclasses": "", "methods": ["[]ChangeNotifyingArrayList(int)", "[void]onContentsChanged()", "[E]set(int,E)", "[boolean]add(E)", "[void]add(int,E)", "[E]remove(int)", "[boolean]remove(Object)", "[void]clear()", "[boolean]addAll(Collection<? extends E>)", "[boolean]addAll(int,Collection<? extends E>)", "[void]removeRange(int,int)", "[boolean]removeAll(Collection<?>)", "[boolean]retainAll(Collection<?>)"], "method_uris": ["src/main/java/org/jsoup/helper/ChangeNotifyingArrayList.java.ChangeNotifyingArrayList.[]ChangeNotifyingArrayList(int)", "src/main/java/org/jsoup/helper/ChangeNotifyingArrayList.java.ChangeNotifyingArrayList.[void]onContentsChanged()", "src/main/java/org/jsoup/helper/ChangeNotifyingArrayList.java.ChangeNotifyingArrayList.[E]set(int,E)", "src/main/java/org/jsoup/helper/ChangeNotifyingArrayList.java.ChangeNotifyingArrayList.[boolean]add(E)", "src/main/java/org/jsoup/helper/ChangeNotifyingArrayList.java.ChangeNotifyingArrayList.[void]add(int,E)", "src/main/java/org/jsoup/helper/ChangeNotifyingArrayList.java.ChangeNotifyingArrayList.[E]remove(int)", "src/main/java/org/jsoup/helper/ChangeNotifyingArrayList.java.ChangeNotifyingArrayList.[boolean]remove(Object)", "src/main/java/org/jsoup/helper/ChangeNotifyingArrayList.java.ChangeNotifyingArrayList.[void]clear()", "src/main/java/org/jsoup/helper/ChangeNotifyingArrayList.java.ChangeNotifyingArrayList.[boolean]addAll(Collection<? extends E>)", "src/main/java/org/jsoup/helper/ChangeNotifyingArrayList.java.ChangeNotifyingArrayList.[boolean]addAll(int,Collection<? extends E>)", "src/main/java/org/jsoup/helper/ChangeNotifyingArrayList.java.ChangeNotifyingArrayList.[void]removeRange(int,int)", "src/main/java/org/jsoup/helper/ChangeNotifyingArrayList.java.ChangeNotifyingArrayList.[boolean]removeAll(Collection<?>)", "src/main/java/org/jsoup/helper/ChangeNotifyingArrayList.java.ChangeNotifyingArrayList.[boolean]retainAll(Collection<?>)"], "overrides": null, "attributes": [], "class_docstring": "\nImplementation of ArrayList that watches out for changes to the contents.\n", "original_string": "public abstract class ChangeNotifyingArrayList<E> extends ArrayList<E> {\n    public ChangeNotifyingArrayList(int initialCapacity) {\n        super(initialCapacity);\n    }\n\n    public abstract void onContentsChanged();\n\n    @Override\n    public E set(int index, E element) {\n        onContentsChanged();\n        return super.set(index, element);\n    }\n\n    @Override\n    public boolean add(E e) {\n        onContentsChanged();\n        return super.add(e);\n    }\n\n    @Override\n    public void add(int index, E element) {\n        onContentsChanged();\n        super.add(index, element);\n    }\n\n    @Override\n    public E remove(int index) {\n        onContentsChanged();\n        return super.remove(index);\n    }\n\n    @Override\n    public boolean remove(Object o) {\n        onContentsChanged();\n        return super.remove(o);\n    }\n\n    @Override\n    public void clear() {\n        onContentsChanged();\n        super.clear();\n    }\n\n    @Override\n    public boolean addAll(Collection<? extends E> c) {\n        onContentsChanged();\n        return super.addAll(c);\n    }\n\n    @Override\n    public boolean addAll(int index, Collection<? extends E> c) {\n        onContentsChanged();\n        return super.addAll(index, c);\n    }\n\n    @Override\n    protected void removeRange(int fromIndex, int toIndex) {\n        onContentsChanged();\n        super.removeRange(fromIndex, toIndex);\n    }\n\n    @Override\n    public boolean removeAll(Collection<?> c) {\n        onContentsChanged();\n        return super.removeAll(c);\n    }\n\n    @Override\n    public boolean retainAll(Collection<?> c) {\n        onContentsChanged();\n        return super.retainAll(c);\n    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/main/java/org/jsoup/select/CombiningEvaluator.java.CombiningEvaluator", "name": "CombiningEvaluator", "file_path": "src/main/java/org/jsoup/select/CombiningEvaluator.java", "superclasses": "Evaluator", "methods": ["[]CombiningEvaluator()", "[]CombiningEvaluator(Collection<Evaluator>)", "[void]reset()", "[int]cost()", "[Evaluator]rightMostEvaluator()", "[void]replaceRightMostEvaluator(Evaluator)", "[void]updateEvaluators()"], "method_uris": ["src/main/java/org/jsoup/select/CombiningEvaluator.java.CombiningEvaluator.[]CombiningEvaluator()", "src/main/java/org/jsoup/select/CombiningEvaluator.java.CombiningEvaluator.[]CombiningEvaluator(Collection<Evaluator>)", "src/main/java/org/jsoup/select/CombiningEvaluator.java.CombiningEvaluator.[void]reset()", "src/main/java/org/jsoup/select/CombiningEvaluator.java.CombiningEvaluator.[int]cost()", "src/main/java/org/jsoup/select/CombiningEvaluator.java.CombiningEvaluator.[Evaluator]rightMostEvaluator()", "src/main/java/org/jsoup/select/CombiningEvaluator.java.CombiningEvaluator.[void]replaceRightMostEvaluator(Evaluator)", "src/main/java/org/jsoup/select/CombiningEvaluator.java.CombiningEvaluator.[void]updateEvaluators()"], "overrides": null, "attributes": [{"original_string": "    public static final class And extends CombiningEvaluator {\n        And(Collection<Evaluator> evaluators) {\n            super(evaluators);\n        }\n\n        And(Evaluator... evaluators) {\n            this(Arrays.asList(evaluators));\n        }\n\n        @Override\n        public boolean matches(Element root, Element element) {\n            for (int i = 0; i < num; i++) {\n                Evaluator s = sortedEvaluators.get(i);\n                if (!s.matches(root, element))\n                    return false;\n            }\n            return true;\n        }\n\n        @Override\n        public String toString() {\n            return StringUtil.join(evaluators, \"\");\n        }\n    }", "definition": "    public static final class And extends CombiningEvaluator", "class_docstring": "", "name": "And", "super_interfaces": [], "superclasses": "CombiningEvaluator", "attributes": {"modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        And(Collection<Evaluator> evaluators) {\n            super(evaluators);\n        }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "And", "params": [{"name": "evaluators", "type": "Collection<Evaluator>"}], "body": "                                              {\n            super(evaluators);\n        }", "signature": "And(Collection<Evaluator> evaluators)"}, {"syntax_pass": true, "original_string": "        And(Evaluator... evaluators) {\n            this(Arrays.asList(evaluators));\n        }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "And", "params": [], "body": "                                     {\n            this(Arrays.asList(evaluators));\n        }", "signature": "And(Evaluator... evaluators)"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean matches(Element root, Element element) {\n            for (int i = 0; i < num; i++) {\n                Evaluator s = sortedEvaluators.get(i);\n                if (!s.matches(root, element))\n                    return false;\n            }\n            return true;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "matches", "params": [{"name": "root", "type": "Element"}, {"name": "element", "type": "Element"}], "body": "                                                              {\n            for (int i = 0; i < num; i++) {\n                Evaluator s = sortedEvaluators.get(i);\n                if (!s.matches(root, element))\n                    return false;\n            }\n            return true;\n        }", "signature": "@Override\n        public boolean matches(Element root, Element element)"}, {"syntax_pass": true, "original_string": "        @Override\n        public String toString() {\n            return StringUtil.join(evaluators, \"\");\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "toString", "params": [], "body": "                                 {\n            return StringUtil.join(evaluators, \"\");\n        }", "signature": "@Override\n        public String toString()"}]}, {"original_string": "    public static final class Or extends CombiningEvaluator {\n        /**\n         * Create a new Or evaluator. The initial evaluators are ANDed together and used as the first clause of the OR.\n         * @param evaluators initial OR clause (these are wrapped into an AND evaluator).\n         */\n        Or(Collection<Evaluator> evaluators) {\n            super();\n            if (num > 1)\n                this.evaluators.add(new And(evaluators));\n            else // 0 or 1\n                this.evaluators.addAll(evaluators);\n            updateEvaluators();\n        }\n\n        Or(Evaluator... evaluators) { this(Arrays.asList(evaluators)); }\n\n        Or() {\n            super();\n        }\n\n        public void add(Evaluator e) {\n            evaluators.add(e);\n            updateEvaluators();\n        }\n\n        @Override\n        public boolean matches(Element root, Element node) {\n            for (int i = 0; i < num; i++) {\n                Evaluator s = sortedEvaluators.get(i);\n                if (s.matches(root, node))\n                    return true;\n            }\n            return false;\n        }\n\n        @Override\n        public String toString() {\n            return StringUtil.join(evaluators, \", \");\n        }\n    }", "definition": "    public static final class Or extends CombiningEvaluator", "class_docstring": "", "name": "Or", "super_interfaces": [], "superclasses": "CombiningEvaluator", "attributes": {"modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        Or(Collection<Evaluator> evaluators) {\n            super();\n            if (num > 1)\n                this.evaluators.add(new And(evaluators));\n            else // 0 or 1\n                this.evaluators.addAll(evaluators);\n            updateEvaluators();\n        }", "docstring": "\nCreate a new Or evaluator. The initial evaluators are ANDed together and used as the first clause of the OR.\n@param evaluators initial OR clause (these are wrapped into an AND evaluator).\n", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "Or", "params": [{"name": "evaluators", "type": "Collection<Evaluator>"}], "body": "                                             {\n            super();\n            if (num > 1)\n                this.evaluators.add(new And(evaluators));\n            else // 0 or 1\n                this.evaluators.addAll(evaluators);\n            updateEvaluators();\n        }", "signature": "Or(Collection<Evaluator> evaluators)"}, {"syntax_pass": true, "original_string": "        Or(Evaluator... evaluators) { this(Arrays.asList(evaluators)); }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "Or", "params": [], "body": "                                    { this(Arrays.asList(evaluators)); }", "signature": "Or(Evaluator... evaluators)"}, {"syntax_pass": true, "original_string": "        Or() {\n            super();\n        }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "Or", "params": [], "body": "             {\n            super();\n        }", "signature": "Or()"}, {"syntax_pass": true, "original_string": "        public void add(Evaluator e) {\n            evaluators.add(e);\n            updateEvaluators();\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "add", "params": [{"name": "e", "type": "Evaluator"}], "body": "                                     {\n            evaluators.add(e);\n            updateEvaluators();\n        }", "signature": "public void add(Evaluator e)"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean matches(Element root, Element node) {\n            for (int i = 0; i < num; i++) {\n                Evaluator s = sortedEvaluators.get(i);\n                if (s.matches(root, node))\n                    return true;\n            }\n            return false;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "matches", "params": [{"name": "root", "type": "Element"}, {"name": "node", "type": "Element"}], "body": "                                                           {\n            for (int i = 0; i < num; i++) {\n                Evaluator s = sortedEvaluators.get(i);\n                if (s.matches(root, node))\n                    return true;\n            }\n            return false;\n        }", "signature": "@Override\n        public boolean matches(Element root, Element node)"}, {"syntax_pass": true, "original_string": "        @Override\n        public String toString() {\n            return StringUtil.join(evaluators, \", \");\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "toString", "params": [], "body": "                                 {\n            return StringUtil.join(evaluators, \", \");\n        }", "signature": "@Override\n        public String toString()"}]}], "class_docstring": "\nBase combining (and, or) evaluator.\n", "original_string": "public abstract class CombiningEvaluator extends Evaluator {\n    final ArrayList<Evaluator> evaluators; // maintain original order so that #toString() is sensible\n    final List<Evaluator> sortedEvaluators; // cost ascending order\n    int num = 0;\n    int cost = 0;\n\n    CombiningEvaluator() {\n        super();\n        evaluators = new ArrayList<>();\n        sortedEvaluators = new ArrayList<>();\n    }\n\n    CombiningEvaluator(Collection<Evaluator> evaluators) {\n        this();\n        this.evaluators.addAll(evaluators);\n        updateEvaluators();\n    }\n\n    @Override protected void reset() {\n        for (Evaluator evaluator : evaluators) {\n            evaluator.reset();\n        }\n        super.reset();\n    }\n\n    @Override protected int cost() {\n        return cost;\n    }\n\n    @Nullable Evaluator rightMostEvaluator() {\n        return num > 0 ? evaluators.get(num - 1) : null;\n    }\n    \n    void replaceRightMostEvaluator(Evaluator replacement) {\n        evaluators.set(num - 1, replacement);\n        updateEvaluators();\n    }\n\n    void updateEvaluators() {\n        // used so we don't need to bash on size() for every match test\n        num = evaluators.size();\n\n        // sort the evaluators by lowest cost first, to optimize the evaluation order\n        cost = 0;\n        for (Evaluator evaluator : evaluators) {\n            cost += evaluator.cost();\n        }\n        sortedEvaluators.clear();\n        sortedEvaluators.addAll(evaluators);\n        sortedEvaluators.sort(Comparator.comparingInt(Evaluator::cost));\n    }\n\n    public static final class And extends CombiningEvaluator {\n        And(Collection<Evaluator> evaluators) {\n            super(evaluators);\n        }\n\n        And(Evaluator... evaluators) {\n            this(Arrays.asList(evaluators));\n        }\n\n        @Override\n        public boolean matches(Element root, Element element) {\n            for (int i = 0; i < num; i++) {\n                Evaluator s = sortedEvaluators.get(i);\n                if (!s.matches(root, element))\n                    return false;\n            }\n            return true;\n        }\n\n        @Override\n        public String toString() {\n            return StringUtil.join(evaluators, \"\");\n        }\n    }\n\n    public static final class Or extends CombiningEvaluator {\n        /**\n         * Create a new Or evaluator. The initial evaluators are ANDed together and used as the first clause of the OR.\n         * @param evaluators initial OR clause (these are wrapped into an AND evaluator).\n         */\n        Or(Collection<Evaluator> evaluators) {\n            super();\n            if (num > 1)\n                this.evaluators.add(new And(evaluators));\n            else // 0 or 1\n                this.evaluators.addAll(evaluators);\n            updateEvaluators();\n        }\n\n        Or(Evaluator... evaluators) { this(Arrays.asList(evaluators)); }\n\n        Or() {\n            super();\n        }\n\n        public void add(Evaluator e) {\n            evaluators.add(e);\n            updateEvaluators();\n        }\n\n        @Override\n        public boolean matches(Element root, Element node) {\n            for (int i = 0; i < num; i++) {\n                Evaluator s = sortedEvaluators.get(i);\n                if (s.matches(root, node))\n                    return true;\n            }\n            return false;\n        }\n\n        @Override\n        public String toString() {\n            return StringUtil.join(evaluators, \", \");\n        }\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "final ArrayList<Evaluator> evaluators;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "ArrayList<Evaluator>", "name": "evaluators", "syntax_pass": true}, {"attribute_expression": "final List<Evaluator> sortedEvaluators;", "docstring": " maintain original order so that #toString() is sensible", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "List<Evaluator>", "name": "sortedEvaluators", "syntax_pass": true}, {"attribute_expression": "int num = 0;", "docstring": " cost ascending order", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "int", "name": "num = 0", "syntax_pass": true}, {"attribute_expression": "int cost = 0;", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "int", "name": "cost = 0", "syntax_pass": true}]}, {"uris": "src/main/java/org/jsoup/select/Evaluator.java.Evaluator", "name": "Evaluator", "file_path": "src/main/java/org/jsoup/select/Evaluator.java", "superclasses": "", "methods": ["[]Evaluator()", "[Predicate<Element>]asPredicate(Element)", "[boolean]matches(Element,Element)", "[void]reset()", "[int]cost()"], "method_uris": ["src/main/java/org/jsoup/select/Evaluator.java.Evaluator.[]Evaluator()", "src/main/java/org/jsoup/select/Evaluator.java.Evaluator.[Predicate<Element>]asPredicate(Element)", "src/main/java/org/jsoup/select/Evaluator.java.Evaluator.[boolean]matches(Element,Element)", "src/main/java/org/jsoup/select/Evaluator.java.Evaluator.[void]reset()", "src/main/java/org/jsoup/select/Evaluator.java.Evaluator.[int]cost()"], "overrides": null, "attributes": [{"original_string": "    public static final class Tag extends Evaluator {\n        private final String tagName;\n\n        public Tag(String tagName) {\n            this.tagName = tagName;\n        }\n\n        @Override\n        public boolean matches(Element root, Element element) {\n            return (element.nameIs(tagName));\n        }\n\n        @Override protected int cost() {\n            return 1;\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\"%s\", tagName);\n        }\n    }", "definition": "    public static final class Tag extends Evaluator", "class_docstring": "\nEvaluator for tag name\n", "name": "Tag", "super_interfaces": [], "superclasses": "Evaluator", "attributes": {"modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "fields": [{"attribute_expression": "private final String tagName;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "tagName", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        public Tag(String tagName) {\n            this.tagName = tagName;\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "Tag", "params": [{"name": "tagName", "type": "String"}], "body": "                                   {\n            this.tagName = tagName;\n        }", "signature": "public Tag(String tagName)"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean matches(Element root, Element element) {\n            return (element.nameIs(tagName));\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "matches", "params": [{"name": "root", "type": "Element"}, {"name": "element", "type": "Element"}], "body": "                                                              {\n            return (element.nameIs(tagName));\n        }", "signature": "@Override\n        public boolean matches(Element root, Element element)"}, {"syntax_pass": true, "original_string": "        @Override protected int cost() {\n            return 1;\n        }", "docstring": "", "attributes": {"modifiers": "@Override protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "int", "classes": []}, "name": "cost", "params": [], "body": "                                       {\n            return 1;\n        }", "signature": "@Override protected int cost()"}, {"syntax_pass": true, "original_string": "        @Override\n        public String toString() {\n            return String.format(\"%s\", tagName);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "toString", "params": [], "body": "                                 {\n            return String.format(\"%s\", tagName);\n        }", "signature": "@Override\n        public String toString()"}]}, {"original_string": "    public static final class TagStartsWith extends Evaluator {\n        private final String tagName;\n\n        public TagStartsWith(String tagName) {\n            this.tagName = tagName;\n        }\n\n        @Override\n        public boolean matches(Element root, Element element) {\n            return (element.normalName().startsWith(tagName));\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\"%s\", tagName);\n        }\n    }", "definition": "    public static final class TagStartsWith extends Evaluator", "class_docstring": "\nEvaluator for tag name that starts with prefix; used for ns|*\n", "name": "TagStartsWith", "super_interfaces": [], "superclasses": "Evaluator", "attributes": {"modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "fields": [{"attribute_expression": "private final String tagName;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "tagName", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        public TagStartsWith(String tagName) {\n            this.tagName = tagName;\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "TagStartsWith", "params": [{"name": "tagName", "type": "String"}], "body": "                                             {\n            this.tagName = tagName;\n        }", "signature": "public TagStartsWith(String tagName)"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean matches(Element root, Element element) {\n            return (element.normalName().startsWith(tagName));\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "matches", "params": [{"name": "root", "type": "Element"}, {"name": "element", "type": "Element"}], "body": "                                                              {\n            return (element.normalName().startsWith(tagName));\n        }", "signature": "@Override\n        public boolean matches(Element root, Element element)"}, {"syntax_pass": true, "original_string": "        @Override\n        public String toString() {\n            return String.format(\"%s\", tagName);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "toString", "params": [], "body": "                                 {\n            return String.format(\"%s\", tagName);\n        }", "signature": "@Override\n        public String toString()"}]}, {"original_string": "    public static final class TagEndsWith extends Evaluator {\n        private final String tagName;\n\n        public TagEndsWith(String tagName) {\n            this.tagName = tagName;\n        }\n\n        @Override\n        public boolean matches(Element root, Element element) {\n            return (element.normalName().endsWith(tagName));\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\"%s\", tagName);\n        }\n    }", "definition": "    public static final class TagEndsWith extends Evaluator", "class_docstring": "\nEvaluator for tag name that ends with suffix; used for *|el\n", "name": "TagEndsWith", "super_interfaces": [], "superclasses": "Evaluator", "attributes": {"modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "fields": [{"attribute_expression": "private final String tagName;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "tagName", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        public TagEndsWith(String tagName) {\n            this.tagName = tagName;\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "TagEndsWith", "params": [{"name": "tagName", "type": "String"}], "body": "                                           {\n            this.tagName = tagName;\n        }", "signature": "public TagEndsWith(String tagName)"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean matches(Element root, Element element) {\n            return (element.normalName().endsWith(tagName));\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "matches", "params": [{"name": "root", "type": "Element"}, {"name": "element", "type": "Element"}], "body": "                                                              {\n            return (element.normalName().endsWith(tagName));\n        }", "signature": "@Override\n        public boolean matches(Element root, Element element)"}, {"syntax_pass": true, "original_string": "        @Override\n        public String toString() {\n            return String.format(\"%s\", tagName);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "toString", "params": [], "body": "                                 {\n            return String.format(\"%s\", tagName);\n        }", "signature": "@Override\n        public String toString()"}]}, {"original_string": "    public static final class Id extends Evaluator {\n        private final String id;\n\n        public Id(String id) {\n            this.id = id;\n        }\n\n        @Override\n        public boolean matches(Element root, Element element) {\n            return (id.equals(element.id()));\n        }\n\n        @Override protected int cost() {\n            return 2;\n        }\n        @Override\n        public String toString() {\n            return String.format(\"#%s\", id);\n        }\n    }", "definition": "    public static final class Id extends Evaluator", "class_docstring": "\nEvaluator for element id\n", "name": "Id", "super_interfaces": [], "superclasses": "Evaluator", "attributes": {"modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "fields": [{"attribute_expression": "private final String id;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "id", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        public Id(String id) {\n            this.id = id;\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "Id", "params": [{"name": "id", "type": "String"}], "body": "                             {\n            this.id = id;\n        }", "signature": "public Id(String id)"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean matches(Element root, Element element) {\n            return (id.equals(element.id()));\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "matches", "params": [{"name": "root", "type": "Element"}, {"name": "element", "type": "Element"}], "body": "                                                              {\n            return (id.equals(element.id()));\n        }", "signature": "@Override\n        public boolean matches(Element root, Element element)"}, {"syntax_pass": true, "original_string": "        @Override protected int cost() {\n            return 2;\n        }", "docstring": "", "attributes": {"modifiers": "@Override protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "int", "classes": []}, "name": "cost", "params": [], "body": "                                       {\n            return 2;\n        }", "signature": "@Override protected int cost()"}, {"syntax_pass": true, "original_string": "        @Override\n        public String toString() {\n            return String.format(\"#%s\", id);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "toString", "params": [], "body": "                                 {\n            return String.format(\"#%s\", id);\n        }", "signature": "@Override\n        public String toString()"}]}, {"original_string": "    public static final class Class extends Evaluator {\n        private final String className;\n\n        public Class(String className) {\n            this.className = className;\n        }\n\n        @Override\n        public boolean matches(Element root, Element element) {\n            return (element.hasClass(className));\n        }\n\n        @Override protected int cost() {\n            return 6; // does whitespace scanning\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\".%s\", className);\n        }\n\n    }", "definition": "    public static final class Class extends Evaluator", "class_docstring": "\nEvaluator for element class\n", "name": "Class", "super_interfaces": [], "superclasses": "Evaluator", "attributes": {"modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "fields": [{"attribute_expression": "private final String className;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "className", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        public Class(String className) {\n            this.className = className;\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "Class", "params": [{"name": "className", "type": "String"}], "body": "                                       {\n            this.className = className;\n        }", "signature": "public Class(String className)"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean matches(Element root, Element element) {\n            return (element.hasClass(className));\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "matches", "params": [{"name": "root", "type": "Element"}, {"name": "element", "type": "Element"}], "body": "                                                              {\n            return (element.hasClass(className));\n        }", "signature": "@Override\n        public boolean matches(Element root, Element element)"}, {"syntax_pass": true, "original_string": "        @Override protected int cost() {\n            return 6; // does whitespace scanning\n        }", "docstring": "", "attributes": {"modifiers": "@Override protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "int", "classes": []}, "name": "cost", "params": [], "body": "                                       {\n            return 6; // does whitespace scanning\n        }", "signature": "@Override protected int cost()"}, {"syntax_pass": true, "original_string": "        @Override\n        public String toString() {\n            return String.format(\".%s\", className);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "toString", "params": [], "body": "                                 {\n            return String.format(\".%s\", className);\n        }", "signature": "@Override\n        public String toString()"}]}, {"original_string": "    public static final class Attribute extends Evaluator {\n        private final String key;\n\n        public Attribute(String key) {\n            this.key = key;\n        }\n\n        @Override\n        public boolean matches(Element root, Element element) {\n            return element.hasAttr(key);\n        }\n\n        @Override protected int cost() {\n            return 2;\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\"[%s]\", key);\n        }\n    }", "definition": "    public static final class Attribute extends Evaluator", "class_docstring": "\nEvaluator for attribute name matching\n", "name": "Attribute", "super_interfaces": [], "superclasses": "Evaluator", "attributes": {"modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "fields": [{"attribute_expression": "private final String key;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "key", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        public Attribute(String key) {\n            this.key = key;\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "Attribute", "params": [{"name": "key", "type": "String"}], "body": "                                     {\n            this.key = key;\n        }", "signature": "public Attribute(String key)"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean matches(Element root, Element element) {\n            return element.hasAttr(key);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "matches", "params": [{"name": "root", "type": "Element"}, {"name": "element", "type": "Element"}], "body": "                                                              {\n            return element.hasAttr(key);\n        }", "signature": "@Override\n        public boolean matches(Element root, Element element)"}, {"syntax_pass": true, "original_string": "        @Override protected int cost() {\n            return 2;\n        }", "docstring": "", "attributes": {"modifiers": "@Override protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "int", "classes": []}, "name": "cost", "params": [], "body": "                                       {\n            return 2;\n        }", "signature": "@Override protected int cost()"}, {"syntax_pass": true, "original_string": "        @Override\n        public String toString() {\n            return String.format(\"[%s]\", key);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "toString", "params": [], "body": "                                 {\n            return String.format(\"[%s]\", key);\n        }", "signature": "@Override\n        public String toString()"}]}, {"original_string": "    public static final class AttributeStarting extends Evaluator {\n        private final String keyPrefix;\n\n        public AttributeStarting(String keyPrefix) {\n            Validate.notNull(keyPrefix); // OK to be empty - will find elements with any attributes\n            this.keyPrefix = lowerCase(keyPrefix);\n        }\n\n        @Override\n        public boolean matches(Element root, Element element) {\n            List<org.jsoup.nodes.Attribute> values = element.attributes().asList();\n            for (org.jsoup.nodes.Attribute attribute : values) {\n                if (lowerCase(attribute.getKey()).startsWith(keyPrefix))\n                    return true;\n            }\n            return false;\n        }\n\n        @Override protected int cost() {\n            return 6;\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\"[^%s]\", keyPrefix);\n        }\n\n    }", "definition": "    public static final class AttributeStarting extends Evaluator", "class_docstring": "\nEvaluator for attribute name prefix matching\n", "name": "AttributeStarting", "super_interfaces": [], "superclasses": "Evaluator", "attributes": {"modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "fields": [{"attribute_expression": "private final String keyPrefix;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "keyPrefix", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        public AttributeStarting(String keyPrefix) {\n            Validate.notNull(keyPrefix); // OK to be empty - will find elements with any attributes\n            this.keyPrefix = lowerCase(keyPrefix);\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "AttributeStarting", "params": [{"name": "keyPrefix", "type": "String"}], "body": "                                                   {\n            Validate.notNull(keyPrefix); // OK to be empty - will find elements with any attributes\n            this.keyPrefix = lowerCase(keyPrefix);\n        }", "signature": "public AttributeStarting(String keyPrefix)"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean matches(Element root, Element element) {\n            List<org.jsoup.nodes.Attribute> values = element.attributes().asList();\n            for (org.jsoup.nodes.Attribute attribute : values) {\n                if (lowerCase(attribute.getKey()).startsWith(keyPrefix))\n                    return true;\n            }\n            return false;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "matches", "params": [{"name": "root", "type": "Element"}, {"name": "element", "type": "Element"}], "body": "                                                              {\n            List<org.jsoup.nodes.Attribute> values = element.attributes().asList();\n            for (org.jsoup.nodes.Attribute attribute : values) {\n                if (lowerCase(attribute.getKey()).startsWith(keyPrefix))\n                    return true;\n            }\n            return false;\n        }", "signature": "@Override\n        public boolean matches(Element root, Element element)"}, {"syntax_pass": true, "original_string": "        @Override protected int cost() {\n            return 6;\n        }", "docstring": "", "attributes": {"modifiers": "@Override protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "int", "classes": []}, "name": "cost", "params": [], "body": "                                       {\n            return 6;\n        }", "signature": "@Override protected int cost()"}, {"syntax_pass": true, "original_string": "        @Override\n        public String toString() {\n            return String.format(\"[^%s]\", keyPrefix);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "toString", "params": [], "body": "                                 {\n            return String.format(\"[^%s]\", keyPrefix);\n        }", "signature": "@Override\n        public String toString()"}]}, {"original_string": "    public static final class AttributeWithValue extends AttributeKeyPair {\n        public AttributeWithValue(String key, String value) {\n            super(key, value);\n        }\n\n        @Override\n        public boolean matches(Element root, Element element) {\n            return element.hasAttr(key) && value.equalsIgnoreCase(element.attr(key).trim());\n        }\n\n        @Override protected int cost() {\n            return 3;\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\"[%s=%s]\", key, value);\n        }\n\n    }", "definition": "    public static final class AttributeWithValue extends AttributeKeyPair", "class_docstring": "\nEvaluator for attribute name/value matching\n", "name": "AttributeWithValue", "super_interfaces": [], "superclasses": "AttributeKeyPair", "attributes": {"modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        public AttributeWithValue(String key, String value) {\n            super(key, value);\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "AttributeWithValue", "params": [{"name": "key", "type": "String"}, {"name": "value", "type": "String"}], "body": "                                                            {\n            super(key, value);\n        }", "signature": "public AttributeWithValue(String key, String value)"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean matches(Element root, Element element) {\n            return element.hasAttr(key) && value.equalsIgnoreCase(element.attr(key).trim());\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "matches", "params": [{"name": "root", "type": "Element"}, {"name": "element", "type": "Element"}], "body": "                                                              {\n            return element.hasAttr(key) && value.equalsIgnoreCase(element.attr(key).trim());\n        }", "signature": "@Override\n        public boolean matches(Element root, Element element)"}, {"syntax_pass": true, "original_string": "        @Override protected int cost() {\n            return 3;\n        }", "docstring": "", "attributes": {"modifiers": "@Override protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "int", "classes": []}, "name": "cost", "params": [], "body": "                                       {\n            return 3;\n        }", "signature": "@Override protected int cost()"}, {"syntax_pass": true, "original_string": "        @Override\n        public String toString() {\n            return String.format(\"[%s=%s]\", key, value);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "toString", "params": [], "body": "                                 {\n            return String.format(\"[%s=%s]\", key, value);\n        }", "signature": "@Override\n        public String toString()"}]}, {"original_string": "    public static final class AttributeWithValueNot extends AttributeKeyPair {\n        public AttributeWithValueNot(String key, String value) {\n            super(key, value);\n        }\n\n        @Override\n        public boolean matches(Element root, Element element) {\n            return !value.equalsIgnoreCase(element.attr(key));\n        }\n\n        @Override protected int cost() {\n            return 3;\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\"[%s!=%s]\", key, value);\n        }\n\n    }", "definition": "    public static final class AttributeWithValueNot extends AttributeKeyPair", "class_docstring": "\nEvaluator for attribute name != value matching\n", "name": "AttributeWithValueNot", "super_interfaces": [], "superclasses": "AttributeKeyPair", "attributes": {"modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        public AttributeWithValueNot(String key, String value) {\n            super(key, value);\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "AttributeWithValueNot", "params": [{"name": "key", "type": "String"}, {"name": "value", "type": "String"}], "body": "                                                               {\n            super(key, value);\n        }", "signature": "public AttributeWithValueNot(String key, String value)"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean matches(Element root, Element element) {\n            return !value.equalsIgnoreCase(element.attr(key));\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "matches", "params": [{"name": "root", "type": "Element"}, {"name": "element", "type": "Element"}], "body": "                                                              {\n            return !value.equalsIgnoreCase(element.attr(key));\n        }", "signature": "@Override\n        public boolean matches(Element root, Element element)"}, {"syntax_pass": true, "original_string": "        @Override protected int cost() {\n            return 3;\n        }", "docstring": "", "attributes": {"modifiers": "@Override protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "int", "classes": []}, "name": "cost", "params": [], "body": "                                       {\n            return 3;\n        }", "signature": "@Override protected int cost()"}, {"syntax_pass": true, "original_string": "        @Override\n        public String toString() {\n            return String.format(\"[%s!=%s]\", key, value);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "toString", "params": [], "body": "                                 {\n            return String.format(\"[%s!=%s]\", key, value);\n        }", "signature": "@Override\n        public String toString()"}]}, {"original_string": "    public static final class AttributeWithValueStarting extends AttributeKeyPair {\n        public AttributeWithValueStarting(String key, String value) {\n            super(key, value, false);\n        }\n\n        @Override\n        public boolean matches(Element root, Element element) {\n            return element.hasAttr(key) && lowerCase(element.attr(key)).startsWith(value); // value is lower case already\n        }\n\n        @Override protected int cost() {\n            return 4;\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\"[%s^=%s]\", key, value);\n        }\n    }", "definition": "    public static final class AttributeWithValueStarting extends AttributeKeyPair", "class_docstring": "\nEvaluator for attribute name/value matching (value prefix)\n", "name": "AttributeWithValueStarting", "super_interfaces": [], "superclasses": "AttributeKeyPair", "attributes": {"modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        public AttributeWithValueStarting(String key, String value) {\n            super(key, value, false);\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "AttributeWithValueStarting", "params": [{"name": "key", "type": "String"}, {"name": "value", "type": "String"}], "body": "                                                                    {\n            super(key, value, false);\n        }", "signature": "public AttributeWithValueStarting(String key, String value)"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean matches(Element root, Element element) {\n            return element.hasAttr(key) && lowerCase(element.attr(key)).startsWith(value); // value is lower case already\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "matches", "params": [{"name": "root", "type": "Element"}, {"name": "element", "type": "Element"}], "body": "                                                              {\n            return element.hasAttr(key) && lowerCase(element.attr(key)).startsWith(value); // value is lower case already\n        }", "signature": "@Override\n        public boolean matches(Element root, Element element)"}, {"syntax_pass": true, "original_string": "        @Override protected int cost() {\n            return 4;\n        }", "docstring": "", "attributes": {"modifiers": "@Override protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "int", "classes": []}, "name": "cost", "params": [], "body": "                                       {\n            return 4;\n        }", "signature": "@Override protected int cost()"}, {"syntax_pass": true, "original_string": "        @Override\n        public String toString() {\n            return String.format(\"[%s^=%s]\", key, value);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "toString", "params": [], "body": "                                 {\n            return String.format(\"[%s^=%s]\", key, value);\n        }", "signature": "@Override\n        public String toString()"}]}, {"original_string": "    public static final class AttributeWithValueEnding extends AttributeKeyPair {\n        public AttributeWithValueEnding(String key, String value) {\n            super(key, value, false);\n        }\n\n        @Override\n        public boolean matches(Element root, Element element) {\n            return element.hasAttr(key) && lowerCase(element.attr(key)).endsWith(value); // value is lower case\n        }\n\n        @Override protected int cost() {\n            return 4;\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\"[%s$=%s]\", key, value);\n        }\n    }", "definition": "    public static final class AttributeWithValueEnding extends AttributeKeyPair", "class_docstring": "\nEvaluator for attribute name/value matching (value ending)\n", "name": "AttributeWithValueEnding", "super_interfaces": [], "superclasses": "AttributeKeyPair", "attributes": {"modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        public AttributeWithValueEnding(String key, String value) {\n            super(key, value, false);\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "AttributeWithValueEnding", "params": [{"name": "key", "type": "String"}, {"name": "value", "type": "String"}], "body": "                                                                  {\n            super(key, value, false);\n        }", "signature": "public AttributeWithValueEnding(String key, String value)"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean matches(Element root, Element element) {\n            return element.hasAttr(key) && lowerCase(element.attr(key)).endsWith(value); // value is lower case\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "matches", "params": [{"name": "root", "type": "Element"}, {"name": "element", "type": "Element"}], "body": "                                                              {\n            return element.hasAttr(key) && lowerCase(element.attr(key)).endsWith(value); // value is lower case\n        }", "signature": "@Override\n        public boolean matches(Element root, Element element)"}, {"syntax_pass": true, "original_string": "        @Override protected int cost() {\n            return 4;\n        }", "docstring": "", "attributes": {"modifiers": "@Override protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "int", "classes": []}, "name": "cost", "params": [], "body": "                                       {\n            return 4;\n        }", "signature": "@Override protected int cost()"}, {"syntax_pass": true, "original_string": "        @Override\n        public String toString() {\n            return String.format(\"[%s$=%s]\", key, value);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "toString", "params": [], "body": "                                 {\n            return String.format(\"[%s$=%s]\", key, value);\n        }", "signature": "@Override\n        public String toString()"}]}, {"original_string": "    public static final class AttributeWithValueContaining extends AttributeKeyPair {\n        public AttributeWithValueContaining(String key, String value) {\n            super(key, value);\n        }\n\n        @Override\n        public boolean matches(Element root, Element element) {\n            return element.hasAttr(key) && lowerCase(element.attr(key)).contains(value); // value is lower case\n        }\n\n        @Override protected int cost() {\n            return 6;\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\"[%s*=%s]\", key, value);\n        }\n\n    }", "definition": "    public static final class AttributeWithValueContaining extends AttributeKeyPair", "class_docstring": "\nEvaluator for attribute name/value matching (value containing)\n", "name": "AttributeWithValueContaining", "super_interfaces": [], "superclasses": "AttributeKeyPair", "attributes": {"modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        public AttributeWithValueContaining(String key, String value) {\n            super(key, value);\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "AttributeWithValueContaining", "params": [{"name": "key", "type": "String"}, {"name": "value", "type": "String"}], "body": "                                                                      {\n            super(key, value);\n        }", "signature": "public AttributeWithValueContaining(String key, String value)"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean matches(Element root, Element element) {\n            return element.hasAttr(key) && lowerCase(element.attr(key)).contains(value); // value is lower case\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "matches", "params": [{"name": "root", "type": "Element"}, {"name": "element", "type": "Element"}], "body": "                                                              {\n            return element.hasAttr(key) && lowerCase(element.attr(key)).contains(value); // value is lower case\n        }", "signature": "@Override\n        public boolean matches(Element root, Element element)"}, {"syntax_pass": true, "original_string": "        @Override protected int cost() {\n            return 6;\n        }", "docstring": "", "attributes": {"modifiers": "@Override protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "int", "classes": []}, "name": "cost", "params": [], "body": "                                       {\n            return 6;\n        }", "signature": "@Override protected int cost()"}, {"syntax_pass": true, "original_string": "        @Override\n        public String toString() {\n            return String.format(\"[%s*=%s]\", key, value);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "toString", "params": [], "body": "                                 {\n            return String.format(\"[%s*=%s]\", key, value);\n        }", "signature": "@Override\n        public String toString()"}]}, {"original_string": "    public static final class AttributeWithValueMatching extends Evaluator {\n        final String key;\n        final Pattern pattern;\n\n        public AttributeWithValueMatching(String key, Pattern pattern) {\n            this.key = normalize(key);\n            this.pattern = pattern;\n        }\n\n        @Override\n        public boolean matches(Element root, Element element) {\n            return element.hasAttr(key) && pattern.matcher(element.attr(key)).find();\n        }\n\n        @Override protected int cost() {\n            return 8;\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\"[%s~=%s]\", key, pattern.toString());\n        }\n\n    }", "definition": "    public static final class AttributeWithValueMatching extends Evaluator", "class_docstring": "\nEvaluator for attribute name/value matching (value regex matching)\n", "name": "AttributeWithValueMatching", "super_interfaces": [], "superclasses": "Evaluator", "attributes": {"modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "fields": [{"attribute_expression": "final String key;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "String", "name": "key", "syntax_pass": true}, {"attribute_expression": "final Pattern pattern;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "Pattern", "name": "pattern", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        public AttributeWithValueMatching(String key, Pattern pattern) {\n            this.key = normalize(key);\n            this.pattern = pattern;\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "AttributeWithValueMatching", "params": [{"name": "key", "type": "String"}, {"name": "pattern", "type": "Pattern"}], "body": "                                                                       {\n            this.key = normalize(key);\n            this.pattern = pattern;\n        }", "signature": "public AttributeWithValueMatching(String key, Pattern pattern)"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean matches(Element root, Element element) {\n            return element.hasAttr(key) && pattern.matcher(element.attr(key)).find();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "matches", "params": [{"name": "root", "type": "Element"}, {"name": "element", "type": "Element"}], "body": "                                                              {\n            return element.hasAttr(key) && pattern.matcher(element.attr(key)).find();\n        }", "signature": "@Override\n        public boolean matches(Element root, Element element)"}, {"syntax_pass": true, "original_string": "        @Override protected int cost() {\n            return 8;\n        }", "docstring": "", "attributes": {"modifiers": "@Override protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "int", "classes": []}, "name": "cost", "params": [], "body": "                                       {\n            return 8;\n        }", "signature": "@Override protected int cost()"}, {"syntax_pass": true, "original_string": "        @Override\n        public String toString() {\n            return String.format(\"[%s~=%s]\", key, pattern.toString());\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "toString", "params": [], "body": "                                 {\n            return String.format(\"[%s~=%s]\", key, pattern.toString());\n        }", "signature": "@Override\n        public String toString()"}]}, {"original_string": "    public abstract static class AttributeKeyPair extends Evaluator {\n        final String key;\n        final String value;\n\n        public AttributeKeyPair(String key, String value) {\n            this(key, value, true);\n        }\n\n        public AttributeKeyPair(String key, String value, boolean trimValue) {\n            Validate.notEmpty(key);\n            Validate.notEmpty(value);\n\n            this.key = normalize(key);\n            boolean isStringLiteral = value.startsWith(\"'\") && value.endsWith(\"'\")\n                                        || value.startsWith(\"\\\"\") && value.endsWith(\"\\\"\");\n            if (isStringLiteral) {\n                value = value.substring(1, value.length()-1);\n            }\n\n            this.value = trimValue ? normalize(value) : normalize(value, isStringLiteral);\n        }\n    }", "definition": "    public abstract static class AttributeKeyPair extends Evaluator", "class_docstring": "\nAbstract evaluator for attribute name/value matching\n", "name": "AttributeKeyPair", "super_interfaces": [], "superclasses": "Evaluator", "attributes": {"modifiers": "public abstract static", "marker_annotations": [], "non_marker_annotations": ["public", "abstract", "static"], "comments": [], "fields": [{"attribute_expression": "final String key;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "String", "name": "key", "syntax_pass": true}, {"attribute_expression": "final String value;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "String", "name": "value", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        public AttributeKeyPair(String key, String value) {\n            this(key, value, true);\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "AttributeKeyPair", "params": [{"name": "key", "type": "String"}, {"name": "value", "type": "String"}], "body": "                                                          {\n            this(key, value, true);\n        }", "signature": "public AttributeKeyPair(String key, String value)"}, {"syntax_pass": true, "original_string": "        public AttributeKeyPair(String key, String value, boolean trimValue) {\n            Validate.notEmpty(key);\n            Validate.notEmpty(value);\n\n            this.key = normalize(key);\n            boolean isStringLiteral = value.startsWith(\"'\") && value.endsWith(\"'\")\n                                        || value.startsWith(\"\\\"\") && value.endsWith(\"\\\"\");\n            if (isStringLiteral) {\n                value = value.substring(1, value.length()-1);\n            }\n\n            this.value = trimValue ? normalize(value) : normalize(value, isStringLiteral);\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "AttributeKeyPair", "params": [{"name": "key", "type": "String"}, {"name": "value", "type": "String"}, {"name": "trimValue", "type": "boolean"}], "body": "                                                                             {\n            Validate.notEmpty(key);\n            Validate.notEmpty(value);\n\n            this.key = normalize(key);\n            boolean isStringLiteral = value.startsWith(\"'\") && value.endsWith(\"'\")\n                                        || value.startsWith(\"\\\"\") && value.endsWith(\"\\\"\");\n            if (isStringLiteral) {\n                value = value.substring(1, value.length()-1);\n            }\n\n            this.value = trimValue ? normalize(value) : normalize(value, isStringLiteral);\n        }", "signature": "public AttributeKeyPair(String key, String value, boolean trimValue)"}]}, {"original_string": "    public static final class AllElements extends Evaluator {\n\n        @Override\n        public boolean matches(Element root, Element element) {\n            return true;\n        }\n\n        @Override protected int cost() {\n            return 10;\n        }\n\n        @Override\n        public String toString() {\n            return \"*\";\n        }\n    }", "definition": "    public static final class AllElements extends Evaluator", "class_docstring": "\nEvaluator for any / all element matching\n", "name": "AllElements", "super_interfaces": [], "superclasses": "Evaluator", "attributes": {"modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        @Override\n        public boolean matches(Element root, Element element) {\n            return true;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "matches", "params": [{"name": "root", "type": "Element"}, {"name": "element", "type": "Element"}], "body": "                                                              {\n            return true;\n        }", "signature": "@Override\n        public boolean matches(Element root, Element element)"}, {"syntax_pass": true, "original_string": "        @Override protected int cost() {\n            return 10;\n        }", "docstring": "", "attributes": {"modifiers": "@Override protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "int", "classes": []}, "name": "cost", "params": [], "body": "                                       {\n            return 10;\n        }", "signature": "@Override protected int cost()"}, {"syntax_pass": true, "original_string": "        @Override\n        public String toString() {\n            return \"*\";\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "toString", "params": [], "body": "                                 {\n            return \"*\";\n        }", "signature": "@Override\n        public String toString()"}]}, {"original_string": "    public static final class IndexLessThan extends IndexEvaluator {\n        public IndexLessThan(int index) {\n            super(index);\n        }\n\n        @Override\n        public boolean matches(Element root, Element element) {\n            return root != element && element.elementSiblingIndex() < index;\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\":lt(%d)\", index);\n        }\n\n    }", "definition": "    public static final class IndexLessThan extends IndexEvaluator", "class_docstring": "\nEvaluator for matching by sibling index number (e {@literal <} idx)\n", "name": "IndexLessThan", "super_interfaces": [], "superclasses": "IndexEvaluator", "attributes": {"modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        public IndexLessThan(int index) {\n            super(index);\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "IndexLessThan", "params": [{"name": "index", "type": "int"}], "body": "                                        {\n            super(index);\n        }", "signature": "public IndexLessThan(int index)"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean matches(Element root, Element element) {\n            return root != element && element.elementSiblingIndex() < index;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "matches", "params": [{"name": "root", "type": "Element"}, {"name": "element", "type": "Element"}], "body": "                                                              {\n            return root != element && element.elementSiblingIndex() < index;\n        }", "signature": "@Override\n        public boolean matches(Element root, Element element)"}, {"syntax_pass": true, "original_string": "        @Override\n        public String toString() {\n            return String.format(\":lt(%d)\", index);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "toString", "params": [], "body": "                                 {\n            return String.format(\":lt(%d)\", index);\n        }", "signature": "@Override\n        public String toString()"}]}, {"original_string": "    public static final class IndexGreaterThan extends IndexEvaluator {\n        public IndexGreaterThan(int index) {\n            super(index);\n        }\n\n        @Override\n        public boolean matches(Element root, Element element) {\n            return element.elementSiblingIndex() > index;\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\":gt(%d)\", index);\n        }\n\n    }", "definition": "    public static final class IndexGreaterThan extends IndexEvaluator", "class_docstring": "\nEvaluator for matching by sibling index number (e {@literal >} idx)\n", "name": "IndexGreaterThan", "super_interfaces": [], "superclasses": "IndexEvaluator", "attributes": {"modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        public IndexGreaterThan(int index) {\n            super(index);\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "IndexGreaterThan", "params": [{"name": "index", "type": "int"}], "body": "                                           {\n            super(index);\n        }", "signature": "public IndexGreaterThan(int index)"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean matches(Element root, Element element) {\n            return element.elementSiblingIndex() > index;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "matches", "params": [{"name": "root", "type": "Element"}, {"name": "element", "type": "Element"}], "body": "                                                              {\n            return element.elementSiblingIndex() > index;\n        }", "signature": "@Override\n        public boolean matches(Element root, Element element)"}, {"syntax_pass": true, "original_string": "        @Override\n        public String toString() {\n            return String.format(\":gt(%d)\", index);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "toString", "params": [], "body": "                                 {\n            return String.format(\":gt(%d)\", index);\n        }", "signature": "@Override\n        public String toString()"}]}, {"original_string": "    public static final class IndexEquals extends IndexEvaluator {\n        public IndexEquals(int index) {\n            super(index);\n        }\n\n        @Override\n        public boolean matches(Element root, Element element) {\n            return element.elementSiblingIndex() == index;\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\":eq(%d)\", index);\n        }\n\n    }", "definition": "    public static final class IndexEquals extends IndexEvaluator", "class_docstring": "\nEvaluator for matching by sibling index number (e = idx)\n", "name": "IndexEquals", "super_interfaces": [], "superclasses": "IndexEvaluator", "attributes": {"modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        public IndexEquals(int index) {\n            super(index);\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "IndexEquals", "params": [{"name": "index", "type": "int"}], "body": "                                      {\n            super(index);\n        }", "signature": "public IndexEquals(int index)"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean matches(Element root, Element element) {\n            return element.elementSiblingIndex() == index;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "matches", "params": [{"name": "root", "type": "Element"}, {"name": "element", "type": "Element"}], "body": "                                                              {\n            return element.elementSiblingIndex() == index;\n        }", "signature": "@Override\n        public boolean matches(Element root, Element element)"}, {"syntax_pass": true, "original_string": "        @Override\n        public String toString() {\n            return String.format(\":eq(%d)\", index);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "toString", "params": [], "body": "                                 {\n            return String.format(\":eq(%d)\", index);\n        }", "signature": "@Override\n        public String toString()"}]}, {"original_string": "    public static final class IsLastChild extends Evaluator {\n\t\t@Override\n\t\tpublic boolean matches(Element root, Element element) {\n\t\t\tfinal Element p = element.parent();\n\t\t\treturn p != null && !(p instanceof Document) && element == p.lastElementChild();\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \":last-child\";\n\t\t}\n    }", "definition": "    public static final class IsLastChild extends Evaluator", "class_docstring": "\nEvaluator for matching the last sibling (css :last-child)\n", "name": "IsLastChild", "super_interfaces": [], "superclasses": "Evaluator", "attributes": {"modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "  @Override\n\t\tpublic boolean matches(Element root, Element element) {\n\t\t\tfinal Element p = element.parent();\n\t\t\treturn p != null && !(p instanceof Document) && element == p.lastElementChild();\n\t\t}", "docstring": "", "attributes": {"modifiers": "@Override\n\t\tpublic", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "matches", "params": [{"name": "root", "type": "Element"}, {"name": "element", "type": "Element"}], "body": "                                                        {\n\t\t\tfinal Element p = element.parent();\n\t\t\treturn p != null && !(p instanceof Document) && element == p.lastElementChild();\n\t\t}", "signature": "@Override\n\t\tpublic boolean matches(Element root, Element element)"}, {"syntax_pass": true, "original_string": "  @Override\n\t\tpublic String toString() {\n\t\t\treturn \":last-child\";\n\t\t}", "docstring": "", "attributes": {"modifiers": "@Override\n\t\tpublic", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "toString", "params": [], "body": "                           {\n\t\t\treturn \":last-child\";\n\t\t}", "signature": "@Override\n\t\tpublic String toString()"}]}, {"original_string": "    public static final class IsFirstOfType extends IsNthOfType {\n\t\tpublic IsFirstOfType() {\n\t\t\tsuper(0,1);\n\t\t}\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \":first-of-type\";\n\t\t}\n    }", "definition": "    public static final class IsFirstOfType extends IsNthOfType", "class_docstring": "", "name": "IsFirstOfType", "super_interfaces": [], "superclasses": "IsNthOfType", "attributes": {"modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "  public IsFirstOfType() {\n\t\t\tsuper(0,1);\n\t\t}", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "IsFirstOfType", "params": [], "body": "                         {\n\t\t\tsuper(0,1);\n\t\t}", "signature": "public IsFirstOfType()"}, {"syntax_pass": true, "original_string": "  @Override\n\t\tpublic String toString() {\n\t\t\treturn \":first-of-type\";\n\t\t}", "docstring": "", "attributes": {"modifiers": "@Override\n\t\tpublic", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "toString", "params": [], "body": "                           {\n\t\t\treturn \":first-of-type\";\n\t\t}", "signature": "@Override\n\t\tpublic String toString()"}]}, {"original_string": "    public static final class IsLastOfType extends IsNthLastOfType {\n\t\tpublic IsLastOfType() {\n\t\t\tsuper(0,1);\n\t\t}\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \":last-of-type\";\n\t\t}\n    }", "definition": "    public static final class IsLastOfType extends IsNthLastOfType", "class_docstring": "", "name": "IsLastOfType", "super_interfaces": [], "superclasses": "IsNthLastOfType", "attributes": {"modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "  public IsLastOfType() {\n\t\t\tsuper(0,1);\n\t\t}", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "IsLastOfType", "params": [], "body": "                        {\n\t\t\tsuper(0,1);\n\t\t}", "signature": "public IsLastOfType()"}, {"syntax_pass": true, "original_string": "  @Override\n\t\tpublic String toString() {\n\t\t\treturn \":last-of-type\";\n\t\t}", "docstring": "", "attributes": {"modifiers": "@Override\n\t\tpublic", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "toString", "params": [], "body": "                           {\n\t\t\treturn \":last-of-type\";\n\t\t}", "signature": "@Override\n\t\tpublic String toString()"}]}, {"original_string": "    public static abstract class CssNthEvaluator extends Evaluator {\n    \tprotected final int a, b;\n\n    \tpublic CssNthEvaluator(int a, int b) {\n    \t\tthis.a = a;\n    \t\tthis.b = b;\n    \t}\n    \tpublic CssNthEvaluator(int b) {\n    \t\tthis(0,b);\n    \t}\n\n    \t@Override\n    \tpublic boolean matches(Element root, Element element) {\n    \t\tfinal Element p = element.parent();\n    \t\tif (p == null || (p instanceof Document)) return false;\n\n    \t\tfinal int pos = calculatePosition(root, element);\n    \t\tif (a == 0) return pos == b;\n\n    \t\treturn (pos-b)*a >= 0 && (pos-b)%a==0;\n    \t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\tif (a == 0)\n\t\t\t\treturn String.format(\":%s(%d)\",getPseudoClass(), b);\n\t\t\tif (b == 0)\n\t\t\t\treturn String.format(\":%s(%dn)\",getPseudoClass(), a);\n\t\t\treturn String.format(\":%s(%dn%+d)\", getPseudoClass(),a, b);\n\t\t}\n\n\t\tprotected abstract String getPseudoClass();\n\t\tprotected abstract int calculatePosition(Element root, Element element);\n    }", "definition": "    public static abstract class CssNthEvaluator extends Evaluator", "class_docstring": "", "name": "CssNthEvaluator", "super_interfaces": [], "superclasses": "Evaluator", "attributes": {"modifiers": "public static abstract", "marker_annotations": [], "non_marker_annotations": ["public", "static", "abstract"], "comments": [], "fields": [{"attribute_expression": "protected final int a, b;", "docstring": "", "modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "type": "int", "name": "a", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "     public CssNthEvaluator(int a, int b) {\n    \t\tthis.a = a;\n    \t\tthis.b = b;\n    \t}", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "CssNthEvaluator", "params": [{"name": "a", "type": "int"}, {"name": "b", "type": "int"}], "body": "                                          {\n    \t\tthis.a = a;\n    \t\tthis.b = b;\n    \t}", "signature": "public CssNthEvaluator(int a, int b)"}, {"syntax_pass": true, "original_string": "     public CssNthEvaluator(int b) {\n    \t\tthis(0,b);\n    \t}", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "CssNthEvaluator", "params": [{"name": "b", "type": "int"}], "body": "                                   {\n    \t\tthis(0,b);\n    \t}", "signature": "public CssNthEvaluator(int b)"}, {"syntax_pass": true, "original_string": "     @Override\n    \tpublic boolean matches(Element root, Element element) {\n    \t\tfinal Element p = element.parent();\n    \t\tif (p == null || (p instanceof Document)) return false;\n\n    \t\tfinal int pos = calculatePosition(root, element);\n    \t\tif (a == 0) return pos == b;\n\n    \t\treturn (pos-b)*a >= 0 && (pos-b)%a==0;\n    \t}", "docstring": "", "attributes": {"modifiers": "@Override\n    \tpublic", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "matches", "params": [{"name": "root", "type": "Element"}, {"name": "element", "type": "Element"}], "body": "                                                           {\n    \t\tfinal Element p = element.parent();\n    \t\tif (p == null || (p instanceof Document)) return false;\n\n    \t\tfinal int pos = calculatePosition(root, element);\n    \t\tif (a == 0) return pos == b;\n\n    \t\treturn (pos-b)*a >= 0 && (pos-b)%a==0;\n    \t}", "signature": "@Override\n    \tpublic boolean matches(Element root, Element element)"}, {"syntax_pass": true, "original_string": "  @Override\n\t\tpublic String toString() {\n\t\t\tif (a == 0)\n\t\t\t\treturn String.format(\":%s(%d)\",getPseudoClass(), b);\n\t\t\tif (b == 0)\n\t\t\t\treturn String.format(\":%s(%dn)\",getPseudoClass(), a);\n\t\t\treturn String.format(\":%s(%dn%+d)\", getPseudoClass(),a, b);\n\t\t}", "docstring": "", "attributes": {"modifiers": "@Override\n\t\tpublic", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "toString", "params": [], "body": "                           {\n\t\t\tif (a == 0)\n\t\t\t\treturn String.format(\":%s(%d)\",getPseudoClass(), b);\n\t\t\tif (b == 0)\n\t\t\t\treturn String.format(\":%s(%dn)\",getPseudoClass(), a);\n\t\t\treturn String.format(\":%s(%dn%+d)\", getPseudoClass(),a, b);\n\t\t}", "signature": "@Override\n\t\tpublic String toString()"}, {"syntax_pass": true, "original_string": "  protected abstract String getPseudoClass();", "docstring": "", "attributes": {"modifiers": "protected abstract", "marker_annotations": [], "non_marker_annotations": ["protected", "abstract"], "comments": [], "return_type": "String", "classes": []}, "name": "getPseudoClass", "params": [], "body": "", "signature": "protected abstract String getPseudoClass()"}, {"syntax_pass": true, "original_string": "  protected abstract int calculatePosition(Element root, Element element);", "docstring": "", "attributes": {"modifiers": "protected abstract", "marker_annotations": [], "non_marker_annotations": ["protected", "abstract"], "comments": [], "return_type": "int", "classes": []}, "name": "calculatePosition", "params": [{"name": "root", "type": "Element"}, {"name": "element", "type": "Element"}], "body": "", "signature": "protected abstract int calculatePosition(Element root, Element element)"}]}, {"original_string": "    public static final class IsNthChild extends CssNthEvaluator {\n\n    \tpublic IsNthChild(int a, int b) {\n    \t\tsuper(a,b);\n\t\t}\n\n\t\t@Override protected int calculatePosition(Element root, Element element) {\n\t\t\treturn element.elementSiblingIndex()+1;\n\t\t}\n\n\n\t\t@Override protected String getPseudoClass() {\n\t\t\treturn \"nth-child\";\n\t\t}\n    }", "definition": "    public static final class IsNthChild extends CssNthEvaluator", "class_docstring": "\ncss-compatible Evaluator for :eq (css :nth-child)\n\n@see IndexEquals\n", "name": "IsNthChild", "super_interfaces": [], "superclasses": "CssNthEvaluator", "attributes": {"modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "     public IsNthChild(int a, int b) {\n    \t\tsuper(a,b);\n\t\t}", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "IsNthChild", "params": [{"name": "a", "type": "int"}, {"name": "b", "type": "int"}], "body": "                                     {\n    \t\tsuper(a,b);\n\t\t}", "signature": "public IsNthChild(int a, int b)"}, {"syntax_pass": true, "original_string": "  @Override protected int calculatePosition(Element root, Element element) {\n\t\t\treturn element.elementSiblingIndex()+1;\n\t\t}", "docstring": "", "attributes": {"modifiers": "@Override protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "int", "classes": []}, "name": "calculatePosition", "params": [{"name": "root", "type": "Element"}, {"name": "element", "type": "Element"}], "body": "                                                                           {\n\t\t\treturn element.elementSiblingIndex()+1;\n\t\t}", "signature": "@Override protected int calculatePosition(Element root, Element element)"}, {"syntax_pass": true, "original_string": "  @Override protected String getPseudoClass() {\n\t\t\treturn \"nth-child\";\n\t\t}", "docstring": "", "attributes": {"modifiers": "@Override protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "String", "classes": []}, "name": "getPseudoClass", "params": [], "body": "                                              {\n\t\t\treturn \"nth-child\";\n\t\t}", "signature": "@Override protected String getPseudoClass()"}]}, {"original_string": "    public static final class IsNthLastChild extends CssNthEvaluator {\n    \tpublic IsNthLastChild(int a, int b) {\n    \t\tsuper(a,b);\n    \t}\n\n        @Override\n        protected int calculatePosition(Element root, Element element) {\n    \t    if (element.parent() == null)\n    \t        return 0;\n        \treturn element.parent().childrenSize()- element.elementSiblingIndex();\n        }\n\n\t\t@Override\n\t\tprotected String getPseudoClass() {\n\t\t\treturn \"nth-last-child\";\n\t\t}\n    }", "definition": "    public static final class IsNthLastChild extends CssNthEvaluator", "class_docstring": "\ncss pseudo class :nth-last-child)\n\n@see IndexEquals\n", "name": "IsNthLastChild", "super_interfaces": [], "superclasses": "CssNthEvaluator", "attributes": {"modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "     public IsNthLastChild(int a, int b) {\n    \t\tsuper(a,b);\n    \t}", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "IsNthLastChild", "params": [{"name": "a", "type": "int"}, {"name": "b", "type": "int"}], "body": "                                         {\n    \t\tsuper(a,b);\n    \t}", "signature": "public IsNthLastChild(int a, int b)"}, {"syntax_pass": true, "original_string": "        @Override\n        protected int calculatePosition(Element root, Element element) {\n    \t    if (element.parent() == null)\n    \t        return 0;\n        \treturn element.parent().childrenSize()- element.elementSiblingIndex();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "int", "classes": []}, "name": "calculatePosition", "params": [{"name": "root", "type": "Element"}, {"name": "element", "type": "Element"}], "body": "                                                                       {\n    \t    if (element.parent() == null)\n    \t        return 0;\n        \treturn element.parent().childrenSize()- element.elementSiblingIndex();\n        }", "signature": "@Override\n        protected int calculatePosition(Element root, Element element)"}, {"syntax_pass": true, "original_string": "  @Override\n\t\tprotected String getPseudoClass() {\n\t\t\treturn \"nth-last-child\";\n\t\t}", "docstring": "", "attributes": {"modifiers": "@Override\n\t\tprotected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "String", "classes": []}, "name": "getPseudoClass", "params": [], "body": "                                    {\n\t\t\treturn \"nth-last-child\";\n\t\t}", "signature": "@Override\n\t\tprotected String getPseudoClass()"}]}, {"original_string": "    public static class IsNthOfType extends CssNthEvaluator {\n        public IsNthOfType(int a, int b) {\n            super(a, b);\n        }\n\n        @Override protected int calculatePosition(Element root, Element element) {\n            Element parent = element.parent();\n            if (parent == null)\n                return 0;\n\n            int pos = 0;\n            final int size = parent.childNodeSize();\n            for (int i = 0; i < size; i++) {\n                Node node = parent.childNode(i);\n                if (node.normalName().equals(element.normalName())) pos++;\n                if (node == element) break;\n            }\n            return pos;\n        }\n\n        @Override\n        protected String getPseudoClass() {\n            return \"nth-of-type\";\n        }\n    }", "definition": "    public static class IsNthOfType extends CssNthEvaluator", "class_docstring": "\ncss pseudo class nth-of-type\n\n", "name": "IsNthOfType", "super_interfaces": [], "superclasses": "CssNthEvaluator", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        public IsNthOfType(int a, int b) {\n            super(a, b);\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "IsNthOfType", "params": [{"name": "a", "type": "int"}, {"name": "b", "type": "int"}], "body": "                                         {\n            super(a, b);\n        }", "signature": "public IsNthOfType(int a, int b)"}, {"syntax_pass": true, "original_string": "        @Override protected int calculatePosition(Element root, Element element) {\n            Element parent = element.parent();\n            if (parent == null)\n                return 0;\n\n            int pos = 0;\n            final int size = parent.childNodeSize();\n            for (int i = 0; i < size; i++) {\n                Node node = parent.childNode(i);\n                if (node.normalName().equals(element.normalName())) pos++;\n                if (node == element) break;\n            }\n            return pos;\n        }", "docstring": "", "attributes": {"modifiers": "@Override protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "int", "classes": []}, "name": "calculatePosition", "params": [{"name": "root", "type": "Element"}, {"name": "element", "type": "Element"}], "body": "                                                                                 {\n            Element parent = element.parent();\n            if (parent == null)\n                return 0;\n\n            int pos = 0;\n            final int size = parent.childNodeSize();\n            for (int i = 0; i < size; i++) {\n                Node node = parent.childNode(i);\n                if (node.normalName().equals(element.normalName())) pos++;\n                if (node == element) break;\n            }\n            return pos;\n        }", "signature": "@Override protected int calculatePosition(Element root, Element element)"}, {"syntax_pass": true, "original_string": "        @Override\n        protected String getPseudoClass() {\n            return \"nth-of-type\";\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "String", "classes": []}, "name": "getPseudoClass", "params": [], "body": "                                          {\n            return \"nth-of-type\";\n        }", "signature": "@Override\n        protected String getPseudoClass()"}]}, {"original_string": "    public static class IsNthLastOfType extends CssNthEvaluator {\n\n        public IsNthLastOfType(int a, int b) {\n            super(a, b);\n        }\n\n        @Override\n        protected int calculatePosition(Element root, Element element) {\n            Element parent = element.parent();\n            if (parent == null)\n                return 0;\n\n            int pos = 0;\n            Element next = element;\n            while (next != null) {\n                if (next.normalName().equals(element.normalName()))\n                    pos++;\n                next = next.nextElementSibling();\n            }\n            return pos;\n        }\n\n        @Override\n        protected String getPseudoClass() {\n            return \"nth-last-of-type\";\n        }\n    }", "definition": "    public static class IsNthLastOfType extends CssNthEvaluator", "class_docstring": "", "name": "IsNthLastOfType", "super_interfaces": [], "superclasses": "CssNthEvaluator", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        public IsNthLastOfType(int a, int b) {\n            super(a, b);\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "IsNthLastOfType", "params": [{"name": "a", "type": "int"}, {"name": "b", "type": "int"}], "body": "                                             {\n            super(a, b);\n        }", "signature": "public IsNthLastOfType(int a, int b)"}, {"syntax_pass": true, "original_string": "        @Override\n        protected int calculatePosition(Element root, Element element) {\n            Element parent = element.parent();\n            if (parent == null)\n                return 0;\n\n            int pos = 0;\n            Element next = element;\n            while (next != null) {\n                if (next.normalName().equals(element.normalName()))\n                    pos++;\n                next = next.nextElementSibling();\n            }\n            return pos;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "int", "classes": []}, "name": "calculatePosition", "params": [{"name": "root", "type": "Element"}, {"name": "element", "type": "Element"}], "body": "                                                                       {\n            Element parent = element.parent();\n            if (parent == null)\n                return 0;\n\n            int pos = 0;\n            Element next = element;\n            while (next != null) {\n                if (next.normalName().equals(element.normalName()))\n                    pos++;\n                next = next.nextElementSibling();\n            }\n            return pos;\n        }", "signature": "@Override\n        protected int calculatePosition(Element root, Element element)"}, {"syntax_pass": true, "original_string": "        @Override\n        protected String getPseudoClass() {\n            return \"nth-last-of-type\";\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "String", "classes": []}, "name": "getPseudoClass", "params": [], "body": "                                          {\n            return \"nth-last-of-type\";\n        }", "signature": "@Override\n        protected String getPseudoClass()"}]}, {"original_string": "    public static final class IsFirstChild extends Evaluator {\n    \t@Override\n    \tpublic boolean matches(Element root, Element element) {\n    \t\tfinal Element p = element.parent();\n    \t\treturn p != null && !(p instanceof Document) && element == p.firstElementChild();\n    \t}\n\n    \t@Override\n    \tpublic String toString() {\n    \t\treturn \":first-child\";\n    \t}\n    }", "definition": "    public static final class IsFirstChild extends Evaluator", "class_docstring": "\nEvaluator for matching the first sibling (css :first-child)\n", "name": "IsFirstChild", "super_interfaces": [], "superclasses": "Evaluator", "attributes": {"modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "     @Override\n    \tpublic boolean matches(Element root, Element element) {\n    \t\tfinal Element p = element.parent();\n    \t\treturn p != null && !(p instanceof Document) && element == p.firstElementChild();\n    \t}", "docstring": "", "attributes": {"modifiers": "@Override\n    \tpublic", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "matches", "params": [{"name": "root", "type": "Element"}, {"name": "element", "type": "Element"}], "body": "                                                           {\n    \t\tfinal Element p = element.parent();\n    \t\treturn p != null && !(p instanceof Document) && element == p.firstElementChild();\n    \t}", "signature": "@Override\n    \tpublic boolean matches(Element root, Element element)"}, {"syntax_pass": true, "original_string": "     @Override\n    \tpublic String toString() {\n    \t\treturn \":first-child\";\n    \t}", "docstring": "", "attributes": {"modifiers": "@Override\n    \tpublic", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "toString", "params": [], "body": "                              {\n    \t\treturn \":first-child\";\n    \t}", "signature": "@Override\n    \tpublic String toString()"}]}, {"original_string": "    public static final class IsRoot extends Evaluator {\n    \t@Override\n    \tpublic boolean matches(Element root, Element element) {\n    \t\tfinal Element r = root instanceof Document ? root.firstElementChild() : root;\n    \t\treturn element == r;\n    \t}\n\n        @Override protected int cost() {\n            return 1;\n        }\n\n    \t@Override\n    \tpublic String toString() {\n    \t\treturn \":root\";\n    \t}\n    }", "definition": "    public static final class IsRoot extends Evaluator", "class_docstring": "\ncss3 pseudo-class :root\n@see <a href=\"http://www.w3.org/TR/selectors/#root-pseudo\">:root selector</a>\n\n", "name": "IsRoot", "super_interfaces": [], "superclasses": "Evaluator", "attributes": {"modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "     @Override\n    \tpublic boolean matches(Element root, Element element) {\n    \t\tfinal Element r = root instanceof Document ? root.firstElementChild() : root;\n    \t\treturn element == r;\n    \t}", "docstring": "", "attributes": {"modifiers": "@Override\n    \tpublic", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "matches", "params": [{"name": "root", "type": "Element"}, {"name": "element", "type": "Element"}], "body": "                                                           {\n    \t\tfinal Element r = root instanceof Document ? root.firstElementChild() : root;\n    \t\treturn element == r;\n    \t}", "signature": "@Override\n    \tpublic boolean matches(Element root, Element element)"}, {"syntax_pass": true, "original_string": "        @Override protected int cost() {\n            return 1;\n        }", "docstring": "", "attributes": {"modifiers": "@Override protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "int", "classes": []}, "name": "cost", "params": [], "body": "                                       {\n            return 1;\n        }", "signature": "@Override protected int cost()"}, {"syntax_pass": true, "original_string": "     @Override\n    \tpublic String toString() {\n    \t\treturn \":root\";\n    \t}", "docstring": "", "attributes": {"modifiers": "@Override\n    \tpublic", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "toString", "params": [], "body": "                              {\n    \t\treturn \":root\";\n    \t}", "signature": "@Override\n    \tpublic String toString()"}]}, {"original_string": "    public static final class IsOnlyChild extends Evaluator {\n\t\t@Override\n\t\tpublic boolean matches(Element root, Element element) {\n\t\t\tfinal Element p = element.parent();\n\t\t\treturn p!=null && !(p instanceof Document) && element.siblingElements().isEmpty();\n\t\t}\n    \t@Override\n    \tpublic String toString() {\n    \t\treturn \":only-child\";\n    \t}\n    }", "definition": "    public static final class IsOnlyChild extends Evaluator", "class_docstring": "", "name": "IsOnlyChild", "super_interfaces": [], "superclasses": "Evaluator", "attributes": {"modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "  @Override\n\t\tpublic boolean matches(Element root, Element element) {\n\t\t\tfinal Element p = element.parent();\n\t\t\treturn p!=null && !(p instanceof Document) && element.siblingElements().isEmpty();\n\t\t}", "docstring": "", "attributes": {"modifiers": "@Override\n\t\tpublic", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "matches", "params": [{"name": "root", "type": "Element"}, {"name": "element", "type": "Element"}], "body": "                                                        {\n\t\t\tfinal Element p = element.parent();\n\t\t\treturn p!=null && !(p instanceof Document) && element.siblingElements().isEmpty();\n\t\t}", "signature": "@Override\n\t\tpublic boolean matches(Element root, Element element)"}, {"syntax_pass": true, "original_string": "     @Override\n    \tpublic String toString() {\n    \t\treturn \":only-child\";\n    \t}", "docstring": "", "attributes": {"modifiers": "@Override\n    \tpublic", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "toString", "params": [], "body": "                              {\n    \t\treturn \":only-child\";\n    \t}", "signature": "@Override\n    \tpublic String toString()"}]}, {"original_string": "    public static final class IsOnlyOfType extends Evaluator {\n\t\t@Override\n\t\tpublic boolean matches(Element root, Element element) {\n\t\t\tfinal Element p = element.parent();\n\t\t\tif (p==null || p instanceof Document) return false;\n\n\t\t\tint pos = 0;\n            Element next = p.firstElementChild();\n            while (next != null) {\n                if (next.normalName().equals(element.normalName()))\n                    pos++;\n                if (pos > 1)\n                    break;\n                next = next.nextElementSibling();\n            }\n        \treturn pos == 1;\n\t\t}\n    \t@Override\n    \tpublic String toString() {\n    \t\treturn \":only-of-type\";\n    \t}\n    }", "definition": "    public static final class IsOnlyOfType extends Evaluator", "class_docstring": "", "name": "IsOnlyOfType", "super_interfaces": [], "superclasses": "Evaluator", "attributes": {"modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "  @Override\n\t\tpublic boolean matches(Element root, Element element) {\n\t\t\tfinal Element p = element.parent();\n\t\t\tif (p==null || p instanceof Document) return false;\n\n\t\t\tint pos = 0;\n            Element next = p.firstElementChild();\n            while (next != null) {\n                if (next.normalName().equals(element.normalName()))\n                    pos++;\n                if (pos > 1)\n                    break;\n                next = next.nextElementSibling();\n            }\n        \treturn pos == 1;\n\t\t}", "docstring": "", "attributes": {"modifiers": "@Override\n\t\tpublic", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "matches", "params": [{"name": "root", "type": "Element"}, {"name": "element", "type": "Element"}], "body": "                                                        {\n\t\t\tfinal Element p = element.parent();\n\t\t\tif (p==null || p instanceof Document) return false;\n\n\t\t\tint pos = 0;\n            Element next = p.firstElementChild();\n            while (next != null) {\n                if (next.normalName().equals(element.normalName()))\n                    pos++;\n                if (pos > 1)\n                    break;\n                next = next.nextElementSibling();\n            }\n        \treturn pos == 1;\n\t\t}", "signature": "@Override\n\t\tpublic boolean matches(Element root, Element element)"}, {"syntax_pass": true, "original_string": "     @Override\n    \tpublic String toString() {\n    \t\treturn \":only-of-type\";\n    \t}", "docstring": "", "attributes": {"modifiers": "@Override\n    \tpublic", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "toString", "params": [], "body": "                              {\n    \t\treturn \":only-of-type\";\n    \t}", "signature": "@Override\n    \tpublic String toString()"}]}, {"original_string": "    public static final class IsEmpty extends Evaluator {\n        @Override\n        public boolean matches(Element root, Element el) {\n            for (Node n = el.firstChild(); n != null; n = n.nextSibling()) {\n                if (n instanceof TextNode) {\n                    if (!((TextNode) n).isBlank())\n                        return false; // non-blank text: not empty\n                } else if (!(n instanceof Comment || n instanceof XmlDeclaration || n instanceof DocumentType))\n                    return false; // non \"blank\" element: not empty\n            }\n            return true;\n        }\n\n        @Override\n        public String toString() {\n            return \":empty\";\n        }\n    }", "definition": "    public static final class IsEmpty extends Evaluator", "class_docstring": "", "name": "IsEmpty", "super_interfaces": [], "superclasses": "Evaluator", "attributes": {"modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        @Override\n        public boolean matches(Element root, Element el) {\n            for (Node n = el.firstChild(); n != null; n = n.nextSibling()) {\n                if (n instanceof TextNode) {\n                    if (!((TextNode) n).isBlank())\n                        return false; // non-blank text: not empty\n                } else if (!(n instanceof Comment || n instanceof XmlDeclaration || n instanceof DocumentType))\n                    return false; // non \"blank\" element: not empty\n            }\n            return true;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "matches", "params": [{"name": "root", "type": "Element"}, {"name": "el", "type": "Element"}], "body": "                                                         {\n            for (Node n = el.firstChild(); n != null; n = n.nextSibling()) {\n                if (n instanceof TextNode) {\n                    if (!((TextNode) n).isBlank())\n                        return false; // non-blank text: not empty\n                } else if (!(n instanceof Comment || n instanceof XmlDeclaration || n instanceof DocumentType))\n                    return false; // non \"blank\" element: not empty\n            }\n            return true;\n        }", "signature": "@Override\n        public boolean matches(Element root, Element el)"}, {"syntax_pass": true, "original_string": "        @Override\n        public String toString() {\n            return \":empty\";\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "toString", "params": [], "body": "                                 {\n            return \":empty\";\n        }", "signature": "@Override\n        public String toString()"}]}, {"original_string": "    public abstract static class IndexEvaluator extends Evaluator {\n        final int index;\n\n        public IndexEvaluator(int index) {\n            this.index = index;\n        }\n    }", "definition": "    public abstract static class IndexEvaluator extends Evaluator", "class_docstring": "\nAbstract evaluator for sibling index matching\n\n@author ant\n", "name": "IndexEvaluator", "super_interfaces": [], "superclasses": "Evaluator", "attributes": {"modifiers": "public abstract static", "marker_annotations": [], "non_marker_annotations": ["public", "abstract", "static"], "comments": [], "fields": [{"attribute_expression": "final int index;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "int", "name": "index", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        public IndexEvaluator(int index) {\n            this.index = index;\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "IndexEvaluator", "params": [{"name": "index", "type": "int"}], "body": "                                         {\n            this.index = index;\n        }", "signature": "public IndexEvaluator(int index)"}]}, {"original_string": "    public static final class ContainsText extends Evaluator {\n        private final String searchText;\n\n        public ContainsText(String searchText) {\n            this.searchText = lowerCase(normaliseWhitespace(searchText));\n        }\n\n        @Override\n        public boolean matches(Element root, Element element) {\n            return lowerCase(element.text()).contains(searchText);\n        }\n\n        @Override protected int cost() {\n            return 10;\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\":contains(%s)\", searchText);\n        }\n    }", "definition": "    public static final class ContainsText extends Evaluator", "class_docstring": "\nEvaluator for matching Element (and its descendants) text\n", "name": "ContainsText", "super_interfaces": [], "superclasses": "Evaluator", "attributes": {"modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "fields": [{"attribute_expression": "private final String searchText;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "searchText", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        public ContainsText(String searchText) {\n            this.searchText = lowerCase(normaliseWhitespace(searchText));\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "ContainsText", "params": [{"name": "searchText", "type": "String"}], "body": "                                               {\n            this.searchText = lowerCase(normaliseWhitespace(searchText));\n        }", "signature": "public ContainsText(String searchText)"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean matches(Element root, Element element) {\n            return lowerCase(element.text()).contains(searchText);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "matches", "params": [{"name": "root", "type": "Element"}, {"name": "element", "type": "Element"}], "body": "                                                              {\n            return lowerCase(element.text()).contains(searchText);\n        }", "signature": "@Override\n        public boolean matches(Element root, Element element)"}, {"syntax_pass": true, "original_string": "        @Override protected int cost() {\n            return 10;\n        }", "docstring": "", "attributes": {"modifiers": "@Override protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "int", "classes": []}, "name": "cost", "params": [], "body": "                                       {\n            return 10;\n        }", "signature": "@Override protected int cost()"}, {"syntax_pass": true, "original_string": "        @Override\n        public String toString() {\n            return String.format(\":contains(%s)\", searchText);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "toString", "params": [], "body": "                                 {\n            return String.format(\":contains(%s)\", searchText);\n        }", "signature": "@Override\n        public String toString()"}]}, {"original_string": "    public static final class ContainsWholeText extends Evaluator {\n        private final String searchText;\n\n        public ContainsWholeText(String searchText) {\n            this.searchText = searchText;\n        }\n\n        @Override\n        public boolean matches(Element root, Element element) {\n            return element.wholeText().contains(searchText);\n        }\n\n        @Override protected int cost() {\n            return 10;\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\":containsWholeText(%s)\", searchText);\n        }\n    }", "definition": "    public static final class ContainsWholeText extends Evaluator", "class_docstring": "\nEvaluator for matching Element (and its descendants) wholeText. Neither the input nor the element text is\nnormalized. <code>:containsWholeText()</code>\n@since 1.15.1.\n", "name": "ContainsWholeText", "super_interfaces": [], "superclasses": "Evaluator", "attributes": {"modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "fields": [{"attribute_expression": "private final String searchText;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "searchText", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        public ContainsWholeText(String searchText) {\n            this.searchText = searchText;\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "ContainsWholeText", "params": [{"name": "searchText", "type": "String"}], "body": "                                                    {\n            this.searchText = searchText;\n        }", "signature": "public ContainsWholeText(String searchText)"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean matches(Element root, Element element) {\n            return element.wholeText().contains(searchText);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "matches", "params": [{"name": "root", "type": "Element"}, {"name": "element", "type": "Element"}], "body": "                                                              {\n            return element.wholeText().contains(searchText);\n        }", "signature": "@Override\n        public boolean matches(Element root, Element element)"}, {"syntax_pass": true, "original_string": "        @Override protected int cost() {\n            return 10;\n        }", "docstring": "", "attributes": {"modifiers": "@Override protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "int", "classes": []}, "name": "cost", "params": [], "body": "                                       {\n            return 10;\n        }", "signature": "@Override protected int cost()"}, {"syntax_pass": true, "original_string": "        @Override\n        public String toString() {\n            return String.format(\":containsWholeText(%s)\", searchText);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "toString", "params": [], "body": "                                 {\n            return String.format(\":containsWholeText(%s)\", searchText);\n        }", "signature": "@Override\n        public String toString()"}]}, {"original_string": "    public static final class ContainsWholeOwnText extends Evaluator {\n        private final String searchText;\n\n        public ContainsWholeOwnText(String searchText) {\n            this.searchText = searchText;\n        }\n\n        @Override\n        public boolean matches(Element root, Element element) {\n            return element.wholeOwnText().contains(searchText);\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\":containsWholeOwnText(%s)\", searchText);\n        }\n    }", "definition": "    public static final class ContainsWholeOwnText extends Evaluator", "class_docstring": "\nEvaluator for matching Element (but <b>not</b> its descendants) wholeText. Neither the input nor the element text is\nnormalized. <code>:containsWholeOwnText()</code>\n@since 1.15.1.\n", "name": "ContainsWholeOwnText", "super_interfaces": [], "superclasses": "Evaluator", "attributes": {"modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "fields": [{"attribute_expression": "private final String searchText;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "searchText", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        public ContainsWholeOwnText(String searchText) {\n            this.searchText = searchText;\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "ContainsWholeOwnText", "params": [{"name": "searchText", "type": "String"}], "body": "                                                       {\n            this.searchText = searchText;\n        }", "signature": "public ContainsWholeOwnText(String searchText)"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean matches(Element root, Element element) {\n            return element.wholeOwnText().contains(searchText);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "matches", "params": [{"name": "root", "type": "Element"}, {"name": "element", "type": "Element"}], "body": "                                                              {\n            return element.wholeOwnText().contains(searchText);\n        }", "signature": "@Override\n        public boolean matches(Element root, Element element)"}, {"syntax_pass": true, "original_string": "        @Override\n        public String toString() {\n            return String.format(\":containsWholeOwnText(%s)\", searchText);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "toString", "params": [], "body": "                                 {\n            return String.format(\":containsWholeOwnText(%s)\", searchText);\n        }", "signature": "@Override\n        public String toString()"}]}, {"original_string": "    public static final class ContainsData extends Evaluator {\n        private final String searchText;\n\n        public ContainsData(String searchText) {\n            this.searchText = lowerCase(searchText);\n        }\n\n        @Override\n        public boolean matches(Element root, Element element) {\n            return lowerCase(element.data()).contains(searchText); // not whitespace normalized\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\":containsData(%s)\", searchText);\n        }\n    }", "definition": "    public static final class ContainsData extends Evaluator", "class_docstring": "\nEvaluator for matching Element (and its descendants) data\n", "name": "ContainsData", "super_interfaces": [], "superclasses": "Evaluator", "attributes": {"modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "fields": [{"attribute_expression": "private final String searchText;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "searchText", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        public ContainsData(String searchText) {\n            this.searchText = lowerCase(searchText);\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "ContainsData", "params": [{"name": "searchText", "type": "String"}], "body": "                                               {\n            this.searchText = lowerCase(searchText);\n        }", "signature": "public ContainsData(String searchText)"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean matches(Element root, Element element) {\n            return lowerCase(element.data()).contains(searchText); // not whitespace normalized\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "matches", "params": [{"name": "root", "type": "Element"}, {"name": "element", "type": "Element"}], "body": "                                                              {\n            return lowerCase(element.data()).contains(searchText); // not whitespace normalized\n        }", "signature": "@Override\n        public boolean matches(Element root, Element element)"}, {"syntax_pass": true, "original_string": "        @Override\n        public String toString() {\n            return String.format(\":containsData(%s)\", searchText);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "toString", "params": [], "body": "                                 {\n            return String.format(\":containsData(%s)\", searchText);\n        }", "signature": "@Override\n        public String toString()"}]}, {"original_string": "    public static final class ContainsOwnText extends Evaluator {\n        private final String searchText;\n\n        public ContainsOwnText(String searchText) {\n            this.searchText = lowerCase(normaliseWhitespace(searchText));\n        }\n\n        @Override\n        public boolean matches(Element root, Element element) {\n            return lowerCase(element.ownText()).contains(searchText);\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\":containsOwn(%s)\", searchText);\n        }\n    }", "definition": "    public static final class ContainsOwnText extends Evaluator", "class_docstring": "\nEvaluator for matching Element's own text\n", "name": "ContainsOwnText", "super_interfaces": [], "superclasses": "Evaluator", "attributes": {"modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "fields": [{"attribute_expression": "private final String searchText;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "searchText", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        public ContainsOwnText(String searchText) {\n            this.searchText = lowerCase(normaliseWhitespace(searchText));\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "ContainsOwnText", "params": [{"name": "searchText", "type": "String"}], "body": "                                                  {\n            this.searchText = lowerCase(normaliseWhitespace(searchText));\n        }", "signature": "public ContainsOwnText(String searchText)"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean matches(Element root, Element element) {\n            return lowerCase(element.ownText()).contains(searchText);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "matches", "params": [{"name": "root", "type": "Element"}, {"name": "element", "type": "Element"}], "body": "                                                              {\n            return lowerCase(element.ownText()).contains(searchText);\n        }", "signature": "@Override\n        public boolean matches(Element root, Element element)"}, {"syntax_pass": true, "original_string": "        @Override\n        public String toString() {\n            return String.format(\":containsOwn(%s)\", searchText);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "toString", "params": [], "body": "                                 {\n            return String.format(\":containsOwn(%s)\", searchText);\n        }", "signature": "@Override\n        public String toString()"}]}, {"original_string": "    public static final class Matches extends Evaluator {\n        private final Pattern pattern;\n\n        public Matches(Pattern pattern) {\n            this.pattern = pattern;\n        }\n\n        @Override\n        public boolean matches(Element root, Element element) {\n            Matcher m = pattern.matcher(element.text());\n            return m.find();\n        }\n\n        @Override protected int cost() {\n            return 8;\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\":matches(%s)\", pattern);\n        }\n    }", "definition": "    public static final class Matches extends Evaluator", "class_docstring": "\nEvaluator for matching Element (and its descendants) text with regex\n", "name": "Matches", "super_interfaces": [], "superclasses": "Evaluator", "attributes": {"modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "fields": [{"attribute_expression": "private final Pattern pattern;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Pattern", "name": "pattern", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        public Matches(Pattern pattern) {\n            this.pattern = pattern;\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "Matches", "params": [{"name": "pattern", "type": "Pattern"}], "body": "                                        {\n            this.pattern = pattern;\n        }", "signature": "public Matches(Pattern pattern)"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean matches(Element root, Element element) {\n            Matcher m = pattern.matcher(element.text());\n            return m.find();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "matches", "params": [{"name": "root", "type": "Element"}, {"name": "element", "type": "Element"}], "body": "                                                              {\n            Matcher m = pattern.matcher(element.text());\n            return m.find();\n        }", "signature": "@Override\n        public boolean matches(Element root, Element element)"}, {"syntax_pass": true, "original_string": "        @Override protected int cost() {\n            return 8;\n        }", "docstring": "", "attributes": {"modifiers": "@Override protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "int", "classes": []}, "name": "cost", "params": [], "body": "                                       {\n            return 8;\n        }", "signature": "@Override protected int cost()"}, {"syntax_pass": true, "original_string": "        @Override\n        public String toString() {\n            return String.format(\":matches(%s)\", pattern);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "toString", "params": [], "body": "                                 {\n            return String.format(\":matches(%s)\", pattern);\n        }", "signature": "@Override\n        public String toString()"}]}, {"original_string": "    public static final class MatchesOwn extends Evaluator {\n        private final Pattern pattern;\n\n        public MatchesOwn(Pattern pattern) {\n            this.pattern = pattern;\n        }\n\n        @Override\n        public boolean matches(Element root, Element element) {\n            Matcher m = pattern.matcher(element.ownText());\n            return m.find();\n        }\n\n        @Override protected int cost() {\n            return 7;\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\":matchesOwn(%s)\", pattern);\n        }\n    }", "definition": "    public static final class MatchesOwn extends Evaluator", "class_docstring": "\nEvaluator for matching Element's own text with regex\n", "name": "MatchesOwn", "super_interfaces": [], "superclasses": "Evaluator", "attributes": {"modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "fields": [{"attribute_expression": "private final Pattern pattern;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Pattern", "name": "pattern", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        public MatchesOwn(Pattern pattern) {\n            this.pattern = pattern;\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "MatchesOwn", "params": [{"name": "pattern", "type": "Pattern"}], "body": "                                           {\n            this.pattern = pattern;\n        }", "signature": "public MatchesOwn(Pattern pattern)"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean matches(Element root, Element element) {\n            Matcher m = pattern.matcher(element.ownText());\n            return m.find();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "matches", "params": [{"name": "root", "type": "Element"}, {"name": "element", "type": "Element"}], "body": "                                                              {\n            Matcher m = pattern.matcher(element.ownText());\n            return m.find();\n        }", "signature": "@Override\n        public boolean matches(Element root, Element element)"}, {"syntax_pass": true, "original_string": "        @Override protected int cost() {\n            return 7;\n        }", "docstring": "", "attributes": {"modifiers": "@Override protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "int", "classes": []}, "name": "cost", "params": [], "body": "                                       {\n            return 7;\n        }", "signature": "@Override protected int cost()"}, {"syntax_pass": true, "original_string": "        @Override\n        public String toString() {\n            return String.format(\":matchesOwn(%s)\", pattern);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "toString", "params": [], "body": "                                 {\n            return String.format(\":matchesOwn(%s)\", pattern);\n        }", "signature": "@Override\n        public String toString()"}]}, {"original_string": "    public static final class MatchesWholeText extends Evaluator {\n        private final Pattern pattern;\n\n        public MatchesWholeText(Pattern pattern) {\n            this.pattern = pattern;\n        }\n\n        @Override\n        public boolean matches(Element root, Element element) {\n            Matcher m = pattern.matcher(element.wholeText());\n            return m.find();\n        }\n\n        @Override protected int cost() {\n            return 8;\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\":matchesWholeText(%s)\", pattern);\n        }\n    }", "definition": "    public static final class MatchesWholeText extends Evaluator", "class_docstring": "\nEvaluator for matching Element (and its descendants) whole text with regex.\n@since 1.15.1.\n", "name": "MatchesWholeText", "super_interfaces": [], "superclasses": "Evaluator", "attributes": {"modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "fields": [{"attribute_expression": "private final Pattern pattern;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Pattern", "name": "pattern", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        public MatchesWholeText(Pattern pattern) {\n            this.pattern = pattern;\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "MatchesWholeText", "params": [{"name": "pattern", "type": "Pattern"}], "body": "                                                 {\n            this.pattern = pattern;\n        }", "signature": "public MatchesWholeText(Pattern pattern)"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean matches(Element root, Element element) {\n            Matcher m = pattern.matcher(element.wholeText());\n            return m.find();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "matches", "params": [{"name": "root", "type": "Element"}, {"name": "element", "type": "Element"}], "body": "                                                              {\n            Matcher m = pattern.matcher(element.wholeText());\n            return m.find();\n        }", "signature": "@Override\n        public boolean matches(Element root, Element element)"}, {"syntax_pass": true, "original_string": "        @Override protected int cost() {\n            return 8;\n        }", "docstring": "", "attributes": {"modifiers": "@Override protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "int", "classes": []}, "name": "cost", "params": [], "body": "                                       {\n            return 8;\n        }", "signature": "@Override protected int cost()"}, {"syntax_pass": true, "original_string": "        @Override\n        public String toString() {\n            return String.format(\":matchesWholeText(%s)\", pattern);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "toString", "params": [], "body": "                                 {\n            return String.format(\":matchesWholeText(%s)\", pattern);\n        }", "signature": "@Override\n        public String toString()"}]}, {"original_string": "    public static final class MatchesWholeOwnText extends Evaluator {\n        private final Pattern pattern;\n\n        public MatchesWholeOwnText(Pattern pattern) {\n            this.pattern = pattern;\n        }\n\n        @Override\n        public boolean matches(Element root, Element element) {\n            Matcher m = pattern.matcher(element.wholeOwnText());\n            return m.find();\n        }\n\n        @Override protected int cost() {\n            return 7;\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\":matchesWholeOwnText(%s)\", pattern);\n        }\n    }", "definition": "    public static final class MatchesWholeOwnText extends Evaluator", "class_docstring": "\nEvaluator for matching Element's own whole text with regex.\n@since 1.15.1.\n", "name": "MatchesWholeOwnText", "super_interfaces": [], "superclasses": "Evaluator", "attributes": {"modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "fields": [{"attribute_expression": "private final Pattern pattern;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Pattern", "name": "pattern", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        public MatchesWholeOwnText(Pattern pattern) {\n            this.pattern = pattern;\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "MatchesWholeOwnText", "params": [{"name": "pattern", "type": "Pattern"}], "body": "                                                    {\n            this.pattern = pattern;\n        }", "signature": "public MatchesWholeOwnText(Pattern pattern)"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean matches(Element root, Element element) {\n            Matcher m = pattern.matcher(element.wholeOwnText());\n            return m.find();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "matches", "params": [{"name": "root", "type": "Element"}, {"name": "element", "type": "Element"}], "body": "                                                              {\n            Matcher m = pattern.matcher(element.wholeOwnText());\n            return m.find();\n        }", "signature": "@Override\n        public boolean matches(Element root, Element element)"}, {"syntax_pass": true, "original_string": "        @Override protected int cost() {\n            return 7;\n        }", "docstring": "", "attributes": {"modifiers": "@Override protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "int", "classes": []}, "name": "cost", "params": [], "body": "                                       {\n            return 7;\n        }", "signature": "@Override protected int cost()"}, {"syntax_pass": true, "original_string": "        @Override\n        public String toString() {\n            return String.format(\":matchesWholeOwnText(%s)\", pattern);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "toString", "params": [], "body": "                                 {\n            return String.format(\":matchesWholeOwnText(%s)\", pattern);\n        }", "signature": "@Override\n        public String toString()"}]}, {"original_string": "    public static final class MatchText extends Evaluator {\n\n        @Override\n        public boolean matches(Element root, Element element) {\n            if (element instanceof PseudoTextElement)\n                return true;\n\n            List<TextNode> textNodes = element.textNodes();\n            for (TextNode textNode : textNodes) {\n                PseudoTextElement pel = new PseudoTextElement(\n                    org.jsoup.parser.Tag.valueOf(element.tagName(), element.tag().namespace(), ParseSettings.preserveCase), element.baseUri(), element.attributes());\n                textNode.replaceWith(pel);\n                pel.appendChild(textNode);\n            }\n            return false;\n        }\n\n        @Override protected int cost() {\n            return -1; // forces first evaluation, which prepares the DOM for later evaluator matches\n        }\n\n        @Override\n        public String toString() {\n            return \":matchText\";\n        }\n    }", "definition": "    public static final class MatchText extends Evaluator", "class_docstring": "", "name": "MatchText", "super_interfaces": [], "superclasses": "Evaluator", "attributes": {"modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        @Override\n        public boolean matches(Element root, Element element) {\n            if (element instanceof PseudoTextElement)\n                return true;\n\n            List<TextNode> textNodes = element.textNodes();\n            for (TextNode textNode : textNodes) {\n                PseudoTextElement pel = new PseudoTextElement(\n                    org.jsoup.parser.Tag.valueOf(element.tagName(), element.tag().namespace(), ParseSettings.preserveCase), element.baseUri(), element.attributes());\n                textNode.replaceWith(pel);\n                pel.appendChild(textNode);\n            }\n            return false;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "matches", "params": [{"name": "root", "type": "Element"}, {"name": "element", "type": "Element"}], "body": "                                                              {\n            if (element instanceof PseudoTextElement)\n                return true;\n\n            List<TextNode> textNodes = element.textNodes();\n            for (TextNode textNode : textNodes) {\n                PseudoTextElement pel = new PseudoTextElement(\n                    org.jsoup.parser.Tag.valueOf(element.tagName(), element.tag().namespace(), ParseSettings.preserveCase), element.baseUri(), element.attributes());\n                textNode.replaceWith(pel);\n                pel.appendChild(textNode);\n            }\n            return false;\n        }", "signature": "@Override\n        public boolean matches(Element root, Element element)"}, {"syntax_pass": true, "original_string": "        @Override protected int cost() {\n            return -1; // forces first evaluation, which prepares the DOM for later evaluator matches\n        }", "docstring": "", "attributes": {"modifiers": "@Override protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "int", "classes": []}, "name": "cost", "params": [], "body": "                                       {\n            return -1; // forces first evaluation, which prepares the DOM for later evaluator matches\n        }", "signature": "@Override protected int cost()"}, {"syntax_pass": true, "original_string": "        @Override\n        public String toString() {\n            return \":matchText\";\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "toString", "params": [], "body": "                                 {\n            return \":matchText\";\n        }", "signature": "@Override\n        public String toString()"}]}], "class_docstring": "\nEvaluates that an element matches the selector.\n", "original_string": "public abstract class Evaluator {\n    protected Evaluator() {\n    }\n\n    /**\n     Provides a Predicate for this Evaluator, matching the test Element.\n     * @param root the root Element, for match evaluation\n     * @return a predicate that accepts an Element to test for matches with this Evaluator\n     * @since 1.17.1\n     */\n    public Predicate<Element> asPredicate(Element root) {\n        return element -> matches(root, element);\n    }\n\n    /**\n     * Test if the element meets the evaluator's requirements.\n     *\n     * @param root    Root of the matching subtree\n     * @param element tested element\n     * @return Returns <tt>true</tt> if the requirements are met or\n     * <tt>false</tt> otherwise\n     */\n    public abstract boolean matches(Element root, Element element);\n\n    /**\n     Reset any internal state in this Evaluator before executing a new Collector evaluation.\n     */\n    protected void reset() {\n    }\n\n    /**\n     A relative evaluator cost function. During evaluation, Evaluators are sorted by ascending cost as an optimization.\n     * @return the relative cost of this Evaluator\n     */\n    protected int cost() {\n        return 5; // a nominal default cost\n    }\n\n    /**\n     * Evaluator for tag name\n     */\n    public static final class Tag extends Evaluator {\n        private final String tagName;\n\n        public Tag(String tagName) {\n            this.tagName = tagName;\n        }\n\n        @Override\n        public boolean matches(Element root, Element element) {\n            return (element.nameIs(tagName));\n        }\n\n        @Override protected int cost() {\n            return 1;\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\"%s\", tagName);\n        }\n    }\n\n    /**\n     * Evaluator for tag name that starts with prefix; used for ns|*\n     */\n    public static final class TagStartsWith extends Evaluator {\n        private final String tagName;\n\n        public TagStartsWith(String tagName) {\n            this.tagName = tagName;\n        }\n\n        @Override\n        public boolean matches(Element root, Element element) {\n            return (element.normalName().startsWith(tagName));\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\"%s\", tagName);\n        }\n    }\n\n\n    /**\n     * Evaluator for tag name that ends with suffix; used for *|el\n     */\n    public static final class TagEndsWith extends Evaluator {\n        private final String tagName;\n\n        public TagEndsWith(String tagName) {\n            this.tagName = tagName;\n        }\n\n        @Override\n        public boolean matches(Element root, Element element) {\n            return (element.normalName().endsWith(tagName));\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\"%s\", tagName);\n        }\n    }\n\n    /**\n     * Evaluator for element id\n     */\n    public static final class Id extends Evaluator {\n        private final String id;\n\n        public Id(String id) {\n            this.id = id;\n        }\n\n        @Override\n        public boolean matches(Element root, Element element) {\n            return (id.equals(element.id()));\n        }\n\n        @Override protected int cost() {\n            return 2;\n        }\n        @Override\n        public String toString() {\n            return String.format(\"#%s\", id);\n        }\n    }\n\n    /**\n     * Evaluator for element class\n     */\n    public static final class Class extends Evaluator {\n        private final String className;\n\n        public Class(String className) {\n            this.className = className;\n        }\n\n        @Override\n        public boolean matches(Element root, Element element) {\n            return (element.hasClass(className));\n        }\n\n        @Override protected int cost() {\n            return 6; // does whitespace scanning\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\".%s\", className);\n        }\n\n    }\n\n    /**\n     * Evaluator for attribute name matching\n     */\n    public static final class Attribute extends Evaluator {\n        private final String key;\n\n        public Attribute(String key) {\n            this.key = key;\n        }\n\n        @Override\n        public boolean matches(Element root, Element element) {\n            return element.hasAttr(key);\n        }\n\n        @Override protected int cost() {\n            return 2;\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\"[%s]\", key);\n        }\n    }\n\n    /**\n     * Evaluator for attribute name prefix matching\n     */\n    public static final class AttributeStarting extends Evaluator {\n        private final String keyPrefix;\n\n        public AttributeStarting(String keyPrefix) {\n            Validate.notNull(keyPrefix); // OK to be empty - will find elements with any attributes\n            this.keyPrefix = lowerCase(keyPrefix);\n        }\n\n        @Override\n        public boolean matches(Element root, Element element) {\n            List<org.jsoup.nodes.Attribute> values = element.attributes().asList();\n            for (org.jsoup.nodes.Attribute attribute : values) {\n                if (lowerCase(attribute.getKey()).startsWith(keyPrefix))\n                    return true;\n            }\n            return false;\n        }\n\n        @Override protected int cost() {\n            return 6;\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\"[^%s]\", keyPrefix);\n        }\n\n    }\n\n    /**\n     * Evaluator for attribute name/value matching\n     */\n    public static final class AttributeWithValue extends AttributeKeyPair {\n        public AttributeWithValue(String key, String value) {\n            super(key, value);\n        }\n\n        @Override\n        public boolean matches(Element root, Element element) {\n            return element.hasAttr(key) && value.equalsIgnoreCase(element.attr(key).trim());\n        }\n\n        @Override protected int cost() {\n            return 3;\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\"[%s=%s]\", key, value);\n        }\n\n    }\n\n    /**\n     * Evaluator for attribute name != value matching\n     */\n    public static final class AttributeWithValueNot extends AttributeKeyPair {\n        public AttributeWithValueNot(String key, String value) {\n            super(key, value);\n        }\n\n        @Override\n        public boolean matches(Element root, Element element) {\n            return !value.equalsIgnoreCase(element.attr(key));\n        }\n\n        @Override protected int cost() {\n            return 3;\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\"[%s!=%s]\", key, value);\n        }\n\n    }\n\n    /**\n     * Evaluator for attribute name/value matching (value prefix)\n     */\n    public static final class AttributeWithValueStarting extends AttributeKeyPair {\n        public AttributeWithValueStarting(String key, String value) {\n            super(key, value, false);\n        }\n\n        @Override\n        public boolean matches(Element root, Element element) {\n            return element.hasAttr(key) && lowerCase(element.attr(key)).startsWith(value); // value is lower case already\n        }\n\n        @Override protected int cost() {\n            return 4;\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\"[%s^=%s]\", key, value);\n        }\n    }\n\n    /**\n     * Evaluator for attribute name/value matching (value ending)\n     */\n    public static final class AttributeWithValueEnding extends AttributeKeyPair {\n        public AttributeWithValueEnding(String key, String value) {\n            super(key, value, false);\n        }\n\n        @Override\n        public boolean matches(Element root, Element element) {\n            return element.hasAttr(key) && lowerCase(element.attr(key)).endsWith(value); // value is lower case\n        }\n\n        @Override protected int cost() {\n            return 4;\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\"[%s$=%s]\", key, value);\n        }\n    }\n\n    /**\n     * Evaluator for attribute name/value matching (value containing)\n     */\n    public static final class AttributeWithValueContaining extends AttributeKeyPair {\n        public AttributeWithValueContaining(String key, String value) {\n            super(key, value);\n        }\n\n        @Override\n        public boolean matches(Element root, Element element) {\n            return element.hasAttr(key) && lowerCase(element.attr(key)).contains(value); // value is lower case\n        }\n\n        @Override protected int cost() {\n            return 6;\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\"[%s*=%s]\", key, value);\n        }\n\n    }\n\n    /**\n     * Evaluator for attribute name/value matching (value regex matching)\n     */\n    public static final class AttributeWithValueMatching extends Evaluator {\n        final String key;\n        final Pattern pattern;\n\n        public AttributeWithValueMatching(String key, Pattern pattern) {\n            this.key = normalize(key);\n            this.pattern = pattern;\n        }\n\n        @Override\n        public boolean matches(Element root, Element element) {\n            return element.hasAttr(key) && pattern.matcher(element.attr(key)).find();\n        }\n\n        @Override protected int cost() {\n            return 8;\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\"[%s~=%s]\", key, pattern.toString());\n        }\n\n    }\n\n    /**\n     * Abstract evaluator for attribute name/value matching\n     */\n    public abstract static class AttributeKeyPair extends Evaluator {\n        final String key;\n        final String value;\n\n        public AttributeKeyPair(String key, String value) {\n            this(key, value, true);\n        }\n\n        public AttributeKeyPair(String key, String value, boolean trimValue) {\n            Validate.notEmpty(key);\n            Validate.notEmpty(value);\n\n            this.key = normalize(key);\n            boolean isStringLiteral = value.startsWith(\"'\") && value.endsWith(\"'\")\n                                        || value.startsWith(\"\\\"\") && value.endsWith(\"\\\"\");\n            if (isStringLiteral) {\n                value = value.substring(1, value.length()-1);\n            }\n\n            this.value = trimValue ? normalize(value) : normalize(value, isStringLiteral);\n        }\n    }\n\n    /**\n     * Evaluator for any / all element matching\n     */\n    public static final class AllElements extends Evaluator {\n\n        @Override\n        public boolean matches(Element root, Element element) {\n            return true;\n        }\n\n        @Override protected int cost() {\n            return 10;\n        }\n\n        @Override\n        public String toString() {\n            return \"*\";\n        }\n    }\n\n    /**\n     * Evaluator for matching by sibling index number (e {@literal <} idx)\n     */\n    public static final class IndexLessThan extends IndexEvaluator {\n        public IndexLessThan(int index) {\n            super(index);\n        }\n\n        @Override\n        public boolean matches(Element root, Element element) {\n            return root != element && element.elementSiblingIndex() < index;\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\":lt(%d)\", index);\n        }\n\n    }\n\n    /**\n     * Evaluator for matching by sibling index number (e {@literal >} idx)\n     */\n    public static final class IndexGreaterThan extends IndexEvaluator {\n        public IndexGreaterThan(int index) {\n            super(index);\n        }\n\n        @Override\n        public boolean matches(Element root, Element element) {\n            return element.elementSiblingIndex() > index;\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\":gt(%d)\", index);\n        }\n\n    }\n\n    /**\n     * Evaluator for matching by sibling index number (e = idx)\n     */\n    public static final class IndexEquals extends IndexEvaluator {\n        public IndexEquals(int index) {\n            super(index);\n        }\n\n        @Override\n        public boolean matches(Element root, Element element) {\n            return element.elementSiblingIndex() == index;\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\":eq(%d)\", index);\n        }\n\n    }\n\n    /**\n     * Evaluator for matching the last sibling (css :last-child)\n     */\n    public static final class IsLastChild extends Evaluator {\n\t\t@Override\n\t\tpublic boolean matches(Element root, Element element) {\n\t\t\tfinal Element p = element.parent();\n\t\t\treturn p != null && !(p instanceof Document) && element == p.lastElementChild();\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \":last-child\";\n\t\t}\n    }\n\n    public static final class IsFirstOfType extends IsNthOfType {\n\t\tpublic IsFirstOfType() {\n\t\t\tsuper(0,1);\n\t\t}\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \":first-of-type\";\n\t\t}\n    }\n\n    public static final class IsLastOfType extends IsNthLastOfType {\n\t\tpublic IsLastOfType() {\n\t\t\tsuper(0,1);\n\t\t}\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \":last-of-type\";\n\t\t}\n    }\n\n\n    public static abstract class CssNthEvaluator extends Evaluator {\n    \tprotected final int a, b;\n\n    \tpublic CssNthEvaluator(int a, int b) {\n    \t\tthis.a = a;\n    \t\tthis.b = b;\n    \t}\n    \tpublic CssNthEvaluator(int b) {\n    \t\tthis(0,b);\n    \t}\n\n    \t@Override\n    \tpublic boolean matches(Element root, Element element) {\n    \t\tfinal Element p = element.parent();\n    \t\tif (p == null || (p instanceof Document)) return false;\n\n    \t\tfinal int pos = calculatePosition(root, element);\n    \t\tif (a == 0) return pos == b;\n\n    \t\treturn (pos-b)*a >= 0 && (pos-b)%a==0;\n    \t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\tif (a == 0)\n\t\t\t\treturn String.format(\":%s(%d)\",getPseudoClass(), b);\n\t\t\tif (b == 0)\n\t\t\t\treturn String.format(\":%s(%dn)\",getPseudoClass(), a);\n\t\t\treturn String.format(\":%s(%dn%+d)\", getPseudoClass(),a, b);\n\t\t}\n\n\t\tprotected abstract String getPseudoClass();\n\t\tprotected abstract int calculatePosition(Element root, Element element);\n    }\n\n\n    /**\n     * css-compatible Evaluator for :eq (css :nth-child)\n     *\n     * @see IndexEquals\n     */\n    public static final class IsNthChild extends CssNthEvaluator {\n\n    \tpublic IsNthChild(int a, int b) {\n    \t\tsuper(a,b);\n\t\t}\n\n\t\t@Override protected int calculatePosition(Element root, Element element) {\n\t\t\treturn element.elementSiblingIndex()+1;\n\t\t}\n\n\n\t\t@Override protected String getPseudoClass() {\n\t\t\treturn \"nth-child\";\n\t\t}\n    }\n\n    /**\n     * css pseudo class :nth-last-child)\n     *\n     * @see IndexEquals\n     */\n    public static final class IsNthLastChild extends CssNthEvaluator {\n    \tpublic IsNthLastChild(int a, int b) {\n    \t\tsuper(a,b);\n    \t}\n\n        @Override\n        protected int calculatePosition(Element root, Element element) {\n    \t    if (element.parent() == null)\n    \t        return 0;\n        \treturn element.parent().childrenSize()- element.elementSiblingIndex();\n        }\n\n\t\t@Override\n\t\tprotected String getPseudoClass() {\n\t\t\treturn \"nth-last-child\";\n\t\t}\n    }\n\n    /**\n     * css pseudo class nth-of-type\n     *\n     */\n    public static class IsNthOfType extends CssNthEvaluator {\n        public IsNthOfType(int a, int b) {\n            super(a, b);\n        }\n\n        @Override protected int calculatePosition(Element root, Element element) {\n            Element parent = element.parent();\n            if (parent == null)\n                return 0;\n\n            int pos = 0;\n            final int size = parent.childNodeSize();\n            for (int i = 0; i < size; i++) {\n                Node node = parent.childNode(i);\n                if (node.normalName().equals(element.normalName())) pos++;\n                if (node == element) break;\n            }\n            return pos;\n        }\n\n        @Override\n        protected String getPseudoClass() {\n            return \"nth-of-type\";\n        }\n    }\n\n    public static class IsNthLastOfType extends CssNthEvaluator {\n\n        public IsNthLastOfType(int a, int b) {\n            super(a, b);\n        }\n\n        @Override\n        protected int calculatePosition(Element root, Element element) {\n            Element parent = element.parent();\n            if (parent == null)\n                return 0;\n\n            int pos = 0;\n            Element next = element;\n            while (next != null) {\n                if (next.normalName().equals(element.normalName()))\n                    pos++;\n                next = next.nextElementSibling();\n            }\n            return pos;\n        }\n\n        @Override\n        protected String getPseudoClass() {\n            return \"nth-last-of-type\";\n        }\n    }\n\n    /**\n     * Evaluator for matching the first sibling (css :first-child)\n     */\n    public static final class IsFirstChild extends Evaluator {\n    \t@Override\n    \tpublic boolean matches(Element root, Element element) {\n    \t\tfinal Element p = element.parent();\n    \t\treturn p != null && !(p instanceof Document) && element == p.firstElementChild();\n    \t}\n\n    \t@Override\n    \tpublic String toString() {\n    \t\treturn \":first-child\";\n    \t}\n    }\n\n    /**\n     * css3 pseudo-class :root\n     * @see <a href=\"http://www.w3.org/TR/selectors/#root-pseudo\">:root selector</a>\n     *\n     */\n    public static final class IsRoot extends Evaluator {\n    \t@Override\n    \tpublic boolean matches(Element root, Element element) {\n    \t\tfinal Element r = root instanceof Document ? root.firstElementChild() : root;\n    \t\treturn element == r;\n    \t}\n\n        @Override protected int cost() {\n            return 1;\n        }\n\n    \t@Override\n    \tpublic String toString() {\n    \t\treturn \":root\";\n    \t}\n    }\n\n    public static final class IsOnlyChild extends Evaluator {\n\t\t@Override\n\t\tpublic boolean matches(Element root, Element element) {\n\t\t\tfinal Element p = element.parent();\n\t\t\treturn p!=null && !(p instanceof Document) && element.siblingElements().isEmpty();\n\t\t}\n    \t@Override\n    \tpublic String toString() {\n    \t\treturn \":only-child\";\n    \t}\n    }\n\n    public static final class IsOnlyOfType extends Evaluator {\n\t\t@Override\n\t\tpublic boolean matches(Element root, Element element) {\n\t\t\tfinal Element p = element.parent();\n\t\t\tif (p==null || p instanceof Document) return false;\n\n\t\t\tint pos = 0;\n            Element next = p.firstElementChild();\n            while (next != null) {\n                if (next.normalName().equals(element.normalName()))\n                    pos++;\n                if (pos > 1)\n                    break;\n                next = next.nextElementSibling();\n            }\n        \treturn pos == 1;\n\t\t}\n    \t@Override\n    \tpublic String toString() {\n    \t\treturn \":only-of-type\";\n    \t}\n    }\n\n    public static final class IsEmpty extends Evaluator {\n        @Override\n        public boolean matches(Element root, Element el) {\n            for (Node n = el.firstChild(); n != null; n = n.nextSibling()) {\n                if (n instanceof TextNode) {\n                    if (!((TextNode) n).isBlank())\n                        return false; // non-blank text: not empty\n                } else if (!(n instanceof Comment || n instanceof XmlDeclaration || n instanceof DocumentType))\n                    return false; // non \"blank\" element: not empty\n            }\n            return true;\n        }\n\n        @Override\n        public String toString() {\n            return \":empty\";\n        }\n    }\n\n    /**\n     * Abstract evaluator for sibling index matching\n     *\n     * @author ant\n     */\n    public abstract static class IndexEvaluator extends Evaluator {\n        final int index;\n\n        public IndexEvaluator(int index) {\n            this.index = index;\n        }\n    }\n\n    /**\n     * Evaluator for matching Element (and its descendants) text\n     */\n    public static final class ContainsText extends Evaluator {\n        private final String searchText;\n\n        public ContainsText(String searchText) {\n            this.searchText = lowerCase(normaliseWhitespace(searchText));\n        }\n\n        @Override\n        public boolean matches(Element root, Element element) {\n            return lowerCase(element.text()).contains(searchText);\n        }\n\n        @Override protected int cost() {\n            return 10;\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\":contains(%s)\", searchText);\n        }\n    }\n\n    /**\n     * Evaluator for matching Element (and its descendants) wholeText. Neither the input nor the element text is\n     * normalized. <code>:containsWholeText()</code>\n     * @since 1.15.1.\n     */\n    public static final class ContainsWholeText extends Evaluator {\n        private final String searchText;\n\n        public ContainsWholeText(String searchText) {\n            this.searchText = searchText;\n        }\n\n        @Override\n        public boolean matches(Element root, Element element) {\n            return element.wholeText().contains(searchText);\n        }\n\n        @Override protected int cost() {\n            return 10;\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\":containsWholeText(%s)\", searchText);\n        }\n    }\n\n    /**\n     * Evaluator for matching Element (but <b>not</b> its descendants) wholeText. Neither the input nor the element text is\n     * normalized. <code>:containsWholeOwnText()</code>\n     * @since 1.15.1.\n     */\n    public static final class ContainsWholeOwnText extends Evaluator {\n        private final String searchText;\n\n        public ContainsWholeOwnText(String searchText) {\n            this.searchText = searchText;\n        }\n\n        @Override\n        public boolean matches(Element root, Element element) {\n            return element.wholeOwnText().contains(searchText);\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\":containsWholeOwnText(%s)\", searchText);\n        }\n    }\n\n    /**\n     * Evaluator for matching Element (and its descendants) data\n     */\n    public static final class ContainsData extends Evaluator {\n        private final String searchText;\n\n        public ContainsData(String searchText) {\n            this.searchText = lowerCase(searchText);\n        }\n\n        @Override\n        public boolean matches(Element root, Element element) {\n            return lowerCase(element.data()).contains(searchText); // not whitespace normalized\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\":containsData(%s)\", searchText);\n        }\n    }\n\n    /**\n     * Evaluator for matching Element's own text\n     */\n    public static final class ContainsOwnText extends Evaluator {\n        private final String searchText;\n\n        public ContainsOwnText(String searchText) {\n            this.searchText = lowerCase(normaliseWhitespace(searchText));\n        }\n\n        @Override\n        public boolean matches(Element root, Element element) {\n            return lowerCase(element.ownText()).contains(searchText);\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\":containsOwn(%s)\", searchText);\n        }\n    }\n\n    /**\n     * Evaluator for matching Element (and its descendants) text with regex\n     */\n    public static final class Matches extends Evaluator {\n        private final Pattern pattern;\n\n        public Matches(Pattern pattern) {\n            this.pattern = pattern;\n        }\n\n        @Override\n        public boolean matches(Element root, Element element) {\n            Matcher m = pattern.matcher(element.text());\n            return m.find();\n        }\n\n        @Override protected int cost() {\n            return 8;\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\":matches(%s)\", pattern);\n        }\n    }\n\n    /**\n     * Evaluator for matching Element's own text with regex\n     */\n    public static final class MatchesOwn extends Evaluator {\n        private final Pattern pattern;\n\n        public MatchesOwn(Pattern pattern) {\n            this.pattern = pattern;\n        }\n\n        @Override\n        public boolean matches(Element root, Element element) {\n            Matcher m = pattern.matcher(element.ownText());\n            return m.find();\n        }\n\n        @Override protected int cost() {\n            return 7;\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\":matchesOwn(%s)\", pattern);\n        }\n    }\n\n    /**\n     * Evaluator for matching Element (and its descendants) whole text with regex.\n     * @since 1.15.1.\n     */\n    public static final class MatchesWholeText extends Evaluator {\n        private final Pattern pattern;\n\n        public MatchesWholeText(Pattern pattern) {\n            this.pattern = pattern;\n        }\n\n        @Override\n        public boolean matches(Element root, Element element) {\n            Matcher m = pattern.matcher(element.wholeText());\n            return m.find();\n        }\n\n        @Override protected int cost() {\n            return 8;\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\":matchesWholeText(%s)\", pattern);\n        }\n    }\n\n    /**\n     * Evaluator for matching Element's own whole text with regex.\n     * @since 1.15.1.\n     */\n    public static final class MatchesWholeOwnText extends Evaluator {\n        private final Pattern pattern;\n\n        public MatchesWholeOwnText(Pattern pattern) {\n            this.pattern = pattern;\n        }\n\n        @Override\n        public boolean matches(Element root, Element element) {\n            Matcher m = pattern.matcher(element.wholeOwnText());\n            return m.find();\n        }\n\n        @Override protected int cost() {\n            return 7;\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\":matchesWholeOwnText(%s)\", pattern);\n        }\n    }\n\n    public static final class MatchText extends Evaluator {\n\n        @Override\n        public boolean matches(Element root, Element element) {\n            if (element instanceof PseudoTextElement)\n                return true;\n\n            List<TextNode> textNodes = element.textNodes();\n            for (TextNode textNode : textNodes) {\n                PseudoTextElement pel = new PseudoTextElement(\n                    org.jsoup.parser.Tag.valueOf(element.tagName(), element.tag().namespace(), ParseSettings.preserveCase), element.baseUri(), element.attributes());\n                textNode.replaceWith(pel);\n                pel.appendChild(textNode);\n            }\n            return false;\n        }\n\n        @Override protected int cost() {\n            return -1; // forces first evaluation, which prepares the DOM for later evaluator matches\n        }\n\n        @Override\n        public String toString() {\n            return \":matchText\";\n        }\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/main/java/org/jsoup/select/StructuralEvaluator.java.StructuralEvaluator", "name": "StructuralEvaluator", "file_path": "src/main/java/org/jsoup/select/StructuralEvaluator.java", "superclasses": "Evaluator", "methods": ["[]StructuralEvaluator(Evaluator)", "[boolean]memoMatches(Element,Element)", "[void]reset()"], "method_uris": ["src/main/java/org/jsoup/select/StructuralEvaluator.java.StructuralEvaluator.[]StructuralEvaluator(Evaluator)", "src/main/java/org/jsoup/select/StructuralEvaluator.java.StructuralEvaluator.[boolean]memoMatches(Element,Element)", "src/main/java/org/jsoup/select/StructuralEvaluator.java.StructuralEvaluator.[void]reset()"], "overrides": null, "attributes": [{"original_string": "    static class Root extends Evaluator {\n        @Override\n        public boolean matches(Element root, Element element) {\n            return root == element;\n        }\n\n        @Override protected int cost() {\n            return 1;\n        }\n\n        @Override public String toString() {\n            return \"\";\n        }\n    }", "definition": "    static class Root extends Evaluator", "class_docstring": "", "name": "Root", "super_interfaces": [], "superclasses": "Evaluator", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        @Override\n        public boolean matches(Element root, Element element) {\n            return root == element;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "matches", "params": [{"name": "root", "type": "Element"}, {"name": "element", "type": "Element"}], "body": "                                                              {\n            return root == element;\n        }", "signature": "@Override\n        public boolean matches(Element root, Element element)"}, {"syntax_pass": true, "original_string": "        @Override protected int cost() {\n            return 1;\n        }", "docstring": "", "attributes": {"modifiers": "@Override protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "int", "classes": []}, "name": "cost", "params": [], "body": "                                       {\n            return 1;\n        }", "signature": "@Override protected int cost()"}, {"syntax_pass": true, "original_string": "        @Override public String toString() {\n            return \"\";\n        }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "toString", "params": [], "body": "                                           {\n            return \"\";\n        }", "signature": "@Override public String toString()"}]}, {"original_string": "    static class Has extends StructuralEvaluator {\n        static final SoftPool<NodeIterator<Element>> ElementIterPool =\n            new SoftPool<>(() -> new NodeIterator<>(new Element(\"html\"), Element.class));\n        // the element here is just a placeholder so this can be final - gets set in restart()\n\n        private final boolean checkSiblings; // evaluating against siblings (or children)\n\n        public Has(Evaluator evaluator) {\n            super(evaluator);\n            checkSiblings = evalWantsSiblings(evaluator);\n        }\n\n        @Override public boolean matches(Element root, Element element) {\n            if (checkSiblings) { // evaluating against siblings\n                for (Element sib = element.firstElementSibling(); sib != null; sib = sib.nextElementSibling()) {\n                    if (sib != element && evaluator.matches(element, sib)) { // don't match against self\n                        return true;\n                    }\n                }\n            }\n            // otherwise we only want to match children (or below), and not the input element. And we want to minimize GCs so reusing the Iterator obj\n            NodeIterator<Element> it = ElementIterPool.borrow();\n            it.restart(element);\n            try {\n                while (it.hasNext()) {\n                    Element el = it.next();\n                    if (el == element) continue; // don't match self, only descendants\n                    if (evaluator.matches(element, el)) {\n                        return true;\n                    }\n                }\n            } finally {\n                ElementIterPool.release(it);\n            }\n            return false;\n        }\n\n        /* Test if the :has sub-clause wants sibling elements (vs nested elements) - will be a Combining eval */\n        private static boolean evalWantsSiblings(Evaluator eval) {\n            if (eval instanceof CombiningEvaluator) {\n                CombiningEvaluator ce = (CombiningEvaluator) eval;\n                for (Evaluator innerEval : ce.evaluators) {\n                    if (innerEval instanceof PreviousSibling || innerEval instanceof ImmediatePreviousSibling)\n                        return true;\n                }\n            }\n            return false;\n        }\n\n        @Override protected int cost() {\n            return 10 * evaluator.cost();\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\":has(%s)\", evaluator);\n        }\n    }", "definition": "    static class Has extends StructuralEvaluator", "class_docstring": "", "name": "Has", "super_interfaces": [], "superclasses": "StructuralEvaluator", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "fields": [{"attribute_expression": "static final SoftPool<NodeIterator<Element>> ElementIterPool =\n            new SoftPool<>(() -> new NodeIterator<>(new Element(\"html\"), Element.class));", "docstring": "", "modifiers": "static final", "marker_annotations": [], "non_marker_annotations": ["static", "final"], "comments": [], "type": "SoftPool<NodeIterator<Element>>", "name": "ElementIterPool =\n            new SoftPool<>(() -> new NodeIterator<>(new Element(\"html\"), Element.class))", "syntax_pass": true}, {"attribute_expression": "private final boolean checkSiblings;", "docstring": " the element here is just a placeholder so this can be final - gets set in restart()", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "boolean", "name": "checkSiblings", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        public Has(Evaluator evaluator) {\n            super(evaluator);\n            checkSiblings = evalWantsSiblings(evaluator);\n        }", "docstring": " evaluating against siblings (or children)", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "Has", "params": [{"name": "evaluator", "type": "Evaluator"}], "body": "                                        {\n            super(evaluator);\n            checkSiblings = evalWantsSiblings(evaluator);\n        }", "signature": "public Has(Evaluator evaluator)"}, {"syntax_pass": true, "original_string": "        @Override public boolean matches(Element root, Element element) {\n            if (checkSiblings) { // evaluating against siblings\n                for (Element sib = element.firstElementSibling(); sib != null; sib = sib.nextElementSibling()) {\n                    if (sib != element && evaluator.matches(element, sib)) { // don't match against self\n                        return true;\n                    }\n                }\n            }\n            // otherwise we only want to match children (or below), and not the input element. And we want to minimize GCs so reusing the Iterator obj\n            NodeIterator<Element> it = ElementIterPool.borrow();\n            it.restart(element);\n            try {\n                while (it.hasNext()) {\n                    Element el = it.next();\n                    if (el == element) continue; // don't match self, only descendants\n                    if (evaluator.matches(element, el)) {\n                        return true;\n                    }\n                }\n            } finally {\n                ElementIterPool.release(it);\n            }\n            return false;\n        }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "matches", "params": [{"name": "root", "type": "Element"}, {"name": "element", "type": "Element"}], "body": "                                                                        {\n            if (checkSiblings) { // evaluating against siblings\n                for (Element sib = element.firstElementSibling(); sib != null; sib = sib.nextElementSibling()) {\n                    if (sib != element && evaluator.matches(element, sib)) { // don't match against self\n                        return true;\n                    }\n                }\n            }\n            // otherwise we only want to match children (or below), and not the input element. And we want to minimize GCs so reusing the Iterator obj\n            NodeIterator<Element> it = ElementIterPool.borrow();\n            it.restart(element);\n            try {\n                while (it.hasNext()) {\n                    Element el = it.next();\n                    if (el == element) continue; // don't match self, only descendants\n                    if (evaluator.matches(element, el)) {\n                        return true;\n                    }\n                }\n            } finally {\n                ElementIterPool.release(it);\n            }\n            return false;\n        }", "signature": "@Override public boolean matches(Element root, Element element)"}, {"syntax_pass": true, "original_string": "        private static boolean evalWantsSiblings(Evaluator eval) {\n            if (eval instanceof CombiningEvaluator) {\n                CombiningEvaluator ce = (CombiningEvaluator) eval;\n                for (Evaluator innerEval : ce.evaluators) {\n                    if (innerEval instanceof PreviousSibling || innerEval instanceof ImmediatePreviousSibling)\n                        return true;\n                }\n            }\n            return false;\n        }", "docstring": " Test if the :has sub-clause wants sibling elements (vs nested elements) - will be a Combining eval", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "boolean", "classes": []}, "name": "evalWantsSiblings", "params": [{"name": "eval", "type": "Evaluator"}], "body": "                                                                 {\n            if (eval instanceof CombiningEvaluator) {\n                CombiningEvaluator ce = (CombiningEvaluator) eval;\n                for (Evaluator innerEval : ce.evaluators) {\n                    if (innerEval instanceof PreviousSibling || innerEval instanceof ImmediatePreviousSibling)\n                        return true;\n                }\n            }\n            return false;\n        }", "signature": "private static boolean evalWantsSiblings(Evaluator eval)"}, {"syntax_pass": true, "original_string": "        @Override protected int cost() {\n            return 10 * evaluator.cost();\n        }", "docstring": "", "attributes": {"modifiers": "@Override protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "int", "classes": []}, "name": "cost", "params": [], "body": "                                       {\n            return 10 * evaluator.cost();\n        }", "signature": "@Override protected int cost()"}, {"syntax_pass": true, "original_string": "        @Override\n        public String toString() {\n            return String.format(\":has(%s)\", evaluator);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "toString", "params": [], "body": "                                 {\n            return String.format(\":has(%s)\", evaluator);\n        }", "signature": "@Override\n        public String toString()"}]}, {"original_string": "    static class Is extends StructuralEvaluator {\n        public Is(Evaluator evaluator) {\n            super(evaluator);\n        }\n\n        @Override\n        public boolean matches(Element root, Element element) {\n            return evaluator.matches(root, element);\n        }\n\n        @Override protected int cost() {\n            return 2 + evaluator.cost();\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\":is(%s)\", evaluator);\n        }\n    }", "definition": "    static class Is extends StructuralEvaluator", "class_docstring": " Implements the :is(sub-query) pseudo-selector", "name": "Is", "super_interfaces": [], "superclasses": "StructuralEvaluator", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        public Is(Evaluator evaluator) {\n            super(evaluator);\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "Is", "params": [{"name": "evaluator", "type": "Evaluator"}], "body": "                                       {\n            super(evaluator);\n        }", "signature": "public Is(Evaluator evaluator)"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean matches(Element root, Element element) {\n            return evaluator.matches(root, element);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "matches", "params": [{"name": "root", "type": "Element"}, {"name": "element", "type": "Element"}], "body": "                                                              {\n            return evaluator.matches(root, element);\n        }", "signature": "@Override\n        public boolean matches(Element root, Element element)"}, {"syntax_pass": true, "original_string": "        @Override protected int cost() {\n            return 2 + evaluator.cost();\n        }", "docstring": "", "attributes": {"modifiers": "@Override protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "int", "classes": []}, "name": "cost", "params": [], "body": "                                       {\n            return 2 + evaluator.cost();\n        }", "signature": "@Override protected int cost()"}, {"syntax_pass": true, "original_string": "        @Override\n        public String toString() {\n            return String.format(\":is(%s)\", evaluator);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "toString", "params": [], "body": "                                 {\n            return String.format(\":is(%s)\", evaluator);\n        }", "signature": "@Override\n        public String toString()"}]}, {"original_string": "    static class Not extends StructuralEvaluator {\n        public Not(Evaluator evaluator) {\n            super(evaluator);\n        }\n\n        @Override\n        public boolean matches(Element root, Element element) {\n            return !memoMatches(root, element);\n        }\n\n        @Override protected int cost() {\n            return 2 + evaluator.cost();\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\":not(%s)\", evaluator);\n        }\n    }", "definition": "    static class Not extends StructuralEvaluator", "class_docstring": "", "name": "Not", "super_interfaces": [], "superclasses": "StructuralEvaluator", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        public Not(Evaluator evaluator) {\n            super(evaluator);\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "Not", "params": [{"name": "evaluator", "type": "Evaluator"}], "body": "                                        {\n            super(evaluator);\n        }", "signature": "public Not(Evaluator evaluator)"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean matches(Element root, Element element) {\n            return !memoMatches(root, element);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "matches", "params": [{"name": "root", "type": "Element"}, {"name": "element", "type": "Element"}], "body": "                                                              {\n            return !memoMatches(root, element);\n        }", "signature": "@Override\n        public boolean matches(Element root, Element element)"}, {"syntax_pass": true, "original_string": "        @Override protected int cost() {\n            return 2 + evaluator.cost();\n        }", "docstring": "", "attributes": {"modifiers": "@Override protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "int", "classes": []}, "name": "cost", "params": [], "body": "                                       {\n            return 2 + evaluator.cost();\n        }", "signature": "@Override protected int cost()"}, {"syntax_pass": true, "original_string": "        @Override\n        public String toString() {\n            return String.format(\":not(%s)\", evaluator);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "toString", "params": [], "body": "                                 {\n            return String.format(\":not(%s)\", evaluator);\n        }", "signature": "@Override\n        public String toString()"}]}, {"original_string": "    static class Parent extends StructuralEvaluator {\n        public Parent(Evaluator evaluator) {\n            super(evaluator);\n        }\n\n        @Override\n        public boolean matches(Element root, Element element) {\n            if (root == element)\n                return false;\n\n            for (Element parent = element.parent(); parent != null; parent = parent.parent()) {\n                if (memoMatches(root, parent))\n                    return true;\n                if (parent == root)\n                    break;\n            }\n            return false;\n        }\n\n        @Override protected int cost() {\n            return 2 * evaluator.cost();\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\"%s \", evaluator);\n        }\n    }", "definition": "    static class Parent extends StructuralEvaluator", "class_docstring": "", "name": "Parent", "super_interfaces": [], "superclasses": "StructuralEvaluator", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        public Parent(Evaluator evaluator) {\n            super(evaluator);\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "Parent", "params": [{"name": "evaluator", "type": "Evaluator"}], "body": "                                           {\n            super(evaluator);\n        }", "signature": "public Parent(Evaluator evaluator)"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean matches(Element root, Element element) {\n            if (root == element)\n                return false;\n\n            for (Element parent = element.parent(); parent != null; parent = parent.parent()) {\n                if (memoMatches(root, parent))\n                    return true;\n                if (parent == root)\n                    break;\n            }\n            return false;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "matches", "params": [{"name": "root", "type": "Element"}, {"name": "element", "type": "Element"}], "body": "                                                              {\n            if (root == element)\n                return false;\n\n            for (Element parent = element.parent(); parent != null; parent = parent.parent()) {\n                if (memoMatches(root, parent))\n                    return true;\n                if (parent == root)\n                    break;\n            }\n            return false;\n        }", "signature": "@Override\n        public boolean matches(Element root, Element element)"}, {"syntax_pass": true, "original_string": "        @Override protected int cost() {\n            return 2 * evaluator.cost();\n        }", "docstring": "", "attributes": {"modifiers": "@Override protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "int", "classes": []}, "name": "cost", "params": [], "body": "                                       {\n            return 2 * evaluator.cost();\n        }", "signature": "@Override protected int cost()"}, {"syntax_pass": true, "original_string": "        @Override\n        public String toString() {\n            return String.format(\"%s \", evaluator);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "toString", "params": [], "body": "                                 {\n            return String.format(\"%s \", evaluator);\n        }", "signature": "@Override\n        public String toString()"}]}, {"original_string": "    static class ImmediateParentRun extends Evaluator {\n        final ArrayList<Evaluator> evaluators = new ArrayList<>();\n        int cost = 2;\n\n        public ImmediateParentRun(Evaluator evaluator) {\n            evaluators.add(evaluator);\n            cost += evaluator.cost();\n        }\n\n        void add(Evaluator evaluator) {\n            evaluators.add(evaluator);\n            cost += evaluator.cost();\n        }\n\n        @Override\n        public boolean matches(Element root, Element element) {\n            if (element == root)\n                return false; // cannot match as the second eval (first parent test) would be above the root\n\n            for (int i = evaluators.size() -1; i >= 0; --i) {\n                if (element == null)\n                    return false;\n                Evaluator eval = evaluators.get(i);\n                if (!eval.matches(root, element))\n                    return false;\n                element = element.parent();\n            }\n            return true;\n        }\n\n        @Override protected int cost() {\n            return cost;\n        }\n\n        @Override\n        public String toString() {\n            return StringUtil.join(evaluators, \" > \");\n        }\n    }", "definition": "    static class ImmediateParentRun extends Evaluator", "class_docstring": "\nHolds a list of evaluators for one > two > three immediate parent matches, and the final direct evaluator under\ntest. To match, these are effectively ANDed together, starting from the last, matching up to the first.\n", "name": "ImmediateParentRun", "super_interfaces": [], "superclasses": "Evaluator", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "fields": [{"attribute_expression": "final ArrayList<Evaluator> evaluators = new ArrayList<>();", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "ArrayList<Evaluator>", "name": "evaluators = new ArrayList<>()", "syntax_pass": true}, {"attribute_expression": "int cost = 2;", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "int", "name": "cost = 2", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        public ImmediateParentRun(Evaluator evaluator) {\n            evaluators.add(evaluator);\n            cost += evaluator.cost();\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "ImmediateParentRun", "params": [{"name": "evaluator", "type": "Evaluator"}], "body": "                                                       {\n            evaluators.add(evaluator);\n            cost += evaluator.cost();\n        }", "signature": "public ImmediateParentRun(Evaluator evaluator)"}, {"syntax_pass": true, "original_string": "        void add(Evaluator evaluator) {\n            evaluators.add(evaluator);\n            cost += evaluator.cost();\n        }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "name": "add", "params": [{"name": "evaluator", "type": "Evaluator"}], "body": "                                      {\n            evaluators.add(evaluator);\n            cost += evaluator.cost();\n        }", "signature": "void add(Evaluator evaluator)"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean matches(Element root, Element element) {\n            if (element == root)\n                return false; // cannot match as the second eval (first parent test) would be above the root\n\n            for (int i = evaluators.size() -1; i >= 0; --i) {\n                if (element == null)\n                    return false;\n                Evaluator eval = evaluators.get(i);\n                if (!eval.matches(root, element))\n                    return false;\n                element = element.parent();\n            }\n            return true;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "matches", "params": [{"name": "root", "type": "Element"}, {"name": "element", "type": "Element"}], "body": "                                                              {\n            if (element == root)\n                return false; // cannot match as the second eval (first parent test) would be above the root\n\n            for (int i = evaluators.size() -1; i >= 0; --i) {\n                if (element == null)\n                    return false;\n                Evaluator eval = evaluators.get(i);\n                if (!eval.matches(root, element))\n                    return false;\n                element = element.parent();\n            }\n            return true;\n        }", "signature": "@Override\n        public boolean matches(Element root, Element element)"}, {"syntax_pass": true, "original_string": "        @Override protected int cost() {\n            return cost;\n        }", "docstring": "", "attributes": {"modifiers": "@Override protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "int", "classes": []}, "name": "cost", "params": [], "body": "                                       {\n            return cost;\n        }", "signature": "@Override protected int cost()"}, {"syntax_pass": true, "original_string": "        @Override\n        public String toString() {\n            return StringUtil.join(evaluators, \" > \");\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "toString", "params": [], "body": "                                 {\n            return StringUtil.join(evaluators, \" > \");\n        }", "signature": "@Override\n        public String toString()"}]}, {"original_string": "    static class PreviousSibling extends StructuralEvaluator {\n        public PreviousSibling(Evaluator evaluator) {\n            super(evaluator);\n        }\n\n        @Override\n        public boolean matches(Element root, Element element) {\n            if (root == element) return false;\n\n            for (Element sib = element.firstElementSibling(); sib != null; sib = sib.nextElementSibling()) {\n                if (sib == element) break;\n                if (memoMatches(root, sib)) return true;\n            }\n\n            return false;\n        }\n\n        @Override protected int cost() {\n            return 3 * evaluator.cost();\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\"%s ~ \", evaluator);\n        }\n    }", "definition": "    static class PreviousSibling extends StructuralEvaluator", "class_docstring": "", "name": "PreviousSibling", "super_interfaces": [], "superclasses": "StructuralEvaluator", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        public PreviousSibling(Evaluator evaluator) {\n            super(evaluator);\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "PreviousSibling", "params": [{"name": "evaluator", "type": "Evaluator"}], "body": "                                                    {\n            super(evaluator);\n        }", "signature": "public PreviousSibling(Evaluator evaluator)"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean matches(Element root, Element element) {\n            if (root == element) return false;\n\n            for (Element sib = element.firstElementSibling(); sib != null; sib = sib.nextElementSibling()) {\n                if (sib == element) break;\n                if (memoMatches(root, sib)) return true;\n            }\n\n            return false;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "matches", "params": [{"name": "root", "type": "Element"}, {"name": "element", "type": "Element"}], "body": "                                                              {\n            if (root == element) return false;\n\n            for (Element sib = element.firstElementSibling(); sib != null; sib = sib.nextElementSibling()) {\n                if (sib == element) break;\n                if (memoMatches(root, sib)) return true;\n            }\n\n            return false;\n        }", "signature": "@Override\n        public boolean matches(Element root, Element element)"}, {"syntax_pass": true, "original_string": "        @Override protected int cost() {\n            return 3 * evaluator.cost();\n        }", "docstring": "", "attributes": {"modifiers": "@Override protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "int", "classes": []}, "name": "cost", "params": [], "body": "                                       {\n            return 3 * evaluator.cost();\n        }", "signature": "@Override protected int cost()"}, {"syntax_pass": true, "original_string": "        @Override\n        public String toString() {\n            return String.format(\"%s ~ \", evaluator);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "toString", "params": [], "body": "                                 {\n            return String.format(\"%s ~ \", evaluator);\n        }", "signature": "@Override\n        public String toString()"}]}, {"original_string": "    static class ImmediatePreviousSibling extends StructuralEvaluator {\n        public ImmediatePreviousSibling(Evaluator evaluator) {\n            super(evaluator);\n        }\n\n        @Override\n        public boolean matches(Element root, Element element) {\n            if (root == element)\n                return false;\n\n            Element prev = element.previousElementSibling();\n            return prev != null && memoMatches(root, prev);\n        }\n\n        @Override protected int cost() {\n            return 2 + evaluator.cost();\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\"%s + \", evaluator);\n        }\n    }", "definition": "    static class ImmediatePreviousSibling extends StructuralEvaluator", "class_docstring": "", "name": "ImmediatePreviousSibling", "super_interfaces": [], "superclasses": "StructuralEvaluator", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        public ImmediatePreviousSibling(Evaluator evaluator) {\n            super(evaluator);\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "ImmediatePreviousSibling", "params": [{"name": "evaluator", "type": "Evaluator"}], "body": "                                                             {\n            super(evaluator);\n        }", "signature": "public ImmediatePreviousSibling(Evaluator evaluator)"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean matches(Element root, Element element) {\n            if (root == element)\n                return false;\n\n            Element prev = element.previousElementSibling();\n            return prev != null && memoMatches(root, prev);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "matches", "params": [{"name": "root", "type": "Element"}, {"name": "element", "type": "Element"}], "body": "                                                              {\n            if (root == element)\n                return false;\n\n            Element prev = element.previousElementSibling();\n            return prev != null && memoMatches(root, prev);\n        }", "signature": "@Override\n        public boolean matches(Element root, Element element)"}, {"syntax_pass": true, "original_string": "        @Override protected int cost() {\n            return 2 + evaluator.cost();\n        }", "docstring": "", "attributes": {"modifiers": "@Override protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "int", "classes": []}, "name": "cost", "params": [], "body": "                                       {\n            return 2 + evaluator.cost();\n        }", "signature": "@Override protected int cost()"}, {"syntax_pass": true, "original_string": "        @Override\n        public String toString() {\n            return String.format(\"%s + \", evaluator);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "toString", "params": [], "body": "                                 {\n            return String.format(\"%s + \", evaluator);\n        }", "signature": "@Override\n        public String toString()"}]}], "class_docstring": "\nBase structural evaluator.\n", "original_string": "abstract class StructuralEvaluator extends Evaluator {\n    final Evaluator evaluator;\n\n    public StructuralEvaluator(Evaluator evaluator) {\n        this.evaluator = evaluator;\n    }\n\n    // Memoize inner matches, to save repeated re-evaluations of parent, sibling etc.\n    // root + element: Boolean matches. ThreadLocal in case the Evaluator is compiled then reused across multi threads\n    final ThreadLocal<IdentityHashMap<Element, IdentityHashMap<Element, Boolean>>>\n        threadMemo = ThreadLocal.withInitial(IdentityHashMap::new);\n\n    boolean memoMatches(final Element root, final Element element) {\n        Map<Element, IdentityHashMap<Element, Boolean>> rootMemo = threadMemo.get();\n        Map<Element, Boolean> memo = rootMemo.computeIfAbsent(root, Functions.identityMapFunction());\n        return memo.computeIfAbsent(element, key -> evaluator.matches(root, key));\n    }\n\n    @Override protected void reset() {\n        threadMemo.get().clear();\n        super.reset();\n    }\n\n    static class Root extends Evaluator {\n        @Override\n        public boolean matches(Element root, Element element) {\n            return root == element;\n        }\n\n        @Override protected int cost() {\n            return 1;\n        }\n\n        @Override public String toString() {\n            return \"\";\n        }\n    }\n\n    static class Has extends StructuralEvaluator {\n        static final SoftPool<NodeIterator<Element>> ElementIterPool =\n            new SoftPool<>(() -> new NodeIterator<>(new Element(\"html\"), Element.class));\n        // the element here is just a placeholder so this can be final - gets set in restart()\n\n        private final boolean checkSiblings; // evaluating against siblings (or children)\n\n        public Has(Evaluator evaluator) {\n            super(evaluator);\n            checkSiblings = evalWantsSiblings(evaluator);\n        }\n\n        @Override public boolean matches(Element root, Element element) {\n            if (checkSiblings) { // evaluating against siblings\n                for (Element sib = element.firstElementSibling(); sib != null; sib = sib.nextElementSibling()) {\n                    if (sib != element && evaluator.matches(element, sib)) { // don't match against self\n                        return true;\n                    }\n                }\n            }\n            // otherwise we only want to match children (or below), and not the input element. And we want to minimize GCs so reusing the Iterator obj\n            NodeIterator<Element> it = ElementIterPool.borrow();\n            it.restart(element);\n            try {\n                while (it.hasNext()) {\n                    Element el = it.next();\n                    if (el == element) continue; // don't match self, only descendants\n                    if (evaluator.matches(element, el)) {\n                        return true;\n                    }\n                }\n            } finally {\n                ElementIterPool.release(it);\n            }\n            return false;\n        }\n\n        /* Test if the :has sub-clause wants sibling elements (vs nested elements) - will be a Combining eval */\n        private static boolean evalWantsSiblings(Evaluator eval) {\n            if (eval instanceof CombiningEvaluator) {\n                CombiningEvaluator ce = (CombiningEvaluator) eval;\n                for (Evaluator innerEval : ce.evaluators) {\n                    if (innerEval instanceof PreviousSibling || innerEval instanceof ImmediatePreviousSibling)\n                        return true;\n                }\n            }\n            return false;\n        }\n\n        @Override protected int cost() {\n            return 10 * evaluator.cost();\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\":has(%s)\", evaluator);\n        }\n    }\n\n    /** Implements the :is(sub-query) pseudo-selector */\n    static class Is extends StructuralEvaluator {\n        public Is(Evaluator evaluator) {\n            super(evaluator);\n        }\n\n        @Override\n        public boolean matches(Element root, Element element) {\n            return evaluator.matches(root, element);\n        }\n\n        @Override protected int cost() {\n            return 2 + evaluator.cost();\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\":is(%s)\", evaluator);\n        }\n    }\n\n    static class Not extends StructuralEvaluator {\n        public Not(Evaluator evaluator) {\n            super(evaluator);\n        }\n\n        @Override\n        public boolean matches(Element root, Element element) {\n            return !memoMatches(root, element);\n        }\n\n        @Override protected int cost() {\n            return 2 + evaluator.cost();\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\":not(%s)\", evaluator);\n        }\n    }\n\n    static class Parent extends StructuralEvaluator {\n        public Parent(Evaluator evaluator) {\n            super(evaluator);\n        }\n\n        @Override\n        public boolean matches(Element root, Element element) {\n            if (root == element)\n                return false;\n\n            for (Element parent = element.parent(); parent != null; parent = parent.parent()) {\n                if (memoMatches(root, parent))\n                    return true;\n                if (parent == root)\n                    break;\n            }\n            return false;\n        }\n\n        @Override protected int cost() {\n            return 2 * evaluator.cost();\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\"%s \", evaluator);\n        }\n    }\n\n    /**\n     Holds a list of evaluators for one > two > three immediate parent matches, and the final direct evaluator under\n     test. To match, these are effectively ANDed together, starting from the last, matching up to the first.\n     */\n    static class ImmediateParentRun extends Evaluator {\n        final ArrayList<Evaluator> evaluators = new ArrayList<>();\n        int cost = 2;\n\n        public ImmediateParentRun(Evaluator evaluator) {\n            evaluators.add(evaluator);\n            cost += evaluator.cost();\n        }\n\n        void add(Evaluator evaluator) {\n            evaluators.add(evaluator);\n            cost += evaluator.cost();\n        }\n\n        @Override\n        public boolean matches(Element root, Element element) {\n            if (element == root)\n                return false; // cannot match as the second eval (first parent test) would be above the root\n\n            for (int i = evaluators.size() -1; i >= 0; --i) {\n                if (element == null)\n                    return false;\n                Evaluator eval = evaluators.get(i);\n                if (!eval.matches(root, element))\n                    return false;\n                element = element.parent();\n            }\n            return true;\n        }\n\n        @Override protected int cost() {\n            return cost;\n        }\n\n        @Override\n        public String toString() {\n            return StringUtil.join(evaluators, \" > \");\n        }\n    }\n\n    static class PreviousSibling extends StructuralEvaluator {\n        public PreviousSibling(Evaluator evaluator) {\n            super(evaluator);\n        }\n\n        @Override\n        public boolean matches(Element root, Element element) {\n            if (root == element) return false;\n\n            for (Element sib = element.firstElementSibling(); sib != null; sib = sib.nextElementSibling()) {\n                if (sib == element) break;\n                if (memoMatches(root, sib)) return true;\n            }\n\n            return false;\n        }\n\n        @Override protected int cost() {\n            return 3 * evaluator.cost();\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\"%s ~ \", evaluator);\n        }\n    }\n\n    static class ImmediatePreviousSibling extends StructuralEvaluator {\n        public ImmediatePreviousSibling(Evaluator evaluator) {\n            super(evaluator);\n        }\n\n        @Override\n        public boolean matches(Element root, Element element) {\n            if (root == element)\n                return false;\n\n            Element prev = element.previousElementSibling();\n            return prev != null && memoMatches(root, prev);\n        }\n\n        @Override protected int cost() {\n            return 2 + evaluator.cost();\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\"%s + \", evaluator);\n        }\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "final Evaluator evaluator;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "Evaluator", "name": "evaluator", "syntax_pass": true}, {"attribute_expression": "final ThreadLocal<IdentityHashMap<Element, IdentityHashMap<Element, Boolean>>>\n        threadMemo = ThreadLocal.withInitial(IdentityHashMap::new);", "docstring": " root + element: Boolean matches. ThreadLocal in case the Evaluator is compiled then reused across multi threads", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "ThreadLocal<IdentityHashMap<Element, IdentityHashMap<Element, Boolean>>>", "name": "threadMemo = ThreadLocal.withInitial(IdentityHashMap::new)", "syntax_pass": true}]}, {"uris": "src/main/java/org/jsoup/parser/TreeBuilder.java.TreeBuilder", "name": "TreeBuilder", "file_path": "src/main/java/org/jsoup/parser/TreeBuilder.java", "superclasses": "", "methods": ["[ParseSettings]defaultSettings()", "[void]initialiseParse(Reader,String,Parser)", "[void]completeParse()", "[Document]parse(Reader,String,Parser)", "[List<Node>]parseFragment(String,Element,String,Parser)", "[void]initialiseParseFragment(Element)", "[List<Node>]completeParseFragment()", "[void]nodeListener(NodeVisitor)", "[TreeBuilder]newInstance()", "[void]runParser()", "[boolean]stepParser()", "[boolean]process(Token)", "[boolean]processStartTag(String)", "[boolean]processStartTag(String,Attributes)", "[boolean]processEndTag(String)", "[Element]pop()", "[void]push(Element)", "[Element]currentElement()", "[boolean]currentElementIs(String)", "[boolean]currentElementIs(String,String)", "[void]error(String)", "[void]error(String)", "[boolean]isContentForTagData(String)", "[Tag]tagFor(String,String,ParseSettings)", "[Tag]tagFor(String,ParseSettings)", "[String]defaultNamespace()", "[void]onNodeInserted(Node)", "[void]onNodeClosed(Node)", "[void]trackNodePosition(Node,boolean)"], "method_uris": ["src/main/java/org/jsoup/parser/TreeBuilder.java.TreeBuilder.[ParseSettings]defaultSettings()", "src/main/java/org/jsoup/parser/TreeBuilder.java.TreeBuilder.[void]initialiseParse(Reader,String,Parser)", "src/main/java/org/jsoup/parser/TreeBuilder.java.TreeBuilder.[void]completeParse()", "src/main/java/org/jsoup/parser/TreeBuilder.java.TreeBuilder.[Document]parse(Reader,String,Parser)", "src/main/java/org/jsoup/parser/TreeBuilder.java.TreeBuilder.[List<Node>]parseFragment(String,Element,String,Parser)", "src/main/java/org/jsoup/parser/TreeBuilder.java.TreeBuilder.[void]initialiseParseFragment(Element)", "src/main/java/org/jsoup/parser/TreeBuilder.java.TreeBuilder.[List<Node>]completeParseFragment()", "src/main/java/org/jsoup/parser/TreeBuilder.java.TreeBuilder.[void]nodeListener(NodeVisitor)", "src/main/java/org/jsoup/parser/TreeBuilder.java.TreeBuilder.[TreeBuilder]newInstance()", "src/main/java/org/jsoup/parser/TreeBuilder.java.TreeBuilder.[void]runParser()", "src/main/java/org/jsoup/parser/TreeBuilder.java.TreeBuilder.[boolean]stepParser()", "src/main/java/org/jsoup/parser/TreeBuilder.java.TreeBuilder.[boolean]process(Token)", "src/main/java/org/jsoup/parser/TreeBuilder.java.TreeBuilder.[boolean]processStartTag(String)", "src/main/java/org/jsoup/parser/TreeBuilder.java.TreeBuilder.[boolean]processStartTag(String,Attributes)", "src/main/java/org/jsoup/parser/TreeBuilder.java.TreeBuilder.[boolean]processEndTag(String)", "src/main/java/org/jsoup/parser/TreeBuilder.java.TreeBuilder.[Element]pop()", "src/main/java/org/jsoup/parser/TreeBuilder.java.TreeBuilder.[void]push(Element)", "src/main/java/org/jsoup/parser/TreeBuilder.java.TreeBuilder.[Element]currentElement()", "src/main/java/org/jsoup/parser/TreeBuilder.java.TreeBuilder.[boolean]currentElementIs(String)", "src/main/java/org/jsoup/parser/TreeBuilder.java.TreeBuilder.[boolean]currentElementIs(String,String)", "src/main/java/org/jsoup/parser/TreeBuilder.java.TreeBuilder.[void]error(String)", "src/main/java/org/jsoup/parser/TreeBuilder.java.TreeBuilder.[void]error(String)", "src/main/java/org/jsoup/parser/TreeBuilder.java.TreeBuilder.[boolean]isContentForTagData(String)", "src/main/java/org/jsoup/parser/TreeBuilder.java.TreeBuilder.[Tag]tagFor(String,String,ParseSettings)", "src/main/java/org/jsoup/parser/TreeBuilder.java.TreeBuilder.[Tag]tagFor(String,ParseSettings)", "src/main/java/org/jsoup/parser/TreeBuilder.java.TreeBuilder.[String]defaultNamespace()", "src/main/java/org/jsoup/parser/TreeBuilder.java.TreeBuilder.[void]onNodeInserted(Node)", "src/main/java/org/jsoup/parser/TreeBuilder.java.TreeBuilder.[void]onNodeClosed(Node)", "src/main/java/org/jsoup/parser/TreeBuilder.java.TreeBuilder.[void]trackNodePosition(Node,boolean)"], "overrides": null, "attributes": [], "class_docstring": "\n@author Jonathan Hedley\n", "original_string": "abstract class TreeBuilder {\n    protected Parser parser;\n    CharacterReader reader;\n    Tokeniser tokeniser;\n    Document doc; // current doc we are building into\n    ArrayList<Element> stack; // the stack of open elements\n    String baseUri; // current base uri, for creating new elements\n    Token currentToken; // currentToken is used for error and source position tracking. Null at start of fragment parse\n    ParseSettings settings;\n    Map<String, Tag> seenTags; // tags we've used in this parse; saves tag GC for custom tags.\n    @Nullable NodeVisitor nodeListener; // optional listener for node add / removes\n\n    private Token.StartTag start; // start tag to process\n    private final Token.EndTag end  = new Token.EndTag(this);\n    abstract ParseSettings defaultSettings();\n\n    boolean trackSourceRange;  // optionally tracks the source range of nodes and attributes\n\n    void initialiseParse(Reader input, String baseUri, Parser parser) {\n        Validate.notNullParam(input, \"input\");\n        Validate.notNullParam(baseUri, \"baseUri\");\n        Validate.notNull(parser);\n\n        doc = new Document(parser.defaultNamespace(), baseUri);\n        doc.parser(parser);\n        this.parser = parser;\n        settings = parser.settings();\n        reader = new CharacterReader(input);\n        trackSourceRange = parser.isTrackPosition();\n        reader.trackNewlines(parser.isTrackErrors() || trackSourceRange); // when tracking errors or source ranges, enable newline tracking for better legibility\n        tokeniser = new Tokeniser(this);\n        stack = new ArrayList<>(32);\n        seenTags = new HashMap<>();\n        start = new Token.StartTag(this);\n        currentToken = start; // init current token to the virtual start token.\n        this.baseUri = baseUri;\n        onNodeInserted(doc);\n    }\n\n    void completeParse() {\n        // tidy up - as the Parser and Treebuilder are retained in document for settings / fragments\n        if (reader == null) return;\n        reader.close();\n        reader = null;\n        tokeniser = null;\n        stack = null;\n        seenTags = null;\n    }\n\n    Document parse(Reader input, String baseUri, Parser parser) {\n        initialiseParse(input, baseUri, parser);\n        runParser();\n        return doc;\n    }\n\n    List<Node> parseFragment(String inputFragment, @Nullable Element context, String baseUri, Parser parser) {\n        initialiseParse(new StringReader(inputFragment), baseUri, parser);\n        initialiseParseFragment(context);\n        runParser();\n        return completeParseFragment();\n    }\n\n    void initialiseParseFragment(@Nullable Element context) {\n        // in Html, sets up context; no-op in XML\n    }\n\n    abstract List<Node> completeParseFragment();\n\n    /** Set the node listener, which will then get callbacks for node insert and removals. */\n    void nodeListener(NodeVisitor nodeListener) {\n        this.nodeListener = nodeListener;\n    }\n\n    /**\n     Create a new copy of this TreeBuilder\n     @return copy, ready for a new parse\n     */\n    abstract TreeBuilder newInstance();\n\n    void runParser() {\n        do {} while (stepParser()); // run until stepParser sees EOF\n        completeParse();\n    }\n\n    boolean stepParser() {\n        // if we have reached the end already, step by popping off the stack, to hit nodeRemoved callbacks:\n        if (currentToken.type == Token.TokenType.EOF) {\n            if (stack == null) {\n                return false;\n            } if (stack.isEmpty()) {\n                onNodeClosed(doc); // the root doc is not on the stack, so let this final step close it\n                stack = null;\n                return true;\n            }\n            pop();\n            return true;\n        }\n        final Token token = tokeniser.read();\n        currentToken = token;\n        process(token);\n        token.reset();\n        return true;\n    }\n\n    abstract boolean process(Token token);\n\n    boolean processStartTag(String name) {\n        // these are \"virtual\" start tags (auto-created by the treebuilder), so not tracking the start position\n        final Token.StartTag start = this.start;\n        if (currentToken == start) { // don't recycle an in-use token\n            return process(new Token.StartTag(this).name(name));\n        }\n        return process(start.reset().name(name));\n    }\n\n    boolean processStartTag(String name, Attributes attrs) {\n        final Token.StartTag start = this.start;\n        if (currentToken == start) { // don't recycle an in-use token\n            return process(new Token.StartTag(this).nameAttr(name, attrs));\n        }\n        start.reset();\n        start.nameAttr(name, attrs);\n        return process(start);\n    }\n\n    boolean processEndTag(String name) {\n        if (currentToken == end) { // don't recycle an in-use token\n            return process(new Token.EndTag(this).name(name));\n        }\n        return process(end.reset().name(name));\n    }\n\n    /**\n     Removes the last Element from the stack, hits onNodeClosed, and then returns it.\n     * @return\n     */\n    final Element pop() {\n        int size = stack.size();\n        Element removed = stack.remove(size - 1);\n        onNodeClosed(removed);\n        return removed;\n    }\n\n    /**\n     Adds the specified Element to the end of the stack, and hits onNodeInserted.\n     * @param element\n     */\n    final void push(Element element) {\n        stack.add(element);\n        onNodeInserted(element);\n    }\n\n    /**\n     Get the current element (last on the stack). If all items have been removed, returns the document instead\n     (which might not actually be on the stack; use stack.size() == 0 to test if required.\n     @return the last element on the stack, if any; or the root document\n     */\n    Element currentElement() {\n        int size = stack.size();\n        return size > 0 ? stack.get(size-1) : doc;\n    }\n\n    /**\n     Checks if the Current Element's normal name equals the supplied name, in the HTML namespace.\n     @param normalName name to check\n     @return true if there is a current element on the stack, and its name equals the supplied\n     */\n    boolean currentElementIs(String normalName) {\n        if (stack.size() == 0)\n            return false;\n        Element current = currentElement();\n        return current != null && current.normalName().equals(normalName)\n            && current.tag().namespace().equals(NamespaceHtml);\n    }\n\n    /**\n     Checks if the Current Element's normal name equals the supplied name, in the specified namespace.\n     @param normalName name to check\n     @param namespace the namespace\n     @return true if there is a current element on the stack, and its name equals the supplied\n     */\n    boolean currentElementIs(String normalName, String namespace) {\n        if (stack.size() == 0)\n            return false;\n        Element current = currentElement();\n        return current != null && current.normalName().equals(normalName)\n            && current.tag().namespace().equals(namespace);\n    }\n\n    /**\n     * If the parser is tracking errors, add an error at the current position.\n     * @param msg error message\n     */\n    void error(String msg) {\n        error(msg, (Object[]) null);\n    }\n\n    /**\n     * If the parser is tracking errors, add an error at the current position.\n     * @param msg error message template\n     * @param args template arguments\n     */\n    void error(String msg, Object... args) {\n        ParseErrorList errors = parser.getErrors();\n        if (errors.canAddError())\n            errors.add(new ParseError(reader, msg, args));\n    }\n\n    /**\n     (An internal method, visible for Element. For HTML parse, signals that script and style text should be treated as\n     Data Nodes).\n     */\n    boolean isContentForTagData(String normalName) {\n        return false;\n    }\n\n    Tag tagFor(String tagName, String namespace, ParseSettings settings) {\n        Tag cached = seenTags.get(tagName); // note that we don't normalize the cache key. But tag via valueOf may be normalized.\n        if (cached == null || !cached.namespace().equals(namespace)) {\n            // only return from cache if the namespace is the same. not running nested cache to save double hit on the common flow\n            Tag tag = Tag.valueOf(tagName, namespace, settings);\n            seenTags.put(tagName, tag);\n            return tag;\n        }\n        return cached;\n    }\n\n    Tag tagFor(String tagName, ParseSettings settings) {\n        return tagFor(tagName, defaultNamespace(), settings);\n    }\n\n    /**\n     Gets the default namespace for this TreeBuilder\n     * @return the default namespace\n     */\n    String defaultNamespace() {\n        return NamespaceHtml;\n    }\n\n    /**\n     Called by implementing TreeBuilders when a node has been inserted. This implementation includes optionally tracking\n     the source range of the node.  @param node the node that was just inserted\n     */\n    void onNodeInserted(Node node) {\n        trackNodePosition(node, true);\n\n        if (nodeListener != null)\n            nodeListener.head(node, stack.size());\n    }\n\n    /**\n     Called by implementing TreeBuilders when a node is explicitly closed. This implementation includes optionally\n     tracking the closing source range of the node.  @param node the node being closed\n     */\n    void onNodeClosed(Node node) {\n        trackNodePosition(node, false);\n\n        if (nodeListener != null)\n            nodeListener.tail(node, stack.size());\n    }\n\n    private void trackNodePosition(Node node, boolean isStart) {\n        if (!trackSourceRange) return;\n\n        final Token token = currentToken;\n        int startPos = token.startPos();\n        int endPos = token.endPos();\n\n        // handle implicit element open / closes.\n        if (node instanceof Element) {\n            final Element el = (Element) node;\n            if (token.isEOF()) {\n                if (el.endSourceRange().isTracked())\n                    return; // /body and /html are left on stack until EOF, don't reset them\n                startPos = endPos = reader.pos();\n            } else if (isStart) { // opening tag\n                if  (!token.isStartTag() || !el.normalName().equals(token.asStartTag().normalName)) {\n                    endPos = startPos;\n                }\n            } else { // closing tag\n                if (!el.tag().isEmpty() && !el.tag().isSelfClosing()) {\n                    if (!token.isEndTag() || !el.normalName().equals(token.asEndTag().normalName)) {\n                        endPos = startPos;\n                    }\n                }\n            }\n        }\n\n        Range.Position startPosition = new Range.Position\n            (startPos, reader.lineNumber(startPos), reader.columnNumber(startPos));\n        Range.Position endPosition = new Range.Position\n            (endPos, reader.lineNumber(endPos), reader.columnNumber(endPos));\n        Range range = new Range(startPosition, endPosition);\n        node.attributes().userData(isStart ? SharedConstants.RangeKey : SharedConstants.EndRangeKey, range);\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "protected Parser parser;", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "Parser", "name": "parser", "syntax_pass": true}, {"attribute_expression": "CharacterReader reader;", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "CharacterReader", "name": "reader", "syntax_pass": true}, {"attribute_expression": "Tokeniser tokeniser;", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "Tokeniser", "name": "tokeniser", "syntax_pass": true}, {"attribute_expression": "Document doc;", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "Document", "name": "doc", "syntax_pass": true}, {"attribute_expression": "ArrayList<Element> stack;", "docstring": " current doc we are building into", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "ArrayList<Element>", "name": "stack", "syntax_pass": true}, {"attribute_expression": "String baseUri;", "docstring": " the stack of open elements", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "String", "name": "baseUri", "syntax_pass": true}, {"attribute_expression": "Token currentToken;", "docstring": " current base uri, for creating new elements", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "Token", "name": "currentToken", "syntax_pass": true}, {"attribute_expression": "ParseSettings settings;", "docstring": " currentToken is used for error and source position tracking. Null at start of fragment parse", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "ParseSettings", "name": "settings", "syntax_pass": true}, {"attribute_expression": "Map<String, Tag> seenTags;", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "Map<String, Tag>", "name": "seenTags", "syntax_pass": true}, {"attribute_expression": "@Nullable NodeVisitor nodeListener;", "docstring": " tags we've used in this parse; saves tag GC for custom tags.", "modifiers": "@Nullable", "marker_annotations": ["@Nullable"], "non_marker_annotations": [], "comments": [], "type": "NodeVisitor", "name": "nodeListener", "syntax_pass": true}, {"attribute_expression": "private Token.StartTag start;", "docstring": " optional listener for node add / removes", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Token.StartTag", "name": "start", "syntax_pass": true}, {"attribute_expression": "private final Token.EndTag end  = new Token.EndTag(this);", "docstring": " start tag to process", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Token.EndTag", "name": "end  = new Token.EndTag(this)", "syntax_pass": true}, {"attribute_expression": "boolean trackSourceRange;", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "boolean", "name": "trackSourceRange", "syntax_pass": true}]}, {"uris": "src/main/java/org/jsoup/parser/Token.java.Token", "name": "Token", "file_path": "src/main/java/org/jsoup/parser/Token.java", "superclasses": "", "methods": ["[]Token(TokenType)", "[String]tokenType()", "[Token]reset()", "[int]startPos()", "[void]startPos(int)", "[int]endPos()", "[void]endPos(int)", "[void]reset(StringBuilder)", "[boolean]isDoctype()", "[Doctype]asDoctype()", "[boolean]isStartTag()", "[StartTag]asStartTag()", "[boolean]isEndTag()", "[EndTag]asEndTag()", "[boolean]isComment()", "[Comment]asComment()", "[boolean]isCharacter()", "[boolean]isCData()", "[Character]asCharacter()", "[boolean]isEOF()"], "method_uris": ["src/main/java/org/jsoup/parser/Token.java.Token.[]Token(TokenType)", "src/main/java/org/jsoup/parser/Token.java.Token.[String]tokenType()", "src/main/java/org/jsoup/parser/Token.java.Token.[Token]reset()", "src/main/java/org/jsoup/parser/Token.java.Token.[int]startPos()", "src/main/java/org/jsoup/parser/Token.java.Token.[void]startPos(int)", "src/main/java/org/jsoup/parser/Token.java.Token.[int]endPos()", "src/main/java/org/jsoup/parser/Token.java.Token.[void]endPos(int)", "src/main/java/org/jsoup/parser/Token.java.Token.[void]reset(StringBuilder)", "src/main/java/org/jsoup/parser/Token.java.Token.[boolean]isDoctype()", "src/main/java/org/jsoup/parser/Token.java.Token.[Doctype]asDoctype()", "src/main/java/org/jsoup/parser/Token.java.Token.[boolean]isStartTag()", "src/main/java/org/jsoup/parser/Token.java.Token.[StartTag]asStartTag()", "src/main/java/org/jsoup/parser/Token.java.Token.[boolean]isEndTag()", "src/main/java/org/jsoup/parser/Token.java.Token.[EndTag]asEndTag()", "src/main/java/org/jsoup/parser/Token.java.Token.[boolean]isComment()", "src/main/java/org/jsoup/parser/Token.java.Token.[Comment]asComment()", "src/main/java/org/jsoup/parser/Token.java.Token.[boolean]isCharacter()", "src/main/java/org/jsoup/parser/Token.java.Token.[boolean]isCData()", "src/main/java/org/jsoup/parser/Token.java.Token.[Character]asCharacter()", "src/main/java/org/jsoup/parser/Token.java.Token.[boolean]isEOF()"], "overrides": null, "attributes": [{"original_string": "    static final class Doctype extends Token {\n        final StringBuilder name = new StringBuilder();\n        @Nullable String pubSysKey = null;\n        final StringBuilder publicIdentifier = new StringBuilder();\n        final StringBuilder systemIdentifier = new StringBuilder();\n        boolean forceQuirks = false;\n\n        Doctype() {\n            super(TokenType.Doctype);\n        }\n\n        @Override\n        Token reset() {\n            super.reset();\n            reset(name);\n            pubSysKey = null;\n            reset(publicIdentifier);\n            reset(systemIdentifier);\n            forceQuirks = false;\n            return this;\n        }\n\n        String getName() {\n            return name.toString();\n        }\n\n        @Nullable String getPubSysKey() {\n            return pubSysKey;\n        }\n\n        String getPublicIdentifier() {\n            return publicIdentifier.toString();\n        }\n\n        public String getSystemIdentifier() {\n            return systemIdentifier.toString();\n        }\n\n        public boolean isForceQuirks() {\n            return forceQuirks;\n        }\n\n        @Override\n        public String toString() {\n            return \"<!doctype \" + getName() + \">\";\n        }\n    }", "definition": "    static final class Doctype extends Token", "class_docstring": "", "name": "Doctype", "super_interfaces": [], "superclasses": "Token", "attributes": {"modifiers": "static final", "marker_annotations": [], "non_marker_annotations": ["static", "final"], "comments": [], "fields": [{"attribute_expression": "final StringBuilder name = new StringBuilder();", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "StringBuilder", "name": "name = new StringBuilder()", "syntax_pass": true}, {"attribute_expression": "@Nullable String pubSysKey = null;", "docstring": "", "modifiers": "@Nullable", "marker_annotations": ["@Nullable"], "non_marker_annotations": [], "comments": [], "type": "String", "name": "pubSysKey = null", "syntax_pass": true}, {"attribute_expression": "final StringBuilder publicIdentifier = new StringBuilder();", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "StringBuilder", "name": "publicIdentifier = new StringBuilder()", "syntax_pass": true}, {"attribute_expression": "final StringBuilder systemIdentifier = new StringBuilder();", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "StringBuilder", "name": "systemIdentifier = new StringBuilder()", "syntax_pass": true}, {"attribute_expression": "boolean forceQuirks = false;", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "boolean", "name": "forceQuirks = false", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        Doctype() {\n            super(TokenType.Doctype);\n        }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "Doctype", "params": [], "body": "                  {\n            super(TokenType.Doctype);\n        }", "signature": "Doctype()"}, {"syntax_pass": true, "original_string": "        @Override\n        Token reset() {\n            super.reset();\n            reset(name);\n            pubSysKey = null;\n            reset(publicIdentifier);\n            reset(systemIdentifier);\n            forceQuirks = false;\n            return this;\n        }", "docstring": "", "attributes": {"modifiers": "@Override", "marker_annotations": ["@Override"], "non_marker_annotations": [], "comments": [], "return_type": "Token", "classes": []}, "name": "reset", "params": [], "body": "                      {\n            super.reset();\n            reset(name);\n            pubSysKey = null;\n            reset(publicIdentifier);\n            reset(systemIdentifier);\n            forceQuirks = false;\n            return this;\n        }", "signature": "@Override\n        Token reset()"}, {"syntax_pass": true, "original_string": "        String getName() {\n            return name.toString();\n        }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "String", "classes": []}, "name": "getName", "params": [], "body": "                         {\n            return name.toString();\n        }", "signature": "String getName()"}, {"syntax_pass": true, "original_string": "        @Nullable String getPubSysKey() {\n            return pubSysKey;\n        }", "docstring": "", "attributes": {"modifiers": "@Nullable", "marker_annotations": ["@Nullable"], "non_marker_annotations": [], "comments": [], "return_type": "String", "classes": []}, "name": "getPubSysKey", "params": [], "body": "                                        {\n            return pubSysKey;\n        }", "signature": "@Nullable String getPubSysKey()"}, {"syntax_pass": true, "original_string": "        String getPublicIdentifier() {\n            return publicIdentifier.toString();\n        }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "String", "classes": []}, "name": "getPublicIdentifier", "params": [], "body": "                                     {\n            return publicIdentifier.toString();\n        }", "signature": "String getPublicIdentifier()"}, {"syntax_pass": true, "original_string": "        public String getSystemIdentifier() {\n            return systemIdentifier.toString();\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "getSystemIdentifier", "params": [], "body": "                                            {\n            return systemIdentifier.toString();\n        }", "signature": "public String getSystemIdentifier()"}, {"syntax_pass": true, "original_string": "        public boolean isForceQuirks() {\n            return forceQuirks;\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isForceQuirks", "params": [], "body": "                                       {\n            return forceQuirks;\n        }", "signature": "public boolean isForceQuirks()"}, {"syntax_pass": true, "original_string": "        @Override\n        public String toString() {\n            return \"<!doctype \" + getName() + \">\";\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "toString", "params": [], "body": "                                 {\n            return \"<!doctype \" + getName() + \">\";\n        }", "signature": "@Override\n        public String toString()"}]}, {"original_string": "    static abstract class Tag extends Token {\n        @Nullable protected String tagName;\n        @Nullable protected String normalName; // lc version of tag name, for case-insensitive tree build\n        boolean selfClosing = false;\n        @Nullable Attributes attributes; // start tags get attributes on construction. End tags get attributes on first new attribute (but only for parser convenience, not used).\n\n        @Nullable private String attrName; // try to get attr names and vals in one shot, vs Builder\n        private final StringBuilder attrNameSb = new StringBuilder();\n        private boolean hasAttrName = false;\n\n        @Nullable private String attrValue;\n        private final StringBuilder attrValueSb = new StringBuilder();\n        private boolean hasAttrValue = false;\n        private boolean hasEmptyAttrValue = false; // distinguish boolean attribute from empty string value\n\n        // attribute source range tracking\n        final TreeBuilder treeBuilder;\n        final boolean trackSource;\n        int attrNameStart, attrNameEnd, attrValStart, attrValEnd;\n\n        Tag(TokenType type, TreeBuilder treeBuilder) {\n            super(type);\n            this.treeBuilder = treeBuilder;\n            this.trackSource = treeBuilder.trackSourceRange;\n        }\n\n        @Override\n        Tag reset() {\n            super.reset();\n            tagName = null;\n            normalName = null;\n            selfClosing = false;\n            attributes = null;\n            resetPendingAttr();\n            return this;\n        }\n\n        private void resetPendingAttr() {\n            reset(attrNameSb);\n            attrName = null;\n            hasAttrName = false;\n\n            reset(attrValueSb);\n            attrValue = null;\n            hasEmptyAttrValue = false;\n            hasAttrValue = false;\n\n            if (trackSource)\n                attrNameStart = attrNameEnd = attrValStart = attrValEnd = Unset;\n        }\n\n        /* Limits runaway crafted HTML from spewing attributes and getting a little sluggish in ensureCapacity.\n        Real-world HTML will P99 around 8 attributes, so plenty of headroom. Implemented here and not in the Attributes\n        object so that API users can add more if ever required. */\n        private static final int MaxAttributes = 512;\n\n        final void newAttribute() {\n            if (attributes == null)\n                attributes = new Attributes();\n\n            if (hasAttrName && attributes.size() < MaxAttributes) {\n                // the tokeniser has skipped whitespace control chars, but trimming could collapse to empty for other control codes, so verify here\n                String name = attrNameSb.length() > 0 ? attrNameSb.toString() : attrName;\n                name = name.trim();\n                if (name.length() > 0) {\n                    String value;\n                    if (hasAttrValue)\n                        value = attrValueSb.length() > 0 ? attrValueSb.toString() : attrValue;\n                    else if (hasEmptyAttrValue)\n                        value = \"\";\n                    else\n                        value = null;\n                    // note that we add, not put. So that the first is kept, and rest are deduped, once in a context where case sensitivity is known, and we can warn for duplicates.\n                    attributes.add(name, value);\n\n                    trackAttributeRange(name);\n                }\n            }\n            resetPendingAttr();\n        }\n\n        private void trackAttributeRange(String name) {\n            if (trackSource && isStartTag()) {\n                final StartTag start = asStartTag();\n                final CharacterReader r = start.treeBuilder.reader;\n                final boolean preserve = start.treeBuilder.settings.preserveAttributeCase();\n\n                assert attributes != null;\n                //noinspection unchecked\n                Map<String, Range.AttributeRange> attrRanges =\n                    (Map<String, Range.AttributeRange>) attributes.userData(AttrRangeKey);\n                if (attrRanges == null) {\n                    attrRanges = new HashMap<>();\n                    attributes.userData(AttrRangeKey, attrRanges);\n                }\n\n                if (!preserve) name = Normalizer.lowerCase(name);\n                if (attrRanges.containsKey(name)) return; // dedupe ranges as we go; actual attributes get deduped later for error count\n\n                // if there's no value (e.g. boolean), make it an implicit range at current\n                if (!hasAttrValue) attrValStart = attrValEnd = attrNameEnd;\n\n                Range.AttributeRange range = new Range.AttributeRange(\n                    new Range(\n                        new Range.Position(attrNameStart, r.lineNumber(attrNameStart), r.columnNumber(attrNameStart)),\n                        new Range.Position(attrNameEnd, r.lineNumber(attrNameEnd), r.columnNumber(attrNameEnd))),\n                    new Range(\n                        new Range.Position(attrValStart, r.lineNumber(attrValStart), r.columnNumber(attrValStart)),\n                        new Range.Position(attrValEnd, r.lineNumber(attrValEnd), r.columnNumber(attrValEnd)))\n                );\n                attrRanges.put(name, range);\n            }\n        }\n\n        final boolean hasAttributes() {\n            return attributes != null;\n        }\n\n        /** Case-sensitive check */\n        final boolean hasAttribute(String key) {\n            return attributes != null && attributes.hasKey(key);\n        }\n\n        final boolean hasAttributeIgnoreCase(String key) {\n            return attributes != null && attributes.hasKeyIgnoreCase(key);\n        }\n\n        final void finaliseTag() {\n            // finalises for emit\n            if (hasAttrName) {\n                newAttribute();\n            }\n        }\n\n        /** Preserves case */\n        final String name() { // preserves case, for input into Tag.valueOf (which may drop case)\n            Validate.isFalse(tagName == null || tagName.length() == 0);\n            return tagName;\n        }\n\n        /** Lower case */\n        final String normalName() { // lower case, used in tree building for working out where in tree it should go\n            return normalName;\n        }\n\n        final String toStringName() {\n            return tagName != null ? tagName : \"[unset]\";\n        }\n\n        final Tag name(String name) {\n            tagName = name;\n            normalName = ParseSettings.normalName(tagName);\n            return this;\n        }\n\n        final boolean isSelfClosing() {\n            return selfClosing;\n        }\n\n        // these appenders are rarely hit in not null state-- caused by null chars.\n        final void appendTagName(String append) {\n            // might have null chars - need to replace with null replacement character\n            append = append.replace(TokeniserState.nullChar, Tokeniser.replacementChar);\n            tagName = tagName == null ? append : tagName.concat(append);\n            normalName = ParseSettings.normalName(tagName);\n        }\n\n        final void appendTagName(char append) {\n            appendTagName(String.valueOf(append));\n        }\n\n        final void appendAttributeName(String append, int startPos, int endPos) {\n            // might have null chars because we eat in one pass - need to replace with null replacement character\n            append = append.replace(TokeniserState.nullChar, Tokeniser.replacementChar);\n\n            ensureAttrName(startPos, endPos);\n            if (attrNameSb.length() == 0) {\n                attrName = append;\n            } else {\n                attrNameSb.append(append);\n            }\n        }\n\n        final void appendAttributeName(char append, int startPos, int endPos) {\n            ensureAttrName(startPos, endPos);\n            attrNameSb.append(append);\n        }\n\n        final void appendAttributeValue(String append, int startPos, int endPos) {\n            ensureAttrValue(startPos, endPos);\n            if (attrValueSb.length() == 0) {\n                attrValue = append;\n            } else {\n                attrValueSb.append(append);\n            }\n        }\n\n        final void appendAttributeValue(char append, int startPos, int endPos) {\n            ensureAttrValue(startPos, endPos);\n            attrValueSb.append(append);\n        }\n\n        final void appendAttributeValue(int[] appendCodepoints, int startPos, int endPos) {\n            ensureAttrValue(startPos, endPos);\n            for (int codepoint : appendCodepoints) {\n                attrValueSb.appendCodePoint(codepoint);\n            }\n        }\n        \n        final void setEmptyAttributeValue() {\n            hasEmptyAttrValue = true;\n        }\n\n        private void ensureAttrName(int startPos, int endPos) {\n            hasAttrName = true;\n            // if on second hit, we'll need to move to the builder\n            if (attrName != null) {\n                attrNameSb.append(attrName);\n                attrName = null;\n            }\n            if (trackSource) {\n                attrNameStart = attrNameStart > Unset ? attrNameStart : startPos; // latches to first\n                attrNameEnd = endPos;\n            }\n        }\n\n        private void ensureAttrValue(int startPos, int endPos) {\n            hasAttrValue = true;\n            // if on second hit, we'll need to move to the builder\n            if (attrValue != null) {\n                attrValueSb.append(attrValue);\n                attrValue = null;\n            }\n            if (trackSource) {\n                attrValStart = attrValStart > Unset ? attrValStart : startPos; // latches to first\n                attrValEnd = endPos;\n            }\n        }\n\n        @Override\n        abstract public String toString();\n    }", "definition": "    static abstract class Tag extends Token", "class_docstring": "", "name": "Tag", "super_interfaces": [], "superclasses": "Token", "attributes": {"modifiers": "static abstract", "marker_annotations": [], "non_marker_annotations": ["static", "abstract"], "comments": [], "fields": [{"attribute_expression": "@Nullable protected String tagName;", "docstring": "", "modifiers": "@Nullable protected", "marker_annotations": ["@Nullable"], "non_marker_annotations": ["protected"], "comments": [], "type": "String", "name": "tagName", "syntax_pass": true}, {"attribute_expression": "@Nullable protected String normalName;", "docstring": "", "modifiers": "@Nullable protected", "marker_annotations": ["@Nullable"], "non_marker_annotations": ["protected"], "comments": [], "type": "String", "name": "normalName", "syntax_pass": true}, {"attribute_expression": "boolean selfClosing = false;", "docstring": " lc version of tag name, for case-insensitive tree build", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "boolean", "name": "selfClosing = false", "syntax_pass": true}, {"attribute_expression": "@Nullable Attributes attributes;", "docstring": "", "modifiers": "@Nullable", "marker_annotations": ["@Nullable"], "non_marker_annotations": [], "comments": [], "type": "Attributes", "name": "attributes", "syntax_pass": true}, {"attribute_expression": "@Nullable private String attrName;", "docstring": " start tags get attributes on construction. End tags get attributes on first new attribute (but only for parser convenience, not used).", "modifiers": "@Nullable private", "marker_annotations": ["@Nullable"], "non_marker_annotations": ["private"], "comments": [], "type": "String", "name": "attrName", "syntax_pass": true}, {"attribute_expression": "private final StringBuilder attrNameSb = new StringBuilder();", "docstring": " try to get attr names and vals in one shot, vs Builder", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "StringBuilder", "name": "attrNameSb = new StringBuilder()", "syntax_pass": true}, {"attribute_expression": "private boolean hasAttrName = false;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "boolean", "name": "hasAttrName = false", "syntax_pass": true}, {"attribute_expression": "@Nullable private String attrValue;", "docstring": "", "modifiers": "@Nullable private", "marker_annotations": ["@Nullable"], "non_marker_annotations": ["private"], "comments": [], "type": "String", "name": "attrValue", "syntax_pass": true}, {"attribute_expression": "private final StringBuilder attrValueSb = new StringBuilder();", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "StringBuilder", "name": "attrValueSb = new StringBuilder()", "syntax_pass": true}, {"attribute_expression": "private boolean hasAttrValue = false;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "boolean", "name": "hasAttrValue = false", "syntax_pass": true}, {"attribute_expression": "private boolean hasEmptyAttrValue = false;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "boolean", "name": "hasEmptyAttrValue = false", "syntax_pass": true}, {"attribute_expression": "final TreeBuilder treeBuilder;", "docstring": " attribute source range tracking", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "TreeBuilder", "name": "treeBuilder", "syntax_pass": true}, {"attribute_expression": "final boolean trackSource;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "boolean", "name": "trackSource", "syntax_pass": true}, {"attribute_expression": "int attrNameStart, attrNameEnd, attrValStart, attrValEnd;", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "int", "name": "attrNameStart", "syntax_pass": true}, {"attribute_expression": "private static final int MaxAttributes = 512;", "docstring": " Limits runaway crafted HTML from spewing attributes and getting a little sluggish in ensureCapacity.\nReal-world HTML will P99 around 8 attributes, so plenty of headroom. Implemented here and not in the Attributes\nobject so that API users can add more if ever required.", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "int", "name": "MaxAttributes = 512", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        Tag(TokenType type, TreeBuilder treeBuilder) {\n            super(type);\n            this.treeBuilder = treeBuilder;\n            this.trackSource = treeBuilder.trackSourceRange;\n        }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "Tag", "params": [{"name": "type", "type": "TokenType"}, {"name": "treeBuilder", "type": "TreeBuilder"}], "body": "                                                     {\n            super(type);\n            this.treeBuilder = treeBuilder;\n            this.trackSource = treeBuilder.trackSourceRange;\n        }", "signature": "Tag(TokenType type, TreeBuilder treeBuilder)"}, {"syntax_pass": true, "original_string": "        @Override\n        Tag reset() {\n            super.reset();\n            tagName = null;\n            normalName = null;\n            selfClosing = false;\n            attributes = null;\n            resetPendingAttr();\n            return this;\n        }", "docstring": "", "attributes": {"modifiers": "@Override", "marker_annotations": ["@Override"], "non_marker_annotations": [], "comments": [], "return_type": "Tag", "classes": []}, "name": "reset", "params": [], "body": "                    {\n            super.reset();\n            tagName = null;\n            normalName = null;\n            selfClosing = false;\n            attributes = null;\n            resetPendingAttr();\n            return this;\n        }", "signature": "@Override\n        Tag reset()"}, {"syntax_pass": true, "original_string": "        private void resetPendingAttr() {\n            reset(attrNameSb);\n            attrName = null;\n            hasAttrName = false;\n\n            reset(attrValueSb);\n            attrValue = null;\n            hasEmptyAttrValue = false;\n            hasAttrValue = false;\n\n            if (trackSource)\n                attrNameStart = attrNameEnd = attrValStart = attrValEnd = Unset;\n        }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "name": "resetPendingAttr", "params": [], "body": "                                        {\n            reset(attrNameSb);\n            attrName = null;\n            hasAttrName = false;\n\n            reset(attrValueSb);\n            attrValue = null;\n            hasEmptyAttrValue = false;\n            hasAttrValue = false;\n\n            if (trackSource)\n                attrNameStart = attrNameEnd = attrValStart = attrValEnd = Unset;\n        }", "signature": "private void resetPendingAttr()"}, {"syntax_pass": true, "original_string": "        final void newAttribute() {\n            if (attributes == null)\n                attributes = new Attributes();\n\n            if (hasAttrName && attributes.size() < MaxAttributes) {\n                // the tokeniser has skipped whitespace control chars, but trimming could collapse to empty for other control codes, so verify here\n                String name = attrNameSb.length() > 0 ? attrNameSb.toString() : attrName;\n                name = name.trim();\n                if (name.length() > 0) {\n                    String value;\n                    if (hasAttrValue)\n                        value = attrValueSb.length() > 0 ? attrValueSb.toString() : attrValue;\n                    else if (hasEmptyAttrValue)\n                        value = \"\";\n                    else\n                        value = null;\n                    // note that we add, not put. So that the first is kept, and rest are deduped, once in a context where case sensitivity is known, and we can warn for duplicates.\n                    attributes.add(name, value);\n\n                    trackAttributeRange(name);\n                }\n            }\n            resetPendingAttr();\n        }", "docstring": "", "attributes": {"modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "return_type": "void", "classes": []}, "name": "newAttribute", "params": [], "body": "                                  {\n            if (attributes == null)\n                attributes = new Attributes();\n\n            if (hasAttrName && attributes.size() < MaxAttributes) {\n                // the tokeniser has skipped whitespace control chars, but trimming could collapse to empty for other control codes, so verify here\n                String name = attrNameSb.length() > 0 ? attrNameSb.toString() : attrName;\n                name = name.trim();\n                if (name.length() > 0) {\n                    String value;\n                    if (hasAttrValue)\n                        value = attrValueSb.length() > 0 ? attrValueSb.toString() : attrValue;\n                    else if (hasEmptyAttrValue)\n                        value = \"\";\n                    else\n                        value = null;\n                    // note that we add, not put. So that the first is kept, and rest are deduped, once in a context where case sensitivity is known, and we can warn for duplicates.\n                    attributes.add(name, value);\n\n                    trackAttributeRange(name);\n                }\n            }\n            resetPendingAttr();\n        }", "signature": "final void newAttribute()"}, {"syntax_pass": true, "original_string": "        private void trackAttributeRange(String name) {\n            if (trackSource && isStartTag()) {\n                final StartTag start = asStartTag();\n                final CharacterReader r = start.treeBuilder.reader;\n                final boolean preserve = start.treeBuilder.settings.preserveAttributeCase();\n\n                assert attributes != null;\n                //noinspection unchecked\n                Map<String, Range.AttributeRange> attrRanges =\n                    (Map<String, Range.AttributeRange>) attributes.userData(AttrRangeKey);\n                if (attrRanges == null) {\n                    attrRanges = new HashMap<>();\n                    attributes.userData(AttrRangeKey, attrRanges);\n                }\n\n                if (!preserve) name = Normalizer.lowerCase(name);\n                if (attrRanges.containsKey(name)) return; // dedupe ranges as we go; actual attributes get deduped later for error count\n\n                // if there's no value (e.g. boolean), make it an implicit range at current\n                if (!hasAttrValue) attrValStart = attrValEnd = attrNameEnd;\n\n                Range.AttributeRange range = new Range.AttributeRange(\n                    new Range(\n                        new Range.Position(attrNameStart, r.lineNumber(attrNameStart), r.columnNumber(attrNameStart)),\n                        new Range.Position(attrNameEnd, r.lineNumber(attrNameEnd), r.columnNumber(attrNameEnd))),\n                    new Range(\n                        new Range.Position(attrValStart, r.lineNumber(attrValStart), r.columnNumber(attrValStart)),\n                        new Range.Position(attrValEnd, r.lineNumber(attrValEnd), r.columnNumber(attrValEnd)))\n                );\n                attrRanges.put(name, range);\n            }\n        }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "name": "trackAttributeRange", "params": [{"name": "name", "type": "String"}], "body": "                                                      {\n            if (trackSource && isStartTag()) {\n                final StartTag start = asStartTag();\n                final CharacterReader r = start.treeBuilder.reader;\n                final boolean preserve = start.treeBuilder.settings.preserveAttributeCase();\n\n                assert attributes != null;\n                //noinspection unchecked\n                Map<String, Range.AttributeRange> attrRanges =\n                    (Map<String, Range.AttributeRange>) attributes.userData(AttrRangeKey);\n                if (attrRanges == null) {\n                    attrRanges = new HashMap<>();\n                    attributes.userData(AttrRangeKey, attrRanges);\n                }\n\n                if (!preserve) name = Normalizer.lowerCase(name);\n                if (attrRanges.containsKey(name)) return; // dedupe ranges as we go; actual attributes get deduped later for error count\n\n                // if there's no value (e.g. boolean), make it an implicit range at current\n                if (!hasAttrValue) attrValStart = attrValEnd = attrNameEnd;\n\n                Range.AttributeRange range = new Range.AttributeRange(\n                    new Range(\n                        new Range.Position(attrNameStart, r.lineNumber(attrNameStart), r.columnNumber(attrNameStart)),\n                        new Range.Position(attrNameEnd, r.lineNumber(attrNameEnd), r.columnNumber(attrNameEnd))),\n                    new Range(\n                        new Range.Position(attrValStart, r.lineNumber(attrValStart), r.columnNumber(attrValStart)),\n                        new Range.Position(attrValEnd, r.lineNumber(attrValEnd), r.columnNumber(attrValEnd)))\n                );\n                attrRanges.put(name, range);\n            }\n        }", "signature": "private void trackAttributeRange(String name)"}, {"syntax_pass": true, "original_string": "        final boolean hasAttributes() {\n            return attributes != null;\n        }", "docstring": "", "attributes": {"modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "return_type": "boolean", "classes": []}, "name": "hasAttributes", "params": [], "body": "                                      {\n            return attributes != null;\n        }", "signature": "final boolean hasAttributes()"}, {"syntax_pass": true, "original_string": "        final boolean hasAttribute(String key) {\n            return attributes != null && attributes.hasKey(key);\n        }", "docstring": " Case-sensitive check", "attributes": {"modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "return_type": "boolean", "classes": []}, "name": "hasAttribute", "params": [{"name": "key", "type": "String"}], "body": "                                               {\n            return attributes != null && attributes.hasKey(key);\n        }", "signature": "final boolean hasAttribute(String key)"}, {"syntax_pass": true, "original_string": "        final boolean hasAttributeIgnoreCase(String key) {\n            return attributes != null && attributes.hasKeyIgnoreCase(key);\n        }", "docstring": "", "attributes": {"modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "return_type": "boolean", "classes": []}, "name": "hasAttributeIgnoreCase", "params": [{"name": "key", "type": "String"}], "body": "                                                         {\n            return attributes != null && attributes.hasKeyIgnoreCase(key);\n        }", "signature": "final boolean hasAttributeIgnoreCase(String key)"}, {"syntax_pass": true, "original_string": "        final void finaliseTag() {\n            // finalises for emit\n            if (hasAttrName) {\n                newAttribute();\n            }\n        }", "docstring": "", "attributes": {"modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "return_type": "void", "classes": []}, "name": "finaliseTag", "params": [], "body": "                                 {\n            // finalises for emit\n            if (hasAttrName) {\n                newAttribute();\n            }\n        }", "signature": "final void finaliseTag()"}, {"syntax_pass": true, "original_string": "        final String name() { // preserves case, for input into Tag.valueOf (which may drop case)\n            Validate.isFalse(tagName == null || tagName.length() == 0);\n            return tagName;\n        }", "docstring": " Preserves case", "attributes": {"modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "return_type": "String", "classes": []}, "name": "name", "params": [], "body": "                            { // preserves case, for input into Tag.valueOf (which may drop case)\n            Validate.isFalse(tagName == null || tagName.length() == 0);\n            return tagName;\n        }", "signature": "final String name()"}, {"syntax_pass": true, "original_string": "        final String normalName() { // lower case, used in tree building for working out where in tree it should go\n            return normalName;\n        }", "docstring": " Lower case", "attributes": {"modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "return_type": "String", "classes": []}, "name": "normalName", "params": [], "body": "                                  { // lower case, used in tree building for working out where in tree it should go\n            return normalName;\n        }", "signature": "final String normalName()"}, {"syntax_pass": true, "original_string": "        final String toStringName() {\n            return tagName != null ? tagName : \"[unset]\";\n        }", "docstring": "", "attributes": {"modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "return_type": "String", "classes": []}, "name": "toStringName", "params": [], "body": "                                    {\n            return tagName != null ? tagName : \"[unset]\";\n        }", "signature": "final String toStringName()"}, {"syntax_pass": true, "original_string": "        final Tag name(String name) {\n            tagName = name;\n            normalName = ParseSettings.normalName(tagName);\n            return this;\n        }", "docstring": "", "attributes": {"modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "return_type": "Tag", "classes": []}, "name": "name", "params": [{"name": "name", "type": "String"}], "body": "                                    {\n            tagName = name;\n            normalName = ParseSettings.normalName(tagName);\n            return this;\n        }", "signature": "final Tag name(String name)"}, {"syntax_pass": true, "original_string": "        final boolean isSelfClosing() {\n            return selfClosing;\n        }", "docstring": "", "attributes": {"modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isSelfClosing", "params": [], "body": "                                      {\n            return selfClosing;\n        }", "signature": "final boolean isSelfClosing()"}, {"syntax_pass": true, "original_string": "        final void appendTagName(String append) {\n            // might have null chars - need to replace with null replacement character\n            append = append.replace(TokeniserState.nullChar, Tokeniser.replacementChar);\n            tagName = tagName == null ? append : tagName.concat(append);\n            normalName = ParseSettings.normalName(tagName);\n        }", "docstring": " these appenders are rarely hit in not null state-- caused by null chars.", "attributes": {"modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "return_type": "void", "classes": []}, "name": "appendTagName", "params": [{"name": "append", "type": "String"}], "body": "                                                {\n            // might have null chars - need to replace with null replacement character\n            append = append.replace(TokeniserState.nullChar, Tokeniser.replacementChar);\n            tagName = tagName == null ? append : tagName.concat(append);\n            normalName = ParseSettings.normalName(tagName);\n        }", "signature": "final void appendTagName(String append)"}, {"syntax_pass": true, "original_string": "        final void appendTagName(char append) {\n            appendTagName(String.valueOf(append));\n        }", "docstring": "", "attributes": {"modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "return_type": "void", "classes": []}, "name": "appendTagName", "params": [{"name": "append", "type": "char"}], "body": "                                              {\n            appendTagName(String.valueOf(append));\n        }", "signature": "final void appendTagName(char append)"}, {"syntax_pass": true, "original_string": "        final void appendAttributeName(String append, int startPos, int endPos) {\n            // might have null chars because we eat in one pass - need to replace with null replacement character\n            append = append.replace(TokeniserState.nullChar, Tokeniser.replacementChar);\n\n            ensureAttrName(startPos, endPos);\n            if (attrNameSb.length() == 0) {\n                attrName = append;\n            } else {\n                attrNameSb.append(append);\n            }\n        }", "docstring": "", "attributes": {"modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "return_type": "void", "classes": []}, "name": "appendAttributeName", "params": [{"name": "append", "type": "String"}, {"name": "startPos", "type": "int"}, {"name": "endPos", "type": "int"}], "body": "                                                                                {\n            // might have null chars because we eat in one pass - need to replace with null replacement character\n            append = append.replace(TokeniserState.nullChar, Tokeniser.replacementChar);\n\n            ensureAttrName(startPos, endPos);\n            if (attrNameSb.length() == 0) {\n                attrName = append;\n            } else {\n                attrNameSb.append(append);\n            }\n        }", "signature": "final void appendAttributeName(String append, int startPos, int endPos)"}, {"syntax_pass": true, "original_string": "        final void appendAttributeName(char append, int startPos, int endPos) {\n            ensureAttrName(startPos, endPos);\n            attrNameSb.append(append);\n        }", "docstring": "", "attributes": {"modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "return_type": "void", "classes": []}, "name": "appendAttributeName", "params": [{"name": "append", "type": "char"}, {"name": "startPos", "type": "int"}, {"name": "endPos", "type": "int"}], "body": "                                                                              {\n            ensureAttrName(startPos, endPos);\n            attrNameSb.append(append);\n        }", "signature": "final void appendAttributeName(char append, int startPos, int endPos)"}, {"syntax_pass": true, "original_string": "        final void appendAttributeValue(String append, int startPos, int endPos) {\n            ensureAttrValue(startPos, endPos);\n            if (attrValueSb.length() == 0) {\n                attrValue = append;\n            } else {\n                attrValueSb.append(append);\n            }\n        }", "docstring": "", "attributes": {"modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "return_type": "void", "classes": []}, "name": "appendAttributeValue", "params": [{"name": "append", "type": "String"}, {"name": "startPos", "type": "int"}, {"name": "endPos", "type": "int"}], "body": "                                                                                 {\n            ensureAttrValue(startPos, endPos);\n            if (attrValueSb.length() == 0) {\n                attrValue = append;\n            } else {\n                attrValueSb.append(append);\n            }\n        }", "signature": "final void appendAttributeValue(String append, int startPos, int endPos)"}, {"syntax_pass": true, "original_string": "        final void appendAttributeValue(char append, int startPos, int endPos) {\n            ensureAttrValue(startPos, endPos);\n            attrValueSb.append(append);\n        }", "docstring": "", "attributes": {"modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "return_type": "void", "classes": []}, "name": "appendAttributeValue", "params": [{"name": "append", "type": "char"}, {"name": "startPos", "type": "int"}, {"name": "endPos", "type": "int"}], "body": "                                                                               {\n            ensureAttrValue(startPos, endPos);\n            attrValueSb.append(append);\n        }", "signature": "final void appendAttributeValue(char append, int startPos, int endPos)"}, {"syntax_pass": true, "original_string": "        final void appendAttributeValue(int[] appendCodepoints, int startPos, int endPos) {\n            ensureAttrValue(startPos, endPos);\n            for (int codepoint : appendCodepoints) {\n                attrValueSb.appendCodePoint(codepoint);\n            }\n        }", "docstring": "", "attributes": {"modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "return_type": "void", "classes": []}, "name": "appendAttributeValue", "params": [{"name": "appendCodepoints", "type": "int[]"}, {"name": "startPos", "type": "int"}, {"name": "endPos", "type": "int"}], "body": "                                                                                          {\n            ensureAttrValue(startPos, endPos);\n            for (int codepoint : appendCodepoints) {\n                attrValueSb.appendCodePoint(codepoint);\n            }\n        }", "signature": "final void appendAttributeValue(int[] appendCodepoints, int startPos, int endPos)"}, {"syntax_pass": true, "original_string": "        final void setEmptyAttributeValue() {\n            hasEmptyAttrValue = true;\n        }", "docstring": "", "attributes": {"modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "return_type": "void", "classes": []}, "name": "setEmptyAttributeValue", "params": [], "body": "                                            {\n            hasEmptyAttrValue = true;\n        }", "signature": "final void setEmptyAttributeValue()"}, {"syntax_pass": true, "original_string": "        private void ensureAttrName(int startPos, int endPos) {\n            hasAttrName = true;\n            // if on second hit, we'll need to move to the builder\n            if (attrName != null) {\n                attrNameSb.append(attrName);\n                attrName = null;\n            }\n            if (trackSource) {\n                attrNameStart = attrNameStart > Unset ? attrNameStart : startPos; // latches to first\n                attrNameEnd = endPos;\n            }\n        }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "name": "ensureAttrName", "params": [{"name": "startPos", "type": "int"}, {"name": "endPos", "type": "int"}], "body": "                                                              {\n            hasAttrName = true;\n            // if on second hit, we'll need to move to the builder\n            if (attrName != null) {\n                attrNameSb.append(attrName);\n                attrName = null;\n            }\n            if (trackSource) {\n                attrNameStart = attrNameStart > Unset ? attrNameStart : startPos; // latches to first\n                attrNameEnd = endPos;\n            }\n        }", "signature": "private void ensureAttrName(int startPos, int endPos)"}, {"syntax_pass": true, "original_string": "        private void ensureAttrValue(int startPos, int endPos) {\n            hasAttrValue = true;\n            // if on second hit, we'll need to move to the builder\n            if (attrValue != null) {\n                attrValueSb.append(attrValue);\n                attrValue = null;\n            }\n            if (trackSource) {\n                attrValStart = attrValStart > Unset ? attrValStart : startPos; // latches to first\n                attrValEnd = endPos;\n            }\n        }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "name": "ensureAttrValue", "params": [{"name": "startPos", "type": "int"}, {"name": "endPos", "type": "int"}], "body": "                                                               {\n            hasAttrValue = true;\n            // if on second hit, we'll need to move to the builder\n            if (attrValue != null) {\n                attrValueSb.append(attrValue);\n                attrValue = null;\n            }\n            if (trackSource) {\n                attrValStart = attrValStart > Unset ? attrValStart : startPos; // latches to first\n                attrValEnd = endPos;\n            }\n        }", "signature": "private void ensureAttrValue(int startPos, int endPos)"}, {"syntax_pass": true, "original_string": "        @Override\n        abstract public String toString();", "docstring": "", "attributes": {"modifiers": "@Override\n        abstract public", "marker_annotations": ["@Override"], "non_marker_annotations": ["abstract", "public"], "comments": [], "return_type": "String", "classes": []}, "name": "toString", "params": [], "body": "", "signature": "@Override\n        abstract public String toString()"}]}, {"original_string": "    final static class StartTag extends Tag {\n\n        // TreeBuilder is provided so if tracking, can get line / column positions for Range; and can dedupe as we go\n        StartTag(TreeBuilder treeBuilder) {\n            super(TokenType.StartTag, treeBuilder);\n        }\n\n        @Override\n        Tag reset() {\n            super.reset();\n            attributes = null;\n            return this;\n        }\n\n        StartTag nameAttr(String name, Attributes attributes) {\n            this.tagName = name;\n            this.attributes = attributes;\n            normalName = ParseSettings.normalName(tagName);\n            return this;\n        }\n\n        @Override\n        public String toString() {\n            String closer = isSelfClosing() ? \"/>\" : \">\";\n            if (hasAttributes() && attributes.size() > 0)\n                return \"<\" + toStringName() + \" \" + attributes.toString() + closer;\n            else\n                return \"<\" + toStringName() + closer;\n        }\n    }", "definition": "    final static class StartTag extends Tag", "class_docstring": "", "name": "StartTag", "super_interfaces": [], "superclasses": "Tag", "attributes": {"modifiers": "final static", "marker_annotations": [], "non_marker_annotations": ["final", "static"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        StartTag(TreeBuilder treeBuilder) {\n            super(TokenType.StartTag, treeBuilder);\n        }", "docstring": " TreeBuilder is provided so if tracking, can get line / column positions for Range; and can dedupe as we go", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "StartTag", "params": [{"name": "treeBuilder", "type": "TreeBuilder"}], "body": "                                          {\n            super(TokenType.StartTag, treeBuilder);\n        }", "signature": "StartTag(TreeBuilder treeBuilder)"}, {"syntax_pass": true, "original_string": "        @Override\n        Tag reset() {\n            super.reset();\n            attributes = null;\n            return this;\n        }", "docstring": "", "attributes": {"modifiers": "@Override", "marker_annotations": ["@Override"], "non_marker_annotations": [], "comments": [], "return_type": "Tag", "classes": []}, "name": "reset", "params": [], "body": "                    {\n            super.reset();\n            attributes = null;\n            return this;\n        }", "signature": "@Override\n        Tag reset()"}, {"syntax_pass": true, "original_string": "        StartTag nameAttr(String name, Attributes attributes) {\n            this.tagName = name;\n            this.attributes = attributes;\n            normalName = ParseSettings.normalName(tagName);\n            return this;\n        }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "StartTag", "classes": []}, "name": "nameAttr", "params": [{"name": "name", "type": "String"}, {"name": "attributes", "type": "Attributes"}], "body": "                                                              {\n            this.tagName = name;\n            this.attributes = attributes;\n            normalName = ParseSettings.normalName(tagName);\n            return this;\n        }", "signature": "StartTag nameAttr(String name, Attributes attributes)"}, {"syntax_pass": true, "original_string": "        @Override\n        public String toString() {\n            String closer = isSelfClosing() ? \"/>\" : \">\";\n            if (hasAttributes() && attributes.size() > 0)\n                return \"<\" + toStringName() + \" \" + attributes.toString() + closer;\n            else\n                return \"<\" + toStringName() + closer;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "toString", "params": [], "body": "                                 {\n            String closer = isSelfClosing() ? \"/>\" : \">\";\n            if (hasAttributes() && attributes.size() > 0)\n                return \"<\" + toStringName() + \" \" + attributes.toString() + closer;\n            else\n                return \"<\" + toStringName() + closer;\n        }", "signature": "@Override\n        public String toString()"}]}, {"original_string": "    final static class EndTag extends Tag{\n        EndTag(TreeBuilder treeBuilder) {\n            super(TokenType.EndTag, treeBuilder);\n        }\n\n        @Override\n        public String toString() {\n            return \"</\" + toStringName() + \">\";\n        }\n    }", "definition": "    final static class EndTag extends Tag", "class_docstring": "", "name": "EndTag", "super_interfaces": [], "superclasses": "Tag", "attributes": {"modifiers": "final static", "marker_annotations": [], "non_marker_annotations": ["final", "static"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        EndTag(TreeBuilder treeBuilder) {\n            super(TokenType.EndTag, treeBuilder);\n        }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "EndTag", "params": [{"name": "treeBuilder", "type": "TreeBuilder"}], "body": "                                        {\n            super(TokenType.EndTag, treeBuilder);\n        }", "signature": "EndTag(TreeBuilder treeBuilder)"}, {"syntax_pass": true, "original_string": "        @Override\n        public String toString() {\n            return \"</\" + toStringName() + \">\";\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "toString", "params": [], "body": "                                 {\n            return \"</\" + toStringName() + \">\";\n        }", "signature": "@Override\n        public String toString()"}]}, {"original_string": "    final static class Comment extends Token {\n        private final StringBuilder data = new StringBuilder();\n        private String dataS; // try to get in one shot\n        boolean bogus = false;\n\n        @Override\n        Token reset() {\n            super.reset();\n            reset(data);\n            dataS = null;\n            bogus = false;\n            return this;\n        }\n\n        Comment() {\n            super(TokenType.Comment);\n        }\n\n        String getData() {\n            return dataS != null ? dataS : data.toString();\n        }\n\n        Comment append(String append) {\n            ensureData();\n            if (data.length() == 0) {\n                dataS = append;\n            } else {\n                data.append(append);\n            }\n            return this;\n        }\n\n        Comment append(char append) {\n            ensureData();\n            data.append(append);\n            return this;\n        }\n\n        private void ensureData() {\n            // if on second hit, we'll need to move to the builder\n            if (dataS != null) {\n                data.append(dataS);\n                dataS = null;\n            }\n        }\n\n        @Override\n        public String toString() {\n            return \"<!--\" + getData() + \"-->\";\n        }\n    }", "definition": "    final static class Comment extends Token", "class_docstring": "", "name": "Comment", "super_interfaces": [], "superclasses": "Token", "attributes": {"modifiers": "final static", "marker_annotations": [], "non_marker_annotations": ["final", "static"], "comments": [], "fields": [{"attribute_expression": "private final StringBuilder data = new StringBuilder();", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "StringBuilder", "name": "data = new StringBuilder()", "syntax_pass": true}, {"attribute_expression": "private String dataS;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "String", "name": "dataS", "syntax_pass": true}, {"attribute_expression": "boolean bogus = false;", "docstring": " try to get in one shot", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "boolean", "name": "bogus = false", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        @Override\n        Token reset() {\n            super.reset();\n            reset(data);\n            dataS = null;\n            bogus = false;\n            return this;\n        }", "docstring": "", "attributes": {"modifiers": "@Override", "marker_annotations": ["@Override"], "non_marker_annotations": [], "comments": [], "return_type": "Token", "classes": []}, "name": "reset", "params": [], "body": "                      {\n            super.reset();\n            reset(data);\n            dataS = null;\n            bogus = false;\n            return this;\n        }", "signature": "@Override\n        Token reset()"}, {"syntax_pass": true, "original_string": "        Comment() {\n            super(TokenType.Comment);\n        }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "Comment", "params": [], "body": "                  {\n            super(TokenType.Comment);\n        }", "signature": "Comment()"}, {"syntax_pass": true, "original_string": "        String getData() {\n            return dataS != null ? dataS : data.toString();\n        }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "String", "classes": []}, "name": "getData", "params": [], "body": "                         {\n            return dataS != null ? dataS : data.toString();\n        }", "signature": "String getData()"}, {"syntax_pass": true, "original_string": "        Comment append(String append) {\n            ensureData();\n            if (data.length() == 0) {\n                dataS = append;\n            } else {\n                data.append(append);\n            }\n            return this;\n        }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "Comment", "classes": []}, "name": "append", "params": [{"name": "append", "type": "String"}], "body": "                                      {\n            ensureData();\n            if (data.length() == 0) {\n                dataS = append;\n            } else {\n                data.append(append);\n            }\n            return this;\n        }", "signature": "Comment append(String append)"}, {"syntax_pass": true, "original_string": "        Comment append(char append) {\n            ensureData();\n            data.append(append);\n            return this;\n        }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "Comment", "classes": []}, "name": "append", "params": [{"name": "append", "type": "char"}], "body": "                                    {\n            ensureData();\n            data.append(append);\n            return this;\n        }", "signature": "Comment append(char append)"}, {"syntax_pass": true, "original_string": "        private void ensureData() {\n            // if on second hit, we'll need to move to the builder\n            if (dataS != null) {\n                data.append(dataS);\n                dataS = null;\n            }\n        }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "name": "ensureData", "params": [], "body": "                                  {\n            // if on second hit, we'll need to move to the builder\n            if (dataS != null) {\n                data.append(dataS);\n                dataS = null;\n            }\n        }", "signature": "private void ensureData()"}, {"syntax_pass": true, "original_string": "        @Override\n        public String toString() {\n            return \"<!--\" + getData() + \"-->\";\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "toString", "params": [], "body": "                                 {\n            return \"<!--\" + getData() + \"-->\";\n        }", "signature": "@Override\n        public String toString()"}]}, {"original_string": "    static class Character extends Token implements Cloneable {\n        private String data;\n\n        Character() {\n            super(TokenType.Character);\n        }\n\n        @Override\n        Token reset() {\n            super.reset();\n            data = null;\n            return this;\n        }\n\n        Character data(String data) {\n            this.data = data;\n            return this;\n        }\n\n        String getData() {\n            return data;\n        }\n\n        @Override\n        public String toString() {\n            return getData();\n        }\n\n        @Override protected Token.Character clone() {\n            try {\n                return (Token.Character) super.clone();\n            } catch (CloneNotSupportedException e) {\n                throw new RuntimeException(e);\n            }\n        }\n    }", "definition": "    static class Character extends Token implements Cloneable", "class_docstring": "", "name": "Character", "super_interfaces": ["Cloneable"], "superclasses": "Token", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "fields": [{"attribute_expression": "private String data;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "String", "name": "data", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        Character() {\n            super(TokenType.Character);\n        }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "Character", "params": [], "body": "                    {\n            super(TokenType.Character);\n        }", "signature": "Character()"}, {"syntax_pass": true, "original_string": "        @Override\n        Token reset() {\n            super.reset();\n            data = null;\n            return this;\n        }", "docstring": "", "attributes": {"modifiers": "@Override", "marker_annotations": ["@Override"], "non_marker_annotations": [], "comments": [], "return_type": "Token", "classes": []}, "name": "reset", "params": [], "body": "                      {\n            super.reset();\n            data = null;\n            return this;\n        }", "signature": "@Override\n        Token reset()"}, {"syntax_pass": true, "original_string": "        Character data(String data) {\n            this.data = data;\n            return this;\n        }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "Character", "classes": []}, "name": "data", "params": [{"name": "data", "type": "String"}], "body": "                                    {\n            this.data = data;\n            return this;\n        }", "signature": "Character data(String data)"}, {"syntax_pass": true, "original_string": "        String getData() {\n            return data;\n        }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "String", "classes": []}, "name": "getData", "params": [], "body": "                         {\n            return data;\n        }", "signature": "String getData()"}, {"syntax_pass": true, "original_string": "        @Override\n        public String toString() {\n            return getData();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "toString", "params": [], "body": "                                 {\n            return getData();\n        }", "signature": "@Override\n        public String toString()"}, {"syntax_pass": true, "original_string": "        @Override protected Token.Character clone() {\n            try {\n                return (Token.Character) super.clone();\n            } catch (CloneNotSupportedException e) {\n                throw new RuntimeException(e);\n            }\n        }", "docstring": "", "attributes": {"modifiers": "@Override protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "Token.Character", "classes": []}, "name": "clone", "params": [], "body": "                                                    {\n            try {\n                return (Token.Character) super.clone();\n            } catch (CloneNotSupportedException e) {\n                throw new RuntimeException(e);\n            }\n        }", "signature": "@Override protected Token.Character clone()"}]}, {"original_string": "    final static class CData extends Character {\n        CData(String data) {\n            super();\n            this.data(data);\n        }\n\n        @Override\n        public String toString() {\n            return \"<![CDATA[\" + getData() + \"]]>\";\n        }\n\n    }", "definition": "    final static class CData extends Character", "class_docstring": "", "name": "CData", "super_interfaces": [], "superclasses": "Character", "attributes": {"modifiers": "final static", "marker_annotations": [], "non_marker_annotations": ["final", "static"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        CData(String data) {\n            super();\n            this.data(data);\n        }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "CData", "params": [{"name": "data", "type": "String"}], "body": "                           {\n            super();\n            this.data(data);\n        }", "signature": "CData(String data)"}, {"syntax_pass": true, "original_string": "        @Override\n        public String toString() {\n            return \"<![CDATA[\" + getData() + \"]]>\";\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "toString", "params": [], "body": "                                 {\n            return \"<![CDATA[\" + getData() + \"]]>\";\n        }", "signature": "@Override\n        public String toString()"}]}, {"original_string": "    final static class EOF extends Token {\n        EOF() {\n            super(Token.TokenType.EOF);\n        }\n\n        @Override\n        Token reset() {\n            super.reset();\n            return this;\n        }\n\n        @Override\n        public String toString() {\n            return \"\";\n        }\n    }", "definition": "    final static class EOF extends Token", "class_docstring": "", "name": "EOF", "super_interfaces": [], "superclasses": "Token", "attributes": {"modifiers": "final static", "marker_annotations": [], "non_marker_annotations": ["final", "static"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        EOF() {\n            super(Token.TokenType.EOF);\n        }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "EOF", "params": [], "body": "              {\n            super(Token.TokenType.EOF);\n        }", "signature": "EOF()"}, {"syntax_pass": true, "original_string": "        @Override\n        Token reset() {\n            super.reset();\n            return this;\n        }", "docstring": "", "attributes": {"modifiers": "@Override", "marker_annotations": ["@Override"], "non_marker_annotations": [], "comments": [], "return_type": "Token", "classes": []}, "name": "reset", "params": [], "body": "                      {\n            super.reset();\n            return this;\n        }", "signature": "@Override\n        Token reset()"}, {"syntax_pass": true, "original_string": "        @Override\n        public String toString() {\n            return \"\";\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "toString", "params": [], "body": "                                 {\n            return \"\";\n        }", "signature": "@Override\n        public String toString()"}]}], "class_docstring": "\nParse tokens for the Tokeniser.\n", "original_string": "abstract class Token {\n    final TokenType type; // used in switches in TreeBuilder vs .getClass()\n    static final int Unset = -1;\n    private int startPos, endPos = Unset; // position in CharacterReader this token was read from\n\n    private Token(TokenType type) {\n        this.type = type;\n    }\n    \n    String tokenType() {\n        return this.getClass().getSimpleName();\n    }\n\n    /**\n     * Reset the data represent by this token, for reuse. Prevents the need to create transfer objects for every\n     * piece of data, which immediately get GCed.\n     */\n    Token reset() {\n        startPos = Unset;\n        endPos = Unset;\n        return this;\n    }\n\n    int startPos() {\n        return startPos;\n    }\n\n    void startPos(int pos) {\n        startPos = pos;\n    }\n\n    int endPos() {\n        return endPos;\n    }\n\n    void endPos(int pos) {\n        endPos = pos;\n    }\n\n    static void reset(StringBuilder sb) {\n        if (sb != null) {\n            sb.delete(0, sb.length());\n        }\n    }\n\n    static final class Doctype extends Token {\n        final StringBuilder name = new StringBuilder();\n        @Nullable String pubSysKey = null;\n        final StringBuilder publicIdentifier = new StringBuilder();\n        final StringBuilder systemIdentifier = new StringBuilder();\n        boolean forceQuirks = false;\n\n        Doctype() {\n            super(TokenType.Doctype);\n        }\n\n        @Override\n        Token reset() {\n            super.reset();\n            reset(name);\n            pubSysKey = null;\n            reset(publicIdentifier);\n            reset(systemIdentifier);\n            forceQuirks = false;\n            return this;\n        }\n\n        String getName() {\n            return name.toString();\n        }\n\n        @Nullable String getPubSysKey() {\n            return pubSysKey;\n        }\n\n        String getPublicIdentifier() {\n            return publicIdentifier.toString();\n        }\n\n        public String getSystemIdentifier() {\n            return systemIdentifier.toString();\n        }\n\n        public boolean isForceQuirks() {\n            return forceQuirks;\n        }\n\n        @Override\n        public String toString() {\n            return \"<!doctype \" + getName() + \">\";\n        }\n    }\n\n    static abstract class Tag extends Token {\n        @Nullable protected String tagName;\n        @Nullable protected String normalName; // lc version of tag name, for case-insensitive tree build\n        boolean selfClosing = false;\n        @Nullable Attributes attributes; // start tags get attributes on construction. End tags get attributes on first new attribute (but only for parser convenience, not used).\n\n        @Nullable private String attrName; // try to get attr names and vals in one shot, vs Builder\n        private final StringBuilder attrNameSb = new StringBuilder();\n        private boolean hasAttrName = false;\n\n        @Nullable private String attrValue;\n        private final StringBuilder attrValueSb = new StringBuilder();\n        private boolean hasAttrValue = false;\n        private boolean hasEmptyAttrValue = false; // distinguish boolean attribute from empty string value\n\n        // attribute source range tracking\n        final TreeBuilder treeBuilder;\n        final boolean trackSource;\n        int attrNameStart, attrNameEnd, attrValStart, attrValEnd;\n\n        Tag(TokenType type, TreeBuilder treeBuilder) {\n            super(type);\n            this.treeBuilder = treeBuilder;\n            this.trackSource = treeBuilder.trackSourceRange;\n        }\n\n        @Override\n        Tag reset() {\n            super.reset();\n            tagName = null;\n            normalName = null;\n            selfClosing = false;\n            attributes = null;\n            resetPendingAttr();\n            return this;\n        }\n\n        private void resetPendingAttr() {\n            reset(attrNameSb);\n            attrName = null;\n            hasAttrName = false;\n\n            reset(attrValueSb);\n            attrValue = null;\n            hasEmptyAttrValue = false;\n            hasAttrValue = false;\n\n            if (trackSource)\n                attrNameStart = attrNameEnd = attrValStart = attrValEnd = Unset;\n        }\n\n        /* Limits runaway crafted HTML from spewing attributes and getting a little sluggish in ensureCapacity.\n        Real-world HTML will P99 around 8 attributes, so plenty of headroom. Implemented here and not in the Attributes\n        object so that API users can add more if ever required. */\n        private static final int MaxAttributes = 512;\n\n        final void newAttribute() {\n            if (attributes == null)\n                attributes = new Attributes();\n\n            if (hasAttrName && attributes.size() < MaxAttributes) {\n                // the tokeniser has skipped whitespace control chars, but trimming could collapse to empty for other control codes, so verify here\n                String name = attrNameSb.length() > 0 ? attrNameSb.toString() : attrName;\n                name = name.trim();\n                if (name.length() > 0) {\n                    String value;\n                    if (hasAttrValue)\n                        value = attrValueSb.length() > 0 ? attrValueSb.toString() : attrValue;\n                    else if (hasEmptyAttrValue)\n                        value = \"\";\n                    else\n                        value = null;\n                    // note that we add, not put. So that the first is kept, and rest are deduped, once in a context where case sensitivity is known, and we can warn for duplicates.\n                    attributes.add(name, value);\n\n                    trackAttributeRange(name);\n                }\n            }\n            resetPendingAttr();\n        }\n\n        private void trackAttributeRange(String name) {\n            if (trackSource && isStartTag()) {\n                final StartTag start = asStartTag();\n                final CharacterReader r = start.treeBuilder.reader;\n                final boolean preserve = start.treeBuilder.settings.preserveAttributeCase();\n\n                assert attributes != null;\n                //noinspection unchecked\n                Map<String, Range.AttributeRange> attrRanges =\n                    (Map<String, Range.AttributeRange>) attributes.userData(AttrRangeKey);\n                if (attrRanges == null) {\n                    attrRanges = new HashMap<>();\n                    attributes.userData(AttrRangeKey, attrRanges);\n                }\n\n                if (!preserve) name = Normalizer.lowerCase(name);\n                if (attrRanges.containsKey(name)) return; // dedupe ranges as we go; actual attributes get deduped later for error count\n\n                // if there's no value (e.g. boolean), make it an implicit range at current\n                if (!hasAttrValue) attrValStart = attrValEnd = attrNameEnd;\n\n                Range.AttributeRange range = new Range.AttributeRange(\n                    new Range(\n                        new Range.Position(attrNameStart, r.lineNumber(attrNameStart), r.columnNumber(attrNameStart)),\n                        new Range.Position(attrNameEnd, r.lineNumber(attrNameEnd), r.columnNumber(attrNameEnd))),\n                    new Range(\n                        new Range.Position(attrValStart, r.lineNumber(attrValStart), r.columnNumber(attrValStart)),\n                        new Range.Position(attrValEnd, r.lineNumber(attrValEnd), r.columnNumber(attrValEnd)))\n                );\n                attrRanges.put(name, range);\n            }\n        }\n\n        final boolean hasAttributes() {\n            return attributes != null;\n        }\n\n        /** Case-sensitive check */\n        final boolean hasAttribute(String key) {\n            return attributes != null && attributes.hasKey(key);\n        }\n\n        final boolean hasAttributeIgnoreCase(String key) {\n            return attributes != null && attributes.hasKeyIgnoreCase(key);\n        }\n\n        final void finaliseTag() {\n            // finalises for emit\n            if (hasAttrName) {\n                newAttribute();\n            }\n        }\n\n        /** Preserves case */\n        final String name() { // preserves case, for input into Tag.valueOf (which may drop case)\n            Validate.isFalse(tagName == null || tagName.length() == 0);\n            return tagName;\n        }\n\n        /** Lower case */\n        final String normalName() { // lower case, used in tree building for working out where in tree it should go\n            return normalName;\n        }\n\n        final String toStringName() {\n            return tagName != null ? tagName : \"[unset]\";\n        }\n\n        final Tag name(String name) {\n            tagName = name;\n            normalName = ParseSettings.normalName(tagName);\n            return this;\n        }\n\n        final boolean isSelfClosing() {\n            return selfClosing;\n        }\n\n        // these appenders are rarely hit in not null state-- caused by null chars.\n        final void appendTagName(String append) {\n            // might have null chars - need to replace with null replacement character\n            append = append.replace(TokeniserState.nullChar, Tokeniser.replacementChar);\n            tagName = tagName == null ? append : tagName.concat(append);\n            normalName = ParseSettings.normalName(tagName);\n        }\n\n        final void appendTagName(char append) {\n            appendTagName(String.valueOf(append));\n        }\n\n        final void appendAttributeName(String append, int startPos, int endPos) {\n            // might have null chars because we eat in one pass - need to replace with null replacement character\n            append = append.replace(TokeniserState.nullChar, Tokeniser.replacementChar);\n\n            ensureAttrName(startPos, endPos);\n            if (attrNameSb.length() == 0) {\n                attrName = append;\n            } else {\n                attrNameSb.append(append);\n            }\n        }\n\n        final void appendAttributeName(char append, int startPos, int endPos) {\n            ensureAttrName(startPos, endPos);\n            attrNameSb.append(append);\n        }\n\n        final void appendAttributeValue(String append, int startPos, int endPos) {\n            ensureAttrValue(startPos, endPos);\n            if (attrValueSb.length() == 0) {\n                attrValue = append;\n            } else {\n                attrValueSb.append(append);\n            }\n        }\n\n        final void appendAttributeValue(char append, int startPos, int endPos) {\n            ensureAttrValue(startPos, endPos);\n            attrValueSb.append(append);\n        }\n\n        final void appendAttributeValue(int[] appendCodepoints, int startPos, int endPos) {\n            ensureAttrValue(startPos, endPos);\n            for (int codepoint : appendCodepoints) {\n                attrValueSb.appendCodePoint(codepoint);\n            }\n        }\n        \n        final void setEmptyAttributeValue() {\n            hasEmptyAttrValue = true;\n        }\n\n        private void ensureAttrName(int startPos, int endPos) {\n            hasAttrName = true;\n            // if on second hit, we'll need to move to the builder\n            if (attrName != null) {\n                attrNameSb.append(attrName);\n                attrName = null;\n            }\n            if (trackSource) {\n                attrNameStart = attrNameStart > Unset ? attrNameStart : startPos; // latches to first\n                attrNameEnd = endPos;\n            }\n        }\n\n        private void ensureAttrValue(int startPos, int endPos) {\n            hasAttrValue = true;\n            // if on second hit, we'll need to move to the builder\n            if (attrValue != null) {\n                attrValueSb.append(attrValue);\n                attrValue = null;\n            }\n            if (trackSource) {\n                attrValStart = attrValStart > Unset ? attrValStart : startPos; // latches to first\n                attrValEnd = endPos;\n            }\n        }\n\n        @Override\n        abstract public String toString();\n    }\n\n    final static class StartTag extends Tag {\n\n        // TreeBuilder is provided so if tracking, can get line / column positions for Range; and can dedupe as we go\n        StartTag(TreeBuilder treeBuilder) {\n            super(TokenType.StartTag, treeBuilder);\n        }\n\n        @Override\n        Tag reset() {\n            super.reset();\n            attributes = null;\n            return this;\n        }\n\n        StartTag nameAttr(String name, Attributes attributes) {\n            this.tagName = name;\n            this.attributes = attributes;\n            normalName = ParseSettings.normalName(tagName);\n            return this;\n        }\n\n        @Override\n        public String toString() {\n            String closer = isSelfClosing() ? \"/>\" : \">\";\n            if (hasAttributes() && attributes.size() > 0)\n                return \"<\" + toStringName() + \" \" + attributes.toString() + closer;\n            else\n                return \"<\" + toStringName() + closer;\n        }\n    }\n\n    final static class EndTag extends Tag{\n        EndTag(TreeBuilder treeBuilder) {\n            super(TokenType.EndTag, treeBuilder);\n        }\n\n        @Override\n        public String toString() {\n            return \"</\" + toStringName() + \">\";\n        }\n    }\n\n    final static class Comment extends Token {\n        private final StringBuilder data = new StringBuilder();\n        private String dataS; // try to get in one shot\n        boolean bogus = false;\n\n        @Override\n        Token reset() {\n            super.reset();\n            reset(data);\n            dataS = null;\n            bogus = false;\n            return this;\n        }\n\n        Comment() {\n            super(TokenType.Comment);\n        }\n\n        String getData() {\n            return dataS != null ? dataS : data.toString();\n        }\n\n        Comment append(String append) {\n            ensureData();\n            if (data.length() == 0) {\n                dataS = append;\n            } else {\n                data.append(append);\n            }\n            return this;\n        }\n\n        Comment append(char append) {\n            ensureData();\n            data.append(append);\n            return this;\n        }\n\n        private void ensureData() {\n            // if on second hit, we'll need to move to the builder\n            if (dataS != null) {\n                data.append(dataS);\n                dataS = null;\n            }\n        }\n\n        @Override\n        public String toString() {\n            return \"<!--\" + getData() + \"-->\";\n        }\n    }\n\n    static class Character extends Token implements Cloneable {\n        private String data;\n\n        Character() {\n            super(TokenType.Character);\n        }\n\n        @Override\n        Token reset() {\n            super.reset();\n            data = null;\n            return this;\n        }\n\n        Character data(String data) {\n            this.data = data;\n            return this;\n        }\n\n        String getData() {\n            return data;\n        }\n\n        @Override\n        public String toString() {\n            return getData();\n        }\n\n        @Override protected Token.Character clone() {\n            try {\n                return (Token.Character) super.clone();\n            } catch (CloneNotSupportedException e) {\n                throw new RuntimeException(e);\n            }\n        }\n    }\n\n    final static class CData extends Character {\n        CData(String data) {\n            super();\n            this.data(data);\n        }\n\n        @Override\n        public String toString() {\n            return \"<![CDATA[\" + getData() + \"]]>\";\n        }\n\n    }\n\n    final static class EOF extends Token {\n        EOF() {\n            super(Token.TokenType.EOF);\n        }\n\n        @Override\n        Token reset() {\n            super.reset();\n            return this;\n        }\n\n        @Override\n        public String toString() {\n            return \"\";\n        }\n    }\n\n    final boolean isDoctype() {\n        return type == TokenType.Doctype;\n    }\n\n    final Doctype asDoctype() {\n        return (Doctype) this;\n    }\n\n    final boolean isStartTag() {\n        return type == TokenType.StartTag;\n    }\n\n    final StartTag asStartTag() {\n        return (StartTag) this;\n    }\n\n    final boolean isEndTag() {\n        return type == TokenType.EndTag;\n    }\n\n    final EndTag asEndTag() {\n        return (EndTag) this;\n    }\n\n    final boolean isComment() {\n        return type == TokenType.Comment;\n    }\n\n    final Comment asComment() {\n        return (Comment) this;\n    }\n\n    final boolean isCharacter() {\n        return type == TokenType.Character;\n    }\n\n    final boolean isCData() {\n        return this instanceof CData;\n    }\n\n    final Character asCharacter() {\n        return (Character) this;\n    }\n\n    final boolean isEOF() {\n        return type == TokenType.EOF;\n    }\n\n    public enum TokenType {\n        Doctype,\n        StartTag,\n        EndTag,\n        Comment,\n        Character, // note no CData - treated in builder as an extension of Character\n        EOF\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "final TokenType type;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "TokenType", "name": "type", "syntax_pass": true}, {"attribute_expression": "static final int Unset = -1;", "docstring": " used in switches in TreeBuilder vs .getClass()", "modifiers": "static final", "marker_annotations": [], "non_marker_annotations": ["static", "final"], "comments": [], "type": "int", "name": "Unset = -1", "syntax_pass": true}, {"attribute_expression": "private int startPos, endPos = Unset;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "int", "name": "startPos", "syntax_pass": true}]}, {"uris": "src/main/java/org/jsoup/nodes/LeafNode.java.LeafNode", "name": "LeafNode", "file_path": "src/main/java/org/jsoup/nodes/LeafNode.java", "superclasses": "Node", "methods": ["[]LeafNode()", "[]LeafNode(String)", "[boolean]hasAttributes()", "[Attributes]attributes()", "[void]ensureAttributes()", "[String]coreValue()", "[void]coreValue(String)", "[String]attr(String)", "[Node]attr(String,String)", "[boolean]hasAttr(String)", "[Node]removeAttr(String)", "[String]absUrl(String)", "[String]baseUri()", "[void]doSetBaseUri(String)", "[int]childNodeSize()", "[Node]empty()", "[List<Node>]ensureChildNodes()", "[LeafNode]doClone(Node)"], "method_uris": ["src/main/java/org/jsoup/nodes/LeafNode.java.LeafNode.[]LeafNode()", "src/main/java/org/jsoup/nodes/LeafNode.java.LeafNode.[]LeafNode(String)", "src/main/java/org/jsoup/nodes/LeafNode.java.LeafNode.[boolean]hasAttributes()", "src/main/java/org/jsoup/nodes/LeafNode.java.LeafNode.[Attributes]attributes()", "src/main/java/org/jsoup/nodes/LeafNode.java.LeafNode.[void]ensureAttributes()", "src/main/java/org/jsoup/nodes/LeafNode.java.LeafNode.[String]coreValue()", "src/main/java/org/jsoup/nodes/LeafNode.java.LeafNode.[void]coreValue(String)", "src/main/java/org/jsoup/nodes/LeafNode.java.LeafNode.[String]attr(String)", "src/main/java/org/jsoup/nodes/LeafNode.java.LeafNode.[Node]attr(String,String)", "src/main/java/org/jsoup/nodes/LeafNode.java.LeafNode.[boolean]hasAttr(String)", "src/main/java/org/jsoup/nodes/LeafNode.java.LeafNode.[Node]removeAttr(String)", "src/main/java/org/jsoup/nodes/LeafNode.java.LeafNode.[String]absUrl(String)", "src/main/java/org/jsoup/nodes/LeafNode.java.LeafNode.[String]baseUri()", "src/main/java/org/jsoup/nodes/LeafNode.java.LeafNode.[void]doSetBaseUri(String)", "src/main/java/org/jsoup/nodes/LeafNode.java.LeafNode.[int]childNodeSize()", "src/main/java/org/jsoup/nodes/LeafNode.java.LeafNode.[Node]empty()", "src/main/java/org/jsoup/nodes/LeafNode.java.LeafNode.[List<Node>]ensureChildNodes()", "src/main/java/org/jsoup/nodes/LeafNode.java.LeafNode.[LeafNode]doClone(Node)"], "overrides": null, "attributes": [], "class_docstring": "\nA node that does not hold any children. E.g.: {@link TextNode}, {@link DataNode}, {@link Comment}.\n", "original_string": "public abstract class LeafNode extends Node {\n    Object value; // either a string value, or an attribute map (in the rare case multiple attributes are set)\n\n    public LeafNode() {\n        value = \"\";\n    }\n\n    protected LeafNode(String coreValue) {\n        Validate.notNull(coreValue);\n        value = coreValue;\n    }\n\n    @Override protected final boolean hasAttributes() {\n        return value instanceof Attributes;\n    }\n\n    @Override\n    public final Attributes attributes() {\n        ensureAttributes();\n        return (Attributes) value;\n    }\n\n    private void ensureAttributes() {\n        if (!hasAttributes()) { // then value is String coreValue\n            String coreValue = (String) value;\n            Attributes attributes = new Attributes();\n            value = attributes;\n            attributes.put(nodeName(), coreValue);\n        }\n    }\n\n    String coreValue() {\n        return attr(nodeName());\n    }\n\n    void coreValue(String value) {\n        attr(nodeName(), value);\n    }\n\n    @Override\n    public String attr(String key) {\n        if (!hasAttributes()) {\n            return nodeName().equals(key) ? (String) value : EmptyString;\n        }\n        return super.attr(key);\n    }\n\n    @Override\n    public Node attr(String key, String value) {\n        if (!hasAttributes() && key.equals(nodeName())) {\n            this.value = value;\n        } else {\n            ensureAttributes();\n            super.attr(key, value);\n        }\n        return this;\n    }\n\n    @Override\n    public boolean hasAttr(String key) {\n        ensureAttributes();\n        return super.hasAttr(key);\n    }\n\n    @Override\n    public Node removeAttr(String key) {\n        ensureAttributes();\n        return super.removeAttr(key);\n    }\n\n    @Override\n    public String absUrl(String key) {\n        ensureAttributes();\n        return super.absUrl(key);\n    }\n\n    @Override\n    public String baseUri() {\n        return parentNode != null ? parentNode.baseUri() : \"\";\n    }\n\n    @Override\n    protected void doSetBaseUri(String baseUri) {\n        // noop\n    }\n\n    @Override\n    public int childNodeSize() {\n        return 0;\n    }\n\n    @Override\n    public Node empty() {\n        return this;\n    }\n\n    @Override\n    protected List<Node> ensureChildNodes() {\n        return EmptyNodes;\n    }\n\n    @Override\n    protected LeafNode doClone(Node parent) {\n        LeafNode clone = (LeafNode) super.doClone(parent);\n\n        // Object value could be plain string or attributes - need to clone\n        if (hasAttributes())\n            clone.value = ((Attributes) value).clone();\n\n        return clone;\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "Object value;", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "Object", "name": "value", "syntax_pass": true}]}, {"uris": "src/main/java/org/jsoup/nodes/Node.java.Node", "name": "Node", "file_path": "src/main/java/org/jsoup/nodes/Node.java", "superclasses": "", "methods": ["[]Node()", "[String]nodeName()", "[String]normalName()", "[boolean]nameIs(String)", "[boolean]parentNameIs(String)", "[boolean]parentElementIs(String,String)", "[boolean]hasAttributes()", "[boolean]hasParent()", "[String]attr(String)", "[Attributes]attributes()", "[int]attributesSize()", "[Node]attr(String,String)", "[boolean]hasAttr(String)", "[Node]removeAttr(String)", "[Node]clearAttributes()", "[String]baseUri()", "[void]doSetBaseUri(String)", "[void]setBaseUri(String)", "[String]absUrl(String)", "[List<Node>]ensureChildNodes()", "[Node]childNode(int)", "[List<Node>]childNodes()", "[List<Node>]childNodesCopy()", "[int]childNodeSize()", "[Node[]]childNodesAsArray()", "[Node]empty()", "[Node]parent()", "[Node]parentNode()", "[Node]root()", "[Document]ownerDocument()", "[void]remove()", "[Node]before(String)", "[Node]before(Node)", "[Node]after(String)", "[Node]after(Node)", "[void]addSiblingHtml(int,String)", "[Node]wrap(String)", "[Node]unwrap()", "[Element]getDeepChild(Element)", "[void]nodelistChanged()", "[void]replaceWith(Node)", "[void]setParentNode(Node)", "[void]replaceChild(Node,Node)", "[void]removeChild(Node)", "[void]addChildren()", "[void]addChildren(int)", "[void]reparentChild(Node)", "[void]reindexChildren(int)", "[List<Node>]siblingNodes()", "[Node]nextSibling()", "[Node]previousSibling()", "[int]siblingIndex()", "[void]setSiblingIndex(int)", "[Node]firstChild()", "[Node]lastChild()", "[Node]traverse(NodeVisitor)", "[Node]forEachNode(Consumer<? super Node>)", "[Node]filter(NodeFilter)", "[Stream<Node>]nodeStream()", "[Stream<T>]nodeStream(Class<T>)", "[String]outerHtml()", "[void]outerHtml(Appendable)", "[void]outerHtmlHead(Appendable,int,Document.OutputSettings)", "[void]outerHtmlTail(Appendable,int,Document.OutputSettings)", "[T]html(T)", "[Range]sourceRange()", "[boolean]isEffectivelyFirst()", "[String]toString()", "[void]indent(Appendable,int,Document.OutputSettings)", "[boolean]equals(Object)", "[int]hashCode()", "[boolean]hasSameValue(Object)", "[Node]clone()", "[Node]shallowClone()", "[Node]doClone(Node)"], "method_uris": ["src/main/java/org/jsoup/nodes/Node.java.Node.[]Node()", "src/main/java/org/jsoup/nodes/Node.java.Node.[String]nodeName()", "src/main/java/org/jsoup/nodes/Node.java.Node.[String]normalName()", "src/main/java/org/jsoup/nodes/Node.java.Node.[boolean]nameIs(String)", "src/main/java/org/jsoup/nodes/Node.java.Node.[boolean]parentNameIs(String)", "src/main/java/org/jsoup/nodes/Node.java.Node.[boolean]parentElementIs(String,String)", "src/main/java/org/jsoup/nodes/Node.java.Node.[boolean]hasAttributes()", "src/main/java/org/jsoup/nodes/Node.java.Node.[boolean]hasParent()", "src/main/java/org/jsoup/nodes/Node.java.Node.[String]attr(String)", "src/main/java/org/jsoup/nodes/Node.java.Node.[Attributes]attributes()", "src/main/java/org/jsoup/nodes/Node.java.Node.[int]attributesSize()", "src/main/java/org/jsoup/nodes/Node.java.Node.[Node]attr(String,String)", "src/main/java/org/jsoup/nodes/Node.java.Node.[boolean]hasAttr(String)", "src/main/java/org/jsoup/nodes/Node.java.Node.[Node]removeAttr(String)", "src/main/java/org/jsoup/nodes/Node.java.Node.[Node]clearAttributes()", "src/main/java/org/jsoup/nodes/Node.java.Node.[String]baseUri()", "src/main/java/org/jsoup/nodes/Node.java.Node.[void]doSetBaseUri(String)", "src/main/java/org/jsoup/nodes/Node.java.Node.[void]setBaseUri(String)", "src/main/java/org/jsoup/nodes/Node.java.Node.[String]absUrl(String)", "src/main/java/org/jsoup/nodes/Node.java.Node.[List<Node>]ensureChildNodes()", "src/main/java/org/jsoup/nodes/Node.java.Node.[Node]childNode(int)", "src/main/java/org/jsoup/nodes/Node.java.Node.[List<Node>]childNodes()", "src/main/java/org/jsoup/nodes/Node.java.Node.[List<Node>]childNodesCopy()", "src/main/java/org/jsoup/nodes/Node.java.Node.[int]childNodeSize()", "src/main/java/org/jsoup/nodes/Node.java.Node.[Node[]]childNodesAsArray()", "src/main/java/org/jsoup/nodes/Node.java.Node.[Node]empty()", "src/main/java/org/jsoup/nodes/Node.java.Node.[Node]parent()", "src/main/java/org/jsoup/nodes/Node.java.Node.[Node]parentNode()", "src/main/java/org/jsoup/nodes/Node.java.Node.[Node]root()", "src/main/java/org/jsoup/nodes/Node.java.Node.[Document]ownerDocument()", "src/main/java/org/jsoup/nodes/Node.java.Node.[void]remove()", "src/main/java/org/jsoup/nodes/Node.java.Node.[Node]before(String)", "src/main/java/org/jsoup/nodes/Node.java.Node.[Node]before(Node)", "src/main/java/org/jsoup/nodes/Node.java.Node.[Node]after(String)", "src/main/java/org/jsoup/nodes/Node.java.Node.[Node]after(Node)", "src/main/java/org/jsoup/nodes/Node.java.Node.[void]addSiblingHtml(int,String)", "src/main/java/org/jsoup/nodes/Node.java.Node.[Node]wrap(String)", "src/main/java/org/jsoup/nodes/Node.java.Node.[Node]unwrap()", "src/main/java/org/jsoup/nodes/Node.java.Node.[Element]getDeepChild(Element)", "src/main/java/org/jsoup/nodes/Node.java.Node.[void]nodelistChanged()", "src/main/java/org/jsoup/nodes/Node.java.Node.[void]replaceWith(Node)", "src/main/java/org/jsoup/nodes/Node.java.Node.[void]setParentNode(Node)", "src/main/java/org/jsoup/nodes/Node.java.Node.[void]replaceChild(Node,Node)", "src/main/java/org/jsoup/nodes/Node.java.Node.[void]removeChild(Node)", "src/main/java/org/jsoup/nodes/Node.java.Node.[void]addChildren()", "src/main/java/org/jsoup/nodes/Node.java.Node.[void]addChildren(int)", "src/main/java/org/jsoup/nodes/Node.java.Node.[void]reparentChild(Node)", "src/main/java/org/jsoup/nodes/Node.java.Node.[void]reindexChildren(int)", "src/main/java/org/jsoup/nodes/Node.java.Node.[List<Node>]siblingNodes()", "src/main/java/org/jsoup/nodes/Node.java.Node.[Node]nextSibling()", "src/main/java/org/jsoup/nodes/Node.java.Node.[Node]previousSibling()", "src/main/java/org/jsoup/nodes/Node.java.Node.[int]siblingIndex()", "src/main/java/org/jsoup/nodes/Node.java.Node.[void]setSiblingIndex(int)", "src/main/java/org/jsoup/nodes/Node.java.Node.[Node]firstChild()", "src/main/java/org/jsoup/nodes/Node.java.Node.[Node]lastChild()", "src/main/java/org/jsoup/nodes/Node.java.Node.[Node]traverse(NodeVisitor)", "src/main/java/org/jsoup/nodes/Node.java.Node.[Node]forEachNode(Consumer<? super Node>)", "src/main/java/org/jsoup/nodes/Node.java.Node.[Node]filter(NodeFilter)", "src/main/java/org/jsoup/nodes/Node.java.Node.[Stream<Node>]nodeStream()", "src/main/java/org/jsoup/nodes/Node.java.Node.[Stream<T>]nodeStream(Class<T>)", "src/main/java/org/jsoup/nodes/Node.java.Node.[String]outerHtml()", "src/main/java/org/jsoup/nodes/Node.java.Node.[void]outerHtml(Appendable)", "src/main/java/org/jsoup/nodes/Node.java.Node.[void]outerHtmlHead(Appendable,int,Document.OutputSettings)", "src/main/java/org/jsoup/nodes/Node.java.Node.[void]outerHtmlTail(Appendable,int,Document.OutputSettings)", "src/main/java/org/jsoup/nodes/Node.java.Node.[T]html(T)", "src/main/java/org/jsoup/nodes/Node.java.Node.[Range]sourceRange()", "src/main/java/org/jsoup/nodes/Node.java.Node.[boolean]isEffectivelyFirst()", "src/main/java/org/jsoup/nodes/Node.java.Node.[String]toString()", "src/main/java/org/jsoup/nodes/Node.java.Node.[void]indent(Appendable,int,Document.OutputSettings)", "src/main/java/org/jsoup/nodes/Node.java.Node.[boolean]equals(Object)", "src/main/java/org/jsoup/nodes/Node.java.Node.[int]hashCode()", "src/main/java/org/jsoup/nodes/Node.java.Node.[boolean]hasSameValue(Object)", "src/main/java/org/jsoup/nodes/Node.java.Node.[Node]clone()", "src/main/java/org/jsoup/nodes/Node.java.Node.[Node]shallowClone()", "src/main/java/org/jsoup/nodes/Node.java.Node.[Node]doClone(Node)"], "overrides": null, "attributes": [{"original_string": "    private static class OuterHtmlVisitor implements NodeVisitor {\n        private final Appendable accum;\n        private final Document.OutputSettings out;\n\n        OuterHtmlVisitor(Appendable accum, Document.OutputSettings out) {\n            this.accum = accum;\n            this.out = out;\n        }\n\n        @Override public void head(Node node, int depth) {\n            try {\n\t\t\t\tnode.outerHtmlHead(accum, depth, out);\n\t\t\t} catch (IOException exception) {\n\t\t\t\tthrow new SerializationException(exception);\n\t\t\t}\n        }\n\n        @Override public void tail(Node node, int depth) {\n            if (!node.nodeName().equals(\"#text\")) { // saves a void hit.\n\t\t\t\ttry {\n\t\t\t\t\tnode.outerHtmlTail(accum, depth, out);\n\t\t\t\t} catch (IOException exception) {\n\t\t\t\t\tthrow new SerializationException(exception);\n\t\t\t\t}\n            }\n        }\n    }", "definition": "    private static class OuterHtmlVisitor implements NodeVisitor", "class_docstring": "", "name": "OuterHtmlVisitor", "super_interfaces": ["NodeVisitor"], "superclasses": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "fields": [{"attribute_expression": "private final Appendable accum;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Appendable", "name": "accum", "syntax_pass": true}, {"attribute_expression": "private final Document.OutputSettings out;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Document.OutputSettings", "name": "out", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        OuterHtmlVisitor(Appendable accum, Document.OutputSettings out) {\n            this.accum = accum;\n            this.out = out;\n        }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "OuterHtmlVisitor", "params": [{"name": "accum", "type": "Appendable"}, {"name": "out", "type": "Document.OutputSettings"}], "body": "                                                                        {\n            this.accum = accum;\n            this.out = out;\n        }", "signature": "OuterHtmlVisitor(Appendable accum, Document.OutputSettings out)"}, {"syntax_pass": true, "original_string": "        @Override public void head(Node node, int depth) {\n            try {\n\t\t\t\tnode.outerHtmlHead(accum, depth, out);\n\t\t\t} catch (IOException exception) {\n\t\t\t\tthrow new SerializationException(exception);\n\t\t\t}\n        }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "head", "params": [{"name": "node", "type": "Node"}, {"name": "depth", "type": "int"}], "body": "                                                         {\n            try {\n\t\t\t\tnode.outerHtmlHead(accum, depth, out);\n\t\t\t} catch (IOException exception) {\n\t\t\t\tthrow new SerializationException(exception);\n\t\t\t}\n        }", "signature": "@Override public void head(Node node, int depth)"}, {"syntax_pass": true, "original_string": "        @Override public void tail(Node node, int depth) {\n            if (!node.nodeName().equals(\"#text\")) { // saves a void hit.\n\t\t\t\ttry {\n\t\t\t\t\tnode.outerHtmlTail(accum, depth, out);\n\t\t\t\t} catch (IOException exception) {\n\t\t\t\t\tthrow new SerializationException(exception);\n\t\t\t\t}\n            }\n        }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "tail", "params": [{"name": "node", "type": "Node"}, {"name": "depth", "type": "int"}], "body": "                                                         {\n            if (!node.nodeName().equals(\"#text\")) { // saves a void hit.\n\t\t\t\ttry {\n\t\t\t\t\tnode.outerHtmlTail(accum, depth, out);\n\t\t\t\t} catch (IOException exception) {\n\t\t\t\t\tthrow new SerializationException(exception);\n\t\t\t\t}\n            }\n        }", "signature": "@Override public void tail(Node node, int depth)"}]}], "class_docstring": "\nThe base, abstract Node model. {@link Element}, {@link Document}, {@link Comment}, {@link TextNode}, et al.,\nare instances of Node.\n\n@author Jonathan Hedley, jonathan@hedley.net", "original_string": "public abstract class Node implements Cloneable {\n    static final List<Node> EmptyNodes = Collections.emptyList();\n    static final String EmptyString = \"\";\n    @Nullable Node parentNode; // Nodes don't always have parents\n    int siblingIndex;\n\n    /**\n     * Default constructor. Doesn't set up base uri, children, or attributes; use with caution.\n     */\n    protected Node() {\n    }\n\n    /**\n     Get the node name of this node. Use for debugging purposes and not logic switching (for that, use instanceof).\n     @return node name\n     */\n    public abstract String nodeName();\n\n    /**\n     Get the normalized name of this node. For node types other than Element, this is the same as {@link #nodeName()}.\n     For an Element, will be the lower-cased tag name.\n     @return normalized node name\n     @since 1.15.4.\n     */\n    public String normalName() {\n        return nodeName();\n    }\n\n    /**\n     Test if this node has the specified normalized name, in any namespace.\n     * @param normalName a normalized element name (e.g. {@code div}).\n     * @return true if the element's normal name matches exactly\n     * @since 1.17.2\n     */\n    public boolean nameIs(String normalName) {\n        return normalName().equals(normalName);\n    }\n\n    /**\n     Test if this node's parent has the specified normalized name.\n     * @param normalName a normalized name (e.g. {@code div}).\n     * @return true if the parent element's normal name matches exactly\n     * @since 1.17.2\n     */\n    public boolean parentNameIs(String normalName) {\n        return parentNode != null && parentNode.normalName().equals(normalName);\n    }\n\n    /**\n     Test if this node's parent is an Element with the specified normalized name and namespace.\n     * @param normalName a normalized element name (e.g. {@code div}).\n     * @param namespace the namespace\n     * @return true if the parent element's normal name matches exactly, and that element is in the specified namespace\n     * @since 1.17.2\n     */\n    public boolean parentElementIs(String normalName, String namespace) {\n        return parentNode != null && parentNode instanceof Element\n            && ((Element) parentNode).elementIs(normalName, namespace);\n    }\n\n    /**\n     * Check if this Node has an actual Attributes object.\n     */\n    protected abstract boolean hasAttributes();\n\n    /**\n     Checks if this node has a parent. Nodes won't have parents if (e.g.) they are newly created and not added as a child\n     to an existing node, or if they are a {@link #shallowClone()}. In such cases, {@link #parent()} will return {@code null}.\n     @return if this node has a parent.\n     */\n    public boolean hasParent() {\n        return parentNode != null;\n    }\n\n    /**\n     * Get an attribute's value by its key. <b>Case insensitive</b>\n     * <p>\n     * To get an absolute URL from an attribute that may be a relative URL, prefix the key with <code><b>abs:</b></code>,\n     * which is a shortcut to the {@link #absUrl} method.\n     * </p>\n     * E.g.:\n     * <blockquote><code>String url = a.attr(\"abs:href\");</code></blockquote>\n     *\n     * @param attributeKey The attribute key.\n     * @return The attribute, or empty string if not present (to avoid nulls).\n     * @see #attributes()\n     * @see #hasAttr(String)\n     * @see #absUrl(String)\n     */\n    public String attr(String attributeKey) {\n        Validate.notNull(attributeKey);\n        if (!hasAttributes())\n            return EmptyString;\n\n        String val = attributes().getIgnoreCase(attributeKey);\n        if (val.length() > 0)\n            return val;\n        else if (attributeKey.startsWith(\"abs:\"))\n            return absUrl(attributeKey.substring(\"abs:\".length()));\n        else return \"\";\n    }\n\n    /**\n     * Get each of the Element's attributes.\n     * @return attributes (which implements Iterable, with the same order as presented in the original HTML).\n     */\n    public abstract Attributes attributes();\n\n    /**\n     Get the number of attributes that this Node has.\n     @return the number of attributes\n     @since 1.14.2\n     */\n    public int attributesSize() {\n        // added so that we can test how many attributes exist without implicitly creating the Attributes object\n        return hasAttributes() ? attributes().size() : 0;\n    }\n\n    /**\n     * Set an attribute (key=value). If the attribute already exists, it is replaced. The attribute key comparison is\n     * <b>case insensitive</b>. The key will be set with case sensitivity as set in the parser settings.\n     * @param attributeKey The attribute key.\n     * @param attributeValue The attribute value.\n     * @return this (for chaining)\n     */\n    public Node attr(String attributeKey, String attributeValue) {\n        attributeKey = NodeUtils.parser(this).settings().normalizeAttribute(attributeKey);\n        attributes().putIgnoreCase(attributeKey, attributeValue);\n        return this;\n    }\n\n    /**\n     * Test if this Node has an attribute. <b>Case insensitive</b>.\n     * @param attributeKey The attribute key to check.\n     * @return true if the attribute exists, false if not.\n     */\n    public boolean hasAttr(String attributeKey) {\n        Validate.notNull(attributeKey);\n        if (!hasAttributes())\n            return false;\n\n        if (attributeKey.startsWith(\"abs:\")) {\n            String key = attributeKey.substring(\"abs:\".length());\n            if (attributes().hasKeyIgnoreCase(key) && !absUrl(key).isEmpty())\n                return true;\n        }\n        return attributes().hasKeyIgnoreCase(attributeKey);\n    }\n\n    /**\n     * Remove an attribute from this node.\n     * @param attributeKey The attribute to remove.\n     * @return this (for chaining)\n     */\n    public Node removeAttr(String attributeKey) {\n        Validate.notNull(attributeKey);\n        if (hasAttributes())\n            attributes().removeIgnoreCase(attributeKey);\n        return this;\n    }\n\n    /**\n     * Clear (remove) each of the attributes in this node.\n     * @return this, for chaining\n     */\n    public Node clearAttributes() {\n        if (hasAttributes()) {\n            Iterator<Attribute> it = attributes().iterator();\n            while (it.hasNext()) {\n                it.next();\n                it.remove();\n            }\n        }\n        return this;\n    }\n\n    /**\n     Get the base URI that applies to this node. Will return an empty string if not defined. Used to make relative links\n     absolute.\n\n     @return base URI\n     @see #absUrl\n     */\n    public abstract String baseUri();\n\n    /**\n     * Set the baseUri for just this node (not its descendants), if this Node tracks base URIs.\n     * @param baseUri new URI\n     */\n    protected abstract void doSetBaseUri(String baseUri);\n\n    /**\n     Update the base URI of this node and all of its descendants.\n     @param baseUri base URI to set\n     */\n    public void setBaseUri(final String baseUri) {\n        Validate.notNull(baseUri);\n        doSetBaseUri(baseUri);\n    }\n\n    /**\n     * Get an absolute URL from a URL attribute that may be relative (such as an <code>&lt;a href&gt;</code> or\n     * <code>&lt;img src&gt;</code>).\n     * <p>\n     * E.g.: <code>String absUrl = linkEl.absUrl(\"href\");</code>\n     * </p>\n     * <p>\n     * If the attribute value is already absolute (i.e. it starts with a protocol, like\n     * <code>http://</code> or <code>https://</code> etc), and it successfully parses as a URL, the attribute is\n     * returned directly. Otherwise, it is treated as a URL relative to the element's {@link #baseUri}, and made\n     * absolute using that.\n     * </p>\n     * <p>\n     * As an alternate, you can use the {@link #attr} method with the <code>abs:</code> prefix, e.g.:\n     * <code>String absUrl = linkEl.attr(\"abs:href\");</code>\n     * </p>\n     *\n     * @param attributeKey The attribute key\n     * @return An absolute URL if one could be made, or an empty string (not null) if the attribute was missing or\n     * could not be made successfully into a URL.\n     * @see #attr\n     * @see java.net.URL#URL(java.net.URL, String)\n     */\n    public String absUrl(String attributeKey) {\n        Validate.notEmpty(attributeKey);\n        if (!(hasAttributes() && attributes().hasKeyIgnoreCase(attributeKey))) // not using hasAttr, so that we don't recurse down hasAttr->absUrl\n            return \"\";\n\n        return StringUtil.resolve(baseUri(), attributes().getIgnoreCase(attributeKey));\n    }\n\n    protected abstract List<Node> ensureChildNodes();\n\n    /**\n     Get a child node by its 0-based index.\n     @param index index of child node\n     @return the child node at this index.\n     @throws IndexOutOfBoundsException if the index is out of bounds.\n     */\n    public Node childNode(int index) {\n        return ensureChildNodes().get(index);\n    }\n\n    /**\n     Get this node's children. Presented as an unmodifiable list: new children can not be added, but the child nodes\n     themselves can be manipulated.\n     @return list of children. If no children, returns an empty list.\n     */\n    public List<Node> childNodes() {\n        if (childNodeSize() == 0)\n            return EmptyNodes;\n\n        List<Node> children = ensureChildNodes();\n        List<Node> rewrap = new ArrayList<>(children.size()); // wrapped so that looping and moving will not throw a CME as the source changes\n        rewrap.addAll(children);\n        return Collections.unmodifiableList(rewrap);\n    }\n\n    /**\n     * Returns a deep copy of this node's children. Changes made to these nodes will not be reflected in the original\n     * nodes\n     * @return a deep copy of this node's children\n     */\n    public List<Node> childNodesCopy() {\n        final List<Node> nodes = ensureChildNodes();\n        final ArrayList<Node> children = new ArrayList<>(nodes.size());\n        for (Node node : nodes) {\n            children.add(node.clone());\n        }\n        return children;\n    }\n\n    /**\n     * Get the number of child nodes that this node holds.\n     * @return the number of child nodes that this node holds.\n     */\n    public abstract int childNodeSize();\n\n    protected Node[] childNodesAsArray() {\n        return ensureChildNodes().toArray(new Node[0]);\n    }\n\n    /**\n     * Delete all this node's children.\n     * @return this node, for chaining\n     */\n    public abstract Node empty();\n\n\n    /**\n     Gets this node's parent node.\n     @return parent node; or null if no parent.\n     @see #hasParent()\n     */\n    public @Nullable Node parent() {\n        return parentNode;\n    }\n\n    /**\n     Gets this node's parent node. Not overridable by extending classes, so useful if you really just need the Node type.\n     @return parent node; or null if no parent.\n     */\n    public @Nullable final Node parentNode() {\n        return parentNode;\n    }\n\n    /**\n     * Get this node's root node; that is, its topmost ancestor. If this node is the top ancestor, returns {@code this}.\n     * @return topmost ancestor.\n     */\n    public Node root() {\n        Node node = this;\n        while (node.parentNode != null)\n            node = node.parentNode;\n        return node;\n    }\n\n    /**\n     * Gets the Document associated with this Node.\n     * @return the Document associated with this Node, or null if there is no such Document.\n     */\n    public @Nullable Document ownerDocument() {\n        Node root = root();\n        return (root instanceof Document) ? (Document) root : null;\n    }\n\n    /**\n     * Remove (delete) this node from the DOM tree. If this node has children, they are also removed. If this node is\n     * an orphan, nothing happens.\n     */\n    public void remove() {\n        if (parentNode != null)\n            parentNode.removeChild(this);\n    }\n\n    /**\n     * Insert the specified HTML into the DOM before this node (as a preceding sibling).\n     * @param html HTML to add before this node\n     * @return this node, for chaining\n     * @see #after(String)\n     */\n    public Node before(String html) {\n        addSiblingHtml(siblingIndex, html);\n        return this;\n    }\n\n    /**\n     * Insert the specified node into the DOM before this node (as a preceding sibling).\n     * @param node to add before this node\n     * @return this node, for chaining\n     * @see #after(Node)\n     */\n    public Node before(Node node) {\n        Validate.notNull(node);\n        Validate.notNull(parentNode);\n\n        // if the incoming node is a sibling of this, remove it first so siblingIndex is correct on add\n        if (node.parentNode == parentNode) node.remove();\n\n        parentNode.addChildren(siblingIndex, node);\n        return this;\n    }\n\n    /**\n     * Insert the specified HTML into the DOM after this node (as a following sibling).\n     * @param html HTML to add after this node\n     * @return this node, for chaining\n     * @see #before(String)\n     */\n    public Node after(String html) {\n        addSiblingHtml(siblingIndex + 1, html);\n        return this;\n    }\n\n    /**\n     * Insert the specified node into the DOM after this node (as a following sibling).\n     * @param node to add after this node\n     * @return this node, for chaining\n     * @see #before(Node)\n     */\n    public Node after(Node node) {\n        Validate.notNull(node);\n        Validate.notNull(parentNode);\n\n        // if the incoming node is a sibling of this, remove it first so siblingIndex is correct on add\n        if (node.parentNode == parentNode) node.remove();\n\n        parentNode.addChildren(siblingIndex + 1, node);\n        return this;\n    }\n\n    private void addSiblingHtml(int index, String html) {\n        Validate.notNull(html);\n        Validate.notNull(parentNode);\n\n        Element context = parentNode instanceof Element ? (Element) parentNode : null;\n        List<Node> nodes = NodeUtils.parser(this).parseFragmentInput(html, context, baseUri());\n        parentNode.addChildren(index, nodes.toArray(new Node[0]));\n    }\n\n    /**\n     Wrap the supplied HTML around this node.\n\n     @param html HTML to wrap around this node, e.g. {@code <div class=\"head\"></div>}. Can be arbitrarily deep. If\n     the input HTML does not parse to a result starting with an Element, this will be a no-op.\n     @return this node, for chaining.\n     */\n    public Node wrap(String html) {\n        Validate.notEmpty(html);\n\n        // Parse context - parent (because wrapping), this, or null\n        Element context =\n            parentNode != null && parentNode instanceof Element ? (Element) parentNode :\n                this instanceof Element ? (Element) this :\n                    null;\n        List<Node> wrapChildren = NodeUtils.parser(this).parseFragmentInput(html, context, baseUri());\n        Node wrapNode = wrapChildren.get(0);\n        if (!(wrapNode instanceof Element)) // nothing to wrap with; noop\n            return this;\n\n        Element wrap = (Element) wrapNode;\n        Element deepest = getDeepChild(wrap);\n        if (parentNode != null)\n            parentNode.replaceChild(this, wrap);\n        deepest.addChildren(this); // side effect of tricking wrapChildren to lose first\n\n        // remainder (unbalanced wrap, like <div></div><p></p> -- The <p> is remainder\n        if (wrapChildren.size() > 0) {\n            //noinspection ForLoopReplaceableByForEach (beacause it allocates an Iterator which is wasteful here)\n            for (int i = 0; i < wrapChildren.size(); i++) {\n                Node remainder = wrapChildren.get(i);\n                // if no parent, this could be the wrap node, so skip\n                if (wrap == remainder)\n                    continue;\n\n                if (remainder.parentNode != null)\n                    remainder.parentNode.removeChild(remainder);\n                wrap.after(remainder);\n            }\n        }\n        return this;\n    }\n\n    /**\n     * Removes this node from the DOM, and moves its children up into the node's parent. This has the effect of dropping\n     * the node but keeping its children.\n     * <p>\n     * For example, with the input html:\n     * </p>\n     * <p>{@code <div>One <span>Two <b>Three</b></span></div>}</p>\n     * Calling {@code element.unwrap()} on the {@code span} element will result in the html:\n     * <p>{@code <div>One Two <b>Three</b></div>}</p>\n     * and the {@code \"Two \"} {@link TextNode} being returned.\n     *\n     * @return the first child of this node, after the node has been unwrapped. @{code Null} if the node had no children.\n     * @see #remove()\n     * @see #wrap(String)\n     */\n    public @Nullable Node unwrap() {\n        Validate.notNull(parentNode);\n        Node firstChild = firstChild();\n        parentNode.addChildren(siblingIndex, this.childNodesAsArray());\n        this.remove();\n\n        return firstChild;\n    }\n\n    private static Element getDeepChild(Element el) {\n        Element child = el.firstElementChild();\n        while (child != null) {\n            el = child;\n            child = child.firstElementChild();\n        }\n        return el;\n    }\n\n    void nodelistChanged() {\n        // Element overrides this to clear its shadow children elements\n    }\n\n    /**\n     * Replace this node in the DOM with the supplied node.\n     * @param in the node that will replace the existing node.\n     */\n    public void replaceWith(Node in) {\n        Validate.notNull(in);\n        Validate.notNull(parentNode);\n        parentNode.replaceChild(this, in);\n    }\n\n    protected void setParentNode(Node parentNode) {\n        Validate.notNull(parentNode);\n        if (this.parentNode != null)\n            this.parentNode.removeChild(this);\n        this.parentNode = parentNode;\n    }\n\n    protected void replaceChild(Node out, Node in) {\n        Validate.isTrue(out.parentNode == this);\n        Validate.notNull(in);\n        if (out == in) return; // no-op self replacement\n\n        if (in.parentNode != null)\n            in.parentNode.removeChild(in);\n\n        final int index = out.siblingIndex;\n        ensureChildNodes().set(index, in);\n        in.parentNode = this;\n        in.setSiblingIndex(index);\n        out.parentNode = null;\n    }\n\n    protected void removeChild(Node out) {\n        Validate.isTrue(out.parentNode == this);\n        final int index = out.siblingIndex;\n        ensureChildNodes().remove(index);\n        reindexChildren(index);\n        out.parentNode = null;\n    }\n\n    protected void addChildren(Node... children) {\n        //most used. short circuit addChildren(int), which hits reindex children and array copy\n        final List<Node> nodes = ensureChildNodes();\n\n        for (Node child: children) {\n            reparentChild(child);\n            nodes.add(child);\n            child.setSiblingIndex(nodes.size()-1);\n        }\n    }\n\n    protected void addChildren(int index, Node... children) {\n        Validate.notNull(children);\n        if (children.length == 0) {\n            return;\n        }\n        final List<Node> nodes = ensureChildNodes();\n\n        // fast path - if used as a wrap (index=0, children = child[0].parent.children - do inplace\n        final Node firstParent = children[0].parent();\n        if (firstParent != null && firstParent.childNodeSize() == children.length) {\n            boolean sameList = true;\n            final List<Node> firstParentNodes = firstParent.ensureChildNodes();\n            // identity check contents to see if same\n            int i = children.length;\n            while (i-- > 0) {\n                if (children[i] != firstParentNodes.get(i)) {\n                    sameList = false;\n                    break;\n                }\n            }\n            if (sameList) { // moving, so OK to empty firstParent and short-circuit\n                boolean wasEmpty = childNodeSize() == 0;\n                firstParent.empty();\n                nodes.addAll(index, Arrays.asList(children));\n                i = children.length;\n                while (i-- > 0) {\n                    children[i].parentNode = this;\n                }\n                if (!(wasEmpty && children[0].siblingIndex == 0)) // skip reindexing if we just moved\n                    reindexChildren(index);\n                return;\n            }\n        }\n\n        Validate.noNullElements(children);\n        for (Node child : children) {\n            reparentChild(child);\n        }\n        nodes.addAll(index, Arrays.asList(children));\n        reindexChildren(index);\n    }\n    \n    protected void reparentChild(Node child) {\n        child.setParentNode(this);\n    }\n\n    private void reindexChildren(int start) {\n        final int size = childNodeSize();\n        if (size == 0) return;\n        final List<Node> childNodes = ensureChildNodes();\n        for (int i = start; i < size; i++) {\n            childNodes.get(i).setSiblingIndex(i);\n        }\n    }\n\n    /**\n     Retrieves this node's sibling nodes. Similar to {@link #childNodes() node.parent.childNodes()}, but does not\n     include this node (a node is not a sibling of itself).\n     @return node siblings. If the node has no parent, returns an empty list.\n     */\n    public List<Node> siblingNodes() {\n        if (parentNode == null)\n            return Collections.emptyList();\n\n        List<Node> nodes = parentNode.ensureChildNodes();\n        List<Node> siblings = new ArrayList<>(nodes.size() - 1);\n        for (Node node: nodes)\n            if (node != this)\n                siblings.add(node);\n        return siblings;\n    }\n\n    /**\n     Get this node's next sibling.\n     @return next sibling, or {@code null} if this is the last sibling\n     */\n    public @Nullable Node nextSibling() {\n        if (parentNode == null)\n            return null; // root\n\n        final List<Node> siblings = parentNode.ensureChildNodes();\n        final int index = siblingIndex+1;\n        if (siblings.size() > index)\n            return siblings.get(index);\n        else\n            return null;\n    }\n\n    /**\n     Get this node's previous sibling.\n     @return the previous sibling, or @{code null} if this is the first sibling\n     */\n    public @Nullable Node previousSibling() {\n        if (parentNode == null)\n            return null; // root\n\n        if (siblingIndex > 0)\n            return parentNode.ensureChildNodes().get(siblingIndex-1);\n        else\n            return null;\n    }\n\n    /**\n     * Get the list index of this node in its node sibling list. E.g. if this is the first node\n     * sibling, returns 0.\n     * @return position in node sibling list\n     * @see org.jsoup.nodes.Element#elementSiblingIndex()\n     */\n    public int siblingIndex() {\n        return siblingIndex;\n    }\n\n    protected void setSiblingIndex(int siblingIndex) {\n        this.siblingIndex = siblingIndex;\n    }\n\n    /**\n     Gets the first child node of this node, or {@code null} if there is none. This could be any Node type, such as an\n     Element, TextNode, Comment, etc. Use {@link Element#firstElementChild()} to get the first Element child.\n     @return the first child node, or null if there are no children.\n     @see Element#firstElementChild()\n     @see #lastChild()\n     @since 1.15.2\n     */\n    public @Nullable Node firstChild() {\n        if (childNodeSize() == 0) return null;\n        return ensureChildNodes().get(0);\n    }\n\n    /**\n     Gets the last child node of this node, or {@code null} if there is none.\n     @return the last child node, or null if there are no children.\n     @see Element#lastElementChild()\n     @see #firstChild()\n     @since 1.15.2\n     */\n    public @Nullable Node lastChild() {\n        final int size = childNodeSize();\n        if (size == 0) return null;\n        List<Node> children = ensureChildNodes();\n        return children.get(size - 1);\n    }\n\n    /**\n     * Perform a depth-first traversal through this node and its descendants.\n     * @param nodeVisitor the visitor callbacks to perform on each node\n     * @return this node, for chaining\n     */\n    public Node traverse(NodeVisitor nodeVisitor) {\n        Validate.notNull(nodeVisitor);\n        NodeTraversor.traverse(nodeVisitor, this);\n        return this;\n    }\n\n    /**\n     Perform the supplied action on this Node and each of its descendants, during a depth-first traversal. Nodes may be\n     inspected, changed, added, replaced, or removed.\n     @param action the function to perform on the node\n     @return this Node, for chaining\n     @see Element#forEach(Consumer)\n     */\n    public Node forEachNode(Consumer<? super Node> action) {\n        Validate.notNull(action);\n        nodeStream().forEach(action);\n        return this;\n    }\n\n    /**\n     * Perform a depth-first filtered traversal through this node and its descendants.\n     * @param nodeFilter the filter callbacks to perform on each node\n     * @return this node, for chaining\n     */\n    public Node filter(NodeFilter nodeFilter) {\n        Validate.notNull(nodeFilter);\n        NodeTraversor.filter(nodeFilter, this);\n        return this;\n    }\n\n    /**\n     Returns a Stream of this Node and all of its descendant Nodes. The stream has document order.\n     @return a stream of all nodes.\n     @see Element#stream()\n     @since 1.17.1\n     */\n    public Stream<Node> nodeStream() {\n        return NodeUtils.stream(this, Node.class);\n    }\n\n    /**\n     Returns a Stream of this and descendant nodes, containing only nodes of the specified type. The stream has document\n     order.\n     @return a stream of nodes filtered by type.\n     @see Element#stream()\n     @since 1.17.1\n     */\n    public <T extends Node> Stream<T> nodeStream(Class<T> type) {\n        return NodeUtils.stream(this, type);\n    }\n\n    /**\n     Get the outer HTML of this node. For example, on a {@code p} element, may return {@code <p>Para</p>}.\n     @return outer HTML\n     @see Element#html()\n     @see Element#text()\n     */\n    public String outerHtml() {\n        StringBuilder accum = StringUtil.borrowBuilder();\n        outerHtml(accum);\n        return StringUtil.releaseBuilder(accum);\n    }\n\n    protected void outerHtml(Appendable accum) {\n        NodeTraversor.traverse(new OuterHtmlVisitor(accum, NodeUtils.outputSettings(this)), this);\n    }\n\n    /**\n     Get the outer HTML of this node.\n     @param accum accumulator to place HTML into\n     @throws IOException if appending to the given accumulator fails.\n     */\n    abstract void outerHtmlHead(final Appendable accum, int depth, final Document.OutputSettings out) throws IOException;\n\n    abstract void outerHtmlTail(final Appendable accum, int depth, final Document.OutputSettings out) throws IOException;\n\n    /**\n     * Write this node and its children to the given {@link Appendable}.\n     *\n     * @param appendable the {@link Appendable} to write to.\n     * @return the supplied {@link Appendable}, for chaining.\n     */\n    public <T extends Appendable> T html(T appendable) {\n        outerHtml(appendable);\n        return appendable;\n    }\n\n    /**\n     Get the source range (start and end positions) in the original input source from which this node was parsed.\n     Position tracking must be enabled prior to parsing the content. For an Element, this will be the positions of the\n     start tag.\n     @return the range for the start of the node, or {@code untracked} if its range was not tracked.\n     @see org.jsoup.parser.Parser#setTrackPosition(boolean)\n     @see Range#isImplicit()\n     @see Element#endSourceRange()\n     @see Attributes#sourceRange(String name)\n     @since 1.15.2\n     */\n    public Range sourceRange() {\n        return Range.of(this, true);\n    }\n\n    /** Test if this node is the first child, or first following blank text. */\n    final boolean isEffectivelyFirst() {\n        if (siblingIndex == 0) return true;\n        if (siblingIndex == 1) {\n            final Node prev = previousSibling();\n            return prev instanceof TextNode && (((TextNode) prev).isBlank());\n        }\n        return false;\n    }\n\n    /**\n     * Gets this node's outer HTML.\n     * @return outer HTML.\n     * @see #outerHtml()\n     */\n\tpublic String toString() {\n        return outerHtml();\n    }\n\n    protected void indent(Appendable accum, int depth, Document.OutputSettings out) throws IOException {\n        accum.append('\\n').append(StringUtil.padding(depth * out.indentAmount(), out.maxPaddingWidth()));\n    }\n\n    /**\n     * Check if this node is the same instance of another (object identity test).\n     * <p>For an node value equality check, see {@link #hasSameValue(Object)}</p>\n     * @param o other object to compare to\n     * @return true if the content of this node is the same as the other\n     * @see Node#hasSameValue(Object)\n     */\n    @Override\n    public boolean equals(@Nullable Object o) {\n        // implemented just so that javadoc is clear this is an identity test\n        return this == o;\n    }\n\n    /**\n     Provides a hashCode for this Node, based on its object identity. Changes to the Node's content will not impact the\n     result.\n     @return an object identity based hashcode for this Node\n     */\n    @Override\n    public int hashCode() {\n        // implemented so that javadoc and scanners are clear this is an identity test\n        return super.hashCode();\n    }\n\n    /**\n     * Check if this node has the same content as another node. A node is considered the same if its name, attributes and content match the\n     * other node; particularly its position in the tree does not influence its similarity.\n     * @param o other object to compare to\n     * @return true if the content of this node is the same as the other\n     */\n    public boolean hasSameValue(@Nullable Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n\n        return this.outerHtml().equals(((Node) o).outerHtml());\n    }\n\n    /**\n     * Create a stand-alone, deep copy of this node, and all of its children. The cloned node will have no siblings or\n     * parent node. As a stand-alone object, any changes made to the clone or any of its children will not impact the\n     * original node.\n     * <p>\n     * The cloned node may be adopted into another Document or node structure using {@link Element#appendChild(Node)}.\n     * @return a stand-alone cloned node, including clones of any children\n     * @see #shallowClone()\n     */\n    @SuppressWarnings(\"MethodDoesntCallSuperMethod\") // because it does call super.clone in doClone - analysis just isn't following\n    @Override\n    public Node clone() {\n        Node thisClone = doClone(null); // splits for orphan\n\n        // Queue up nodes that need their children cloned (BFS).\n        final LinkedList<Node> nodesToProcess = new LinkedList<>();\n        nodesToProcess.add(thisClone);\n\n        while (!nodesToProcess.isEmpty()) {\n            Node currParent = nodesToProcess.remove();\n\n            final int size = currParent.childNodeSize();\n            for (int i = 0; i < size; i++) {\n                final List<Node> childNodes = currParent.ensureChildNodes();\n                Node childClone = childNodes.get(i).doClone(currParent);\n                childNodes.set(i, childClone);\n                nodesToProcess.add(childClone);\n            }\n        }\n\n        return thisClone;\n    }\n\n    /**\n     * Create a stand-alone, shallow copy of this node. None of its children (if any) will be cloned, and it will have\n     * no parent or sibling nodes.\n     * @return a single independent copy of this node\n     * @see #clone()\n     */\n    public Node shallowClone() {\n        return doClone(null);\n    }\n\n    /*\n     * Return a clone of the node using the given parent (which can be null).\n     * Not a deep copy of children.\n     */\n    protected Node doClone(@Nullable Node parent) {\n        Node clone;\n\n        try {\n            clone = (Node) super.clone();\n        } catch (CloneNotSupportedException e) {\n            throw new RuntimeException(e);\n        }\n\n        clone.parentNode = parent; // can be null, to create an orphan split\n        clone.siblingIndex = parent == null ? 0 : siblingIndex;\n        // if not keeping the parent, shallowClone the ownerDocument to preserve its settings\n        if (parent == null && !(this instanceof Document)) {\n            Document doc = ownerDocument();\n            if (doc != null) {\n                Document docClone = doc.shallowClone();\n                clone.parentNode = docClone;\n                docClone.ensureChildNodes().add(clone);\n            }\n        }\n\n        return clone;\n    }\n\n    private static class OuterHtmlVisitor implements NodeVisitor {\n        private final Appendable accum;\n        private final Document.OutputSettings out;\n\n        OuterHtmlVisitor(Appendable accum, Document.OutputSettings out) {\n            this.accum = accum;\n            this.out = out;\n        }\n\n        @Override public void head(Node node, int depth) {\n            try {\n\t\t\t\tnode.outerHtmlHead(accum, depth, out);\n\t\t\t} catch (IOException exception) {\n\t\t\t\tthrow new SerializationException(exception);\n\t\t\t}\n        }\n\n        @Override public void tail(Node node, int depth) {\n            if (!node.nodeName().equals(\"#text\")) { // saves a void hit.\n\t\t\t\ttry {\n\t\t\t\t\tnode.outerHtmlTail(accum, depth, out);\n\t\t\t\t} catch (IOException exception) {\n\t\t\t\t\tthrow new SerializationException(exception);\n\t\t\t\t}\n            }\n        }\n    }\n}", "super_interfaces": ["Cloneable"], "fields": [{"attribute_expression": "static final List<Node> EmptyNodes = Collections.emptyList();", "docstring": "", "modifiers": "static final", "marker_annotations": [], "non_marker_annotations": ["static", "final"], "comments": [], "type": "List<Node>", "name": "EmptyNodes = Collections.emptyList()", "syntax_pass": true}, {"attribute_expression": "static final String EmptyString = \"\";", "docstring": "", "modifiers": "static final", "marker_annotations": [], "non_marker_annotations": ["static", "final"], "comments": [], "type": "String", "name": "EmptyString = \"\"", "syntax_pass": true}, {"attribute_expression": "@Nullable Node parentNode;", "docstring": "", "modifiers": "@Nullable", "marker_annotations": ["@Nullable"], "non_marker_annotations": [], "comments": [], "type": "Node", "name": "parentNode", "syntax_pass": true}, {"attribute_expression": "int siblingIndex;", "docstring": " Nodes don't always have parents", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "int", "name": "siblingIndex", "syntax_pass": true}]}]