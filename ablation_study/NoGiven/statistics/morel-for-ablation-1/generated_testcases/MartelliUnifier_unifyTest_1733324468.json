[{"strategy": "generate", "code": "\npackage net.hydromatic.morel.util;\n\nimport com.google.common.collect.ImmutableMap;\nimport org.checkerframework.checker.nullness.qual.NonNull;\nimport org.junit.jupiter.api.Test;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nclass MartelliUnifier_unifyTest {\n\n    @Test\n    void testUnify_Delete() {\n        MartelliUnifier unifier = new MartelliUnifier();\n        List<TermTerm> termPairs = new ArrayList<>();\n        termPairs.add(new TermTerm(new Variable(\"x\"), new Variable(\"x\")));\n        Map<Variable, Action> termActions = new HashMap<>();\n        Tracer tracer = new Tracer();\n\n        Result result = unifier.unify(termPairs, termActions, tracer);\n\n        assertTrue(termPairs.isEmpty());\n        assertTrue(result instanceof SubstitutionResult);\n        assertEquals(0, ((SubstitutionResult) result).getResult().size());\n    }\n\n    @Test\n    void testUnify_Conflict() {\n        MartelliUnifier unifier = new MartelliUnifier();\n        List<TermTerm> termPairs = new ArrayList<>();\n        termPairs.add(new TermTerm(new Sequence(\"f\", List.of(new Variable(\"x\"))), new Sequence(\"g\", List.of(new Variable(\"y\")))));\n        Map<Variable, Action> termActions = new HashMap<>();\n        Tracer tracer = new Tracer();\n\n        Result result = unifier.unify(termPairs, termActions, tracer);\n\n        assertTrue(result instanceof FailureResult);\n        assertEquals(\"conflict: f(x) vs g(y)\", ((FailureResult) result).getMessage());\n    }\n\n    @Test\n    void testUnify_Swap() {\n        MartelliUnifier unifier = new MartelliUnifier();\n        List<TermTerm> termPairs = new ArrayList<>();\n        termPairs.add(new TermTerm(new Sequence(\"f\", List.of(new Variable(\"x\"))), new Variable(\"y\")));\n        Map<Variable, Action> termActions = new HashMap<>();\n        Tracer tracer = new Tracer();\n\n        Result result = unifier.unify(termPairs, termActions, tracer);\n\n        assertEquals(1, termPairs.size());\n        assertEquals(new TermTerm(new Variable(\"y\"), new Sequence(\"f\", List.of(new Variable(\"x\")))), termPairs.get(0));\n    }\n\n    @Test\n    void testUnify_Cycle() {\n        MartelliUnifier unifier = new MartelliUnifier();\n        List<TermTerm> termPairs = new ArrayList<>();\n        Variable x = new Variable(\"x\");\n        termPairs.add(new TermTerm(x, new Sequence(\"f\", List.of(x))));\n        Map<Variable, Action> termActions = new HashMap<>();\n        Tracer tracer = new Tracer();\n\n        Result result = unifier.unify(termPairs, termActions, tracer);\n\n        assertTrue(result instanceof FailureResult);\n        assertEquals(\"cycle: variable x in f(x)\", ((FailureResult) result).getMessage());\n    }\n\n    @Test\n    void testUnify_Success() {\n        MartelliUnifier unifier = new MartelliUnifier();\n        List<TermTerm> termPairs = new ArrayList<>();\n        termPairs.add(new TermTerm(new Variable(\"x\"), new Sequence(\"f\", List.of(new Variable(\"y\")))));\n        Map<Variable, Action> termActions = new HashMap<>();\n        Tracer tracer = new Tracer();\n\n        Result result = unifier.unify(termPairs, termActions, tracer);\n\n        assertTrue(result instanceof SubstitutionResult);\n        assertEquals(1, ((SubstitutionResult) result).getResult().size());\n        assertEquals(new Sequence(\"f\", List.of(new Variable(\"y\"))), ((SubstitutionResult) result).getResult().get(new Variable(\"x\")));\n    }\n\n    // Mock classes for testing\n    private static class TermTerm {\n        Term left;\n        Term right;\n\n        TermTerm(Term left, Term right) {\n            this.left = left;\n            this.right = right;\n        }\n    }\n\n    private static class Term {\n        String name;\n\n        Term(String name) {\n            this.name = name;\n        }\n\n        boolean contains(Variable variable) {\n            return this.name.equals(variable.name);\n        }\n\n        Term apply(Map<Variable, Term> map) {\n            return this;\n        }\n\n        @Override\n        public boolean equals(Object obj) {\n            if (obj instanceof Term) {\n                return this.name.equals(((Term) obj).name);\n            }\n            return false;\n        }\n\n        @Override\n        public String toString() {\n            return name;\n        }\n    }\n\n    private static class Variable extends Term {\n        Variable(String name) {\n            super(name);\n        }\n    }\n\n    private static class Sequence extends Term {\n        String operator;\n        List<Term> terms;\n\n        Sequence(String operator, List<Term> terms) {\n            super(operator);\n            this.operator = operator;\n            this.terms = terms;\n        }\n\n        @Override\n        public String toString() {\n            return operator + \"(\" + terms.toString().replace(\"[\", \"\").replace(\"]\", \"\") + \")\";\n        }\n    }\n\n    private static class Tracer {\n        void onDelete(Term left, Term right) {}\n        void onConflict(Sequence left, Sequence right) {}\n        void onSwap(Term left, Term right) {}\n        void onCycle(Variable variable, Term term) {}\n        void onVariable(Variable variable, Term term) {}\n        void onSequence(Sequence left, Sequence right) {}\n        void onSubstitute(Term left, Term right, Term left2, Term right2) {}\n    }\n\n    private static class Result {}\n\n    private static class SubstitutionResult extends Result {\n        Map<Variable, Term> result;\n\n        static SubstitutionResult create(Map<Variable, Term> result) {\n            SubstitutionResult sr = new SubstitutionResult();\n            sr.result = result;\n            return sr;\n        }\n\n        Map<Variable, Term> getResult() {\n            return result;\n        }\n    }\n\n    private static class FailureResult extends Result {\n        String message;\n\n        FailureResult(String message) {\n            this.message = message;\n        }\n\n        String getMessage() {\n            return message;\n        }\n    }\n\n    private static Result failure(String message) {\n        return new FailureResult(message);\n    }\n\n    private static class Action {\n        void accept(Variable variable, Term term, Substitution substitution, List<TermTerm> termPairs) {}\n    }\n\n    private static class Substitution {\n        Map<Variable, Term> resultMap;\n\n        Substitution(Map<Variable, Term> resultMap) {\n            this.resultMap = resultMap;\n        }\n    }\n}\n"}]