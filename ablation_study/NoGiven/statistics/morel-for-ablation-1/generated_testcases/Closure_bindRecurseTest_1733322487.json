[{"strategy": "generate", "code": "\npackage net.hydromatic.morel.eval;\n\nimport net.hydromatic.morel.ast.Core;\nimport org.junit.jupiter.api.Test;\n\nimport java.math.BigDecimal;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.function.BiConsumer;\n\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nclass Closure_bindRecurseTest {\n\n    @Test\n    void testBindRecurse_ID_PAT() {\n        Core.IdPat idPat = new Core.IdPat(Core.Op.ID_PAT, \"x\");\n        assertTrue(Closure.bindRecurse(idPat, \"value\", (namedPat, o) -> {}));\n    }\n\n    @Test\n    void testBindRecurse_WILDCARD_PAT() {\n        Core.WildcardPat wildcardPat = new Core.WildcardPat(Core.Op.WILDCARD_PAT);\n        assertTrue(Closure.bindRecurse(wildcardPat, \"value\", (namedPat, o) -> {}));\n    }\n\n    @Test\n    void testBindRecurse_AS_PAT() {\n        Core.AsPat asPat = new Core.AsPat(Core.Op.AS_PAT, new Core.IdPat(Core.Op.ID_PAT, \"x\"), \"alias\");\n        assertTrue(Closure.bindRecurse(asPat, \"value\", (namedPat, o) -> {}));\n    }\n\n    @Test\n    void testBindRecurse_BOOL_LITERAL_PAT() {\n        Core.LiteralPat literalPat = new Core.LiteralPat(Core.Op.BOOL_LITERAL_PAT, true);\n        assertTrue(Closure.bindRecurse(literalPat, true, (namedPat, o) -> {}));\n        assertFalse(Closure.bindRecurse(literalPat, false, (namedPat, o) -> {}));\n    }\n\n    @Test\n    void testBindRecurse_INT_LITERAL_PAT() {\n        Core.LiteralPat literalPat = new Core.LiteralPat(Core.Op.INT_LITERAL_PAT, new BigDecimal(10));\n        assertTrue(Closure.bindRecurse(literalPat, 10, (namedPat, o) -> {}));\n        assertFalse(Closure.bindRecurse(literalPat, 20, (namedPat, o) -> {}));\n    }\n\n    @Test\n    void testBindRecurse_REAL_LITERAL_PAT() {\n        Core.LiteralPat literalPat = new Core.LiteralPat(Core.Op.REAL_LITERAL_PAT, new BigDecimal(10.5));\n        assertTrue(Closure.bindRecurse(literalPat, 10.5, (namedPat, o) -> {}));\n        assertFalse(Closure.bindRecurse(literalPat, 20.5, (namedPat, o) -> {}));\n    }\n\n    @Test\n    void testBindRecurse_TUPLE_PAT() {\n        Core.TuplePat tuplePat = new Core.TuplePat(Core.Op.TUPLE_PAT, Arrays.asList(\n                new Core.LiteralPat(Core.Op.INT_LITERAL_PAT, new BigDecimal(1)),\n                new Core.LiteralPat(Core.Op.INT_LITERAL_PAT, new BigDecimal(2))\n        ));\n        List<Object> listValue = Arrays.asList(1, 2);\n        assertTrue(Closure.bindRecurse(tuplePat, listValue, (namedPat, o) -> {}));\n    }\n\n    @Test\n    void testBindRecurse_LIST_PAT() {\n        Core.ListPat listPat = new Core.ListPat(Core.Op.LIST_PAT, Arrays.asList(\n                new Core.LiteralPat(Core.Op.INT_LITERAL_PAT, new BigDecimal(1)),\n                new Core.LiteralPat(Core.Op.INT_LITERAL_PAT, new BigDecimal(2))\n        ));\n        List<Object> listValue = Arrays.asList(1, 2);\n        assertTrue(Closure.bindRecurse(listPat, listValue, (namedPat, o) -> {}));\n        assertFalse(Closure.bindRecurse(listPat, Arrays.asList(1), (namedPat, o) -> {}));\n    }\n\n    @Test\n    void testBindRecurse_CONS_PAT() {\n        Core.ConPat consPat = new Core.ConPat(Core.Op.CONS_PAT, new Core.TuplePat(Core.Op.TUPLE_PAT, Arrays.asList(\n                new Core.LiteralPat(Core.Op.INT_LITERAL_PAT, new BigDecimal(1)),\n                new Core.ListPat(Core.Op.LIST_PAT, Arrays.asList(\n                        new Core.LiteralPat(Core.Op.INT_LITERAL_PAT, new BigDecimal(2))\n                ))\n        )), \"cons\");\n        List<Object> consValue = Arrays.asList(1, Arrays.asList(2));\n        assertTrue(Closure.bindRecurse(consPat, consValue, (namedPat, o) -> {}));\n        assertFalse(Closure.bindRecurse(consPat, Arrays.asList(), (namedPat, o) -> {}));\n    }\n\n    @Test\n    void testBindRecurse_CON0_PAT() {\n        Core.Con0Pat con0Pat = new Core.Con0Pat(Core.Op.CON0_PAT, \"con0\");\n        List<Object> con0Value = Arrays.asList(\"con0\");\n        assertTrue(Closure.bindRecurse(con0Pat, con0Value, (namedPat, o) -> {}));\n        assertFalse(Closure.bindRecurse(con0Pat, Arrays.asList(\"other\"), (namedPat, o) -> {}));\n    }\n\n    @Test\n    void testBindRecurse_CON_PAT() {\n        Core.ConPat conPat = new Core.ConPat(Core.Op.CON_PAT, new Core.LiteralPat(Core.Op.INT_LITERAL_PAT, new BigDecimal(1)), \"con\");\n        List<Object> conValue = Arrays.asList(\"con\", 1);\n        assertTrue(Closure.bindRecurse(conPat, conValue, (namedPat, o) -> {}));\n        assertFalse(Closure.bindRecurse(conPat, Arrays.asList(\"other\", 1), (namedPat, o) -> {}));\n    }\n\n    @Test\n    void testBindRecurse_DefaultCase() {\n        Core.Pat unknownPat = new Core.Pat(Core.Op.UNKNOWN_OP) {};\n        assertThrows(AssertionError.class, () -> Closure.bindRecurse(unknownPat, \"value\", (namedPat, o) -> {}));\n    }\n}\n"}]