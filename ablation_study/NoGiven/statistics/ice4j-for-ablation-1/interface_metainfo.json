[{"uris": "src/test/java/test/signalling/SignallingCallback.java.SignallingCallback", "name": "SignallingCallback", "file_path": "src/test/java/test/signalling/SignallingCallback.java", "superclasses": [], "methods": ["[void]onSignalling(String)"], "method_uris": ["src/test/java/test/signalling/SignallingCallback.java.SignallingCallback.[void]onSignalling(String)"], "overrides": null, "attributes": null, "class_docstring": "\nA simple signalling callback interface where we deliever newly received\nsignalling from the {@link Signalling}\n\n@author Emil Ivov\n", "original_string": "public interface SignallingCallback\n{\n    /**\n     * Processes the specified signalling string\n     *\n     * @param signalling the signalling string to process\n     */\n    public void onSignalling(String signalling);\n}"}, {"uris": "src/main/java/org/ice4j/ResponseCollector.java.ResponseCollector", "name": "ResponseCollector", "file_path": "src/main/java/org/ice4j/ResponseCollector.java", "superclasses": [], "methods": ["[void]processResponse(StunResponseEvent)", "[void]processTimeout(StunTimeoutEvent)"], "method_uris": ["src/main/java/org/ice4j/ResponseCollector.java.ResponseCollector.[void]processResponse(StunResponseEvent)", "src/main/java/org/ice4j/ResponseCollector.java.ResponseCollector.[void]processTimeout(StunTimeoutEvent)"], "overrides": null, "attributes": null, "class_docstring": "\nThe interface is used as a callback when sending a request. The response\ncollector is then used as a means of dispatching the response.\n\n@author Emil Ivov\n", "original_string": "public interface ResponseCollector\n{\n    /**\n     * Dispatch the specified response.\n     *\n     * @param event the response to dispatch.\n     */\n    public void processResponse(StunResponseEvent event);\n\n    /**\n     * Notifies this collector that no response had been received after repeated\n     * retransmissions of the original request (as described by rfc3489) and\n     * that the request should be considered unanswered.\n     *\n     * @param event the <tt>StunTimeoutEvent</tt> containing a reference to the\n     * transaction that has just failed.\n     */\n    public void processTimeout(StunTimeoutEvent event);\n}"}, {"uris": "src/main/java/org/ice4j/stack/MessageEventHandler.java.MessageEventHandler", "name": "MessageEventHandler", "file_path": "src/main/java/org/ice4j/stack/MessageEventHandler.java", "superclasses": [], "methods": ["[void]handleMessageEvent(StunMessageEvent)"], "method_uris": ["src/main/java/org/ice4j/stack/MessageEventHandler.java.MessageEventHandler.[void]handleMessageEvent(StunMessageEvent)"], "overrides": null, "attributes": null, "class_docstring": "\nThe class is used for collecting incoming STUN messages from the\nNetAccessManager (and more precisely - MessageProcessors). This is our\nway of keeping scalable network and stun layers.\n\n@author Emil Ivov\n", "original_string": "public interface MessageEventHandler\n{\n    /**\n     * Called when an incoming message has been received, parsed and is ready\n     * for delivery.\n     * @param evt the Event object that encapsulates the newly received message.\n     */\n    public void handleMessageEvent(StunMessageEvent evt);\n}"}, {"uris": "src/main/java/org/ice4j/stack/ChannelDataEventHandler.java.ChannelDataEventHandler", "name": "ChannelDataEventHandler", "file_path": "src/main/java/org/ice4j/stack/ChannelDataEventHandler.java", "superclasses": [], "methods": ["[void]handleMessageEvent(ChannelDataMessageEvent)"], "method_uris": ["src/main/java/org/ice4j/stack/ChannelDataEventHandler.java.ChannelDataEventHandler.[void]handleMessageEvent(ChannelDataMessageEvent)"], "overrides": null, "attributes": null, "class_docstring": "\nThe interface is used for collecting incoming ChannelData messages from the\nNetAccessManager (and more precisely - MessageProcessors). This is our way of\nkeeping scalable network and stun layers.\n\n@author Aakash Garg\n", "original_string": "public interface ChannelDataEventHandler\n{\n    /**\n     * Called when an incoming Channel Data message has been received, parsed\n     * and is ready for delivery.\n     * \n     * @param messageEvent the event object that encapsulates the newly received\n     *                     message.\n     */\n    public void handleMessageEvent(ChannelDataMessageEvent messageEvent);\n}"}, {"uris": "src/main/java/org/ice4j/stack/PacketLogger.java.PacketLogger", "name": "PacketLogger", "file_path": "src/main/java/org/ice4j/stack/PacketLogger.java", "superclasses": [], "methods": ["[void]logPacket(byte[],int,byte[],int,byte[],boolean)", "[boolean]isEnabled()"], "method_uris": ["src/main/java/org/ice4j/stack/PacketLogger.java.PacketLogger.[void]logPacket(byte[],int,byte[],int,byte[],boolean)", "src/main/java/org/ice4j/stack/PacketLogger.java.PacketLogger.[boolean]isEnabled()"], "overrides": null, "attributes": null, "class_docstring": "\nThe interface which interested implementers will use in order\nto track and log packets send and received by this stack.\n\n@author Damian Minkov\n", "original_string": "public interface PacketLogger\n{\n    /**\n     * Logs a incoming or outgoing packet.\n     *\n     * @param sourceAddress the source address of the packet.\n     * @param sourcePort the source port.\n     * @param destinationAddress the destination address of the packet.\n     * @param destinationPort the destination port.\n     * @param packetContent the content of the packet.\n     * @param sender whether we are sending or not the packet.\n     */\n    public void logPacket(\n            byte[] sourceAddress,\n            int sourcePort,\n            byte[] destinationAddress,\n            int destinationPort,\n            byte[] packetContent,\n            boolean sender);\n\n    /**\n     * Checks whether the logger is enabled. \n     * @return <tt>true</tt> if the logger is enabled, <tt>false</tt>\n     *  otherwise.\n     */\n    public boolean isEnabled();\n}"}, {"uris": "src/main/java/org/ice4j/stack/PeerUdpMessageEventHandler.java.PeerUdpMessageEventHandler", "name": "PeerUdpMessageEventHandler", "file_path": "src/main/java/org/ice4j/stack/PeerUdpMessageEventHandler.java", "superclasses": [], "methods": ["[void]handleMessageEvent(PeerUdpMessageEvent)"], "method_uris": ["src/main/java/org/ice4j/stack/PeerUdpMessageEventHandler.java.PeerUdpMessageEventHandler.[void]handleMessageEvent(PeerUdpMessageEvent)"], "overrides": null, "attributes": null, "class_docstring": "\nThe interface is used for collecting incoming Peer UDP Message messages from\nthe NetAccessManager (and more precisely - MessageProcessors) if it is of no\nother type. This is our way of keeping scalable network and stun layers.\n\n@author Aakash Garg\n", "original_string": "public interface PeerUdpMessageEventHandler\n{\n    /**\n     * Called when an incoming Peer UDP message has been received, parsed\n     * and is ready for delivery.\n     * \n     * @param messageEvent the event object that encapsulates the newly received\n     *                     message.\n     */\n    public void handleMessageEvent(PeerUdpMessageEvent messageEvent);\n}"}, {"uris": "src/main/java/org/ice4j/stack/ErrorHandler.java.ErrorHandler", "name": "ErrorHandler", "file_path": "src/main/java/org/ice4j/stack/ErrorHandler.java", "superclasses": [], "methods": ["[void]handleError(String,Throwable)", "[void]handleFatalError(Runnable,String,Throwable)"], "method_uris": ["src/main/java/org/ice4j/stack/ErrorHandler.java.ErrorHandler.[void]handleError(String,Throwable)", "src/main/java/org/ice4j/stack/ErrorHandler.java.ErrorHandler.[void]handleFatalError(Runnable,String,Throwable)"], "overrides": null, "attributes": null, "class_docstring": "\nGeneric Error Handler.\n\n@author Emil Ivov\n", "original_string": "interface ErrorHandler\n{\n    /**\n     * Called when an error has occurred which may have caused data loss but the\n     * calling thread is still running.\n     *\n     * @param message A message describing the error\n     * @param error   The error itself.\n     */\n    public void handleError(String message, Throwable error);\n\n    /**\n     * Called when a fatal error has occurred and the calling thread will exit.\n     *\n     * @param callingThread the thread where the error has occurred\n     * @param message       a message describing the error.\n     * @param error         the error itself.\n     */\n    public void handleFatalError(Runnable callingThread,\n                                 String message,\n                                 Throwable error);\n}"}, {"uris": "src/main/java/org/ice4j/stack/RequestListener.java.RequestListener", "name": "RequestListener", "file_path": "src/main/java/org/ice4j/stack/RequestListener.java", "superclasses": [], "methods": ["[void]processRequest(StunMessageEvent)"], "method_uris": ["src/main/java/org/ice4j/stack/RequestListener.java.RequestListener.[void]processRequest(StunMessageEvent)"], "overrides": null, "attributes": null, "class_docstring": "\nHandles incoming requests.\n\n@author Emil Ivov\n", "original_string": "public interface RequestListener\n{\n    /**\n     * Called when delivering incoming STUN requests. Throwing an\n     * {@link IllegalArgumentException} from within this method would cause the\n     * stack to reply with a <tt>400 Bad Request</tt> {@link Response} using\n     * the exception's message as a reason phrase for the error response. Any\n     * other exception would result in a <tt>500 Server Error</tt> {@link\n     * Response}.\n     *\n     * @param evt the event containing the incoming STUN request.\n     *\n     * @throws IllegalArgumentException if <tt>evt</tt> contains a malformed\n     * {@link Request} and the stack would need to response with a\n     * <tt>400 Bad Request</tt> {@link Response}.\n     */\n    public void processRequest(StunMessageEvent evt)\n        throws IllegalArgumentException;\n}"}, {"uris": "src/main/java/org/ice4j/attribute/ContentDependentAttribute.java.ContentDependentAttribute", "name": "ContentDependentAttribute", "file_path": "src/main/java/org/ice4j/attribute/ContentDependentAttribute.java", "superclasses": [], "methods": ["[byte[]]encode(StunStack,byte[],int,int)"], "method_uris": ["src/main/java/org/ice4j/attribute/ContentDependentAttribute.java.ContentDependentAttribute.[byte[]]encode(StunStack,byte[],int,int)"], "overrides": null, "attributes": null, "class_docstring": "\n<tt>ContentDependentAttribute</tt>s have a value that depend on the content\nof the message. The {@link MessageIntegrityAttribute} and {@link\nFingerprintAttribute} are two such attributes.\n<p>\nRather than encoding them via the standard {@link Attribute#encode()} method,\nthe stack would use the one from this interface.\n</p>\n\n@author Emil Ivov\n", "original_string": "public interface ContentDependentAttribute\n{\n    /**\n     * Returns a binary representation of this attribute.\n     *\n     * @param stunStack the <tt>StunStack</tt> in the context of which the\n     * request to encode this <tt>ContentDependentAttribute</tt> is being made\n     * @param content the content of the message that this attribute will be\n     * transported in\n     * @param offset the <tt>content</tt>-related offset where the actual\n     * content starts.\n     * @param length the length of the content in the <tt>content</tt> array.\n     *\n     * @return a binary representation of this attribute valid for the message\n     * with the specified <tt>content</tt>.\n     */\n    public byte[] encode(\n            StunStack stunStack,\n            byte[] content, int offset, int length);\n}"}, {"uris": "src/main/java/org/ice4j/security/CredentialsAuthority.java.CredentialsAuthority", "name": "CredentialsAuthority", "file_path": "src/main/java/org/ice4j/security/CredentialsAuthority.java", "superclasses": [], "methods": ["[byte[]]getLocalKey(String)", "[byte[]]getRemoteKey(String,String)", "[boolean]checkLocalUserName(String)"], "method_uris": ["src/main/java/org/ice4j/security/CredentialsAuthority.java.CredentialsAuthority.[byte[]]getLocalKey(String)", "src/main/java/org/ice4j/security/CredentialsAuthority.java.CredentialsAuthority.[byte[]]getRemoteKey(String,String)", "src/main/java/org/ice4j/security/CredentialsAuthority.java.CredentialsAuthority.[boolean]checkLocalUserName(String)"], "overrides": null, "attributes": null, "class_docstring": "\nThe {@link CredentialsAuthority} interface is implemented by applications\nin order to allow the stack to verify the integrity of incoming messages\ncontaining the <tt>MessageIntegrityAttribute</tt>.\n\n@author Emil Ivov\n", "original_string": "public interface CredentialsAuthority\n{\n    /**\n     * Returns the key (password) that corresponds to the specified local\n     * username or user frag,  an empty array if there was no password for that\n     * username or <tt>null</tt> if the username is not a local user name\n     * recognized by this <tt>CredentialsAuthority</tt>.\n     *\n     * @param username the local user name or user frag whose credentials we'd\n     * like to obtain.\n     *\n     * @return the key (password) that corresponds to the specified local\n     * username or user frag,  an empty array if there was no password for that\n     * username or <tt>null</tt> if the username is not a local user name\n     * recognized by this <tt>CredentialsAuthority</tt>.\n     */\n    public byte[] getLocalKey(String username);\n\n    /**\n     * Returns the key (password) that corresponds to the specified remote\n     * username or user frag,  an empty array if there was no password for that\n     * username or <tt>null</tt> if the username is not a remote user name\n     * recognized by this <tt>CredentialsAuthority</tt>.\n     *\n     * @param username the remote user name or user frag whose credentials we'd\n     * like to obtain.\n     * @param media the media name that we want to get remote key.\n     *\n     * @return the key (password) that corresponds to the specified remote\n     * username or user frag,  an empty array if there was no password for that\n     * username or <tt>null</tt> if the username is not a remote user name\n     * recognized by this <tt>CredentialsAuthority</tt>.\n     */\n    public byte[] getRemoteKey(String username, String media);\n\n    /**\n     * Verifies whether <tt>username</tt> is currently known to this authority\n     * and returns <tt>true</tt> if so. Returns <tt>false</tt> otherwise.\n     *\n     * @param username the user name whose validity we'd like to check.\n     *\n     * @return <tt>true</tt> if <tt>username</tt> is known to this\n     * <tt>CredentialsAuthority</tt> and <tt>false</tt> otherwise.\n     */\n    public boolean checkLocalUserName(String username);\n}"}, {"uris": "src/main/java/org/ice4j/pseudotcp/IPseudoTcpNotify.java.IPseudoTcpNotify", "name": "IPseudoTcpNotify", "file_path": "src/main/java/org/ice4j/pseudotcp/IPseudoTcpNotify.java", "superclasses": [], "methods": ["[void]OnTcpOpen(PseudoTCPBase)", "[void]OnTcpReadable(PseudoTCPBase)", "[void]OnTcpWriteable(PseudoTCPBase)", "[void]OnTcpClosed(PseudoTCPBase,IOException)", "[WriteResult]TcpWritePacket(PseudoTCPBase,byte[],int)"], "method_uris": ["src/main/java/org/ice4j/pseudotcp/IPseudoTcpNotify.java.IPseudoTcpNotify.[void]OnTcpOpen(PseudoTCPBase)", "src/main/java/org/ice4j/pseudotcp/IPseudoTcpNotify.java.IPseudoTcpNotify.[void]OnTcpReadable(PseudoTCPBase)", "src/main/java/org/ice4j/pseudotcp/IPseudoTcpNotify.java.IPseudoTcpNotify.[void]OnTcpWriteable(PseudoTCPBase)", "src/main/java/org/ice4j/pseudotcp/IPseudoTcpNotify.java.IPseudoTcpNotify.[void]OnTcpClosed(PseudoTCPBase,IOException)", "src/main/java/org/ice4j/pseudotcp/IPseudoTcpNotify.java.IPseudoTcpNotify.[WriteResult]TcpWritePacket(PseudoTCPBase,byte[],int)"], "overrides": null, "attributes": null, "class_docstring": "\nNotification of tcp events.\nIs implemented by @link(PseudoTcpSocket) to expose stream functionality.\n@author Pawel Domas\n", "original_string": "interface IPseudoTcpNotify\n{\n    /**\n     * Called when tcp enters opened state\n     * @param tcp \n     */\n    void OnTcpOpen(PseudoTCPBase tcp);\n\n    /**\n     * Called when any data is available in read buffer\n     * @param tcp \n     */\n    void OnTcpReadable(PseudoTCPBase tcp);\n\n    /**\n     * Called when there is free space available in the send buffer\n     * @param tcp \n     */\n    void OnTcpWriteable(PseudoTCPBase tcp);\n\n    /**\n     * Called when tcp enters closed state\n     * @param tcp\n     * @param e null means no error\n     */\n    void OnTcpClosed(PseudoTCPBase tcp, IOException e);\n\n    /**\n     * Called when protocol requests packet transfer through the network.\n     * @param tcp\n     * @param buffer data\n     * @param len data length\n     * @return the result, see {@link WriteResult} description for more info\n     */    \n    WriteResult TcpWritePacket(PseudoTCPBase tcp, byte[] buffer, int len);\n}"}, {"uris": "src/main/java/org/ice4j/pseudotcp/PseudoTcpNotify.java.PseudoTcpNotify", "name": "PseudoTcpNotify", "file_path": "src/main/java/org/ice4j/pseudotcp/PseudoTcpNotify.java", "superclasses": [], "methods": ["[void]onTcpOpen(PseudoTCPBase)", "[void]onTcpReadable(PseudoTCPBase)", "[void]onTcpWriteable(PseudoTCPBase)", "[void]onTcpClosed(PseudoTCPBase,IOException)", "[WriteResult]tcpWritePacket(PseudoTCPBase,byte[],int)"], "method_uris": ["src/main/java/org/ice4j/pseudotcp/PseudoTcpNotify.java.PseudoTcpNotify.[void]onTcpOpen(PseudoTCPBase)", "src/main/java/org/ice4j/pseudotcp/PseudoTcpNotify.java.PseudoTcpNotify.[void]onTcpReadable(PseudoTCPBase)", "src/main/java/org/ice4j/pseudotcp/PseudoTcpNotify.java.PseudoTcpNotify.[void]onTcpWriteable(PseudoTCPBase)", "src/main/java/org/ice4j/pseudotcp/PseudoTcpNotify.java.PseudoTcpNotify.[void]onTcpClosed(PseudoTCPBase,IOException)", "src/main/java/org/ice4j/pseudotcp/PseudoTcpNotify.java.PseudoTcpNotify.[WriteResult]tcpWritePacket(PseudoTCPBase,byte[],int)"], "overrides": null, "attributes": null, "class_docstring": "\nNotification of tcp events.\nIs implemented by <tt>PseudoTcpSocketImpl</tt> to expose stream functionality.\n\n@author Pawel Domas\n", "original_string": "public interface PseudoTcpNotify\n{\n    /**\n     * Called when TCP enters opened state\n     * @param tcp the socket that was opened\n     */\n    void onTcpOpen(PseudoTCPBase tcp);\n\n    /**\n     * Called when any data is available in read buffer\n     * @param tcp the socket that became readable\n     */\n    void onTcpReadable(PseudoTCPBase tcp);\n\n    /**\n     * Called when there is free space available in the send buffer\n     * @param tcp the socket that became writable\n     */\n    void onTcpWriteable(PseudoTCPBase tcp);\n\n    /**\n     * Called when tcp enters closed state\n     * @param tcp the socket that was closed\n     * @param e null means no error\n     */\n    void onTcpClosed(PseudoTCPBase tcp, IOException e);\n\n    /**\n     * Called when protocol requests packet transfer through the network.\n     * @param tcp the socket on which the write occurred\n     * @param buffer the data that was written\n     * @param len data length\n     * @return the result, see {@link WriteResult} description for more info\n     */\n    WriteResult tcpWritePacket(PseudoTCPBase tcp, byte[] buffer, int len);\n}"}, {"uris": "src/main/java/org/ice4j/ice/harvest/TrickleCallback.java.TrickleCallback", "name": "TrickleCallback", "file_path": "src/main/java/org/ice4j/ice/harvest/TrickleCallback.java", "superclasses": [], "methods": ["[void]onIceCandidates(Collection<LocalCandidate>)"], "method_uris": ["src/main/java/org/ice4j/ice/harvest/TrickleCallback.java.TrickleCallback.[void]onIceCandidates(Collection<LocalCandidate>)"], "overrides": null, "attributes": null, "class_docstring": "\nWe use this callback to feed candidates to ice4j user applications that\nsupport trickle ICE. The interface provides two methods that allow passing\ncandidates to applications either one-by-one or in batches. The former would\ntypically be used for harvesters such as STUN, where candidates are learned\none per message. Discovering batches of candidates is possible when querying\na TURN server, which in many cases would return both server reflexive (STUN)\nand relayed (TURN) candidates.\n\n@author Emil Ivov\n", "original_string": "public interface TrickleCallback\n{\n\n    /**\n     * Notifies the callback that a new batch of <tt>LocalCandidate</tt>s has\n     * been discovered and should be advertised to the remove party.\n     *\n     * @param iceCandidates the newly discovered list of candidates or,\n     * similarly to WebRTC, <tt>null</tt> in case all candidate harvesting is\n     * now completed.\n     */\n    public void onIceCandidates(Collection<LocalCandidate> iceCandidates);\n\n    /**\n     * Notifies the callback that harvesting has completed for a specific\n     * stream. This may allow for optimizations in cases where all checks for\n     * a specific stream have failed and no candidate has been found, so a\n     * failure is due and we wouldn't won't to waist any more time.\n     *\n     * @param stream the {@link IceMediaStream}, for which we have just\n     * completed harvesting.\n     */\n    // we don't currently support this but we might do it one day.\n    //public void streamCompleted(IceMediaStream stream);\n}"}, {"uris": "src/main/java/org/ice4j/ice/harvest/CandidateHarvester.java.CandidateHarvester", "name": "CandidateHarvester", "file_path": "src/main/java/org/ice4j/ice/harvest/CandidateHarvester.java", "superclasses": [], "methods": ["[Collection<LocalCandidate>]harvest(Component)", "[HarvestStatistics]getHarvestStatistics()", "[boolean]isHostHarvester()"], "method_uris": ["src/main/java/org/ice4j/ice/harvest/CandidateHarvester.java.CandidateHarvester.[Collection<LocalCandidate>]harvest(Component)", "src/main/java/org/ice4j/ice/harvest/CandidateHarvester.java.CandidateHarvester.[HarvestStatistics]getHarvestStatistics()", "src/main/java/org/ice4j/ice/harvest/CandidateHarvester.java.CandidateHarvester.[boolean]isHostHarvester()"], "overrides": null, "attributes": null, "class_docstring": "\nA <tt>CandidateHarvester</tt> gathers a certain kind of <tt>Candidate</tt>s\n(e.g. host, reflexive, or relayed) for a specified {@link\norg.ice4j.ice.Component}.\n\n@author Emil Ivov\n@author Lyubomir Marinov\n@author Boris Grozev\n", "original_string": "public interface CandidateHarvester\n{\n    /**\n     * Gathers all candidate addresses of the type that this\n     * <tt>CandidateHarvester</tt> supports. The gathered candidate addresses\n     * are to be added by this <tt>CandidateHarvester</tt> to the specified\n     * <tt>Component</tt> using\n     * {@link Component#addLocalCandidate(LocalCandidate)} as soon as they are\n     * discovered.\n     *\n     * @param component the {@link Component} that we'd like to gather candidate\n     * addresses for.\n     * @return  the <tt>LocalCandidate</tt>s gathered by this\n     * <tt>CandidateHarvester</tt>. Though they are to be added by this\n     * <tt>CandidateHarvester</tt> to the specified <tt>component</tt> as soon\n     * as they are discovered, they should also be returned in order to make\n     * sure that the gathering will be considered successful.\n     */\n    Collection<LocalCandidate> harvest(Component component);\n\n    /**\n     * Returns the statistics describing how well the various harvests of this\n     * harvester went.\n     *\n     * @return The {@link HarvestStatistics} describing this harvester's\n     * harvests.\n     */\n    HarvestStatistics getHarvestStatistics();\n\n    /**\n     * Returns <tt>true</tt> if this <tt>CandidateHarvester</tt> is to be\n     * considered a harvester for host candidates. Such a harvester should\n     * 1. Create local candidates of type <tt>HOST_CANDIDATE</tt>.\n     * 2. Not depend on other local candidates, already harvested for the\n     *      component for which it is called.\n     * 3. Not perform blocking operations while harvesting.\n     *\n     * @return <tt>true</tt> if this <tt>CandidateHarvester</tt> is a harvester\n     * for host candidates.\n     */\n    boolean isHostHarvester();\n}"}, {"uris": "src/main/java/org/ice4j/socket/MultiplexedXXXSocket.java.MultiplexedXXXSocket", "name": "MultiplexedXXXSocket", "file_path": "src/main/java/org/ice4j/socket/MultiplexedXXXSocket.java", "superclasses": [], "methods": ["[DatagramPacketFilter]getFilter()"], "method_uris": ["src/main/java/org/ice4j/socket/MultiplexedXXXSocket.java.MultiplexedXXXSocket.[DatagramPacketFilter]getFilter()"], "overrides": null, "attributes": null, "class_docstring": "\nDefines the application programming interface (API) expected of pseudo\nsockets which are in fact {@code DatagramPacket}-based views of actual\nsockets.\n\n@author Lyubomir Marinov\n", "original_string": "interface MultiplexedXXXSocket\n{\n    /**\n     * Gets the {@code DatagramPacketFilter} which determines which\n     * {@code DatagramPacket}s read from the network are to be received through\n     * this socket.\n     *\n     * @return the {@code DatagramPacketFilter} which determines which\n     * {@code DatagramPacket}s read from the network are to be received through\n     * this socket\n     */\n    DatagramPacketFilter getFilter();\n}"}, {"uris": "src/main/java/org/ice4j/socket/DatagramSocketFactory.java.DatagramSocketFactory", "name": "DatagramSocketFactory", "file_path": "src/main/java/org/ice4j/socket/DatagramSocketFactory.java", "superclasses": [], "methods": ["[DatagramSocket]createUnboundDatagramSocket()"], "method_uris": ["src/main/java/org/ice4j/socket/DatagramSocketFactory.java.DatagramSocketFactory.[DatagramSocket]createUnboundDatagramSocket()"], "overrides": null, "attributes": null, "class_docstring": "\nClasses implementing this interface follow the factory pattern, generating\nDatagramSocket objects for use by other classes in the stack.\n\nBy extending this interface and using the method\nDelegatingDatagramSocket#setDefaultDelegateFactory()\nit is possible for the application developer to ensure their own variety\nof DatagramSocket is used by the ice4j stack and passed back to their\napplication when the ICE protocol is completed.\n\n@author Daniel Pocock\n@author Vincent Lucas\n", "original_string": "public interface DatagramSocketFactory\n{\n    /**\n     * Creates an unbound DatagramSocket:\n     * - i.e <tt>return new DatagramSocket((SocketAddress) null)</tt>.\n     *\n     * @return An unbound DatagramSocket.\n     *\n     * @throws SocketException if the socket could not be opened.\n     */\n    public DatagramSocket createUnboundDatagramSocket()\n        throws SocketException;\n}"}, {"uris": "src/main/java/org/ice4j/socket/DatagramPacketFilter.java.DatagramPacketFilter", "name": "DatagramPacketFilter", "file_path": "src/main/java/org/ice4j/socket/DatagramPacketFilter.java", "superclasses": [], "methods": ["[boolean]accept(DatagramPacket)"], "method_uris": ["src/main/java/org/ice4j/socket/DatagramPacketFilter.java.DatagramPacketFilter.[boolean]accept(DatagramPacket)"], "overrides": null, "attributes": null, "class_docstring": "\nRepresents a filter which selects or deselects <tt>DatagramPacket</tt>s.\n\n@author Lubomir Marinov\n", "original_string": "public interface DatagramPacketFilter\n{\n    /**\n     * Determines whether a specific <tt>DatagramPacket</tt> is accepted by this\n     * filter i.e. whether the caller should include the specified\n     * <tt>DatagramPacket</tt> in a selection based on this filter.\n     *\n     * @param p the <tt>DatagramPacket</tt> which is to be checked whether it is\n     * accepted by this filter\n     * @return <tt>true</tt> if this filter accepts the specified\n     * <tt>DatagramPacket</tt> i.e. if the caller should include the specified\n     * <tt>DatagramPacket</tt> in a selection based on this filter; otherwise,\n     * <tt>false</tt>\n     */\n    public boolean accept(DatagramPacket p);\n}"}]